extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 20 "include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
#line 40
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 44 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
struct v4l2_format;
#line 68
struct i2c_adapter;
#line 77
struct v4l2_control;
#line 101
struct v4l2_ext_controls;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_220 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_220 __annonCompField58 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 34 "./arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 54 "include/linux/delay.h"
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 61 "include/linux/delay.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 1084 "include/linux/of.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 82 "include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 39 "include/linux/i2c.h"
struct i2c_algorithm;
#line 40
struct i2c_client;
#line 43
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 196 "include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client * , enum i2c_slave_event  , u8 * ) ;
};
#line 251
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
} ;
#line 359 "include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
   int (*reg_slave)(struct i2c_client * ) ;
   int (*unreg_slave)(struct i2c_client * ) ;
};
#line 411 "include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter * ) ;
   int (*get_scl)(struct i2c_adapter * ) ;
   void (*set_scl)(struct i2c_adapter * , int  ) ;
   int (*get_sda)(struct i2c_adapter * ) ;
   void (*prepare_recovery)(struct i2c_adapter * ) ;
   void (*unprepare_recovery)(struct i2c_adapter * ) ;
   int scl_gpio ;
   int sda_gpio ;
};
#line 451 "include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};
#line 481 "include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks  const  *quirks ;
};
#line 242 "include/linux/freezer.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 571 "./include/uapi/linux/v4l2-common.h"
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 643
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 651 "./include/uapi/linux/v4l2-common.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 370 "include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 375 "include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 396 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
   __u32 flags ;
   __u32 ycbcr_enc ;
   __u32 quantization ;
   __u32 xfer_func ;
};
#line 450 "include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 640 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 653 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 662 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_222 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 662 "include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion____missing_field_name_222 __annonCompField59 ;
   __u32 reserved[2U] ;
};
#line 681 "include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 690 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_223 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 690 "include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion____missing_field_name_223 __annonCompField60 ;
   __u32 reserved[2U] ;
};
#line 705 "include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 719 "include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 748 "include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 773 "include/uapi/linux/videodev2.h"
union __anonunion_m_224 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 773 "include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_224 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 805 "include/uapi/linux/videodev2.h"
union __anonunion_m_225 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 805 "include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_225 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 858 "include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct __anonstruct_fmt_226 {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct __anonstruct_fmt_226 fmt ;
};
#line 940 "include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 962 "include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 972 "include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 984 "include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 997 "include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 1007 "include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 1012 "include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 1039 "include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1175 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_227 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion____missing_field_name_227 __annonCompField61 ;
};
#line 1299 "include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1317 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_228 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion____missing_field_name_228 __annonCompField62 ;
};
#line 1365 "include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1381 "include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1429 "include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1447 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_229 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
   __u8 *p_u8 ;
   __u16 *p_u16 ;
   __u32 *p_u32 ;
   void *ptr ;
};
#line 1447 "include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion____missing_field_name_229 __annonCompField63 ;
};
#line 1462 "include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1486 "include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1506 "include/uapi/linux/videodev2.h"
struct v4l2_query_ext_ctrl {
   __u32 id ;
   __u32 type ;
   char name[32U] ;
   __s64 minimum ;
   __s64 maximum ;
   __u64 step ;
   __s64 default_value ;
   __u32 flags ;
   __u32 elem_size ;
   __u32 elems ;
   __u32 nr_of_dims ;
   __u32 dims[4U] ;
   __u32 reserved[32U] ;
};
#line 1523 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_230 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1523 "include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion____missing_field_name_230 __annonCompField64 ;
   __u32 reserved ;
};
#line 1534 "include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1573 "include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1583 "include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1622 "include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1637 "include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1658 "include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1680 "include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1695 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1714 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_232 {
   __u32 data[8U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_231 {
   struct __anonstruct_raw_232 raw ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_231 __annonCompField65 ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_stop_234 {
   __u64 pts ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_start_235 {
   __s32 speed ;
   __u32 format ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_236 {
   __u32 data[16U] ;
};
#line 1741 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_233 {
   struct __anonstruct_stop_234 stop ;
   struct __anonstruct_start_235 start ;
   struct __anonstruct_raw_236 raw ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_233 __annonCompField66 ;
};
#line 1790 "include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1810 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1838 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1862 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1917 "include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u32 bytesperline ;
   __u16 reserved[6U] ;
};
#line 1934 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 flags ;
   __u8 ycbcr_enc ;
   __u8 quantization ;
   __u8 xfer_func ;
   __u8 reserved[7U] ;
};
#line 1964 "include/uapi/linux/videodev2.h"
struct v4l2_sdr_format {
   __u32 pixelformat ;
   __u32 buffersize ;
   __u8 reserved[24U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
union __anonunion_fmt_238 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   struct v4l2_sdr_format sdr ;
   __u8 raw_data[200U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_238 fmt ;
};
#line 1998 "include/uapi/linux/videodev2.h"
union __anonunion_parm_239 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1998 "include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_239 parm ;
};
#line 2089 "include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_242 {
   __u32 addr ;
   char name[32U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion____missing_field_name_242 __annonCompField69 ;
};
#line 2125 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 2132 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 2143 "include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 2165 "include/uapi/linux/videodev2.h"
struct tuner_setup {
   unsigned short addr ;
   unsigned int type ;
   unsigned int mode_mask ;
   void *config ;
   int (*tuner_callback)(void * , int  , int  , int  ) ;
};
#line 205 "include/media/tuner.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_243 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_243 __annonCompField70 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38
struct kiocb;
#line 54 "include/uapi/linux/net.h"
struct poll_table_struct;
#line 55
struct net;
#line 72
struct fasync_struct;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_244 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_244 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_249 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_250 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_249 __annonCompField74 ;
   union __anonunion____missing_field_name_250 __annonCompField75 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_253 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_252 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_253 __annonCompField76 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_252 __annonCompField77 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_256 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_255 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_256 __annonCompField78 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_254 {
   struct __anonstruct____missing_field_name_255 __annonCompField79 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_258 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_257 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_258 __annonCompField81 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_259 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_260 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_261 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_254 __annonCompField80 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_257 __annonCompField82 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_259 __annonCompField83 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_260 __annonCompField84 ;
   union __anonunion____missing_field_name_261 __annonCompField85 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 34 "include/linux/if_ether.h"
struct tveeprom {
   u32 has_radio ;
   u32 has_ir ;
   u32 has_MAC_address ;
   u32 tuner_type ;
   u32 tuner_formats ;
   u32 tuner_hauppauge_model ;
   u32 tuner2_type ;
   u32 tuner2_formats ;
   u32 tuner2_hauppauge_model ;
   u32 digitizer ;
   u32 digitizer_formats ;
   u32 audio_processor ;
   u32 decoder_processor ;
   u32 model ;
   u32 revision ;
   u32 serial_number ;
   char rev_str[5U] ;
   u8 MAC_address[6U] ;
};
#line 52 "include/media/tveeprom.h"
struct hlist_bl_node;
#line 52 "include/media/tveeprom.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_265 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_264 {
   struct __anonstruct____missing_field_name_265 __annonCompField86 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_264 __annonCompField87 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_267 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_266 {
   struct __anonstruct____missing_field_name_267 __annonCompField88 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_266 __annonCompField89 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_268 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_268 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_272 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_271 {
   struct __anonstruct____missing_field_name_272 __annonCompField90 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_271 __annonCompField91 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 62
struct kstatfs;
#line 63
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_276 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_276 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_277 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_277 __annonCompField93 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_280 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_281 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_282 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_280 __annonCompField94 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_281 __annonCompField95 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_282 __annonCompField96 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_283 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_283 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_285 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_284 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_285 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_284 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 3032 "include/linux/fs.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 95 "include/media/videobuf-dma-sg.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 32 "include/linux/cdev.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 169 "./include/uapi/linux/media.h"
struct media_pipeline {

};
#line 172
struct media_pad;
#line 172 "./include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 40 "include/media/media-entity.h"
struct media_entity;
#line 40 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 46 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 62
struct media_device;
#line 62 "include/media/media-entity.h"
struct __anonstruct_dev_293 {
   u32 major ;
   u32 minor ;
};
#line 62 "include/media/media-entity.h"
union __anonunion_info_292 {
   struct __anonstruct_dev_293 dev ;
};
#line 62 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_292 info ;
};
#line 154 "include/media/media-entity.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 98 "include/media/media-device.h"
struct dvb_frontend;
#line 99
struct dvb_device;
#line 99 "include/media/media-device.h"
struct dvb_adapter {
   int num ;
   struct list_head list_head ;
   struct list_head device_list ;
   char const   *name ;
   u8 proposed_mac[6U] ;
   void *priv ;
   struct device *device ;
   struct module *module ;
   int mfe_shared ;
   struct dvb_device *mfe_dvbdev ;
   struct mutex mfe_lock ;
};
#line 76 "./drivers/media/dvb-core/dvbdev.h"
struct dvb_device {
   struct list_head list_head ;
   struct file_operations  const  *fops ;
   struct dvb_adapter *adapter ;
   int type ;
   int minor ;
   u32 id ;
   int readers ;
   int writers ;
   int users ;
   wait_queue_head_t wait_queue ;
   int (*kernel_ioctl)(struct file * , unsigned int  , void * ) ;
   void *priv ;
};
#line 149
enum dmx_output {
    DMX_OUT_DECODER = 0,
    DMX_OUT_TAP = 1,
    DMX_OUT_TS_TAP = 2,
    DMX_OUT_TSDEMUX_TAP = 3
} ;
#line 46 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_output dmx_output_t;
#line 47
enum dmx_input {
    DMX_IN_FRONTEND = 0,
    DMX_IN_DVR = 1
} ;
#line 52 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_input dmx_input_t;
#line 53
enum dmx_ts_pes {
    DMX_PES_AUDIO0 = 0,
    DMX_PES_VIDEO0 = 1,
    DMX_PES_TELETEXT0 = 2,
    DMX_PES_SUBTITLE0 = 3,
    DMX_PES_PCR0 = 4,
    DMX_PES_AUDIO1 = 5,
    DMX_PES_VIDEO1 = 6,
    DMX_PES_TELETEXT1 = 7,
    DMX_PES_SUBTITLE1 = 8,
    DMX_PES_PCR1 = 9,
    DMX_PES_AUDIO2 = 10,
    DMX_PES_VIDEO2 = 11,
    DMX_PES_TELETEXT2 = 12,
    DMX_PES_SUBTITLE2 = 13,
    DMX_PES_PCR2 = 14,
    DMX_PES_AUDIO3 = 15,
    DMX_PES_VIDEO3 = 16,
    DMX_PES_TELETEXT3 = 17,
    DMX_PES_SUBTITLE3 = 18,
    DMX_PES_PCR3 = 19,
    DMX_PES_OTHER = 20
} ;
#line 82 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_ts_pes dmx_pes_type_t;
#line 83 "./include/uapi/linux/dvb/dmx.h"
struct dmx_filter {
   __u8 filter[16U] ;
   __u8 mask[16U] ;
   __u8 mode[16U] ;
};
#line 96 "./include/uapi/linux/dvb/dmx.h"
typedef struct dmx_filter dmx_filter_t;
#line 97 "./include/uapi/linux/dvb/dmx.h"
struct dmx_sct_filter_params {
   __u16 pid ;
   dmx_filter_t filter ;
   __u32 timeout ;
   __u32 flags ;
};
#line 106 "./include/uapi/linux/dvb/dmx.h"
struct dmx_pes_filter_params {
   __u16 pid ;
   dmx_input_t input ;
   dmx_output_t output ;
   dmx_pes_type_t pes_type ;
   __u32 flags ;
};
#line 120 "./include/uapi/linux/dvb/dmx.h"
struct dmx_caps {
   __u32 caps ;
   int num_decoders ;
};
#line 125
enum dmx_source {
    DMX_SOURCE_FRONT0 = 0,
    DMX_SOURCE_FRONT1 = 1,
    DMX_SOURCE_FRONT2 = 2,
    DMX_SOURCE_FRONT3 = 3,
    DMX_SOURCE_DVR0 = 16,
    DMX_SOURCE_DVR1 = 17,
    DMX_SOURCE_DVR2 = 18,
    DMX_SOURCE_DVR3 = 19
} ;
#line 135 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_source dmx_source_t;
#line 142
enum dmx_success {
    DMX_OK = 0,
    DMX_LENGTH_ERROR = 1,
    DMX_OVERRUN_ERROR = 2,
    DMX_CRC_ERROR = 3,
    DMX_FRAME_ERROR = 4,
    DMX_FIFO_ERROR = 5,
    DMX_MISSED_ERROR = 6
} ;
#line 152
struct dmx_demux;
#line 152 "./include/uapi/linux/dvb/dmx.h"
struct dmx_ts_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int (*set)(struct dmx_ts_feed * , u16  , int  , enum dmx_ts_pes  , size_t  , struct timespec  ) ;
   int (*start_filtering)(struct dmx_ts_feed * ) ;
   int (*stop_filtering)(struct dmx_ts_feed * ) ;
};
#line 99 "./drivers/media/dvb-core/demux.h"
struct dmx_section_feed;
#line 99 "./drivers/media/dvb-core/demux.h"
struct dmx_section_filter {
   u8 filter_value[18U] ;
   u8 filter_mask[18U] ;
   u8 filter_mode[18U] ;
   struct dmx_section_feed *parent ;
   void *priv ;
};
#line 111 "./drivers/media/dvb-core/demux.h"
struct dmx_section_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int check_crc ;
   u32 crc_val ;
   u8 *secbuf ;
   u8 secbuf_base[4284U] ;
   u16 secbufp ;
   u16 seclen ;
   u16 tsfeedp ;
   int (*set)(struct dmx_section_feed * , u16  , size_t  , int  ) ;
   int (*allocate_filter)(struct dmx_section_feed * , struct dmx_section_filter ** ) ;
   int (*release_filter)(struct dmx_section_feed * , struct dmx_section_filter * ) ;
   int (*start_filtering)(struct dmx_section_feed * ) ;
   int (*stop_filtering)(struct dmx_section_feed * ) ;
};
#line 148
enum dmx_frontend_source {
    DMX_MEMORY_FE = 0,
    DMX_FRONTEND_0 = 1,
    DMX_FRONTEND_1 = 2,
    DMX_FRONTEND_2 = 3,
    DMX_FRONTEND_3 = 4,
    DMX_STREAM_0 = 5,
    DMX_STREAM_1 = 6,
    DMX_STREAM_2 = 7,
    DMX_STREAM_3 = 8
} ;
#line 160 "./drivers/media/dvb-core/demux.h"
struct dmx_frontend {
   struct list_head connectivity_list ;
   enum dmx_frontend_source source ;
};
#line 176 "./drivers/media/dvb-core/demux.h"
struct dmx_demux {
   u32 capabilities ;
   struct dmx_frontend *frontend ;
   void *priv ;
   int (*open)(struct dmx_demux * ) ;
   int (*close)(struct dmx_demux * ) ;
   int (*write)(struct dmx_demux * , char const   * , size_t  ) ;
   int (*allocate_ts_feed)(struct dmx_demux * , struct dmx_ts_feed ** , int (*)(u8 const   * ,
                                                                                size_t  ,
                                                                                u8 const   * ,
                                                                                size_t  ,
                                                                                struct dmx_ts_feed * ,
                                                                                enum dmx_success  ) ) ;
   int (*release_ts_feed)(struct dmx_demux * , struct dmx_ts_feed * ) ;
   int (*allocate_section_feed)(struct dmx_demux * , struct dmx_section_feed ** ,
                                int (*)(u8 const   * , size_t  , u8 const   * , size_t  ,
                                        struct dmx_section_filter * , enum dmx_success  ) ) ;
   int (*release_section_feed)(struct dmx_demux * , struct dmx_section_feed * ) ;
   int (*add_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*remove_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   struct list_head *(*get_frontends)(struct dmx_demux * ) ;
   int (*connect_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*disconnect_frontend)(struct dmx_demux * ) ;
   int (*get_pes_pids)(struct dmx_demux * , u16 * ) ;
   int (*get_caps)(struct dmx_demux * , struct dmx_caps * ) ;
   int (*set_source)(struct dmx_demux * , dmx_source_t const   * ) ;
   int (*get_stc)(struct dmx_demux * , unsigned int  , u64 * , unsigned int * ) ;
};
#line 239 "./drivers/media/dvb-core/demux.h"
struct dvb_ringbuffer {
   u8 *data ;
   ssize_t size ;
   ssize_t pread ;
   ssize_t pwrite ;
   int error ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
};
#line 186 "./drivers/media/dvb-core/dvb_ringbuffer.h"
enum dmxdev_type {
    DMXDEV_TYPE_NONE = 0,
    DMXDEV_TYPE_SEC = 1,
    DMXDEV_TYPE_PES = 2
} ;
#line 192
enum dmxdev_state {
    DMXDEV_STATE_FREE = 0,
    DMXDEV_STATE_ALLOCATED = 1,
    DMXDEV_STATE_SET = 2,
    DMXDEV_STATE_GO = 3,
    DMXDEV_STATE_DONE = 4,
    DMXDEV_STATE_TIMEDOUT = 5
} ;
#line 63 "./drivers/media/dvb-core/dmxdev.h"
union __anonunion_filter_295 {
   struct dmx_section_filter *sec ;
};
#line 63 "./drivers/media/dvb-core/dmxdev.h"
union __anonunion_feed_296 {
   struct list_head ts ;
   struct dmx_section_feed *sec ;
};
#line 63 "./drivers/media/dvb-core/dmxdev.h"
union __anonunion_params_297 {
   struct dmx_sct_filter_params sec ;
   struct dmx_pes_filter_params pes ;
};
#line 63
struct dmxdev;
#line 63 "./drivers/media/dvb-core/dmxdev.h"
struct dmxdev_filter {
   union __anonunion_filter_295 filter ;
   union __anonunion_feed_296 feed ;
   union __anonunion_params_297 params ;
   enum dmxdev_type type ;
   enum dmxdev_state state ;
   struct dmxdev *dev ;
   struct dvb_ringbuffer buffer ;
   struct mutex mutex ;
   struct timer_list timer ;
   int todo ;
   u8 secheader[3U] ;
};
#line 92 "./drivers/media/dvb-core/dmxdev.h"
struct dmxdev {
   struct dvb_device *dvbdev ;
   struct dvb_device *dvr_dvbdev ;
   struct dmxdev_filter *filter ;
   struct dmx_demux *demux ;
   int filternum ;
   int capabilities ;
   unsigned char exit : 1 ;
   struct dmx_frontend *dvr_orig_fe ;
   struct dvb_ringbuffer dvr_buffer ;
   struct mutex mutex ;
   spinlock_t lock ;
};
#line 118
struct dvb_demux_feed;
#line 118 "./drivers/media/dvb-core/dmxdev.h"
struct dvb_demux_filter {
   struct dmx_section_filter filter ;
   u8 maskandmode[18U] ;
   u8 maskandnotmode[18U] ;
   int doneq ;
   struct dvb_demux_filter *next ;
   struct dvb_demux_feed *feed ;
   int index ;
   int state ;
   int type ;
   u16 hw_handle ;
   struct timer_list timer ;
};
#line 64 "./drivers/media/dvb-core/dvb_demux.h"
union __anonunion_feed_298 {
   struct dmx_ts_feed ts ;
   struct dmx_section_feed sec ;
};
#line 64 "./drivers/media/dvb-core/dvb_demux.h"
union __anonunion_cb_299 {
   int (*ts)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_ts_feed * ,
             enum dmx_success  ) ;
   int (*sec)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_section_filter * ,
              enum dmx_success  ) ;
};
#line 64
struct dvb_demux;
#line 64 "./drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux_feed {
   union __anonunion_feed_298 feed ;
   union __anonunion_cb_299 cb ;
   struct dvb_demux *demux ;
   void *priv ;
   int type ;
   int state ;
   u16 pid ;
   u8 *buffer ;
   int buffer_size ;
   struct timespec timeout ;
   struct dvb_demux_filter *filter ;
   int ts_type ;
   enum dmx_ts_pes pes_type ;
   int cc ;
   int pusi_seen ;
   u16 peslen ;
   struct list_head list_head ;
   unsigned int index ;
};
#line 100 "./drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux {
   struct dmx_demux dmx ;
   void *priv ;
   int filternum ;
   int feednum ;
   int (*start_feed)(struct dvb_demux_feed * ) ;
   int (*stop_feed)(struct dvb_demux_feed * ) ;
   int (*write_to_decoder)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   u32 (*check_crc32)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   void (*memcopy)(struct dvb_demux_feed * , u8 * , u8 const   * , size_t  ) ;
   int users ;
   struct dvb_demux_filter *filter ;
   struct dvb_demux_feed *feed ;
   struct list_head frontend_list ;
   struct dvb_demux_feed *pesfilter[20U] ;
   u16 pids[20U] ;
   int playing ;
   int recording ;
   struct list_head feed_list ;
   u8 tsbuf[204U] ;
   int tsbufp ;
   struct mutex mutex ;
   spinlock_t lock ;
   uint8_t *cnt_storage ;
   struct timespec speed_last_time ;
   uint32_t speed_pkts_cnt ;
};
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_301 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_301 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_302 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_302 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_303 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_303 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_304 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_304 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_305 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_305 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_306 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_306 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_307 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_307 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_308 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_308 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_309 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_310 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_309 ifr_ifrn ;
   union __anonunion_ifr_ifru_310 ifr_ifru ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 715 "include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_342 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_342 possible_net_t;
#line 338 "include/linux/mii.h"
enum ldv_29759 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_29759 phy_interface_t;
#line 126
enum ldv_29813 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_29813 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_351 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_352 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_353 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_351 adj_list ;
   struct __anonstruct_all_adj_list_352 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_353 __annonCompField107 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 116 "include/linux/rtnetlink.h"
struct ipv4_devconf {
   void *sysctl ;
   int data[29U] ;
   unsigned long state[1U] ;
};
#line 20 "include/linux/inetdevice.h"
struct in_ifaddr;
#line 20
struct ip_mc_list;
#line 20 "include/linux/inetdevice.h"
struct in_device {
   struct net_device *dev ;
   atomic_t refcnt ;
   int dead ;
   struct in_ifaddr *ifa_list ;
   struct ip_mc_list *mc_list ;
   struct ip_mc_list **mc_hash ;
   int mc_count ;
   spinlock_t mc_tomb_lock ;
   struct ip_mc_list *mc_tomb ;
   unsigned long mr_v1_seen ;
   unsigned long mr_v2_seen ;
   unsigned long mr_maxdelay ;
   unsigned char mr_qrv ;
   unsigned char mr_gq_running ;
   unsigned char mr_ifc_count ;
   struct timer_list mr_gq_timer ;
   struct timer_list mr_ifc_timer ;
   struct neigh_parms *arp_parms ;
   struct ipv4_devconf cnf ;
   struct callback_head callback_head ;
};
#line 71 "include/linux/inetdevice.h"
struct in_ifaddr {
   struct hlist_node hash ;
   struct in_ifaddr *ifa_next ;
   struct in_device *ifa_dev ;
   struct callback_head callback_head ;
   __be32 ifa_local ;
   __be32 ifa_address ;
   __be32 ifa_mask ;
   __be32 ifa_broadcast ;
   unsigned char ifa_scope ;
   unsigned char ifa_prefixlen ;
   __u32 ifa_flags ;
   char ifa_label[16U] ;
   __u32 ifa_valid_lft ;
   __u32 ifa_preferred_lft ;
   unsigned long ifa_cstamp ;
   unsigned long ifa_tstamp ;
};
#line 449 "include/linux/etherdevice.h"
struct dvb_net {
   struct dvb_device *dvbdev ;
   struct net_device *device[10U] ;
   int state[10U] ;
   unsigned char exit : 1 ;
   struct dmx_demux *demux ;
   struct mutex ioctl_mutex ;
};
#line 48 "./drivers/media/dvb-core/dvb_net.h"
enum fe_type {
    FE_QPSK = 0,
    FE_QAM = 1,
    FE_OFDM = 2,
    FE_ATSC = 3
} ;
#line 55
enum fe_caps {
    FE_IS_STUPID = 0,
    FE_CAN_INVERSION_AUTO = 1,
    FE_CAN_FEC_1_2 = 2,
    FE_CAN_FEC_2_3 = 4,
    FE_CAN_FEC_3_4 = 8,
    FE_CAN_FEC_4_5 = 16,
    FE_CAN_FEC_5_6 = 32,
    FE_CAN_FEC_6_7 = 64,
    FE_CAN_FEC_7_8 = 128,
    FE_CAN_FEC_8_9 = 256,
    FE_CAN_FEC_AUTO = 512,
    FE_CAN_QPSK = 1024,
    FE_CAN_QAM_16 = 2048,
    FE_CAN_QAM_32 = 4096,
    FE_CAN_QAM_64 = 8192,
    FE_CAN_QAM_128 = 16384,
    FE_CAN_QAM_256 = 32768,
    FE_CAN_QAM_AUTO = 65536,
    FE_CAN_TRANSMISSION_MODE_AUTO = 131072,
    FE_CAN_BANDWIDTH_AUTO = 262144,
    FE_CAN_GUARD_INTERVAL_AUTO = 524288,
    FE_CAN_HIERARCHY_AUTO = 1048576,
    FE_CAN_8VSB = 2097152,
    FE_CAN_16VSB = 4194304,
    FE_HAS_EXTENDED_CAPS = 8388608,
    FE_CAN_MULTISTREAM = 67108864,
    FE_CAN_TURBO_FEC = 134217728,
    FE_CAN_2G_MODULATION = 268435456,
    FE_NEEDS_BENDING = 536870912,
    FE_CAN_RECOVER = 1073741824,
    FE_CAN_MUTE_TS = 2147483648U
} ;
#line 89 "./drivers/media/dvb-core/dvb_net.h"
struct dvb_frontend_info {
   char name[128U] ;
   enum fe_type type ;
   __u32 frequency_min ;
   __u32 frequency_max ;
   __u32 frequency_stepsize ;
   __u32 frequency_tolerance ;
   __u32 symbol_rate_min ;
   __u32 symbol_rate_max ;
   __u32 symbol_rate_tolerance ;
   __u32 notifier_delay ;
   enum fe_caps caps ;
};
#line 85 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_master_cmd {
   __u8 msg[6U] ;
   __u8 msg_len ;
};
#line 95 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_slave_reply {
   __u8 msg[4U] ;
   __u8 msg_len ;
   int timeout ;
};
#line 101
enum fe_sec_voltage {
    SEC_VOLTAGE_13 = 0,
    SEC_VOLTAGE_18 = 1,
    SEC_VOLTAGE_OFF = 2
} ;
#line 107
enum fe_sec_tone_mode {
    SEC_TONE_ON = 0,
    SEC_TONE_OFF = 1
} ;
#line 112
enum fe_sec_mini_cmd {
    SEC_MINI_A = 0,
    SEC_MINI_B = 1
} ;
#line 117
enum fe_status {
    FE_HAS_SIGNAL = 1,
    FE_HAS_CARRIER = 2,
    FE_HAS_VITERBI = 4,
    FE_HAS_SYNC = 8,
    FE_HAS_LOCK = 16,
    FE_TIMEDOUT = 32,
    FE_REINIT = 64
} ;
#line 127
enum fe_spectral_inversion {
    INVERSION_OFF = 0,
    INVERSION_ON = 1,
    INVERSION_AUTO = 2
} ;
#line 133
enum fe_code_rate {
    FEC_NONE = 0,
    FEC_1_2 = 1,
    FEC_2_3 = 2,
    FEC_3_4 = 3,
    FEC_4_5 = 4,
    FEC_5_6 = 5,
    FEC_6_7 = 6,
    FEC_7_8 = 7,
    FEC_8_9 = 8,
    FEC_AUTO = 9,
    FEC_3_5 = 10,
    FEC_9_10 = 11,
    FEC_2_5 = 12
} ;
#line 149
enum fe_modulation {
    QPSK = 0,
    QAM_16 = 1,
    QAM_32 = 2,
    QAM_64 = 3,
    QAM_128 = 4,
    QAM_256 = 5,
    QAM_AUTO = 6,
    VSB_8 = 7,
    VSB_16 = 8,
    PSK_8 = 9,
    APSK_16 = 10,
    APSK_32 = 11,
    DQPSK = 12,
    QAM_4_NR = 13
} ;
#line 166
enum fe_transmit_mode {
    TRANSMISSION_MODE_2K = 0,
    TRANSMISSION_MODE_8K = 1,
    TRANSMISSION_MODE_AUTO = 2,
    TRANSMISSION_MODE_4K = 3,
    TRANSMISSION_MODE_1K = 4,
    TRANSMISSION_MODE_16K = 5,
    TRANSMISSION_MODE_32K = 6,
    TRANSMISSION_MODE_C1 = 7,
    TRANSMISSION_MODE_C3780 = 8
} ;
#line 178
enum fe_guard_interval {
    GUARD_INTERVAL_1_32 = 0,
    GUARD_INTERVAL_1_16 = 1,
    GUARD_INTERVAL_1_8 = 2,
    GUARD_INTERVAL_1_4 = 3,
    GUARD_INTERVAL_AUTO = 4,
    GUARD_INTERVAL_1_128 = 5,
    GUARD_INTERVAL_19_128 = 6,
    GUARD_INTERVAL_19_256 = 7,
    GUARD_INTERVAL_PN420 = 8,
    GUARD_INTERVAL_PN595 = 9,
    GUARD_INTERVAL_PN945 = 10
} ;
#line 192
enum fe_hierarchy {
    HIERARCHY_NONE = 0,
    HIERARCHY_1 = 1,
    HIERARCHY_2 = 2,
    HIERARCHY_4 = 3,
    HIERARCHY_AUTO = 4
} ;
#line 200
enum fe_interleaving {
    INTERLEAVING_NONE = 0,
    INTERLEAVING_AUTO = 1,
    INTERLEAVING_240 = 2,
    INTERLEAVING_720 = 3
} ;
#line 207
enum fe_pilot {
    PILOT_ON = 0,
    PILOT_OFF = 1,
    PILOT_AUTO = 2
} ;
#line 213
enum fe_rolloff {
    ROLLOFF_35 = 0,
    ROLLOFF_20 = 1,
    ROLLOFF_25 = 2,
    ROLLOFF_AUTO = 3
} ;
#line 220
enum fe_delivery_system {
    SYS_UNDEFINED = 0,
    SYS_DVBC_ANNEX_A = 1,
    SYS_DVBC_ANNEX_B = 2,
    SYS_DVBT = 3,
    SYS_DSS = 4,
    SYS_DVBS = 5,
    SYS_DVBS2 = 6,
    SYS_DVBH = 7,
    SYS_ISDBT = 8,
    SYS_ISDBS = 9,
    SYS_ISDBC = 10,
    SYS_ATSC = 11,
    SYS_ATSCMH = 12,
    SYS_DTMB = 13,
    SYS_CMMB = 14,
    SYS_DAB = 15,
    SYS_DVBT2 = 16,
    SYS_TURBO = 17,
    SYS_DVBC_ANNEX_C = 18
} ;
#line 403 "./include/uapi/linux/dvb/frontend.h"
union __anonunion____missing_field_name_367 {
   __u64 uvalue ;
   __s64 svalue ;
};
#line 403 "./include/uapi/linux/dvb/frontend.h"
struct dtv_stats {
   __u8 scale ;
   union __anonunion____missing_field_name_367 __annonCompField108 ;
};
#line 454 "./include/uapi/linux/dvb/frontend.h"
struct dtv_fe_stats {
   __u8 len ;
   struct dtv_stats stat[4U] ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
struct __anonstruct_buffer_369 {
   __u8 data[32U] ;
   __u32 len ;
   __u32 reserved1[3U] ;
   void *reserved2 ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
union __anonunion_u_368 {
   __u32 data ;
   struct dtv_fe_stats st ;
   struct __anonstruct_buffer_369 buffer ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
struct dtv_property {
   __u32 cmd ;
   __u32 reserved[3U] ;
   union __anonunion_u_368 u ;
   int result ;
};
#line 486 "./include/uapi/linux/dvb/frontend.h"
struct dvb_frontend_tune_settings {
   int min_delay_ms ;
   int step_size ;
   int max_drift ;
};
#line 56 "./drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_info {
   char name[128U] ;
   u32 frequency_min ;
   u32 frequency_max ;
   u32 frequency_step ;
   u32 bandwidth_min ;
   u32 bandwidth_max ;
   u32 bandwidth_step ;
};
#line 70 "./drivers/media/dvb-core/dvb_frontend.h"
struct analog_parameters {
   unsigned int frequency ;
   unsigned int mode ;
   unsigned int audmode ;
   u64 std ;
};
#line 113
enum tuner_param {
    DVBFE_TUNER_FREQUENCY = 1,
    DVBFE_TUNER_TUNERSTEP = 2,
    DVBFE_TUNER_IFFREQ = 4,
    DVBFE_TUNER_BANDWIDTH = 8,
    DVBFE_TUNER_REFCLOCK = 16,
    DVBFE_TUNER_IQSENSE = 32,
    DVBFE_TUNER_DUMMY = (-0x7FFFFFFF-1)
} ;
#line 123
enum dvbfe_algo {
    DVBFE_ALGO_HW = 1,
    DVBFE_ALGO_SW = 2,
    DVBFE_ALGO_CUSTOM = 4,
    DVBFE_ALGO_RECOVERY = (-0x7FFFFFFF-1)
} ;
#line 130 "./drivers/media/dvb-core/dvb_frontend.h"
struct tuner_state {
   u32 frequency ;
   u32 tunerstep ;
   u32 ifreq ;
   u32 bandwidth ;
   u32 iqsense ;
   u32 refclock ;
};
#line 164
enum dvbfe_search {
    DVBFE_ALGO_SEARCH_SUCCESS = 1,
    DVBFE_ALGO_SEARCH_ASLEEP = 2,
    DVBFE_ALGO_SEARCH_FAILED = 4,
    DVBFE_ALGO_SEARCH_INVALID = 8,
    DVBFE_ALGO_SEARCH_AGAIN = 16,
    DVBFE_ALGO_SEARCH_ERROR = (-0x7FFFFFFF-1)
} ;
#line 173 "./drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_ops {
   struct dvb_tuner_info info ;
   int (*release)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*suspend)(struct dvb_frontend * ) ;
   int (*resume)(struct dvb_frontend * ) ;
   int (*set_params)(struct dvb_frontend * ) ;
   int (*set_analog_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*calc_regs)(struct dvb_frontend * , u8 * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
   int (*get_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_bandwidth)(struct dvb_frontend * , u32 * ) ;
   int (*get_if_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_status)(struct dvb_frontend * , u32 * ) ;
   int (*get_rf_strength)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   int (*set_frequency)(struct dvb_frontend * , u32  ) ;
   int (*set_bandwidth)(struct dvb_frontend * , u32  ) ;
   int (*set_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
   int (*get_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
};
#line 239 "./drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_info {
   char *name ;
};
#line 243 "./drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_ops {
   struct analog_demod_info info ;
   void (*set_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*has_signal)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   void (*tuner_status)(struct dvb_frontend * ) ;
   void (*standby)(struct dvb_frontend * ) ;
   void (*release)(struct dvb_frontend * ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
};
#line 260
struct dtv_frontend_properties;
#line 261 "./drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend_ops {
   struct dvb_frontend_info info ;
   u8 delsys[8U] ;
   void (*release)(struct dvb_frontend * ) ;
   void (*release_sec)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*write)(struct dvb_frontend * , u8 const   * , int  ) ;
   int (*tune)(struct dvb_frontend * , bool  , unsigned int  , unsigned int * , enum fe_status * ) ;
   enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend * ) ;
   int (*set_frontend)(struct dvb_frontend * ) ;
   int (*get_tune_settings)(struct dvb_frontend * , struct dvb_frontend_tune_settings * ) ;
   int (*get_frontend)(struct dvb_frontend * ) ;
   int (*read_status)(struct dvb_frontend * , enum fe_status * ) ;
   int (*read_ber)(struct dvb_frontend * , u32 * ) ;
   int (*read_signal_strength)(struct dvb_frontend * , u16 * ) ;
   int (*read_snr)(struct dvb_frontend * , u16 * ) ;
   int (*read_ucblocks)(struct dvb_frontend * , u32 * ) ;
   int (*diseqc_reset_overload)(struct dvb_frontend * ) ;
   int (*diseqc_send_master_cmd)(struct dvb_frontend * , struct dvb_diseqc_master_cmd * ) ;
   int (*diseqc_recv_slave_reply)(struct dvb_frontend * , struct dvb_diseqc_slave_reply * ) ;
   int (*diseqc_send_burst)(struct dvb_frontend * , enum fe_sec_mini_cmd  ) ;
   int (*set_tone)(struct dvb_frontend * , enum fe_sec_tone_mode  ) ;
   int (*set_voltage)(struct dvb_frontend * , enum fe_sec_voltage  ) ;
   int (*enable_high_lnb_voltage)(struct dvb_frontend * , long  ) ;
   int (*dishnetwork_send_legacy_command)(struct dvb_frontend * , unsigned long  ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*ts_bus_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_lna)(struct dvb_frontend * ) ;
   enum dvbfe_search (*search)(struct dvb_frontend * ) ;
   struct dvb_tuner_ops tuner_ops ;
   struct analog_demod_ops analog_ops ;
   int (*set_property)(struct dvb_frontend * , struct dtv_property * ) ;
   int (*get_property)(struct dvb_frontend * , struct dtv_property * ) ;
};
#line 323 "./drivers/media/dvb-core/dvb_frontend.h"
struct __anonstruct_layer_370 {
   u8 segment_count ;
   enum fe_code_rate fec ;
   enum fe_modulation modulation ;
   u8 interleaving ;
};
#line 323 "./drivers/media/dvb-core/dvb_frontend.h"
struct dtv_frontend_properties {
   u32 state ;
   u32 frequency ;
   enum fe_modulation modulation ;
   enum fe_sec_voltage voltage ;
   enum fe_sec_tone_mode sectone ;
   enum fe_spectral_inversion inversion ;
   enum fe_code_rate fec_inner ;
   enum fe_transmit_mode transmission_mode ;
   u32 bandwidth_hz ;
   enum fe_guard_interval guard_interval ;
   enum fe_hierarchy hierarchy ;
   u32 symbol_rate ;
   enum fe_code_rate code_rate_HP ;
   enum fe_code_rate code_rate_LP ;
   enum fe_pilot pilot ;
   enum fe_rolloff rolloff ;
   enum fe_delivery_system delivery_system ;
   enum fe_interleaving interleaving ;
   u8 isdbt_partial_reception ;
   u8 isdbt_sb_mode ;
   u8 isdbt_sb_subchannel ;
   u32 isdbt_sb_segment_idx ;
   u32 isdbt_sb_segment_count ;
   u8 isdbt_layer_enabled ;
   struct __anonstruct_layer_370 layer[3U] ;
   u32 stream_id ;
   u8 atscmh_fic_ver ;
   u8 atscmh_parade_id ;
   u8 atscmh_nog ;
   u8 atscmh_tnog ;
   u8 atscmh_sgn ;
   u8 atscmh_prc ;
   u8 atscmh_rs_frame_mode ;
   u8 atscmh_rs_frame_ensemble ;
   u8 atscmh_rs_code_mode_pri ;
   u8 atscmh_rs_code_mode_sec ;
   u8 atscmh_sccc_block_mode ;
   u8 atscmh_sccc_code_mode_a ;
   u8 atscmh_sccc_code_mode_b ;
   u8 atscmh_sccc_code_mode_c ;
   u8 atscmh_sccc_code_mode_d ;
   u32 lna ;
   struct dtv_fe_stats strength ;
   struct dtv_fe_stats cnr ;
   struct dtv_fe_stats pre_bit_error ;
   struct dtv_fe_stats pre_bit_count ;
   struct dtv_fe_stats post_bit_error ;
   struct dtv_fe_stats post_bit_count ;
   struct dtv_fe_stats block_error ;
   struct dtv_fe_stats block_count ;
};
#line 411 "./drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend {
   struct dvb_frontend_ops ops ;
   struct dvb_adapter *dvb ;
   void *demodulator_priv ;
   void *tuner_priv ;
   void *frontend_priv ;
   void *sec_priv ;
   void *analog_demod_priv ;
   struct dtv_frontend_properties dtv_property_cache ;
   int (*callback)(void * , int  , int  , int  ) ;
   int id ;
   unsigned int exit ;
};
#line 58 "include/media/videobuf-dvb.h"
struct video_device;
#line 59
struct v4l2_device;
#line 60
struct v4l2_ctrl_handler;
#line 61 "include/media/videobuf-dvb.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 61 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 78
struct vb2_queue;
#line 78
struct v4l2_ioctl_ops;
#line 78 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 86 "include/media/v4l2-common.h"
struct v4l2_subdev;
#line 87
struct v4l2_subdev_ops;
#line 147 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 191
struct v4l2_fh;
#line 192 "include/media/v4l2-common.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_sdr_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_query_ext_ctrl)(struct file * , void * , struct v4l2_query_ext_ctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_g_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_s_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 334 "include/media/v4l2-ioctl.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u16 xfer_func ;
   __u16 reserved[11U] ;
};
#line 45 "./include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 66 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 81 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 100 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 111 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 132 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 156
struct v4l2_async_notifier;
#line 157
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_372 {
   struct device_node  const  *node ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_373 {
   char const   *name ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_374 {
   int adapter_id ;
   unsigned short address ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_375 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_371 {
   struct __anonstruct_of_372 of ;
   struct __anonstruct_device_name_373 device_name ;
   struct __anonstruct_i2c_374 i2c ;
   struct __anonstruct_custom_375 custom ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_371 match ;
   struct list_head list ;
};
#line 63 "include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 97
struct v4l2_m2m_ctx;
#line 97 "include/media/v4l2-async.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 106 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 112 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 115 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 116
struct v4l2_mbus_frame_desc;
#line 117 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 63 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 119 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   long (*compat_ioctl32)(struct v4l2_subdev * , unsigned int  , unsigned long  ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 180 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*enum_freq_bands)(struct v4l2_subdev * , struct v4l2_frequency_band * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 207 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 234 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 255 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 267 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 341 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 381 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 396
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 400 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 448 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 467 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_config {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 480 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                         struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                          struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                              struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 524 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 536 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 557
struct regulator_bulk_data;
#line 558 "include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 579 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct device_node *of_node ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 619 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct v4l2_subdev_pad_config *pad ;
};
#line 684 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 128 "include/media/v4l2-device.h"
struct tmComResHWDescr {
   u8 bLength ;
   u8 bDescriptorType ;
   u8 bDescriptorSubtype ;
   u16 bcdSpecVersion ;
   u32 dwClockFrequency ;
   u32 dwClockUpdateRes ;
   u8 bCapabilities ;
   u32 dwDeviceRegistersLocation ;
   u32 dwHostMemoryRegion ;
   u32 dwHostMemoryRegionSize ;
   u32 dwHostHibernatMemRegion ;
   u32 dwHostHibernatMemRegionSize ;
};
#line 41 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResInterfaceDescr {
   u8 bLength ;
   u8 bDescriptorType ;
   u8 bDescriptorSubtype ;
   u8 bFlags ;
   u8 bInterfaceType ;
   u8 bInterfaceId ;
   u8 bBaseInterface ;
   u8 bInterruptId ;
   u8 bDebugInterruptId ;
   u8 BARLocation ;
   u8 Reserved[3U] ;
};
#line 60 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResBusDescr {
   u64 CommandRing ;
   u64 ResponseRing ;
   u32 CommandWrite ;
   u32 CommandRead ;
   u32 ResponseWrite ;
   u32 ResponseRead ;
};
#line 69
enum tmBusType {
    NONE = 0,
    TYPE_BUS_PCI = 1,
    TYPE_BUS_PCIe = 2,
    TYPE_BUS_USB = 3,
    TYPE_BUS_I2C = 4
} ;
#line 77 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResBusInfo {
   enum tmBusType Type ;
   u16 m_wMaxReqSize ;
   u8 *m_pdwSetRing ;
   u32 m_dwSizeSetRing ;
   u8 *m_pdwGetRing ;
   u32 m_dwSizeGetRing ;
   u32 m_dwSetWritePos ;
   u32 m_dwSetReadPos ;
   u32 m_dwGetWritePos ;
   u32 m_dwGetReadPos ;
   struct mutex lock ;
};
#line 114 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct cmd {
   u8 seqno ;
   u32 inuse ;
   u32 timeout ;
   u32 signalled ;
   struct mutex lock ;
   wait_queue_head_t wait ;
};
#line 136 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResExtDevDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 unitid ;
   u32 devicetype ;
   u16 deviceid ;
   u32 numgpiopins ;
   u8 numgpiogroups ;
   u8 controlsize ;
};
#line 182 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResTunerDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 unitid ;
   u8 sourceid ;
   u8 iunit ;
   u32 tuningstandards ;
   u8 controlsize ;
   u32 controls ;
};
#line 219 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmHWStreamParameters {
   u32 bitspersample ;
   u32 samplesperline ;
   u32 numberoflines ;
   u32 pitch ;
   u32 linethreshold ;
   u64 **pagetablelistvirt ;
   u64 *pagetablelistphys ;
   u32 numpagetables ;
   u32 numpagetableentries ;
};
#line 237 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResDMATermDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtyle ;
   u8 unitid ;
   u16 terminaltype ;
   u8 assocterminal ;
   u8 sourceid ;
   u8 iterminal ;
   u32 BARLocation ;
   u8 flags ;
   u8 interruptid ;
   u8 buffercount ;
   u8 metadatasize ;
   u8 numformats ;
   u8 controlsize ;
};
#line 299 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResProcDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 unitid ;
   u8 sourceid ;
   u16 wreserved ;
   u8 controlsize ;
};
#line 337 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResEncoderDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 unitid ;
   u8 vsourceid ;
   u8 asourceid ;
   u8 iunit ;
   u32 dwmControlCap ;
   u32 dwmProfileCap ;
   u32 dwmVidFormatCap ;
   u8 bmVidBitrateCap ;
   u16 wmVidResolutionsCap ;
   u16 wmVidFrmRateCap ;
   u32 dwmAudFormatCap ;
   u8 bmAudBitrateCap ;
};
#line 356 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResAFeatureDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 unitid ;
   u8 sourceid ;
   u8 controlsize ;
};
#line 404 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResVBIFormatDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 bFormatIndex ;
   u32 VideoStandard ;
   u8 StartLine ;
   u8 EndLine ;
   u8 FieldRate ;
   u8 bNumLines ;
};
#line 443
enum port_t {
    SAA7164_MPEG_UNDEFINED = 0,
    SAA7164_MPEG_DVB = 1,
    SAA7164_MPEG_ENCODER = 2,
    SAA7164_MPEG_VBI = 3
} ;
#line 450
enum saa7164_i2c_bus_nr {
    SAA7164_I2C_BUS_0 = 0,
    SAA7164_I2C_BUS_1 = 1,
    SAA7164_I2C_BUS_2 = 2
} ;
#line 456
enum saa7164_buffer_flags {
    SAA7164_BUFFER_UNDEFINED = 0,
    SAA7164_BUFFER_FREE = 1,
    SAA7164_BUFFER_BUSY = 2,
    SAA7164_BUFFER_FULL = 3
} ;
#line 463
enum saa7164_unit_type {
    SAA7164_UNIT_UNDEFINED = 0,
    SAA7164_UNIT_DIGITAL_DEMODULATOR = 1,
    SAA7164_UNIT_ANALOG_DEMODULATOR = 2,
    SAA7164_UNIT_TUNER = 3,
    SAA7164_UNIT_EEPROM = 4,
    SAA7164_UNIT_ZILOG_IRBLASTER = 5,
    SAA7164_UNIT_ENCODER = 6
} ;
#line 473 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct saa7164_unit {
   enum saa7164_unit_type type ;
   u8 id ;
   char *name ;
   enum saa7164_i2c_bus_nr i2c_bus_nr ;
   u8 i2c_bus_addr ;
   u8 i2c_reg_len ;
};
#line 168 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
enum ldv_34530 {
    SAA7164_CHIP_UNDEFINED = 0,
    SAA7164_CHIP_REV2 = 1,
    SAA7164_CHIP_REV3 = 2
} ;
#line 174 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_board {
   char *name ;
   enum port_t porta ;
   enum port_t portb ;
   enum port_t portc ;
   enum port_t portd ;
   enum port_t porte ;
   enum port_t portf ;
   enum ldv_34530 chiprev ;
   struct saa7164_unit unit[8U] ;
};
#line 180 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_subid {
   u16 subvendor ;
   u16 subdevice ;
   u32 card ;
};
#line 186
struct saa7164_port;
#line 196 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_histogram_bucket {
   u32 val ;
   u32 count ;
   u64 update_time ;
};
#line 202 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_histogram {
   char name[32U] ;
   struct saa7164_histogram_bucket counter1[64U] ;
};
#line 218 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_fw_status {
   u32 status ;
   u32 mode ;
   u32 spec ;
   u32 inst ;
   u32 cpuload ;
   u32 remainheap ;
   u32 version ;
   u32 major ;
   u32 sub ;
   u32 rel ;
   u32 buildnr ;
};
#line 236 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_dvb {
   struct mutex lock ;
   struct dvb_adapter adapter ;
   struct dvb_frontend *frontend ;
   struct dvb_demux demux ;
   struct dmxdev dmxdev ;
   struct dmx_frontend fe_hw ;
   struct dmx_frontend fe_mem ;
   struct dvb_net net ;
   int feeding ;
};
#line 248
struct saa7164_dev;
#line 248 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_i2c {
   struct saa7164_dev *dev ;
   enum saa7164_i2c_bus_nr nr ;
   struct i2c_adapter i2c_adap ;
   struct i2c_client i2c_client ;
   u32 i2c_rc ;
};
#line 263 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_tvnorm {
   char *name ;
   v4l2_std_id id ;
};
#line 268 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_encoder_params {
   struct saa7164_tvnorm encodernorm ;
   u32 height ;
   u32 width ;
   u32 is_50hz ;
   u32 bitrate ;
   u32 bitrate_peak ;
   u32 bitrate_mode ;
   u32 stream_type ;
   u32 audio_sampling_freq ;
   u32 ctl_mute ;
   u32 ctl_aspect ;
   u32 refdist ;
   u32 gop_size ;
};
#line 285 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_vbi_params {
   struct saa7164_tvnorm encodernorm ;
   u32 height ;
   u32 width ;
   u32 is_50hz ;
   u32 bitrate ;
   u32 bitrate_peak ;
   u32 bitrate_mode ;
   u32 stream_type ;
   u32 audio_sampling_freq ;
   u32 ctl_mute ;
   u32 ctl_aspect ;
   u32 refdist ;
   u32 gop_size ;
};
#line 302 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_buffer {
   struct list_head list ;
   int idx ;
   struct saa7164_port *port ;
   enum saa7164_buffer_flags flags ;
   u32 pci_size ;
   u64 *cpu ;
   dma_addr_t dma ;
   u32 crc ;
   u32 pt_size ;
   u64 *pt_cpu ;
   dma_addr_t pt_dma ;
   u32 pos ;
   u32 actual_size ;
};
#line 332 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_port {
   struct saa7164_dev *dev ;
   enum port_t type ;
   int nr ;
   struct tmHWStreamParameters hw_streamingparams ;
   struct tmComResDMATermDescrHeader hwcfg ;
   u32 bufcounter ;
   u32 pitch ;
   u32 bufsize ;
   u32 bufoffset ;
   u32 bufptr32l ;
   u32 bufptr32h ;
   u64 bufptr64 ;
   u32 numpte ;
   struct mutex dmaqueue_lock ;
   struct saa7164_buffer dmaqueue ;
   u64 last_irq_msecs ;
   u64 last_svc_msecs ;
   u64 last_irq_msecs_diff ;
   u64 last_svc_msecs_diff ;
   u32 last_svc_wp ;
   u32 last_svc_rp ;
   u64 last_irq_svc_msecs_diff ;
   u64 last_read_msecs ;
   u64 last_read_msecs_diff ;
   u64 last_poll_msecs ;
   u64 last_poll_msecs_diff ;
   struct saa7164_histogram irq_interval ;
   struct saa7164_histogram svc_interval ;
   struct saa7164_histogram irq_svc_interval ;
   struct saa7164_histogram read_interval ;
   struct saa7164_histogram poll_interval ;
   struct saa7164_dvb dvb ;
   struct i2c_client *i2c_client_demod ;
   struct i2c_client *i2c_client_tuner ;
   struct saa7164_tvnorm encodernorm ;
   v4l2_std_id std ;
   u32 height ;
   u32 width ;
   u32 freq ;
   u32 ts_packet_size ;
   u32 ts_packet_count ;
   u8 mux_input ;
   u8 encoder_profile ;
   u8 video_format ;
   u8 audio_format ;
   u8 video_resolution ;
   u16 ctl_brightness ;
   u16 ctl_contrast ;
   u16 ctl_hue ;
   u16 ctl_saturation ;
   u16 ctl_sharpness ;
   s8 ctl_volume ;
   struct tmComResAFeatureDescrHeader audfeat ;
   struct tmComResEncoderDescrHeader encunit ;
   struct tmComResProcDescrHeader vidproc ;
   struct tmComResExtDevDescrHeader ifunit ;
   struct tmComResTunerDescrHeader tunerunit ;
   struct work_struct workenc ;
   struct saa7164_encoder_params encoder_params ;
   struct video_device *v4l_device ;
   atomic_t v4l_reader_count ;
   struct saa7164_buffer list_buf_used ;
   struct saa7164_buffer list_buf_free ;
   wait_queue_head_t wait_read ;
   struct tmComResVBIFormatDescrHeader vbi_fmt_ntsc ;
   struct saa7164_vbi_params vbi_params ;
   u32 sync_errors ;
   u32 v_cc_errors ;
   u32 a_cc_errors ;
   u8 last_v_cc ;
   u8 last_a_cc ;
   u32 done_first_interrupt ;
};
#line 431 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_dev {
   struct list_head devlist ;
   atomic_t refcount ;
   struct v4l2_device v4l2_dev ;
   struct pci_dev *pci ;
   unsigned char pci_rev ;
   unsigned char pci_lat ;
   int pci_bus ;
   int pci_slot ;
   u32 *lmmio ;
   u8 *bmmio ;
   u32 *lmmio2 ;
   u8 *bmmio2 ;
   int pci_irqmask ;
   int nr ;
   int hwrevision ;
   u32 board ;
   char name[16U] ;
   struct saa7164_fw_status fw_status ;
   u32 firmwareloaded ;
   struct tmComResHWDescr hwdesc ;
   struct tmComResInterfaceDescr intfdesc ;
   struct tmComResBusDescr busdesc ;
   struct tmComResBusInfo bus ;
   u32 int_status ;
   u32 int_ack ;
   bool msi ;
   struct cmd cmds[256U] ;
   struct mutex lock ;
   struct saa7164_i2c i2c_bus[3U] ;
   struct saa7164_port ports[6U] ;
   struct work_struct workcmd ;
   struct task_struct *kthread ;
};
#line 258 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 269 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
typedef bool ldv_func_ret_type___3;
#line 280 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
typedef bool ldv_func_ret_type___4;
#line 299 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
typedef bool ldv_func_ret_type___5;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 22 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 432 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmFwInfoStruct {
   u32 status ;
   u32 mode ;
   u32 devicespec ;
   u32 deviceinst ;
   u32 CPULoad ;
   u32 RemainHeap ;
   u32 CPUClock ;
   u32 RAMSpeed ;
};
#line 207 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_user_buffer {
   struct list_head list ;
   u8 *data ;
   u32 pos ;
   u32 actual_size ;
   u32 crc ;
};
#line 1390 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
typedef int ldv_func_ret_type___6;
#line 1403 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 1424 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
typedef int ldv_func_ret_type___8;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 42 "include/linux/i2c.h"
struct i2c_board_info;
#line 43
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 271 "include/linux/i2c.h"
struct i2c_board_info {
   char type[20U] ;
   unsigned short flags ;
   unsigned short addr ;
   void *platform_data ;
   struct dev_archdata *archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   int irq ;
};
#line 52 "include/linux/firmware.h"
struct tda10048_config {
   u8 demod_address ;
   u8 output_mode ;
   u8 fwbulkwritelen ;
   u8 inversion ;
   u16 dtv6_if_freq_khz ;
   u16 dtv7_if_freq_khz ;
   u16 dtv8_if_freq_khz ;
   u16 clk_freq_khz ;
   u8 disable_gate_access ;
   bool no_firmware ;
   bool set_pll ;
   u8 pll_m ;
   u8 pll_p ;
   u8 pll_n ;
};
#line 78 "./drivers/media/dvb-frontends/tda10048.h"
struct tda18271_std_map_item {
   u16 if_freq ;
   unsigned char agc_mode : 2 ;
   unsigned char std : 3 ;
   unsigned char fm_rfn : 1 ;
   unsigned char if_lvl : 3 ;
   unsigned char rfagc_top : 7 ;
};
#line 41 "./drivers/media/tuners/tda18271.h"
struct tda18271_std_map {
   struct tda18271_std_map_item fm_radio ;
   struct tda18271_std_map_item atv_b ;
   struct tda18271_std_map_item atv_dk ;
   struct tda18271_std_map_item atv_gh ;
   struct tda18271_std_map_item atv_i ;
   struct tda18271_std_map_item atv_l ;
   struct tda18271_std_map_item atv_lc ;
   struct tda18271_std_map_item atv_mn ;
   struct tda18271_std_map_item atsc_6 ;
   struct tda18271_std_map_item dvbt_6 ;
   struct tda18271_std_map_item dvbt_7 ;
   struct tda18271_std_map_item dvbt_8 ;
   struct tda18271_std_map_item qam_6 ;
   struct tda18271_std_map_item qam_7 ;
   struct tda18271_std_map_item qam_8 ;
};
#line 59
enum tda18271_role {
    TDA18271_MASTER = 0,
    TDA18271_SLAVE = 1
} ;
#line 64
enum tda18271_i2c_gate {
    TDA18271_GATE_AUTO = 0,
    TDA18271_GATE_ANALOG = 1,
    TDA18271_GATE_DIGITAL = 2
} ;
#line 70
enum tda18271_output_options {
    TDA18271_OUTPUT_LT_XT_ON = 0,
    TDA18271_OUTPUT_LT_OFF = 1,
    TDA18271_OUTPUT_XT_OFF = 2
} ;
#line 76
enum tda18271_small_i2c {
    TDA18271_39_BYTE_CHUNK_INIT = 0,
    TDA18271_16_BYTE_CHUNK_INIT = 16,
    TDA18271_08_BYTE_CHUNK_INIT = 8,
    TDA18271_03_BYTE_CHUNK_INIT = 3
} ;
#line 83 "./drivers/media/tuners/tda18271.h"
struct tda18271_config {
   struct tda18271_std_map *std_map ;
   enum tda18271_role role ;
   enum tda18271_i2c_gate gate ;
   enum tda18271_output_options output_opt ;
   enum tda18271_small_i2c small_i2c ;
   unsigned char rf_cal_on_startup : 1 ;
   unsigned char delay_cal : 1 ;
   unsigned int config ;
};
#line 126 "./drivers/media/tuners/tda18271.h"
struct s5h1411_config {
   u8 output_mode ;
   u8 gpio ;
   u16 mpeg_timing ;
   u16 qam_if ;
   u16 vsb_if ;
   u8 inversion ;
   u8 status_mode ;
};
#line 74 "./drivers/media/dvb-frontends/s5h1411.h"
struct si2157_config {
   struct dvb_frontend *fe ;
   bool inversion ;
   u8 if_port ;
};
#line 44 "./drivers/media/tuners/si2157.h"
struct si2168_config {
   struct dvb_frontend **fe ;
   struct i2c_adapter **i2c_adapter ;
   u8 ts_mode ;
   bool ts_clock_inv ;
   bool ts_clock_gapped ;
};
#line 49 "./drivers/media/dvb-frontends/si2168.h"
enum lgdt3306a_mpeg_mode {
    LGDT3306A_MPEG_PARALLEL = 0,
    LGDT3306A_MPEG_SERIAL = 1
} ;
#line 54
enum lgdt3306a_tp_clock_edge {
    LGDT3306A_TPCLK_RISING_EDGE = 0,
    LGDT3306A_TPCLK_FALLING_EDGE = 1
} ;
#line 59
enum lgdt3306a_tp_valid_polarity {
    LGDT3306A_TP_VALID_LOW = 0,
    LGDT3306A_TP_VALID_HIGH = 1
} ;
#line 64 "./drivers/media/dvb-frontends/si2168.h"
struct lgdt3306a_config {
   u8 i2c_addr ;
   u16 qam_if_khz ;
   u16 vsb_if_khz ;
   unsigned char deny_i2c_rptr : 1 ;
   unsigned char spectral_inversion : 1 ;
   enum lgdt3306a_mpeg_mode mpeg_mode ;
   enum lgdt3306a_tp_clock_edge tpclk_edge ;
   enum lgdt3306a_tp_valid_polarity tpvalid_polarity ;
   int xtalMHz ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 142 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 610 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct fw_header {
   u32 firmwaresize ;
   u32 bslsize ;
   u32 reserved ;
   u32 version ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 93 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResInfo {
   u8 id ;
   u8 flags ;
   u16 size ;
   u32 command ;
   u16 controlselector ;
   u8 seqno ;
};
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 103 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
enum tmComResCmd {
    SET_CUR = 1,
    GET_CUR = 129,
    GET_MIN = 130,
    GET_MAX = 131,
    GET_RES = 132,
    GET_LEN = 133,
    GET_INFO = 134,
    GET_DEF = 135
} ;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 129 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 unitid ;
};
#line 148 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResGPIO {
   u32 pin ;
   u8 state ;
};
#line 153 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResPathDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 pathid ;
};
#line 170 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResAntTermDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 terminalid ;
   u16 terminaltype ;
   u8 assocterminal ;
   u8 iterminal ;
   u8 controlsize ;
};
#line 255 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResTSFormatDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 bFormatIndex ;
   u8 bDataOffset ;
   u8 bPacketLength ;
   u8 bStrideLength ;
   u8 guidStrideFormat[16U] ;
};
#line 287 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResSelDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 unitid ;
   u8 nrinpins ;
   u8 sourceid ;
};
#line 310 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResEncVideoBitRate {
   u8 ucVideoBitRateMode ;
   u32 dwVideoBitRate ;
   u32 dwVideoBitRatePeak ;
};
#line 320 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResEncVideoInputAspectRatio {
   u8 width ;
   u8 height ;
};
#line 326 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResEncVideoGopStructure {
   u8 ucGOPSize ;
   u8 ucRefFrameDist ;
};
#line 366 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResAudioDefaults {
   u8 ucDecoderLevel ;
   u8 ucDecoderFM_Level ;
   u8 ucMonoLevel ;
   u8 ucNICAM_Level ;
   u8 ucSAP_Level ;
   u8 ucADC_Level ;
};
#line 376 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResEncAudioBitRate {
   u8 ucAudioBitRateMode ;
   u32 dwAudioBitRate ;
   u32 dwAudioBitRatePeak ;
};
#line 383 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResTunerStandard {
   u8 std ;
   u32 country ;
};
#line 389 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResTunerStandardAuto {
   u8 mode ;
};
#line 393 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResPSFormatDescrHeader {
   u8 len ;
   u8 type ;
   u8 subtype ;
   u8 bFormatIndex ;
   u16 wPacketLength ;
   u16 wPackLength ;
   u8 bPackDataType ;
};
#line 417 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResProbeCommit {
   u16 bmHint ;
   u8 bFormatIndex ;
   u8 bFrameIndex ;
};
#line 423 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResDebugSetLevel {
   u32 dwDebugLevel ;
};
#line 427 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164-types.h"
struct tmComResDebugGetData {
   u32 dwResult ;
   u8 ucDebugData[256U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 186 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_encoder_fh {
   struct saa7164_port *port ;
   atomic_t v4l_reading ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 191 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct saa7164_vbi_fh {
   struct saa7164_port *port ;
   atomic_t v4l_reading ;
};
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 8
extern void *memset(void * , int  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 429 "include/linux/workqueue.h"
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_15(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_17(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_16(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_25(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 18 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 35 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_irq_2_0  =    0;
#line 42 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_irq_2_2  =    0;
#line 58 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_irq_2_1  =    0;
#line 60 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_irq_1_3  =    0;
#line 67 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_irq_1_0  =    0;
#line 90 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_irq_1_2  =    0;
#line 91 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 92 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_irq_1_1  =    0;
#line 94 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_irq_2_3  =    0;
#line 115
void activate_work_3(struct work_struct *work , int state ) ;
#line 135
void call_and_disable_all_3(int state ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_33(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_41(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_35(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_39(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_40(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_36(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_37(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_38(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 48 "include/media/tveeprom.h"
extern void tveeprom_hauppauge_analog(struct i2c_client * , struct tveeprom * , unsigned char * ) ;
#line 538 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
int saa7164_api_read_eeprom(struct saa7164_dev *dev , u8 *buf , int buflen ) ;
#line 539
int saa7164_api_set_gpiobit(struct saa7164_dev *dev , u8 unitid , u8 pin ) ;
#line 540
int saa7164_api_clear_gpiobit(struct saa7164_dev *dev , u8 unitid , u8 pin ) ;
#line 563
struct saa7164_board saa7164_boards[14U] ;
#line 564
unsigned int const   saa7164_bcount ;
#line 566
struct saa7164_subid saa7164_subids[13U] ;
#line 567
unsigned int const   saa7164_idcount ;
#line 569
void saa7164_card_list(struct saa7164_dev *dev ) ;
#line 570
void saa7164_gpio_setup(struct saa7164_dev *dev ) ;
#line 571
void saa7164_card_setup(struct saa7164_dev *dev ) ;
#line 573
int saa7164_i2caddr_to_reglen(struct saa7164_i2c *bus , int addr ) ;
#line 574
int saa7164_i2caddr_to_unitid(struct saa7164_i2c *bus , int addr ) ;
#line 575
char *saa7164_unitid_name(struct saa7164_dev *dev , u8 unitid ) ;
#line 37 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
struct saa7164_board saa7164_boards[14U]  = 
#line 37 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
  {      {(char *)"Unknown", 0, 0, 0, 0, 0, 0, 0, {{0, (unsigned char)0, 0, 0, (unsigned char)0,
                                                (unsigned char)0}, {0, (unsigned char)0,
                                                                    0, 0, (unsigned char)0,
                                                                    (unsigned char)0},
                                               {0, (unsigned char)0, 0, 0, (unsigned char)0,
                                                (unsigned char)0}, {0, (unsigned char)0,
                                                                    0, 0, (unsigned char)0,
                                                                    (unsigned char)0},
                                               {0, (unsigned char)0, 0, 0, (unsigned char)0,
                                                (unsigned char)0}, {0, (unsigned char)0,
                                                                    0, 0, (unsigned char)0,
                                                                    (unsigned char)0},
                                               {0, (unsigned char)0, 0, 0, (unsigned char)0,
                                                (unsigned char)0}, {0, (unsigned char)0,
                                                                    0, 0, (unsigned char)0,
                                                                    (unsigned char)0}}}, 
        {(char *)"Generic Rev2",
      0, 0, 0, 0, 0, 0, 1, {{0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0}}}, 
        {(char *)"Generic Rev3",
      0, 0, 0, 0, 0, 0, 2, {{0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0},
                            {0, (unsigned char)0, 0, 0, (unsigned char)0, (unsigned char)0}}}, 
        {(char *)"Hauppauge WinTV-HVR2250",
      1, 1, 2, 2, 3, 3, 2, {{4, 34U, (char *)"4K EEPROM", 0, 80U, 1U}, {3, 4U, (char *)"TDA18271-1",
                                                                        1, 96U, 1U},
                            {1, 7U, (char *)"CX24228/S5H1411-1 (TOP)", 1, 25U, 1U},
                            {1, 8U, (char *)"CX24228/S5H1411-1 (QAM)", 1, 26U, 1U},
                            {3, 30U, (char *)"TDA18271-2", 2, 96U, 1U}, {1, 32U, (char *)"CX24228/S5H1411-2 (TOP)",
                                                                         2, 25U, 1U},
                            {1, 35U, (char *)"CX24228/S5H1411-2 (QAM)", 2, 26U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2200",
      1, 1, 2, 2, 3, 3, 2, {{4, 29U, (char *)"4K EEPROM", 0, 80U, 1U}, {3, 4U, (char *)"TDA18271-1",
                                                                        1, 96U, 1U},
                            {3, 27U, (char *)"TDA18271-2", 2, 96U, 1U}, {1, 30U, (char *)"TDA10048-1",
                                                                         1, 8U, 1U},
                            {1, 31U, (char *)"TDA10048-2", 2, 9U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2200", 1, 1, 2, 2, 3, 3, 1, {{4, 6U, (char *)"4K EEPROM",
                                                                0, 80U, 1U}, {3, 4U,
                                                                              (char *)"TDA18271-1",
                                                                              1, 96U,
                                                                              1U},
                                                               {1, 5U, (char *)"TDA10048-1",
                                                                1, 8U, 1U}, {3, 30U,
                                                                             (char *)"TDA18271-2",
                                                                             2, 96U,
                                                                             1U},
                                                               {1, 31U, (char *)"TDA10048-2",
                                                                2, 9U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2200", 1, 1, 2, 2, 3, 3, 1, {{4, 29U, (char *)"4K EEPROM",
                                                                0, 80U, 1U}, {3, 4U,
                                                                              (char *)"TDA18271-1",
                                                                              1, 96U,
                                                                              1U},
                                                               {2, 5U, (char *)"TDA8290-1",
                                                                1, 66U, 1U}, {3, 27U,
                                                                              (char *)"TDA18271-2",
                                                                              2, 96U,
                                                                              1U},
                                                               {2, 28U, (char *)"TDA8290-2",
                                                                2, 66U, 1U}, {1, 30U,
                                                                              (char *)"TDA10048-1",
                                                                              1, 8U,
                                                                              1U},
                                                               {1, 31U, (char *)"TDA10048-2",
                                                                2, 9U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2250", 1, 1, 2, 2, 3, 3, 2, {{4, 40U, (char *)"4K EEPROM",
                                                                0, 80U, 1U}, {3, 4U,
                                                                              (char *)"TDA18271-1",
                                                                              1, 96U,
                                                                              1U},
                                                               {1, 7U, (char *)"CX24228/S5H1411-1 (TOP)",
                                                                1, 25U, 1U}, {1, 8U,
                                                                              (char *)"CX24228/S5H1411-1 (QAM)",
                                                                              1, 26U,
                                                                              1U},
                                                               {3, 36U, (char *)"TDA18271-2",
                                                                2, 96U, 1U}, {1, 38U,
                                                                              (char *)"CX24228/S5H1411-2 (TOP)",
                                                                              2, 25U,
                                                                              1U},
                                                               {1, 41U, (char *)"CX24228/S5H1411-2 (QAM)",
                                                                2, 26U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2250", 1, 1, 2, 2, 3, 3, 2, {{4, 38U, (char *)"4K EEPROM",
                                                                0, 80U, 1U}, {3, 4U,
                                                                              (char *)"TDA18271-1",
                                                                              1, 96U,
                                                                              1U},
                                                               {1, 7U, (char *)"CX24228/S5H1411-1 (TOP)",
                                                                1, 25U, 1U}, {1, 8U,
                                                                              (char *)"CX24228/S5H1411-1 (QAM)",
                                                                              1, 26U,
                                                                              1U},
                                                               {3, 34U, (char *)"TDA18271-2",
                                                                2, 96U, 1U}, {1, 36U,
                                                                              (char *)"CX24228/S5H1411-2 (TOP)",
                                                                              2, 25U,
                                                                              1U},
                                                               {1, 39U, (char *)"CX24228/S5H1411-2 (QAM)",
                                                                2, 26U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2200", 1, 1, 2, 2, 3, 3, 2, {{4, 29U, (char *)"4K EEPROM",
                                                                0, 80U, 1U}, {3, 4U,
                                                                              (char *)"TDA18271-1",
                                                                              1, 96U,
                                                                              1U},
                                                               {2, 5U, (char *)"TDA8290-1",
                                                                1, 66U, 1U}, {3, 27U,
                                                                              (char *)"TDA18271-2",
                                                                              2, 96U,
                                                                              1U},
                                                               {2, 28U, (char *)"TDA8290-2",
                                                                2, 66U, 1U}, {1, 30U,
                                                                              (char *)"TDA10048-1",
                                                                              1, 8U,
                                                                              1U},
                                                               {1, 31U, (char *)"TDA10048-2",
                                                                2, 9U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2200", 1, 1, 0, 0, 0, 0, 2, {{4, 35U, (char *)"4K EEPROM",
                                                                0, 80U, 1U}, {3, 4U,
                                                                              (char *)"TDA18271-1",
                                                                              1, 96U,
                                                                              1U},
                                                               {2, 5U, (char *)"TDA8290-1",
                                                                1, 66U, 1U}, {3, 33U,
                                                                              (char *)"TDA18271-2",
                                                                              2, 96U,
                                                                              1U},
                                                               {2, 34U, (char *)"TDA8290-2",
                                                                2, 66U, 1U}, {1, 36U,
                                                                              (char *)"TDA10048-1",
                                                                              1, 8U,
                                                                              1U},
                                                               {1, 37U, (char *)"TDA10048-2",
                                                                2, 9U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2255(proto)", 1, 1, 2, 2, 3, 3, 2, {{4, 39U, (char *)"4K EEPROM",
                                                                       0, 80U, 1U},
                                                                      {3, 4U, (char *)"SI2157-1",
                                                                       0, 96U, 0U},
                                                                      {1, 6U, (char *)"LGDT3306",
                                                                       2, 89U, 1U},
                                                                      {3, 36U, (char *)"SI2157-2",
                                                                       1, 96U, 0U},
                                                                      {1, 38U, (char *)"LGDT3306-2",
                                                                       2, 14U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2255",
      1, 1, 2, 2, 3, 3, 2, {{4, 40U, (char *)"4K EEPROM", 0, 80U, 1U}, {3, 4U, (char *)"SI2157-1",
                                                                        0, 96U, 0U},
                            {1, 6U, (char *)"LGDT3306-1", 2, 89U, 1U}, {3, 37U, (char *)"SI2157-2",
                                                                        1, 96U, 0U},
                            {1, 39U, (char *)"LGDT3306-2", 2, 14U, 1U}}}, 
        {(char *)"Hauppauge WinTV-HVR2205", 1, 1, 2, 2, 3, 3, 2, {{4, 40U, (char *)"4K EEPROM",
                                                                0, 80U, 1U}, {3, 4U,
                                                                              (char *)"SI2157-1",
                                                                              0, 96U,
                                                                              0U},
                                                               {1, 6U, (char *)"SI2168-1",
                                                                2, 100U, 0U}, {3,
                                                                               37U,
                                                                               (char *)"SI2157-2",
                                                                               1,
                                                                               96U,
                                                                               0U},
                                                               {1, 39U, (char *)"SI2168-2",
                                                                2, 102U, 0U}}}};
#line 642 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
unsigned int const   saa7164_bcount  =    14U;
#line 647 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
struct saa7164_subid saa7164_subids[13U]  = 
#line 647
  {      {112U, 34944U, 3U}, 
        {112U, 34832U, 3U}, 
        {112U, 35200U, 4U}, 
        {112U, 35072U, 5U}, 
        {112U, 35073U, 6U}, 
        {112U, 34977U, 8U}, 
        {112U, 34961U, 7U}, 
        {112U, 34897U, 7U}, 
        {112U, 35136U, 9U}, 
        {112U, 35155U, 10U}, 
        {112U, 61713U, 12U}, 
        {112U, 61731U, 13U}, 
        {112U, 61728U, 13U}};
#line 705 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
unsigned int const   saa7164_idcount  =    13U;
#line 707 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
void saa7164_card_list(struct saa7164_dev *dev ) 
{ 
  int i ;

  {
#line 711
  if ((unsigned int )(dev->pci)->subsystem_vendor == 0U && (unsigned int )(dev->pci)->subsystem_device == 0U) {
#line 713
    printk("\v%s: Board has no valid PCIe Subsystem ID and can\'t\n%s: be autodetected. Pass card=<n> insmod option to\n%s: workaround that. Send complaints to the vendor\n%s: of the TV card. Best regards,\n%s:         -- tux\n",
           (char *)(& dev->name), (char *)(& dev->name), (char *)(& dev->name), (char *)(& dev->name),
           (char *)(& dev->name));
  } else {
#line 721
    printk("\v%s: Your board isn\'t known (yet) to the driver.\n%s: Try to pick one of the existing card configs via\n%s: card=<n> insmod option.  Updating to the latest\n%s: version might help as well.\n",
           (char *)(& dev->name), (char *)(& dev->name), (char *)(& dev->name), (char *)(& dev->name));
  }
#line 729
  printk("\v%s: Here are valid choices for the card=<n> insmod option:\n", (char *)(& dev->name));
#line 732
  i = 0;
#line 732
  goto ldv_51802;
  ldv_51801: 
#line 733
  printk("\v%s:    card=%d -> %s\n", (char *)(& dev->name), i, saa7164_boards[i].name);
#line 732
  i = i + 1;
  ldv_51802: ;
#line 732
  if ((unsigned int )i < (unsigned int )saa7164_bcount) {
#line 734
    goto ldv_51801;
  } else {

  }

#line 739
  return;
}
}
#line 740 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
void saa7164_gpio_setup(struct saa7164_dev *dev ) 
{ 


  {
#line 742
  switch (dev->board) {
  case 4U: ;
  case 5U: ;
  case 6U: ;
  case 9U: ;
  case 10U: ;
  case 3U: ;
  case 7U: ;
  case 8U: ;
  case 11U: ;
  case 12U: ;
  case 13U: 
#line 772
  saa7164_api_clear_gpiobit(dev, 2, 2);
#line 773
  saa7164_api_clear_gpiobit(dev, 2, 3);
#line 775
  msleep(20U);
#line 777
  saa7164_api_set_gpiobit(dev, 2, 2);
#line 778
  saa7164_api_set_gpiobit(dev, 2, 3);
#line 779
  goto ldv_51818;
  }
  ldv_51818: ;
#line 782
  return;
}
}
#line 783 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
static void hauppauge_eeprom(struct saa7164_dev *dev , u8 *eeprom_data ) 
{ 
  struct tveeprom tv ;

  {
#line 788
  tveeprom_hauppauge_analog(& dev->i2c_bus[0].i2c_client, & tv, eeprom_data);
#line 792
  switch (tv.model) {
  case 88001U: ;
  case 88021U: ;
#line 800
  goto ldv_51826;
  case 88041U: ;
#line 804
  goto ldv_51826;
  case 88061U: ;
#line 808
  goto ldv_51826;
  case 89519U: ;
  case 89609U: ;
#line 813
  goto ldv_51826;
  case 89619U: ;
#line 817
  goto ldv_51826;
  case 151009U: ;
#line 822
  goto ldv_51826;
  case 151609U: ;
#line 827
  goto ldv_51826;
  case 151061U: ;
#line 832
  goto ldv_51826;
  default: 
#line 834
  printk("\v%s: Warning: Unknown Hauppauge model #%d\n", (char *)(& dev->name), tv.model);
#line 836
  goto ldv_51826;
  }
  ldv_51826: 
#line 839
  printk("\016%s: Hauppauge eeprom: model=%d\n", (char *)(& dev->name), tv.model);
#line 841
  return;
}
}
#line 843 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
void saa7164_card_setup(struct saa7164_dev *dev ) 
{ 
  u8 eeprom[256U] ;
  int tmp ;

  {
#line 847
  if (dev->i2c_bus[0].i2c_rc == 0U) {
#line 848
    tmp = saa7164_api_read_eeprom(dev, (u8 *)(& eeprom), 256);
#line 848
    if (tmp < 0) {
#line 850
      return;
    } else {

    }
  } else {

  }
#line 853
  switch (dev->board) {
  case 4U: ;
  case 5U: ;
  case 6U: ;
  case 9U: ;
  case 10U: ;
  case 3U: ;
  case 7U: ;
  case 8U: ;
  case 11U: ;
  case 12U: ;
  case 13U: 
#line 865
  hauppauge_eeprom(dev, (u8 *)(& eeprom));
#line 866
  goto ldv_51851;
  }
  ldv_51851: ;
#line 869
  return;
}
}
#line 883 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
int saa7164_i2caddr_to_unitid(struct saa7164_i2c *bus , int addr ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_unit *unit ;
  int i ;

  {
#line 888
  dev = bus->dev;
#line 892
  i = 0;
#line 892
  goto ldv_51861;
  ldv_51860: 
#line 893
  unit = (struct saa7164_unit *)(& saa7164_boards[dev->board].unit) + (unsigned long )i;
#line 895
  if ((unsigned int )unit->type == 0U) {
#line 896
    goto ldv_51859;
  } else {

  }
#line 897
  if ((unsigned int )bus->nr == (unsigned int )unit->i2c_bus_nr && (int )unit->i2c_bus_addr == addr) {
#line 899
    return ((int )unit->id);
  } else {

  }
  ldv_51859: 
#line 892
  i = i + 1;
  ldv_51861: ;
#line 892
  if (i <= 7) {
#line 894
    goto ldv_51860;
  } else {

  }

#line 902
  return (-1);
}
}
#line 909 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
int saa7164_i2caddr_to_reglen(struct saa7164_i2c *bus , int addr ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_unit *unit ;
  int i ;

  {
#line 915
  dev = bus->dev;
#line 919
  i = 0;
#line 919
  goto ldv_51872;
  ldv_51871: 
#line 920
  unit = (struct saa7164_unit *)(& saa7164_boards[dev->board].unit) + (unsigned long )i;
#line 922
  if ((unsigned int )unit->type == 0U) {
#line 923
    goto ldv_51870;
  } else {

  }
#line 925
  if ((unsigned int )bus->nr == (unsigned int )unit->i2c_bus_nr && (int )unit->i2c_bus_addr == addr) {
#line 927
    return ((int )unit->i2c_reg_len);
  } else {

  }
  ldv_51870: 
#line 919
  i = i + 1;
  ldv_51872: ;
#line 919
  if (i <= 7) {
#line 921
    goto ldv_51871;
  } else {

  }

#line 930
  return (-1);
}
}
#line 937 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.c"
char *saa7164_unitid_name(struct saa7164_dev *dev , u8 unitid ) 
{ 
  char *undefed ;
  char *bridge ;
  struct saa7164_unit *unit ;
  int i ;

  {
#line 939
  undefed = (char *)"UNDEFINED";
#line 940
  bridge = (char *)"BRIDGE";
#line 944
  if ((unsigned int )unitid == 0U) {
#line 945
    return (bridge);
  } else {

  }
#line 947
  i = 0;
#line 947
  goto ldv_51884;
  ldv_51883: 
#line 948
  unit = (struct saa7164_unit *)(& saa7164_boards[dev->board].unit) + (unsigned long )i;
#line 950
  if ((unsigned int )unit->type == 0U) {
#line 951
    goto ldv_51882;
  } else {

  }
#line 953
  if ((int )unit->id == (int )unitid) {
#line 954
    return (unit->name);
  } else {

  }
  ldv_51882: 
#line 947
  i = i + 1;
  ldv_51884: ;
#line 947
  if (i <= 7) {
#line 949
    goto ldv_51883;
  } else {

  }

#line 957
  return (undefed);
}
}
#line 256 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
bool ldv_queue_work_on_15(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 260
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 260
  ldv_func_res = tmp;
#line 262
  activate_work_3(ldv_func_arg3, 2);
#line 264
  return (ldv_func_res);
}
}
#line 267 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
bool ldv_queue_delayed_work_on_16(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 271
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 271
  ldv_func_res = tmp;
#line 273
  activate_work_3(& ldv_func_arg3->work, 2);
#line 275
  return (ldv_func_res);
}
}
#line 278 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
bool ldv_queue_work_on_17(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 282
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 282
  ldv_func_res = tmp;
#line 284
  activate_work_3(ldv_func_arg3, 2);
#line 286
  return (ldv_func_res);
}
}
#line 289 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
void ldv_flush_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 292
  flush_workqueue(ldv_func_arg1);
#line 294
  call_and_disable_all_3(2);
#line 295
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
bool ldv_queue_delayed_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 301
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 301
  ldv_func_res = tmp;
#line 303
  activate_work_3(& ldv_func_arg3->work, 2);
#line 305
  return (ldv_func_res);
}
}
#line 343 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
void *ldv_kmem_cache_alloc_25(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 346
  ldv_check_alloc_flags(flags);
#line 347
  tmp = ldv_undef_ptr();
#line 347
  return (tmp);
}
}
#line 385 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 388
  ldv_check_alloc_flags(flags);
#line 389
  tmp = ldv_undef_ptr();
#line 389
  return ((int )((long )tmp));
}
}
#line 399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
struct sk_buff *ldv_skb_clone_33(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 402
  ldv_check_alloc_flags(flags);
#line 403
  tmp = ldv_undef_ptr();
#line 403
  return ((struct sk_buff *)tmp);
}
}
#line 413 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
struct sk_buff *ldv_skb_copy_35(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 416
  ldv_check_alloc_flags(flags);
#line 417
  tmp = ldv_undef_ptr();
#line 417
  return ((struct sk_buff *)tmp);
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_36(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 423
  ldv_check_alloc_flags(flags);
#line 424
  tmp = ldv_undef_ptr();
#line 424
  return ((struct sk_buff *)tmp);
}
}
#line 427 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_37(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 430
  ldv_check_alloc_flags(flags);
#line 431
  tmp = ldv_undef_ptr();
#line 431
  return ((struct sk_buff *)tmp);
}
}
#line 434 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_38(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 438
  tmp = ldv_undef_ptr();
#line 438
  return ((struct sk_buff *)tmp);
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_pskb_expand_head_39(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 444
  ldv_check_alloc_flags(flags);
#line 445
  tmp = ldv_undef_ptr();
#line 445
  return ((int )((long )tmp));
}
}
#line 448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
int ldv_pskb_expand_head_40(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 451
  ldv_check_alloc_flags(flags);
#line 452
  tmp = ldv_undef_ptr();
#line 452
  return ((int )((long )tmp));
}
}
#line 455 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cards.o.c.prepared"
struct sk_buff *ldv_skb_clone_41(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 459
  tmp = ldv_undef_ptr();
#line 459
  return ((struct sk_buff *)tmp);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 3 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 113
extern void list_del(struct list_head * ) ;
#line 165 "include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 168
  __list_del_entry(list);
#line 169
  list_add_tail(list, head);
#line 170
  return;
}
}
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3233;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3233: ;
#line 14
  return (pfo_ret__);
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 65
extern char *strcpy(char * , char const   * ) ;
#line 41 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 116 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  char c ;

  {
#line 118
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 118
  return ((int )((signed char )c) != 0);
}
}
#line 54 "include/linux/debug_locks.h"
extern void debug_check_no_locks_held(void) ;
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 138
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 284
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 352
extern struct workqueue_struct *system_wq ;
#line 433
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_61(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 528 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 530
  tmp = queue_work(system_wq, work);
#line 530
  return (tmp);
}
}
#line 139 "include/linux/ioport.h"
extern struct resource iomem_resource ;
#line 192
extern struct resource *__request_region(struct resource * , resource_size_t  , resource_size_t  ,
                                         char const   * , int  ) ;
#line 201
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 56 "./arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
#line 56
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
#line 56
  return (ret);
}
}
#line 58 "./arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 58
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 58
  return (ret);
}
}
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 181
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 190 "./arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
#line 192
  tmp = ioremap_nocache(offset, size);
#line 192
  return (tmp);
}
}
#line 195
extern void iounmap(void volatile   * ) ;
#line 215 "./arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ 


  {
#line 217
  memcpy(dst, (void const   *)src, count);
#line 218
  return;
}
}
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 2410 "include/linux/sched.h"
extern int wake_up_process(struct task_struct * ) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 293
void *ldv_kmem_cache_alloc_71(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 28 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_8  ;
#line 29 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int pci_counter  ;
#line 30 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 31 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_5_2  ;
#line 32 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_0  ;
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_5  ;
#line 34 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_5_3  ;
#line 36 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_12  ;
#line 37 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_3_2  ;
#line 38 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_3_0  ;
#line 39 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct file *vbi_fops_group0  ;
#line 40 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct inode *saa7164_proc_fops_group1  ;
#line 41 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_irq_data_2_3  ;
#line 43 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_4_3  ;
#line 44 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct v4l2_format *mpeg_ioctl_ops_group1  ;
#line 45 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_9  ;
#line 46 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_line_2_0  ;
#line 47 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ref_cnt  ;
#line 48 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_line_1_1  ;
#line 49 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_irq_data_2_2  ;
#line 50 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_3_3  ;
#line 51 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_4_0  ;
#line 52 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_1  ;
#line 53 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_7  ;
#line 54 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_5_3  ;
#line 55 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_line_1_2  ;
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 57 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_line_2_3  ;
#line 59 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_irq_data_2_1  ;
#line 61 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_irq_data_1_1  ;
#line 62 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_line_2_2  ;
#line 63 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_10  ;
#line 64 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct file *mpeg_ioctl_ops_group3  ;
#line 65 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct file *saa7164_proc_fops_group2  ;
#line 66 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct v4l2_format *vbi_ioctl_ops_group2  ;
#line 68 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct i2c_adapter *saa7164_i2c_algo_template_group0  ;
#line 69 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_4_0  ;
#line 70 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 71 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_6  ;
#line 72 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_irq_data_1_0  ;
#line 73 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct pci_dev *saa7164_pci_driver_group1  ;
#line 74 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_4_1  ;
#line 75 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_4_3  ;
#line 76 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_3_1  ;
#line 77 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct v4l2_control *mpeg_ioctl_ops_group0  ;
#line 78 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_line_2_1  ;
#line 79 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_5_0  ;
#line 80 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_irq_data_1_3  ;
#line 81 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_2  ;
#line 82 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_5_1  ;
#line 83 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_4_2  ;
#line 84 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_irq_data_1_2  ;
#line 85 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_irq_data_2_0  ;
#line 86 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 87 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_4_2  ;
#line 88 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct file *mpeg_fops_group0  ;
#line 89 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_11  ;
#line 93 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct v4l2_control *vbi_ioctl_ops_group0  ;
#line 96 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_5_0  ;
#line 97 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct file *vbi_ioctl_ops_group3  ;
#line 98 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_5_1  ;
#line 99 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_line_1_3  ;
#line 100 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_work_5_2  ;
#line 101 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_3  ;
#line 102 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct v4l2_ext_controls *vbi_ioctl_ops_group1  ;
#line 103 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_line_1_0  ;
#line 104 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct work_struct *ldv_work_struct_4_1  ;
#line 105 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct v4l2_ext_controls *mpeg_ioctl_ops_group2  ;
#line 106 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_state_variable_4  ;
#line 107
void activate_work_5(struct work_struct *work , int state ) ;
#line 108
void work_init_3(void) ;
#line 109
void choose_interrupt_2(void) ;
#line 110
void disable_suitable_irq_2(int line , void *data ) ;
#line 111
void activate_work_4(struct work_struct *work , int state ) ;
#line 112
void call_and_disable_all_5(int state ) ;
#line 113
void ldv_initialize_v4l2_file_operations_7(void) ;
#line 114
void activate_suitable_irq_2(int line , void *data ) ;
#line 115
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
#line 117
void work_init_5(void) ;
#line 118
void ldv_initialize_v4l2_ioctl_ops_6(void) ;
#line 119
void call_and_disable_all_4(int state ) ;
#line 120
void ldv_initialize_i2c_algorithm_10(void) ;
#line 121
void choose_interrupt_1(void) ;
#line 122
void invoke_work_5(void) ;
#line 123
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) ;
#line 124
void disable_work_5(struct work_struct *work ) ;
#line 125
void call_and_disable_work_3(struct work_struct *work ) ;
#line 126
void disable_work_3(struct work_struct *work ) ;
#line 127
void disable_work_4(struct work_struct *work ) ;
#line 128
void work_init_4(void) ;
#line 129
void invoke_work_3(void) ;
#line 130
void disable_suitable_irq_1(int line , void *data ) ;
#line 131
int ldv_irq_1(int state , int line , void *data ) ;
#line 132
void activate_suitable_irq_1(int line , void *data ) ;
#line 134
void invoke_work_4(void) ;
#line 135
void call_and_disable_work_5(struct work_struct *work ) ;
#line 137
void ldv_pci_driver_11(void) ;
#line 138
void ldv_initialize_v4l2_file_operations_9(void) ;
#line 139
void call_and_disable_work_4(struct work_struct *work ) ;
#line 140
void ldv_initialize_v4l2_ioctl_ops_8(void) ;
#line 141
int ldv_irq_2(int state , int line , void *data ) ;
#line 142
void ldv_file_operations_12(void) ;
#line 127 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 132 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 135
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
#line 135
  return (tmp);
}
}
#line 141
__inline static int ldv_request_irq_88(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 145
__inline static int ldv_request_irq_89(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 154
extern void free_irq(unsigned int  , void * ) ;
#line 157
void ldv_free_irq_90(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 47 "include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 25 "include/linux/proc_fs.h"
extern struct proc_dir_entry *proc_create_data(char const   * , umode_t  , struct proc_dir_entry * ,
                                               struct file_operations  const  * ,
                                               void * ) ;
#line 30 "include/linux/proc_fs.h"
__inline static struct proc_dir_entry *proc_create(char const   *name , umode_t mode ,
                                                   struct proc_dir_entry *parent ,
                                                   struct file_operations  const  *proc_fops ) 
{ 
  struct proc_dir_entry *tmp ;

  {
#line 34
  tmp = proc_create_data(name, (int )mode, parent, proc_fops, (void *)0);
#line 34
  return (tmp);
}
}
#line 42
extern void remove_proc_entry(char const   * , struct proc_dir_entry * ) ;
#line 114 "include/linux/seq_file.h"
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 115
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 122
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 131
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
#line 133
extern int single_release(struct inode * , struct file * ) ;
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 1084
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 857 "include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 881 "include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
#line 883
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
#line 883
  return (tmp);
}
}
#line 949
extern int pci_enable_device(struct pci_dev * ) ;
#line 966
extern void pci_disable_device(struct pci_dev * ) ;
#line 969
extern void pci_set_master(struct pci_dev * ) ;
#line 1140
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1144
int ldv___pci_register_driver_91(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1153
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1156
void ldv_pci_unregister_driver_92(struct pci_driver *ldv_func_arg1 ) ;
#line 1209
extern void pci_disable_msi(struct pci_dev * ) ;
#line 1216
extern int pci_enable_msi_range(struct pci_dev * , int  , int  ) ;
#line 1217 "include/linux/pci.h"
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec ) 
{ 
  int rc ;
  int tmp ;

  {
#line 1219
  tmp = pci_enable_msi_range(dev, nvec, nvec);
#line 1219
  rc = tmp;
#line 1220
  if (rc < 0) {
#line 1221
    return (rc);
  } else {

  }
#line 1222
  return (0);
}
}
#line 60 "./arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 10 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_supported(struct pci_dev *hwdev , u64 mask ) 
{ 
  int tmp ;

  {
#line 12
  tmp = dma_supported((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                      mask);
#line 12
  return (tmp);
}
}
#line 1468 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1470
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1470
  return (tmp);
}
}
#line 1473 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1475
  dev_set_drvdata(& pdev->dev, data);
#line 1476
  return;
}
}
#line 1481 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1483
  tmp = dev_name(& pdev->dev);
#line 1483
  return (tmp);
}
}
#line 11 "include/linux/crc32.h"
extern u32 crc32_le(u32  , unsigned char const   * , size_t  ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 12 "include/linux/freezer.h"
extern atomic_t system_freezing_cnt ;
#line 29
extern bool freezing_slow_path(struct task_struct * ) ;
#line 34 "include/linux/freezer.h"
__inline static bool freezing(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 36
  tmp = atomic_read((atomic_t const   *)(& system_freezing_cnt));
#line 36
  tmp___0 = ldv__builtin_expect(tmp == 0, 1L);
#line 36
  if (tmp___0 != 0L) {
#line 37
    return (0);
  } else {

  }
#line 38
  tmp___1 = freezing_slow_path(p);
#line 38
  return (tmp___1);
}
}
#line 44
extern bool __refrigerator(bool  ) ;
#line 54 "include/linux/freezer.h"
__inline static bool try_to_freeze_unsafe(void) 
{ 
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;

  {
#line 56
  __might_sleep("include/linux/freezer.h", 56, 0);
#line 57
  tmp = get_current();
#line 57
  tmp___0 = freezing(tmp);
#line 57
  if (tmp___0) {
#line 57
    tmp___1 = 0;
  } else {
#line 57
    tmp___1 = 1;
  }
#line 57
  tmp___2 = ldv__builtin_expect((long )tmp___1, 1L);
#line 57
  if (tmp___2 != 0L) {
#line 58
    return (0);
  } else {

  }
#line 59
  tmp___3 = __refrigerator(0);
#line 59
  return (tmp___3);
}
}
#line 62 "include/linux/freezer.h"
__inline static bool try_to_freeze(void) 
{ 
  struct task_struct *tmp ;
  bool tmp___0 ;

  {
#line 64
  tmp = get_current();
#line 64
  if ((tmp->flags & 32768U) == 0U) {
#line 65
    debug_check_no_locks_held();
  } else {

  }
#line 66
  tmp___0 = try_to_freeze_unsafe();
#line 66
  return (tmp___0);
}
}
#line 70
extern bool set_freezable(void) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_79(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_87(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_81(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_77(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_85(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_82(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_83(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_84(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 143 "./drivers/media/dvb-core/dvb_demux.h"
extern void dvb_dmx_swfilter_packets(struct dvb_demux * , u8 const   * , size_t  ) ;
#line 77 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 104
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 488 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
struct list_head saa7164_devlist ;
#line 489
unsigned int waitsecs ;
#line 490
unsigned int encoder_buffers ;
#line 491
unsigned int vbi_buffers ;
#line 495
void saa7164_dumpregs(struct saa7164_dev *dev , u32 addr ) ;
#line 496
void saa7164_getfirmwarestatus(struct saa7164_dev *dev ) ;
#line 497
u32 saa7164_getcurrentfirmwareversion(struct saa7164_dev *dev ) ;
#line 498
void saa7164_histogram_update(struct saa7164_histogram *hg , u32 val ) ;
#line 502
int saa7164_downloadfirmware(struct saa7164_dev *dev ) ;
#line 506
int saa7164_i2c_register(struct saa7164_i2c *bus ) ;
#line 507
int saa7164_i2c_unregister(struct saa7164_i2c *bus ) ;
#line 513
int saa7164_bus_setup(struct saa7164_dev *dev ) ;
#line 514
void saa7164_bus_dump(struct saa7164_dev *dev ) ;
#line 526
int saa7164_irq_dequeue(struct saa7164_dev *dev ) ;
#line 530
int saa7164_api_get_fw_version(struct saa7164_dev *dev , u32 *version ) ;
#line 531
int saa7164_api_enum_subdevs(struct saa7164_dev *dev ) ;
#line 556
int saa7164_api_set_debug(struct saa7164_dev *dev , u8 level ) ;
#line 557
int saa7164_api_collect_debug(struct saa7164_dev *dev ) ;
#line 558
int saa7164_api_get_load_info(struct saa7164_dev *dev , struct tmFwInfoStruct *i ) ;
#line 579
int saa7164_dvb_register(struct saa7164_port *port ) ;
#line 580
int saa7164_dvb_unregister(struct saa7164_port *port ) ;
#line 593
int saa7164_buffer_zero_offsets(struct saa7164_port *port , int i ) ;
#line 597
int saa7164_encoder_register(struct saa7164_port *port ) ;
#line 598
void saa7164_encoder_unregister(struct saa7164_port *port ) ;
#line 602
int saa7164_vbi_register(struct saa7164_port *port ) ;
#line 603
void saa7164_vbi_unregister(struct saa7164_port *port ) ;
#line 607
unsigned int crc_checking ;
#line 609 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
unsigned int saa_debug  ;
#line 55 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static unsigned int fw_debug  ;
#line 59 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
unsigned int encoder_buffers  =    64U;
#line 63 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
unsigned int vbi_buffers  =    64U;
#line 67 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
unsigned int waitsecs  =    10U;
#line 71 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static unsigned int card[8U]  = 
#line 71
  {      4294967295U,      4294967295U,      4294967295U,      4294967295U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 75 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static unsigned int print_histogram  =    64U;
#line 79 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
unsigned int crc_checking  =    1U;
#line 83 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static unsigned int guard_checking  =    1U;
#line 88 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static bool enable_msi  =    1;
#line 93 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static unsigned int saa7164_devcount  ;
#line 95 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static struct mutex devlist  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "devlist.wait_lock",
                                                          0, 0UL}}}}, {& devlist.wait_list,
                                                                       & devlist.wait_list},
    0, (void *)(& devlist), {0, {0, 0}, "devlist", 0, 0UL}};
#line 96 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
struct list_head saa7164_devlist  =    {& saa7164_devlist, & saa7164_devlist};
#line 100 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_pack_verifier(struct saa7164_buffer *buf ) 
{ 
  u8 *p ;
  int i ;

  {
#line 102
  p = (u8 *)buf->cpu;
#line 105
  i = 0;
#line 105
  goto ldv_52123;
  ldv_52122: ;
#line 107
  if ((((unsigned int )*(p + (unsigned long )i) != 0U || (unsigned int )*(p + ((unsigned long )i + 1UL)) != 0U) || (unsigned int )*(p + ((unsigned long )i + 2UL)) != 1U) || (unsigned int )*(p + ((unsigned long )i + 3UL)) != 186U) {
#line 109
    printk("\vNo pack at 0x%x\n", i);
  } else {

  }
#line 105
  i = i + 2048;
  ldv_52123: ;
#line 105
  if ((u32 )i < buf->actual_size) {
#line 107
    goto ldv_52122;
  } else {

  }

#line 112
  return;
}
}
#line 121 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_ts_verifier(struct saa7164_buffer *buf ) 
{ 
  struct saa7164_port *port ;
  u32 i ;
  u8 cc ;
  u8 a ;
  u16 pid ;
  u8 *bufcpu ;

  {
#line 123
  port = buf->port;
#line 127
  bufcpu = (u8 *)buf->cpu;
#line 129
  port->sync_errors = 0U;
#line 130
  port->v_cc_errors = 0U;
#line 131
  port->a_cc_errors = 0U;
#line 133
  i = 0U;
#line 133
  goto ldv_52135;
  ldv_52134: ;
#line 134
  if ((unsigned int )*(bufcpu + (unsigned long )i) != 71U) {
#line 135
    port->sync_errors = port->sync_errors + 1U;
  } else {

  }
#line 138
  pid = (u16 )((int )((short )(((int )*(bufcpu + ((unsigned long )i + 1UL)) & 31) << 8)) | (int )((short )*(bufcpu + ((unsigned long )i + 2UL))));
#line 139
  cc = (unsigned int )*(bufcpu + ((unsigned long )i + 3UL)) & 15U;
#line 141
  if ((unsigned int )pid == 241U) {
#line 142
    a = (unsigned int )((u8 )((unsigned int )port->last_v_cc + 1U)) & 15U;
#line 143
    if ((int )a != (int )cc) {
#line 144
      printk("\vvideo cc last = %x current = %x i = %d\n", (int )port->last_v_cc,
             (int )cc, i);
#line 146
      port->v_cc_errors = port->v_cc_errors + 1U;
    } else {

    }
#line 149
    port->last_v_cc = cc;
  } else
#line 151
  if ((unsigned int )pid == 242U) {
#line 152
    a = (unsigned int )((u8 )((unsigned int )port->last_a_cc + 1U)) & 15U;
#line 153
    if ((int )a != (int )cc) {
#line 154
      printk("\vaudio cc last = %x current = %x i = %d\n", (int )port->last_a_cc,
             (int )cc, i);
#line 156
      port->a_cc_errors = port->a_cc_errors + 1U;
    } else {

    }
#line 159
    port->last_a_cc = cc;
  } else {

  }
#line 133
  i = i + 188U;
  ldv_52135: ;
#line 133
  if (buf->actual_size > i) {
#line 135
    goto ldv_52134;
  } else {

  }

#line 168
  if (port->v_cc_errors != 0U && port->done_first_interrupt > 1U) {
#line 169
    printk("\vvideo pid cc, %d errors\n", port->v_cc_errors);
  } else {

  }
#line 171
  if (port->a_cc_errors != 0U && port->done_first_interrupt > 1U) {
#line 172
    printk("\vaudio pid cc, %d errors\n", port->a_cc_errors);
  } else {

  }
#line 174
  if (port->sync_errors != 0U && port->done_first_interrupt > 1U) {
#line 175
    printk("\vsync_errors = %d\n", port->sync_errors);
  } else {

  }
#line 177
  if (port->done_first_interrupt == 1U) {
#line 178
    port->done_first_interrupt = port->done_first_interrupt + 1U;
  } else {

  }
#line 179
  return;
}
}
#line 181 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_histogram_reset(struct saa7164_histogram *hg , char *name ) 
{ 
  int i ;

  {
#line 185
  memset((void *)hg, 0, 1056UL);
#line 186
  strcpy((char *)(& hg->name), (char const   *)name);
#line 189
  i = 0;
#line 189
  goto ldv_52143;
  ldv_52142: 
#line 190
  hg->counter1[i].val = (u32 )i;
#line 189
  i = i + 1;
  ldv_52143: ;
#line 189
  if (i <= 29) {
#line 191
    goto ldv_52142;
  } else {

  }
#line 193
  i = 0;
#line 193
  goto ldv_52146;
  ldv_52145: 
#line 194
  hg->counter1[i + 30].val = (u32 )(i * 10 + 30);
#line 193
  i = i + 1;
  ldv_52146: ;
#line 193
  if (i <= 17) {
#line 195
    goto ldv_52145;
  } else {

  }
#line 197
  i = 0;
#line 197
  goto ldv_52149;
  ldv_52148: 
#line 198
  hg->counter1[i + 48].val = (u32 )((i + 1) * 200);
#line 197
  i = i + 1;
  ldv_52149: ;
#line 197
  if (i <= 14) {
#line 199
    goto ldv_52148;
  } else {

  }
#line 201
  hg->counter1[55].val = 2000U;
#line 204
  hg->counter1[56].val = 4000U;
#line 207
  hg->counter1[57].val = 8000U;
#line 210
  hg->counter1[58].val = 15000U;
#line 213
  hg->counter1[59].val = 30000U;
#line 216
  hg->counter1[60].val = 60000U;
#line 219
  hg->counter1[61].val = 300000U;
#line 222
  hg->counter1[62].val = 900000U;
#line 225
  hg->counter1[63].val = 3600000U;
#line 226
  return;
}
}
#line 228 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
void saa7164_histogram_update(struct saa7164_histogram *hg , u32 val ) 
{ 
  int i ;

  {
#line 231
  i = 0;
#line 231
  goto ldv_52158;
  ldv_52157: ;
#line 232
  if (hg->counter1[i].val >= val) {
#line 233
    hg->counter1[i].count = hg->counter1[i].count + 1U;
#line 234
    hg->counter1[i].update_time = (u64 )jiffies;
#line 235
    goto ldv_52156;
  } else {

  }
#line 231
  i = i + 1;
  ldv_52158: ;
#line 231
  if (i <= 63) {
#line 233
    goto ldv_52157;
  } else {

  }
  ldv_52156: ;
#line 238
  return;
}
}
#line 240 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_histogram_print(struct saa7164_port *port , struct saa7164_histogram *hg ) 
{ 
  u32 entries ;
  int i ;

  {
#line 243
  entries = 0U;
#line 246
  printk("\vHistogram named %s (ms, count, last_update_jiffy)\n", (char *)(& hg->name));
#line 247
  i = 0;
#line 247
  goto ldv_52167;
  ldv_52166: ;
#line 248
  if (hg->counter1[i].count == 0U) {
#line 249
    goto ldv_52165;
  } else {

  }
#line 251
  printk("\v %4d %12d %Ld\n", hg->counter1[i].val, hg->counter1[i].count, hg->counter1[i].update_time);
#line 256
  entries = entries + 1U;
  ldv_52165: 
#line 247
  i = i + 1;
  ldv_52167: ;
#line 247
  if (i <= 63) {
#line 249
    goto ldv_52166;
  } else {

  }
#line 258
  printk("\vTotal: %d\n", entries);
#line 259
  return;
}
}
#line 261 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_work_enchandler_helper(struct saa7164_port *port , int bufnr ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct saa7164_user_buffer *ubuf ;
  struct list_head *c ;
  struct list_head *n ;
  int i ;
  u8 *p ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;

  {
#line 263
  dev = port->dev;
#line 264
  buf = (struct saa7164_buffer *)0;
#line 265
  ubuf = (struct saa7164_user_buffer *)0;
#line 267
  i = 0;
#line 270
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 271
  c = port->dmaqueue.list.next;
#line 271
  n = c->next;
#line 271
  goto ldv_52187;
  ldv_52186: 
#line 273
  __mptr = (struct list_head  const  *)c;
#line 273
  buf = (struct saa7164_buffer *)__mptr;
#line 274
  tmp = i;
#line 274
  i = i + 1;
#line 274
  if (tmp > (int )port->hwcfg.buffercount) {
#line 275
    printk("\v%s() illegal i count %d\n", "saa7164_work_enchandler_helper", i);
#line 277
    goto ldv_52183;
  } else {

  }
#line 280
  if (buf->idx == bufnr) {
#line 283
    if ((saa_debug & 256U) != 0U) {
#line 283
      printk("\017%s: %s() bufnr: %d\n", (char *)(& dev->name), "saa7164_work_enchandler_helper",
             bufnr);
    } else {

    }
#line 285
    if (crc_checking != 0U) {
#line 287
      buf->crc = crc32_le(0U, (unsigned char const   *)buf->cpu, (size_t )buf->actual_size);
    } else {

    }
#line 290
    if (guard_checking != 0U) {
#line 291
      p = (u8 *)buf->cpu;
#line 292
      if ((((((((unsigned int )*(p + (unsigned long )buf->actual_size) != 255U || (unsigned int )*(p + ((unsigned long )buf->actual_size + 1UL)) != 255U) || (unsigned int )*(p + ((unsigned long )buf->actual_size + 2UL)) != 255U) || (unsigned int )*(p + ((unsigned long )buf->actual_size + 3UL)) != 255U) || (unsigned int )*(p + ((unsigned long )buf->actual_size + 16UL)) != 255U) || (unsigned int )*(p + ((unsigned long )buf->actual_size + 17UL)) != 255U) || (unsigned int )*(p + ((unsigned long )buf->actual_size + 18UL)) != 255U) || (unsigned int )*(p + ((unsigned long )buf->actual_size + 19UL)) != 255U) {
#line 300
        printk("\v%s() buf %p guard buffer breach\n", "saa7164_work_enchandler_helper",
               buf);
      } else {

      }
    } else {

    }
#line 309
    if (port->nr != 4 && port->nr != 5) {
#line 311
      if (port->encoder_params.stream_type == 1U) {
#line 312
        saa7164_ts_verifier(buf);
      } else
#line 313
      if (port->encoder_params.stream_type == 0U) {
#line 314
        saa7164_pack_verifier(buf);
      } else {

      }
    } else {

    }
#line 318
    tmp___0 = list_empty((struct list_head  const  *)(& port->list_buf_free.list));
#line 318
    if (tmp___0 == 0) {
#line 321
      __mptr___0 = (struct list_head  const  *)port->list_buf_free.list.next;
#line 321
      ubuf = (struct saa7164_user_buffer *)__mptr___0;
#line 324
      if (buf->actual_size <= ubuf->actual_size) {
#line 326
        memcpy((void *)ubuf->data, (void const   *)buf->cpu, (size_t )ubuf->actual_size);
#line 328
        if (crc_checking != 0U) {
#line 330
          ubuf->crc = crc32_le(0U, (unsigned char const   *)ubuf->data, (size_t )ubuf->actual_size);
        } else {

        }
#line 334
        ubuf->pos = 0U;
#line 336
        list_move_tail(& ubuf->list, & port->list_buf_used.list);
#line 340
        __wake_up(& port->wait_read, 1U, 1, (void *)0);
      } else {
#line 343
        printk("\vbuf %p bufsize fails match\n", buf);
      }
    } else {
#line 347
      printk("\vencirq no free buffers, increase param encoder_buffers\n");
    }
#line 352
    saa7164_buffer_zero_offsets(port, bufnr);
#line 353
    memset((void *)buf->cpu, 255, (size_t )buf->pci_size);
#line 354
    if (crc_checking != 0U) {
#line 356
      buf->crc = crc32_le(0U, (unsigned char const   *)buf->cpu, (size_t )buf->actual_size);
    } else {

    }
#line 359
    goto ldv_52183;
  } else {

  }
#line 271
  c = n;
#line 271
  n = c->next;
  ldv_52187: ;
#line 271
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )c) {
#line 273
    goto ldv_52186;
  } else {

  }
  ldv_52183: 
#line 362
  mutex_unlock(& port->dmaqueue_lock);
#line 363
  return;
}
}
#line 365 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_work_enchandler(struct work_struct *w ) 
{ 
  struct saa7164_port *port ;
  struct work_struct  const  *__mptr ;
  struct saa7164_dev *dev ;
  u32 wp ;
  u32 mcb ;
  u32 rp ;
  u32 cnt ;
  unsigned int tmp ;

  {
#line 368
  __mptr = (struct work_struct  const  *)w;
#line 368
  port = (struct saa7164_port *)__mptr + 0xffffffffffffe058UL;
#line 369
  dev = port->dev;
#line 371
  cnt = 0U;
#line 373
  port->last_svc_msecs_diff = port->last_svc_msecs;
#line 374
  tmp = jiffies_to_msecs(jiffies);
#line 374
  port->last_svc_msecs = (u64 )tmp;
#line 376
  port->last_svc_msecs_diff = port->last_svc_msecs - port->last_svc_msecs_diff;
#line 379
  saa7164_histogram_update(& port->svc_interval, (u32 )port->last_svc_msecs_diff);
#line 382
  port->last_irq_svc_msecs_diff = port->last_svc_msecs - port->last_irq_msecs;
#line 385
  saa7164_histogram_update(& port->irq_svc_interval, (u32 )port->last_irq_svc_msecs_diff);
#line 388
  if ((saa_debug & 256U) != 0U) {
#line 388
    printk("\017%s: %s() %Ldms elapsed irq->deferred %Ldms wp: %d rp: %d\n", (char *)(& dev->name),
           "saa7164_work_enchandler", port->last_svc_msecs_diff, port->last_irq_svc_msecs_diff,
           port->last_svc_wp, port->last_svc_rp);
  } else {

  }
#line 398
  wp = readl((void const volatile   *)dev->lmmio + (unsigned long )(port->bufcounter >> 2));
#line 399
  if ((u32 )((int )port->hwcfg.buffercount + -1) < wp) {
#line 400
    printk("\v%s() illegal buf count %d\n", "saa7164_work_enchandler", wp);
#line 401
    return;
  } else {

  }
#line 405
  if (wp == 0U) {
#line 406
    mcb = (u32 )((int )port->hwcfg.buffercount + -1);
  } else {
#line 408
    mcb = wp - 1U;
  }
  ldv_52201: ;
#line 411
  if (port->done_first_interrupt == 0U) {
#line 412
    port->done_first_interrupt = port->done_first_interrupt + 1U;
#line 413
    rp = mcb;
  } else {
#line 415
    rp = (port->last_svc_rp + 1U) & 7U;
  }
#line 417
  if ((u32 )((int )port->hwcfg.buffercount + -1) < rp) {
#line 418
    printk("\v%s() illegal rp count %d\n", "saa7164_work_enchandler", rp);
#line 419
    goto ldv_52200;
  } else {

  }
#line 422
  saa7164_work_enchandler_helper(port, (int )rp);
#line 423
  port->last_svc_rp = rp;
#line 424
  cnt = cnt + 1U;
#line 426
  if (rp == mcb) {
#line 427
    goto ldv_52200;
  } else {

  }
#line 428
  goto ldv_52201;
  ldv_52200: ;
#line 431
  if ((unsigned int )port->nr == print_histogram) {
#line 432
    saa7164_histogram_print(port, & port->irq_interval);
#line 433
    saa7164_histogram_print(port, & port->svc_interval);
#line 434
    saa7164_histogram_print(port, & port->irq_svc_interval);
#line 435
    saa7164_histogram_print(port, & port->read_interval);
#line 436
    saa7164_histogram_print(port, & port->poll_interval);
#line 438
    print_histogram = (unsigned int )(port->nr + 64);
  } else {

  }
#line 440
  return;
}
}
#line 442 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_work_vbihandler(struct work_struct *w ) 
{ 
  struct saa7164_port *port ;
  struct work_struct  const  *__mptr ;
  struct saa7164_dev *dev ;
  u32 wp ;
  u32 mcb ;
  u32 rp ;
  u32 cnt ;
  unsigned int tmp ;

  {
#line 445
  __mptr = (struct work_struct  const  *)w;
#line 445
  port = (struct saa7164_port *)__mptr + 0xffffffffffffe058UL;
#line 446
  dev = port->dev;
#line 448
  cnt = 0U;
#line 450
  port->last_svc_msecs_diff = port->last_svc_msecs;
#line 451
  tmp = jiffies_to_msecs(jiffies);
#line 451
  port->last_svc_msecs = (u64 )tmp;
#line 452
  port->last_svc_msecs_diff = port->last_svc_msecs - port->last_svc_msecs_diff;
#line 455
  saa7164_histogram_update(& port->svc_interval, (u32 )port->last_svc_msecs_diff);
#line 458
  port->last_irq_svc_msecs_diff = port->last_svc_msecs - port->last_irq_msecs;
#line 461
  saa7164_histogram_update(& port->irq_svc_interval, (u32 )port->last_irq_svc_msecs_diff);
#line 464
  if ((saa_debug & 256U) != 0U) {
#line 464
    printk("\017%s: %s() %Ldms elapsed irq->deferred %Ldms wp: %d rp: %d\n", (char *)(& dev->name),
           "saa7164_work_vbihandler", port->last_svc_msecs_diff, port->last_irq_svc_msecs_diff,
           port->last_svc_wp, port->last_svc_rp);
  } else {

  }
#line 474
  wp = readl((void const volatile   *)dev->lmmio + (unsigned long )(port->bufcounter >> 2));
#line 475
  if ((u32 )((int )port->hwcfg.buffercount + -1) < wp) {
#line 476
    printk("\v%s() illegal buf count %d\n", "saa7164_work_vbihandler", wp);
#line 477
    return;
  } else {

  }
#line 481
  if (wp == 0U) {
#line 482
    mcb = (u32 )((int )port->hwcfg.buffercount + -1);
  } else {
#line 484
    mcb = wp - 1U;
  }
  ldv_52215: ;
#line 487
  if (port->done_first_interrupt == 0U) {
#line 488
    port->done_first_interrupt = port->done_first_interrupt + 1U;
#line 489
    rp = mcb;
  } else {
#line 491
    rp = (port->last_svc_rp + 1U) & 7U;
  }
#line 493
  if ((u32 )((int )port->hwcfg.buffercount + -1) < rp) {
#line 494
    printk("\v%s() illegal rp count %d\n", "saa7164_work_vbihandler", rp);
#line 495
    goto ldv_52214;
  } else {

  }
#line 498
  saa7164_work_enchandler_helper(port, (int )rp);
#line 499
  port->last_svc_rp = rp;
#line 500
  cnt = cnt + 1U;
#line 502
  if (rp == mcb) {
#line 503
    goto ldv_52214;
  } else {

  }
#line 504
  goto ldv_52215;
  ldv_52214: ;
#line 507
  if ((unsigned int )port->nr == print_histogram) {
#line 508
    saa7164_histogram_print(port, & port->irq_interval);
#line 509
    saa7164_histogram_print(port, & port->svc_interval);
#line 510
    saa7164_histogram_print(port, & port->irq_svc_interval);
#line 511
    saa7164_histogram_print(port, & port->read_interval);
#line 512
    saa7164_histogram_print(port, & port->poll_interval);
#line 514
    print_histogram = (unsigned int )(port->nr + 64);
  } else {

  }
#line 516
  return;
}
}
#line 518 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_work_cmdhandler(struct work_struct *w ) 
{ 
  struct saa7164_dev *dev ;
  struct work_struct  const  *__mptr ;

  {
#line 520
  __mptr = (struct work_struct  const  *)w;
#line 520
  dev = (struct saa7164_dev *)__mptr + 0xfffffffffffe0228UL;
#line 523
  saa7164_irq_dequeue(dev);
#line 524
  return;
}
}
#line 526 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_buffer_deliver(struct saa7164_buffer *buf ) 
{ 
  struct saa7164_port *port ;

  {
#line 528
  port = buf->port;
#line 531
  dvb_dmx_swfilter_packets(& port->dvb.demux, (u8 const   *)buf->cpu, 312UL);
#line 532
  return;
}
}
#line 536 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static irqreturn_t saa7164_irq_vbi(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  unsigned int tmp ;

  {
#line 538
  dev = port->dev;
#line 541
  port->last_irq_msecs_diff = port->last_irq_msecs;
#line 544
  tmp = jiffies_to_msecs(jiffies);
#line 544
  port->last_irq_msecs = (u64 )tmp;
#line 547
  port->last_irq_msecs_diff = port->last_irq_msecs - port->last_irq_msecs_diff;
#line 550
  saa7164_histogram_update(& port->irq_interval, (u32 )port->last_irq_msecs_diff);
#line 553
  if ((saa_debug & 256U) != 0U) {
#line 553
    printk("\017%s: %s() %Ldms elapsed\n", (char *)(& dev->name), "saa7164_irq_vbi",
           port->last_irq_msecs_diff);
  } else {

  }
#line 557
  schedule_work(& port->workenc);
#line 558
  return (0);
}
}
#line 561 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static irqreturn_t saa7164_irq_encoder(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  unsigned int tmp ;

  {
#line 563
  dev = port->dev;
#line 566
  port->last_irq_msecs_diff = port->last_irq_msecs;
#line 569
  tmp = jiffies_to_msecs(jiffies);
#line 569
  port->last_irq_msecs = (u64 )tmp;
#line 572
  port->last_irq_msecs_diff = port->last_irq_msecs - port->last_irq_msecs_diff;
#line 575
  saa7164_histogram_update(& port->irq_interval, (u32 )port->last_irq_msecs_diff);
#line 578
  if ((saa_debug & 256U) != 0U) {
#line 578
    printk("\017%s: %s() %Ldms elapsed\n", (char *)(& dev->name), "saa7164_irq_encoder",
           port->last_irq_msecs_diff);
  } else {

  }
#line 581
  schedule_work(& port->workenc);
#line 582
  return (0);
}
}
#line 585 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static irqreturn_t saa7164_irq_ts(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct list_head *c ;
  struct list_head *n ;
  int wp ;
  int i ;
  int rp ;
  unsigned int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 587
  dev = port->dev;
#line 590
  i = 0;
#line 593
  tmp = readl((void const volatile   *)dev->lmmio + (unsigned long )(port->bufcounter >> 2));
#line 593
  wp = (int )tmp;
#line 594
  if ((int )port->hwcfg.buffercount + -1 < wp) {
#line 595
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"),
                         "i" (595), "i" (12UL));
    ldv_52246: ;
#line 595
    goto ldv_52246;
  } else {

  }
#line 598
  if (wp == 0) {
#line 599
    rp = (int )port->hwcfg.buffercount + -1;
  } else {
#line 601
    rp = wp + -1;
  }
#line 605
  c = port->dmaqueue.list.next;
#line 605
  n = c->next;
#line 605
  goto ldv_52253;
  ldv_52252: 
#line 606
  __mptr = (struct list_head  const  *)c;
#line 606
  buf = (struct saa7164_buffer *)__mptr;
#line 607
  tmp___0 = i;
#line 607
  i = i + 1;
#line 607
  if (tmp___0 > (int )port->hwcfg.buffercount) {
#line 608
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"),
                         "i" (608), "i" (12UL));
    ldv_52249: ;
#line 608
    goto ldv_52249;
  } else {

  }
#line 610
  if (buf->idx == rp) {
#line 612
    if ((saa_debug & 256U) != 0U) {
#line 612
      printk("\017%s: %s() wp: %d processing: %d\n", (char *)(& dev->name), "saa7164_irq_ts",
             wp, rp);
    } else {

    }
#line 614
    saa7164_buffer_deliver(buf);
#line 615
    goto ldv_52251;
  } else {

  }
#line 605
  c = n;
#line 605
  n = c->next;
  ldv_52253: ;
#line 605
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )c) {
#line 607
    goto ldv_52252;
  } else {

  }
  ldv_52251: ;
#line 619
  return (0);
}
}
#line 623 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static irqreturn_t saa7164_irq(int irq , void *dev_id ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_port *porta ;
  struct saa7164_port *portb ;
  struct saa7164_port *portc ;
  struct saa7164_port *portd ;
  struct saa7164_port *porte ;
  struct saa7164_port *portf ;
  u32 intid ;
  u32 intstat[4U] ;
  int i ;
  int handled ;
  int bit ;

  {
#line 625
  dev = (struct saa7164_dev *)dev_id;
#line 629
  handled = 0;
#line 631
  if ((unsigned long )dev == (unsigned long )((struct saa7164_dev *)0)) {
#line 632
    printk("\v%s() No device specified\n", "saa7164_irq");
#line 633
    handled = 0;
#line 634
    goto out;
  } else {

  }
#line 637
  porta = (struct saa7164_port *)(& dev->ports);
#line 638
  portb = (struct saa7164_port *)(& dev->ports) + 1UL;
#line 639
  portc = (struct saa7164_port *)(& dev->ports) + 2UL;
#line 640
  portd = (struct saa7164_port *)(& dev->ports) + 3UL;
#line 641
  porte = (struct saa7164_port *)(& dev->ports) + 4UL;
#line 642
  portf = (struct saa7164_port *)(& dev->ports) + 5UL;
#line 649
  i = 0;
#line 649
  goto ldv_52273;
  ldv_52272: 
#line 653
  intstat[i] = readl((void const volatile   *)dev->lmmio + (unsigned long )((dev->int_status + (u32 )(i * 4)) >> 2));
#line 655
  if (intstat[i] != 0U) {
#line 656
    handled = 1;
  } else {

  }
#line 649
  i = i + 1;
  ldv_52273: ;
#line 649
  if (i <= 3) {
#line 651
    goto ldv_52272;
  } else {

  }

#line 658
  if (handled == 0) {
#line 659
    goto out;
  } else {

  }
#line 662
  i = 0;
#line 662
  goto ldv_52280;
  ldv_52279: ;
#line 664
  if (intstat[i] != 0U) {
#line 669
    bit = 0;
#line 669
    goto ldv_52277;
    ldv_52276: ;
#line 671
    if (((intstat[i] >> bit) & 1U) == 0U) {
#line 672
      goto ldv_52275;
    } else {

    }
#line 676
    intid = (u32 )(i * 32 + bit);
#line 677
    if ((u32 )dev->intfdesc.bInterruptId == intid) {
#line 679
      schedule_work(& dev->workcmd);
    } else
#line 680
    if ((u32 )porta->hwcfg.interruptid == intid) {
#line 683
      saa7164_irq_ts(porta);
    } else
#line 685
    if ((u32 )portb->hwcfg.interruptid == intid) {
#line 688
      saa7164_irq_ts(portb);
    } else
#line 690
    if ((u32 )portc->hwcfg.interruptid == intid) {
#line 693
      saa7164_irq_encoder(portc);
    } else
#line 695
    if ((u32 )portd->hwcfg.interruptid == intid) {
#line 698
      saa7164_irq_encoder(portd);
    } else
#line 700
    if ((u32 )porte->hwcfg.interruptid == intid) {
#line 703
      saa7164_irq_vbi(porte);
    } else
#line 705
    if ((u32 )portf->hwcfg.interruptid == intid) {
#line 708
      saa7164_irq_vbi(portf);
    } else
#line 712
    if ((saa_debug & 256U) != 0U) {
#line 712
      printk("\017%s: %s() unhandled interrupt reg 0x%x bit 0x%x intid = 0x%x\n",
             (char *)(& dev->name), "saa7164_irq", i, bit, intid);
    } else {

    }
    ldv_52275: 
#line 669
    bit = bit + 1;
    ldv_52277: ;
#line 669
    if (bit <= 31) {
#line 671
      goto ldv_52276;
    } else {

    }
#line 721
    writel(intstat[i], (void volatile   *)dev->lmmio + (unsigned long )((dev->int_ack + (u32 )(i * 4)) >> 2));
  } else {

  }
#line 662
  i = i + 1;
  ldv_52280: ;
#line 662
  if (i <= 3) {
#line 664
    goto ldv_52279;
  } else {

  }

  out: ;
#line 726
  return (handled != 0);
}
}
#line 729 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
void saa7164_getfirmwarestatus(struct saa7164_dev *dev ) 
{ 
  struct saa7164_fw_status *s ;

  {
#line 731
  s = & dev->fw_status;
#line 733
  dev->fw_status.status = readl((void const volatile   *)dev->lmmio + 28U);
#line 734
  dev->fw_status.mode = readl((void const volatile   *)dev->lmmio + 29U);
#line 735
  dev->fw_status.spec = readl((void const volatile   *)dev->lmmio + 30U);
#line 736
  dev->fw_status.inst = readl((void const volatile   *)dev->lmmio + 31U);
#line 737
  dev->fw_status.cpuload = readl((void const volatile   *)dev->lmmio + 32U);
#line 738
  dev->fw_status.remainheap = readl((void const volatile   *)dev->lmmio + 33U);
#line 741
  if ((int )saa_debug & 1) {
#line 741
    printk("\017%s: Firmware status:\n", (char *)(& dev->name));
  } else {

  }
#line 742
  if ((int )saa_debug & 1) {
#line 742
    printk("\017%s:  .status     = 0x%08x\n", (char *)(& dev->name), s->status);
  } else {

  }
#line 743
  if ((int )saa_debug & 1) {
#line 743
    printk("\017%s:  .mode       = 0x%08x\n", (char *)(& dev->name), s->mode);
  } else {

  }
#line 744
  if ((int )saa_debug & 1) {
#line 744
    printk("\017%s:  .spec       = 0x%08x\n", (char *)(& dev->name), s->spec);
  } else {

  }
#line 745
  if ((int )saa_debug & 1) {
#line 745
    printk("\017%s:  .inst       = 0x%08x\n", (char *)(& dev->name), s->inst);
  } else {

  }
#line 746
  if ((int )saa_debug & 1) {
#line 746
    printk("\017%s:  .cpuload    = 0x%08x\n", (char *)(& dev->name), s->cpuload);
  } else {

  }
#line 747
  if ((int )saa_debug & 1) {
#line 747
    printk("\017%s:  .remainheap = 0x%08x\n", (char *)(& dev->name), s->remainheap);
  } else {

  }
#line 748
  return;
}
}
#line 750 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
u32 saa7164_getcurrentfirmwareversion(struct saa7164_dev *dev ) 
{ 
  u32 reg ;

  {
#line 754
  reg = readl((void const volatile   *)dev->lmmio + 12U);
#line 755
  if ((int )saa_debug & 1) {
#line 755
    printk("\017%s: Device running firmware version %d.%d.%d.%d (0x%x)\n", (char *)(& dev->name),
           (reg & 64512U) >> 10, (reg & 992U) >> 5, reg & 31U, reg >> 16, reg);
  } else {

  }
#line 762
  return (reg);
}
}
#line 766 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
void saa7164_dumpregs(struct saa7164_dev *dev , u32 addr ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;

  {
#line 770
  if ((int )saa_debug & 1) {
#line 770
    printk("\017%s: --------------------> 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n",
           (char *)(& dev->name));
  } else {

  }
#line 773
  i = 0;
#line 773
  goto ldv_52296;
  ldv_52295: ;
#line 774
  if ((int )saa_debug & 1) {
#line 774
    tmp = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 15U));
#line 774
    tmp___0 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 14U));
#line 774
    tmp___1 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 13U));
#line 774
    tmp___2 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 12U));
#line 774
    tmp___3 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 11U));
#line 774
    tmp___4 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 10U));
#line 774
    tmp___5 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 9U));
#line 774
    tmp___6 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 8U));
#line 774
    tmp___7 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 7U));
#line 774
    tmp___8 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 6U));
#line 774
    tmp___9 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 5U));
#line 774
    tmp___10 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 4U));
#line 774
    tmp___11 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 3U));
#line 774
    tmp___12 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 2U));
#line 774
    tmp___13 = readl((void const volatile   *)dev->bmmio + (unsigned long )((addr + (u32 )i) + 1U));
#line 774
    tmp___14 = readl((void const volatile   *)dev->bmmio + (unsigned long )(addr + (u32 )i));
#line 774
    printk("\017%s: region0[0x%08x] = %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
           (char *)(& dev->name), i, (int )((unsigned char )tmp___14), (int )((unsigned char )tmp___13),
           (int )((unsigned char )tmp___12), (int )((unsigned char )tmp___11), (int )((unsigned char )tmp___10),
           (int )((unsigned char )tmp___9), (int )((unsigned char )tmp___8), (int )((unsigned char )tmp___7),
           (int )((unsigned char )tmp___6), (int )((unsigned char )tmp___5), (int )((unsigned char )tmp___4),
           (int )((unsigned char )tmp___3), (int )((unsigned char )tmp___2), (int )((unsigned char )tmp___1),
           (int )((unsigned char )tmp___0), (int )((unsigned char )tmp));
  } else {

  }
#line 773
  i = i + 16;
  ldv_52296: ;
#line 773
  if (i <= 255) {
#line 775
    goto ldv_52295;
  } else {

  }

#line 780
  return;
}
}
#line 796 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_dump_hwdesc(struct saa7164_dev *dev ) 
{ 


  {
#line 798
  if ((int )saa_debug & 1) {
#line 798
    printk("\017%s: @0x%p hwdesc sizeof(struct tmComResHWDescr) = %d bytes\n", (char *)(& dev->name),
           & dev->hwdesc, 34U);
  } else {

  }
#line 801
  if ((int )saa_debug & 1) {
#line 801
    printk("\017%s:  .bLength = 0x%x\n", (char *)(& dev->name), (int )dev->hwdesc.bLength);
  } else {

  }
#line 802
  if ((int )saa_debug & 1) {
#line 802
    printk("\017%s:  .bDescriptorType = 0x%x\n", (char *)(& dev->name), (int )dev->hwdesc.bDescriptorType);
  } else {

  }
#line 803
  if ((int )saa_debug & 1) {
#line 803
    printk("\017%s:  .bDescriptorSubtype = 0x%x\n", (char *)(& dev->name), (int )dev->hwdesc.bDescriptorSubtype);
  } else {

  }
#line 806
  if ((int )saa_debug & 1) {
#line 806
    printk("\017%s:  .bcdSpecVersion = 0x%x\n", (char *)(& dev->name), (int )dev->hwdesc.bcdSpecVersion);
  } else {

  }
#line 807
  if ((int )saa_debug & 1) {
#line 807
    printk("\017%s:  .dwClockFrequency = 0x%x\n", (char *)(& dev->name), dev->hwdesc.dwClockFrequency);
  } else {

  }
#line 808
  if ((int )saa_debug & 1) {
#line 808
    printk("\017%s:  .dwClockUpdateRes = 0x%x\n", (char *)(& dev->name), dev->hwdesc.dwClockUpdateRes);
  } else {

  }
#line 809
  if ((int )saa_debug & 1) {
#line 809
    printk("\017%s:  .bCapabilities = 0x%x\n", (char *)(& dev->name), (int )dev->hwdesc.bCapabilities);
  } else {

  }
#line 810
  if ((int )saa_debug & 1) {
#line 810
    printk("\017%s:  .dwDeviceRegistersLocation = 0x%x\n", (char *)(& dev->name),
           dev->hwdesc.dwDeviceRegistersLocation);
  } else {

  }
#line 813
  if ((int )saa_debug & 1) {
#line 813
    printk("\017%s:  .dwHostMemoryRegion = 0x%x\n", (char *)(& dev->name), dev->hwdesc.dwHostMemoryRegion);
  } else {

  }
#line 816
  if ((int )saa_debug & 1) {
#line 816
    printk("\017%s:  .dwHostMemoryRegionSize = 0x%x\n", (char *)(& dev->name), dev->hwdesc.dwHostMemoryRegionSize);
  } else {

  }
#line 819
  if ((int )saa_debug & 1) {
#line 819
    printk("\017%s:  .dwHostHibernatMemRegion = 0x%x\n", (char *)(& dev->name), dev->hwdesc.dwHostHibernatMemRegion);
  } else {

  }
#line 822
  if ((int )saa_debug & 1) {
#line 822
    printk("\017%s:  .dwHostHibernatMemRegionSize = 0x%x\n", (char *)(& dev->name),
           dev->hwdesc.dwHostHibernatMemRegionSize);
  } else {

  }
#line 823
  return;
}
}
#line 826 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_dump_intfdesc(struct saa7164_dev *dev ) 
{ 


  {
#line 828
  if ((int )saa_debug & 1) {
#line 828
    printk("\017%s: @0x%p intfdesc sizeof(struct tmComResInterfaceDescr) = %d bytes\n",
           (char *)(& dev->name), & dev->intfdesc, 13U);
  } else {

  }
#line 832
  if ((int )saa_debug & 1) {
#line 832
    printk("\017%s:  .bLength = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bLength);
  } else {

  }
#line 833
  if ((int )saa_debug & 1) {
#line 833
    printk("\017%s:  .bDescriptorType = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bDescriptorType);
  } else {

  }
#line 834
  if ((int )saa_debug & 1) {
#line 834
    printk("\017%s:  .bDescriptorSubtype = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bDescriptorSubtype);
  } else {

  }
#line 837
  if ((int )saa_debug & 1) {
#line 837
    printk("\017%s:  .bFlags = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bFlags);
  } else {

  }
#line 838
  if ((int )saa_debug & 1) {
#line 838
    printk("\017%s:  .bInterfaceType = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bInterfaceType);
  } else {

  }
#line 839
  if ((int )saa_debug & 1) {
#line 839
    printk("\017%s:  .bInterfaceId = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bInterfaceId);
  } else {

  }
#line 840
  if ((int )saa_debug & 1) {
#line 840
    printk("\017%s:  .bBaseInterface = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bBaseInterface);
  } else {

  }
#line 841
  if ((int )saa_debug & 1) {
#line 841
    printk("\017%s:  .bInterruptId = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bInterruptId);
  } else {

  }
#line 842
  if ((int )saa_debug & 1) {
#line 842
    printk("\017%s:  .bDebugInterruptId = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.bDebugInterruptId);
  } else {

  }
#line 845
  if ((int )saa_debug & 1) {
#line 845
    printk("\017%s:  .BARLocation = 0x%x\n", (char *)(& dev->name), (int )dev->intfdesc.BARLocation);
  } else {

  }
#line 846
  return;
}
}
#line 848 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_dump_busdesc(struct saa7164_dev *dev ) 
{ 


  {
#line 850
  if ((int )saa_debug & 1) {
#line 850
    printk("\017%s: @0x%p busdesc sizeof(struct tmComResBusDescr) = %d bytes\n", (char *)(& dev->name),
           & dev->busdesc, 32U);
  } else {

  }
#line 853
  if ((int )saa_debug & 1) {
#line 853
    printk("\017%s:  .CommandRing   = 0x%016Lx\n", (char *)(& dev->name), dev->busdesc.CommandRing);
  } else {

  }
#line 854
  if ((int )saa_debug & 1) {
#line 854
    printk("\017%s:  .ResponseRing  = 0x%016Lx\n", (char *)(& dev->name), dev->busdesc.ResponseRing);
  } else {

  }
#line 855
  if ((int )saa_debug & 1) {
#line 855
    printk("\017%s:  .CommandWrite  = 0x%x\n", (char *)(& dev->name), dev->busdesc.CommandWrite);
  } else {

  }
#line 856
  if ((int )saa_debug & 1) {
#line 856
    printk("\017%s:  .CommandRead   = 0x%x\n", (char *)(& dev->name), dev->busdesc.CommandRead);
  } else {

  }
#line 857
  if ((int )saa_debug & 1) {
#line 857
    printk("\017%s:  .ResponseWrite = 0x%x\n", (char *)(& dev->name), dev->busdesc.ResponseWrite);
  } else {

  }
#line 858
  if ((int )saa_debug & 1) {
#line 858
    printk("\017%s:  .ResponseRead  = 0x%x\n", (char *)(& dev->name), dev->busdesc.ResponseRead);
  } else {

  }
#line 859
  return;
}
}
#line 866 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_get_descriptors(struct saa7164_dev *dev ) 
{ 


  {
#line 868
  memcpy_fromio((void *)(& dev->hwdesc), (void const volatile   *)dev->bmmio, 34UL);
#line 869
  memcpy_fromio((void *)(& dev->intfdesc), (void const volatile   *)dev->bmmio + 34U,
                13UL);
#line 871
  memcpy_fromio((void *)(& dev->busdesc), (void const volatile   *)dev->bmmio + (unsigned long )dev->intfdesc.BARLocation,
                32UL);
#line 874
  if ((unsigned int )dev->hwdesc.bLength != 34U) {
#line 875
    printk("\vStructure struct tmComResHWDescr is mangled\n");
#line 876
    printk("\vNeed %x got %d\n", (int )dev->hwdesc.bLength, 34U);
  } else {
#line 879
    saa7164_dump_hwdesc(dev);
  }
#line 881
  if ((unsigned int )dev->intfdesc.bLength != 13U) {
#line 882
    printk("\vstruct struct tmComResInterfaceDescr is mangled\n");
#line 883
    printk("\vNeed %x got %d\n", (int )dev->intfdesc.bLength, 13U);
  } else {
#line 886
    saa7164_dump_intfdesc(dev);
  }
#line 888
  saa7164_dump_busdesc(dev);
#line 889
  return;
}
}
#line 891 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_pci_quirks(struct saa7164_dev *dev ) 
{ 


  {
#line 893
  return (0);
}
}
#line 896 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int get_resources(struct saa7164_dev *dev ) 
{ 
  struct resource *tmp ;
  struct resource *tmp___0 ;

  {
#line 898
  tmp___0 = __request_region(& iomem_resource, (dev->pci)->resource[0].start, (dev->pci)->resource[0].start != 0ULL || (dev->pci)->resource[0].end != (dev->pci)->resource[0].start ? ((dev->pci)->resource[0].end - (dev->pci)->resource[0].start) + 1ULL : 0ULL,
                             (char const   *)(& dev->name), 0);
#line 898
  if ((unsigned long )tmp___0 != (unsigned long )((struct resource *)0)) {
#line 901
    tmp = __request_region(& iomem_resource, (dev->pci)->resource[2].start, (dev->pci)->resource[2].start != 0ULL || (dev->pci)->resource[2].end != (dev->pci)->resource[2].start ? ((dev->pci)->resource[2].end - (dev->pci)->resource[2].start) + 1ULL : 0ULL,
                           (char const   *)(& dev->name), 0);
#line 901
    if ((unsigned long )tmp != (unsigned long )((struct resource *)0)) {
#line 903
      return (0);
    } else {

    }
  } else {

  }
#line 906
  printk("\v%s: can\'t get MMIO memory @ 0x%llx or 0x%llx\n", (char *)(& dev->name),
         (dev->pci)->resource[0].start, (dev->pci)->resource[2].start);
#line 911
  return (-16);
}
}
#line 914 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_port_init(struct saa7164_dev *dev , int portnr ) 
{ 
  struct saa7164_port *port ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;

  {
#line 916
  port = (struct saa7164_port *)0;
#line 918
  if (portnr < 0 || portnr > 5) {
#line 919
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"),
                         "i" (919), "i" (12UL));
    ldv_52321: ;
#line 919
    goto ldv_52321;
  } else {

  }
#line 921
  port = (struct saa7164_port *)(& dev->ports) + (unsigned long )portnr;
#line 923
  port->dev = dev;
#line 924
  port->nr = portnr;
#line 926
  if (portnr == 0 || portnr == 1) {
#line 927
    port->type = 1;
  } else
#line 929
  if (portnr == 2 || portnr == 3) {
#line 930
    port->type = 2;
#line 933
    __init_work(& port->workenc, 0);
#line 933
    __constr_expr_0.counter = 137438953408L;
#line 933
    port->workenc.data = __constr_expr_0;
#line 933
    lockdep_init_map(& port->workenc.lockdep_map, "(&port->workenc)", & __key, 0);
#line 933
    INIT_LIST_HEAD(& port->workenc.entry);
#line 933
    port->workenc.func = & saa7164_work_enchandler;
  } else
#line 934
  if (portnr == 4 || portnr == 5) {
#line 935
    port->type = 3;
#line 938
    __init_work(& port->workenc, 0);
#line 938
    __constr_expr_1.counter = 137438953408L;
#line 938
    port->workenc.data = __constr_expr_1;
#line 938
    lockdep_init_map(& port->workenc.lockdep_map, "(&port->workenc)", & __key___0,
                     0);
#line 938
    INIT_LIST_HEAD(& port->workenc.entry);
#line 938
    port->workenc.func = & saa7164_work_vbihandler;
  } else {
#line 940
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"),
                         "i" (940), "i" (12UL));
    ldv_52326: ;
#line 940
    goto ldv_52326;
  }
#line 943
  __mutex_init(& port->dvb.lock, "&port->dvb.lock", & __key___1);
#line 944
  INIT_LIST_HEAD(& port->dmaqueue.list);
#line 945
  __mutex_init(& port->dmaqueue_lock, "&port->dmaqueue_lock", & __key___2);
#line 947
  INIT_LIST_HEAD(& port->list_buf_used.list);
#line 948
  INIT_LIST_HEAD(& port->list_buf_free.list);
#line 949
  __init_waitqueue_head(& port->wait_read, "&port->wait_read", & __key___3);
#line 952
  saa7164_histogram_reset(& port->irq_interval, (char *)"irq intervals");
#line 953
  saa7164_histogram_reset(& port->svc_interval, (char *)"deferred intervals");
#line 954
  saa7164_histogram_reset(& port->irq_svc_interval, (char *)"irq to deferred intervals");
#line 956
  saa7164_histogram_reset(& port->read_interval, (char *)"encoder/vbi read() intervals");
#line 958
  saa7164_histogram_reset(& port->poll_interval, (char *)"encoder/vbi poll() intervals");
#line 961
  return (0);
}
}
#line 964 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_dev_setup(struct saa7164_dev *dev ) 
{ 
  int i ;
  struct lock_class_key __key ;
  unsigned int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 968
  __mutex_init(& dev->lock, "&dev->lock", & __key);
#line 969
  atomic_inc(& dev->refcount);
#line 970
  tmp = saa7164_devcount;
#line 970
  saa7164_devcount = saa7164_devcount + 1U;
#line 970
  dev->nr = (int )tmp;
#line 972
  snprintf((char *)(& dev->name), 16UL, "saa7164[%d]", dev->nr);
#line 974
  mutex_lock_nested(& devlist, 0U);
#line 975
  list_add_tail(& dev->devlist, & saa7164_devlist);
#line 976
  mutex_unlock(& devlist);
#line 979
  dev->board = 4294967295U;
#line 980
  if (card[dev->nr] < (unsigned int )saa7164_bcount) {
#line 981
    dev->board = card[dev->nr];
  } else {

  }
#line 983
  i = 0;
#line 983
  goto ldv_52336;
  ldv_52335: ;
#line 984
  if ((int )(dev->pci)->subsystem_vendor == (int )saa7164_subids[i].subvendor && (int )(dev->pci)->subsystem_device == (int )saa7164_subids[i].subdevice) {
#line 987
    dev->board = saa7164_subids[i].card;
  } else {

  }
#line 983
  i = i + 1;
  ldv_52336: ;
#line 983
  if (dev->board == 4294967295U && (unsigned int )i < (unsigned int )saa7164_idcount) {
#line 985
    goto ldv_52335;
  } else {

  }

#line 989
  if (dev->board == 4294967295U) {
#line 990
    dev->board = 0U;
#line 991
    saa7164_card_list(dev);
  } else {

  }
#line 994
  dev->pci_bus = (int )((dev->pci)->bus)->number;
#line 995
  dev->pci_slot = (int )((dev->pci)->devfn >> 3) & 31;
#line 998
  dev->i2c_bus[0].dev = dev;
#line 999
  dev->i2c_bus[0].nr = 0;
#line 1000
  dev->i2c_bus[1].dev = dev;
#line 1001
  dev->i2c_bus[1].nr = 1;
#line 1002
  dev->i2c_bus[2].dev = dev;
#line 1003
  dev->i2c_bus[2].nr = 2;
#line 1006
  saa7164_port_init(dev, 0);
#line 1007
  saa7164_port_init(dev, 1);
#line 1008
  saa7164_port_init(dev, 2);
#line 1009
  saa7164_port_init(dev, 3);
#line 1010
  saa7164_port_init(dev, 4);
#line 1011
  saa7164_port_init(dev, 5);
#line 1013
  tmp___0 = get_resources(dev);
#line 1013
  if (tmp___0 < 0) {
#line 1014
    printk("\vCORE %s No more PCIe resources for subsystem: %04x:%04x\n", (char *)(& dev->name),
           (int )(dev->pci)->subsystem_vendor, (int )(dev->pci)->subsystem_device);
#line 1019
    saa7164_devcount = saa7164_devcount - 1U;
#line 1020
    return (-19);
  } else {

  }
#line 1024
  tmp___1 = ioremap((dev->pci)->resource[0].start, (dev->pci)->resource[0].start != 0ULL || (dev->pci)->resource[0].end != (dev->pci)->resource[0].start ? (unsigned long )(((dev->pci)->resource[0].end - (dev->pci)->resource[0].start) + 1ULL) : 0UL);
#line 1024
  dev->lmmio = (u32 *)tmp___1;
#line 1027
  tmp___2 = ioremap((dev->pci)->resource[2].start, (dev->pci)->resource[2].start != 0ULL || (dev->pci)->resource[2].end != (dev->pci)->resource[2].start ? (unsigned long )(((dev->pci)->resource[2].end - (dev->pci)->resource[2].start) + 1ULL) : 0UL);
#line 1027
  dev->lmmio2 = (u32 *)tmp___2;
#line 1030
  dev->bmmio = (u8 *)dev->lmmio;
#line 1031
  dev->bmmio2 = (u8 *)dev->lmmio2;
#line 1034
  dev->int_status = 1589120U;
#line 1035
  dev->int_ack = 1589136U;
#line 1037
  printk("\016CORE %s: subsystem: %04x:%04x, board: %s [card=%d,%s]\n", (char *)(& dev->name),
         (int )(dev->pci)->subsystem_vendor, (int )(dev->pci)->subsystem_device, saa7164_boards[dev->board].name,
         dev->board, card[dev->nr] == dev->board ? (char *)"insmod option" : (char *)"autodetected");
#line 1044
  saa7164_pci_quirks(dev);
#line 1046
  return (0);
}
}
#line 1049 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_dev_unregister(struct saa7164_dev *dev ) 
{ 
  int tmp ;

  {
#line 1051
  if ((int )saa_debug & 1) {
#line 1051
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_dev_unregister");
  } else {

  }
#line 1053
  __release_region(& iomem_resource, (dev->pci)->resource[0].start, (dev->pci)->resource[0].start != 0ULL || (dev->pci)->resource[0].end != (dev->pci)->resource[0].start ? ((dev->pci)->resource[0].end - (dev->pci)->resource[0].start) + 1ULL : 0ULL);
#line 1056
  __release_region(& iomem_resource, (dev->pci)->resource[2].start, (dev->pci)->resource[2].start != 0ULL || (dev->pci)->resource[2].end != (dev->pci)->resource[2].start ? ((dev->pci)->resource[2].end - (dev->pci)->resource[2].start) + 1ULL : 0ULL);
#line 1059
  tmp = atomic_dec_and_test(& dev->refcount);
#line 1059
  if (tmp == 0) {
#line 1060
    return;
  } else {

  }
#line 1062
  iounmap((void volatile   *)dev->lmmio);
#line 1063
  iounmap((void volatile   *)dev->lmmio2);
#line 1065
  return;
}
}
#line 1069 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_proc_show(struct seq_file *m , void *v ) 
{ 
  struct saa7164_dev *dev ;
  struct tmComResBusInfo *b ;
  struct list_head *list ;
  int i ;
  int c ;
  struct list_head  const  *__mptr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;

  {
#line 1076
  if (saa7164_devcount == 0U) {
#line 1077
    return (0);
  } else {

  }
#line 1079
  list = saa7164_devlist.next;
#line 1079
  goto ldv_52360;
  ldv_52359: 
#line 1080
  __mptr = (struct list_head  const  *)list;
#line 1080
  dev = (struct saa7164_dev *)__mptr;
#line 1081
  seq_printf(m, "%s = %p\n", (char *)(& dev->name), dev);
#line 1084
  b = & dev->bus;
#line 1085
  mutex_lock_nested(& b->lock, 0U);
#line 1087
  tmp = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwSetReadPos >> 2));
#line 1087
  seq_printf(m, " .m_pdwSetWritePos = 0x%x (0x%08x)\n", b->m_dwSetReadPos, tmp);
#line 1090
  tmp___0 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwSetWritePos >> 2));
#line 1090
  seq_printf(m, " .m_pdwSetReadPos  = 0x%x (0x%08x)\n", b->m_dwSetWritePos, tmp___0);
#line 1093
  tmp___1 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwGetReadPos >> 2));
#line 1093
  seq_printf(m, " .m_pdwGetWritePos = 0x%x (0x%08x)\n", b->m_dwGetReadPos, tmp___1);
#line 1096
  tmp___2 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwGetWritePos >> 2));
#line 1096
  seq_printf(m, " .m_pdwGetReadPos  = 0x%x (0x%08x)\n", b->m_dwGetWritePos, tmp___2);
#line 1098
  c = 0;
#line 1099
  seq_printf(m, "\n  Set Ring:\n");
#line 1100
  seq_printf(m, "\n addr  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");
#line 1101
  i = 0;
#line 1101
  goto ldv_52354;
  ldv_52353: ;
#line 1102
  if (c == 0) {
#line 1103
    seq_printf(m, " %04x:", i);
  } else {

  }
#line 1105
  tmp___3 = readb((void const volatile   *)b->m_pdwSetRing + (unsigned long )i);
#line 1105
  seq_printf(m, " %02x", (int )tmp___3);
#line 1107
  c = c + 1;
#line 1107
  if (c == 16) {
#line 1108
    seq_printf(m, "\n");
#line 1109
    c = 0;
  } else {

  }
#line 1101
  i = i + 1;
  ldv_52354: ;
#line 1101
  if ((u32 )i < b->m_dwSizeSetRing) {
#line 1103
    goto ldv_52353;
  } else {

  }
#line 1113
  c = 0;
#line 1114
  seq_printf(m, "\n  Get Ring:\n");
#line 1115
  seq_printf(m, "\n addr  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");
#line 1116
  i = 0;
#line 1116
  goto ldv_52357;
  ldv_52356: ;
#line 1117
  if (c == 0) {
#line 1118
    seq_printf(m, " %04x:", i);
  } else {

  }
#line 1120
  tmp___4 = readb((void const volatile   *)b->m_pdwGetRing + (unsigned long )i);
#line 1120
  seq_printf(m, " %02x", (int )tmp___4);
#line 1122
  c = c + 1;
#line 1122
  if (c == 16) {
#line 1123
    seq_printf(m, "\n");
#line 1124
    c = 0;
  } else {

  }
#line 1116
  i = i + 1;
  ldv_52357: ;
#line 1116
  if ((u32 )i < b->m_dwSizeGetRing) {
#line 1118
    goto ldv_52356;
  } else {

  }
#line 1128
  mutex_unlock(& b->lock);
#line 1079
  list = list->next;
  ldv_52360: ;
#line 1079
  if ((unsigned long )list != (unsigned long )(& saa7164_devlist)) {
#line 1081
    goto ldv_52359;
  } else {

  }

#line 1132
  return (0);
}
}
#line 1135 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_proc_open(struct inode *inode , struct file *filp ) 
{ 
  int tmp ;

  {
#line 1137
  tmp = single_open(filp, & saa7164_proc_show, (void *)0);
#line 1137
  return (tmp);
}
}
#line 1140 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static struct file_operations  const  saa7164_proc_fops  = 
#line 1140
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & saa7164_proc_open, 0,
    & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1147 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_proc_create(void) 
{ 
  struct proc_dir_entry *pe ;

  {
#line 1151
  pe = proc_create("saa7164", 292, (struct proc_dir_entry *)0, & saa7164_proc_fops);
#line 1152
  if ((unsigned long )pe == (unsigned long )((struct proc_dir_entry *)0)) {
#line 1153
    return (-12);
  } else {

  }
#line 1155
  return (0);
}
}
#line 1159 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_thread_function(void *data ) 
{ 
  struct saa7164_dev *dev ;
  struct tmFwInfoStruct fwinfo ;
  u64 last_poll_time ;
  bool tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1161
  dev = (struct saa7164_dev *)data;
#line 1163
  last_poll_time = 0ULL;
#line 1165
  if ((saa_debug & 4096U) != 0U) {
#line 1165
    printk("\017%s: thread started\n", (char *)(& dev->name));
  } else {

  }
#line 1167
  set_freezable();
  ldv_52378: 
#line 1170
  msleep_interruptible(100U);
#line 1171
  tmp = kthread_should_stop();
#line 1171
  if ((int )tmp) {
#line 1172
    goto ldv_52377;
  } else {

  }
#line 1173
  try_to_freeze();
#line 1175
  if ((saa_debug & 4096U) != 0U) {
#line 1175
    printk("\017%s: thread running\n", (char *)(& dev->name));
  } else {

  }
#line 1180
  saa7164_api_collect_debug(dev);
#line 1183
  tmp___1 = jiffies_to_msecs(jiffies);
#line 1183
  if (last_poll_time + 1000ULL < (u64 )tmp___1) {
#line 1184
    saa7164_api_get_load_info(dev, & fwinfo);
#line 1185
    tmp___0 = jiffies_to_msecs(jiffies);
#line 1185
    last_poll_time = (u64 )tmp___0;
  } else {

  }
#line 1188
  goto ldv_52378;
  ldv_52377: ;
#line 1190
  if ((saa_debug & 4096U) != 0U) {
#line 1190
    printk("\017%s: thread exiting\n", (char *)(& dev->name));
  } else {

  }
#line 1191
  return (0);
}
}
#line 1194 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static bool saa7164_enable_msi(struct pci_dev *pci_dev , struct saa7164_dev *dev ) 
{ 
  int err ;

  {
#line 1198
  if (! enable_msi) {
#line 1199
    printk("\f%s() MSI disabled by module parameter \'enable_msi\'", "saa7164_enable_msi");
#line 1201
    return (0);
  } else {

  }
#line 1204
  err = pci_enable_msi_exact(pci_dev, 1);
#line 1206
  if (err != 0) {
#line 1207
    printk("\v%s() Failed to enable MSI interrupt. Falling back to a shared IRQ\n",
           "saa7164_enable_msi");
#line 1209
    return (0);
  } else {

  }
#line 1213
  err = ldv_request_irq_88(pci_dev->irq, & saa7164_irq, 0UL, (char const   *)(& dev->name),
                           (void *)dev);
#line 1216
  if (err != 0) {
#line 1218
    printk("\v%s() Failed to get an MSI interrupt. Falling back to a shared IRQ\n",
           "saa7164_enable_msi");
#line 1220
    pci_disable_msi(pci_dev);
#line 1221
    return (0);
  } else {

  }
#line 1224
  return (1);
}
}
#line 1227 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_initdev(struct pci_dev *pci_dev , struct pci_device_id  const  *pci_id ) 
{ 
  struct saa7164_dev *dev ;
  int err ;
  int i ;
  u32 version ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct task_struct *__k ;
  struct task_struct *tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;

  {
#line 1234
  tmp = kzalloc(130608UL, 208U);
#line 1234
  dev = (struct saa7164_dev *)tmp;
#line 1235
  if ((unsigned long )dev == (unsigned long )((struct saa7164_dev *)0)) {
#line 1236
    return (-12);
  } else {

  }
#line 1238
  err = v4l2_device_register(& pci_dev->dev, & dev->v4l2_dev);
#line 1239
  if (err < 0) {
#line 1240
    dev_err((struct device  const  *)(& pci_dev->dev), "v4l2_device_register failed\n");
#line 1241
    goto fail_free;
  } else {

  }
#line 1245
  dev->pci = pci_dev;
#line 1246
  tmp___0 = pci_enable_device(pci_dev);
#line 1246
  if (tmp___0 != 0) {
#line 1247
    err = -5;
#line 1248
    goto fail_free;
  } else {

  }
#line 1251
  tmp___1 = saa7164_dev_setup(dev);
#line 1251
  if (tmp___1 < 0) {
#line 1252
    err = -22;
#line 1253
    goto fail_free;
  } else {

  }
#line 1257
  dev->pci_rev = pci_dev->revision;
#line 1258
  pci_read_config_byte((struct pci_dev  const  *)pci_dev, 13, & dev->pci_lat);
#line 1259
  tmp___2 = pci_name((struct pci_dev  const  *)pci_dev);
#line 1259
  printk("\016%s/0: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\n", (char *)(& dev->name),
         tmp___2, (int )dev->pci_rev, pci_dev->irq, (int )dev->pci_lat, pci_dev->resource[0].start);
#line 1265
  pci_set_master(pci_dev);
#line 1267
  tmp___3 = pci_dma_supported(pci_dev, 4294967295ULL);
#line 1267
  if (tmp___3 == 0) {
#line 1268
    printk("%s/0: Oops: no 32bit PCI DMA ???\n", (char *)(& dev->name));
#line 1269
    err = -5;
#line 1270
    goto fail_irq;
  } else {

  }
#line 1274
  tmp___4 = saa7164_enable_msi(pci_dev, dev);
#line 1274
  if ((int )tmp___4) {
#line 1275
    dev->msi = 1;
  } else {
#line 1280
    err = ldv_request_irq_89(pci_dev->irq, & saa7164_irq, 128UL, (char const   *)(& dev->name),
                             (void *)dev);
#line 1283
    if (err < 0) {
#line 1284
      printk("\v%s: can\'t get IRQ %d\n", (char *)(& dev->name), pci_dev->irq);
#line 1286
      err = -5;
#line 1287
      goto fail_irq;
    } else {

    }
  }
#line 1291
  pci_set_drvdata(pci_dev, (void *)dev);
#line 1294
  i = 0;
#line 1294
  goto ldv_52398;
  ldv_52397: 
#line 1295
  dev->cmds[i].seqno = (u8 )i;
#line 1296
  dev->cmds[i].inuse = 0U;
#line 1297
  __mutex_init(& dev->cmds[i].lock, "&dev->cmds[i].lock", & __key);
#line 1298
  __init_waitqueue_head(& dev->cmds[i].wait, "&dev->cmds[i].wait", & __key___0);
#line 1294
  i = i + 1;
  ldv_52398: ;
#line 1294
  if (i <= 255) {
#line 1296
    goto ldv_52397;
  } else {

  }
#line 1302
  __init_work(& dev->workcmd, 0);
#line 1302
  __constr_expr_0.counter = 137438953408L;
#line 1302
  dev->workcmd.data = __constr_expr_0;
#line 1302
  lockdep_init_map(& dev->workcmd.lockdep_map, "(&dev->workcmd)", & __key___1, 0);
#line 1302
  INIT_LIST_HEAD(& dev->workcmd.entry);
#line 1302
  dev->workcmd.func = & saa7164_work_cmdhandler;
#line 1305
  if (dev->board != 0U) {
#line 1307
    err = saa7164_downloadfirmware(dev);
#line 1308
    if (err < 0) {
#line 1309
      printk("\vFailed to boot firmware, no features registered\n");
#line 1312
      goto fail_fw;
    } else {

    }
#line 1315
    saa7164_get_descriptors(dev);
#line 1316
    saa7164_dumpregs(dev, 0U);
#line 1317
    saa7164_getcurrentfirmwareversion(dev);
#line 1318
    saa7164_getfirmwarestatus(dev);
#line 1319
    err = saa7164_bus_setup(dev);
#line 1320
    if (err < 0) {
#line 1321
      printk("\vFailed to setup the bus, will continue\n");
    } else {

    }
#line 1323
    saa7164_bus_dump(dev);
#line 1328
    version = 0U;
#line 1329
    tmp___5 = saa7164_api_get_fw_version(dev, & version);
#line 1329
    if (tmp___5 == 0) {
#line 1330
      if ((int )saa_debug & 1) {
#line 1330
        printk("\017%s: Bus is operating correctly using version %d.%d.%d.%d (0x%x)\n",
               (char *)(& dev->name), (version & 64512U) >> 10, (version & 992U) >> 5,
               version & 31U, version >> 16, version);
      } else {

      }
    } else {
#line 1338
      printk("\vFailed to communicate with the firmware\n");
    }
#line 1342
    saa7164_i2c_register((struct saa7164_i2c *)(& dev->i2c_bus));
#line 1343
    saa7164_i2c_register((struct saa7164_i2c *)(& dev->i2c_bus) + 1UL);
#line 1344
    saa7164_i2c_register((struct saa7164_i2c *)(& dev->i2c_bus) + 2UL);
#line 1345
    saa7164_gpio_setup(dev);
#line 1346
    saa7164_card_setup(dev);
#line 1354
    saa7164_api_enum_subdevs(dev);
#line 1357
    if ((unsigned int )saa7164_boards[dev->board].porta == 1U) {
#line 1358
      tmp___6 = saa7164_dvb_register((struct saa7164_port *)(& dev->ports));
#line 1358
      if (tmp___6 < 0) {
#line 1359
        printk("\v%s() Failed to register dvb adapters on porta\n", "saa7164_initdev");
      } else {

      }
    } else {

    }
#line 1365
    if ((unsigned int )saa7164_boards[dev->board].portb == 1U) {
#line 1366
      tmp___7 = saa7164_dvb_register((struct saa7164_port *)(& dev->ports) + 1UL);
#line 1366
      if (tmp___7 < 0) {
#line 1367
        printk("\v%s() Failed to register dvb adapters on portb\n", "saa7164_initdev");
      } else {

      }
    } else {

    }
#line 1373
    if ((unsigned int )saa7164_boards[dev->board].portc == 2U) {
#line 1374
      tmp___8 = saa7164_encoder_register((struct saa7164_port *)(& dev->ports) + 2UL);
#line 1374
      if (tmp___8 < 0) {
#line 1375
        printk("\v%s() Failed to register mpeg encoder\n", "saa7164_initdev");
      } else {

      }
    } else {

    }
#line 1380
    if ((unsigned int )saa7164_boards[dev->board].portd == 2U) {
#line 1381
      tmp___9 = saa7164_encoder_register((struct saa7164_port *)(& dev->ports) + 3UL);
#line 1381
      if (tmp___9 < 0) {
#line 1382
        printk("\v%s() Failed to register mpeg encoder\n", "saa7164_initdev");
      } else {

      }
    } else {

    }
#line 1387
    if ((unsigned int )saa7164_boards[dev->board].porte == 3U) {
#line 1388
      tmp___10 = saa7164_vbi_register((struct saa7164_port *)(& dev->ports) + 4UL);
#line 1388
      if (tmp___10 < 0) {
#line 1389
        printk("\v%s() Failed to register vbi device\n", "saa7164_initdev");
      } else {

      }
    } else {

    }
#line 1394
    if ((unsigned int )saa7164_boards[dev->board].portf == 3U) {
#line 1395
      tmp___11 = saa7164_vbi_register((struct saa7164_port *)(& dev->ports) + 5UL);
#line 1395
      if (tmp___11 < 0) {
#line 1396
        printk("\v%s() Failed to register vbi device\n", "saa7164_initdev");
      } else {

      }
    } else {

    }
#line 1400
    saa7164_api_set_debug(dev, (int )((u8 )fw_debug));
#line 1402
    if (fw_debug != 0U) {
#line 1403
      tmp___12 = kthread_create_on_node(& saa7164_thread_function, (void *)dev, -1,
                                        "saa7164 debug");
#line 1403
      __k = tmp___12;
#line 1403
      tmp___13 = IS_ERR((void const   *)__k);
#line 1403
      if (tmp___13) {
#line 1403
        tmp___14 = 0;
      } else {
#line 1403
        tmp___14 = 1;
      }
#line 1403
      if (tmp___14) {
#line 1403
        wake_up_process(__k);
      } else {

      }
#line 1403
      dev->kthread = __k;
#line 1405
      tmp___15 = IS_ERR((void const   *)dev->kthread);
#line 1405
      if ((int )tmp___15) {
#line 1406
        dev->kthread = (struct task_struct *)0;
#line 1407
        printk("\v%s() Failed to create debug kernel thread\n", "saa7164_initdev");
      } else {

      }
    } else {

    }
  } else {
#line 1414
    printk("\v%s() Unsupported board detected, registering without firmware\n", "saa7164_initdev");
  }
#line 1417
  if ((int )saa_debug & 1) {
#line 1417
    printk("\017%s: %s() parameter debug = %d\n", (char *)(& dev->name), "saa7164_initdev",
           saa_debug);
  } else {

  }
#line 1418
  if ((int )saa_debug & 1) {
#line 1418
    printk("\017%s: %s() parameter waitsecs = %d\n", (char *)(& dev->name), "saa7164_initdev",
           waitsecs);
  } else {

  }
  fail_fw: ;
#line 1421
  return (0);
  fail_irq: 
#line 1424
  saa7164_dev_unregister(dev);
  fail_free: 
#line 1426
  v4l2_device_unregister(& dev->v4l2_dev);
#line 1427
  kfree((void const   *)dev);
#line 1428
  return (err);
}
}
#line 1431 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_shutdown(struct saa7164_dev *dev ) 
{ 


  {
#line 1433
  if ((int )saa_debug & 1) {
#line 1433
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_shutdown");
  } else {

  }
#line 1434
  return;
}
}
#line 1436 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_finidev(struct pci_dev *pci_dev ) 
{ 
  struct saa7164_dev *dev ;
  void *tmp ;

  {
#line 1438
  tmp = pci_get_drvdata(pci_dev);
#line 1438
  dev = (struct saa7164_dev *)tmp;
#line 1440
  if (dev->board != 0U) {
#line 1441
    if (fw_debug != 0U && (unsigned long )dev->kthread != (unsigned long )((struct task_struct *)0)) {
#line 1442
      kthread_stop(dev->kthread);
#line 1443
      dev->kthread = (struct task_struct *)0;
    } else {

    }
#line 1445
    if (dev->firmwareloaded != 0U) {
#line 1446
      saa7164_api_set_debug(dev, 0);
    } else {

    }
  } else {

  }
#line 1449
  saa7164_histogram_print((struct saa7164_port *)(& dev->ports) + 2UL, & dev->ports[2].irq_interval);
#line 1451
  saa7164_histogram_print((struct saa7164_port *)(& dev->ports) + 2UL, & dev->ports[2].svc_interval);
#line 1453
  saa7164_histogram_print((struct saa7164_port *)(& dev->ports) + 2UL, & dev->ports[2].irq_svc_interval);
#line 1455
  saa7164_histogram_print((struct saa7164_port *)(& dev->ports) + 2UL, & dev->ports[2].read_interval);
#line 1457
  saa7164_histogram_print((struct saa7164_port *)(& dev->ports) + 2UL, & dev->ports[2].poll_interval);
#line 1459
  saa7164_histogram_print((struct saa7164_port *)(& dev->ports) + 4UL, & dev->ports[4].read_interval);
#line 1461
  saa7164_histogram_print((struct saa7164_port *)(& dev->ports) + 5UL, & dev->ports[5].poll_interval);
#line 1464
  saa7164_shutdown(dev);
#line 1466
  if ((unsigned int )saa7164_boards[dev->board].porta == 1U) {
#line 1467
    saa7164_dvb_unregister((struct saa7164_port *)(& dev->ports));
  } else {

  }
#line 1469
  if ((unsigned int )saa7164_boards[dev->board].portb == 1U) {
#line 1470
    saa7164_dvb_unregister((struct saa7164_port *)(& dev->ports) + 1UL);
  } else {

  }
#line 1472
  if ((unsigned int )saa7164_boards[dev->board].portc == 2U) {
#line 1473
    saa7164_encoder_unregister((struct saa7164_port *)(& dev->ports) + 2UL);
  } else {

  }
#line 1475
  if ((unsigned int )saa7164_boards[dev->board].portd == 2U) {
#line 1476
    saa7164_encoder_unregister((struct saa7164_port *)(& dev->ports) + 3UL);
  } else {

  }
#line 1478
  if ((unsigned int )saa7164_boards[dev->board].porte == 3U) {
#line 1479
    saa7164_vbi_unregister((struct saa7164_port *)(& dev->ports) + 4UL);
  } else {

  }
#line 1481
  if ((unsigned int )saa7164_boards[dev->board].portf == 3U) {
#line 1482
    saa7164_vbi_unregister((struct saa7164_port *)(& dev->ports) + 5UL);
  } else {

  }
#line 1484
  saa7164_i2c_unregister((struct saa7164_i2c *)(& dev->i2c_bus));
#line 1485
  saa7164_i2c_unregister((struct saa7164_i2c *)(& dev->i2c_bus) + 1UL);
#line 1486
  saa7164_i2c_unregister((struct saa7164_i2c *)(& dev->i2c_bus) + 2UL);
#line 1489
  ldv_free_irq_90(pci_dev->irq, (void *)dev);
#line 1491
  if ((int )dev->msi) {
#line 1492
    pci_disable_msi(pci_dev);
#line 1493
    dev->msi = 0;
  } else {

  }
#line 1496
  pci_disable_device(pci_dev);
#line 1498
  mutex_lock_nested(& devlist, 0U);
#line 1499
  list_del(& dev->devlist);
#line 1500
  mutex_unlock(& devlist);
#line 1502
  saa7164_dev_unregister(dev);
#line 1503
  v4l2_device_unregister(& dev->v4l2_dev);
#line 1504
  kfree((void const   *)dev);
#line 1505
  return;
}
}
#line 1507 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static struct pci_device_id saa7164_pci_tbl[2U]  = {      {4401U, 29028U, 4294967295U, 4294967295U, 0U, 0U, 0UL}};
#line 1518 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
struct pci_device_id  const  __mod_pci__saa7164_pci_tbl_device_table[2U]  ;
#line 1520 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static struct pci_driver saa7164_pci_driver  = 
#line 1520
     {{0, 0}, "saa7164", (struct pci_device_id  const  *)(& saa7164_pci_tbl), & saa7164_initdev,
    & saa7164_finidev, (int (*)(struct pci_dev * , pm_message_t  ))0, 0, 0, (int (*)(struct pci_dev * ))0,
    0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0}}, 0U,
                                                                          0U, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                       {0, 0}}};
#line 1530 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static int saa7164_init(void) 
{ 
  int tmp ;

  {
#line 1532
  printk("\016saa7164 driver loaded\n");
#line 1535
  saa7164_proc_create();
#line 1537
  tmp = ldv___pci_register_driver_91(& saa7164_pci_driver, & __this_module, "saa7164");
#line 1537
  return (tmp);
}
}
#line 1540 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.c"
static void saa7164_fini(void) 
{ 


  {
#line 1543
  remove_proc_entry("saa7164", (struct proc_dir_entry *)0);
#line 1545
  ldv_pci_unregister_driver_92(& saa7164_pci_driver);
#line 1546
  return;
}
}
#line 144 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_retval_0  ;
#line 145 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_retval_4  ;
#line 146
extern void ldv_initialize(void) ;
#line 147
extern void ldv_check_final_state(void) ;
#line 148 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_retval_3  ;
#line 149
extern int ldv_shutdown_11(void) ;
#line 152 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void activate_work_5(struct work_struct *work , int state ) 
{ 


  {
#line 153
  if (ldv_work_5_0 == 0) {
#line 154
    ldv_work_struct_5_0 = work;
#line 155
    ldv_work_5_0 = state;
#line 156
    return;
  } else {

  }
#line 159
  if (ldv_work_5_1 == 0) {
#line 160
    ldv_work_struct_5_1 = work;
#line 161
    ldv_work_5_1 = state;
#line 162
    return;
  } else {

  }
#line 165
  if (ldv_work_5_2 == 0) {
#line 166
    ldv_work_struct_5_2 = work;
#line 167
    ldv_work_5_2 = state;
#line 168
    return;
  } else {

  }
#line 171
  if (ldv_work_5_3 == 0) {
#line 172
    ldv_work_struct_5_3 = work;
#line 173
    ldv_work_5_3 = state;
#line 174
    return;
  } else {

  }
#line 176
  return;
}
}
#line 179 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 180
  ldv_work_3_0 = 0;
#line 181
  ldv_work_3_1 = 0;
#line 182
  ldv_work_3_2 = 0;
#line 183
  ldv_work_3_3 = 0;
#line 184
  return;
}
}
#line 187 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void choose_interrupt_2(void) 
{ 
  int tmp ;

  {
#line 188
  tmp = __VERIFIER_nondet_int();
#line 188
  switch (tmp) {
  case 0: 
#line 190
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_0, ldv_irq_line_2_0, ldv_irq_data_2_0);
#line 192
  goto ldv_52453;
  case 1: 
#line 194
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_1, ldv_irq_line_2_1, ldv_irq_data_2_1);
#line 196
  goto ldv_52453;
  case 2: 
#line 198
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_2, ldv_irq_line_2_2, ldv_irq_data_2_2);
#line 200
  goto ldv_52453;
  case 3: 
#line 202
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_3, ldv_irq_line_2_3, ldv_irq_data_2_3);
#line 204
  goto ldv_52453;
  default: 
#line 205
  ldv_stop();
  }
  ldv_52453: ;
#line 207
  return;
}
}
#line 211 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void disable_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 212
  if (ldv_irq_2_0 != 0 && line == ldv_irq_line_2_0) {
#line 213
    ldv_irq_2_0 = 0;
#line 214
    return;
  } else {

  }
#line 216
  if (ldv_irq_2_1 != 0 && line == ldv_irq_line_2_1) {
#line 217
    ldv_irq_2_1 = 0;
#line 218
    return;
  } else {

  }
#line 220
  if (ldv_irq_2_2 != 0 && line == ldv_irq_line_2_2) {
#line 221
    ldv_irq_2_2 = 0;
#line 222
    return;
  } else {

  }
#line 224
  if (ldv_irq_2_3 != 0 && line == ldv_irq_line_2_3) {
#line 225
    ldv_irq_2_3 = 0;
#line 226
    return;
  } else {

  }
#line 228
  return;
}
}
#line 232 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
#line 233
  if (ldv_work_4_0 == 0) {
#line 234
    ldv_work_struct_4_0 = work;
#line 235
    ldv_work_4_0 = state;
#line 236
    return;
  } else {

  }
#line 239
  if (ldv_work_4_1 == 0) {
#line 240
    ldv_work_struct_4_1 = work;
#line 241
    ldv_work_4_1 = state;
#line 242
    return;
  } else {

  }
#line 245
  if (ldv_work_4_2 == 0) {
#line 246
    ldv_work_struct_4_2 = work;
#line 247
    ldv_work_4_2 = state;
#line 248
    return;
  } else {

  }
#line 251
  if (ldv_work_4_3 == 0) {
#line 252
    ldv_work_struct_4_3 = work;
#line 253
    ldv_work_4_3 = state;
#line 254
    return;
  } else {

  }
#line 256
  return;
}
}
#line 259 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void call_and_disable_all_5(int state ) 
{ 


  {
#line 261
  if (ldv_work_5_0 == state) {
#line 262
    call_and_disable_work_5(ldv_work_struct_5_0);
  } else {

  }
#line 263
  if (ldv_work_5_1 == state) {
#line 264
    call_and_disable_work_5(ldv_work_struct_5_1);
  } else {

  }
#line 265
  if (ldv_work_5_2 == state) {
#line 266
    call_and_disable_work_5(ldv_work_struct_5_2);
  } else {

  }
#line 267
  if (ldv_work_5_3 == state) {
#line 268
    call_and_disable_work_5(ldv_work_struct_5_3);
  } else {

  }
#line 269
  return;
}
}
#line 272 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void activate_suitable_irq_2(int line , void *data ) 
{ 


  {
#line 273
  if (ldv_irq_2_0 == 0) {
#line 274
    ldv_irq_line_2_0 = line;
#line 275
    ldv_irq_data_2_0 = data;
#line 276
    ldv_irq_2_0 = 1;
#line 277
    return;
  } else {

  }
#line 279
  if (ldv_irq_2_1 == 0) {
#line 280
    ldv_irq_line_2_1 = line;
#line 281
    ldv_irq_data_2_1 = data;
#line 282
    ldv_irq_2_1 = 1;
#line 283
    return;
  } else {

  }
#line 285
  if (ldv_irq_2_2 == 0) {
#line 286
    ldv_irq_line_2_2 = line;
#line 287
    ldv_irq_data_2_2 = data;
#line 288
    ldv_irq_2_2 = 1;
#line 289
    return;
  } else {

  }
#line 291
  if (ldv_irq_2_3 == 0) {
#line 292
    ldv_irq_line_2_3 = line;
#line 293
    ldv_irq_data_2_3 = data;
#line 294
    ldv_irq_2_3 = 1;
#line 295
    return;
  } else {

  }
#line 297
  return;
}
}
#line 301 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 302
  if ((unsigned long )handler == (unsigned long )(& saa7164_irq)) {
#line 303
    return (1);
  } else {

  }
#line 305
  return (0);
}
}
#line 309 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 310
  if (ldv_work_3_0 == 0) {
#line 311
    ldv_work_struct_3_0 = work;
#line 312
    ldv_work_3_0 = state;
#line 313
    return;
  } else {

  }
#line 316
  if (ldv_work_3_1 == 0) {
#line 317
    ldv_work_struct_3_1 = work;
#line 318
    ldv_work_3_1 = state;
#line 319
    return;
  } else {

  }
#line 322
  if (ldv_work_3_2 == 0) {
#line 323
    ldv_work_struct_3_2 = work;
#line 324
    ldv_work_3_2 = state;
#line 325
    return;
  } else {

  }
#line 328
  if (ldv_work_3_3 == 0) {
#line 329
    ldv_work_struct_3_3 = work;
#line 330
    ldv_work_3_3 = state;
#line 331
    return;
  } else {

  }
#line 333
  return;
}
}
#line 336 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void work_init_5(void) 
{ 


  {
#line 337
  ldv_work_5_0 = 0;
#line 338
  ldv_work_5_1 = 0;
#line 339
  ldv_work_5_2 = 0;
#line 340
  ldv_work_5_3 = 0;
#line 341
  return;
}
}
#line 344 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void call_and_disable_all_4(int state ) 
{ 


  {
#line 346
  if (ldv_work_4_0 == state) {
#line 347
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
#line 348
  if (ldv_work_4_1 == state) {
#line 349
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
#line 350
  if (ldv_work_4_2 == state) {
#line 351
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
#line 352
  if (ldv_work_4_3 == state) {
#line 353
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
#line 354
  return;
}
}
#line 357 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = __VERIFIER_nondet_int();
#line 358
  switch (tmp) {
  case 0: 
#line 360
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
#line 362
  goto ldv_52492;
  case 1: 
#line 364
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
#line 366
  goto ldv_52492;
  case 2: 
#line 368
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
#line 370
  goto ldv_52492;
  case 3: 
#line 372
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
#line 374
  goto ldv_52492;
  default: 
#line 375
  ldv_stop();
  }
  ldv_52492: ;
#line 377
  return;
}
}
#line 381 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void invoke_work_5(void) 
{ 
  int tmp ;

  {
#line 383
  tmp = __VERIFIER_nondet_int();
#line 383
  switch (tmp) {
  case 0: ;
#line 385
  if (ldv_work_5_0 == 2 || ldv_work_5_0 == 3) {
#line 386
    ldv_work_5_0 = 4;
#line 387
    saa7164_work_cmdhandler(ldv_work_struct_5_0);
#line 388
    ldv_work_5_0 = 1;
  } else {

  }
#line 391
  goto ldv_52503;
  case 1: ;
#line 393
  if (ldv_work_5_1 == 2 || ldv_work_5_1 == 3) {
#line 394
    ldv_work_5_1 = 4;
#line 395
    saa7164_work_cmdhandler(ldv_work_struct_5_0);
#line 396
    ldv_work_5_1 = 1;
  } else {

  }
#line 399
  goto ldv_52503;
  case 2: ;
#line 401
  if (ldv_work_5_2 == 2 || ldv_work_5_2 == 3) {
#line 402
    ldv_work_5_2 = 4;
#line 403
    saa7164_work_cmdhandler(ldv_work_struct_5_0);
#line 404
    ldv_work_5_2 = 1;
  } else {

  }
#line 407
  goto ldv_52503;
  case 3: ;
#line 409
  if (ldv_work_5_3 == 2 || ldv_work_5_3 == 3) {
#line 410
    ldv_work_5_3 = 4;
#line 411
    saa7164_work_cmdhandler(ldv_work_struct_5_0);
#line 412
    ldv_work_5_3 = 1;
  } else {

  }
#line 415
  goto ldv_52503;
  default: 
#line 416
  ldv_stop();
  }
  ldv_52503: ;
#line 418
  return;
}
}
#line 422 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
#line 423
  if ((unsigned long )handler == (unsigned long )(& saa7164_irq)) {
#line 424
    return (1);
  } else {

  }
#line 426
  return (0);
}
}
#line 430 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void disable_work_5(struct work_struct *work ) 
{ 


  {
#line 432
  if ((ldv_work_5_0 == 3 || ldv_work_5_0 == 2) && (unsigned long )ldv_work_struct_5_0 == (unsigned long )work) {
#line 434
    ldv_work_5_0 = 1;
  } else {

  }
#line 436
  if ((ldv_work_5_1 == 3 || ldv_work_5_1 == 2) && (unsigned long )ldv_work_struct_5_1 == (unsigned long )work) {
#line 438
    ldv_work_5_1 = 1;
  } else {

  }
#line 440
  if ((ldv_work_5_2 == 3 || ldv_work_5_2 == 2) && (unsigned long )ldv_work_struct_5_2 == (unsigned long )work) {
#line 442
    ldv_work_5_2 = 1;
  } else {

  }
#line 444
  if ((ldv_work_5_3 == 3 || ldv_work_5_3 == 2) && (unsigned long )ldv_work_struct_5_3 == (unsigned long )work) {
#line 446
    ldv_work_5_3 = 1;
  } else {

  }
#line 447
  return;
}
}
#line 451 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 454
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 456
    saa7164_work_enchandler(work);
#line 457
    ldv_work_3_0 = 1;
#line 458
    return;
  } else {

  }
#line 460
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 462
    saa7164_work_enchandler(work);
#line 463
    ldv_work_3_1 = 1;
#line 464
    return;
  } else {

  }
#line 466
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 468
    saa7164_work_enchandler(work);
#line 469
    ldv_work_3_2 = 1;
#line 470
    return;
  } else {

  }
#line 472
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 474
    saa7164_work_enchandler(work);
#line 475
    ldv_work_3_3 = 1;
#line 476
    return;
  } else {

  }
#line 478
  return;
}
}
#line 481 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 483
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 485
    ldv_work_3_0 = 1;
  } else {

  }
#line 487
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 489
    ldv_work_3_1 = 1;
  } else {

  }
#line 491
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 493
    ldv_work_3_2 = 1;
  } else {

  }
#line 495
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 497
    ldv_work_3_3 = 1;
  } else {

  }
#line 498
  return;
}
}
#line 502 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void disable_work_4(struct work_struct *work ) 
{ 


  {
#line 504
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
#line 506
    ldv_work_4_0 = 1;
  } else {

  }
#line 508
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
#line 510
    ldv_work_4_1 = 1;
  } else {

  }
#line 512
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
#line 514
    ldv_work_4_2 = 1;
  } else {

  }
#line 516
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
#line 518
    ldv_work_4_3 = 1;
  } else {

  }
#line 519
  return;
}
}
#line 523 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void work_init_4(void) 
{ 


  {
#line 524
  ldv_work_4_0 = 0;
#line 525
  ldv_work_4_1 = 0;
#line 526
  ldv_work_4_2 = 0;
#line 527
  ldv_work_4_3 = 0;
#line 528
  return;
}
}
#line 531 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 533
  tmp = __VERIFIER_nondet_int();
#line 533
  switch (tmp) {
  case 0: ;
#line 535
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 536
    ldv_work_3_0 = 4;
#line 537
    saa7164_work_enchandler(ldv_work_struct_3_0);
#line 538
    ldv_work_3_0 = 1;
  } else {

  }
#line 541
  goto ldv_52536;
  case 1: ;
#line 543
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 544
    ldv_work_3_1 = 4;
#line 545
    saa7164_work_enchandler(ldv_work_struct_3_0);
#line 546
    ldv_work_3_1 = 1;
  } else {

  }
#line 549
  goto ldv_52536;
  case 2: ;
#line 551
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 552
    ldv_work_3_2 = 4;
#line 553
    saa7164_work_enchandler(ldv_work_struct_3_0);
#line 554
    ldv_work_3_2 = 1;
  } else {

  }
#line 557
  goto ldv_52536;
  case 3: ;
#line 559
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 560
    ldv_work_3_3 = 4;
#line 561
    saa7164_work_enchandler(ldv_work_struct_3_0);
#line 562
    ldv_work_3_3 = 1;
  } else {

  }
#line 565
  goto ldv_52536;
  default: 
#line 566
  ldv_stop();
  }
  ldv_52536: ;
#line 568
  return;
}
}
#line 572 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 573
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
#line 574
    ldv_irq_1_0 = 0;
#line 575
    return;
  } else {

  }
#line 577
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
#line 578
    ldv_irq_1_1 = 0;
#line 579
    return;
  } else {

  }
#line 581
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
#line 582
    ldv_irq_1_2 = 0;
#line 583
    return;
  } else {

  }
#line 585
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
#line 586
    ldv_irq_1_3 = 0;
#line 587
    return;
  } else {

  }
#line 589
  return;
}
}
#line 593 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 595
  tmp = __VERIFIER_nondet_int();
#line 595
  irq_retval = (irqreturn_t )tmp;
#line 597
  if (state != 0) {
#line 598
    tmp___0 = __VERIFIER_nondet_int();
#line 598
    switch (tmp___0) {
    case 0: ;
#line 600
    if (state == 1) {
#line 601
      LDV_IN_INTERRUPT = 2;
#line 602
      irq_retval = saa7164_irq(line, data);
#line 603
      LDV_IN_INTERRUPT = 1;
#line 604
      return (state);
    } else {

    }
#line 607
    goto ldv_52552;
    default: 
#line 608
    ldv_stop();
    }
    ldv_52552: ;
  } else {

  }
#line 611
  return (state);
}
}
#line 615 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
#line 616
  if (ldv_irq_1_0 == 0) {
#line 617
    ldv_irq_line_1_0 = line;
#line 618
    ldv_irq_data_1_0 = data;
#line 619
    ldv_irq_1_0 = 1;
#line 620
    return;
  } else {

  }
#line 622
  if (ldv_irq_1_1 == 0) {
#line 623
    ldv_irq_line_1_1 = line;
#line 624
    ldv_irq_data_1_1 = data;
#line 625
    ldv_irq_1_1 = 1;
#line 626
    return;
  } else {

  }
#line 628
  if (ldv_irq_1_2 == 0) {
#line 629
    ldv_irq_line_1_2 = line;
#line 630
    ldv_irq_data_1_2 = data;
#line 631
    ldv_irq_1_2 = 1;
#line 632
    return;
  } else {

  }
#line 634
  if (ldv_irq_1_3 == 0) {
#line 635
    ldv_irq_line_1_3 = line;
#line 636
    ldv_irq_data_1_3 = data;
#line 637
    ldv_irq_1_3 = 1;
#line 638
    return;
  } else {

  }
#line 640
  return;
}
}
#line 645 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void invoke_work_4(void) 
{ 
  int tmp ;

  {
#line 647
  tmp = __VERIFIER_nondet_int();
#line 647
  switch (tmp) {
  case 0: ;
#line 649
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
#line 650
    ldv_work_4_0 = 4;
#line 651
    saa7164_work_vbihandler(ldv_work_struct_4_0);
#line 652
    ldv_work_4_0 = 1;
  } else {

  }
#line 655
  goto ldv_52566;
  case 1: ;
#line 657
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
#line 658
    ldv_work_4_1 = 4;
#line 659
    saa7164_work_vbihandler(ldv_work_struct_4_0);
#line 660
    ldv_work_4_1 = 1;
  } else {

  }
#line 663
  goto ldv_52566;
  case 2: ;
#line 665
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
#line 666
    ldv_work_4_2 = 4;
#line 667
    saa7164_work_vbihandler(ldv_work_struct_4_0);
#line 668
    ldv_work_4_2 = 1;
  } else {

  }
#line 671
  goto ldv_52566;
  case 3: ;
#line 673
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
#line 674
    ldv_work_4_3 = 4;
#line 675
    saa7164_work_vbihandler(ldv_work_struct_4_0);
#line 676
    ldv_work_4_3 = 1;
  } else {

  }
#line 679
  goto ldv_52566;
  default: 
#line 680
  ldv_stop();
  }
  ldv_52566: ;
#line 682
  return;
}
}
#line 686 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void call_and_disable_work_5(struct work_struct *work ) 
{ 


  {
#line 689
  if ((ldv_work_5_0 == 2 || ldv_work_5_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_0) {
#line 691
    saa7164_work_cmdhandler(work);
#line 692
    ldv_work_5_0 = 1;
#line 693
    return;
  } else {

  }
#line 695
  if ((ldv_work_5_1 == 2 || ldv_work_5_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_1) {
#line 697
    saa7164_work_cmdhandler(work);
#line 698
    ldv_work_5_1 = 1;
#line 699
    return;
  } else {

  }
#line 701
  if ((ldv_work_5_2 == 2 || ldv_work_5_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_2) {
#line 703
    saa7164_work_cmdhandler(work);
#line 704
    ldv_work_5_2 = 1;
#line 705
    return;
  } else {

  }
#line 707
  if ((ldv_work_5_3 == 2 || ldv_work_5_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_3) {
#line 709
    saa7164_work_cmdhandler(work);
#line 710
    ldv_work_5_3 = 1;
#line 711
    return;
  } else {

  }
#line 713
  return;
}
}
#line 716 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 718
  if (ldv_work_3_0 == state) {
#line 719
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 720
  if (ldv_work_3_1 == state) {
#line 721
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 722
  if (ldv_work_3_2 == state) {
#line 723
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 724
  if (ldv_work_3_3 == state) {
#line 725
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 726
  return;
}
}
#line 729 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void ldv_pci_driver_11(void) 
{ 
  void *tmp ;

  {
#line 730
  tmp = ldv_init_zalloc(2976UL);
#line 730
  saa7164_pci_driver_group1 = (struct pci_dev *)tmp;
#line 731
  return;
}
}
#line 734 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
#line 737
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
#line 739
    saa7164_work_vbihandler(work);
#line 740
    ldv_work_4_0 = 1;
#line 741
    return;
  } else {

  }
#line 743
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
#line 745
    saa7164_work_vbihandler(work);
#line 746
    ldv_work_4_1 = 1;
#line 747
    return;
  } else {

  }
#line 749
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
#line 751
    saa7164_work_vbihandler(work);
#line 752
    ldv_work_4_2 = 1;
#line 753
    return;
  } else {

  }
#line 755
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
#line 757
    saa7164_work_vbihandler(work);
#line 758
    ldv_work_4_3 = 1;
#line 759
    return;
  } else {

  }
#line 761
  return;
}
}
#line 764 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_irq_2(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 766
  tmp = __VERIFIER_nondet_int();
#line 766
  irq_retval = (irqreturn_t )tmp;
#line 768
  if (state != 0) {
#line 769
    tmp___0 = __VERIFIER_nondet_int();
#line 769
    switch (tmp___0) {
    case 0: ;
#line 771
    if (state == 1) {
#line 772
      LDV_IN_INTERRUPT = 2;
#line 773
      irq_retval = saa7164_irq(line, data);
#line 774
      LDV_IN_INTERRUPT = 1;
#line 775
      return (state);
    } else {

    }
#line 778
    goto ldv_52594;
    default: 
#line 779
    ldv_stop();
    }
    ldv_52594: ;
  } else {

  }
#line 782
  return (state);
}
}
#line 786 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void ldv_file_operations_12(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 787
  tmp = ldv_init_zalloc(1000UL);
#line 787
  saa7164_proc_fops_group1 = (struct inode *)tmp;
#line 788
  tmp___0 = ldv_init_zalloc(504UL);
#line 788
  saa7164_proc_fops_group2 = (struct file *)tmp___0;
#line 789
  return;
}
}
#line 796
void ldv_main_exported_6(void) ;
#line 797
void ldv_main_exported_7(void) ;
#line 798
void ldv_main_exported_10(void) ;
#line 799
void ldv_main_exported_8(void) ;
#line 800
void ldv_main_exported_9(void) ;
#line 804 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int main(void) 
{ 
  struct pci_device_id *ldvarg35 ;
  void *tmp ;
  int ldvarg48 ;
  size_t ldvarg51 ;
  char *ldvarg52 ;
  void *tmp___0 ;
  loff_t ldvarg49 ;
  loff_t *ldvarg50 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 807
  tmp = ldv_init_zalloc(32UL);
#line 807
  ldvarg35 = (struct pci_device_id *)tmp;
#line 810
  tmp___0 = ldv_init_zalloc(1UL);
#line 810
  ldvarg52 = (char *)tmp___0;
#line 812
  tmp___1 = ldv_init_zalloc(8UL);
#line 812
  ldvarg50 = (loff_t *)tmp___1;
#line 805
  ldv_initialize();
#line 808
  ldv_memset((void *)(& ldvarg48), 0, 4UL);
#line 809
  ldv_memset((void *)(& ldvarg51), 0, 8UL);
#line 811
  ldv_memset((void *)(& ldvarg49), 0, 8UL);
#line 814
  ldv_state_variable_6 = 0;
#line 815
  ldv_state_variable_11 = 0;
#line 817
  work_init_3();
#line 819
  ldv_state_variable_3 = 1;
#line 820
  ldv_state_variable_7 = 0;
#line 821
  ldv_state_variable_9 = 0;
#line 822
  ldv_state_variable_12 = 0;
#line 824
  ldv_state_variable_2 = 1;
#line 825
  ldv_state_variable_8 = 0;
#line 827
  ldv_state_variable_1 = 1;
#line 829
  work_init_4();
#line 831
  ldv_state_variable_4 = 1;
#line 832
  ref_cnt = 0;
#line 833
  ldv_state_variable_0 = 1;
#line 834
  ldv_state_variable_10 = 0;
#line 836
  work_init_5();
#line 838
  ldv_state_variable_5 = 1;
  ldv_52655: 
#line 840
  tmp___2 = __VERIFIER_nondet_int();
#line 840
  switch (tmp___2) {
  case 0: ;
#line 844
  if (ldv_state_variable_6 != 0) {
#line 845
    ldv_main_exported_6();
  } else {

  }
#line 848
  goto ldv_52625;
  case 1: ;
#line 852
  if (ldv_state_variable_11 != 0) {
#line 853
    tmp___3 = __VERIFIER_nondet_int();
#line 853
    switch (tmp___3) {
    case 0: ;
#line 856
    if (ldv_state_variable_11 == 1) {
#line 858
      ldv_retval_0 = saa7164_initdev(saa7164_pci_driver_group1, (struct pci_device_id  const  *)ldvarg35);
#line 859
      if (ldv_retval_0 == 0) {
#line 860
        ldv_state_variable_11 = 2;
#line 861
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 865
    goto ldv_52628;
    case 1: ;
#line 868
    if (ldv_state_variable_11 == 2) {
#line 870
      saa7164_finidev(saa7164_pci_driver_group1);
#line 871
      ldv_state_variable_11 = 1;
    } else {

    }
#line 874
    goto ldv_52628;
    case 2: ;
#line 877
    if (ldv_state_variable_11 == 2) {
#line 879
      ldv_shutdown_11();
#line 880
      ldv_state_variable_11 = 2;
    } else {

    }
#line 883
    goto ldv_52628;
    default: 
#line 884
    ldv_stop();
    }
    ldv_52628: ;
  } else {

  }
#line 888
  goto ldv_52625;
  case 2: ;
#line 892
  if (ldv_state_variable_3 != 0) {
#line 893
    invoke_work_3();
  } else {

  }
#line 896
  goto ldv_52625;
  case 3: ;
#line 900
  if (ldv_state_variable_7 != 0) {
#line 901
    ldv_main_exported_7();
  } else {

  }
#line 904
  goto ldv_52625;
  case 4: ;
#line 908
  if (ldv_state_variable_9 != 0) {
#line 909
    ldv_main_exported_9();
  } else {

  }
#line 912
  goto ldv_52625;
  case 5: ;
#line 916
  if (ldv_state_variable_12 != 0) {
#line 917
    tmp___4 = __VERIFIER_nondet_int();
#line 917
    switch (tmp___4) {
    case 0: ;
#line 920
    if (ldv_state_variable_12 == 2) {
#line 922
      single_release(saa7164_proc_fops_group1, saa7164_proc_fops_group2);
#line 923
      ldv_state_variable_12 = 1;
#line 924
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 927
    goto ldv_52637;
    case 1: ;
#line 930
    if (ldv_state_variable_12 == 2) {
#line 932
      seq_read(saa7164_proc_fops_group2, ldvarg52, ldvarg51, ldvarg50);
#line 934
      ldv_state_variable_12 = 2;
    } else {

    }
#line 937
    goto ldv_52637;
    case 2: ;
#line 940
    if (ldv_state_variable_12 == 2) {
#line 942
      seq_lseek(saa7164_proc_fops_group2, ldvarg49, ldvarg48);
#line 944
      ldv_state_variable_12 = 2;
    } else {

    }
#line 947
    goto ldv_52637;
    case 3: ;
#line 950
    if (ldv_state_variable_12 == 1) {
#line 952
      ldv_retval_3 = saa7164_proc_open(saa7164_proc_fops_group1, saa7164_proc_fops_group2);
#line 953
      if (ldv_retval_3 == 0) {
#line 954
        ldv_state_variable_12 = 2;
#line 955
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 959
    goto ldv_52637;
    default: 
#line 960
    ldv_stop();
    }
    ldv_52637: ;
  } else {

  }
#line 964
  goto ldv_52625;
  case 6: ;
#line 968
  if (ldv_state_variable_2 != 0) {
#line 969
    choose_interrupt_2();
  } else {

  }
#line 972
  goto ldv_52625;
  case 7: ;
#line 976
  if (ldv_state_variable_8 != 0) {
#line 977
    ldv_main_exported_8();
  } else {

  }
#line 980
  goto ldv_52625;
  case 8: ;
#line 984
  if (ldv_state_variable_1 != 0) {
#line 985
    choose_interrupt_1();
  } else {

  }
#line 988
  goto ldv_52625;
  case 9: ;
#line 992
  if (ldv_state_variable_4 != 0) {
#line 993
    invoke_work_4();
  } else {

  }
#line 996
  goto ldv_52625;
  case 10: ;
#line 1000
  if (ldv_state_variable_0 != 0) {
#line 1001
    tmp___5 = __VERIFIER_nondet_int();
#line 1001
    switch (tmp___5) {
    case 0: ;
#line 1004
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 1006
      saa7164_fini();
#line 1007
      ldv_state_variable_0 = 2;
#line 1008
      goto ldv_final;
    } else {

    }
#line 1011
    goto ldv_52649;
    case 1: ;
#line 1014
    if (ldv_state_variable_0 == 1) {
#line 1016
      ldv_retval_4 = saa7164_init();
#line 1018
      if (ldv_retval_4 == 0) {
#line 1019
        ldv_state_variable_0 = 3;
#line 1020
        ldv_state_variable_12 = 1;
#line 1021
        ldv_file_operations_12();
#line 1022
        ldv_state_variable_9 = 1;
#line 1023
        ldv_initialize_v4l2_file_operations_9();
#line 1024
        ldv_state_variable_10 = 1;
#line 1025
        ldv_initialize_i2c_algorithm_10();
#line 1026
        ldv_state_variable_7 = 1;
#line 1027
        ldv_initialize_v4l2_file_operations_7();
#line 1028
        ldv_state_variable_6 = 1;
#line 1029
        ldv_initialize_v4l2_ioctl_ops_6();
#line 1030
        ldv_state_variable_8 = 1;
#line 1031
        ldv_initialize_v4l2_ioctl_ops_8();
      } else {

      }
#line 1033
      if (ldv_retval_4 != 0) {
#line 1034
        ldv_state_variable_0 = 2;
#line 1035
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 1039
    goto ldv_52649;
    default: 
#line 1040
    ldv_stop();
    }
    ldv_52649: ;
  } else {

  }
#line 1044
  goto ldv_52625;
  case 11: ;
#line 1048
  if (ldv_state_variable_10 != 0) {
#line 1049
    ldv_main_exported_10();
  } else {

  }
#line 1052
  goto ldv_52625;
  case 12: ;
#line 1056
  if (ldv_state_variable_5 != 0) {
#line 1057
    invoke_work_5();
  } else {

  }
#line 1060
  goto ldv_52625;
  default: 
#line 1061
  ldv_stop();
  }
  ldv_52625: ;
#line 1063
  goto ldv_52655;
  ldv_final: 
#line 1065
  ldv_check_final_state();
#line 1066
  return 0;
}
}
#line 1081 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 1084
  tmp = ldv_is_err(ptr);
#line 1084
  return (tmp);
}
}
#line 1182 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1186
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1186
  ldv_func_res = tmp;
#line 1188
  activate_work_3(ldv_func_arg3, 2);
#line 1190
  return (ldv_func_res);
}
}
#line 1193 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
bool ldv_queue_delayed_work_on_62(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 1197
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1197
  ldv_func_res = tmp;
#line 1199
  activate_work_3(& ldv_func_arg3->work, 2);
#line 1201
  return (ldv_func_res);
}
}
#line 1204 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 1208
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1208
  ldv_func_res = tmp;
#line 1210
  activate_work_3(ldv_func_arg3, 2);
#line 1212
  return (ldv_func_res);
}
}
#line 1215 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1218
  flush_workqueue(ldv_func_arg1);
#line 1220
  call_and_disable_all_3(2);
#line 1221
  return;
}
}
#line 1223 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
bool ldv_queue_delayed_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 1227
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1227
  ldv_func_res = tmp;
#line 1229
  activate_work_3(& ldv_func_arg3->work, 2);
#line 1231
  return (ldv_func_res);
}
}
#line 1269 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void *ldv_kmem_cache_alloc_71(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1272
  ldv_check_alloc_flags(flags);
#line 1273
  tmp = ldv_undef_ptr();
#line 1273
  return (tmp);
}
}
#line 1276 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1279
  ldv_check_alloc_flags(flags);
#line 1280
  tmp = ldv_undef_ptr();
#line 1280
  return (tmp);
}
}
#line 1311 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_pskb_expand_head_77(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1314
  ldv_check_alloc_flags(flags);
#line 1315
  tmp = ldv_undef_ptr();
#line 1315
  return ((int )((long )tmp));
}
}
#line 1325 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct sk_buff *ldv_skb_clone_79(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1328
  ldv_check_alloc_flags(flags);
#line 1329
  tmp = ldv_undef_ptr();
#line 1329
  return ((struct sk_buff *)tmp);
}
}
#line 1339 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct sk_buff *ldv_skb_copy_81(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1342
  ldv_check_alloc_flags(flags);
#line 1343
  tmp = ldv_undef_ptr();
#line 1343
  return ((struct sk_buff *)tmp);
}
}
#line 1346 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_82(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1349
  ldv_check_alloc_flags(flags);
#line 1350
  tmp = ldv_undef_ptr();
#line 1350
  return ((struct sk_buff *)tmp);
}
}
#line 1353 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_83(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1356
  ldv_check_alloc_flags(flags);
#line 1357
  tmp = ldv_undef_ptr();
#line 1357
  return ((struct sk_buff *)tmp);
}
}
#line 1360 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_84(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1363
  ldv_check_alloc_flags(flags);
#line 1364
  tmp = ldv_undef_ptr();
#line 1364
  return ((struct sk_buff *)tmp);
}
}
#line 1367 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_pskb_expand_head_85(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1370
  ldv_check_alloc_flags(flags);
#line 1371
  tmp = ldv_undef_ptr();
#line 1371
  return ((int )((long )tmp));
}
}
#line 1374 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1377
  ldv_check_alloc_flags(flags);
#line 1378
  tmp = ldv_undef_ptr();
#line 1378
  return ((int )((long )tmp));
}
}
#line 1381 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
struct sk_buff *ldv_skb_clone_87(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 1384
  ldv_check_alloc_flags(flags);
#line 1385
  tmp = ldv_undef_ptr();
#line 1385
  return ((struct sk_buff *)tmp);
}
}
#line 1388 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
__inline static int ldv_request_irq_88(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1392
  tmp = request_irq(irq, handler, flags, name, dev);
#line 1392
  ldv_func_res = tmp;
#line 1394
  tmp___0 = reg_check_2(handler);
#line 1394
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 1395
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
#line 1398
  return (ldv_func_res);
}
}
#line 1401 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
__inline static int ldv_request_irq_89(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1405
  tmp = request_irq(irq, handler, flags, name, dev);
#line 1405
  ldv_func_res = tmp;
#line 1407
  tmp___0 = reg_check_2(handler);
#line 1407
  if (tmp___0 != 0 && ldv_func_res == 0) {
#line 1408
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
#line 1411
  return (ldv_func_res);
}
}
#line 1414 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void ldv_free_irq_90(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
#line 1417
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 1419
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
#line 1420
  return;
}
}
#line 1422 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
int ldv___pci_register_driver_91(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 1426
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1426
  ldv_func_res = tmp;
#line 1428
  ldv_state_variable_11 = 1;
#line 1429
  ldv_pci_driver_11();
#line 1432
  return (ldv_func_res);
}
}
#line 1435 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-core.o.c.prepared"
void ldv_pci_unregister_driver_92(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
#line 1438
  pci_unregister_driver(ldv_func_arg1);
#line 1440
  ldv_state_variable_11 = 0;
#line 1441
  return;
}
}
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_118(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_120(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_127(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 528 "include/linux/i2c.h"
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 


  {
#line 530
  dev_set_drvdata(& dev->dev, data);
#line 531
  return;
}
}
#line 579
extern int i2c_add_adapter(struct i2c_adapter * ) ;
#line 580
extern void i2c_del_adapter(struct i2c_adapter * ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_135(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_143(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_137(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_133(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_141(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_142(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_138(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_139(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_140(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 532 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
int saa7164_api_i2c_read(struct saa7164_i2c *bus , u8 addr , u32 reglen , u8 *reg ,
                         u32 datalen , u8 *data ) ;
#line 534
int saa7164_api_i2c_write(struct saa7164_i2c *bus , u8 addr , u32 datalen , u8 *data ) ;
#line 30 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.c"
static int i2c_xfer(struct i2c_adapter *i2c_adap , struct i2c_msg *msgs , int num ) 
{ 
  struct saa7164_i2c *bus ;
  struct saa7164_dev *dev ;
  int i ;
  int retval ;

  {
#line 32
  bus = (struct saa7164_i2c *)i2c_adap->algo_data;
#line 33
  dev = bus->dev;
#line 34
  retval = 0;
#line 36
  if ((saa_debug & 16U) != 0U) {
#line 36
    printk("\017%s: %s(num = %d)\n", (char *)(& dev->name), "i2c_xfer", num);
  } else {

  }
#line 38
  i = 0;
#line 38
  goto ldv_51801;
  ldv_51800: ;
#line 39
  if ((saa_debug & 16U) != 0U) {
#line 39
    printk("\017%s: %s(num = %d) addr = 0x%02x  len = 0x%x\n", (char *)(& dev->name),
           "i2c_xfer", num, (int )(msgs + (unsigned long )i)->addr, (int )(msgs + (unsigned long )i)->len);
  } else {

  }
#line 41
  if ((int )(msgs + (unsigned long )i)->flags & 1) {
#line 42
    retval = saa7164_api_i2c_read(bus, (int )((u8 )(msgs + (unsigned long )i)->addr),
                                  0U, (u8 *)0U, (u32 )(msgs + (unsigned long )i)->len,
                                  (msgs + (unsigned long )i)->buf);
  } else
#line 46
  if ((i + 1 < num && (int )(msgs + ((unsigned long )i + 1UL))->flags & 1) && (int )(msgs + (unsigned long )i)->addr == (int )(msgs + ((unsigned long )i + 1UL))->addr) {
#line 50
    retval = saa7164_api_i2c_read(bus, (int )((u8 )(msgs + (unsigned long )i)->addr),
                                  (u32 )(msgs + (unsigned long )i)->len, (msgs + (unsigned long )i)->buf,
                                  (u32 )(msgs + ((unsigned long )i + 1UL))->len, (msgs + ((unsigned long )i + 1UL))->buf);
#line 55
    i = i + 1;
#line 57
    if (retval < 0) {
#line 58
      goto err;
    } else {

    }
  } else {
#line 61
    retval = saa7164_api_i2c_write(bus, (int )((u8 )(msgs + (unsigned long )i)->addr),
                                   (u32 )(msgs + (unsigned long )i)->len, (msgs + (unsigned long )i)->buf);
  }
#line 64
  if (retval < 0) {
#line 65
    goto err;
  } else {

  }
#line 38
  i = i + 1;
  ldv_51801: ;
#line 38
  if (i < num) {
#line 40
    goto ldv_51800;
  } else {

  }

#line 67
  return (num);
  err: ;
#line 70
  return (retval);
}
}
#line 73 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.c"
static u32 saa7164_functionality(struct i2c_adapter *adap ) 
{ 


  {
#line 75
  return (1U);
}
}
#line 78 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.c"
static struct i2c_algorithm saa7164_i2c_algo_template  =    {& i2c_xfer, 0, & saa7164_functionality, 0, 0};
#line 85 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.c"
static struct i2c_adapter saa7164_i2c_adap_template  = 
#line 85
     {& __this_module, 0U, (struct i2c_algorithm  const  *)(& saa7164_i2c_algo_template),
    0, {{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}, {0}, 0, 0, 0, 0, 0, 0, 0}, 0,
    0, {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0,
                                                                 0UL}}, {{0, 0}, 0UL,
                                                                         0, 0UL, 0U,
                                                                         0, 0, 0,
                                                                         {(char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0},
                                                                         {0, {0, 0},
                                                                          0, 0, 0UL}},
                                              0, 0}, (unsigned char)0, (unsigned char)0,
               (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0, 0, {{0},
                                                                             {{{{{0}},
                                                                                0U,
                                                                                0U,
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                             {0, 0},
                                                                             0, 0,
                                                                             {0, {0,
                                                                                  0},
                                                                              0, 0,
                                                                              0UL}},
        0, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0,
                     (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0}}, 0U,
                                                                          0U, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                     {0, 0}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}},
                                   {0, 0}}}, 0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL,
                                                                     0, 0UL, 0U, 0,
                                                                     0, 0, {(char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0},
                                                                     {0, {0, 0}, 0,
                                                                      0, 0UL}}, 0UL,
                     {{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}}, {{{{{{0}}, 0U, 0U,
                                                                    0, {0, {0, 0},
                                                                        0, 0, 0UL}}}},
                                                                 {0, 0}}, 0, {0},
                     {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, 0, 0, 0,
                     0, 0UL, 0UL, 0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0,
                                                                                 0},
        0, 0, {0, 0}, 0, 0, 0U, 0U, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}},
        {0, 0}, {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0}, 0, {'s', 'a',
                                                                         'a', '7',
                                                                         '1', '6',
                                                                         '4', '\000'},
    {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}}, {{0}, {{{{{0}},
                                                                             0U, 0U,
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                     {0, 0}, 0, 0,
                                                                     {0, {0, 0}, 0,
                                                                      0, 0UL}}, {0,
                                                                                 0},
    0, 0};
#line 91 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.c"
static struct i2c_client saa7164_i2c_client_template  = 
#line 91
     {(unsigned short)0, (unsigned short)0, {'s', 'a', 'a', '7', '1', '6', '4', ' ',
                                           'i', 'n', 't', 'e', 'r', 'n', 'a', 'l',
                                           '\000'}, 0, {0, 0, {0, {0, 0}, 0, 0, 0,
                                                               0, {{0}}, {{{0L}, {0,
                                                                                  0},
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}},
                                                                          {{0, 0},
                                                                           0UL, 0,
                                                                           0UL, 0U,
                                                                           0, 0, 0,
                                                                           {(char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0},
                                                                           {0, {0,
                                                                                0},
                                                                            0, 0,
                                                                            0UL}},
                                                                          0, 0}, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0},
                                                        0, 0, {{0}, {{{{{0}}, 0U,
                                                                       0U, 0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                               {0, 0}, 0, 0, {0, {0,
                                                                                  0},
                                                                              0, 0,
                                                                              0UL}},
                                                        0, 0, 0, 0, {{0}, (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (_Bool)0, (_Bool)0,
                                                                     (_Bool)0, (_Bool)0,
                                                                     (_Bool)0, (_Bool)0,
                                                                     (_Bool)0, {{{{{0}},
                                                                                  0U,
                                                                                  0U,
                                                                                  0,
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}}}},
                                                                     {0, 0}, {0U,
                                                                              {{{{{{0}},
                                                                                  0U,
                                                                                  0U,
                                                                                  0,
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}}}},
                                                                               {0,
                                                                                0}}},
                                                                     0, (_Bool)0,
                                                                     (_Bool)0, {{0,
                                                                                 0},
                                                                                0UL,
                                                                                0,
                                                                                0UL,
                                                                                0U,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                     0UL, {{0L}, {0,
                                                                                  0},
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}},
                                                                     {{{{{{0}}, 0U,
                                                                         0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                      {0, 0}}, 0,
                                                                     {0}, {0}, (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     0, 0, 0, 0, 0UL,
                                                                     0UL, 0UL, 0UL,
                                                                     0, 0, 0}, 0,
                                                        0, 0, 0, 0ULL, 0UL, 0, {0,
                                                                                0},
                                                        0, 0, {0, 0}, 0, 0, 0U, 0U,
                                                        {{{{{0}}, 0U, 0U, 0, {0, {0,
                                                                                  0},
                                                                              0, 0,
                                                                              0UL}}}},
                                                        {0, 0}, {0, {0, 0}, {{0}}},
                                                        0, 0, 0, 0, (_Bool)0, (_Bool)0},
    0, {0, 0}, 0};
#line 95 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.c"
int saa7164_i2c_register(struct saa7164_i2c *bus ) 
{ 
  struct saa7164_dev *dev ;

  {
#line 97
  dev = bus->dev;
#line 99
  if ((saa_debug & 16U) != 0U) {
#line 99
    printk("\017%s: %s(bus = %d)\n", (char *)(& dev->name), "saa7164_i2c_register",
           (unsigned int )bus->nr);
  } else {

  }
#line 101
  bus->i2c_adap = saa7164_i2c_adap_template;
#line 102
  bus->i2c_client = saa7164_i2c_client_template;
#line 104
  bus->i2c_adap.dev.parent = & (dev->pci)->dev;
#line 106
  strlcpy((char *)(& bus->i2c_adap.name), (char const   *)(& (bus->dev)->name), 48UL);
#line 109
  bus->i2c_adap.algo_data = (void *)bus;
#line 110
  i2c_set_adapdata(& bus->i2c_adap, (void *)bus);
#line 111
  i2c_add_adapter(& bus->i2c_adap);
#line 113
  bus->i2c_client.adapter = & bus->i2c_adap;
#line 115
  if (bus->i2c_rc != 0U) {
#line 116
    printk("\v%s: i2c bus %d register FAILED\n", (char *)(& dev->name), (unsigned int )bus->nr);
  } else {

  }
#line 119
  return ((int )bus->i2c_rc);
}
}
#line 122 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.c"
int saa7164_i2c_unregister(struct saa7164_i2c *bus ) 
{ 


  {
#line 124
  i2c_del_adapter(& bus->i2c_adap);
#line 125
  return (0);
}
}
#line 144 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
void ldv_initialize_i2c_algorithm_10(void) 
{ 
  void *tmp ;

  {
#line 145
  tmp = ldv_init_zalloc(1936UL);
#line 145
  saa7164_i2c_algo_template_group0 = (struct i2c_adapter *)tmp;
#line 146
  return;
}
}
#line 148 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  struct i2c_msg *ldvarg86 ;
  void *tmp ;
  int ldvarg85 ;
  int tmp___0 ;

  {
#line 149
  tmp = ldv_init_zalloc(16UL);
#line 149
  ldvarg86 = (struct i2c_msg *)tmp;
#line 150
  ldv_memset((void *)(& ldvarg85), 0, 4UL);
#line 152
  tmp___0 = __VERIFIER_nondet_int();
#line 152
  switch (tmp___0) {
  case 0: ;
#line 155
  if (ldv_state_variable_10 == 1) {
#line 157
    i2c_xfer(saa7164_i2c_algo_template_group0, ldvarg86, ldvarg85);
#line 159
    ldv_state_variable_10 = 1;
  } else {

  }
#line 162
  goto ldv_51826;
  case 1: ;
#line 165
  if (ldv_state_variable_10 == 1) {
#line 167
    saa7164_functionality(saa7164_i2c_algo_template_group0);
#line 169
    ldv_state_variable_10 = 1;
  } else {

  }
#line 172
  goto ldv_51826;
  default: 
#line 173
  ldv_stop();
  }
  ldv_51826: ;
#line 177
  return;
}
}
#line 291 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 295
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 295
  ldv_func_res = tmp;
#line 297
  activate_work_3(ldv_func_arg3, 2);
#line 299
  return (ldv_func_res);
}
}
#line 302 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_118(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 306
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 306
  ldv_func_res = tmp;
#line 308
  activate_work_3(& ldv_func_arg3->work, 2);
#line 310
  return (ldv_func_res);
}
}
#line 313 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
bool ldv_queue_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 317
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 317
  ldv_func_res = tmp;
#line 319
  activate_work_3(ldv_func_arg3, 2);
#line 321
  return (ldv_func_res);
}
}
#line 324 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
void ldv_flush_workqueue_120(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 327
  flush_workqueue(ldv_func_arg1);
#line 329
  call_and_disable_all_3(2);
#line 330
  return;
}
}
#line 332 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
bool ldv_queue_delayed_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 336
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 336
  ldv_func_res = tmp;
#line 338
  activate_work_3(& ldv_func_arg3->work, 2);
#line 340
  return (ldv_func_res);
}
}
#line 378 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
void *ldv_kmem_cache_alloc_127(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 381
  ldv_check_alloc_flags(flags);
#line 382
  tmp = ldv_undef_ptr();
#line 382
  return (tmp);
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
int ldv_pskb_expand_head_133(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 423
  ldv_check_alloc_flags(flags);
#line 424
  tmp = ldv_undef_ptr();
#line 424
  return ((int )((long )tmp));
}
}
#line 434 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
struct sk_buff *ldv_skb_clone_135(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 438
  tmp = ldv_undef_ptr();
#line 438
  return ((struct sk_buff *)tmp);
}
}
#line 448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
struct sk_buff *ldv_skb_copy_137(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 451
  ldv_check_alloc_flags(flags);
#line 452
  tmp = ldv_undef_ptr();
#line 452
  return ((struct sk_buff *)tmp);
}
}
#line 455 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_138(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 459
  tmp = ldv_undef_ptr();
#line 459
  return ((struct sk_buff *)tmp);
}
}
#line 462 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_139(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 465
  ldv_check_alloc_flags(flags);
#line 466
  tmp = ldv_undef_ptr();
#line 466
  return ((struct sk_buff *)tmp);
}
}
#line 469 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_140(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 472
  ldv_check_alloc_flags(flags);
#line 473
  tmp = ldv_undef_ptr();
#line 473
  return ((struct sk_buff *)tmp);
}
}
#line 476 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
int ldv_pskb_expand_head_141(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 479
  ldv_check_alloc_flags(flags);
#line 480
  tmp = ldv_undef_ptr();
#line 480
  return ((int )((long )tmp));
}
}
#line 483 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
int ldv_pskb_expand_head_142(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 486
  ldv_check_alloc_flags(flags);
#line 487
  tmp = ldv_undef_ptr();
#line 487
  return ((int )((long )tmp));
}
}
#line 490 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-i2c.o.c.prepared"
struct sk_buff *ldv_skb_clone_143(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 493
  ldv_check_alloc_flags(flags);
#line 494
  tmp = ldv_undef_ptr();
#line 494
  return ((struct sk_buff *)tmp);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_164(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_166(struct workqueue_struct *ldv_func_arg1 ) ;
#line 36 "include/linux/kmod.h"
extern int __request_module(bool  , char const   *  , ...) ;
#line 196 "include/linux/module.h"
extern void *__symbol_get(char const   * ) ;
#line 492
extern void __symbol_put(char const   * ) ;
#line 502
extern bool try_module_get(struct module * ) ;
#line 504
extern void module_put(struct module * ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_173(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 326 "include/linux/i2c.h"
extern struct i2c_client *i2c_new_device(struct i2c_adapter * , struct i2c_board_info  const  * ) ;
#line 349
extern void i2c_unregister_device(struct i2c_client * ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_181(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_189(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_183(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_179(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_187(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_188(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_184(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_185(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_186(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 113 "./drivers/media/dvb-core/dvbdev.h"
extern int dvb_register_adapter(struct dvb_adapter * , char const   * , struct module * ,
                                struct device * , short * ) ;
#line 116
extern int dvb_unregister_adapter(struct dvb_adapter * ) ;
#line 116 "./drivers/media/dvb-core/dmxdev.h"
extern int dvb_dmxdev_init(struct dmxdev * , struct dvb_adapter * ) ;
#line 117
extern void dvb_dmxdev_release(struct dmxdev * ) ;
#line 141 "./drivers/media/dvb-core/dvb_demux.h"
extern int dvb_dmx_init(struct dvb_demux * ) ;
#line 142
extern void dvb_dmx_release(struct dvb_demux * ) ;
#line 46 "./drivers/media/dvb-core/dvb_net.h"
extern void dvb_net_release(struct dvb_net * ) ;
#line 47
extern int dvb_net_init(struct dvb_adapter * , struct dvb_net * , struct dmx_demux * ) ;
#line 433 "./drivers/media/dvb-core/dvb_frontend.h"
extern int dvb_register_frontend(struct dvb_adapter * , struct dvb_frontend * ) ;
#line 436
extern int dvb_unregister_frontend(struct dvb_frontend * ) ;
#line 438
extern void dvb_frontend_detach(struct dvb_frontend * ) ;
#line 541 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
int saa7164_api_transition_port(struct saa7164_port *port , u8 mode ) ;
#line 584
struct saa7164_buffer *saa7164_buffer_alloc(struct saa7164_port *port , u32 len ) ;
#line 586
int saa7164_buffer_dealloc(struct saa7164_buffer *buf ) ;
#line 589
int saa7164_buffer_cfg_port(struct saa7164_port *port ) ;
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static short adapter_nr[8U]  = 
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 36 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct tda10048_config hauppauge_hvr2200_1_config  = 
#line 36
     {8U, 1U, 200U, 1U, 3300U, 3500U, 4000U, 16000U, (unsigned char)0, (_Bool)0, (_Bool)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 46 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct tda10048_config hauppauge_hvr2200_2_config  = 
#line 46
     {9U, 1U, 200U, 1U, 3300U, 3500U, 4000U, 16000U, (unsigned char)0, (_Bool)0, (_Bool)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 57 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct tda18271_std_map hauppauge_tda18271_std_map  = 
#line 57
     {{(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {3250U, 3U, 3U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {4000U, 3U, 0U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}};
#line 64 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct tda18271_config hauppauge_hvr22x0_tuner_config  = 
#line 64
     {& hauppauge_tda18271_std_map, 0, 1, 0, 0, (unsigned char)0, (unsigned char)0,
    0U};
#line 70 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct tda18271_config hauppauge_hvr22x0s_tuner_config  = 
#line 70
     {& hauppauge_tda18271_std_map, 1, 1, 1, 0, 1U, (unsigned char)0, 0U};
#line 78 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct s5h1411_config hauppauge_s5h1411_config  =    {1U, 1U, 1U, 4000U, 3250U, 1U, 1U};
#line 88 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct lgdt3306a_config hauppauge_hvr2255a_config  = 
#line 88
     {89U, 4000U, 3250U, 1U, 0U, 1, 0, 1, 25};
#line 100 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct lgdt3306a_config hauppauge_hvr2255b_config  = 
#line 100
     {14U, 4000U, 3250U, 1U, 0U, 1, 0, 1, 25};
#line 112 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static struct si2157_config hauppauge_hvr2255_tuner_config  =    {0, 1, 1U};
#line 117 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int si2157_attach(struct saa7164_port *port , struct i2c_adapter *adapter ,
                         struct dvb_frontend *fe , u8 addr8bit , struct si2157_config *cfg ) 
{ 
  struct i2c_board_info bi ;
  struct i2c_client *tuner ;
  bool tmp ;
  int tmp___0 ;

  {
#line 123
  cfg->fe = fe;
#line 125
  memset((void *)(& bi), 0, 64UL);
#line 127
  strlcpy((char *)(& bi.type), "si2157", 20UL);
#line 128
  bi.platform_data = (void *)cfg;
#line 129
  bi.addr = (unsigned short )((int )addr8bit >> 1);
#line 131
  __request_module(1, (char const   *)(& bi.type));
#line 133
  tuner = i2c_new_device(adapter, (struct i2c_board_info  const  *)(& bi));
#line 134
  if ((unsigned long )tuner == (unsigned long )((struct i2c_client *)0) || (unsigned long )tuner->dev.driver == (unsigned long )((struct device_driver *)0)) {
#line 135
    return (-19);
  } else {

  }
#line 137
  tmp = try_module_get((tuner->dev.driver)->owner);
#line 137
  if (tmp) {
#line 137
    tmp___0 = 0;
  } else {
#line 137
    tmp___0 = 1;
  }
#line 137
  if (tmp___0) {
#line 138
    i2c_unregister_device(tuner);
#line 139
    return (-19);
  } else {

  }
#line 142
  port->i2c_client_tuner = tuner;
#line 144
  return (0);
}
}
#line 147 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int saa7164_dvb_stop_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 149
  dev = port->dev;
#line 152
  ret = saa7164_api_transition_port(port, 0);
#line 153
  if (ret != 0 && ret != 38) {
#line 154
    printk("\v%s() stop transition failed, ret = 0x%x\n", "saa7164_dvb_stop_port",
           ret);
#line 156
    ret = -5;
  } else {
#line 158
    if ((saa_debug & 8U) != 0U) {
#line 158
      printk("\017%s: %s()    Stopped\n", (char *)(& dev->name), "saa7164_dvb_stop_port");
    } else {

    }
#line 159
    ret = 0;
  }
#line 162
  return (ret);
}
}
#line 165 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int saa7164_dvb_acquire_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 167
  dev = port->dev;
#line 170
  ret = saa7164_api_transition_port(port, 1);
#line 171
  if (ret != 0 && ret != 38) {
#line 172
    printk("\v%s() acquire transition failed, ret = 0x%x\n", "saa7164_dvb_acquire_port",
           ret);
#line 174
    ret = -5;
  } else {
#line 176
    if ((saa_debug & 8U) != 0U) {
#line 176
      printk("\017%s: %s() Acquired\n", (char *)(& dev->name), "saa7164_dvb_acquire_port");
    } else {

    }
#line 177
    ret = 0;
  }
#line 180
  return (ret);
}
}
#line 183 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int saa7164_dvb_pause_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 185
  dev = port->dev;
#line 188
  ret = saa7164_api_transition_port(port, 2);
#line 189
  if (ret != 0 && ret != 38) {
#line 190
    printk("\v%s() pause transition failed, ret = 0x%x\n", "saa7164_dvb_pause_port",
           ret);
#line 192
    ret = -5;
  } else {
#line 194
    if ((saa_debug & 8U) != 0U) {
#line 194
      printk("\017%s: %s()   Paused\n", (char *)(& dev->name), "saa7164_dvb_pause_port");
    } else {

    }
#line 195
    ret = 0;
  }
#line 198
  return (ret);
}
}
#line 205 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int saa7164_dvb_stop_streaming(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct list_head *p ;
  struct list_head *q ;
  int ret ;
  struct list_head  const  *__mptr ;

  {
#line 207
  dev = port->dev;
#line 212
  if ((saa_debug & 8U) != 0U) {
#line 212
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_dvb_stop_streaming",
           port->nr);
  } else {

  }
#line 214
  ret = saa7164_dvb_pause_port(port);
#line 215
  ret = saa7164_dvb_acquire_port(port);
#line 216
  ret = saa7164_dvb_stop_port(port);
#line 219
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 220
  p = port->dmaqueue.list.next;
#line 220
  q = p->next;
#line 220
  goto ldv_52006;
  ldv_52005: 
#line 221
  __mptr = (struct list_head  const  *)p;
#line 221
  buf = (struct saa7164_buffer *)__mptr;
#line 222
  buf->flags = 1;
#line 220
  p = q;
#line 220
  q = p->next;
  ldv_52006: ;
#line 220
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )p) {
#line 222
    goto ldv_52005;
  } else {

  }
#line 224
  mutex_unlock(& port->dmaqueue_lock);
#line 226
  return (ret);
}
}
#line 229 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int saa7164_dvb_start_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;
  int result ;

  {
#line 231
  dev = port->dev;
#line 232
  ret = 0;
#line 234
  if ((saa_debug & 8U) != 0U) {
#line 234
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_dvb_start_port",
           port->nr);
  } else {

  }
#line 236
  saa7164_buffer_cfg_port(port);
#line 239
  result = saa7164_api_transition_port(port, 1);
#line 240
  if (result != 0 && result != 38) {
#line 241
    printk("\v%s() acquire transition failed, res = 0x%x\n", "saa7164_dvb_start_port",
           result);
#line 245
    result = saa7164_api_transition_port(port, 0);
#line 246
    if (result != 0 && result != 38) {
#line 247
      printk("\v%s() acquire/forced stop transition failed, res = 0x%x\n", "saa7164_dvb_start_port",
             result);
    } else {

    }
#line 250
    ret = -5;
#line 251
    goto out;
  } else
#line 253
  if ((saa_debug & 8U) != 0U) {
#line 253
    printk("\017%s: %s()   Acquired\n", (char *)(& dev->name), "saa7164_dvb_start_port");
  } else {

  }
#line 256
  result = saa7164_api_transition_port(port, 2);
#line 257
  if (result != 0 && result != 38) {
#line 258
    printk("\v%s() pause transition failed, res = 0x%x\n", "saa7164_dvb_start_port",
           result);
#line 262
    result = saa7164_api_transition_port(port, 0);
#line 263
    if (result != 0 && result != 38) {
#line 264
      printk("\v%s() pause/forced stop transition failed, res = 0x%x\n", "saa7164_dvb_start_port",
             result);
    } else {

    }
#line 268
    ret = -5;
#line 269
    goto out;
  } else
#line 271
  if ((saa_debug & 8U) != 0U) {
#line 271
    printk("\017%s: %s()   Paused\n", (char *)(& dev->name), "saa7164_dvb_start_port");
  } else {

  }
#line 274
  result = saa7164_api_transition_port(port, 3);
#line 275
  if (result != 0 && result != 38) {
#line 276
    printk("\v%s() run transition failed, result = 0x%x\n", "saa7164_dvb_start_port",
           result);
#line 280
    result = saa7164_api_transition_port(port, 0);
#line 281
    if (result != 0 && result != 38) {
#line 282
      printk("\v%s() run/forced stop transition failed, res = 0x%x\n", "saa7164_dvb_start_port",
             result);
    } else {

    }
#line 286
    ret = -5;
  } else
#line 288
  if ((saa_debug & 8U) != 0U) {
#line 288
    printk("\017%s: %s()   Running\n", (char *)(& dev->name), "saa7164_dvb_start_port");
  } else {

  }
  out: ;
#line 291
  return (ret);
}
}
#line 294 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int saa7164_dvb_start_feed(struct dvb_demux_feed *feed ) 
{ 
  struct dvb_demux *demux ;
  struct saa7164_port *port ;
  struct saa7164_dvb *dvb ;
  struct saa7164_dev *dev ;
  int ret ;
  int tmp ;

  {
#line 296
  demux = feed->demux;
#line 297
  port = (struct saa7164_port *)demux->priv;
#line 298
  dvb = & port->dvb;
#line 299
  dev = port->dev;
#line 300
  ret = 0;
#line 302
  if ((saa_debug & 8U) != 0U) {
#line 302
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_dvb_start_feed",
           port->nr);
  } else {

  }
#line 304
  if ((unsigned long )demux->dmx.frontend == (unsigned long )((struct dmx_frontend *)0)) {
#line 305
    return (-22);
  } else {

  }
#line 307
  if ((unsigned long )dvb != (unsigned long )((struct saa7164_dvb *)0)) {
#line 308
    mutex_lock_nested(& dvb->lock, 0U);
#line 309
    tmp = dvb->feeding;
#line 309
    dvb->feeding = dvb->feeding + 1;
#line 309
    if (tmp == 0) {
#line 311
      ret = saa7164_dvb_start_port(port);
    } else {

    }
#line 313
    mutex_unlock(& dvb->lock);
#line 314
    if ((saa_debug & 8U) != 0U) {
#line 314
      printk("\017%s: %s(port=%d) now feeding = %d\n", (char *)(& dev->name), "saa7164_dvb_start_feed",
             port->nr, dvb->feeding);
    } else {

    }
  } else {

  }
#line 318
  return (ret);
}
}
#line 321 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int saa7164_dvb_stop_feed(struct dvb_demux_feed *feed ) 
{ 
  struct dvb_demux *demux ;
  struct saa7164_port *port ;
  struct saa7164_dvb *dvb ;
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 323
  demux = feed->demux;
#line 324
  port = (struct saa7164_port *)demux->priv;
#line 325
  dvb = & port->dvb;
#line 326
  dev = port->dev;
#line 327
  ret = 0;
#line 329
  if ((saa_debug & 8U) != 0U) {
#line 329
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_dvb_stop_feed",
           port->nr);
  } else {

  }
#line 331
  if ((unsigned long )dvb != (unsigned long )((struct saa7164_dvb *)0)) {
#line 332
    mutex_lock_nested(& dvb->lock, 0U);
#line 333
    dvb->feeding = dvb->feeding - 1;
#line 333
    if (dvb->feeding == 0) {
#line 335
      ret = saa7164_dvb_stop_streaming(port);
    } else {

    }
#line 337
    mutex_unlock(& dvb->lock);
#line 338
    if ((saa_debug & 8U) != 0U) {
#line 338
      printk("\017%s: %s(port=%d) now feeding = %d\n", (char *)(& dev->name), "saa7164_dvb_stop_feed",
             port->nr, dvb->feeding);
    } else {

    }
  } else {

  }
#line 342
  return (ret);
}
}
#line 345 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
static int dvb_register(struct saa7164_port *port ) 
{ 
  struct saa7164_dvb *dvb ;
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  int result ;
  int i ;

  {
#line 347
  dvb = & port->dvb;
#line 348
  dev = port->dev;
#line 352
  if ((saa_debug & 8U) != 0U) {
#line 352
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "dvb_register", port->nr);
  } else {

  }
#line 354
  if ((unsigned int )port->type != 1U) {
#line 355
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"),
                         "i" (355), "i" (12UL));
    ldv_52043: ;
#line 355
    goto ldv_52043;
  } else {

  }
#line 358
  if (port->hwcfg.BARLocation == 0U) {
#line 359
    result = -12;
#line 360
    printk("\v%s: dvb_register_adapter failed (errno = %d), NO PCI configuration\n",
           (char *)"saa7164", result);
#line 363
    goto fail_adapter;
  } else {

  }
#line 367
  port->hw_streamingparams.bitspersample = 8U;
#line 368
  port->hw_streamingparams.samplesperline = 188U;
#line 369
  port->hw_streamingparams.numberoflines = 312U;
#line 372
  port->hw_streamingparams.pitch = 188U;
#line 373
  port->hw_streamingparams.linethreshold = 0U;
#line 374
  port->hw_streamingparams.pagetablelistvirt = (u64 **)0ULL;
#line 375
  port->hw_streamingparams.pagetablelistphys = (u64 *)0ULL;
#line 376
  port->hw_streamingparams.numpagetables = 16U;
#line 379
  port->hw_streamingparams.numpagetableentries = (u32 )port->hwcfg.buffercount;
#line 382
  i = 0;
#line 382
  goto ldv_52046;
  ldv_52045: 
#line 383
  buf = saa7164_buffer_alloc(port, port->hw_streamingparams.numberoflines * port->hw_streamingparams.pitch);
#line 387
  if ((unsigned long )buf == (unsigned long )((struct saa7164_buffer *)0)) {
#line 388
    result = -12;
#line 389
    printk("\v%s: dvb_register_adapter failed (errno = %d), unable to allocate buffers\n",
           (char *)"saa7164", result);
#line 392
    goto fail_adapter;
  } else {

  }
#line 395
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 396
  list_add_tail(& buf->list, & port->dmaqueue.list);
#line 397
  mutex_unlock(& port->dmaqueue_lock);
#line 382
  i = i + 1;
  ldv_52046: ;
#line 382
  if ((int )port->hwcfg.buffercount > i) {
#line 384
    goto ldv_52045;
  } else {

  }
#line 401
  result = dvb_register_adapter(& dvb->adapter, "saa7164", & __this_module, & (dev->pci)->dev,
                                (short *)(& adapter_nr));
#line 403
  if (result < 0) {
#line 404
    printk("\v%s: dvb_register_adapter failed (errno = %d)\n", (char *)"saa7164",
           result);
#line 406
    goto fail_adapter;
  } else {

  }
#line 408
  dvb->adapter.priv = (void *)port;
#line 411
  result = dvb_register_frontend(& dvb->adapter, dvb->frontend);
#line 412
  if (result < 0) {
#line 413
    printk("\v%s: dvb_register_frontend failed (errno = %d)\n", (char *)"saa7164",
           result);
#line 415
    goto fail_frontend;
  } else {

  }
#line 419
  dvb->demux.dmx.capabilities = 13U;
#line 422
  dvb->demux.priv = (void *)port;
#line 423
  dvb->demux.filternum = 256;
#line 424
  dvb->demux.feednum = 256;
#line 425
  dvb->demux.start_feed = & saa7164_dvb_start_feed;
#line 426
  dvb->demux.stop_feed = & saa7164_dvb_stop_feed;
#line 427
  result = dvb_dmx_init(& dvb->demux);
#line 428
  if (result < 0) {
#line 429
    printk("\v%s: dvb_dmx_init failed (errno = %d)\n", (char *)"saa7164", result);
#line 431
    goto fail_dmx;
  } else {

  }
#line 434
  dvb->dmxdev.filternum = 256;
#line 435
  dvb->dmxdev.demux = & dvb->demux.dmx;
#line 436
  dvb->dmxdev.capabilities = 0;
#line 437
  result = dvb_dmxdev_init(& dvb->dmxdev, & dvb->adapter);
#line 438
  if (result < 0) {
#line 439
    printk("\v%s: dvb_dmxdev_init failed (errno = %d)\n", (char *)"saa7164", result);
#line 441
    goto fail_dmxdev;
  } else {

  }
#line 444
  dvb->fe_hw.source = 1;
#line 445
  result = (*(dvb->demux.dmx.add_frontend))(& dvb->demux.dmx, & dvb->fe_hw);
#line 446
  if (result < 0) {
#line 447
    printk("\v%s: add_frontend failed (DMX_FRONTEND_0, errno = %d)\n", (char *)"saa7164",
           result);
#line 449
    goto fail_fe_hw;
  } else {

  }
#line 452
  dvb->fe_mem.source = 0;
#line 453
  result = (*(dvb->demux.dmx.add_frontend))(& dvb->demux.dmx, & dvb->fe_mem);
#line 454
  if (result < 0) {
#line 455
    printk("\v%s: add_frontend failed (DMX_MEMORY_FE, errno = %d)\n", (char *)"saa7164",
           result);
#line 457
    goto fail_fe_mem;
  } else {

  }
#line 460
  result = (*(dvb->demux.dmx.connect_frontend))(& dvb->demux.dmx, & dvb->fe_hw);
#line 461
  if (result < 0) {
#line 462
    printk("\v%s: connect_frontend failed (errno = %d)\n", (char *)"saa7164", result);
#line 464
    goto fail_fe_conn;
  } else {

  }
#line 468
  dvb_net_init(& dvb->adapter, & dvb->net, & dvb->demux.dmx);
#line 469
  return (0);
  fail_fe_conn: 
#line 472
  (*(dvb->demux.dmx.remove_frontend))(& dvb->demux.dmx, & dvb->fe_mem);
  fail_fe_mem: 
#line 474
  (*(dvb->demux.dmx.remove_frontend))(& dvb->demux.dmx, & dvb->fe_hw);
  fail_fe_hw: 
#line 476
  dvb_dmxdev_release(& dvb->dmxdev);
  fail_dmxdev: 
#line 478
  dvb_dmx_release(& dvb->demux);
  fail_dmx: 
#line 480
  dvb_unregister_frontend(dvb->frontend);
  fail_frontend: 
#line 482
  dvb_frontend_detach(dvb->frontend);
#line 483
  dvb_unregister_adapter(& dvb->adapter);
  fail_adapter: ;
#line 485
  return (result);
}
}
#line 488 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
int saa7164_dvb_unregister(struct saa7164_port *port ) 
{ 
  struct saa7164_dvb *dvb ;
  struct saa7164_dev *dev ;
  struct saa7164_buffer *b ;
  struct list_head *c ;
  struct list_head *n ;
  struct i2c_client *client ;
  struct list_head  const  *__mptr ;

  {
#line 490
  dvb = & port->dvb;
#line 491
  dev = port->dev;
#line 496
  if ((saa_debug & 8U) != 0U) {
#line 496
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_dvb_unregister");
  } else {

  }
#line 498
  if ((unsigned int )port->type != 1U) {
#line 499
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"),
                         "i" (499), "i" (12UL));
    ldv_52064: ;
#line 499
    goto ldv_52064;
  } else {

  }
#line 502
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 503
  c = port->dmaqueue.list.next;
#line 503
  n = c->next;
#line 503
  goto ldv_52068;
  ldv_52067: 
#line 504
  __mptr = (struct list_head  const  *)c;
#line 504
  b = (struct saa7164_buffer *)__mptr;
#line 505
  list_del(c);
#line 506
  saa7164_buffer_dealloc(b);
#line 503
  c = n;
#line 503
  n = c->next;
  ldv_52068: ;
#line 503
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )c) {
#line 505
    goto ldv_52067;
  } else {

  }
#line 508
  mutex_unlock(& port->dmaqueue_lock);
#line 510
  if ((unsigned long )dvb->frontend == (unsigned long )((struct dvb_frontend *)0)) {
#line 511
    return (0);
  } else {

  }
#line 514
  client = port->i2c_client_tuner;
#line 515
  if ((unsigned long )client != (unsigned long )((struct i2c_client *)0)) {
#line 516
    module_put((client->dev.driver)->owner);
#line 517
    i2c_unregister_device(client);
  } else {

  }
#line 521
  client = port->i2c_client_demod;
#line 522
  if ((unsigned long )client != (unsigned long )((struct i2c_client *)0)) {
#line 523
    module_put((client->dev.driver)->owner);
#line 524
    i2c_unregister_device(client);
  } else {

  }
#line 527
  dvb_net_release(& dvb->net);
#line 528
  (*(dvb->demux.dmx.remove_frontend))(& dvb->demux.dmx, & dvb->fe_mem);
#line 529
  (*(dvb->demux.dmx.remove_frontend))(& dvb->demux.dmx, & dvb->fe_hw);
#line 530
  dvb_dmxdev_release(& dvb->dmxdev);
#line 531
  dvb_dmx_release(& dvb->demux);
#line 532
  dvb_unregister_frontend(dvb->frontend);
#line 533
  dvb_frontend_detach(dvb->frontend);
#line 534
  dvb_unregister_adapter(& dvb->adapter);
#line 535
  return (0);
}
}
#line 541 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.c"
int saa7164_dvb_register(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_dvb *dvb ;
  struct saa7164_i2c *i2c_bus ;
  struct si2168_config si2168_config ;
  struct si2157_config si2157_config ;
  struct i2c_adapter *adapter ;
  struct i2c_board_info info ;
  struct i2c_client *client_demod ;
  struct i2c_client *client_tuner ;
  int ret ;
  void *__r ;
  struct dvb_frontend *(*__a)(struct tda10048_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct tda10048_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;
  void *__r___0 ;
  struct dvb_frontend *(*__a___0)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___5 ;
  struct dvb_frontend *(*tmp___6)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___7 ;
  struct dvb_frontend *tmp___8 ;
  void *__r___1 ;
  struct dvb_frontend *(*__a___1)(struct tda10048_config  const  * , struct i2c_adapter * ) ;
  void *tmp___10 ;
  struct dvb_frontend *(*tmp___11)(struct tda10048_config  const  * , struct i2c_adapter * ) ;
  void *tmp___12 ;
  struct dvb_frontend *tmp___13 ;
  void *__r___2 ;
  struct dvb_frontend *(*__a___2)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___15 ;
  struct dvb_frontend *(*tmp___16)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                   struct tda18271_config * ) ;
  void *tmp___17 ;
  struct dvb_frontend *tmp___18 ;
  void *__r___3 ;
  struct dvb_frontend *(*__a___3)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___20 ;
  struct dvb_frontend *(*tmp___21)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___22 ;
  struct dvb_frontend *tmp___23 ;
  void *__r___4 ;
  struct dvb_frontend *(*__a___4)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___25 ;
  struct dvb_frontend *(*tmp___26)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                   struct tda18271_config * ) ;
  void *tmp___27 ;
  struct dvb_frontend *tmp___28 ;
  void *__r___5 ;
  struct dvb_frontend *(*__a___5)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___30 ;
  struct dvb_frontend *(*tmp___31)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                   struct tda18271_config * ) ;
  void *tmp___32 ;
  struct dvb_frontend *tmp___33 ;
  void *__r___6 ;
  struct dvb_frontend *(*__a___6)(struct lgdt3306a_config  const  * , struct i2c_adapter * ) ;
  void *tmp___35 ;
  struct dvb_frontend *(*tmp___36)(struct lgdt3306a_config  const  * , struct i2c_adapter * ) ;
  void *tmp___37 ;
  struct dvb_frontend *tmp___38 ;
  void *__r___7 ;
  struct dvb_frontend *(*__a___7)(struct lgdt3306a_config  const  * , struct i2c_adapter * ) ;
  void *tmp___40 ;
  struct dvb_frontend *(*tmp___41)(struct lgdt3306a_config  const  * , struct i2c_adapter * ) ;
  void *tmp___42 ;
  struct dvb_frontend *tmp___43 ;
  bool tmp___44 ;
  int tmp___45 ;
  bool tmp___46 ;
  int tmp___47 ;
  bool tmp___48 ;
  int tmp___49 ;
  bool tmp___50 ;
  int tmp___51 ;

  {
#line 543
  dev = port->dev;
#line 544
  dvb = & port->dvb;
#line 545
  i2c_bus = (struct saa7164_i2c *)0;
#line 554
  if ((saa_debug & 8U) != 0U) {
#line 554
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_dvb_register");
  } else {

  }
#line 557
  switch (dev->board) {
  case 4U: ;
  case 5U: ;
  case 6U: ;
  case 9U: ;
  case 10U: 
#line 563
  i2c_bus = (struct saa7164_i2c *)(& dev->i2c_bus) + ((unsigned long )port->nr + 1UL);
#line 564
  switch (port->nr) {
  case 0: 
#line 566
  __r = (void *)0;
#line 566
  tmp___2 = __symbol_get("tda10048_attach");
#line 566
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 566
  if (tmp___1) {

  } else {
#line 566
    __request_module(1, "symbol:tda10048_attach");
#line 566
    tmp___0 = __symbol_get("tda10048_attach");
#line 566
    tmp___1 = (struct dvb_frontend *(*)(struct tda10048_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 566
  __a = tmp___1;
#line 566
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 566
    tmp___3 = (*__a)((struct tda10048_config  const  *)(& hauppauge_hvr2200_1_config),
                     & i2c_bus->i2c_adap);
#line 566
    __r = (void *)tmp___3;
#line 566
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 566
      __symbol_put("tda10048_attach");
    } else {

    }
  } else {
#line 566
    printk("\vDVB: Unable to find symbol tda10048_attach()\n");
  }
#line 566
  port->dvb.frontend = (struct dvb_frontend *)__r;
#line 570
  if ((unsigned long )port->dvb.frontend != (unsigned long )((struct dvb_frontend *)0)) {
#line 572
    __r___0 = (void *)0;
#line 572
    tmp___7 = __symbol_get("tda18271_attach");
#line 572
    tmp___6 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , u8  ,
                                                         struct i2c_adapter * , struct tda18271_config * ))tmp___7) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                                                  u8  ,
                                                                                                                                                                  struct i2c_adapter * ,
                                                                                                                                                                  struct tda18271_config * ))0);
#line 572
    if (tmp___6) {

    } else {
#line 572
      __request_module(1, "symbol:tda18271_attach");
#line 572
      tmp___5 = __symbol_get("tda18271_attach");
#line 572
      tmp___6 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                          struct tda18271_config * ))tmp___5;
    }
#line 572
    __a___0 = tmp___6;
#line 572
    if ((unsigned long )__a___0 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              u8  ,
                                                                              struct i2c_adapter * ,
                                                                              struct tda18271_config * ))0)) {
#line 572
      tmp___8 = (*__a___0)(port->dvb.frontend, 96, & i2c_bus->i2c_adap, & hauppauge_hvr22x0_tuner_config);
#line 572
      __r___0 = (void *)tmp___8;
#line 572
      if ((unsigned long )__r___0 == (unsigned long )((void *)0)) {
#line 572
        __symbol_put("tda18271_attach");
      } else {

      }
    } else {
#line 572
      printk("\vDVB: Unable to find symbol tda18271_attach()\n");
    }
  } else {

  }
#line 577
  goto ldv_52096;
  case 1: 
#line 579
  __r___1 = (void *)0;
#line 579
  tmp___12 = __symbol_get("tda10048_attach");
#line 579
  tmp___11 = (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                        struct i2c_adapter * ))tmp___12) != (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 579
  if (tmp___11) {

  } else {
#line 579
    __request_module(1, "symbol:tda10048_attach");
#line 579
    tmp___10 = __symbol_get("tda10048_attach");
#line 579
    tmp___11 = (struct dvb_frontend *(*)(struct tda10048_config  const  * , struct i2c_adapter * ))tmp___10;
  }
#line 579
  __a___1 = tmp___11;
#line 579
  if ((unsigned long )__a___1 != (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 579
    tmp___13 = (*__a___1)((struct tda10048_config  const  *)(& hauppauge_hvr2200_2_config),
                          & i2c_bus->i2c_adap);
#line 579
    __r___1 = (void *)tmp___13;
#line 579
    if ((unsigned long )__r___1 == (unsigned long )((void *)0)) {
#line 579
      __symbol_put("tda10048_attach");
    } else {

    }
  } else {
#line 579
    printk("\vDVB: Unable to find symbol tda10048_attach()\n");
  }
#line 579
  port->dvb.frontend = (struct dvb_frontend *)__r___1;
#line 583
  if ((unsigned long )port->dvb.frontend != (unsigned long )((struct dvb_frontend *)0)) {
#line 585
    __r___2 = (void *)0;
#line 585
    tmp___17 = __symbol_get("tda18271_attach");
#line 585
    tmp___16 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                          u8  , struct i2c_adapter * ,
                                                          struct tda18271_config * ))tmp___17) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                             u8  ,
                                                                                                                                             struct i2c_adapter * ,
                                                                                                                                             struct tda18271_config * ))0);
#line 585
    if (tmp___16) {

    } else {
#line 585
      __request_module(1, "symbol:tda18271_attach");
#line 585
      tmp___15 = __symbol_get("tda18271_attach");
#line 585
      tmp___16 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                           struct tda18271_config * ))tmp___15;
    }
#line 585
    __a___2 = tmp___16;
#line 585
    if ((unsigned long )__a___2 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                              u8  ,
                                                                              struct i2c_adapter * ,
                                                                              struct tda18271_config * ))0)) {
#line 585
      tmp___18 = (*__a___2)(port->dvb.frontend, 96, & i2c_bus->i2c_adap, & hauppauge_hvr22x0s_tuner_config);
#line 585
      __r___2 = (void *)tmp___18;
#line 585
      if ((unsigned long )__r___2 == (unsigned long )((void *)0)) {
#line 585
        __symbol_put("tda18271_attach");
      } else {

      }
    } else {
#line 585
      printk("\vDVB: Unable to find symbol tda18271_attach()\n");
    }
  } else {

  }
#line 590
  goto ldv_52096;
  }
  ldv_52096: ;
#line 592
  goto ldv_52104;
  case 3U: ;
  case 7U: ;
  case 8U: 
#line 596
  i2c_bus = (struct saa7164_i2c *)(& dev->i2c_bus) + ((unsigned long )port->nr + 1UL);
#line 598
  __r___3 = (void *)0;
#line 598
  tmp___22 = __symbol_get("s5h1411_attach");
#line 598
  tmp___21 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                        struct i2c_adapter * ))tmp___22) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                                                                                       struct i2c_adapter * ))0);
#line 598
  if (tmp___21) {

  } else {
#line 598
    __request_module(1, "symbol:s5h1411_attach");
#line 598
    tmp___20 = __symbol_get("s5h1411_attach");
#line 598
    tmp___21 = (struct dvb_frontend *(*)(struct s5h1411_config  const  * , struct i2c_adapter * ))tmp___20;
  }
#line 598
  __a___3 = tmp___21;
#line 598
  if ((unsigned long )__a___3 != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                            struct i2c_adapter * ))0)) {
#line 598
    tmp___23 = (*__a___3)((struct s5h1411_config  const  *)(& hauppauge_s5h1411_config),
                          & i2c_bus->i2c_adap);
#line 598
    __r___3 = (void *)tmp___23;
#line 598
    if ((unsigned long )__r___3 == (unsigned long )((void *)0)) {
#line 598
      __symbol_put("s5h1411_attach");
    } else {

    }
  } else {
#line 598
    printk("\vDVB: Unable to find symbol s5h1411_attach()\n");
  }
#line 598
  port->dvb.frontend = (struct dvb_frontend *)__r___3;
#line 602
  if ((unsigned long )port->dvb.frontend != (unsigned long )((struct dvb_frontend *)0)) {
#line 603
    if (port->nr == 0) {
#line 606
      __r___4 = (void *)0;
#line 606
      tmp___27 = __symbol_get("tda18271_attach");
#line 606
      tmp___26 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                            u8  , struct i2c_adapter * ,
                                                            struct tda18271_config * ))tmp___27) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                               u8  ,
                                                                                                                                               struct i2c_adapter * ,
                                                                                                                                               struct tda18271_config * ))0);
#line 606
      if (tmp___26) {

      } else {
#line 606
        __request_module(1, "symbol:tda18271_attach");
#line 606
        tmp___25 = __symbol_get("tda18271_attach");
#line 606
        tmp___26 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                             struct tda18271_config * ))tmp___25;
      }
#line 606
      __a___4 = tmp___26;
#line 606
      if ((unsigned long )__a___4 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                u8  ,
                                                                                struct i2c_adapter * ,
                                                                                struct tda18271_config * ))0)) {
#line 606
        tmp___28 = (*__a___4)(port->dvb.frontend, 96, & i2c_bus->i2c_adap, & hauppauge_hvr22x0_tuner_config);
#line 606
        __r___4 = (void *)tmp___28;
#line 606
        if ((unsigned long )__r___4 == (unsigned long )((void *)0)) {
#line 606
          __symbol_put("tda18271_attach");
        } else {

        }
      } else {
#line 606
        printk("\vDVB: Unable to find symbol tda18271_attach()\n");
      }
    } else {
#line 611
      __r___5 = (void *)0;
#line 611
      tmp___32 = __symbol_get("tda18271_attach");
#line 611
      tmp___31 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                            u8  , struct i2c_adapter * ,
                                                            struct tda18271_config * ))tmp___32) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                               u8  ,
                                                                                                                                               struct i2c_adapter * ,
                                                                                                                                               struct tda18271_config * ))0);
#line 611
      if (tmp___31) {

      } else {
#line 611
        __request_module(1, "symbol:tda18271_attach");
#line 611
        tmp___30 = __symbol_get("tda18271_attach");
#line 611
        tmp___31 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                             struct tda18271_config * ))tmp___30;
      }
#line 611
      __a___5 = tmp___31;
#line 611
      if ((unsigned long )__a___5 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                u8  ,
                                                                                struct i2c_adapter * ,
                                                                                struct tda18271_config * ))0)) {
#line 611
        tmp___33 = (*__a___5)(port->dvb.frontend, 96, & i2c_bus->i2c_adap, & hauppauge_hvr22x0s_tuner_config);
#line 611
        __r___5 = (void *)tmp___33;
#line 611
        if ((unsigned long )__r___5 == (unsigned long )((void *)0)) {
#line 611
          __symbol_put("tda18271_attach");
        } else {

        }
      } else {
#line 611
        printk("\vDVB: Unable to find symbol tda18271_attach()\n");
      }
    }
  } else {

  }
#line 617
  goto ldv_52104;
  case 11U: ;
  case 12U: 
#line 620
  i2c_bus = (struct saa7164_i2c *)(& dev->i2c_bus) + 2UL;
#line 622
  if (port->nr == 0) {
#line 623
    __r___6 = (void *)0;
#line 623
    tmp___37 = __symbol_get("lgdt3306a_attach");
#line 623
    tmp___36 = (unsigned long )((struct dvb_frontend *(*)(struct lgdt3306a_config  const  * ,
                                                          struct i2c_adapter * ))tmp___37) != (unsigned long )((struct dvb_frontend *(*)(struct lgdt3306a_config  const  * ,
                                                                                                                                         struct i2c_adapter * ))0);
#line 623
    if (tmp___36) {

    } else {
#line 623
      __request_module(1, "symbol:lgdt3306a_attach");
#line 623
      tmp___35 = __symbol_get("lgdt3306a_attach");
#line 623
      tmp___36 = (struct dvb_frontend *(*)(struct lgdt3306a_config  const  * , struct i2c_adapter * ))tmp___35;
    }
#line 623
    __a___6 = tmp___36;
#line 623
    if ((unsigned long )__a___6 != (unsigned long )((struct dvb_frontend *(*)(struct lgdt3306a_config  const  * ,
                                                                              struct i2c_adapter * ))0)) {
#line 623
      tmp___38 = (*__a___6)((struct lgdt3306a_config  const  *)(& hauppauge_hvr2255a_config),
                            & i2c_bus->i2c_adap);
#line 623
      __r___6 = (void *)tmp___38;
#line 623
      if ((unsigned long )__r___6 == (unsigned long )((void *)0)) {
#line 623
        __symbol_put("lgdt3306a_attach");
      } else {

      }
    } else {
#line 623
      printk("\vDVB: Unable to find symbol lgdt3306a_attach()\n");
    }
#line 623
    port->dvb.frontend = (struct dvb_frontend *)__r___6;
  } else {
#line 626
    __r___7 = (void *)0;
#line 626
    tmp___42 = __symbol_get("lgdt3306a_attach");
#line 626
    tmp___41 = (unsigned long )((struct dvb_frontend *(*)(struct lgdt3306a_config  const  * ,
                                                          struct i2c_adapter * ))tmp___42) != (unsigned long )((struct dvb_frontend *(*)(struct lgdt3306a_config  const  * ,
                                                                                                                                         struct i2c_adapter * ))0);
#line 626
    if (tmp___41) {

    } else {
#line 626
      __request_module(1, "symbol:lgdt3306a_attach");
#line 626
      tmp___40 = __symbol_get("lgdt3306a_attach");
#line 626
      tmp___41 = (struct dvb_frontend *(*)(struct lgdt3306a_config  const  * , struct i2c_adapter * ))tmp___40;
    }
#line 626
    __a___7 = tmp___41;
#line 626
    if ((unsigned long )__a___7 != (unsigned long )((struct dvb_frontend *(*)(struct lgdt3306a_config  const  * ,
                                                                              struct i2c_adapter * ))0)) {
#line 626
      tmp___43 = (*__a___7)((struct lgdt3306a_config  const  *)(& hauppauge_hvr2255b_config),
                            & i2c_bus->i2c_adap);
#line 626
      __r___7 = (void *)tmp___43;
#line 626
      if ((unsigned long )__r___7 == (unsigned long )((void *)0)) {
#line 626
        __symbol_put("lgdt3306a_attach");
      } else {

      }
    } else {
#line 626
      printk("\vDVB: Unable to find symbol lgdt3306a_attach()\n");
    }
#line 626
    port->dvb.frontend = (struct dvb_frontend *)__r___7;
  }
#line 630
  if ((unsigned long )port->dvb.frontend != (unsigned long )((struct dvb_frontend *)0)) {
#line 632
    if (port->nr == 0) {
#line 633
      si2157_attach(port, & dev->i2c_bus[0].i2c_adap, port->dvb.frontend, 192, & hauppauge_hvr2255_tuner_config);
    } else {
#line 637
      si2157_attach(port, & dev->i2c_bus[1].i2c_adap, port->dvb.frontend, 192, & hauppauge_hvr2255_tuner_config);
    }
  } else {

  }
#line 642
  goto ldv_52104;
  case 13U: ;
#line 645
  if (port->nr == 0) {
#line 647
    memset((void *)(& si2168_config), 0, 24UL);
#line 648
    si2168_config.i2c_adapter = & adapter;
#line 649
    si2168_config.fe = & port->dvb.frontend;
#line 650
    si2168_config.ts_mode = 3U;
#line 651
    memset((void *)(& info), 0, 64UL);
#line 652
    strlcpy((char *)(& info.type), "si2168", 20UL);
#line 653
    info.addr = 100U;
#line 654
    info.platform_data = (void *)(& si2168_config);
#line 655
    __request_module(1, (char const   *)(& info.type));
#line 656
    client_demod = i2c_new_device(& dev->i2c_bus[2].i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 658
    if ((unsigned long )client_demod == (unsigned long )((struct i2c_client *)0) || (unsigned long )client_demod->dev.driver == (unsigned long )((struct device_driver *)0)) {
#line 659
      goto frontend_detach;
    } else {

    }
#line 661
    tmp___44 = try_module_get((client_demod->dev.driver)->owner);
#line 661
    if (tmp___44) {
#line 661
      tmp___45 = 0;
    } else {
#line 661
      tmp___45 = 1;
    }
#line 661
    if (tmp___45) {
#line 662
      i2c_unregister_device(client_demod);
#line 663
      goto frontend_detach;
    } else {

    }
#line 665
    port->i2c_client_demod = client_demod;
#line 668
    memset((void *)(& si2157_config), 0, 16UL);
#line 669
    si2157_config.if_port = 1U;
#line 670
    si2157_config.fe = port->dvb.frontend;
#line 671
    memset((void *)(& info), 0, 64UL);
#line 672
    strlcpy((char *)(& info.type), "si2157", 20UL);
#line 673
    info.addr = 96U;
#line 674
    info.platform_data = (void *)(& si2157_config);
#line 675
    __request_module(1, (char const   *)(& info.type));
#line 676
    client_tuner = i2c_new_device(& dev->i2c_bus[0].i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 678
    if ((unsigned long )client_tuner == (unsigned long )((struct i2c_client *)0) || (unsigned long )client_tuner->dev.driver == (unsigned long )((struct device_driver *)0)) {
#line 679
      module_put((client_demod->dev.driver)->owner);
#line 680
      i2c_unregister_device(client_demod);
#line 681
      goto frontend_detach;
    } else {

    }
#line 683
    tmp___46 = try_module_get((client_tuner->dev.driver)->owner);
#line 683
    if (tmp___46) {
#line 683
      tmp___47 = 0;
    } else {
#line 683
      tmp___47 = 1;
    }
#line 683
    if (tmp___47) {
#line 684
      i2c_unregister_device(client_tuner);
#line 685
      module_put((client_demod->dev.driver)->owner);
#line 686
      i2c_unregister_device(client_demod);
#line 687
      goto frontend_detach;
    } else {

    }
#line 689
    port->i2c_client_tuner = client_tuner;
  } else {
#line 692
    memset((void *)(& si2168_config), 0, 24UL);
#line 693
    si2168_config.i2c_adapter = & adapter;
#line 694
    si2168_config.fe = & port->dvb.frontend;
#line 695
    si2168_config.ts_mode = 3U;
#line 696
    memset((void *)(& info), 0, 64UL);
#line 697
    strlcpy((char *)(& info.type), "si2168", 20UL);
#line 698
    info.addr = 102U;
#line 699
    info.platform_data = (void *)(& si2168_config);
#line 700
    __request_module(1, (char const   *)(& info.type));
#line 701
    client_demod = i2c_new_device(& dev->i2c_bus[2].i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 703
    if ((unsigned long )client_demod == (unsigned long )((struct i2c_client *)0) || (unsigned long )client_demod->dev.driver == (unsigned long )((struct device_driver *)0)) {
#line 704
      goto frontend_detach;
    } else {

    }
#line 706
    tmp___48 = try_module_get((client_demod->dev.driver)->owner);
#line 706
    if (tmp___48) {
#line 706
      tmp___49 = 0;
    } else {
#line 706
      tmp___49 = 1;
    }
#line 706
    if (tmp___49) {
#line 707
      i2c_unregister_device(client_demod);
#line 708
      goto frontend_detach;
    } else {

    }
#line 710
    port->i2c_client_demod = client_demod;
#line 713
    memset((void *)(& si2157_config), 0, 16UL);
#line 714
    si2157_config.fe = port->dvb.frontend;
#line 715
    si2157_config.if_port = 1U;
#line 716
    memset((void *)(& info), 0, 64UL);
#line 717
    strlcpy((char *)(& info.type), "si2157", 20UL);
#line 718
    info.addr = 96U;
#line 719
    info.platform_data = (void *)(& si2157_config);
#line 720
    __request_module(1, (char const   *)(& info.type));
#line 721
    client_tuner = i2c_new_device(& dev->i2c_bus[1].i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 723
    if ((unsigned long )client_tuner == (unsigned long )((struct i2c_client *)0) || (unsigned long )client_tuner->dev.driver == (unsigned long )((struct device_driver *)0)) {
#line 724
      module_put((client_demod->dev.driver)->owner);
#line 725
      i2c_unregister_device(client_demod);
#line 726
      goto frontend_detach;
    } else {

    }
#line 728
    tmp___50 = try_module_get((client_tuner->dev.driver)->owner);
#line 728
    if (tmp___50) {
#line 728
      tmp___51 = 0;
    } else {
#line 728
      tmp___51 = 1;
    }
#line 728
    if (tmp___51) {
#line 729
      i2c_unregister_device(client_tuner);
#line 730
      module_put((client_demod->dev.driver)->owner);
#line 731
      i2c_unregister_device(client_demod);
#line 732
      goto frontend_detach;
    } else {

    }
#line 734
    port->i2c_client_tuner = client_tuner;
  }
#line 737
  goto ldv_52104;
  default: 
#line 739
  printk("\v%s: The frontend isn\'t supported\n", (char *)(& dev->name));
#line 741
  goto ldv_52104;
  }
  ldv_52104: ;
#line 743
  if ((unsigned long )dvb->frontend == (unsigned long )((struct dvb_frontend *)0)) {
#line 744
    printk("\v%s() Frontend initialization failed\n", "saa7164_dvb_register");
#line 746
    return (-1);
  } else {

  }
#line 750
  ret = dvb_register(port);
#line 751
  if (ret < 0) {
#line 752
    if ((unsigned long )(dvb->frontend)->ops.release != (unsigned long )((void (*)(struct dvb_frontend * ))0)) {
#line 753
      (*((dvb->frontend)->ops.release))(dvb->frontend);
    } else {

    }
#line 754
    return (ret);
  } else {

  }
#line 757
  return (0);
  frontend_detach: 
#line 760
  printk("\v%s() Frontend/I2C initialization failed\n", "saa7164_dvb_register");
#line 761
  return (-1);
}
}
#line 256 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 260
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 260
  ldv_func_res = tmp;
#line 262
  activate_work_3(ldv_func_arg3, 2);
#line 264
  return (ldv_func_res);
}
}
#line 267 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
bool ldv_queue_delayed_work_on_164(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 271
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 271
  ldv_func_res = tmp;
#line 273
  activate_work_3(& ldv_func_arg3->work, 2);
#line 275
  return (ldv_func_res);
}
}
#line 278 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 282
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 282
  ldv_func_res = tmp;
#line 284
  activate_work_3(ldv_func_arg3, 2);
#line 286
  return (ldv_func_res);
}
}
#line 289 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
void ldv_flush_workqueue_166(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 292
  flush_workqueue(ldv_func_arg1);
#line 294
  call_and_disable_all_3(2);
#line 295
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
bool ldv_queue_delayed_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 301
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 301
  ldv_func_res = tmp;
#line 303
  activate_work_3(& ldv_func_arg3->work, 2);
#line 305
  return (ldv_func_res);
}
}
#line 343 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
void *ldv_kmem_cache_alloc_173(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 346
  ldv_check_alloc_flags(flags);
#line 347
  tmp = ldv_undef_ptr();
#line 347
  return (tmp);
}
}
#line 385 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
int ldv_pskb_expand_head_179(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 388
  ldv_check_alloc_flags(flags);
#line 389
  tmp = ldv_undef_ptr();
#line 389
  return ((int )((long )tmp));
}
}
#line 399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
struct sk_buff *ldv_skb_clone_181(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 402
  ldv_check_alloc_flags(flags);
#line 403
  tmp = ldv_undef_ptr();
#line 403
  return ((struct sk_buff *)tmp);
}
}
#line 413 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
struct sk_buff *ldv_skb_copy_183(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 416
  ldv_check_alloc_flags(flags);
#line 417
  tmp = ldv_undef_ptr();
#line 417
  return ((struct sk_buff *)tmp);
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_184(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 423
  ldv_check_alloc_flags(flags);
#line 424
  tmp = ldv_undef_ptr();
#line 424
  return ((struct sk_buff *)tmp);
}
}
#line 427 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_185(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 430
  ldv_check_alloc_flags(flags);
#line 431
  tmp = ldv_undef_ptr();
#line 431
  return ((struct sk_buff *)tmp);
}
}
#line 434 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_186(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 438
  tmp = ldv_undef_ptr();
#line 438
  return ((struct sk_buff *)tmp);
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
int ldv_pskb_expand_head_187(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 444
  ldv_check_alloc_flags(flags);
#line 445
  tmp = ldv_undef_ptr();
#line 445
  return ((int )((long )tmp));
}
}
#line 448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
int ldv_pskb_expand_head_188(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 451
  ldv_check_alloc_flags(flags);
#line 452
  tmp = ldv_undef_ptr();
#line 452
  return ((int )((long )tmp));
}
}
#line 455 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-dvb.o.c.prepared"
struct sk_buff *ldv_skb_clone_189(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 459
  tmp = ldv_undef_ptr();
#line 459
  return ((struct sk_buff *)tmp);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_210(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_213(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_212(struct workqueue_struct *ldv_func_arg1 ) ;
#line 221 "./arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ 


  {
#line 223
  memcpy((void *)dst, src, count);
#line 224
  return;
}
}
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_219(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 51
extern void release_firmware(struct firmware  const  * ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_227(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_235(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_229(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_225(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_233(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_230(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_231(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_232(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 40 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.c"
static int saa7164_dl_wait_ack(struct saa7164_dev *dev , u32 reg ) 
{ 
  u32 timeout ;
  unsigned int tmp ;

  {
#line 42
  timeout = 5000U;
#line 43
  goto ldv_51830;
  ldv_51829: 
#line 44
  timeout = timeout - 10U;
#line 45
  if (timeout == 0U) {
#line 46
    printk("\v%s() timeout (no d/l ack)\n", "saa7164_dl_wait_ack");
#line 48
    return (-16);
  } else {

  }
#line 50
  msleep(100U);
  ldv_51830: 
#line 43
  tmp = readl((void const volatile   *)dev->lmmio + (unsigned long )(reg >> 2));
#line 43
  if ((tmp & 1U) == 0U) {
#line 45
    goto ldv_51829;
  } else {

  }

#line 53
  return (0);
}
}
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.c"
static int saa7164_dl_wait_clr(struct saa7164_dev *dev , u32 reg ) 
{ 
  u32 timeout ;
  unsigned int tmp ;

  {
#line 58
  timeout = 5000U;
#line 59
  goto ldv_51839;
  ldv_51838: 
#line 60
  timeout = timeout - 10U;
#line 61
  if (timeout == 0U) {
#line 62
    printk("\v%s() timeout (no d/l clr)\n", "saa7164_dl_wait_clr");
#line 64
    return (-16);
  } else {

  }
#line 66
  msleep(100U);
  ldv_51839: 
#line 59
  tmp = readl((void const volatile   *)dev->lmmio + (unsigned long )(reg >> 2));
#line 59
  if ((int )tmp & 1) {
#line 61
    goto ldv_51838;
  } else {

  }

#line 69
  return (0);
}
}
#line 74 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.c"
static int saa7164_downloadimage(struct saa7164_dev *dev , u8 *src , u32 srcsize ,
                                 u32 dlflags , u8 *dst , u32 dstsize ) 
{ 
  u32 reg ;
  u32 timeout ;
  u32 offset ;
  u8 *srcbuf ;
  int ret ;
  u32 dlflag ;
  u32 dlflag_ack ;
  u32 drflag ;
  u32 drflag_ack ;
  u32 bleflag ;
  void *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  u32 tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 78
  srcbuf = (u8 *)0U;
#line 81
  dlflag = dlflags;
#line 82
  dlflag_ack = dlflag + 4U;
#line 83
  drflag = dlflag_ack + 4U;
#line 84
  drflag_ack = drflag + 4U;
#line 85
  bleflag = drflag_ack + 4U;
#line 87
  if ((saa_debug & 4U) != 0U) {
#line 87
    printk("\017%s: %s(image=%p, size=%d, flags=0x%x, dst=%p, dstsize=0x%x)\n", (char *)(& dev->name),
           "saa7164_downloadimage", src, srcsize, dlflags, dst, dstsize);
  } else {

  }
#line 91
  if ((unsigned long )src == (unsigned long )((u8 *)0U) || (unsigned long )dst == (unsigned long )((u8 *)0U)) {
#line 92
    ret = -5;
#line 93
    goto out;
  } else {

  }
#line 96
  tmp = kzalloc(4194304UL, 208U);
#line 96
  srcbuf = (u8 *)tmp;
#line 97
  if ((unsigned long )srcbuf == (unsigned long )((u8 *)0U)) {
#line 98
    ret = -12;
#line 99
    goto out;
  } else {

  }
#line 102
  if (srcsize > 4194304U) {
#line 103
    ret = -12;
#line 104
    goto out;
  } else {

  }
#line 107
  memcpy((void *)srcbuf, (void const   *)src, (size_t )srcsize);
#line 109
  if ((saa_debug & 4U) != 0U) {
#line 109
    printk("\017%s: %s() dlflag = 0x%x\n", (char *)(& dev->name), "saa7164_downloadimage",
           dlflag);
  } else {

  }
#line 110
  if ((saa_debug & 4U) != 0U) {
#line 110
    printk("\017%s: %s() dlflag_ack = 0x%x\n", (char *)(& dev->name), "saa7164_downloadimage",
           dlflag_ack);
  } else {

  }
#line 111
  if ((saa_debug & 4U) != 0U) {
#line 111
    printk("\017%s: %s() drflag = 0x%x\n", (char *)(& dev->name), "saa7164_downloadimage",
           drflag);
  } else {

  }
#line 112
  if ((saa_debug & 4U) != 0U) {
#line 112
    printk("\017%s: %s() drflag_ack = 0x%x\n", (char *)(& dev->name), "saa7164_downloadimage",
           drflag_ack);
  } else {

  }
#line 113
  if ((saa_debug & 4U) != 0U) {
#line 113
    printk("\017%s: %s() bleflag = 0x%x\n", (char *)(& dev->name), "saa7164_downloadimage",
           bleflag);
  } else {

  }
#line 115
  reg = readl((void const volatile   *)dev->lmmio + (unsigned long )(dlflag >> 2));
#line 116
  if ((saa_debug & 4U) != 0U) {
#line 116
    printk("\017%s: %s() dlflag (0x%x)= 0x%x\n", (char *)(& dev->name), "saa7164_downloadimage",
           dlflag, reg);
  } else {

  }
#line 117
  if (reg == 1U) {
#line 118
    if ((saa_debug & 4U) != 0U) {
#line 118
      printk("\017%s: %s() Download flag already set, please reboot\n", (char *)(& dev->name),
             "saa7164_downloadimage");
    } else {

    }
  } else {

  }
#line 123
  writel(1U, (void volatile   *)dev->lmmio + (unsigned long )(dlflag >> 2));
#line 124
  ret = saa7164_dl_wait_ack(dev, dlflag_ack);
#line 125
  if (ret < 0) {
#line 126
    goto out;
  } else {

  }
#line 129
  writel(0U, (void volatile   *)dev->lmmio + (unsigned long )(dlflag >> 2));
#line 130
  ret = saa7164_dl_wait_clr(dev, dlflag_ack);
#line 131
  if (ret < 0) {
#line 132
    goto out;
  } else {

  }
#line 135
  offset = 0U;
#line 135
  goto ldv_51862;
  ldv_51861: ;
#line 138
  if ((saa_debug & 4U) != 0U) {
#line 138
    printk("\017%s: %s() memcpy %d\n", (char *)(& dev->name), "saa7164_downloadimage",
           dstsize);
  } else {

  }
#line 139
  memcpy_toio((void volatile   *)dst, (void const   *)srcbuf + (unsigned long )offset,
              (size_t )dstsize);
#line 142
  writel(1U, (void volatile   *)dev->lmmio + (unsigned long )(drflag >> 2));
#line 143
  ret = saa7164_dl_wait_ack(dev, drflag_ack);
#line 144
  if (ret < 0) {
#line 145
    goto out;
  } else {

  }
#line 148
  writel(0U, (void volatile   *)dev->lmmio + (unsigned long )(drflag >> 2));
#line 149
  ret = saa7164_dl_wait_clr(dev, drflag_ack);
#line 150
  if (ret < 0) {
#line 151
    goto out;
  } else {

  }
#line 136
  srcsize = srcsize - dstsize;
#line 136
  offset = offset + dstsize;
  ldv_51862: ;
#line 135
  if (srcsize > dstsize) {
#line 137
    goto ldv_51861;
  } else {

  }

#line 155
  if ((saa_debug & 4U) != 0U) {
#line 155
    printk("\017%s: %s() memcpy(l) %d\n", (char *)(& dev->name), "saa7164_downloadimage",
           dstsize);
  } else {

  }
#line 157
  memcpy_toio((void volatile   *)dst, (void const   *)srcbuf + (unsigned long )offset,
              (size_t )srcsize);
#line 160
  writel(1U, (void volatile   *)dev->lmmio + (unsigned long )(drflag >> 2));
#line 161
  ret = saa7164_dl_wait_ack(dev, drflag_ack);
#line 162
  if (ret < 0) {
#line 163
    goto out;
  } else {

  }
#line 165
  writel(0U, (void volatile   *)dev->lmmio + (unsigned long )(drflag >> 2));
#line 166
  timeout = 0U;
#line 167
  goto ldv_51866;
  ldv_51865: 
#line 168
  tmp___0 = readl((void const volatile   *)dev->lmmio + (unsigned long )(bleflag >> 2));
#line 168
  if ((tmp___0 & 4U) != 0U) {
#line 169
    printk("\v%s() image corrupt\n", "saa7164_downloadimage");
#line 170
    ret = -16;
#line 171
    goto out;
  } else {

  }
#line 174
  tmp___1 = readl((void const volatile   *)dev->lmmio + (unsigned long )(bleflag >> 2));
#line 174
  if ((tmp___1 & 8U) != 0U) {
#line 175
    printk("\v%s() device memory corrupt\n", "saa7164_downloadimage");
#line 177
    ret = -16;
#line 178
    goto out;
  } else {

  }
#line 181
  msleep(10U);
#line 182
  tmp___2 = timeout;
#line 182
  timeout = timeout + 1U;
#line 182
  if (tmp___2 > 60U) {
#line 183
    goto ldv_51864;
  } else {

  }
  ldv_51866: 
#line 167
  tmp___3 = readl((void const volatile   *)dev->lmmio + (unsigned long )(bleflag >> 2));
#line 167
  if (tmp___3 != 3U) {
#line 169
    goto ldv_51865;
  } else {

  }
  ldv_51864: 
#line 186
  printk("\016%s() Image downloaded, booting...\n", "saa7164_downloadimage");
#line 188
  ret = saa7164_dl_wait_clr(dev, drflag_ack);
#line 189
  if (ret < 0) {
#line 190
    goto out;
  } else {

  }
#line 192
  printk("\016%s() Image booted successfully.\n", "saa7164_downloadimage");
#line 193
  ret = 0;
  out: 
#line 196
  kfree((void const   *)srcbuf);
#line 197
  return (ret);
}
}
#line 203 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.c"
int saa7164_downloadfirmware(struct saa7164_dev *dev ) 
{ 
  u32 tmp ;
  u32 filesize ;
  u32 version ;
  u32 err_flags ;
  u32 first_timeout ;
  u32 fwlength ;
  u32 second_timeout ;
  u32 updatebootloader ;
  u32 bootloadersize ;
  struct firmware  const  *fw ;
  struct fw_header *hdr ;
  struct fw_header *boothdr ;
  struct fw_header *fwhdr ;
  u32 bootloaderversion ;
  u32 fwloadersize ;
  u8 *bootloaderoffset ;
  u8 *fwloaderoffset ;
  char *fwname ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 207
  updatebootloader = 1U;
#line 207
  bootloadersize = 0U;
#line 208
  fw = (struct firmware  const  *)0;
#line 209
  boothdr = (struct fw_header *)0;
#line 210
  bootloaderversion = 0U;
#line 211
  bootloaderoffset = (u8 *)0U;
#line 215
  if ((saa_debug & 4U) != 0U) {
#line 215
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_downloadfirmware");
  } else {

  }
#line 217
  if ((unsigned int )saa7164_boards[dev->board].chiprev == 1U) {
#line 218
    fwname = (char *)"NXP7164-2010-03-10.1.fw";
#line 219
    fwlength = 4019072U;
  } else {
#line 221
    fwname = (char *)"NXP7164-2010-03-10.1.fw";
#line 222
    fwlength = 4019072U;
  }
#line 225
  version = saa7164_getcurrentfirmwareversion(dev);
#line 227
  if (version == 0U) {
#line 229
    second_timeout = 100U;
#line 230
    first_timeout = 100U;
#line 231
    err_flags = readl((void const volatile   *)dev->lmmio + 17U);
#line 232
    if ((saa_debug & 4U) != 0U) {
#line 232
      printk("\017%s: %s() err_flags = %x\n", (char *)(& dev->name), "saa7164_downloadfirmware",
             err_flags);
    } else {

    }
#line 235
    goto ldv_51892;
    ldv_51891: ;
#line 236
    if ((saa_debug & 4U) != 0U) {
#line 236
      printk("\017%s: %s() err_flags = %x\n", (char *)(& dev->name), "saa7164_downloadfirmware",
             err_flags);
    } else {

    }
#line 238
    msleep(10U);
#line 240
    if ((err_flags & 4U) != 0U) {
#line 241
      printk("\v%s() firmware corrupt\n", "saa7164_downloadfirmware");
#line 243
      goto ldv_51890;
    } else {

    }
#line 245
    if ((err_flags & 8U) != 0U) {
#line 246
      printk("\v%s() device memory corrupt\n", "saa7164_downloadfirmware");
#line 248
      goto ldv_51890;
    } else {

    }
#line 250
    if ((err_flags & 16U) != 0U) {
#line 251
      printk("\v%s() no first image\n", "saa7164_downloadfirmware");
#line 253
      goto ldv_51890;
    } else {

    }
#line 255
    if ((int )err_flags & 1) {
#line 256
      first_timeout = first_timeout - 10U;
#line 257
      if (first_timeout == 0U) {
#line 258
        printk("\v%s() no first image\n", "saa7164_downloadfirmware");
#line 261
        goto ldv_51890;
      } else {

      }
    } else
#line 263
    if ((err_flags & 2U) != 0U) {
#line 264
      second_timeout = second_timeout - 10U;
#line 265
      if (second_timeout == 0U) {
#line 266
        printk("\v%s() FW load time exceeded\n", "saa7164_downloadfirmware");
#line 269
        goto ldv_51890;
      } else {

      }
    } else {
#line 272
      second_timeout = second_timeout - 10U;
#line 273
      if (second_timeout == 0U) {
#line 274
        printk("\v%s() Unknown bootloader flags 0x%x\n", "saa7164_downloadfirmware",
               err_flags);
#line 277
        goto ldv_51890;
      } else {

      }
    }
#line 281
    err_flags = readl((void const volatile   *)dev->lmmio + 17U);
    ldv_51892: ;
#line 235
    if (err_flags != 3U) {
#line 237
      goto ldv_51891;
    } else {

    }
    ldv_51890: ;
#line 284
    if (err_flags == 3U) {
#line 285
      if ((saa_debug & 4U) != 0U) {
#line 285
        printk("\017%s: %s() Loader 1 has loaded.\n", (char *)(& dev->name), "saa7164_downloadfirmware");
      } else {

      }
#line 287
      first_timeout = 5000U;
#line 288
      second_timeout = 300000U;
#line 289
      second_timeout = 100U;
#line 291
      err_flags = readl((void const volatile   *)dev->lmmio + 25U);
#line 292
      if ((saa_debug & 4U) != 0U) {
#line 292
        printk("\017%s: %s() err_flags2 = %x\n", (char *)(& dev->name), "saa7164_downloadfirmware",
               err_flags);
      } else {

      }
#line 294
      goto ldv_51895;
      ldv_51894: ;
#line 295
      if ((saa_debug & 4U) != 0U) {
#line 295
        printk("\017%s: %s() err_flags2 = %x\n", (char *)(& dev->name), "saa7164_downloadfirmware",
               err_flags);
      } else {

      }
#line 297
      msleep(10U);
#line 299
      if ((err_flags & 4U) != 0U) {
#line 300
        printk("\v%s() firmware corrupt\n", "saa7164_downloadfirmware");
#line 303
        goto ldv_51893;
      } else {

      }
#line 305
      if ((err_flags & 8U) != 0U) {
#line 306
        printk("\v%s() device memory corrupt\n", "saa7164_downloadfirmware");
#line 309
        goto ldv_51893;
      } else {

      }
#line 311
      if ((err_flags & 16U) != 0U) {
#line 312
        printk("\v%s() no first image\n", "saa7164_downloadfirmware");
#line 314
        goto ldv_51893;
      } else {

      }
#line 316
      if ((int )err_flags & 1) {
#line 317
        first_timeout = first_timeout - 10U;
#line 318
        if (first_timeout == 0U) {
#line 319
          printk("\v%s() no second image\n", "saa7164_downloadfirmware");
#line 322
          goto ldv_51893;
        } else {

        }
      } else
#line 324
      if ((err_flags & 2U) != 0U) {
#line 326
        second_timeout = second_timeout - 10U;
#line 327
        if (second_timeout == 0U) {
#line 328
          printk("\v%s() FW load time exceeded\n", "saa7164_downloadfirmware");
#line 331
          goto ldv_51893;
        } else {

        }
      } else {
#line 334
        second_timeout = second_timeout - 10U;
#line 335
        if (second_timeout == 0U) {
#line 336
          printk("\v%s() Unknown bootloader flags 0x%x\n", "saa7164_downloadfirmware",
                 err_flags);
#line 339
          goto ldv_51893;
        } else {

        }
      }
#line 343
      err_flags = readl((void const volatile   *)dev->lmmio + 25U);
      ldv_51895: ;
#line 294
      if (err_flags != 3U) {
#line 296
        goto ldv_51894;
      } else {

      }
      ldv_51893: ;
#line 347
      if ((saa_debug & 4U) != 0U) {
#line 347
        tmp___0 = readl((void const volatile   *)dev->lmmio + 25U);
#line 347
        tmp___1 = readl((void const volatile   *)dev->lmmio + 17U);
#line 347
        printk("\017%s: %s() Loader flags 1:0x%x 2:0x%x.\n", (char *)(& dev->name),
               "saa7164_downloadfirmware", tmp___1, tmp___0);
      } else {

      }
    } else {

    }
#line 357
    tmp___2 = readl((void const volatile   *)dev->lmmio + 17U);
#line 357
    if (tmp___2 == 3U) {
#line 357
      tmp___3 = readl((void const volatile   *)dev->lmmio + 25U);
#line 357
      if (tmp___3 == 3U) {
#line 363
        if ((saa_debug & 4U) != 0U) {
#line 363
          printk("\017%s: %s() Loader 2 has loaded.\n", (char *)(& dev->name), "saa7164_downloadfirmware");
        } else {

        }
#line 366
        first_timeout = 5000U;
#line 367
        goto ldv_51898;
        ldv_51897: 
#line 368
        msleep(10U);
#line 370
        version = saa7164_getcurrentfirmwareversion(dev);
#line 372
        if (version != 0U) {
#line 373
          if ((saa_debug & 4U) != 0U) {
#line 373
            printk("\017%s: %s() All f/w loaded successfully\n", (char *)(& dev->name),
                   "saa7164_downloadfirmware");
          } else {

          }
#line 376
          goto ldv_51896;
        } else {
#line 378
          first_timeout = first_timeout - 10U;
#line 379
          if (first_timeout == 0U) {
#line 380
            printk("\v%s() FW did not boot\n", "saa7164_downloadfirmware");
#line 383
            goto ldv_51896;
          } else {

          }
        }
        ldv_51898: ;
#line 367
        if (first_timeout != 0U) {
#line 369
          goto ldv_51897;
        } else {

        }
        ldv_51896: ;
      } else {

      }
    } else {

    }
#line 388
    version = saa7164_getcurrentfirmwareversion(dev);
  } else {

  }
#line 392
  tmp___4 = readl((void const volatile   *)dev->lmmio + 17U);
#line 392
  if (tmp___4 == 3U) {
#line 392
    tmp___5 = readl((void const volatile   *)dev->lmmio + 25U);
#line 392
    if (tmp___5 == 3U) {
#line 392
      if (version == 0U) {
#line 397
        printk("\v%s() The firmware hung, probably bad firmware\n", "saa7164_downloadfirmware");
#line 402
        writel(3735936685U, (void volatile   *)dev->lmmio + 27U);
#line 405
        saa7164_getfirmwarestatus(dev);
#line 407
        return (-12);
      } else {

      }
    } else {

    }
  } else {

  }
#line 410
  if ((saa_debug & 4U) != 0U) {
#line 410
    printk("\017%s: Device has Firmware Version %d.%d.%d.%d\n", (char *)(& dev->name),
           (version & 64512U) >> 10, (version & 992U) >> 5, version & 31U, version >> 16);
  } else {

  }
#line 417
  if (version == 0U) {
#line 419
    printk("\016%s() Waiting for firmware upload (%s)\n", "saa7164_downloadfirmware",
           fwname);
#line 422
    ret = request_firmware(& fw, (char const   *)fwname, & (dev->pci)->dev);
#line 423
    if (ret != 0) {
#line 424
      printk("\v%s() Upload failed. (file not found?)\n", "saa7164_downloadfirmware");
#line 426
      return (-12);
    } else {

    }
#line 429
    printk("\016%s() firmware read %Zu bytes.\n", "saa7164_downloadfirmware", fw->size);
#line 432
    if ((unsigned long )fw->size != (unsigned long )fwlength) {
#line 433
      printk("\vxc5000: firmware incorrect size\n");
#line 434
      ret = -12;
#line 435
      goto out;
    } else {

    }
#line 438
    printk("\016%s() firmware loaded.\n", "saa7164_downloadfirmware");
#line 440
    hdr = (struct fw_header *)fw->data;
#line 441
    printk("\016Firmware file header part 1:\n");
#line 442
    printk("\016 .FirmwareSize = 0x%x\n", hdr->firmwaresize);
#line 443
    printk("\016 .BSLSize = 0x%x\n", hdr->bslsize);
#line 444
    printk("\016 .Reserved = 0x%x\n", hdr->reserved);
#line 445
    printk("\016 .Version = 0x%x\n", hdr->version);
#line 448
    if (hdr->firmwaresize == 0U && hdr->bslsize == 0U) {
#line 450
      filesize = hdr->reserved * 16U;
    } else {
#line 452
      filesize = ((hdr->firmwaresize + hdr->bslsize) + 1U) * 16U;
    }
#line 455
    printk("\016%s() SecBootLoader.FileSize = %d\n", "saa7164_downloadfirmware", filesize);
#line 459
    if (hdr->firmwaresize == 0U && hdr->bslsize == 0U) {
#line 463
      boothdr = (struct fw_header *)fw->data + 16U;
#line 466
      bootloaderversion = readl((void const volatile   *)dev->lmmio + 20U);
#line 468
      if ((saa_debug & 4U) != 0U) {
#line 468
        printk("\017%s: Onboard BootLoader:\n", (char *)(& dev->name));
      } else {

      }
#line 469
      if ((saa_debug & 4U) != 0U) {
#line 469
        tmp___6 = readl((void const volatile   *)dev->lmmio + 17U);
#line 469
        printk("\017%s: ->Flag 0x%x\n", (char *)(& dev->name), tmp___6);
      } else {

      }
#line 471
      if ((saa_debug & 4U) != 0U) {
#line 471
        tmp___7 = readl((void const volatile   *)dev->lmmio + 16U);
#line 471
        printk("\017%s: ->Ack 0x%x\n", (char *)(& dev->name), tmp___7);
      } else {

      }
#line 473
      if ((saa_debug & 4U) != 0U) {
#line 473
        printk("\017%s: ->FW Version 0x%x\n", (char *)(& dev->name), version);
      } else {

      }
#line 474
      if ((saa_debug & 4U) != 0U) {
#line 474
        printk("\017%s: ->Loader Version 0x%x\n", (char *)(& dev->name), bootloaderversion);
      } else {

      }
#line 477
      tmp___8 = readl((void const volatile   *)dev->lmmio + 17U);
#line 477
      if (tmp___8 == 3U) {
#line 477
        tmp___9 = readl((void const volatile   *)dev->lmmio + 16U);
#line 477
        if (tmp___9 == 0U) {
#line 477
          if (version == 0U) {
#line 481
            if ((saa_debug & 4U) != 0U) {
#line 481
              printk("\017%s: BootLoader version in  rom %d.%d.%d.%d\n", (char *)(& dev->name),
                     (bootloaderversion & 64512U) >> 10, (bootloaderversion & 992U) >> 5,
                     bootloaderversion & 31U, bootloaderversion >> 16);
            } else {

            }
#line 488
            if ((saa_debug & 4U) != 0U) {
#line 488
              printk("\017%s: BootLoader version in file %d.%d.%d.%d\n", (char *)(& dev->name),
                     (boothdr->version & 64512U) >> 10, (boothdr->version & 992U) >> 5,
                     boothdr->version & 31U, boothdr->version >> 16);
            } else {

            }
#line 496
            if (boothdr->version == bootloaderversion) {
#line 497
              updatebootloader = 0U;
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
#line 501
      tmp = ((boothdr->firmwaresize + boothdr->bslsize) + 2U) * 16U;
#line 505
      fwhdr = (struct fw_header *)fw->data + (unsigned long )tmp;
    } else {
#line 508
      fwhdr = hdr;
    }
#line 511
    if ((saa_debug & 4U) != 0U) {
#line 511
      printk("\017%s: Firmware version in file %d.%d.%d.%d\n", (char *)(& dev->name),
             (fwhdr->version & 64512U) >> 10, (fwhdr->version & 992U) >> 5, fwhdr->version & 31U,
             fwhdr->version >> 16);
    } else {

    }
#line 518
    if (fwhdr->version == version) {
#line 520
      ret = 0;
#line 521
      goto out;
    } else {

    }
#line 524
    if (hdr->firmwaresize == 0U && hdr->bslsize == 0U) {
#line 525
      if (updatebootloader != 0U) {
#line 527
        bootloadersize = ((boothdr->firmwaresize + boothdr->bslsize) + 1U) * 16U;
#line 531
        bootloaderoffset = (u8 *)fw->data + 16U;
#line 534
        if ((saa_debug & 4U) != 0U) {
#line 534
          printk("\017%s: bootloader d/l starts.\n", (char *)(& dev->name));
        } else {

        }
#line 535
        printk("\016%s() FirmwareSize = 0x%x\n", "saa7164_downloadfirmware", boothdr->firmwaresize);
#line 537
        printk("\016%s() BSLSize = 0x%x\n", "saa7164_downloadfirmware", boothdr->bslsize);
#line 539
        printk("\016%s() Reserved = 0x%x\n", "saa7164_downloadfirmware", boothdr->reserved);
#line 541
        printk("\016%s() Version = 0x%x\n", "saa7164_downloadfirmware", boothdr->version);
#line 543
        ret = saa7164_downloadimage(dev, bootloaderoffset, bootloadersize, 52U, dev->bmmio + 4096UL,
                                    4096U);
#line 550
        if (ret < 0) {
#line 551
          printk("\vbootloader d/l has failed\n");
#line 553
          goto out;
        } else {

        }
#line 555
        if ((saa_debug & 4U) != 0U) {
#line 555
          printk("\017%s: bootloader download complete.\n", (char *)(& dev->name));
        } else {

        }
      } else {

      }
#line 560
      printk("\vstarting firmware download(2)\n");
#line 561
      bootloadersize = ((boothdr->firmwaresize + boothdr->bslsize) + 1U) * 16U;
#line 565
      bootloaderoffset = (u8 *)fw->data + 16U;
#line 568
      fwloaderoffset = bootloaderoffset + (unsigned long )bootloadersize;
#line 571
      fwloadersize = ((fwhdr->firmwaresize + fwhdr->bslsize) + 1U) * 16U;
#line 574
      ret = saa7164_downloadimage(dev, fwloaderoffset, fwloadersize, 84U, dev->bmmio + 2097152UL,
                                  1048576U);
#line 581
      if (ret < 0) {
#line 582
        printk("\vfirmware download failed\n");
#line 583
        goto out;
      } else {

      }
#line 585
      printk("\vfirmware download complete.\n");
    } else {
#line 590
      printk("\vstarting firmware download(3)\n");
#line 592
      ret = saa7164_downloadimage(dev, (u8 *)fw->data, (u32 )fw->size, 52U, dev->bmmio + 4096UL,
                                  4096U);
#line 599
      if (ret < 0) {
#line 600
        printk("\vfirmware download failed\n");
#line 601
        goto out;
      } else {

      }
#line 603
      printk("\vfirmware download complete.\n");
    }
  } else {

  }
#line 607
  dev->firmwareloaded = 1U;
#line 608
  ret = 0;
  out: 
#line 611
  release_firmware(fw);
#line 612
  return (ret);
}
}
#line 256 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
bool ldv_queue_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 260
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 260
  ldv_func_res = tmp;
#line 262
  activate_work_3(ldv_func_arg3, 2);
#line 264
  return (ldv_func_res);
}
}
#line 267 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
bool ldv_queue_delayed_work_on_210(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 271
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 271
  ldv_func_res = tmp;
#line 273
  activate_work_3(& ldv_func_arg3->work, 2);
#line 275
  return (ldv_func_res);
}
}
#line 278 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
bool ldv_queue_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 282
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 282
  ldv_func_res = tmp;
#line 284
  activate_work_3(ldv_func_arg3, 2);
#line 286
  return (ldv_func_res);
}
}
#line 289 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
void ldv_flush_workqueue_212(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 292
  flush_workqueue(ldv_func_arg1);
#line 294
  call_and_disable_all_3(2);
#line 295
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
bool ldv_queue_delayed_work_on_213(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 301
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 301
  ldv_func_res = tmp;
#line 303
  activate_work_3(& ldv_func_arg3->work, 2);
#line 305
  return (ldv_func_res);
}
}
#line 343 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
void *ldv_kmem_cache_alloc_219(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 346
  ldv_check_alloc_flags(flags);
#line 347
  tmp = ldv_undef_ptr();
#line 347
  return (tmp);
}
}
#line 385 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
int ldv_pskb_expand_head_225(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 388
  ldv_check_alloc_flags(flags);
#line 389
  tmp = ldv_undef_ptr();
#line 389
  return ((int )((long )tmp));
}
}
#line 399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
struct sk_buff *ldv_skb_clone_227(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 402
  ldv_check_alloc_flags(flags);
#line 403
  tmp = ldv_undef_ptr();
#line 403
  return ((struct sk_buff *)tmp);
}
}
#line 413 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
struct sk_buff *ldv_skb_copy_229(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 416
  ldv_check_alloc_flags(flags);
#line 417
  tmp = ldv_undef_ptr();
#line 417
  return ((struct sk_buff *)tmp);
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_230(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 423
  ldv_check_alloc_flags(flags);
#line 424
  tmp = ldv_undef_ptr();
#line 424
  return ((struct sk_buff *)tmp);
}
}
#line 427 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_231(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 430
  ldv_check_alloc_flags(flags);
#line 431
  tmp = ldv_undef_ptr();
#line 431
  return ((struct sk_buff *)tmp);
}
}
#line 434 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_232(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 438
  tmp = ldv_undef_ptr();
#line 438
  return ((struct sk_buff *)tmp);
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
int ldv_pskb_expand_head_233(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 444
  ldv_check_alloc_flags(flags);
#line 445
  tmp = ldv_undef_ptr();
#line 445
  return ((int )((long )tmp));
}
}
#line 448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
int ldv_pskb_expand_head_234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 451
  ldv_check_alloc_flags(flags);
#line 452
  tmp = ldv_undef_ptr();
#line 452
  return ((int )((long )tmp));
}
}
#line 455 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-fw.o.c.prepared"
struct sk_buff *ldv_skb_clone_235(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 459
  tmp = ldv_undef_ptr();
#line 459
  return ((struct sk_buff *)tmp);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_255(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_256(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_258(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_265(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_273(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_281(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_275(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_271(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_279(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_280(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_276(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_277(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_278(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 515 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
int saa7164_bus_set(struct saa7164_dev *dev , struct tmComResInfo *msg , void *buf ) ;
#line 517
int saa7164_bus_get(struct saa7164_dev *dev , struct tmComResInfo *msg , void *buf ,
                    int peekonly ) ;
#line 27 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.c"
int saa7164_bus_setup(struct saa7164_dev *dev ) 
{ 
  struct tmComResBusInfo *b ;
  struct lock_class_key __key ;

  {
#line 29
  b = & dev->bus;
#line 31
  __mutex_init(& b->lock, "&b->lock", & __key);
#line 33
  b->Type = 2;
#line 34
  b->m_wMaxReqSize = 256U;
#line 36
  b->m_pdwSetRing = dev->bmmio + (unsigned long )((unsigned int )dev->busdesc.CommandRing);
#line 39
  b->m_dwSizeSetRing = 4096U;
#line 41
  b->m_pdwGetRing = dev->bmmio + (unsigned long )((unsigned int )dev->busdesc.ResponseRing);
#line 44
  b->m_dwSizeGetRing = 4096U;
#line 46
  b->m_dwSetWritePos = (u32 )dev->intfdesc.BARLocation + 16U;
#line 48
  b->m_dwSetReadPos = b->m_dwSetWritePos + 4U;
#line 50
  b->m_dwGetWritePos = b->m_dwSetWritePos + 8U;
#line 51
  b->m_dwGetReadPos = b->m_dwSetWritePos + 12U;
#line 53
  return (0);
}
}
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.c"
void saa7164_bus_dump(struct saa7164_dev *dev ) 
{ 
  struct tmComResBusInfo *b ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 58
  b = & dev->bus;
#line 60
  if ((saa_debug & 128U) != 0U) {
#line 60
    printk("\017%s: Dumping the bus structure:\n", (char *)(& dev->name));
  } else {

  }
#line 61
  if ((saa_debug & 128U) != 0U) {
#line 61
    printk("\017%s:  .type             = %d\n", (char *)(& dev->name), (unsigned int )b->Type);
  } else {

  }
#line 62
  if ((saa_debug & 128U) != 0U) {
#line 62
    printk("\017%s:  .dev->bmmio       = 0x%p\n", (char *)(& dev->name), dev->bmmio);
  } else {

  }
#line 63
  if ((saa_debug & 128U) != 0U) {
#line 63
    printk("\017%s:  .m_wMaxReqSize    = 0x%x\n", (char *)(& dev->name), (int )b->m_wMaxReqSize);
  } else {

  }
#line 64
  if ((saa_debug & 128U) != 0U) {
#line 64
    printk("\017%s:  .m_pdwSetRing     = 0x%p\n", (char *)(& dev->name), b->m_pdwSetRing);
  } else {

  }
#line 65
  if ((saa_debug & 128U) != 0U) {
#line 65
    printk("\017%s:  .m_dwSizeSetRing  = 0x%x\n", (char *)(& dev->name), b->m_dwSizeSetRing);
  } else {

  }
#line 66
  if ((saa_debug & 128U) != 0U) {
#line 66
    printk("\017%s:  .m_pdwGetRing     = 0x%p\n", (char *)(& dev->name), b->m_pdwGetRing);
  } else {

  }
#line 67
  if ((saa_debug & 128U) != 0U) {
#line 67
    printk("\017%s:  .m_dwSizeGetRing  = 0x%x\n", (char *)(& dev->name), b->m_dwSizeGetRing);
  } else {

  }
#line 69
  if ((saa_debug & 128U) != 0U) {
#line 69
    tmp = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwSetReadPos >> 2));
#line 69
    printk("\017%s:  .m_dwSetReadPos   = 0x%x (0x%08x)\n", (char *)(& dev->name),
           b->m_dwSetReadPos, tmp);
  } else {

  }
#line 72
  if ((saa_debug & 128U) != 0U) {
#line 72
    tmp___0 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwSetWritePos >> 2));
#line 72
    printk("\017%s:  .m_dwSetWritePos  = 0x%x (0x%08x)\n", (char *)(& dev->name),
           b->m_dwSetWritePos, tmp___0);
  } else {

  }
#line 75
  if ((saa_debug & 128U) != 0U) {
#line 75
    tmp___1 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwGetReadPos >> 2));
#line 75
    printk("\017%s:  .m_dwGetReadPos   = 0x%x (0x%08x)\n", (char *)(& dev->name),
           b->m_dwGetReadPos, tmp___1);
  } else {

  }
#line 78
  if ((saa_debug & 128U) != 0U) {
#line 78
    tmp___2 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwGetWritePos >> 2));
#line 78
    printk("\017%s:  .m_dwGetWritePos  = 0x%x (0x%08x)\n", (char *)(& dev->name),
           b->m_dwGetWritePos, tmp___2);
  } else {

  }
#line 79
  return;
}
}
#line 84 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.c"
static void saa7164_bus_verify(struct saa7164_dev *dev ) 
{ 
  struct tmComResBusInfo *b ;
  int bug ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 86
  b = & dev->bus;
#line 87
  bug = 0;
#line 89
  tmp = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwSetReadPos >> 2));
#line 89
  if (tmp > b->m_dwSizeSetRing) {
#line 90
    bug = bug + 1;
  } else {

  }
#line 92
  tmp___0 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwSetWritePos >> 2));
#line 92
  if (tmp___0 > b->m_dwSizeSetRing) {
#line 93
    bug = bug + 1;
  } else {

  }
#line 95
  tmp___1 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwGetReadPos >> 2));
#line 95
  if (tmp___1 > b->m_dwSizeGetRing) {
#line 96
    bug = bug + 1;
  } else {

  }
#line 98
  tmp___2 = readl((void const volatile   *)dev->lmmio + (unsigned long )(b->m_dwGetWritePos >> 2));
#line 98
  if (tmp___2 > b->m_dwSizeGetRing) {
#line 99
    bug = bug + 1;
  } else {

  }
#line 101
  if (bug != 0) {
#line 102
    saa_debug = 65535U;
#line 103
    saa7164_bus_dump(dev);
#line 104
    saa_debug = 1024U;
#line 105
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.c"),
                         "i" (105), "i" (12UL));
    ldv_51803: ;
#line 105
    goto ldv_51803;
  } else {

  }
#line 107
  return;
}
}
#line 109 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.c"
static void saa7164_bus_dumpmsg(struct saa7164_dev *dev , struct tmComResInfo *m ,
                                void *buf ) 
{ 


  {
#line 112
  if ((saa_debug & 128U) != 0U) {
#line 112
    printk("\017%s: Dumping msg structure:\n", (char *)(& dev->name));
  } else {

  }
#line 113
  if ((saa_debug & 128U) != 0U) {
#line 113
    printk("\017%s:  .id               = %d\n", (char *)(& dev->name), (int )m->id);
  } else {

  }
#line 114
  if ((saa_debug & 128U) != 0U) {
#line 114
    printk("\017%s:  .flags            = 0x%x\n", (char *)(& dev->name), (int )m->flags);
  } else {

  }
#line 115
  if ((saa_debug & 128U) != 0U) {
#line 115
    printk("\017%s:  .size             = 0x%x\n", (char *)(& dev->name), (int )m->size);
  } else {

  }
#line 116
  if ((saa_debug & 128U) != 0U) {
#line 116
    printk("\017%s:  .command          = 0x%x\n", (char *)(& dev->name), m->command);
  } else {

  }
#line 117
  if ((saa_debug & 128U) != 0U) {
#line 117
    printk("\017%s:  .controlselector  = 0x%x\n", (char *)(& dev->name), (int )m->controlselector);
  } else {

  }
#line 118
  if ((saa_debug & 128U) != 0U) {
#line 118
    printk("\017%s:  .seqno            = %d\n", (char *)(& dev->name), (int )m->seqno);
  } else {

  }
#line 119
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 120
    if ((saa_debug & 128U) != 0U) {
#line 120
      printk("\017%s:  .buffer (ignored)\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 121
  return;
}
}
#line 134 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.c"
int saa7164_bus_set(struct saa7164_dev *dev , struct tmComResInfo *msg , void *buf ) 
{ 
  struct tmComResBusInfo *bus ;
  u32 bytes_to_write ;
  u32 free_write_space ;
  u32 timeout ;
  u32 curr_srp ;
  u32 curr_swp ;
  u32 new_swp ;
  u32 space_rem ;
  int ret ;
  u16 size ;
  u32 tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;

  {
#line 137
  bus = & dev->bus;
#line 140
  ret = 9;
#line 143
  if ((unsigned long )msg == (unsigned long )((struct tmComResInfo *)0)) {
#line 144
    printk("\v%s() !msg\n", "saa7164_bus_set");
#line 145
    return (9);
  } else {

  }
#line 148
  if ((saa_debug & 128U) != 0U) {
#line 148
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_bus_set");
  } else {

  }
#line 150
  saa7164_bus_verify(dev);
#line 152
  if ((int )msg->size > (int )dev->bus.m_wMaxReqSize) {
#line 153
    printk("\v%s() Exceeded dev->bus.m_wMaxReqSize\n", "saa7164_bus_set");
#line 155
    return (9);
  } else {

  }
#line 158
  if ((unsigned int )msg->size != 0U && (unsigned long )buf == (unsigned long )((void *)0)) {
#line 159
    printk("\v%s() Missing message buffer\n", "saa7164_bus_set");
#line 160
    return (9);
  } else {

  }
#line 164
  mutex_lock_nested(& bus->lock, 0U);
#line 166
  bytes_to_write = (u32 )msg->size + 11U;
#line 167
  free_write_space = 0U;
#line 168
  timeout = 50U;
#line 169
  curr_srp = readl((void const volatile   *)dev->lmmio + (unsigned long )(bus->m_dwSetReadPos >> 2));
#line 170
  curr_swp = readl((void const volatile   *)dev->lmmio + (unsigned long )(bus->m_dwSetWritePos >> 2));
#line 173
  if (curr_srp > curr_swp) {
#line 175
    free_write_space = curr_srp - curr_swp;
  } else {
#line 178
    free_write_space = (bus->m_dwSizeSetRing + curr_srp) - curr_swp;
  }
#line 180
  if ((saa_debug & 128U) != 0U) {
#line 180
    printk("\017%s: %s() bytes_to_write = %d\n", (char *)(& dev->name), "saa7164_bus_set",
           bytes_to_write);
  } else {

  }
#line 183
  if ((saa_debug & 128U) != 0U) {
#line 183
    printk("\017%s: %s() free_write_space = %d\n", (char *)(& dev->name), "saa7164_bus_set",
           free_write_space);
  } else {

  }
#line 186
  if ((saa_debug & 128U) != 0U) {
#line 186
    printk("\017%s: %s() curr_srp = %x\n", (char *)(& dev->name), "saa7164_bus_set",
           curr_srp);
  } else {

  }
#line 187
  if ((saa_debug & 128U) != 0U) {
#line 187
    printk("\017%s: %s() curr_swp = %x\n", (char *)(& dev->name), "saa7164_bus_set",
           curr_swp);
  } else {

  }
#line 190
  goto ldv_51831;
  ldv_51830: 
#line 192
  tmp = timeout;
#line 192
  timeout = timeout - 1U;
#line 192
  if (tmp == 0U) {
#line 193
    printk("\v%s() bus timeout\n", "saa7164_bus_set");
#line 194
    ret = 12;
#line 195
    goto out;
  } else {

  }
#line 200
  if (1) {
#line 200
    __const_udelay(4295000UL);
  } else {
#line 200
    __ms = 1UL;
#line 200
    goto ldv_51828;
    ldv_51827: 
#line 200
    __const_udelay(4295000UL);
    ldv_51828: 
#line 200
    tmp___0 = __ms;
#line 200
    __ms = __ms - 1UL;
#line 200
    if (tmp___0 != 0UL) {
#line 202
      goto ldv_51827;
    } else {

    }

  }
#line 203
  curr_srp = readl((void const volatile   *)dev->lmmio + (unsigned long )(bus->m_dwSetReadPos >> 2));
#line 206
  if (curr_srp > curr_swp) {
#line 208
    free_write_space = curr_srp - curr_swp;
  } else {
#line 211
    free_write_space = (bus->m_dwSizeSetRing + curr_srp) - curr_swp;
  }
  ldv_51831: ;
#line 190
  if (bytes_to_write >= free_write_space) {
#line 192
    goto ldv_51830;
  } else {

  }
#line 217
  new_swp = curr_swp + bytes_to_write;
#line 219
  if ((saa_debug & 128U) != 0U) {
#line 219
    printk("\017%s: %s() new_swp = %x\n", (char *)(& dev->name), "saa7164_bus_set",
           new_swp);
  } else {

  }
#line 220
  if ((saa_debug & 128U) != 0U) {
#line 220
    printk("\017%s: %s() bus->m_dwSizeSetRing = %x\n", (char *)(& dev->name), "saa7164_bus_set",
           bus->m_dwSizeSetRing);
  } else {

  }
#line 227
  size = msg->size;
#line 229
  msg->size = msg->size;
#line 230
  msg->command = msg->command;
#line 231
  msg->controlselector = msg->controlselector;
#line 236
  if (bus->m_dwSizeSetRing < new_swp) {
#line 239
    new_swp = new_swp - bus->m_dwSizeSetRing;
#line 241
    space_rem = bus->m_dwSizeSetRing - curr_swp;
#line 243
    if ((saa_debug & 128U) != 0U) {
#line 243
      printk("\017%s: %s() space_rem = %x\n", (char *)(& dev->name), "saa7164_bus_set",
             space_rem);
    } else {

    }
#line 246
    if ((saa_debug & 128U) != 0U) {
#line 246
      printk("\017%s: %s() sizeof(*msg) = %d\n", (char *)(& dev->name), "saa7164_bus_set",
             11U);
    } else {

    }
#line 249
    if (space_rem <= 10U) {
#line 250
      if ((saa_debug & 128U) != 0U) {
#line 250
        printk("\017%s: %s() tr4\n", (char *)(& dev->name), "saa7164_bus_set");
      } else {

      }
#line 253
      memcpy_toio((void volatile   *)bus->m_pdwSetRing + (unsigned long )curr_swp,
                  (void const   *)msg, (size_t )space_rem);
#line 254
      memcpy_toio((void volatile   *)bus->m_pdwSetRing, (void const   *)msg + (unsigned long )space_rem,
                  11UL - (unsigned long )space_rem);
#line 257
      memcpy_toio((void volatile   *)(bus->m_pdwSetRing + (11UL - (unsigned long )space_rem)),
                  (void const   *)buf, (size_t )size);
    } else
#line 260
    if (space_rem == 11U) {
#line 261
      if ((saa_debug & 128U) != 0U) {
#line 261
        printk("\017%s: %s() tr5\n", (char *)(& dev->name), "saa7164_bus_set");
      } else {

      }
#line 264
      memcpy_toio((void volatile   *)bus->m_pdwSetRing + (unsigned long )curr_swp,
                  (void const   *)msg, 11UL);
#line 265
      memcpy_toio((void volatile   *)bus->m_pdwSetRing, (void const   *)buf, (size_t )size);
    } else {
#line 269
      memcpy_toio((void volatile   *)bus->m_pdwSetRing + (unsigned long )curr_swp,
                  (void const   *)msg, 11UL);
#line 270
      if ((unsigned int )size != 0U) {
#line 271
        memcpy_toio((void volatile   *)(bus->m_pdwSetRing + ((unsigned long )curr_swp + 11UL)),
                    (void const   *)buf, (unsigned long )space_rem - 11UL);
#line 274
        memcpy_toio((void volatile   *)bus->m_pdwSetRing, (void const   *)buf + ((unsigned long )space_rem + 0xfffffffffffffff5UL),
                    (size_t )(bytes_to_write - space_rem));
      } else {

      }
    }
  } else {
#line 283
    if ((saa_debug & 128U) != 0U) {
#line 283
      printk("\017%s: %s() tr6\n", (char *)(& dev->name), "saa7164_bus_set");
    } else {

    }
#line 286
    memcpy_toio((void volatile   *)bus->m_pdwSetRing + (unsigned long )curr_swp, (void const   *)msg,
                11UL);
#line 287
    memcpy_toio((void volatile   *)(bus->m_pdwSetRing + ((unsigned long )curr_swp + 11UL)),
                (void const   *)buf, (size_t )size);
  }
#line 291
  if ((saa_debug & 128U) != 0U) {
#line 291
    printk("\017%s: %s() new_swp = %x\n", (char *)(& dev->name), "saa7164_bus_set",
           new_swp);
  } else {

  }
#line 294
  writel(new_swp, (void volatile   *)dev->lmmio + (unsigned long )(bus->m_dwSetWritePos >> 2));
#line 297
  msg->size = msg->size;
#line 298
  msg->command = msg->command;
#line 299
  msg->controlselector = msg->controlselector;
#line 300
  ret = 0;
  out: 
#line 303
  saa7164_bus_dump(dev);
#line 304
  mutex_unlock(& bus->lock);
#line 305
  saa7164_bus_verify(dev);
#line 306
  return (ret);
}
}
#line 319 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.c"
int saa7164_bus_get(struct saa7164_dev *dev , struct tmComResInfo *msg , void *buf ,
                    int peekonly ) 
{ 
  struct tmComResBusInfo *bus ;
  u32 bytes_to_read ;
  u32 write_distance ;
  u32 curr_grp ;
  u32 curr_gwp ;
  u32 new_grp ;
  u32 buf_size ;
  u32 space_rem ;
  struct tmComResInfo msg_tmp ;
  int ret ;

  {
#line 322
  bus = & dev->bus;
#line 326
  ret = 9;
#line 328
  saa7164_bus_verify(dev);
#line 330
  if ((unsigned long )msg == (unsigned long )((struct tmComResInfo *)0)) {
#line 331
    return (ret);
  } else {

  }
#line 333
  if ((int )msg->size > (int )dev->bus.m_wMaxReqSize) {
#line 334
    printk("\v%s() Exceeded dev->bus.m_wMaxReqSize\n", "saa7164_bus_get");
#line 336
    return (ret);
  } else {

  }
#line 339
  if ((peekonly == 0 && (unsigned int )msg->size != 0U) && (unsigned long )buf == (unsigned long )((void *)0)) {
#line 340
    printk("\v%s() Missing msg buf, size should be %d bytes\n", "saa7164_bus_get",
           (int )msg->size);
#line 343
    return (ret);
  } else {

  }
#line 346
  mutex_lock_nested(& bus->lock, 0U);
#line 351
  curr_gwp = readl((void const volatile   *)dev->lmmio + (unsigned long )(bus->m_dwGetWritePos >> 2));
#line 352
  curr_grp = readl((void const volatile   *)dev->lmmio + (unsigned long )(bus->m_dwGetReadPos >> 2));
#line 354
  if (curr_gwp == curr_grp) {
#line 355
    ret = 34;
#line 356
    goto out;
  } else {

  }
#line 359
  bytes_to_read = 11U;
#line 362
  write_distance = 0U;
#line 363
  if (curr_gwp >= curr_grp) {
#line 365
    write_distance = curr_gwp - curr_grp;
  } else {
#line 368
    write_distance = (bus->m_dwSizeGetRing + curr_gwp) - curr_grp;
  }
#line 370
  if (bytes_to_read > write_distance) {
#line 371
    printk("\v%s() No message/response found\n", "saa7164_bus_get");
#line 372
    ret = 62;
#line 373
    goto out;
  } else {

  }
#line 377
  new_grp = curr_grp + bytes_to_read;
#line 378
  if (bus->m_dwSizeGetRing < new_grp) {
#line 381
    new_grp = new_grp - bus->m_dwSizeGetRing;
#line 382
    space_rem = bus->m_dwSizeGetRing - curr_grp;
#line 384
    memcpy_fromio((void *)(& msg_tmp), (void const volatile   *)bus->m_pdwGetRing + (unsigned long )curr_grp,
                  (size_t )space_rem);
#line 385
    memcpy_fromio((void *)(& msg_tmp) + (unsigned long )space_rem, (void const volatile   *)bus->m_pdwGetRing,
                  (size_t )(bytes_to_read - space_rem));
  } else {
#line 390
    memcpy_fromio((void *)(& msg_tmp), (void const volatile   *)bus->m_pdwGetRing + (unsigned long )curr_grp,
                  (size_t )bytes_to_read);
  }
#line 393
  msg_tmp.size = msg_tmp.size;
#line 394
  msg_tmp.command = msg_tmp.command;
#line 395
  msg_tmp.controlselector = msg_tmp.controlselector;
#line 399
  if (peekonly != 0) {
#line 400
    memcpy((void *)msg, (void const   *)(& msg_tmp), 11UL);
#line 401
    goto peekout;
  } else {

  }
#line 405
  if (((((int )msg_tmp.id != (int )msg->id || msg_tmp.command != msg->command) || (int )msg_tmp.controlselector != (int )msg->controlselector) || (int )msg_tmp.seqno != (int )msg->seqno) || (int )msg_tmp.size != (int )msg->size) {
#line 409
    printk("\v%s() Unexpected msg miss-match\n", "saa7164_bus_get");
#line 410
    saa7164_bus_dumpmsg(dev, msg, buf);
#line 411
    saa7164_bus_dumpmsg(dev, & msg_tmp, (void *)0);
#line 412
    ret = 62;
#line 413
    goto out;
  } else {

  }
#line 417
  buf_size = (u32 )msg->size;
#line 419
  bytes_to_read = (u32 )msg->size + 11U;
#line 421
  write_distance = 0U;
#line 422
  if (curr_gwp >= curr_grp) {
#line 424
    write_distance = curr_gwp - curr_grp;
  } else {
#line 427
    write_distance = (bus->m_dwSizeGetRing + curr_gwp) - curr_grp;
  }
#line 429
  if (bytes_to_read > write_distance) {
#line 430
    printk("\v%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\n",
           "saa7164_bus_get");
#line 432
    ret = 62;
#line 433
    goto out;
  } else {

  }
#line 437
  new_grp = curr_grp + bytes_to_read;
#line 438
  if (bus->m_dwSizeGetRing < new_grp) {
#line 441
    new_grp = new_grp - bus->m_dwSizeGetRing;
#line 442
    space_rem = bus->m_dwSizeGetRing - curr_grp;
#line 444
    if (space_rem <= 10U) {
#line 446
      memcpy_fromio((void *)msg, (void const volatile   *)bus->m_pdwGetRing + (unsigned long )curr_grp,
                    (size_t )space_rem);
#line 447
      memcpy_fromio((void *)msg + (unsigned long )space_rem, (void const volatile   *)bus->m_pdwGetRing,
                    11UL - (unsigned long )space_rem);
#line 449
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 450
        memcpy_fromio(buf, (void const volatile   *)(bus->m_pdwGetRing + (11UL - (unsigned long )space_rem)),
                      (size_t )buf_size);
      } else {

      }
    } else
#line 453
    if (space_rem == 11U) {
#line 454
      memcpy_fromio((void *)msg, (void const volatile   *)bus->m_pdwGetRing + (unsigned long )curr_grp,
                    11UL);
#line 455
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 456
        memcpy_fromio(buf, (void const volatile   *)bus->m_pdwGetRing, (size_t )buf_size);
      } else {

      }
    } else {
#line 459
      memcpy_fromio((void *)msg, (void const volatile   *)bus->m_pdwGetRing + (unsigned long )curr_grp,
                    11UL);
#line 460
      if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 461
        memcpy_fromio(buf, (void const volatile   *)(bus->m_pdwGetRing + ((unsigned long )curr_grp + 11UL)),
                      (unsigned long )space_rem - 11UL);
#line 463
        memcpy_fromio(buf + ((unsigned long )space_rem + 0xfffffffffffffff5UL), (void const volatile   *)bus->m_pdwGetRing,
                      (size_t )(bytes_to_read - space_rem));
      } else {

      }
    }
  } else {
#line 472
    memcpy_fromio((void *)msg, (void const volatile   *)bus->m_pdwGetRing + (unsigned long )curr_grp,
                  11UL);
#line 473
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 474
      memcpy_fromio(buf, (void const volatile   *)(bus->m_pdwGetRing + ((unsigned long )curr_grp + 11UL)),
                    (size_t )buf_size);
    } else {

    }
  }
#line 478
  msg->size = msg->size;
#line 479
  msg->command = msg->command;
#line 480
  msg->controlselector = msg->controlselector;
#line 483
  writel(new_grp, (void volatile   *)dev->lmmio + (unsigned long )(bus->m_dwGetReadPos >> 2));
  peekout: 
#line 486
  ret = 0;
  out: 
#line 488
  mutex_unlock(& bus->lock);
#line 489
  saa7164_bus_verify(dev);
#line 490
  return (ret);
}
}
#line 256 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
bool ldv_queue_work_on_255(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 260
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 260
  ldv_func_res = tmp;
#line 262
  activate_work_3(ldv_func_arg3, 2);
#line 264
  return (ldv_func_res);
}
}
#line 267 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
bool ldv_queue_delayed_work_on_256(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 271
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 271
  ldv_func_res = tmp;
#line 273
  activate_work_3(& ldv_func_arg3->work, 2);
#line 275
  return (ldv_func_res);
}
}
#line 278 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 282
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 282
  ldv_func_res = tmp;
#line 284
  activate_work_3(ldv_func_arg3, 2);
#line 286
  return (ldv_func_res);
}
}
#line 289 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
void ldv_flush_workqueue_258(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 292
  flush_workqueue(ldv_func_arg1);
#line 294
  call_and_disable_all_3(2);
#line 295
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
bool ldv_queue_delayed_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 301
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 301
  ldv_func_res = tmp;
#line 303
  activate_work_3(& ldv_func_arg3->work, 2);
#line 305
  return (ldv_func_res);
}
}
#line 343 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
void *ldv_kmem_cache_alloc_265(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 346
  ldv_check_alloc_flags(flags);
#line 347
  tmp = ldv_undef_ptr();
#line 347
  return (tmp);
}
}
#line 385 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
int ldv_pskb_expand_head_271(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 388
  ldv_check_alloc_flags(flags);
#line 389
  tmp = ldv_undef_ptr();
#line 389
  return ((int )((long )tmp));
}
}
#line 399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
struct sk_buff *ldv_skb_clone_273(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 402
  ldv_check_alloc_flags(flags);
#line 403
  tmp = ldv_undef_ptr();
#line 403
  return ((struct sk_buff *)tmp);
}
}
#line 413 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
struct sk_buff *ldv_skb_copy_275(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 416
  ldv_check_alloc_flags(flags);
#line 417
  tmp = ldv_undef_ptr();
#line 417
  return ((struct sk_buff *)tmp);
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_276(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 423
  ldv_check_alloc_flags(flags);
#line 424
  tmp = ldv_undef_ptr();
#line 424
  return ((struct sk_buff *)tmp);
}
}
#line 427 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_277(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 430
  ldv_check_alloc_flags(flags);
#line 431
  tmp = ldv_undef_ptr();
#line 431
  return ((struct sk_buff *)tmp);
}
}
#line 434 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_278(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 438
  tmp = ldv_undef_ptr();
#line 438
  return ((struct sk_buff *)tmp);
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
int ldv_pskb_expand_head_279(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 444
  ldv_check_alloc_flags(flags);
#line 445
  tmp = ldv_undef_ptr();
#line 445
  return ((int )((long )tmp));
}
}
#line 448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
int ldv_pskb_expand_head_280(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 451
  ldv_check_alloc_flags(flags);
#line 452
  tmp = ldv_undef_ptr();
#line 452
  return ((int )((long )tmp));
}
}
#line 455 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-bus.o.c.prepared"
struct sk_buff *ldv_skb_clone_281(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 459
  tmp = ldv_undef_ptr();
#line 459
  return ((struct sk_buff *)tmp);
}
}
#line 926 "include/linux/wait.h"
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_301(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_303(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_302(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_305(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_304(struct workqueue_struct *ldv_func_arg1 ) ;
#line 421 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_311(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_319(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_327(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_321(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_317(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_325(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_326(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_322(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_323(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_324(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 522 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
int saa7164_cmd_send(struct saa7164_dev *dev , u8 id , enum tmComResCmd command ,
                     u16 controlselector , u16 size , void *buf ) ;
#line 525
void saa7164_cmd_signal(struct saa7164_dev *dev , u8 seqno ) ;
#line 26 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
static int saa7164_cmd_alloc_seqno(struct saa7164_dev *dev ) 
{ 
  int i ;
  int ret ;

  {
#line 28
  ret = -1;
#line 30
  mutex_lock_nested(& dev->lock, 0U);
#line 31
  i = 0;
#line 31
  goto ldv_51796;
  ldv_51795: ;
#line 32
  if (dev->cmds[i].inuse == 0U) {
#line 33
    dev->cmds[i].inuse = 1U;
#line 34
    dev->cmds[i].signalled = 0U;
#line 35
    dev->cmds[i].timeout = 0U;
#line 36
    ret = (int )dev->cmds[i].seqno;
#line 37
    goto ldv_51794;
  } else {

  }
#line 31
  i = i + 1;
  ldv_51796: ;
#line 31
  if (i <= 255) {
#line 33
    goto ldv_51795;
  } else {

  }
  ldv_51794: 
#line 40
  mutex_unlock(& dev->lock);
#line 42
  return (ret);
}
}
#line 45 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
static void saa7164_cmd_free_seqno(struct saa7164_dev *dev , u8 seqno ) 
{ 


  {
#line 47
  mutex_lock_nested(& dev->lock, 0U);
#line 48
  if (dev->cmds[(int )seqno].inuse == 1U && (int )dev->cmds[(int )seqno].seqno == (int )seqno) {
#line 50
    dev->cmds[(int )seqno].inuse = 0U;
#line 51
    dev->cmds[(int )seqno].signalled = 0U;
#line 52
    dev->cmds[(int )seqno].timeout = 0U;
  } else {

  }
#line 54
  mutex_unlock(& dev->lock);
#line 55
  return;
}
}
#line 57 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
static void saa7164_cmd_timeout_seqno(struct saa7164_dev *dev , u8 seqno ) 
{ 


  {
#line 59
  mutex_lock_nested(& dev->lock, 0U);
#line 60
  if (dev->cmds[(int )seqno].inuse == 1U && (int )dev->cmds[(int )seqno].seqno == (int )seqno) {
#line 62
    dev->cmds[(int )seqno].timeout = 1U;
  } else {

  }
#line 64
  mutex_unlock(& dev->lock);
#line 65
  return;
}
}
#line 67 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
static u32 saa7164_cmd_timeout_get(struct saa7164_dev *dev , u8 seqno ) 
{ 
  int ret ;

  {
#line 69
  ret = 0;
#line 71
  mutex_lock_nested(& dev->lock, 0U);
#line 72
  if (dev->cmds[(int )seqno].inuse == 1U && (int )dev->cmds[(int )seqno].seqno == (int )seqno) {
#line 74
    ret = (int )dev->cmds[(int )seqno].timeout;
  } else {

  }
#line 76
  mutex_unlock(& dev->lock);
#line 78
  return ((u32 )ret);
}
}
#line 83 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
int saa7164_irq_dequeue(struct saa7164_dev *dev ) 
{ 
  int ret ;
  int i ;
  u32 timeout ;
  wait_queue_head_t *q ;
  u8 tmp[512U] ;
  struct tmComResInfo tRsp ;
  int tmp___0 ;

  {
#line 85
  ret = 0;
#line 85
  i = 0;
#line 87
  q = (wait_queue_head_t *)0;
#line 89
  if ((saa_debug & 64U) != 0U) {
#line 89
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_irq_dequeue");
  } else {

  }
  ldv_51821: 
#line 95
  tRsp.id = 0U;
#line 95
  tRsp.flags = 0U;
#line 95
  tRsp.size = 0U;
#line 95
  tRsp.command = 0U;
#line 95
  tRsp.controlselector = 0U;
#line 95
  tRsp.seqno = 0U;
#line 96
  ret = saa7164_bus_get(dev, & tRsp, (void *)0, 1);
#line 97
  if (ret != 0) {
#line 98
    goto ldv_51820;
  } else {

  }
#line 100
  q = & dev->cmds[(int )tRsp.seqno].wait;
#line 101
  timeout = saa7164_cmd_timeout_get(dev, (int )tRsp.seqno);
#line 102
  if ((saa_debug & 64U) != 0U) {
#line 102
    printk("\017%s: %s() timeout = %d\n", (char *)(& dev->name), "saa7164_irq_dequeue",
           timeout);
  } else {

  }
#line 103
  if (timeout == 0U) {
#line 104
    if ((saa_debug & 64U) != 0U) {
#line 104
      printk("\017%s: %s() signalled seqno(%d) (for dequeue)\n", (char *)(& dev->name),
             "saa7164_irq_dequeue", (int )tRsp.seqno);
    } else {

    }
#line 107
    dev->cmds[(int )tRsp.seqno].signalled = 1U;
#line 108
    __wake_up(q, 3U, 1, (void *)0);
  } else {
#line 110
    printk("\v%s() found timed out command on the bus\n", "saa7164_irq_dequeue");
#line 115
    ret = saa7164_bus_get(dev, & tRsp, (void *)(& tmp), 0);
#line 116
    printk("\v%s() ret = %x\n", "saa7164_irq_dequeue", ret);
#line 117
    if (ret == 34) {
#line 119
      return (0);
    } else {

    }
#line 121
    if (ret != 0) {
#line 122
      return (ret);
    } else {

    }
  }
#line 128
  tmp___0 = i;
#line 128
  i = i + 1;
#line 128
  if (tmp___0 <= 31) {
#line 130
    goto ldv_51821;
  } else {

  }
  ldv_51820: ;
#line 130
  return (ret);
}
}
#line 135 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
static int saa7164_cmd_dequeue(struct saa7164_dev *dev ) 
{ 
  int loop ;
  int ret ;
  u32 timeout ;
  wait_queue_head_t *q ;
  u8 tmp[512U] ;
  struct tmComResInfo tRsp ;

  {
#line 137
  loop = 1;
#line 140
  q = (wait_queue_head_t *)0;
#line 142
  if ((saa_debug & 64U) != 0U) {
#line 142
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_cmd_dequeue");
  } else {

  }
#line 144
  goto ldv_51832;
  ldv_51833: 
#line 146
  tRsp.id = 0U;
#line 146
  tRsp.flags = 0U;
#line 146
  tRsp.size = 0U;
#line 146
  tRsp.command = 0U;
#line 146
  tRsp.controlselector = 0U;
#line 146
  tRsp.seqno = 0U;
#line 147
  ret = saa7164_bus_get(dev, & tRsp, (void *)0, 1);
#line 148
  if (ret == 34) {
#line 149
    return (0);
  } else {

  }
#line 151
  if (ret != 0) {
#line 152
    return (ret);
  } else {

  }
#line 154
  q = & dev->cmds[(int )tRsp.seqno].wait;
#line 155
  timeout = saa7164_cmd_timeout_get(dev, (int )tRsp.seqno);
#line 156
  if ((saa_debug & 64U) != 0U) {
#line 156
    printk("\017%s: %s() timeout = %d\n", (char *)(& dev->name), "saa7164_cmd_dequeue",
           timeout);
  } else {

  }
#line 157
  if (timeout != 0U) {
#line 158
    printk("\vfound timed out command on the bus\n");
#line 161
    ret = saa7164_bus_get(dev, & tRsp, (void *)(& tmp), 0);
#line 162
    printk("\vret = %x\n", ret);
#line 163
    if (ret == 34) {
#line 165
      return (0);
    } else {

    }
#line 167
    if (ret != 0) {
#line 168
      return (ret);
    } else {

    }
#line 170
    if (((int )tRsp.flags & 16) != 0) {
#line 171
      printk("\vsplit response\n");
    } else {
#line 173
      saa7164_cmd_free_seqno(dev, (int )tRsp.seqno);
    }
#line 175
    printk("\v timeout continue\n");
#line 176
    goto ldv_51832;
  } else {

  }
#line 179
  if ((saa_debug & 64U) != 0U) {
#line 179
    printk("\017%s: %s() signalled seqno(%d) (for dequeue)\n", (char *)(& dev->name),
           "saa7164_cmd_dequeue", (int )tRsp.seqno);
  } else {

  }
#line 181
  dev->cmds[(int )tRsp.seqno].signalled = 1U;
#line 182
  __wake_up(q, 3U, 1, (void *)0);
#line 183
  return (0);
  ldv_51832: ;
#line 144
  if (loop != 0) {
#line 146
    goto ldv_51833;
  } else {

  }

#line 186
  return (0);
}
}
#line 189 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
static int saa7164_cmd_set(struct saa7164_dev *dev , struct tmComResInfo *msg , void *buf ) 
{ 
  struct tmComResBusInfo *bus ;
  u8 cmd_sent ;
  u16 size ;
  u16 idx ;
  u32 cmds ;
  void *tmp ;
  int ret ;

  {
#line 192
  bus = & dev->bus;
#line 197
  ret = -1;
#line 199
  if ((unsigned long )msg == (unsigned long )((struct tmComResInfo *)0)) {
#line 200
    printk("\v%s() !msg\n", "saa7164_cmd_set");
#line 201
    return (9);
  } else {

  }
#line 204
  mutex_lock_nested(& dev->cmds[(int )msg->id].lock, 0U);
#line 206
  size = msg->size;
#line 207
  idx = 0U;
#line 208
  cmds = (u32 )((int )size / (int )bus->m_wMaxReqSize);
#line 209
  if ((unsigned int )((int )size % (int )bus->m_wMaxReqSize) == 0U) {
#line 210
    cmds = cmds - 1U;
  } else {

  }
#line 212
  cmd_sent = 0U;
#line 215
  idx = 0U;
#line 215
  goto ldv_51850;
  ldv_51849: 
#line 217
  msg->flags = (u8 )((unsigned int )msg->flags | 16U);
#line 218
  msg->size = bus->m_wMaxReqSize;
#line 219
  tmp = buf + (unsigned long )((int )idx * (int )bus->m_wMaxReqSize);
#line 221
  ret = saa7164_bus_set(dev, msg, tmp);
#line 222
  if (ret != 0) {
#line 223
    printk("\v%s() set failed %d\n", "saa7164_cmd_set", ret);
#line 225
    if ((unsigned int )cmd_sent != 0U) {
#line 226
      ret = 21;
#line 227
      goto out;
    } else {

    }
#line 229
    ret = 32;
#line 230
    goto out;
  } else {

  }
#line 232
  cmd_sent = 1U;
#line 215
  idx = (u16 )((int )idx + 1);
  ldv_51850: ;
#line 215
  if ((u32 )idx < cmds) {
#line 217
    goto ldv_51849;
  } else {

  }

#line 236
  if ((unsigned int )idx != 0U) {
#line 237
    msg->flags = (unsigned int )msg->flags & 239U;
  } else {

  }
#line 239
  msg->size = (int )size - (int )bus->m_wMaxReqSize * (int )idx;
#line 241
  ret = saa7164_bus_set(dev, msg, buf + (unsigned long )((int )idx * (int )bus->m_wMaxReqSize));
#line 242
  if (ret != 0) {
#line 243
    printk("\v%s() set last failed %d\n", "saa7164_cmd_set", ret);
#line 245
    if ((unsigned int )cmd_sent != 0U) {
#line 246
      ret = 21;
#line 247
      goto out;
    } else {

    }
#line 249
    ret = 32;
#line 250
    goto out;
  } else {

  }
#line 252
  ret = 0;
  out: 
#line 255
  mutex_unlock(& dev->cmds[(int )msg->id].lock);
#line 256
  return (ret);
}
}
#line 262 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
static int saa7164_cmd_wait(struct saa7164_dev *dev , u8 seqno ) 
{ 
  wait_queue_head_t *q ;
  int ret ;
  unsigned long stamp ;
  int r ;
  long __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  bool __cond ;
  bool __cond___0 ;

  {
#line 264
  q = (wait_queue_head_t *)0;
#line 265
  ret = 50;
#line 269
  if (saa_debug > 3U) {
#line 270
    saa7164_bus_dump(dev);
  } else {

  }
#line 272
  if ((saa_debug & 64U) != 0U) {
#line 272
    printk("\017%s: %s(seqno=%d)\n", (char *)(& dev->name), "saa7164_cmd_wait", (int )seqno);
  } else {

  }
#line 274
  mutex_lock_nested(& dev->lock, 0U);
#line 275
  if (dev->cmds[(int )seqno].inuse == 1U && (int )dev->cmds[(int )seqno].seqno == (int )seqno) {
#line 277
    q = & dev->cmds[(int )seqno].wait;
  } else {

  }
#line 279
  mutex_unlock(& dev->lock);
#line 281
  if ((unsigned long )q != (unsigned long )((wait_queue_head_t *)0)) {
#line 283
    if (dev->cmds[(int )seqno].signalled == 0U) {
#line 284
      stamp = jiffies;
#line 285
      if ((saa_debug & 64U) != 0U) {
#line 285
        printk("\017%s: %s(seqno=%d) Waiting (signalled=%d)\n", (char *)(& dev->name),
               "saa7164_cmd_wait", (int )seqno, dev->cmds[(int )seqno].signalled);
      } else {

      }
#line 296
      __ret = (long )(waitsecs * 250U);
#line 296
      __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c",
                    297, 0);
#line 296
      __cond___0 = dev->cmds[(int )seqno].signalled != 0U;
#line 296
      if ((int )__cond___0 && __ret == 0L) {
#line 296
        __ret = 1L;
      } else {

      }
#line 296
      if (((int )__cond___0 || __ret == 0L) == 0) {
#line 296
        __ret___0 = (long )(waitsecs * 250U);
#line 296
        INIT_LIST_HEAD(& __wait.task_list);
#line 296
        __wait.flags = 0U;
        ldv_51871: 
#line 296
        tmp = prepare_to_wait_event(q, & __wait, 2);
#line 296
        __int = tmp;
#line 296
        __cond = dev->cmds[(int )seqno].signalled != 0U;
#line 296
        if ((int )__cond && __ret___0 == 0L) {
#line 296
          __ret___0 = 1L;
        } else {

        }
#line 296
        if (((int )__cond || __ret___0 == 0L) != 0) {
#line 296
          goto ldv_51870;
        } else {

        }
#line 296
        __ret___0 = schedule_timeout(__ret___0);
#line 296
        goto ldv_51871;
        ldv_51870: 
#line 296
        finish_wait(q, & __wait);
#line 296
        __ret = __ret___0;
      } else {

      }
#line 298
      r = (long )((unsigned long )jiffies - ((unsigned long )(waitsecs * 250U) + stamp)) < 0L;
#line 299
      if (r != 0) {
#line 300
        ret = 0;
      } else {
#line 302
        saa7164_cmd_timeout_seqno(dev, (int )seqno);
      }
#line 304
      if ((saa_debug & 64U) != 0U) {
#line 304
        printk("\017%s: %s(seqno=%d) Waiting res = %d (signalled=%d)\n", (char *)(& dev->name),
               "saa7164_cmd_wait", (int )seqno, r, dev->cmds[(int )seqno].signalled);
      } else {

      }
    } else {
#line 308
      ret = 0;
    }
  } else {
#line 310
    printk("\v%s(seqno=%d) seqno is invalid\n", "saa7164_cmd_wait", (int )seqno);
  }
#line 313
  return (ret);
}
}
#line 316 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
void saa7164_cmd_signal(struct saa7164_dev *dev , u8 seqno ) 
{ 
  int i ;

  {
#line 319
  if ((saa_debug & 64U) != 0U) {
#line 319
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_cmd_signal");
  } else {

  }
#line 321
  mutex_lock_nested(& dev->lock, 0U);
#line 322
  i = 0;
#line 322
  goto ldv_51887;
  ldv_51886: ;
#line 323
  if (dev->cmds[i].inuse == 1U) {
#line 324
    if ((saa_debug & 64U) != 0U) {
#line 324
      printk("\017%s: seqno %d inuse, sig = %d, t/out = %d\n", (char *)(& dev->name),
             (int )dev->cmds[i].seqno, dev->cmds[i].signalled, dev->cmds[i].timeout);
    } else {

    }
  } else {

  }
#line 322
  i = i + 1;
  ldv_51887: ;
#line 322
  if (i <= 255) {
#line 324
    goto ldv_51886;
  } else {

  }
#line 332
  i = 0;
#line 332
  goto ldv_51890;
  ldv_51889: ;
#line 333
  if (dev->cmds[i].inuse == 1U && ((i == 0 || dev->cmds[i].signalled != 0U) || dev->cmds[i].timeout != 0U)) {
#line 335
    if ((saa_debug & 64U) != 0U) {
#line 335
      printk("\017%s: %s(seqno=%d) calling wake_up\n", (char *)(& dev->name), "saa7164_cmd_signal",
             i);
    } else {

    }
#line 337
    dev->cmds[i].signalled = 1U;
#line 338
    __wake_up(& dev->cmds[i].wait, 3U, 1, (void *)0);
  } else {

  }
#line 332
  i = i + 1;
  ldv_51890: ;
#line 332
  if (i <= 255) {
#line 334
    goto ldv_51889;
  } else {

  }
#line 341
  mutex_unlock(& dev->lock);
#line 342
  return;
}
}
#line 344 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.c"
int saa7164_cmd_send(struct saa7164_dev *dev , u8 id , enum tmComResCmd command ,
                     u16 controlselector , u16 size , void *buf ) 
{ 
  struct tmComResInfo command_t ;
  struct tmComResInfo *pcommand_t ;
  struct tmComResInfo response_t ;
  struct tmComResInfo *presponse_t ;
  u8 errdata[256U] ;
  u16 resp_dsize ;
  u16 data_recd ;
  u32 loop ;
  int ret ;
  int safety ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 354
  safety = 0;
#line 356
  if ((saa_debug & 64U) != 0U) {
#line 356
    tmp = saa7164_unitid_name(dev, (int )id);
#line 356
    printk("\017%s: %s(unitid = %s (%d) , command = 0x%x, sel = 0x%x)\n", (char *)(& dev->name),
           "saa7164_cmd_send", tmp, (int )id, (unsigned int )command, (int )controlselector);
  } else {

  }
#line 360
  if ((unsigned int )size == 0U || (unsigned long )buf == (unsigned long )((void *)0)) {
#line 361
    printk("\v%s() Invalid param\n", "saa7164_cmd_send");
#line 362
    return (9);
  } else {

  }
#line 366
  memset((void *)(& command_t), 0, 11UL);
#line 367
  memset((void *)(& response_t), 0, 11UL);
#line 368
  pcommand_t = & command_t;
#line 369
  presponse_t = & response_t;
#line 370
  command_t.id = id;
#line 371
  command_t.command = (u32 )command;
#line 372
  command_t.controlselector = controlselector;
#line 373
  command_t.size = size;
#line 376
  ret = saa7164_cmd_alloc_seqno(dev);
#line 377
  if (ret < 0) {
#line 378
    printk("\v%s() No free sequences\n", "saa7164_cmd_send");
#line 379
    ret = 12;
#line 380
    goto out;
  } else {

  }
#line 383
  command_t.seqno = (unsigned char )ret;
#line 386
  resp_dsize = size;
#line 387
  pcommand_t->size = size;
#line 389
  if ((saa_debug & 64U) != 0U) {
#line 389
    printk("\017%s: %s() pcommand_t.seqno = %d\n", (char *)(& dev->name), "saa7164_cmd_send",
           (int )pcommand_t->seqno);
  } else {

  }
#line 392
  if ((saa_debug & 64U) != 0U) {
#line 392
    printk("\017%s: %s() pcommand_t.size = %d\n", (char *)(& dev->name), "saa7164_cmd_send",
           (int )pcommand_t->size);
  } else {

  }
#line 395
  ret = saa7164_cmd_set(dev, pcommand_t, buf);
#line 396
  if (ret != 0) {
#line 397
    printk("\v%s() set command failed %d\n", "saa7164_cmd_send", ret);
#line 399
    if (ret != 21) {
#line 400
      saa7164_cmd_free_seqno(dev, (int )pcommand_t->seqno);
    } else {
#line 404
      saa7164_cmd_timeout_seqno(dev, (int )pcommand_t->seqno);
    }
#line 406
    goto out;
  } else {

  }
#line 410
  data_recd = 0U;
#line 411
  loop = 1U;
#line 412
  goto ldv_51912;
  ldv_51922: ;
#line 413
  if ((saa_debug & 64U) != 0U) {
#line 413
    printk("\017%s: %s() loop\n", (char *)(& dev->name), "saa7164_cmd_send");
  } else {

  }
#line 415
  ret = saa7164_cmd_wait(dev, (int )pcommand_t->seqno);
#line 416
  if ((saa_debug & 64U) != 0U) {
#line 416
    printk("\017%s: %s() loop ret = %d\n", (char *)(& dev->name), "saa7164_cmd_send",
           ret);
  } else {

  }
#line 420
  if (ret == 50) {
#line 421
    printk("\vEvent timed out\n");
#line 422
    saa7164_cmd_timeout_seqno(dev, (int )pcommand_t->seqno);
#line 423
    return (ret);
  } else {

  }
#line 426
  if (ret != 0) {
#line 427
    printk("\vspurious error\n");
#line 428
    return (ret);
  } else {

  }
#line 432
  ret = saa7164_bus_get(dev, presponse_t, (void *)0, 1);
#line 433
  if (ret == 34) {
#line 434
    if ((saa_debug & 4U) != 0U) {
#line 434
      printk("\017%s: %s() SAA_ERR_EMPTY\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
#line 435
    goto ldv_51912;
  } else {

  }
#line 437
  if (ret != 0) {
#line 438
    printk("\vpeek failed\n");
#line 439
    return (ret);
  } else {

  }
#line 442
  if ((saa_debug & 64U) != 0U) {
#line 442
    printk("\017%s: %s() presponse_t->seqno = %d\n", (char *)(& dev->name), "saa7164_cmd_send",
           (int )presponse_t->seqno);
  } else {

  }
#line 445
  if ((saa_debug & 64U) != 0U) {
#line 445
    printk("\017%s: %s() presponse_t->flags = 0x%x\n", (char *)(& dev->name), "saa7164_cmd_send",
           (int )presponse_t->flags);
  } else {

  }
#line 448
  if ((saa_debug & 64U) != 0U) {
#line 448
    printk("\017%s: %s() presponse_t->size = %d\n", (char *)(& dev->name), "saa7164_cmd_send",
           (int )presponse_t->size);
  } else {

  }
#line 452
  if ((int )presponse_t->seqno != (int )pcommand_t->seqno) {
#line 454
    if ((saa_debug & 64U) != 0U) {
#line 454
      printk("\017%s: wrong event: seqno = %d, expected seqno = %d, will dequeue regardless\n",
             (char *)(& dev->name), (int )presponse_t->seqno, (int )pcommand_t->seqno);
    } else {

    }
#line 460
    ret = saa7164_cmd_dequeue(dev);
#line 461
    if (ret != 0) {
#line 462
      printk("\vdequeue failed, ret = %d\n", ret);
#line 464
      tmp___0 = safety;
#line 464
      safety = safety + 1;
#line 464
      if (tmp___0 > 16) {
#line 465
        printk("\vdequeue exceeded, safety exit\n");
#line 467
        return (21);
      } else {

      }
    } else {

    }
#line 471
    goto ldv_51912;
  } else {

  }
#line 474
  if ((int )presponse_t->flags & 1) {
#line 476
    memset((void *)(& errdata), 0, 256UL);
#line 478
    ret = saa7164_bus_get(dev, presponse_t, (void *)(& errdata), 0);
#line 479
    if (ret != 0) {
#line 480
      printk("\vget error(2)\n");
#line 481
      return (ret);
    } else {

    }
#line 484
    saa7164_cmd_free_seqno(dev, (int )pcommand_t->seqno);
#line 486
    if ((saa_debug & 64U) != 0U) {
#line 486
      printk("\017%s: %s() errdata %02x%02x%02x%02x\n", (char *)(& dev->name), "saa7164_cmd_send",
             (int )errdata[0], (int )errdata[1], (int )errdata[2], (int )errdata[3]);
    } else {

    }
#line 491
    if ((saa_debug & 64U) != 0U) {
#line 491
      printk("\017%s: %s() cmd, error code  = 0x%x\n", (char *)(& dev->name), "saa7164_cmd_send",
             (int )errdata[0]);
    } else {

    }
#line 494
    switch ((int )errdata[0]) {
    case 1: ;
#line 496
    if ((saa_debug & 64U) != 0U) {
#line 496
      printk("\017%s: %s() INVALID_COMMAND\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
#line 498
    ret = 62;
#line 499
    goto ldv_51914;
    case 3: ;
#line 501
    if ((saa_debug & 64U) != 0U) {
#line 501
      printk("\017%s: %s() INVALID_DATA\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
#line 503
    ret = 9;
#line 504
    goto ldv_51914;
    case 4: ;
#line 506
    if ((saa_debug & 64U) != 0U) {
#line 506
      printk("\017%s: %s() TIMEOUT\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
#line 507
    ret = 31;
#line 508
    goto ldv_51914;
    case 5: ;
#line 510
    if ((saa_debug & 64U) != 0U) {
#line 510
      printk("\017%s: %s() NAK\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
#line 511
    ret = 89;
#line 512
    goto ldv_51914;
    case 0: ;
    case 2: ;
#line 515
    if ((saa_debug & 64U) != 0U) {
#line 515
      printk("\017%s: %s() UNKNOWN OR INVALID CONTROL\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
    default: ;
#line 519
    if ((saa_debug & 64U) != 0U) {
#line 519
      printk("\017%s: %s() UNKNOWN\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
#line 520
    ret = 19;
    }
    ldv_51914: 
#line 524
    tmp___1 = saa7164_cmd_dequeue(dev);
#line 524
    if (tmp___1 != 0) {
#line 525
      printk("\vdequeue(2) failed\n");
    } else {

    }
#line 527
    return (ret);
  } else {

  }
#line 531
  if (((((int )presponse_t->id != (int )pcommand_t->id || presponse_t->command != pcommand_t->command) || (int )presponse_t->controlselector != (int )pcommand_t->controlselector) || ((int )resp_dsize - (int )data_recd != (int )presponse_t->size && ((int )presponse_t->flags & 16) == 0)) || (int )resp_dsize - (int )data_recd < (int )presponse_t->size) {
#line 540
    if ((saa_debug & 64U) != 0U) {
#line 540
      printk("\017%s: %s() Invalid\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
#line 541
    ret = saa7164_bus_get(dev, presponse_t, (void *)0, 0);
#line 542
    if (ret != 0) {
#line 543
      printk("\vget failed\n");
#line 544
      return (ret);
    } else {

    }
#line 548
    tmp___2 = saa7164_cmd_dequeue(dev);
#line 548
    if (tmp___2 != 0) {
#line 549
      printk("\vdequeue(3) failed\n");
    } else {

    }
#line 550
    goto ldv_51912;
  } else {

  }
#line 554
  ret = saa7164_bus_get(dev, presponse_t, buf + (unsigned long )data_recd, 0);
#line 555
  if (ret != 0) {
#line 556
    printk("\vget failed\n");
#line 557
    return (ret);
  } else {

  }
#line 560
  data_recd = (int )presponse_t->size + (int )data_recd;
#line 561
  if ((int )resp_dsize == (int )data_recd) {
#line 562
    if ((saa_debug & 64U) != 0U) {
#line 562
      printk("\017%s: %s() Resp recd\n", (char *)(& dev->name), "saa7164_cmd_send");
    } else {

    }
#line 563
    goto ldv_51921;
  } else {

  }
#line 567
  tmp___3 = saa7164_cmd_dequeue(dev);
#line 567
  if (tmp___3 != 0) {
#line 568
    printk("\vdequeue(3) failed\n");
  } else {

  }
#line 570
  goto ldv_51912;
  ldv_51912: ;
#line 412
  if (loop != 0U) {
#line 414
    goto ldv_51922;
  } else {

  }
  ldv_51921: 
#line 575
  saa7164_cmd_free_seqno(dev, (int )pcommand_t->seqno);
#line 579
  if ((saa_debug & 64U) != 0U) {
#line 579
    printk("\017%s: %s() Calling dequeue then exit\n", (char *)(& dev->name), "saa7164_cmd_send");
  } else {

  }
#line 582
  tmp___4 = saa7164_cmd_dequeue(dev);
#line 582
  if (tmp___4 != 0) {
#line 583
    printk("\vdequeue(4) failed\n");
  } else {

  }
#line 585
  ret = 0;
  out: ;
#line 587
  return (ret);
}
}
#line 256 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
bool ldv_queue_work_on_301(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 260
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 260
  ldv_func_res = tmp;
#line 262
  activate_work_3(ldv_func_arg3, 2);
#line 264
  return (ldv_func_res);
}
}
#line 267 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
bool ldv_queue_delayed_work_on_302(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 271
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 271
  ldv_func_res = tmp;
#line 273
  activate_work_3(& ldv_func_arg3->work, 2);
#line 275
  return (ldv_func_res);
}
}
#line 278 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
bool ldv_queue_work_on_303(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 282
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 282
  ldv_func_res = tmp;
#line 284
  activate_work_3(ldv_func_arg3, 2);
#line 286
  return (ldv_func_res);
}
}
#line 289 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
void ldv_flush_workqueue_304(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 292
  flush_workqueue(ldv_func_arg1);
#line 294
  call_and_disable_all_3(2);
#line 295
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
bool ldv_queue_delayed_work_on_305(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 301
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 301
  ldv_func_res = tmp;
#line 303
  activate_work_3(& ldv_func_arg3->work, 2);
#line 305
  return (ldv_func_res);
}
}
#line 343 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
void *ldv_kmem_cache_alloc_311(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 346
  ldv_check_alloc_flags(flags);
#line 347
  tmp = ldv_undef_ptr();
#line 347
  return (tmp);
}
}
#line 385 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
int ldv_pskb_expand_head_317(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 388
  ldv_check_alloc_flags(flags);
#line 389
  tmp = ldv_undef_ptr();
#line 389
  return ((int )((long )tmp));
}
}
#line 399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
struct sk_buff *ldv_skb_clone_319(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 402
  ldv_check_alloc_flags(flags);
#line 403
  tmp = ldv_undef_ptr();
#line 403
  return ((struct sk_buff *)tmp);
}
}
#line 413 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
struct sk_buff *ldv_skb_copy_321(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 416
  ldv_check_alloc_flags(flags);
#line 417
  tmp = ldv_undef_ptr();
#line 417
  return ((struct sk_buff *)tmp);
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_322(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 423
  ldv_check_alloc_flags(flags);
#line 424
  tmp = ldv_undef_ptr();
#line 424
  return ((struct sk_buff *)tmp);
}
}
#line 427 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_323(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 430
  ldv_check_alloc_flags(flags);
#line 431
  tmp = ldv_undef_ptr();
#line 431
  return ((struct sk_buff *)tmp);
}
}
#line 434 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_324(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 438
  tmp = ldv_undef_ptr();
#line 438
  return ((struct sk_buff *)tmp);
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
int ldv_pskb_expand_head_325(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 444
  ldv_check_alloc_flags(flags);
#line 445
  tmp = ldv_undef_ptr();
#line 445
  return ((int )((long )tmp));
}
}
#line 448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
int ldv_pskb_expand_head_326(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 451
  ldv_check_alloc_flags(flags);
#line 452
  tmp = ldv_undef_ptr();
#line 452
  return ((int )((long )tmp));
}
}
#line 455 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-cmd.o.c.prepared"
struct sk_buff *ldv_skb_clone_327(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 459
  tmp = ldv_undef_ptr();
#line 459
  return ((struct sk_buff *)tmp);
}
}
#line 431 "include/linux/printk.h"
extern void print_hex_dump(char const   * , char const   * , int  , int  , int  ,
                           void const   * , size_t  , bool  ) ;
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_347(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_349(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_348(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_351(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_350(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_357(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_365(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_373(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_367(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_363(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_371(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_372(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_368(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_369(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_370(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 542 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
int saa7164_api_initialize_dif(struct saa7164_port *port ) ;
#line 543
int saa7164_api_configure_dif(struct saa7164_port *port , u32 std ) ;
#line 544
int saa7164_api_set_encoder(struct saa7164_port *port ) ;
#line 545
int saa7164_api_get_encoder(struct saa7164_port *port ) ;
#line 546
int saa7164_api_set_aspect_ratio(struct saa7164_port *port ) ;
#line 547
int saa7164_api_set_usercontrol(struct saa7164_port *port , u8 ctl ) ;
#line 548
int saa7164_api_get_usercontrol(struct saa7164_port *port , u8 ctl ) ;
#line 549
int saa7164_api_set_videomux(struct saa7164_port *port ) ;
#line 550
int saa7164_api_audio_mute(struct saa7164_port *port , int mute ) ;
#line 551
int saa7164_api_set_audio_volume(struct saa7164_port *port , s8 level ) ;
#line 552
int saa7164_api_set_audio_std(struct saa7164_port *port ) ;
#line 553
int saa7164_api_set_audio_detection(struct saa7164_port *port , int autodetect ) ;
#line 554
int saa7164_api_get_videomux(struct saa7164_port *port ) ;
#line 555
int saa7164_api_set_vbi_format(struct saa7164_port *port ) ;
#line 27 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_get_load_info(struct saa7164_dev *dev , struct tmFwInfoStruct *i ) 
{ 
  int ret ;

  {
#line 31
  if ((saa_debug & 8192U) == 0U) {
#line 32
    return (0);
  } else {

  }
#line 34
  if ((saa_debug & 32U) != 0U) {
#line 34
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_api_get_load_info");
  } else {

  }
#line 36
  i->deviceinst = 0U;
#line 37
  i->devicespec = 0U;
#line 38
  i->mode = 0U;
#line 39
  i->status = 0U;
#line 41
  ret = saa7164_cmd_send(dev, 0, 129, 8, 32, (void *)i);
#line 43
  if (ret != 0) {
#line 44
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_load_info", ret);
  } else {

  }
#line 46
  printk("\016saa7164[%d]-CPU: %d percent", dev->nr, i->CPULoad);
#line 48
  return (ret);
}
}
#line 51 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_collect_debug(struct saa7164_dev *dev ) 
{ 
  struct tmComResDebugGetData d ;
  u8 more ;
  int ret ;
  u8 tmp ;

  {
#line 54
  more = 255U;
#line 57
  if ((saa_debug & 32U) != 0U) {
#line 57
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_api_collect_debug");
  } else {

  }
#line 59
  goto ldv_51804;
  ldv_51803: 
#line 61
  memset((void *)(& d), 0, 260UL);
#line 63
  ret = saa7164_cmd_send(dev, 0, 129, 12, 260, (void *)(& d));
#line 65
  if (ret != 0) {
#line 66
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_collect_debug", ret);
  } else {

  }
#line 69
  if (d.dwResult != 0U) {
#line 70
    goto ldv_51802;
  } else {

  }
#line 72
  printk("\016saa7164[%d]-FWMSG: %s", dev->nr, (u8 *)(& d.ucDebugData));
  ldv_51804: 
#line 59
  tmp = more;
#line 59
  more = (u8 )((int )more - 1);
#line 59
  if ((unsigned int )tmp != 0U) {
#line 61
    goto ldv_51803;
  } else {

  }
  ldv_51802: ;
#line 76
  return (0);
}
}
#line 79 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_debug(struct saa7164_dev *dev , u8 level ) 
{ 
  struct tmComResDebugSetLevel lvl ;
  int ret ;

  {
#line 84
  if ((saa_debug & 32U) != 0U) {
#line 84
    printk("\017%s: %s(level=%d)\n", (char *)(& dev->name), "saa7164_api_set_debug",
           (int )level);
  } else {

  }
#line 87
  ret = saa7164_cmd_send(dev, 0, 129, 11, 4, (void *)(& lvl));
#line 89
  if (ret != 0) {
#line 90
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_debug", ret);
  } else {

  }
#line 92
  if ((saa_debug & 32U) != 0U) {
#line 92
    printk("\017%s: %s() Was %d\n", (char *)(& dev->name), "saa7164_api_set_debug",
           lvl.dwDebugLevel);
  } else {

  }
#line 94
  lvl.dwDebugLevel = (u32 )level;
#line 97
  ret = saa7164_cmd_send(dev, 0, 1, 11, 4, (void *)(& lvl));
#line 99
  if (ret != 0) {
#line 100
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_debug", ret);
  } else {

  }
#line 102
  return (ret);
}
}
#line 105 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_vbi_format(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct tmComResProbeCommit fmt ;
  struct tmComResProbeCommit rsp ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 107
  dev = port->dev;
#line 111
  if ((saa_debug & 32U) != 0U) {
#line 111
    printk("\017%s: %s(nr=%d, unitid=0x%x)\n", (char *)(& dev->name), "saa7164_api_set_vbi_format",
           port->nr, (int )port->hwcfg.unitid);
  } else {

  }
#line 114
  fmt.bmHint = 0U;
#line 115
  fmt.bFormatIndex = 1U;
#line 116
  fmt.bFrameIndex = 1U;
#line 119
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.unitid, 1, 1, 4, (void *)(& fmt));
#line 121
  if (ret != 0) {
#line 122
    printk("\v%s() set error, ret = 0x%x\n", "saa7164_api_set_vbi_format", ret);
  } else {

  }
#line 125
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.unitid, 129, 1, 4, (void *)(& rsp));
#line 127
  if (ret != 0) {
#line 128
    printk("\v%s() get error, ret = 0x%x\n", "saa7164_api_set_vbi_format", ret);
  } else {
#line 131
    tmp___0 = memcmp((void const   *)(& fmt), (void const   *)(& rsp), 4UL);
#line 131
    if (tmp___0 == 0) {
#line 132
      if ((saa_debug & 32U) != 0U) {
#line 132
        printk("\017%s: SET/PROBE Verified\n", (char *)(& dev->name));
      } else {

      }
#line 135
      ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.unitid, 1, 2, 4, (void *)(& fmt));
#line 137
      if (ret != 0) {
#line 138
        printk("\v%s() commit error, ret = 0x%x\n", "saa7164_api_set_vbi_format",
               ret);
      } else {

      }
#line 141
      ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.unitid, 129, 2, 4, (void *)(& rsp));
#line 143
      if (ret != 0) {
#line 144
        printk("\v%s() GET commit error, ret = 0x%x\n", "saa7164_api_set_vbi_format",
               ret);
      } else {

      }
#line 147
      tmp = memcmp((void const   *)(& fmt), (void const   *)(& rsp), 4UL);
#line 147
      if (tmp != 0) {
#line 148
        printk("\v%s() memcmp error, ret = 0x%x\n", "saa7164_api_set_vbi_format",
               ret);
      } else
#line 151
      if ((saa_debug & 32U) != 0U) {
#line 151
        printk("\017%s: SET/COMMIT Verified\n", (char *)(& dev->name));
      } else {

      }
#line 153
      if ((saa_debug & 32U) != 0U) {
#line 153
        printk("\017%s: rsp.bmHint = 0x%x\n", (char *)(& dev->name), (int )rsp.bmHint);
      } else {

      }
#line 154
      if ((saa_debug & 32U) != 0U) {
#line 154
        printk("\017%s: rsp.bFormatIndex = 0x%x\n", (char *)(& dev->name), (int )rsp.bFormatIndex);
      } else {

      }
#line 156
      if ((saa_debug & 32U) != 0U) {
#line 156
        printk("\017%s: rsp.bFrameIndex = 0x%x\n", (char *)(& dev->name), (int )rsp.bFrameIndex);
      } else {

      }
    } else {
#line 159
      printk("\v%s() compare failed\n", "saa7164_api_set_vbi_format");
    }
  }
#line 162
  if (ret == 0) {
#line 163
    if ((saa_debug & 32U) != 0U) {
#line 163
      printk("\017%s: %s(nr=%d) Success\n", (char *)(& dev->name), "saa7164_api_set_vbi_format",
             port->nr);
    } else {

    }
  } else {

  }
#line 165
  return (ret);
}
}
#line 168 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
static int saa7164_api_set_gop_size(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct tmComResEncVideoGopStructure gs ;
  int ret ;

  {
#line 170
  dev = port->dev;
#line 174
  if ((saa_debug & 1024U) != 0U) {
#line 174
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_api_set_gop_size");
  } else {

  }
#line 176
  gs.ucRefFrameDist = (u8 )port->encoder_params.refdist;
#line 177
  gs.ucGOPSize = (u8 )port->encoder_params.gop_size;
#line 178
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 1, 4, 2, (void *)(& gs));
#line 181
  if (ret != 0) {
#line 182
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_gop_size", ret);
  } else {

  }
#line 184
  return (ret);
}
}
#line 187 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_encoder(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct tmComResEncVideoBitRate vb ;
  struct tmComResEncAudioBitRate ab ;
  int ret ;

  {
#line 189
  dev = port->dev;
#line 194
  if ((saa_debug & 1024U) != 0U) {
#line 194
    printk("\017%s: %s() unitid=0x%x\n", (char *)(& dev->name), "saa7164_api_set_encoder",
           (int )port->hwcfg.sourceid);
  } else {

  }
#line 197
  if (port->encoder_params.stream_type == 0U) {
#line 198
    port->encoder_profile = 6U;
  } else {
#line 200
    port->encoder_profile = 9U;
  }
#line 202
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 1, 0, 1, (void *)(& port->encoder_profile));
#line 204
  if (ret != 0) {
#line 205
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_encoder", ret);
  } else {

  }
#line 208
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 1, 0, 1, (void *)(& port->encoder_profile));
#line 210
  if (ret != 0) {
#line 211
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_encoder", ret);
  } else {

  }
#line 214
  if (port->encoder_params.bitrate_mode == 1U) {
#line 216
    vb.ucVideoBitRateMode = 0U;
  } else {
#line 218
    vb.ucVideoBitRateMode = 2U;
  }
#line 219
  vb.dwVideoBitRate = port->encoder_params.bitrate;
#line 220
  vb.dwVideoBitRatePeak = port->encoder_params.bitrate_peak;
#line 221
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 1, 2, 9, (void *)(& vb));
#line 225
  if (ret != 0) {
#line 226
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_encoder", ret);
  } else {

  }
#line 229
  ab.ucAudioBitRateMode = 0U;
#line 230
  ab.dwAudioBitRate = 384000U;
#line 231
  ab.dwAudioBitRatePeak = ab.dwAudioBitRate;
#line 232
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 1, 13, 9, (void *)(& ab));
#line 236
  if (ret != 0) {
#line 237
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_encoder", ret);
  } else {

  }
#line 240
  saa7164_api_set_aspect_ratio(port);
#line 241
  saa7164_api_set_gop_size(port);
#line 243
  return (ret);
}
}
#line 246 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_get_encoder(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct tmComResEncVideoBitRate v ;
  struct tmComResEncAudioBitRate a ;
  struct tmComResEncVideoInputAspectRatio ar ;
  int ret ;

  {
#line 248
  dev = port->dev;
#line 254
  if ((saa_debug & 1024U) != 0U) {
#line 254
    printk("\017%s: %s() unitid=0x%x\n", (char *)(& dev->name), "saa7164_api_get_encoder",
           (int )port->hwcfg.sourceid);
  } else {

  }
#line 257
  port->encoder_profile = 0U;
#line 258
  port->video_format = 0U;
#line 259
  port->video_resolution = 0U;
#line 260
  port->audio_format = 0U;
#line 262
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 129, 0, 1, (void *)(& port->encoder_profile));
#line 264
  if (ret != 0) {
#line 265
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_encoder", ret);
  } else {

  }
#line 267
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 129, 3, 1, (void *)(& port->video_resolution));
#line 270
  if (ret != 0) {
#line 271
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_encoder", ret);
  } else {

  }
#line 273
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 129, 1, 1, (void *)(& port->video_format));
#line 275
  if (ret != 0) {
#line 276
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_encoder", ret);
  } else {

  }
#line 278
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 129, 2, 9, (void *)(& v));
#line 280
  if (ret != 0) {
#line 281
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_encoder", ret);
  } else {

  }
#line 283
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 129, 12, 1, (void *)(& port->audio_format));
#line 285
  if (ret != 0) {
#line 286
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_encoder", ret);
  } else {

  }
#line 288
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 129, 13, 9, (void *)(& a));
#line 290
  if (ret != 0) {
#line 291
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_encoder", ret);
  } else {

  }
#line 294
  ar.width = 0U;
#line 295
  ar.height = 0U;
#line 296
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 129, 10, 2, (void *)(& ar));
#line 299
  if (ret != 0) {
#line 300
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_encoder", ret);
  } else {

  }
#line 302
  if ((saa_debug & 1024U) != 0U) {
#line 302
    printk("\017%s: encoder_profile = %d\n", (char *)(& dev->name), (int )port->encoder_profile);
  } else {

  }
#line 303
  if ((saa_debug & 1024U) != 0U) {
#line 303
    printk("\017%s: video_format    = %d\n", (char *)(& dev->name), (int )port->video_format);
  } else {

  }
#line 304
  if ((saa_debug & 1024U) != 0U) {
#line 304
    printk("\017%s: audio_format    = %d\n", (char *)(& dev->name), (int )port->audio_format);
  } else {

  }
#line 305
  if ((saa_debug & 1024U) != 0U) {
#line 305
    printk("\017%s: video_resolution= %d\n", (char *)(& dev->name), (int )port->video_resolution);
  } else {

  }
#line 306
  if ((saa_debug & 1024U) != 0U) {
#line 306
    printk("\017%s: v.ucVideoBitRateMode = %d\n", (char *)(& dev->name), (int )v.ucVideoBitRateMode);
  } else {

  }
#line 308
  if ((saa_debug & 1024U) != 0U) {
#line 308
    printk("\017%s: v.dwVideoBitRate     = %d\n", (char *)(& dev->name), v.dwVideoBitRate);
  } else {

  }
#line 310
  if ((saa_debug & 1024U) != 0U) {
#line 310
    printk("\017%s: v.dwVideoBitRatePeak = %d\n", (char *)(& dev->name), v.dwVideoBitRatePeak);
  } else {

  }
#line 312
  if ((saa_debug & 1024U) != 0U) {
#line 312
    printk("\017%s: a.ucVideoBitRateMode = %d\n", (char *)(& dev->name), (int )a.ucAudioBitRateMode);
  } else {

  }
#line 314
  if ((saa_debug & 1024U) != 0U) {
#line 314
    printk("\017%s: a.dwVideoBitRate     = %d\n", (char *)(& dev->name), a.dwAudioBitRate);
  } else {

  }
#line 316
  if ((saa_debug & 1024U) != 0U) {
#line 316
    printk("\017%s: a.dwVideoBitRatePeak = %d\n", (char *)(& dev->name), a.dwAudioBitRatePeak);
  } else {

  }
#line 318
  if ((saa_debug & 1024U) != 0U) {
#line 318
    printk("\017%s: aspect.width / height = %d:%d\n", (char *)(& dev->name), (int )ar.width,
           (int )ar.height);
  } else {

  }
#line 321
  return (ret);
}
}
#line 324 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_aspect_ratio(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct tmComResEncVideoInputAspectRatio ar ;
  int ret ;

  {
#line 326
  dev = port->dev;
#line 330
  if ((saa_debug & 1024U) != 0U) {
#line 330
    printk("\017%s: %s(%d)\n", (char *)(& dev->name), "saa7164_api_set_aspect_ratio",
           port->encoder_params.ctl_aspect);
  } else {

  }
#line 333
  switch (port->encoder_params.ctl_aspect) {
  case 0U: 
#line 335
  ar.width = 1U;
#line 336
  ar.height = 1U;
#line 337
  goto ldv_51852;
  case 1U: 
#line 339
  ar.width = 4U;
#line 340
  ar.height = 3U;
#line 341
  goto ldv_51852;
  case 2U: 
#line 343
  ar.width = 16U;
#line 344
  ar.height = 9U;
#line 345
  goto ldv_51852;
  case 3U: 
#line 347
  ar.width = 221U;
#line 348
  ar.height = 100U;
#line 349
  goto ldv_51852;
  default: 
#line 351
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"),
                       "i" (351), "i" (12UL));
  ldv_51857: ;
#line 351
  goto ldv_51857;
  }
  ldv_51852: ;
#line 354
  if ((saa_debug & 1024U) != 0U) {
#line 354
    printk("\017%s: %s(%d) now %d:%d\n", (char *)(& dev->name), "saa7164_api_set_aspect_ratio",
           port->encoder_params.ctl_aspect, (int )ar.width, (int )ar.height);
  } else {

  }
#line 359
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.sourceid, 1, 10, 2, (void *)(& ar));
#line 362
  if (ret != 0) {
#line 363
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_aspect_ratio", ret);
  } else {

  }
#line 365
  return (ret);
}
}
#line 368 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_usercontrol(struct saa7164_port *port , u8 ctl ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;
  u16 val ;

  {
#line 370
  dev = port->dev;
#line 374
  if ((unsigned int )ctl == 2U) {
#line 375
    val = port->ctl_brightness;
  } else
#line 377
  if ((unsigned int )ctl == 3U) {
#line 378
    val = port->ctl_contrast;
  } else
#line 380
  if ((unsigned int )ctl == 6U) {
#line 381
    val = port->ctl_hue;
  } else
#line 383
  if ((unsigned int )ctl == 7U) {
#line 384
    val = port->ctl_saturation;
  } else
#line 386
  if ((unsigned int )ctl == 8U) {
#line 387
    val = port->ctl_sharpness;
  } else {
#line 389
    return (-22);
  }
#line 391
  if ((saa_debug & 1024U) != 0U) {
#line 391
    printk("\017%s: %s() unitid=0x%x ctl=%d, val=%d\n", (char *)(& dev->name), "saa7164_api_set_usercontrol",
           (int )port->encunit.vsourceid, (int )ctl, (int )val);
  } else {

  }
#line 394
  ret = saa7164_cmd_send(port->dev, (int )port->encunit.vsourceid, 1, (int )ctl, 2,
                         (void *)(& val));
#line 396
  if (ret != 0) {
#line 397
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_usercontrol", ret);
  } else {

  }
#line 399
  return (ret);
}
}
#line 402 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_get_usercontrol(struct saa7164_port *port , u8 ctl ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;
  u16 val ;

  {
#line 404
  dev = port->dev;
#line 408
  ret = saa7164_cmd_send(port->dev, (int )port->encunit.vsourceid, 129, (int )ctl,
                         2, (void *)(& val));
#line 410
  if (ret != 0) {
#line 411
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_usercontrol", ret);
#line 412
    return (ret);
  } else {

  }
#line 415
  if ((saa_debug & 1024U) != 0U) {
#line 415
    printk("\017%s: %s() ctl=%d, val=%d\n", (char *)(& dev->name), "saa7164_api_get_usercontrol",
           (int )ctl, (int )val);
  } else {

  }
#line 418
  if ((unsigned int )ctl == 2U) {
#line 419
    port->ctl_brightness = val;
  } else
#line 421
  if ((unsigned int )ctl == 3U) {
#line 422
    port->ctl_contrast = val;
  } else
#line 424
  if ((unsigned int )ctl == 6U) {
#line 425
    port->ctl_hue = val;
  } else
#line 427
  if ((unsigned int )ctl == 7U) {
#line 428
    port->ctl_saturation = val;
  } else
#line 430
  if ((unsigned int )ctl == 8U) {
#line 431
    port->ctl_sharpness = val;
  } else {

  }
#line 433
  return (ret);
}
}
#line 436 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_videomux(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  u8 inputs[7U] ;
  int ret ;

  {
#line 438
  dev = port->dev;
#line 439
  inputs[0] = 1U;
#line 439
  inputs[1] = 2U;
#line 439
  inputs[2] = 2U;
#line 439
  inputs[3] = 2U;
#line 439
  inputs[4] = 5U;
#line 439
  inputs[5] = 5U;
#line 439
  inputs[6] = 5U;
#line 442
  if ((saa_debug & 1024U) != 0U) {
#line 442
    printk("\017%s: %s() v_mux=%d a_mux=%d\n", (char *)(& dev->name), "saa7164_api_set_videomux",
           (int )port->mux_input, (int )inputs[(int )port->mux_input + -1]);
  } else {

  }
#line 446
  ret = saa7164_api_audio_mute(port, 1);
#line 447
  if (ret != 0) {
#line 448
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_videomux", ret);
  } else {

  }
#line 451
  ret = saa7164_cmd_send(port->dev, (int )port->vidproc.sourceid, 1, 1, 1, (void *)(& port->mux_input));
#line 453
  if (ret != 0) {
#line 454
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_videomux", ret);
  } else {

  }
#line 457
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.sourceid, 1, 1, 1, (void *)(& inputs) + ((unsigned long )port->mux_input + 0xffffffffffffffffUL));
#line 460
  if (ret != 0) {
#line 461
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_videomux", ret);
  } else {

  }
#line 464
  ret = saa7164_api_audio_mute(port, 0);
#line 465
  if (ret != 0) {
#line 466
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_videomux", ret);
  } else {

  }
#line 468
  return (ret);
}
}
#line 471 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_audio_mute(struct saa7164_port *port , int mute ) 
{ 
  struct saa7164_dev *dev ;
  u8 v ;
  int ret ;

  {
#line 473
  dev = port->dev;
#line 474
  v = (u8 )mute;
#line 477
  if ((saa_debug & 32U) != 0U) {
#line 477
    printk("\017%s: %s(%d)\n", (char *)(& dev->name), "saa7164_api_audio_mute", mute);
  } else {

  }
#line 479
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.unitid, 1, 1, 1, (void *)(& v));
#line 481
  if (ret != 0) {
#line 482
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_audio_mute", ret);
  } else {

  }
#line 484
  return (ret);
}
}
#line 488 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_audio_volume(struct saa7164_port *port , s8 level ) 
{ 
  struct saa7164_dev *dev ;
  s16 v ;
  s16 min ;
  s16 max ;
  int ret ;

  {
#line 490
  dev = port->dev;
#line 494
  if ((saa_debug & 32U) != 0U) {
#line 494
    printk("\017%s: %s(%d)\n", (char *)(& dev->name), "saa7164_api_set_audio_volume",
           (int )level);
  } else {

  }
#line 497
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.unitid, 130, 2, 2, (void *)(& min));
#line 499
  if (ret != 0) {
#line 500
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_audio_volume", ret);
  } else {

  }
#line 502
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.unitid, 131, 2, 2, (void *)(& max));
#line 504
  if (ret != 0) {
#line 505
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_audio_volume", ret);
  } else {

  }
#line 507
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.unitid, 129, 258, 2, (void *)(& v));
#line 509
  if (ret != 0) {
#line 510
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_audio_volume", ret);
  } else {

  }
#line 512
  if ((saa_debug & 32U) != 0U) {
#line 512
    printk("\017%s: %s(%d) min=%d max=%d cur=%d\n", (char *)(& dev->name), "saa7164_api_set_audio_volume",
           (int )level, (int )min, (int )max, (int )v);
  } else {

  }
#line 515
  v = (s16 )level;
#line 516
  if ((int )v < (int )min) {
#line 517
    v = min;
  } else {

  }
#line 518
  if ((int )v > (int )max) {
#line 519
    v = max;
  } else {

  }
#line 522
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.unitid, 1, 258, 2, (void *)(& v));
#line 524
  if (ret != 0) {
#line 525
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_audio_volume", ret);
  } else {

  }
#line 528
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.unitid, 1, 514, 2, (void *)(& v));
#line 530
  if (ret != 0) {
#line 531
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_audio_volume", ret);
  } else {

  }
#line 533
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.unitid, 129, 258, 2, (void *)(& v));
#line 535
  if (ret != 0) {
#line 536
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_audio_volume", ret);
  } else {

  }
#line 538
  if ((saa_debug & 32U) != 0U) {
#line 538
    printk("\017%s: %s(%d) min=%d max=%d cur=%d\n", (char *)(& dev->name), "saa7164_api_set_audio_volume",
           (int )level, (int )min, (int )max, (int )v);
  } else {

  }
#line 541
  return (ret);
}
}
#line 544 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_audio_std(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct tmComResAudioDefaults lvl ;
  struct tmComResTunerStandard tvaudio ;
  int ret ;

  {
#line 546
  dev = port->dev;
#line 551
  if ((saa_debug & 32U) != 0U) {
#line 551
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_api_set_audio_std");
  } else {

  }
#line 554
  lvl.ucDecoderLevel = 0U;
#line 555
  lvl.ucDecoderFM_Level = 0U;
#line 556
  lvl.ucMonoLevel = 0U;
#line 557
  lvl.ucNICAM_Level = 0U;
#line 558
  lvl.ucSAP_Level = 0U;
#line 559
  lvl.ucADC_Level = 0U;
#line 560
  ret = saa7164_cmd_send(port->dev, (int )port->audfeat.unitid, 1, 13, 6, (void *)(& lvl));
#line 563
  if (ret != 0) {
#line 564
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_set_audio_std", ret);
  } else {

  }
#line 567
  if ((port->encodernorm.id & 45056ULL) != 0ULL) {
#line 568
    tvaudio.std = 1U;
#line 569
    tvaudio.country = 1U;
  } else {
#line 571
    tvaudio.std = 8U;
#line 572
    tvaudio.country = 44U;
  }
#line 575
  ret = saa7164_cmd_send(port->dev, (int )port->tunerunit.unitid, 1, 0, 5, (void *)(& tvaudio));
#line 577
  if (ret != 0) {
#line 578
    printk("\v%s() TU_STANDARD_CONTROL error, ret = 0x%x\n", "saa7164_api_set_audio_std",
           ret);
  } else {

  }
#line 580
  return (ret);
}
}
#line 583 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_audio_detection(struct saa7164_port *port , int autodetect ) 
{ 
  struct saa7164_dev *dev ;
  struct tmComResTunerStandardAuto p ;
  int ret ;

  {
#line 585
  dev = port->dev;
#line 589
  if ((saa_debug & 32U) != 0U) {
#line 589
    printk("\017%s: %s(%d)\n", (char *)(& dev->name), "saa7164_api_set_audio_detection",
           autodetect);
  } else {

  }
#line 592
  if (autodetect != 0) {
#line 593
    p.mode = 1U;
  } else {
#line 595
    p.mode = 0U;
  }
#line 596
  ret = saa7164_cmd_send(port->dev, (int )port->tunerunit.unitid, 1, 1, 1, (void *)(& p));
#line 598
  if (ret != 0) {
#line 599
    printk("\v%s() TU_STANDARD_AUTO_CONTROL error, ret = 0x%x\n", "saa7164_api_set_audio_detection",
           ret);
  } else {

  }
#line 603
  return (ret);
}
}
#line 606 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_get_videomux(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 608
  dev = port->dev;
#line 611
  ret = saa7164_cmd_send(port->dev, (int )port->vidproc.sourceid, 129, 1, 1, (void *)(& port->mux_input));
#line 613
  if (ret != 0) {
#line 614
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_videomux", ret);
  } else {

  }
#line 616
  if ((saa_debug & 1024U) != 0U) {
#line 616
    printk("\017%s: %s() v_mux=%d\n", (char *)(& dev->name), "saa7164_api_get_videomux",
           (int )port->mux_input);
  } else {

  }
#line 619
  return (ret);
}
}
#line 622 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
static int saa7164_api_set_dif(struct saa7164_port *port , u8 reg , u8 val ) 
{ 
  struct saa7164_dev *dev ;
  u16 len ;
  u8 buf[256U] ;
  int ret ;
  u8 mas ;

  {
#line 624
  dev = port->dev;
#line 626
  len = 0U;
#line 631
  if ((saa_debug & 32U) != 0U) {
#line 631
    printk("\017%s: %s(nr=%d type=%d val=%x)\n", (char *)(& dev->name), "saa7164_api_set_dif",
           port->nr, (unsigned int )port->type, (int )val);
  } else {

  }
#line 634
  if (port->nr == 0) {
#line 635
    mas = 208U;
  } else {
#line 637
    mas = 224U;
  }
#line 639
  memset((void *)(& buf), 0, 256UL);
#line 641
  buf[0] = 4U;
#line 642
  buf[1] = 0U;
#line 643
  buf[2] = 0U;
#line 644
  buf[3] = 0U;
#line 646
  buf[4] = 4U;
#line 647
  buf[5] = 0U;
#line 648
  buf[6] = 0U;
#line 649
  buf[7] = 0U;
#line 651
  buf[8] = reg;
#line 652
  buf[9] = 38U;
#line 653
  buf[10] = mas;
#line 654
  buf[11] = 176U;
#line 656
  buf[12] = val;
#line 657
  buf[13] = 0U;
#line 658
  buf[14] = 0U;
#line 659
  buf[15] = 0U;
#line 661
  ret = saa7164_cmd_send(dev, (int )port->ifunit.unitid, 133, 0, 2, (void *)(& len));
#line 663
  if (ret != 0) {
#line 664
    printk("\v%s() error, ret(1) = 0x%x\n", "saa7164_api_set_dif", ret);
#line 665
    return (-5);
  } else {

  }
#line 668
  ret = saa7164_cmd_send(dev, (int )port->ifunit.unitid, 1, 0, (int )len, (void *)(& buf));
#line 670
  if (ret != 0) {
#line 671
    printk("\v%s() error, ret(2) = 0x%x\n", "saa7164_api_set_dif", ret);
  } else {

  }
#line 676
  return (ret == 0 ? 0 : -5);
}
}
#line 680 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_configure_dif(struct saa7164_port *port , u32 std ) 
{ 
  struct saa7164_dev *dev ;
  u8 agc_disable ;

  {
#line 682
  dev = port->dev;
#line 685
  if ((saa_debug & 32U) != 0U) {
#line 685
    printk("\017%s: %s(nr=%d, 0x%x)\n", (char *)(& dev->name), "saa7164_api_configure_dif",
           port->nr, std);
  } else {

  }
#line 687
  if (((unsigned long long )std & 45056ULL) != 0ULL) {
#line 688
    if ((saa_debug & 32U) != 0U) {
#line 688
      printk("\017%s:  NTSC\n", (char *)(& dev->name));
    } else {

    }
#line 689
    saa7164_api_set_dif(port, 0, 1);
#line 690
    agc_disable = 0U;
  } else
#line 691
  if (((unsigned long long )std & 16ULL) != 0ULL) {
#line 692
    if ((saa_debug & 32U) != 0U) {
#line 692
      printk("\017%s:  PAL-I\n", (char *)(& dev->name));
    } else {

    }
#line 693
    saa7164_api_set_dif(port, 0, 8);
#line 694
    agc_disable = 0U;
  } else
#line 695
  if (((unsigned long long )std & 256ULL) != 0ULL) {
#line 696
    if ((saa_debug & 32U) != 0U) {
#line 696
      printk("\017%s:  PAL-M\n", (char *)(& dev->name));
    } else {

    }
#line 697
    saa7164_api_set_dif(port, 0, 1);
#line 698
    agc_disable = 0U;
  } else
#line 699
  if (((unsigned long long )std & 512ULL) != 0ULL) {
#line 700
    if ((saa_debug & 32U) != 0U) {
#line 700
      printk("\017%s:  PAL-N\n", (char *)(& dev->name));
    } else {

    }
#line 701
    saa7164_api_set_dif(port, 0, 1);
#line 702
    agc_disable = 0U;
  } else
#line 703
  if (((unsigned long long )std & 1024ULL) != 0ULL) {
#line 704
    if ((saa_debug & 32U) != 0U) {
#line 704
      printk("\017%s:  PAL-Nc\n", (char *)(& dev->name));
    } else {

    }
#line 705
    saa7164_api_set_dif(port, 0, 1);
#line 706
    agc_disable = 0U;
  } else
#line 707
  if ((int )std & 1) {
#line 708
    if ((saa_debug & 32U) != 0U) {
#line 708
      printk("\017%s:  PAL-B\n", (char *)(& dev->name));
    } else {

    }
#line 709
    saa7164_api_set_dif(port, 0, 2);
#line 710
    agc_disable = 0U;
  } else
#line 711
  if (((unsigned long long )std & 224ULL) != 0ULL) {
#line 712
    if ((saa_debug & 32U) != 0U) {
#line 712
      printk("\017%s:  PAL-DK\n", (char *)(& dev->name));
    } else {

    }
#line 713
    saa7164_api_set_dif(port, 0, 16);
#line 714
    agc_disable = 0U;
  } else
#line 715
  if (((unsigned long long )std & 4194304ULL) != 0ULL) {
#line 716
    if ((saa_debug & 32U) != 0U) {
#line 716
      printk("\017%s:  SECAM-L\n", (char *)(& dev->name));
    } else {

    }
#line 717
    saa7164_api_set_dif(port, 0, 32);
#line 718
    agc_disable = 0U;
  } else {
#line 721
    if ((saa_debug & 32U) != 0U) {
#line 721
      printk("\017%s:  Unknown (assuming DTV)\n", (char *)(& dev->name));
    } else {

    }
#line 723
    saa7164_api_set_dif(port, 0, 128);
#line 724
    agc_disable = 1U;
  }
#line 727
  saa7164_api_set_dif(port, 72, 160);
#line 728
  saa7164_api_set_dif(port, 192, (int )agc_disable);
#line 729
  saa7164_api_set_dif(port, 124, 4);
#line 730
  saa7164_api_set_dif(port, 4, 1);
#line 731
  msleep(100U);
#line 732
  saa7164_api_set_dif(port, 4, 0);
#line 733
  msleep(100U);
#line 735
  return (0);
}
}
#line 743 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_initialize_dif(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_port *p ;
  int ret ;
  u32 std ;

  {
#line 745
  dev = port->dev;
#line 746
  p = (struct saa7164_port *)0;
#line 747
  ret = -22;
#line 748
  std = 0U;
#line 750
  if ((saa_debug & 32U) != 0U) {
#line 750
    printk("\017%s: %s(nr=%d type=%d)\n", (char *)(& dev->name), "saa7164_api_initialize_dif",
           port->nr, (unsigned int )port->type);
  } else {

  }
#line 753
  if ((unsigned int )port->type == 2U) {
#line 758
    std = 45056U;
  } else
#line 760
  if ((unsigned int )port->type == 1U) {
#line 761
    if (port->nr == 0) {
#line 762
      p = (struct saa7164_port *)(& dev->ports) + 2UL;
    } else {
#line 764
      p = (struct saa7164_port *)(& dev->ports) + 3UL;
    }
  } else
#line 766
  if ((unsigned int )port->type == 3U) {
#line 767
    std = 45056U;
#line 768
    if (port->nr == 4) {
#line 769
      p = (struct saa7164_port *)(& dev->ports) + 2UL;
    } else {
#line 771
      p = (struct saa7164_port *)(& dev->ports) + 3UL;
    }
  } else {
#line 773
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"),
                         "i" (773), "i" (12UL));
    ldv_51947: ;
#line 773
    goto ldv_51947;
  }
#line 775
  if ((unsigned long )p != (unsigned long )((struct saa7164_port *)0)) {
#line 776
    ret = saa7164_api_configure_dif(p, std);
  } else {

  }
#line 778
  return (ret);
}
}
#line 781 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_transition_port(struct saa7164_port *port , u8 mode ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 783
  dev = port->dev;
#line 787
  if ((saa_debug & 32U) != 0U) {
#line 787
    printk("\017%s: %s(nr=%d unitid=0x%x,%d)\n", (char *)(& dev->name), "saa7164_api_transition_port",
           port->nr, (int )port->hwcfg.unitid, (int )mode);
  } else {

  }
#line 790
  ret = saa7164_cmd_send(port->dev, (int )port->hwcfg.unitid, 1, 3, 1, (void *)(& mode));
#line 792
  if (ret != 0) {
#line 793
    printk("\v%s(portnr %d unitid 0x%x) error, ret = 0x%x\n", "saa7164_api_transition_port",
           port->nr, (int )port->hwcfg.unitid, ret);
  } else {

  }
#line 796
  return (ret);
}
}
#line 799 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_get_fw_version(struct saa7164_dev *dev , u32 *version ) 
{ 
  int ret ;

  {
#line 803
  ret = saa7164_cmd_send(dev, 0, 129, 9, 4, (void *)version);
#line 805
  if (ret != 0) {
#line 806
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_get_fw_version", ret);
  } else {

  }
#line 808
  return (ret);
}
}
#line 811 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_read_eeprom(struct saa7164_dev *dev , u8 *buf , int buflen ) 
{ 
  u8 reg[2U] ;
  int tmp ;

  {
#line 813
  reg[0] = 15U;
#line 813
  reg[1] = 0U;
#line 815
  if (buflen <= 127) {
#line 816
    return (-12);
  } else {

  }
#line 820
  tmp = saa7164_api_i2c_read((struct saa7164_i2c *)(& dev->i2c_bus), 80, 2U, (u8 *)(& reg),
                             128U, buf);
#line 820
  return (tmp);
}
}
#line 824 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
static int saa7164_api_configure_port_vbi(struct saa7164_dev *dev , struct saa7164_port *port ) 
{ 
  struct tmComResVBIFormatDescrHeader *fmt ;

  {
#line 827
  fmt = & port->vbi_fmt_ntsc;
#line 829
  if ((saa_debug & 32U) != 0U) {
#line 829
    printk("\017%s:     bFormatIndex  = 0x%x\n", (char *)(& dev->name), (int )fmt->bFormatIndex);
  } else {

  }
#line 830
  if ((saa_debug & 32U) != 0U) {
#line 830
    printk("\017%s:     VideoStandard = 0x%x\n", (char *)(& dev->name), fmt->VideoStandard);
  } else {

  }
#line 831
  if ((saa_debug & 32U) != 0U) {
#line 831
    printk("\017%s:     StartLine     = %d\n", (char *)(& dev->name), (int )fmt->StartLine);
  } else {

  }
#line 832
  if ((saa_debug & 32U) != 0U) {
#line 832
    printk("\017%s:     EndLine       = %d\n", (char *)(& dev->name), (int )fmt->EndLine);
  } else {

  }
#line 833
  if ((saa_debug & 32U) != 0U) {
#line 833
    printk("\017%s:     FieldRate     = %d\n", (char *)(& dev->name), (int )fmt->FieldRate);
  } else {

  }
#line 834
  if ((saa_debug & 32U) != 0U) {
#line 834
    printk("\017%s:     bNumLines     = %d\n", (char *)(& dev->name), (int )fmt->bNumLines);
  } else {

  }
#line 838
  port->bufcounter = port->hwcfg.BARLocation;
#line 839
  port->pitch = port->hwcfg.BARLocation + 8U;
#line 840
  port->bufsize = port->hwcfg.BARLocation + 12U;
#line 841
  port->bufoffset = port->hwcfg.BARLocation + 16U;
#line 842
  port->bufptr32l = (port->hwcfg.BARLocation + (u32 )port->hwcfg.buffercount * 4U) + 20U;
#line 845
  port->bufptr32h = (port->hwcfg.BARLocation + (u32 )port->hwcfg.buffercount * 4U) + 16U;
#line 848
  port->bufptr64 = (u64 )(((unsigned long )port->hwcfg.BARLocation + (unsigned long )port->hwcfg.buffercount * 4UL) + 16UL);
#line 851
  if ((saa_debug & 32U) != 0U) {
#line 851
    printk("\017%s:    = port->hwcfg.BARLocation = 0x%x\n", (char *)(& dev->name),
           port->hwcfg.BARLocation);
  } else {

  }
#line 854
  if ((saa_debug & 32U) != 0U) {
#line 854
    printk("\017%s:    = VS_FORMAT_VBI (becomes dev->en[%d])\n", (char *)(& dev->name),
           port->nr);
  } else {

  }
#line 857
  return (0);
}
}
#line 861 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
static int saa7164_api_configure_port_mpeg2ts(struct saa7164_dev *dev , struct saa7164_port *port ,
                                              struct tmComResTSFormatDescrHeader *tsfmt ) 
{ 


  {
#line 865
  if ((saa_debug & 32U) != 0U) {
#line 865
    printk("\017%s:     bFormatIndex = 0x%x\n", (char *)(& dev->name), (int )tsfmt->bFormatIndex);
  } else {

  }
#line 866
  if ((saa_debug & 32U) != 0U) {
#line 866
    printk("\017%s:     bDataOffset  = 0x%x\n", (char *)(& dev->name), (int )tsfmt->bDataOffset);
  } else {

  }
#line 867
  if ((saa_debug & 32U) != 0U) {
#line 867
    printk("\017%s:     bPacketLength= 0x%x\n", (char *)(& dev->name), (int )tsfmt->bPacketLength);
  } else {

  }
#line 868
  if ((saa_debug & 32U) != 0U) {
#line 868
    printk("\017%s:     bStrideLength= 0x%x\n", (char *)(& dev->name), (int )tsfmt->bStrideLength);
  } else {

  }
#line 869
  if ((saa_debug & 32U) != 0U) {
#line 869
    printk("\017%s:     bguid        = (....)\n", (char *)(& dev->name));
  } else {

  }
#line 873
  port->bufcounter = port->hwcfg.BARLocation;
#line 874
  port->pitch = port->hwcfg.BARLocation + 8U;
#line 875
  port->bufsize = port->hwcfg.BARLocation + 12U;
#line 876
  port->bufoffset = port->hwcfg.BARLocation + 16U;
#line 877
  port->bufptr32l = (port->hwcfg.BARLocation + (u32 )port->hwcfg.buffercount * 4U) + 20U;
#line 880
  port->bufptr32h = (port->hwcfg.BARLocation + (u32 )port->hwcfg.buffercount * 4U) + 16U;
#line 883
  port->bufptr64 = (u64 )(((unsigned long )port->hwcfg.BARLocation + (unsigned long )port->hwcfg.buffercount * 4UL) + 16UL);
#line 886
  if ((saa_debug & 32U) != 0U) {
#line 886
    printk("\017%s:    = port->hwcfg.BARLocation = 0x%x\n", (char *)(& dev->name),
           port->hwcfg.BARLocation);
  } else {

  }
#line 889
  if ((saa_debug & 32U) != 0U) {
#line 889
    printk("\017%s:    = VS_FORMAT_MPEGTS (becomes dev->ts[%d])\n", (char *)(& dev->name),
           port->nr);
  } else {

  }
#line 892
  return (0);
}
}
#line 896 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
static int saa7164_api_configure_port_mpeg2ps(struct saa7164_dev *dev , struct saa7164_port *port ,
                                              struct tmComResPSFormatDescrHeader *fmt ) 
{ 


  {
#line 900
  if ((saa_debug & 32U) != 0U) {
#line 900
    printk("\017%s:     bFormatIndex = 0x%x\n", (char *)(& dev->name), (int )fmt->bFormatIndex);
  } else {

  }
#line 901
  if ((saa_debug & 32U) != 0U) {
#line 901
    printk("\017%s:     wPacketLength= 0x%x\n", (char *)(& dev->name), (int )fmt->wPacketLength);
  } else {

  }
#line 902
  if ((saa_debug & 32U) != 0U) {
#line 902
    printk("\017%s:     wPackLength=   0x%x\n", (char *)(& dev->name), (int )fmt->wPackLength);
  } else {

  }
#line 903
  if ((saa_debug & 32U) != 0U) {
#line 903
    printk("\017%s:     bPackDataType= 0x%x\n", (char *)(& dev->name), (int )fmt->bPackDataType);
  } else {

  }
#line 907
  port->bufcounter = port->hwcfg.BARLocation;
#line 908
  port->pitch = port->hwcfg.BARLocation + 8U;
#line 909
  port->bufsize = port->hwcfg.BARLocation + 12U;
#line 910
  port->bufoffset = port->hwcfg.BARLocation + 16U;
#line 911
  port->bufptr32l = (port->hwcfg.BARLocation + (u32 )port->hwcfg.buffercount * 4U) + 20U;
#line 914
  port->bufptr32h = (port->hwcfg.BARLocation + (u32 )port->hwcfg.buffercount * 4U) + 16U;
#line 917
  port->bufptr64 = (u64 )(((unsigned long )port->hwcfg.BARLocation + (unsigned long )port->hwcfg.buffercount * 4UL) + 16UL);
#line 920
  if ((saa_debug & 32U) != 0U) {
#line 920
    printk("\017%s:    = port->hwcfg.BARLocation = 0x%x\n", (char *)(& dev->name),
           port->hwcfg.BARLocation);
  } else {

  }
#line 923
  if ((saa_debug & 32U) != 0U) {
#line 923
    printk("\017%s:    = VS_FORMAT_MPEGPS (becomes dev->enc[%d])\n", (char *)(& dev->name),
           port->nr);
  } else {

  }
#line 926
  return (0);
}
}
#line 929 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
static int saa7164_api_dump_subdevs(struct saa7164_dev *dev , u8 *buf , int len ) 
{ 
  struct saa7164_port *tsport ;
  struct saa7164_port *encport ;
  struct saa7164_port *vbiport ;
  u32 idx ;
  u32 next_offset ;
  int i ;
  struct tmComResDescrHeader *hdr ;
  struct tmComResDescrHeader *t ;
  struct tmComResExtDevDescrHeader *exthdr ;
  struct tmComResPathDescrHeader *pathhdr ;
  struct tmComResAntTermDescrHeader *anttermhdr ;
  struct tmComResTunerDescrHeader *tunerunithdr ;
  struct tmComResDMATermDescrHeader *vcoutputtermhdr ;
  struct tmComResTSFormatDescrHeader *tsfmt ;
  struct tmComResPSFormatDescrHeader *psfmt ;
  struct tmComResSelDescrHeader *psel ;
  struct tmComResProcDescrHeader *pdh ;
  struct tmComResAFeatureDescrHeader *afd ;
  struct tmComResEncoderDescrHeader *edh ;
  struct tmComResVBIFormatDescrHeader *vbifmt ;
  u32 currpath ;

  {
#line 931
  tsport = (struct saa7164_port *)0;
#line 932
  encport = (struct saa7164_port *)0;
#line 933
  vbiport = (struct saa7164_port *)0;
#line 949
  currpath = 0U;
#line 951
  if ((saa_debug & 32U) != 0U) {
#line 951
    printk("\017%s: %s(?,?,%d) sizeof(struct tmComResDescrHeader) = %d bytes\n", (char *)(& dev->name),
           "saa7164_api_dump_subdevs", len, 4U);
  } else {

  }
#line 955
  idx = 0U;
#line 955
  goto ldv_52053;
  ldv_52052: 
#line 957
  hdr = (struct tmComResDescrHeader *)buf + (unsigned long )idx;
#line 959
  if ((unsigned int )hdr->type != 36U) {
#line 960
    return (19);
  } else {

  }
#line 962
  if ((saa_debug & 32U) != 0U) {
#line 962
    printk("\017%s: @ 0x%x =\n", (char *)(& dev->name), idx);
  } else {

  }
#line 963
  switch ((int )hdr->subtype) {
  case 245: ;
#line 965
  if ((saa_debug & 32U) != 0U) {
#line 965
    printk("\017%s:  GENERAL_REQUEST\n", (char *)(& dev->name));
  } else {

  }
#line 966
  goto ldv_52010;
  case 240: ;
#line 968
  if ((saa_debug & 32U) != 0U) {
#line 968
    printk("\017%s:  VC_TUNER_PATH\n", (char *)(& dev->name));
  } else {

  }
#line 969
  pathhdr = (struct tmComResPathDescrHeader *)buf + (unsigned long )idx;
#line 970
  if ((saa_debug & 32U) != 0U) {
#line 970
    printk("\017%s:   pathid = 0x%x\n", (char *)(& dev->name), (int )pathhdr->pathid);
  } else {

  }
#line 972
  currpath = (u32 )pathhdr->pathid;
#line 973
  goto ldv_52010;
  case 2: ;
#line 975
  if ((saa_debug & 32U) != 0U) {
#line 975
    printk("\017%s:  VC_INPUT_TERMINAL\n", (char *)(& dev->name));
  } else {

  }
#line 976
  anttermhdr = (struct tmComResAntTermDescrHeader *)buf + (unsigned long )idx;
#line 978
  if ((saa_debug & 32U) != 0U) {
#line 978
    printk("\017%s:   terminalid   = 0x%x\n", (char *)(& dev->name), (int )anttermhdr->terminalid);
  } else {

  }
#line 980
  if ((saa_debug & 32U) != 0U) {
#line 980
    printk("\017%s:   terminaltype = 0x%x\n", (char *)(& dev->name), (int )anttermhdr->terminaltype);
  } else {

  }
#line 982
  switch ((int )anttermhdr->terminaltype) {
  case 515: ;
#line 984
  if ((saa_debug & 32U) != 0U) {
#line 984
    printk("\017%s:    = ITT_ANTENNA\n", (char *)(& dev->name));
  } else {

  }
#line 985
  goto ldv_52014;
  case 1539: ;
#line 987
  if ((saa_debug & 32U) != 0U) {
#line 987
    printk("\017%s:    = LINE_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 988
  goto ldv_52014;
  case 1541: ;
#line 990
  if ((saa_debug & 32U) != 0U) {
#line 990
    printk("\017%s:    = SPDIF_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 991
  goto ldv_52014;
  case 1025: ;
#line 993
  if ((saa_debug & 32U) != 0U) {
#line 993
    printk("\017%s:    = COMPOSITE_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 995
  goto ldv_52014;
  case 1026: ;
#line 997
  if ((saa_debug & 32U) != 0U) {
#line 997
    printk("\017%s:    = SVIDEO_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 998
  goto ldv_52014;
  case 1027: ;
#line 1000
  if ((saa_debug & 32U) != 0U) {
#line 1000
    printk("\017%s:    = COMPONENT_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 1002
  goto ldv_52014;
  case 61697: ;
#line 1004
  if ((saa_debug & 32U) != 0U) {
#line 1004
    printk("\017%s:    = STANDARD_DMA\n", (char *)(& dev->name));
  } else {

  }
#line 1005
  goto ldv_52014;
  default: ;
#line 1007
  if ((saa_debug & 32U) != 0U) {
#line 1007
    printk("\017%s:    = undefined (0x%x)\n", (char *)(& dev->name), (int )anttermhdr->terminaltype);
  } else {

  }
  }
  ldv_52014: ;
#line 1010
  if ((saa_debug & 32U) != 0U) {
#line 1010
    printk("\017%s:   assocterminal= 0x%x\n", (char *)(& dev->name), (int )anttermhdr->assocterminal);
  } else {

  }
#line 1012
  if ((saa_debug & 32U) != 0U) {
#line 1012
    printk("\017%s:   iterminal    = 0x%x\n", (char *)(& dev->name), (int )anttermhdr->iterminal);
  } else {

  }
#line 1014
  if ((saa_debug & 32U) != 0U) {
#line 1014
    printk("\017%s:   controlsize  = 0x%x\n", (char *)(& dev->name), (int )anttermhdr->controlsize);
  } else {

  }
#line 1016
  goto ldv_52010;
  case 3: ;
#line 1018
  if ((saa_debug & 32U) != 0U) {
#line 1018
    printk("\017%s:  VC_OUTPUT_TERMINAL\n", (char *)(& dev->name));
  } else {

  }
#line 1019
  vcoutputtermhdr = (struct tmComResDMATermDescrHeader *)buf + (unsigned long )idx;
#line 1021
  if ((saa_debug & 32U) != 0U) {
#line 1021
    printk("\017%s:   unitid = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->unitid);
  } else {

  }
#line 1023
  if ((saa_debug & 32U) != 0U) {
#line 1023
    printk("\017%s:   terminaltype = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->terminaltype);
  } else {

  }
#line 1025
  switch ((int )vcoutputtermhdr->terminaltype) {
  case 515: ;
#line 1027
  if ((saa_debug & 32U) != 0U) {
#line 1027
    printk("\017%s:    = ITT_ANTENNA\n", (char *)(& dev->name));
  } else {

  }
#line 1028
  goto ldv_52024;
  case 1539: ;
#line 1030
  if ((saa_debug & 32U) != 0U) {
#line 1030
    printk("\017%s:    = LINE_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 1031
  goto ldv_52024;
  case 1541: ;
#line 1033
  if ((saa_debug & 32U) != 0U) {
#line 1033
    printk("\017%s:    = SPDIF_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 1034
  goto ldv_52024;
  case 1025: ;
#line 1036
  if ((saa_debug & 32U) != 0U) {
#line 1036
    printk("\017%s:    = COMPOSITE_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 1038
  goto ldv_52024;
  case 1026: ;
#line 1040
  if ((saa_debug & 32U) != 0U) {
#line 1040
    printk("\017%s:    = SVIDEO_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 1041
  goto ldv_52024;
  case 1027: ;
#line 1043
  if ((saa_debug & 32U) != 0U) {
#line 1043
    printk("\017%s:    = COMPONENT_CONNECTOR\n", (char *)(& dev->name));
  } else {

  }
#line 1045
  goto ldv_52024;
  case 61697: ;
#line 1047
  if ((saa_debug & 32U) != 0U) {
#line 1047
    printk("\017%s:    = STANDARD_DMA\n", (char *)(& dev->name));
  } else {

  }
#line 1048
  goto ldv_52024;
  default: ;
#line 1050
  if ((saa_debug & 32U) != 0U) {
#line 1050
    printk("\017%s:    = undefined (0x%x)\n", (char *)(& dev->name), (int )vcoutputtermhdr->terminaltype);
  } else {

  }
  }
  ldv_52024: ;
#line 1053
  if ((saa_debug & 32U) != 0U) {
#line 1053
    printk("\017%s:   assocterminal= 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->assocterminal);
  } else {

  }
#line 1055
  if ((saa_debug & 32U) != 0U) {
#line 1055
    printk("\017%s:   sourceid     = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->sourceid);
  } else {

  }
#line 1057
  if ((saa_debug & 32U) != 0U) {
#line 1057
    printk("\017%s:   iterminal    = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->iterminal);
  } else {

  }
#line 1059
  if ((saa_debug & 32U) != 0U) {
#line 1059
    printk("\017%s:   BARLocation  = 0x%x\n", (char *)(& dev->name), vcoutputtermhdr->BARLocation);
  } else {

  }
#line 1061
  if ((saa_debug & 32U) != 0U) {
#line 1061
    printk("\017%s:   flags        = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->flags);
  } else {

  }
#line 1063
  if ((saa_debug & 32U) != 0U) {
#line 1063
    printk("\017%s:   interruptid  = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->interruptid);
  } else {

  }
#line 1065
  if ((saa_debug & 32U) != 0U) {
#line 1065
    printk("\017%s:   buffercount  = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->buffercount);
  } else {

  }
#line 1067
  if ((saa_debug & 32U) != 0U) {
#line 1067
    printk("\017%s:   metadatasize = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->metadatasize);
  } else {

  }
#line 1069
  if ((saa_debug & 32U) != 0U) {
#line 1069
    printk("\017%s:   controlsize  = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->controlsize);
  } else {

  }
#line 1071
  if ((saa_debug & 32U) != 0U) {
#line 1071
    printk("\017%s:   numformats   = 0x%x\n", (char *)(& dev->name), (int )vcoutputtermhdr->numformats);
  } else {

  }
#line 1074
  t = (struct tmComResDescrHeader *)buf + (unsigned long )idx;
#line 1076
  next_offset = (u32 )vcoutputtermhdr->len + idx;
#line 1077
  i = 0;
#line 1077
  goto ldv_52041;
  ldv_52040: 
#line 1078
  t = (struct tmComResDescrHeader *)buf + (unsigned long )next_offset;
#line 1080
  switch ((int )t->subtype) {
  case 10: 
#line 1082
  tsfmt = (struct tmComResTSFormatDescrHeader *)t;
#line 1084
  if (currpath == 1U) {
#line 1085
    tsport = (struct saa7164_port *)(& dev->ports);
  } else {
#line 1087
    tsport = (struct saa7164_port *)(& dev->ports) + 1UL;
  }
#line 1088
  memcpy((void *)(& tsport->hwcfg), (void const   *)vcoutputtermhdr, 19UL);
#line 1090
  saa7164_api_configure_port_mpeg2ts(dev, tsport, tsfmt);
#line 1092
  goto ldv_52033;
  case 9: 
#line 1094
  psfmt = (struct tmComResPSFormatDescrHeader *)t;
#line 1096
  if (currpath == 1U) {
#line 1097
    encport = (struct saa7164_port *)(& dev->ports) + 2UL;
  } else {
#line 1099
    encport = (struct saa7164_port *)(& dev->ports) + 3UL;
  }
#line 1100
  memcpy((void *)(& encport->hwcfg), (void const   *)vcoutputtermhdr, 19UL);
#line 1102
  saa7164_api_configure_port_mpeg2ps(dev, encport, psfmt);
#line 1104
  goto ldv_52033;
  case 14: 
#line 1106
  vbifmt = (struct tmComResVBIFormatDescrHeader *)t;
#line 1108
  if (currpath == 1U) {
#line 1109
    vbiport = (struct saa7164_port *)(& dev->ports) + 4UL;
  } else {
#line 1111
    vbiport = (struct saa7164_port *)(& dev->ports) + 5UL;
  }
#line 1112
  memcpy((void *)(& vbiport->hwcfg), (void const   *)vcoutputtermhdr, 19UL);
#line 1114
  memcpy((void *)(& vbiport->vbi_fmt_ntsc), (void const   *)vbifmt, 12UL);
#line 1116
  saa7164_api_configure_port_vbi(dev, vbiport);
#line 1118
  goto ldv_52033;
  case 15: ;
#line 1120
  if ((saa_debug & 32U) != 0U) {
#line 1120
    printk("\017%s:    = VS_FORMAT_RDS\n", (char *)(& dev->name));
  } else {

  }
#line 1122
  goto ldv_52033;
  case 4: ;
#line 1124
  if ((saa_debug & 32U) != 0U) {
#line 1124
    printk("\017%s:    = VS_FORMAT_UNCOMPRESSED\n", (char *)(& dev->name));
  } else {

  }
#line 1126
  goto ldv_52033;
  case 2: ;
#line 1128
  if ((saa_debug & 32U) != 0U) {
#line 1128
    printk("\017%s:    = VS_FORMAT_TYPE\n", (char *)(& dev->name));
  } else {

  }
#line 1130
  goto ldv_52033;
  default: ;
#line 1132
  if ((saa_debug & 32U) != 0U) {
#line 1132
    printk("\017%s:    = undefined (0x%x)\n", (char *)(& dev->name), (int )t->subtype);
  } else {

  }
  }
  ldv_52033: 
#line 1136
  next_offset = (u32 )t->len + next_offset;
#line 1077
  i = i + 1;
  ldv_52041: ;
#line 1077
  if ((int )vcoutputtermhdr->numformats > i) {
#line 1079
    goto ldv_52040;
  } else {

  }

#line 1139
  goto ldv_52010;
  case 9: ;
#line 1141
  if ((saa_debug & 32U) != 0U) {
#line 1141
    printk("\017%s:  TUNER_UNIT\n", (char *)(& dev->name));
  } else {

  }
#line 1142
  tunerunithdr = (struct tmComResTunerDescrHeader *)buf + (unsigned long )idx;
#line 1144
  if ((saa_debug & 32U) != 0U) {
#line 1144
    printk("\017%s:   unitid = 0x%x\n", (char *)(& dev->name), (int )tunerunithdr->unitid);
  } else {

  }
#line 1146
  if ((saa_debug & 32U) != 0U) {
#line 1146
    printk("\017%s:   sourceid = 0x%x\n", (char *)(& dev->name), (int )tunerunithdr->sourceid);
  } else {

  }
#line 1148
  if ((saa_debug & 32U) != 0U) {
#line 1148
    printk("\017%s:   iunit = 0x%x\n", (char *)(& dev->name), (int )tunerunithdr->iunit);
  } else {

  }
#line 1150
  if ((saa_debug & 32U) != 0U) {
#line 1150
    printk("\017%s:   tuningstandards = 0x%x\n", (char *)(& dev->name), tunerunithdr->tuningstandards);
  } else {

  }
#line 1152
  if ((saa_debug & 32U) != 0U) {
#line 1152
    printk("\017%s:   controlsize = 0x%x\n", (char *)(& dev->name), (int )tunerunithdr->controlsize);
  } else {

  }
#line 1154
  if ((saa_debug & 32U) != 0U) {
#line 1154
    printk("\017%s:   controls = 0x%x\n", (char *)(& dev->name), tunerunithdr->controls);
  } else {

  }
#line 1157
  if ((int )tunerunithdr->unitid == (int )tunerunithdr->iunit) {
#line 1158
    if (currpath == 1U) {
#line 1159
      encport = (struct saa7164_port *)(& dev->ports) + 2UL;
    } else {
#line 1161
      encport = (struct saa7164_port *)(& dev->ports) + 3UL;
    }
#line 1162
    memcpy((void *)(& encport->tunerunit), (void const   *)tunerunithdr, 15UL);
#line 1164
    if ((saa_debug & 32U) != 0U) {
#line 1164
      printk("\017%s:   (becomes dev->enc[%d] tuner)\n", (char *)(& dev->name), encport->nr);
    } else {

    }
  } else {

  }
#line 1168
  goto ldv_52010;
  case 4: 
#line 1170
  psel = (struct tmComResSelDescrHeader *)buf + (unsigned long )idx;
#line 1171
  if ((saa_debug & 32U) != 0U) {
#line 1171
    printk("\017%s:  VC_SELECTOR_UNIT\n", (char *)(& dev->name));
  } else {

  }
#line 1172
  if ((saa_debug & 32U) != 0U) {
#line 1172
    printk("\017%s:   unitid = 0x%x\n", (char *)(& dev->name), (int )psel->unitid);
  } else {

  }
#line 1174
  if ((saa_debug & 32U) != 0U) {
#line 1174
    printk("\017%s:   nrinpins = 0x%x\n", (char *)(& dev->name), (int )psel->nrinpins);
  } else {

  }
#line 1176
  if ((saa_debug & 32U) != 0U) {
#line 1176
    printk("\017%s:   sourceid = 0x%x\n", (char *)(& dev->name), (int )psel->sourceid);
  } else {

  }
#line 1178
  goto ldv_52010;
  case 5: 
#line 1180
  pdh = (struct tmComResProcDescrHeader *)buf + (unsigned long )idx;
#line 1181
  if ((saa_debug & 32U) != 0U) {
#line 1181
    printk("\017%s:  VC_PROCESSING_UNIT\n", (char *)(& dev->name));
  } else {

  }
#line 1182
  if ((saa_debug & 32U) != 0U) {
#line 1182
    printk("\017%s:   unitid = 0x%x\n", (char *)(& dev->name), (int )pdh->unitid);
  } else {

  }
#line 1184
  if ((saa_debug & 32U) != 0U) {
#line 1184
    printk("\017%s:   sourceid = 0x%x\n", (char *)(& dev->name), (int )pdh->sourceid);
  } else {

  }
#line 1186
  if ((saa_debug & 32U) != 0U) {
#line 1186
    printk("\017%s:   controlsize = 0x%x\n", (char *)(& dev->name), (int )pdh->controlsize);
  } else {

  }
#line 1188
  if ((unsigned int )pdh->controlsize == 4U) {
#line 1189
    if (currpath == 1U) {
#line 1190
      encport = (struct saa7164_port *)(& dev->ports) + 2UL;
    } else {
#line 1192
      encport = (struct saa7164_port *)(& dev->ports) + 3UL;
    }
#line 1193
    memcpy((void *)(& encport->vidproc), (void const   *)pdh, 8UL);
#line 1195
    if ((saa_debug & 32U) != 0U) {
#line 1195
      printk("\017%s:   (becomes dev->enc[%d])\n", (char *)(& dev->name), encport->nr);
    } else {

    }
  } else {

  }
#line 1198
  goto ldv_52010;
  case 6: 
#line 1200
  afd = (struct tmComResAFeatureDescrHeader *)buf + (unsigned long )idx;
#line 1201
  if ((saa_debug & 32U) != 0U) {
#line 1201
    printk("\017%s:  FEATURE_UNIT\n", (char *)(& dev->name));
  } else {

  }
#line 1202
  if ((saa_debug & 32U) != 0U) {
#line 1202
    printk("\017%s:   unitid = 0x%x\n", (char *)(& dev->name), (int )afd->unitid);
  } else {

  }
#line 1204
  if ((saa_debug & 32U) != 0U) {
#line 1204
    printk("\017%s:   sourceid = 0x%x\n", (char *)(& dev->name), (int )afd->sourceid);
  } else {

  }
#line 1206
  if ((saa_debug & 32U) != 0U) {
#line 1206
    printk("\017%s:   controlsize = 0x%x\n", (char *)(& dev->name), (int )afd->controlsize);
  } else {

  }
#line 1208
  if (currpath == 1U) {
#line 1209
    encport = (struct saa7164_port *)(& dev->ports) + 2UL;
  } else {
#line 1211
    encport = (struct saa7164_port *)(& dev->ports) + 3UL;
  }
#line 1212
  memcpy((void *)(& encport->audfeat), (void const   *)afd, 6UL);
#line 1214
  if ((saa_debug & 32U) != 0U) {
#line 1214
    printk("\017%s:   (becomes dev->enc[%d])\n", (char *)(& dev->name), encport->nr);
  } else {

  }
#line 1216
  goto ldv_52010;
  case 10: 
#line 1218
  edh = (struct tmComResEncoderDescrHeader *)buf + (unsigned long )idx;
#line 1219
  if ((saa_debug & 32U) != 0U) {
#line 1219
    printk("\017%s:  ENCODER_UNIT\n", (char *)(& dev->name));
  } else {

  }
#line 1220
  if ((saa_debug & 32U) != 0U) {
#line 1220
    printk("\017%s:   subtype = 0x%x\n", (char *)(& dev->name), (int )edh->subtype);
  } else {

  }
#line 1221
  if ((saa_debug & 32U) != 0U) {
#line 1221
    printk("\017%s:   unitid = 0x%x\n", (char *)(& dev->name), (int )edh->unitid);
  } else {

  }
#line 1222
  if ((saa_debug & 32U) != 0U) {
#line 1222
    printk("\017%s:   vsourceid = 0x%x\n", (char *)(& dev->name), (int )edh->vsourceid);
  } else {

  }
#line 1224
  if ((saa_debug & 32U) != 0U) {
#line 1224
    printk("\017%s:   asourceid = 0x%x\n", (char *)(& dev->name), (int )edh->asourceid);
  } else {

  }
#line 1226
  if ((saa_debug & 32U) != 0U) {
#line 1226
    printk("\017%s:   iunit = 0x%x\n", (char *)(& dev->name), (int )edh->iunit);
  } else {

  }
#line 1227
  if ((int )edh->iunit == (int )edh->unitid) {
#line 1228
    if (currpath == 1U) {
#line 1229
      encport = (struct saa7164_port *)(& dev->ports) + 2UL;
    } else {
#line 1231
      encport = (struct saa7164_port *)(& dev->ports) + 3UL;
    }
#line 1232
    memcpy((void *)(& encport->encunit), (void const   *)edh, 29UL);
#line 1234
    if ((saa_debug & 32U) != 0U) {
#line 1234
      printk("\017%s:   (becomes dev->enc[%d])\n", (char *)(& dev->name), encport->nr);
    } else {

    }
  } else {

  }
#line 1238
  goto ldv_52010;
  case 11: ;
#line 1240
  if ((saa_debug & 32U) != 0U) {
#line 1240
    printk("\017%s:  EXTENSION_UNIT\n", (char *)(& dev->name));
  } else {

  }
#line 1241
  exthdr = (struct tmComResExtDevDescrHeader *)buf + (unsigned long )idx;
#line 1242
  if ((saa_debug & 32U) != 0U) {
#line 1242
    printk("\017%s:   unitid = 0x%x\n", (char *)(& dev->name), (int )exthdr->unitid);
  } else {

  }
#line 1244
  if ((saa_debug & 32U) != 0U) {
#line 1244
    printk("\017%s:   deviceid = 0x%x\n", (char *)(& dev->name), (int )exthdr->deviceid);
  } else {

  }
#line 1246
  if ((saa_debug & 32U) != 0U) {
#line 1246
    printk("\017%s:   devicetype = 0x%x\n", (char *)(& dev->name), exthdr->devicetype);
  } else {

  }
#line 1248
  if ((int )exthdr->devicetype & 1) {
#line 1249
    if ((saa_debug & 32U) != 0U) {
#line 1249
      printk("\017%s:    = Decoder Device\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1250
  if ((exthdr->devicetype & 2U) != 0U) {
#line 1251
    if ((saa_debug & 32U) != 0U) {
#line 1251
      printk("\017%s:    = GPIO Source\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1252
  if ((exthdr->devicetype & 4U) != 0U) {
#line 1253
    if ((saa_debug & 32U) != 0U) {
#line 1253
      printk("\017%s:    = Video Decoder\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1254
  if ((exthdr->devicetype & 8U) != 0U) {
#line 1255
    if ((saa_debug & 32U) != 0U) {
#line 1255
      printk("\017%s:    = Audio Decoder\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1256
  if ((exthdr->devicetype & 32U) != 0U) {
#line 1257
    if ((saa_debug & 32U) != 0U) {
#line 1257
      printk("\017%s:    = Crossbar\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1258
  if ((exthdr->devicetype & 64U) != 0U) {
#line 1259
    if ((saa_debug & 32U) != 0U) {
#line 1259
      printk("\017%s:    = Tuner\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1260
  if ((exthdr->devicetype & 128U) != 0U) {
#line 1261
    if ((saa_debug & 32U) != 0U) {
#line 1261
      printk("\017%s:    = IF PLL\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1262
  if ((exthdr->devicetype & 256U) != 0U) {
#line 1263
    if ((saa_debug & 32U) != 0U) {
#line 1263
      printk("\017%s:    = Demodulator\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1264
  if ((exthdr->devicetype & 512U) != 0U) {
#line 1265
    if ((saa_debug & 32U) != 0U) {
#line 1265
      printk("\017%s:    = RDS Decoder\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1266
  if ((exthdr->devicetype & 1024U) != 0U) {
#line 1267
    if ((saa_debug & 32U) != 0U) {
#line 1267
      printk("\017%s:    = Encoder\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1268
  if ((exthdr->devicetype & 2048U) != 0U) {
#line 1269
    if ((saa_debug & 32U) != 0U) {
#line 1269
      printk("\017%s:    = IR Decoder\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1270
  if ((exthdr->devicetype & 4096U) != 0U) {
#line 1271
    if ((saa_debug & 32U) != 0U) {
#line 1271
      printk("\017%s:    = EEPROM\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1272
  if ((exthdr->devicetype & 8192U) != 0U) {
#line 1273
    if ((saa_debug & 32U) != 0U) {
#line 1273
      printk("\017%s:    = VBI Decoder\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1275
  if ((exthdr->devicetype & 65536U) != 0U) {
#line 1276
    if ((saa_debug & 32U) != 0U) {
#line 1276
      printk("\017%s:    = Streaming Device\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1278
  if ((exthdr->devicetype & 131072U) != 0U) {
#line 1279
    if ((saa_debug & 32U) != 0U) {
#line 1279
      printk("\017%s:    = DRM Device\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1281
  if ((exthdr->devicetype & 1073741824U) != 0U) {
#line 1282
    if ((saa_debug & 32U) != 0U) {
#line 1282
      printk("\017%s:    = Generic Device\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1284
  if ((int )exthdr->devicetype < 0) {
#line 1285
    if ((saa_debug & 32U) != 0U) {
#line 1285
      printk("\017%s:    = Config Space Device\n", (char *)(& dev->name));
    } else {

    }
  } else {

  }
#line 1287
  if ((saa_debug & 32U) != 0U) {
#line 1287
    printk("\017%s:   numgpiopins = 0x%x\n", (char *)(& dev->name), exthdr->numgpiopins);
  } else {

  }
#line 1289
  if ((saa_debug & 32U) != 0U) {
#line 1289
    printk("\017%s:   numgpiogroups = 0x%x\n", (char *)(& dev->name), (int )exthdr->numgpiogroups);
  } else {

  }
#line 1291
  if ((saa_debug & 32U) != 0U) {
#line 1291
    printk("\017%s:   controlsize = 0x%x\n", (char *)(& dev->name), (int )exthdr->controlsize);
  } else {

  }
#line 1293
  if ((exthdr->devicetype & 128U) != 0U) {
#line 1294
    if (currpath == 1U) {
#line 1295
      encport = (struct saa7164_port *)(& dev->ports) + 2UL;
    } else {
#line 1297
      encport = (struct saa7164_port *)(& dev->ports) + 3UL;
    }
#line 1298
    memcpy((void *)(& encport->ifunit), (void const   *)exthdr, 16UL);
#line 1300
    if ((saa_debug & 32U) != 0U) {
#line 1300
      printk("\017%s:   (becomes dev->enc[%d])\n", (char *)(& dev->name), encport->nr);
    } else {

    }
  } else {

  }
#line 1304
  goto ldv_52010;
  case 243: ;
#line 1306
  if ((saa_debug & 32U) != 0U) {
#line 1306
    printk("\017%s:  PVC_INFRARED_UNIT\n", (char *)(& dev->name));
  } else {

  }
#line 1307
  goto ldv_52010;
  case 244: ;
#line 1309
  if ((saa_debug & 32U) != 0U) {
#line 1309
    printk("\017%s:  DRM_UNIT\n", (char *)(& dev->name));
  } else {

  }
#line 1310
  goto ldv_52010;
  default: ;
#line 1312
  if ((saa_debug & 32U) != 0U) {
#line 1312
    printk("\017%s: default %d\n", (char *)(& dev->name), (int )hdr->subtype);
  } else {

  }
  }
  ldv_52010: ;
#line 1315
  if ((saa_debug & 32U) != 0U) {
#line 1315
    printk("\017%s:  1.%x\n", (char *)(& dev->name), (int )hdr->len);
  } else {

  }
#line 1316
  if ((saa_debug & 32U) != 0U) {
#line 1316
    printk("\017%s:  2.%x\n", (char *)(& dev->name), (int )hdr->type);
  } else {

  }
#line 1317
  if ((saa_debug & 32U) != 0U) {
#line 1317
    printk("\017%s:  3.%x\n", (char *)(& dev->name), (int )hdr->subtype);
  } else {

  }
#line 1318
  if ((saa_debug & 32U) != 0U) {
#line 1318
    printk("\017%s:  4.%x\n", (char *)(& dev->name), (int )hdr->unitid);
  } else {

  }
#line 1320
  idx = (u32 )hdr->len + idx;
  ldv_52053: ;
#line 955
  if ((unsigned long )idx < (unsigned long )len - 4UL) {
#line 957
    goto ldv_52052;
  } else {

  }

#line 1323
  return (0);
}
}
#line 1326 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_enum_subdevs(struct saa7164_dev *dev ) 
{ 
  int ret ;
  u32 buflen ;
  u8 *buf ;
  void *tmp ;

  {
#line 1329
  buflen = 0U;
#line 1332
  if ((saa_debug & 32U) != 0U) {
#line 1332
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_api_enum_subdevs");
  } else {

  }
#line 1335
  ret = saa7164_cmd_send(dev, 0, 133, 1, 4, (void *)(& buflen));
#line 1337
  if (ret != 0) {
#line 1338
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_enum_subdevs", ret);
  } else {

  }
#line 1340
  if ((saa_debug & 32U) != 0U) {
#line 1340
    printk("\017%s: %s() total descriptor size = %d bytes.\n", (char *)(& dev->name),
           "saa7164_api_enum_subdevs", buflen);
  } else {

  }
#line 1344
  tmp = kzalloc((size_t )buflen, 208U);
#line 1344
  buf = (u8 *)tmp;
#line 1345
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
#line 1346
    return (12);
  } else {

  }
#line 1349
  ret = saa7164_cmd_send(dev, 0, 129, 1, (int )((u16 )buflen), (void *)buf);
#line 1351
  if (ret != 0) {
#line 1352
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_enum_subdevs", ret);
#line 1353
    goto out;
  } else {

  }
#line 1356
  if ((saa_debug & 32U) != 0U) {
#line 1357
    print_hex_dump("\016", "", 2, 16, 1, (void const   *)buf, (size_t )buflen & 4294967280UL,
                   0);
  } else {

  }
#line 1360
  saa7164_api_dump_subdevs(dev, buf, (int )buflen);
  out: 
#line 1363
  kfree((void const   *)buf);
#line 1364
  return (ret);
}
}
#line 1367 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_i2c_read(struct saa7164_i2c *bus , u8 addr , u32 reglen , u8 *reg ,
                         u32 datalen , u8 *data ) 
{ 
  struct saa7164_dev *dev ;
  u16 len ;
  int unitid ;
  u8 buf[256U] ;
  int ret ;

  {
#line 1370
  dev = bus->dev;
#line 1371
  len = 0U;
#line 1376
  if ((saa_debug & 32U) != 0U) {
#line 1376
    printk("\017%s: %s() addr=%x reglen=%d datalen=%d\n", (char *)(& dev->name), "saa7164_api_i2c_read",
           (int )addr, reglen, datalen);
  } else {

  }
#line 1379
  if (reglen > 4U) {
#line 1380
    return (-5);
  } else {

  }
#line 1387
  memset((void *)(& buf), 0, 256UL);
#line 1388
  memcpy((void *)(& buf) + 8U, (void const   *)reg, (size_t )reglen);
#line 1389
  *((u32 *)(& buf)) = reglen;
#line 1390
  *((u32 *)(& buf) + 4U) = datalen;
#line 1392
  unitid = saa7164_i2caddr_to_unitid(bus, (int )addr);
#line 1393
  if (unitid < 0) {
#line 1394
    printk("\v%s() error, cannot translate regaddr 0x%x to unitid\n", "saa7164_api_i2c_read",
           (int )addr);
#line 1397
    return (-5);
  } else {

  }
#line 1400
  ret = saa7164_cmd_send(bus->dev, (int )((u8 )unitid), 133, 0, 2, (void *)(& len));
#line 1402
  if (ret != 0) {
#line 1403
    printk("\v%s() error, ret(1) = 0x%x\n", "saa7164_api_i2c_read", ret);
#line 1404
    return (-5);
  } else {

  }
#line 1407
  if ((saa_debug & 32U) != 0U) {
#line 1407
    printk("\017%s: %s() len = %d bytes\n", (char *)(& dev->name), "saa7164_api_i2c_read",
           (int )len);
  } else {

  }
#line 1409
  if ((saa_debug & 16U) != 0U) {
#line 1410
    print_hex_dump("\016", "", 2, 16, 1, (void const   *)(& buf), 32UL, 0);
  } else {

  }
#line 1413
  ret = saa7164_cmd_send(bus->dev, (int )((u8 )unitid), 129, 0, (int )len, (void *)(& buf));
#line 1415
  if (ret != 0) {
#line 1416
    printk("\v%s() error, ret(2) = 0x%x\n", "saa7164_api_i2c_read", ret);
  } else {
#line 1418
    if ((saa_debug & 16U) != 0U) {
#line 1419
      print_hex_dump("\016", "", 2, 16, 1, (void const   *)(& buf), 256UL, 0);
    } else {

    }
#line 1421
    memcpy((void *)data, (void const   *)(& buf) + ((unsigned long )reglen + 8UL),
             (size_t )datalen);
  }
#line 1424
  return (ret == 0 ? 0 : -5);
}
}
#line 1428 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_i2c_write(struct saa7164_i2c *bus , u8 addr , u32 datalen , u8 *data ) 
{ 
  struct saa7164_dev *dev ;
  u16 len ;
  int unitid ;
  int reglen ;
  u8 buf[256U] ;
  int ret ;

  {
#line 1431
  dev = bus->dev;
#line 1432
  len = 0U;
#line 1438
  if ((saa_debug & 32U) != 0U) {
#line 1438
    printk("\017%s: %s() addr=0x%2x len=0x%x\n", (char *)(& dev->name), "saa7164_api_i2c_write",
           (int )addr, datalen);
  } else {

  }
#line 1441
  if (datalen == 0U || datalen > 232U) {
#line 1442
    return (-5);
  } else {

  }
#line 1444
  memset((void *)(& buf), 0, 256UL);
#line 1446
  unitid = saa7164_i2caddr_to_unitid(bus, (int )addr);
#line 1447
  if (unitid < 0) {
#line 1448
    printk("\v%s() error, cannot translate regaddr 0x%x to unitid\n", "saa7164_api_i2c_write",
           (int )addr);
#line 1451
    return (-5);
  } else {

  }
#line 1454
  reglen = saa7164_i2caddr_to_reglen(bus, (int )addr);
#line 1455
  if (reglen < 0) {
#line 1456
    printk("\v%s() error, cannot translate regaddr to reglen\n", "saa7164_api_i2c_write");
#line 1459
    return (-5);
  } else {

  }
#line 1462
  ret = saa7164_cmd_send(bus->dev, (int )((u8 )unitid), 133, 0, 2, (void *)(& len));
#line 1464
  if (ret != 0) {
#line 1465
    printk("\v%s() error, ret(1) = 0x%x\n", "saa7164_api_i2c_write", ret);
#line 1466
    return (-5);
  } else {

  }
#line 1469
  if ((saa_debug & 32U) != 0U) {
#line 1469
    printk("\017%s: %s() len = %d bytes unitid=0x%x\n", (char *)(& dev->name), "saa7164_api_i2c_write",
           (int )len, unitid);
  } else {

  }
#line 1477
  *((u32 *)(& buf)) = (u32 )reglen;
#line 1478
  *((u32 *)(& buf) + 4U) = datalen - (u32 )reglen;
#line 1479
  memcpy((void *)(& buf) + 8U, (void const   *)data, (size_t )datalen);
#line 1481
  if ((saa_debug & 16U) != 0U) {
#line 1482
    print_hex_dump("\016", "", 2, 16, 1, (void const   *)(& buf), 256UL, 0);
  } else {

  }
#line 1485
  ret = saa7164_cmd_send(bus->dev, (int )((u8 )unitid), 1, 0, (int )len, (void *)(& buf));
#line 1487
  if (ret != 0) {
#line 1488
    printk("\v%s() error, ret(2) = 0x%x\n", "saa7164_api_i2c_write", ret);
  } else {

  }
#line 1490
  return (ret == 0 ? 0 : -5);
}
}
#line 1493 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
static int saa7164_api_modify_gpio(struct saa7164_dev *dev , u8 unitid , u8 pin ,
                                   u8 state ) 
{ 
  int ret ;
  struct tmComResGPIO t ;

  {
#line 1499
  if ((saa_debug & 32U) != 0U) {
#line 1499
    printk("\017%s: %s(0x%x, %d, %d)\n", (char *)(& dev->name), "saa7164_api_modify_gpio",
           (int )unitid, (int )pin, (int )state);
  } else {

  }
#line 1502
  if ((unsigned int )pin > 7U || (unsigned int )state > 2U) {
#line 1503
    return (9);
  } else {

  }
#line 1505
  t.pin = (u32 )pin;
#line 1506
  t.state = state;
#line 1508
  ret = saa7164_cmd_send(dev, (int )unitid, 1, 1, 5, (void *)(& t));
#line 1510
  if (ret != 0) {
#line 1511
    printk("\v%s() error, ret = 0x%x\n", "saa7164_api_modify_gpio", ret);
  } else {

  }
#line 1514
  return (ret);
}
}
#line 1517 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_set_gpiobit(struct saa7164_dev *dev , u8 unitid , u8 pin ) 
{ 
  int tmp ;

  {
#line 1520
  tmp = saa7164_api_modify_gpio(dev, (int )unitid, (int )pin, 1);
#line 1520
  return (tmp);
}
}
#line 1523 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.c"
int saa7164_api_clear_gpiobit(struct saa7164_dev *dev , u8 unitid , u8 pin ) 
{ 
  int tmp ;

  {
#line 1526
  tmp = saa7164_api_modify_gpio(dev, (int )unitid, (int )pin, 0);
#line 1526
  return (tmp);
}
}
#line 256 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
bool ldv_queue_work_on_347(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 260
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 260
  ldv_func_res = tmp;
#line 262
  activate_work_3(ldv_func_arg3, 2);
#line 264
  return (ldv_func_res);
}
}
#line 267 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
bool ldv_queue_delayed_work_on_348(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 271
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 271
  ldv_func_res = tmp;
#line 273
  activate_work_3(& ldv_func_arg3->work, 2);
#line 275
  return (ldv_func_res);
}
}
#line 278 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
bool ldv_queue_work_on_349(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 282
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 282
  ldv_func_res = tmp;
#line 284
  activate_work_3(ldv_func_arg3, 2);
#line 286
  return (ldv_func_res);
}
}
#line 289 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
void ldv_flush_workqueue_350(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 292
  flush_workqueue(ldv_func_arg1);
#line 294
  call_and_disable_all_3(2);
#line 295
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
bool ldv_queue_delayed_work_on_351(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 301
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 301
  ldv_func_res = tmp;
#line 303
  activate_work_3(& ldv_func_arg3->work, 2);
#line 305
  return (ldv_func_res);
}
}
#line 343 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
void *ldv_kmem_cache_alloc_357(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 346
  ldv_check_alloc_flags(flags);
#line 347
  tmp = ldv_undef_ptr();
#line 347
  return (tmp);
}
}
#line 385 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
int ldv_pskb_expand_head_363(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 388
  ldv_check_alloc_flags(flags);
#line 389
  tmp = ldv_undef_ptr();
#line 389
  return ((int )((long )tmp));
}
}
#line 399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
struct sk_buff *ldv_skb_clone_365(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 402
  ldv_check_alloc_flags(flags);
#line 403
  tmp = ldv_undef_ptr();
#line 403
  return ((struct sk_buff *)tmp);
}
}
#line 413 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
struct sk_buff *ldv_skb_copy_367(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 416
  ldv_check_alloc_flags(flags);
#line 417
  tmp = ldv_undef_ptr();
#line 417
  return ((struct sk_buff *)tmp);
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_368(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 423
  ldv_check_alloc_flags(flags);
#line 424
  tmp = ldv_undef_ptr();
#line 424
  return ((struct sk_buff *)tmp);
}
}
#line 427 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_369(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 430
  ldv_check_alloc_flags(flags);
#line 431
  tmp = ldv_undef_ptr();
#line 431
  return ((struct sk_buff *)tmp);
}
}
#line 434 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_370(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 438
  tmp = ldv_undef_ptr();
#line 438
  return ((struct sk_buff *)tmp);
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
int ldv_pskb_expand_head_371(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 444
  ldv_check_alloc_flags(flags);
#line 445
  tmp = ldv_undef_ptr();
#line 445
  return ((int )((long )tmp));
}
}
#line 448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
int ldv_pskb_expand_head_372(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 451
  ldv_check_alloc_flags(flags);
#line 452
  tmp = ldv_undef_ptr();
#line 452
  return ((int )((long )tmp));
}
}
#line 455 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-api.o.c.prepared"
struct sk_buff *ldv_skb_clone_373(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 459
  tmp = ldv_undef_ptr();
#line 459
  return ((struct sk_buff *)tmp);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_393(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_395(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_394(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_396(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_403(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 131 "./arch/x86/include/asm/dma-mapping.h"
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
#line 136
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
#line 16 "include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
#line 19
  tmp = dma_alloc_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                        size, dma_handle, 32U, (struct dma_attrs *)0);
#line 19
  return (tmp);
}
}
#line 31 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 


  {
#line 34
  dma_free_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                 size, vaddr, dma_handle, (struct dma_attrs *)0);
#line 35
  return;
}
}
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_411(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_419(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_413(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_409(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_417(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_418(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_414(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_415(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_416(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 587 "/home/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/pci/saa7164/saa7164.h"
void saa7164_buffer_display(struct saa7164_buffer *buf ) ;
#line 588
int saa7164_buffer_activate(struct saa7164_buffer *buf , int i ) ;
#line 590
struct saa7164_user_buffer *saa7164_buffer_alloc_user(struct saa7164_dev *dev , u32 len ) ;
#line 592
void saa7164_buffer_dealloc_user(struct saa7164_user_buffer *buf ) ;
#line 69 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"
void saa7164_buffer_display(struct saa7164_buffer *buf ) 
{ 
  struct saa7164_dev *dev ;
  int i ;

  {
#line 71
  dev = (buf->port)->dev;
#line 74
  if ((saa_debug & 512U) != 0U) {
#line 74
    printk("\017%s: %s()   buffer @ 0x%p nr=%d\n", (char *)(& dev->name), "saa7164_buffer_display",
           buf, buf->idx);
  } else {

  }
#line 76
  if ((saa_debug & 512U) != 0U) {
#line 76
    printk("\017%s:   pci_cpu @ 0x%p    dma @ 0x%08llx len = 0x%x\n", (char *)(& dev->name),
           buf->cpu, (long long )buf->dma, buf->pci_size);
  } else {

  }
#line 78
  if ((saa_debug & 512U) != 0U) {
#line 78
    printk("\017%s:    pt_cpu @ 0x%p pt_dma @ 0x%08llx len = 0x%x\n", (char *)(& dev->name),
           buf->pt_cpu, (long long )buf->pt_dma, buf->pt_size);
  } else {

  }
#line 82
  i = 0;
#line 82
  goto ldv_51796;
  ldv_51795: ;
#line 84
  if ((saa_debug & 512U) != 0U) {
#line 84
    printk("\017%s:     pt[%02d] = 0x%p -> 0x%llx\n", (char *)(& dev->name), i, buf->pt_cpu,
           *(buf->pt_cpu));
  } else {

  }
#line 82
  i = i + 1;
  ldv_51796: ;
#line 82
  if (i <= 15) {
#line 84
    goto ldv_51795;
  } else {

  }

#line 89
  return;
}
}
#line 92 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"
struct saa7164_buffer *saa7164_buffer_alloc(struct saa7164_port *port , u32 len ) 
{ 
  struct tmHWStreamParameters *params ;
  struct saa7164_buffer *buf ;
  struct saa7164_dev *dev ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 95
  params = & port->hw_streamingparams;
#line 96
  buf = (struct saa7164_buffer *)0;
#line 97
  dev = port->dev;
#line 100
  if ((len == 0U || len > 65535U) || (len & 7U) != 0U) {
#line 101
    printk("\f%s: %s() SAA_ERR_BAD_PARAMETER\n", (char *)(& dev->name), "saa7164_buffer_alloc");
#line 102
    goto ret;
  } else {

  }
#line 105
  tmp = kzalloc(88UL, 208U);
#line 105
  buf = (struct saa7164_buffer *)tmp;
#line 106
  if ((unsigned long )buf == (unsigned long )((struct saa7164_buffer *)0)) {
#line 107
    printk("\f%s: %s() SAA_ERR_NO_RESOURCES\n", (char *)(& dev->name), "saa7164_buffer_alloc");
#line 108
    goto ret;
  } else {

  }
#line 111
  buf->idx = -1;
#line 112
  buf->port = port;
#line 113
  buf->flags = 1;
#line 114
  buf->pos = 0U;
#line 115
  buf->actual_size = params->pitch * params->numberoflines;
#line 116
  buf->crc = 0U;
#line 118
  buf->pci_size = 65536U;
#line 119
  buf->pt_size = 4224U;
#line 122
  tmp___0 = pci_alloc_consistent((port->dev)->pci, (size_t )buf->pci_size, & buf->dma);
#line 122
  buf->cpu = (u64 *)tmp___0;
#line 124
  if ((unsigned long )buf->cpu == (unsigned long )((u64 *)0ULL)) {
#line 125
    goto fail1;
  } else {

  }
#line 127
  tmp___1 = pci_alloc_consistent((port->dev)->pci, (size_t )buf->pt_size, & buf->pt_dma);
#line 127
  buf->pt_cpu = (u64 *)tmp___1;
#line 129
  if ((unsigned long )buf->pt_cpu == (unsigned long )((u64 *)0ULL)) {
#line 130
    goto fail2;
  } else {

  }
#line 133
  memset((void *)buf->cpu, 255, (size_t )buf->pci_size);
#line 134
  buf->crc = crc32_le(0U, (unsigned char const   *)buf->cpu, (size_t )buf->actual_size);
#line 135
  memset((void *)buf->pt_cpu, 255, (size_t )buf->pt_size);
#line 137
  if ((saa_debug & 512U) != 0U) {
#line 137
    printk("\017%s: %s()   allocated buffer @ 0x%p (%d pageptrs)\n", (char *)(& dev->name),
           "saa7164_buffer_alloc", buf, params->numpagetables);
  } else {

  }
#line 139
  if ((saa_debug & 512U) != 0U) {
#line 139
    printk("\017%s:   pci_cpu @ 0x%p    dma @ 0x%08lx len = 0x%x\n", (char *)(& dev->name),
           buf->cpu, (long )buf->dma, buf->pci_size);
  } else {

  }
#line 141
  if ((saa_debug & 512U) != 0U) {
#line 141
    printk("\017%s:    pt_cpu @ 0x%p pt_dma @ 0x%08lx len = 0x%x\n", (char *)(& dev->name),
           buf->pt_cpu, (long )buf->pt_dma, buf->pt_size);
  } else {

  }
#line 145
  i = 0;
#line 145
  goto ldv_51811;
  ldv_51810: 
#line 147
  *(buf->pt_cpu + (unsigned long )i) = buf->dma + (dma_addr_t )(i * 4096);
#line 148
  if ((saa_debug & 512U) != 0U) {
#line 148
    printk("\017%s:     pt[%02d] = 0x%p -> 0x%llx\n", (char *)(& dev->name), i, buf->pt_cpu,
           *(buf->pt_cpu));
  } else {

  }
#line 145
  i = i + 1;
  ldv_51811: ;
#line 145
  if ((u32 )i < params->numpagetables) {
#line 147
    goto ldv_51810;
  } else {

  }

#line 153
  goto ret;
  fail2: 
#line 156
  pci_free_consistent((port->dev)->pci, (size_t )buf->pci_size, (void *)buf->cpu,
                      buf->dma);
  fail1: 
#line 158
  kfree((void const   *)buf);
#line 160
  buf = (struct saa7164_buffer *)0;
  ret: ;
#line 162
  return (buf);
}
}
#line 165 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"
int saa7164_buffer_dealloc(struct saa7164_buffer *buf ) 
{ 
  struct saa7164_dev *dev ;

  {
#line 169
  if ((unsigned long )buf == (unsigned long )((struct saa7164_buffer *)0) || (unsigned long )buf->port == (unsigned long )((struct saa7164_port *)0)) {
#line 170
    return (9);
  } else {

  }
#line 171
  dev = (buf->port)->dev;
#line 173
  if ((saa_debug & 512U) != 0U) {
#line 173
    printk("\017%s: %s() deallocating buffer @ 0x%p\n", (char *)(& dev->name), "saa7164_buffer_dealloc",
           buf);
  } else {

  }
#line 176
  if ((unsigned int )buf->flags != 1U) {
#line 177
    printk("\f%s:  freeing a non-free buffer\n", (char *)(& dev->name));
  } else {

  }
#line 179
  pci_free_consistent(dev->pci, (size_t )buf->pci_size, (void *)buf->cpu, buf->dma);
#line 180
  pci_free_consistent(dev->pci, (size_t )buf->pt_size, (void *)buf->pt_cpu, buf->pt_dma);
#line 182
  kfree((void const   *)buf);
#line 184
  return (0);
}
}
#line 187 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"
int saa7164_buffer_zero_offsets(struct saa7164_port *port , int i ) 
{ 
  struct saa7164_dev *dev ;

  {
#line 189
  dev = port->dev;
#line 191
  if (i < 0 || (int )port->hwcfg.buffercount <= i) {
#line 192
    return (-22);
  } else {

  }
#line 194
  if ((saa_debug & 512U) != 0U) {
#line 194
    printk("\017%s: %s(idx = %d)\n", (char *)(& dev->name), "saa7164_buffer_zero_offsets",
           i);
  } else {

  }
#line 196
  writel(0U, (void volatile   *)(dev->lmmio + (((unsigned long )port->bufoffset + (unsigned long )i * 4UL) >> 2)));
#line 198
  return (0);
}
}
#line 202 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"
int saa7164_buffer_activate(struct saa7164_buffer *buf , int i ) 
{ 
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 204
  port = buf->port;
#line 205
  dev = port->dev;
#line 207
  if (i < 0 || (int )port->hwcfg.buffercount <= i) {
#line 208
    return (-22);
  } else {

  }
#line 210
  if ((saa_debug & 512U) != 0U) {
#line 210
    printk("\017%s: %s(idx = %d)\n", (char *)(& dev->name), "saa7164_buffer_activate",
           i);
  } else {

  }
#line 212
  buf->idx = i;
#line 213
  buf->flags = 2;
#line 214
  buf->pos = 0U;
#line 217
  writel(0U, (void volatile   *)(dev->lmmio + (((unsigned long )port->bufoffset + (unsigned long )i * 4UL) >> 2)));
#line 218
  writel((unsigned int )buf->pt_dma, (void volatile   *)(dev->lmmio + (((unsigned long )port->bufptr32h + (unsigned long )i * 8UL) >> 2)));
#line 219
  writel(0U, (void volatile   *)(dev->lmmio + (((unsigned long )port->bufptr32l + (unsigned long )i * 8UL) >> 2)));
#line 221
  if ((saa_debug & 512U) != 0U) {
#line 221
    tmp = readl((void const volatile   *)(dev->lmmio + (((unsigned long )port->bufptr32l + (unsigned long )i * 8UL) >> 2)));
#line 221
    tmp___0 = readl((void const volatile   *)(dev->lmmio + (((unsigned long )port->bufptr32h + (unsigned long )i * 8UL) >> 2)));
#line 221
    tmp___1 = readl((void const volatile   *)(dev->lmmio + (((unsigned long )port->bufoffset + (unsigned long )i * 4UL) >> 2)));
#line 221
    printk("\017%s:    buf[%d] offset 0x%llx (0x%x) buf 0x%llx/%llx (0x%x/%x) nr=%d\n",
           (char *)(& dev->name), buf->idx, (unsigned long long )port->bufoffset + (unsigned long long )((unsigned long )i * 4UL),
           tmp___1, (unsigned long long )port->bufptr32h + (unsigned long long )((unsigned long )i * 8UL),
           (unsigned long long )port->bufptr32l + (unsigned long long )((unsigned long )i * 8UL),
           tmp___0, tmp, buf->idx);
  } else {

  }
#line 232
  return (0);
}
}
#line 235 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"
int saa7164_buffer_cfg_port(struct saa7164_port *port ) 
{ 
  struct tmHWStreamParameters *params ;
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct list_head *c ;
  struct list_head *n ;
  int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  struct list_head  const  *__mptr ;
  int tmp___2 ;

  {
#line 237
  params = & port->hw_streamingparams;
#line 238
  dev = port->dev;
#line 241
  i = 0;
#line 243
  if ((saa_debug & 512U) != 0U) {
#line 243
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_buffer_cfg_port",
           port->nr);
  } else {

  }
#line 245
  writel(0U, (void volatile   *)dev->lmmio + (unsigned long )(port->bufcounter >> 2));
#line 246
  writel(params->pitch, (void volatile   *)dev->lmmio + (unsigned long )(port->pitch >> 2));
#line 247
  writel(params->pitch * params->numberoflines, (void volatile   *)dev->lmmio + (unsigned long )(port->bufsize >> 2));
#line 249
  if ((saa_debug & 512U) != 0U) {
#line 249
    printk("\017%s:  configured:\n", (char *)(& dev->name));
  } else {

  }
#line 250
  if ((saa_debug & 512U) != 0U) {
#line 250
    printk("\017%s:    lmmio       0x%p\n", (char *)(& dev->name), dev->lmmio);
  } else {

  }
#line 251
  if ((saa_debug & 512U) != 0U) {
#line 251
    tmp = readl((void const volatile   *)dev->lmmio + (unsigned long )(port->bufcounter >> 2));
#line 251
    printk("\017%s:    bufcounter  0x%x = 0x%x\n", (char *)(& dev->name), port->bufcounter,
           tmp);
  } else {

  }
#line 254
  if ((saa_debug & 512U) != 0U) {
#line 254
    tmp___0 = readl((void const volatile   *)dev->lmmio + (unsigned long )(port->pitch >> 2));
#line 254
    printk("\017%s:    pitch       0x%x = %d\n", (char *)(& dev->name), port->pitch,
           tmp___0);
  } else {

  }
#line 257
  if ((saa_debug & 512U) != 0U) {
#line 257
    tmp___1 = readl((void const volatile   *)dev->lmmio + (unsigned long )(port->bufsize >> 2));
#line 257
    printk("\017%s:    bufsize     0x%x = %d\n", (char *)(& dev->name), port->bufsize,
           tmp___1);
  } else {

  }
#line 260
  if ((saa_debug & 512U) != 0U) {
#line 260
    printk("\017%s:    buffercount = %d\n", (char *)(& dev->name), (int )port->hwcfg.buffercount);
  } else {

  }
#line 261
  if ((saa_debug & 512U) != 0U) {
#line 261
    printk("\017%s:    bufoffset = 0x%x\n", (char *)(& dev->name), port->bufoffset);
  } else {

  }
#line 262
  if ((saa_debug & 512U) != 0U) {
#line 262
    printk("\017%s:    bufptr32h = 0x%x\n", (char *)(& dev->name), port->bufptr32h);
  } else {

  }
#line 263
  if ((saa_debug & 512U) != 0U) {
#line 263
    printk("\017%s:    bufptr32l = 0x%x\n", (char *)(& dev->name), port->bufptr32l);
  } else {

  }
#line 266
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 267
  c = port->dmaqueue.list.next;
#line 267
  n = c->next;
#line 267
  goto ldv_51846;
  ldv_51845: 
#line 268
  __mptr = (struct list_head  const  *)c;
#line 268
  buf = (struct saa7164_buffer *)__mptr;
#line 270
  if ((unsigned int )buf->flags != 1U) {
#line 271
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"),
                         "i" (271), "i" (12UL));
    ldv_51843: ;
#line 271
    goto ldv_51843;
  } else {

  }
#line 274
  saa7164_buffer_activate(buf, i);
#line 277
  tmp___2 = i;
#line 277
  i = i + 1;
#line 277
  if (tmp___2 > (int )port->hwcfg.buffercount) {
#line 278
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"),
                         "i" (278), "i" (12UL));
    ldv_51844: ;
#line 278
    goto ldv_51844;
  } else {

  }
#line 267
  c = n;
#line 267
  n = c->next;
  ldv_51846: ;
#line 267
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )c) {
#line 269
    goto ldv_51845;
  } else {

  }
#line 281
  mutex_unlock(& port->dmaqueue_lock);
#line 283
  return (0);
}
}
#line 286 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"
struct saa7164_user_buffer *saa7164_buffer_alloc_user(struct saa7164_dev *dev , u32 len ) 
{ 
  struct saa7164_user_buffer *buf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 291
  tmp = kzalloc(40UL, 208U);
#line 291
  buf = (struct saa7164_user_buffer *)tmp;
#line 292
  if ((unsigned long )buf == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 293
    return ((struct saa7164_user_buffer *)0);
  } else {

  }
#line 295
  tmp___0 = kzalloc((size_t )len, 208U);
#line 295
  buf->data = (u8 *)tmp___0;
#line 297
  if ((unsigned long )buf->data == (unsigned long )((u8 *)0U)) {
#line 298
    kfree((void const   *)buf);
#line 299
    return ((struct saa7164_user_buffer *)0);
  } else {

  }
#line 302
  buf->actual_size = len;
#line 303
  buf->pos = 0U;
#line 304
  buf->crc = 0U;
#line 306
  if ((saa_debug & 512U) != 0U) {
#line 306
    printk("\017%s: %s()   allocated user buffer @ 0x%p\n", (char *)(& dev->name),
           "saa7164_buffer_alloc_user", buf);
  } else {

  }
#line 309
  return (buf);
}
}
#line 312 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.c"
void saa7164_buffer_dealloc_user(struct saa7164_user_buffer *buf ) 
{ 


  {
#line 314
  if ((unsigned long )buf == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 315
    return;
  } else {

  }
#line 317
  kfree((void const   *)buf->data);
#line 318
  buf->data = (u8 *)0U;
#line 320
  kfree((void const   *)buf);
#line 321
  return;
}
}
#line 256 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
bool ldv_queue_work_on_393(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 260
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 260
  ldv_func_res = tmp;
#line 262
  activate_work_3(ldv_func_arg3, 2);
#line 264
  return (ldv_func_res);
}
}
#line 267 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
bool ldv_queue_delayed_work_on_394(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 271
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 271
  ldv_func_res = tmp;
#line 273
  activate_work_3(& ldv_func_arg3->work, 2);
#line 275
  return (ldv_func_res);
}
}
#line 278 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
bool ldv_queue_work_on_395(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 282
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 282
  ldv_func_res = tmp;
#line 284
  activate_work_3(ldv_func_arg3, 2);
#line 286
  return (ldv_func_res);
}
}
#line 289 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
void ldv_flush_workqueue_396(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 292
  flush_workqueue(ldv_func_arg1);
#line 294
  call_and_disable_all_3(2);
#line 295
  return;
}
}
#line 297 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
bool ldv_queue_delayed_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 301
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 301
  ldv_func_res = tmp;
#line 303
  activate_work_3(& ldv_func_arg3->work, 2);
#line 305
  return (ldv_func_res);
}
}
#line 343 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
void *ldv_kmem_cache_alloc_403(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 346
  ldv_check_alloc_flags(flags);
#line 347
  tmp = ldv_undef_ptr();
#line 347
  return (tmp);
}
}
#line 385 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
int ldv_pskb_expand_head_409(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 388
  ldv_check_alloc_flags(flags);
#line 389
  tmp = ldv_undef_ptr();
#line 389
  return ((int )((long )tmp));
}
}
#line 399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
struct sk_buff *ldv_skb_clone_411(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 402
  ldv_check_alloc_flags(flags);
#line 403
  tmp = ldv_undef_ptr();
#line 403
  return ((struct sk_buff *)tmp);
}
}
#line 413 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
struct sk_buff *ldv_skb_copy_413(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 416
  ldv_check_alloc_flags(flags);
#line 417
  tmp = ldv_undef_ptr();
#line 417
  return ((struct sk_buff *)tmp);
}
}
#line 420 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_414(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 423
  ldv_check_alloc_flags(flags);
#line 424
  tmp = ldv_undef_ptr();
#line 424
  return ((struct sk_buff *)tmp);
}
}
#line 427 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_415(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 430
  ldv_check_alloc_flags(flags);
#line 431
  tmp = ldv_undef_ptr();
#line 431
  return ((struct sk_buff *)tmp);
}
}
#line 434 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_416(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 437
  ldv_check_alloc_flags(flags);
#line 438
  tmp = ldv_undef_ptr();
#line 438
  return ((struct sk_buff *)tmp);
}
}
#line 441 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
int ldv_pskb_expand_head_417(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 444
  ldv_check_alloc_flags(flags);
#line 445
  tmp = ldv_undef_ptr();
#line 445
  return ((int )((long )tmp));
}
}
#line 448 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
int ldv_pskb_expand_head_418(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 451
  ldv_check_alloc_flags(flags);
#line 452
  tmp = ldv_undef_ptr();
#line 452
  return ((int )((long )tmp));
}
}
#line 455 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-buffer.o.c.prepared"
struct sk_buff *ldv_skb_clone_419(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 459
  tmp = ldv_undef_ptr();
#line 459
  return ((struct sk_buff *)tmp);
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 402
extern int sprintf(char * , char const   *  , ...) ;
#line 13 "./arch/x86/include/asm/cmpxchg.h"
extern void __cmpxchg_wrong_size(void) ;
#line 15
extern void __xadd_wrong_size(void) ;
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5763;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5763: ;
#line 157
  return (__ret + i);
}
}
#line 167 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
#line 169
  tmp = atomic_add_return(- i, v);
#line 169
  return (tmp);
}
}
#line 175 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new ) 
{ 
  int __ret ;
  int __old ;
  int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 177
  __old = old;
#line 177
  __new = new;
#line 177
  switch (4UL) {
  case 1UL: 
#line 177
  __ptr = (u8 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                       "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5783;
  case 2UL: 
#line 177
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                       "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5783;
  case 4UL: 
#line 177
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                       "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5783;
  case 8UL: 
#line 177
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                       "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5783;
  default: 
#line 177
  __cmpxchg_wrong_size();
  }
  ldv_5783: ;
#line 177
  return (__ret);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_439(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_441(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_440(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_443(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_442(struct workqueue_struct *ldv_func_arg1 ) ;
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_449(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 652 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 677
extern void __copy_to_user_overflow(void) ;
#line 728 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 730
  tmp = __builtin_object_size(from, 0);
#line 730
  sz = (int )tmp;
#line 732
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
#line 735
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 735
  if (tmp___0 != 0L) {
#line 736
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 740
    __copy_to_user_overflow();
  }
#line 742
  return (n);
}
}
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_457(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_465(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_459(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_455(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_463(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_464(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_460(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_461(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_462(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 149 "include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 156 "include/media/v4l2-dev.h"
__inline static int video_register_device(struct video_device *vdev , int type , int nr ) 
{ 
  int tmp ;

  {
#line 159
  tmp = __video_register_device(vdev, type, nr, 1, (vdev->fops)->owner);
#line 159
  return (tmp);
}
}
#line 172
extern void video_unregister_device(struct video_device * ) ;
#line 176
extern struct video_device *video_device_alloc(void) ;
#line 179
extern void video_device_release(struct video_device * ) ;
#line 207 "include/media/v4l2-dev.h"
__inline static void *video_get_drvdata(struct video_device *vdev ) 
{ 
  void *tmp ;

  {
#line 209
  tmp = dev_get_drvdata((struct device  const  *)(& vdev->dev));
#line 209
  return (tmp);
}
}
#line 212 "include/media/v4l2-dev.h"
__inline static void video_set_drvdata(struct video_device *vdev , void *data ) 
{ 


  {
#line 214
  dev_set_drvdata(& vdev->dev, data);
#line 215
  return;
}
}
#line 217
extern struct video_device *video_devdata(struct file * ) ;
#line 231 "include/media/v4l2-dev.h"
__inline static int video_is_registered(struct video_device *vdev ) 
{ 
  int tmp ;

  {
#line 233
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& vdev->flags));
#line 233
  return (tmp);
}
}
#line 85 "include/media/v4l2-common.h"
extern int v4l2_ctrl_query_fill(struct v4l2_queryctrl * , s32  , s32  , s32  , s32  ) ;
#line 333 "include/media/v4l2-ioctl.h"
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 28 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static struct saa7164_tvnorm saa7164_tvnorms[2U]  = {      {(char *)"NTSC-M", 4096ULL}, 
        {(char *)"NTSC-JP", 8192ULL}};
#line 38 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static u32 const   saa7164_v4l2_ctrls[15U]  = 
#line 38
  {      9963776U,      9963777U,      9963778U,      9963779U, 
        9963781U,      9963803U,      10029312U,      10029513U, 
        10029514U,      10029515U,      10029421U,      10029518U, 
        10029519U,      10029520U,      0U};
#line 59 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static void saa7164_encoder_configure(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;

  {
#line 61
  dev = port->dev;
#line 62
  if ((saa_debug & 1024U) != 0U) {
#line 62
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_encoder_configure");
  } else {

  }
#line 64
  port->encoder_params.width = port->width;
#line 65
  port->encoder_params.height = port->height;
#line 66
  port->encoder_params.is_50hz = (port->encodernorm.id & 16713471ULL) != 0ULL;
#line 70
  saa7164_api_initialize_dif(port);
#line 73
  saa7164_api_configure_dif(port, (u32 )port->encodernorm.id);
#line 76
  saa7164_api_set_audio_std(port);
#line 77
  return;
}
}
#line 79 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_encoder_buffers_dealloc(struct saa7164_port *port ) 
{ 
  struct list_head *c ;
  struct list_head *n ;
  struct list_head *p ;
  struct list_head *q ;
  struct list_head *l ;
  struct list_head *v ;
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct saa7164_user_buffer *ubuf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 82
  dev = port->dev;
#line 87
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 89
  if ((saa_debug & 1024U) != 0U) {
#line 89
    printk("\017%s: %s(port=%d) dmaqueue\n", (char *)(& dev->name), "saa7164_encoder_buffers_dealloc",
           port->nr);
  } else {

  }
#line 90
  c = port->dmaqueue.list.next;
#line 90
  n = c->next;
#line 90
  goto ldv_51812;
  ldv_51811: 
#line 91
  __mptr = (struct list_head  const  *)c;
#line 91
  buf = (struct saa7164_buffer *)__mptr;
#line 92
  list_del(c);
#line 93
  saa7164_buffer_dealloc(buf);
#line 90
  c = n;
#line 90
  n = c->next;
  ldv_51812: ;
#line 90
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )c) {
#line 92
    goto ldv_51811;
  } else {

  }

#line 96
  if ((saa_debug & 1024U) != 0U) {
#line 96
    printk("\017%s: %s(port=%d) used\n", (char *)(& dev->name), "saa7164_encoder_buffers_dealloc",
           port->nr);
  } else {

  }
#line 97
  p = port->list_buf_used.list.next;
#line 97
  q = p->next;
#line 97
  goto ldv_51817;
  ldv_51816: 
#line 98
  __mptr___0 = (struct list_head  const  *)p;
#line 98
  ubuf = (struct saa7164_user_buffer *)__mptr___0;
#line 99
  list_del(p);
#line 100
  saa7164_buffer_dealloc_user(ubuf);
#line 97
  p = q;
#line 97
  q = p->next;
  ldv_51817: ;
#line 97
  if ((unsigned long )(& port->list_buf_used.list) != (unsigned long )p) {
#line 99
    goto ldv_51816;
  } else {

  }

#line 103
  if ((saa_debug & 1024U) != 0U) {
#line 103
    printk("\017%s: %s(port=%d) free\n", (char *)(& dev->name), "saa7164_encoder_buffers_dealloc",
           port->nr);
  } else {

  }
#line 104
  l = port->list_buf_free.list.next;
#line 104
  v = l->next;
#line 104
  goto ldv_51822;
  ldv_51821: 
#line 105
  __mptr___1 = (struct list_head  const  *)l;
#line 105
  ubuf = (struct saa7164_user_buffer *)__mptr___1;
#line 106
  list_del(l);
#line 107
  saa7164_buffer_dealloc_user(ubuf);
#line 104
  l = v;
#line 104
  v = l->next;
  ldv_51822: ;
#line 104
  if ((unsigned long )(& port->list_buf_free.list) != (unsigned long )l) {
#line 106
    goto ldv_51821;
  } else {

  }
#line 110
  mutex_unlock(& port->dmaqueue_lock);
#line 111
  if ((saa_debug & 1024U) != 0U) {
#line 111
    printk("\017%s: %s(port=%d) done\n", (char *)(& dev->name), "saa7164_encoder_buffers_dealloc",
           port->nr);
  } else {

  }
#line 113
  return (0);
}
}
#line 117 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_encoder_buffers_alloc(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct saa7164_user_buffer *ubuf ;
  struct tmHWStreamParameters *params ;
  int result ;
  int i ;
  int len ;

  {
#line 119
  dev = port->dev;
#line 122
  params = & port->hw_streamingparams;
#line 123
  result = -19;
#line 124
  len = 0;
#line 126
  if ((saa_debug & 1024U) != 0U) {
#line 126
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_encoder_buffers_alloc");
  } else {

  }
#line 128
  if (port->encoder_params.stream_type == 0U) {
#line 130
    if ((saa_debug & 1024U) != 0U) {
#line 130
      printk("\017%s: %s() type=V4L2_MPEG_STREAM_TYPE_MPEG2_PS\n", (char *)(& dev->name),
             "saa7164_encoder_buffers_alloc");
    } else {

    }
#line 133
    params->samplesperline = 128U;
#line 134
    params->numberoflines = 256U;
#line 135
    params->pitch = 128U;
#line 136
    params->numpagetables = 10U;
  } else
#line 139
  if (port->encoder_params.stream_type == 1U) {
#line 141
    if ((saa_debug & 1024U) != 0U) {
#line 141
      printk("\017%s: %s() type=V4L2_MPEG_STREAM_TYPE_MPEG2_TS\n", (char *)(& dev->name),
             "saa7164_encoder_buffers_alloc");
    } else {

    }
#line 144
    params->samplesperline = 188U;
#line 145
    params->numberoflines = 312U;
#line 146
    params->pitch = 188U;
#line 147
    params->numpagetables = 16U;
  } else {
#line 150
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"),
                         "i" (150), "i" (12UL));
    ldv_51835: ;
#line 150
    goto ldv_51835;
  }
#line 153
  params->bitspersample = 8U;
#line 154
  params->linethreshold = 0U;
#line 155
  params->pagetablelistvirt = (u64 **)0ULL;
#line 156
  params->pagetablelistphys = (u64 *)0ULL;
#line 157
  params->numpagetableentries = (u32 )port->hwcfg.buffercount;
#line 160
  i = 0;
#line 160
  goto ldv_51838;
  ldv_51837: 
#line 161
  buf = saa7164_buffer_alloc(port, params->numberoflines * params->pitch);
#line 165
  if ((unsigned long )buf == (unsigned long )((struct saa7164_buffer *)0)) {
#line 166
    printk("\v%s() failed (errno = %d), unable to allocate buffer\n", "saa7164_encoder_buffers_alloc",
           result);
#line 169
    result = -12;
#line 170
    goto failed;
  } else {
#line 173
    mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 174
    list_add_tail(& buf->list, & port->dmaqueue.list);
#line 175
    mutex_unlock(& port->dmaqueue_lock);
  }
#line 160
  i = i + 1;
  ldv_51838: ;
#line 160
  if ((int )port->hwcfg.buffercount > i) {
#line 162
    goto ldv_51837;
  } else {

  }
#line 183
  len = (int )(params->numberoflines * params->pitch);
#line 185
  if (encoder_buffers <= 15U) {
#line 186
    encoder_buffers = 16U;
  } else {

  }
#line 187
  if (encoder_buffers > 512U) {
#line 188
    encoder_buffers = 512U;
  } else {

  }
#line 190
  i = 0;
#line 190
  goto ldv_51841;
  ldv_51840: 
#line 192
  ubuf = saa7164_buffer_alloc_user(dev, (u32 )len);
#line 193
  if ((unsigned long )ubuf != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 194
    mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 195
    list_add_tail(& ubuf->list, & port->list_buf_free.list);
#line 196
    mutex_unlock(& port->dmaqueue_lock);
  } else {

  }
#line 190
  i = i + 1;
  ldv_51841: ;
#line 190
  if ((unsigned int )i < encoder_buffers) {
#line 192
    goto ldv_51840;
  } else {

  }
#line 201
  result = 0;
  failed: ;
#line 204
  return (result);
}
}
#line 207 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_encoder_initialize(struct saa7164_port *port ) 
{ 


  {
#line 209
  saa7164_encoder_configure(port);
#line 210
  return (0);
}
}
#line 214 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_s_std(struct file *file , void *priv , v4l2_std_id id ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  unsigned int i ;

  {
#line 216
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 217
  port = fh->port;
#line 218
  dev = port->dev;
#line 221
  if ((saa_debug & 1024U) != 0U) {
#line 221
    printk("\017%s: %s(id=0x%x)\n", (char *)(& dev->name), "vidioc_s_std", (unsigned int )id);
  } else {

  }
#line 223
  i = 0U;
#line 223
  goto ldv_51860;
  ldv_51859: ;
#line 224
  if ((saa7164_tvnorms[i].id & id) != 0ULL) {
#line 225
    goto ldv_51858;
  } else {

  }
#line 223
  i = i + 1U;
  ldv_51860: ;
#line 223
  if (i <= 1U) {
#line 225
    goto ldv_51859;
  } else {

  }
  ldv_51858: ;
#line 227
  if (i == 2U) {
#line 228
    return (-22);
  } else {

  }
#line 230
  port->encodernorm = saa7164_tvnorms[i];
#line 231
  port->std = id;
#line 236
  saa7164_api_set_audio_std(port);
#line 238
  if ((saa_debug & 1024U) != 0U) {
#line 238
    printk("\017%s: %s(id=0x%x) OK\n", (char *)(& dev->name), "vidioc_s_std", (unsigned int )id);
  } else {

  }
#line 240
  return (0);
}
}
#line 243 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_g_std(struct file *file , void *priv , v4l2_std_id *id ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;

  {
#line 245
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 246
  port = fh->port;
#line 248
  *id = port->std;
#line 249
  return (0);
}
}
#line 252 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_enum_input(struct file *file , void *priv , struct v4l2_input *i ) 
{ 
  int n ;
  char *inputs[7U] ;

  {
#line 257
  inputs[0] = (char *)"tuner";
#line 257
  inputs[1] = (char *)"composite";
#line 257
  inputs[2] = (char *)"svideo";
#line 257
  inputs[3] = (char *)"aux";
#line 257
  inputs[4] = (char *)"composite 2";
#line 257
  inputs[5] = (char *)"svideo 2";
#line 257
  inputs[6] = (char *)"aux 2";
#line 260
  if (i->index > 6U) {
#line 261
    return (-22);
  } else {

  }
#line 263
  strcpy((char *)(& i->name), (char const   *)inputs[i->index]);
#line 265
  if (i->index == 0U) {
#line 266
    i->type = 1U;
  } else {
#line 268
    i->type = 2U;
  }
#line 270
  n = 0;
#line 270
  goto ldv_51880;
  ldv_51879: 
#line 271
  i->std = i->std | saa7164_tvnorms[n].id;
#line 270
  n = n + 1;
  ldv_51880: ;
#line 270
  if ((unsigned int )n <= 1U) {
#line 272
    goto ldv_51879;
  } else {

  }

#line 273
  return (0);
}
}
#line 276 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_g_input(struct file *file , void *priv , unsigned int *i ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  int tmp ;

  {
#line 278
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 279
  port = fh->port;
#line 280
  dev = port->dev;
#line 282
  tmp = saa7164_api_get_videomux(port);
#line 282
  if (tmp != 0) {
#line 283
    return (-5);
  } else {

  }
#line 285
  *i = (unsigned int )((int )port->mux_input + -1);
#line 287
  if ((saa_debug & 1024U) != 0U) {
#line 287
    printk("\017%s: %s() input=%d\n", (char *)(& dev->name), "vidioc_g_input", *i);
  } else {

  }
#line 289
  return (0);
}
}
#line 292 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_s_input(struct file *file , void *priv , unsigned int i ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  int tmp ;

  {
#line 294
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 295
  port = fh->port;
#line 296
  dev = port->dev;
#line 298
  if ((saa_debug & 1024U) != 0U) {
#line 298
    printk("\017%s: %s() input=%d\n", (char *)(& dev->name), "vidioc_s_input", i);
  } else {

  }
#line 300
  if (i > 6U) {
#line 301
    return (-22);
  } else {

  }
#line 303
  port->mux_input = (unsigned int )((u8 )i) + 1U;
#line 305
  tmp = saa7164_api_set_videomux(port);
#line 305
  if (tmp != 0) {
#line 306
    return (-5);
  } else {

  }
#line 308
  return (0);
}
}
#line 311 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_g_tuner(struct file *file , void *priv , struct v4l2_tuner *t ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 314
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 315
  port = fh->port;
#line 316
  dev = port->dev;
#line 318
  if (t->index != 0U) {
#line 319
    return (-22);
  } else {

  }
#line 321
  strcpy((char *)(& t->name), "tuner");
#line 322
  t->type = 2U;
#line 323
  t->capability = 18U;
#line 325
  if ((saa_debug & 1024U) != 0U) {
#line 325
    printk("\017%s: VIDIOC_G_TUNER: tuner type %d\n", (char *)(& dev->name), t->type);
  } else {

  }
#line 327
  return (0);
}
}
#line 330 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_s_tuner(struct file *file , void *priv , struct v4l2_tuner  const  *t ) 
{ 


  {
#line 334
  return (0);
}
}
#line 337 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_g_frequency(struct file *file , void *priv , struct v4l2_frequency *f ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;

  {
#line 340
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 341
  port = fh->port;
#line 343
  f->type = 2U;
#line 344
  f->frequency = port->freq;
#line 346
  return (0);
}
}
#line 349 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_s_frequency(struct file *file , void *priv , struct v4l2_frequency  const  *f ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  struct saa7164_port *tsport ;
  struct dvb_frontend *fe ;
  struct analog_parameters params ;

  {
#line 352
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 353
  port = fh->port;
#line 354
  dev = port->dev;
#line 359
  params.frequency = f->frequency;
#line 359
  params.mode = 2U;
#line 359
  params.audmode = 1U;
#line 359
  params.std = port->encodernorm.id;
#line 367
  if ((saa_debug & 1024U) != 0U) {
#line 367
    printk("\017%s: %s() frequency=%d tuner=%d\n", (char *)(& dev->name), "vidioc_s_frequency",
           f->frequency, f->tuner);
  } else {

  }
#line 370
  if ((unsigned int )f->tuner != 0U) {
#line 371
    return (-22);
  } else {

  }
#line 373
  if ((unsigned int )f->type != 2U) {
#line 374
    return (-22);
  } else {

  }
#line 376
  port->freq = f->frequency;
#line 379
  if (port->nr == 2) {
#line 380
    tsport = (struct saa7164_port *)(& dev->ports);
  } else
#line 382
  if (port->nr == 3) {
#line 383
    tsport = (struct saa7164_port *)(& dev->ports) + 1UL;
  } else {
#line 385
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"),
                         "i" (385), "i" (12UL));
    ldv_51932: ;
#line 385
    goto ldv_51932;
  }
#line 387
  fe = tsport->dvb.frontend;
#line 389
  if ((unsigned long )fe != (unsigned long )((struct dvb_frontend *)0) && (unsigned long )fe->ops.tuner_ops.set_analog_params != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                                                                                                           struct analog_parameters * ))0)) {
#line 390
    (*(fe->ops.tuner_ops.set_analog_params))(fe, & params);
  } else {
#line 392
    printk("\v%s() No analog tuner, aborting\n", "vidioc_s_frequency");
  }
#line 394
  saa7164_encoder_initialize(port);
#line 396
  return (0);
}
}
#line 399 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_g_ctrl(struct file *file , void *priv , struct v4l2_control *ctl ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 402
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 403
  port = fh->port;
#line 404
  dev = port->dev;
#line 406
  if ((saa_debug & 1024U) != 0U) {
#line 406
    printk("\017%s: %s(id=%d, value=%d)\n", (char *)(& dev->name), "vidioc_g_ctrl",
           ctl->id, ctl->value);
  } else {

  }
#line 409
  switch (ctl->id) {
  case 9963776U: 
#line 411
  ctl->value = (__s32 )port->ctl_brightness;
#line 412
  goto ldv_51943;
  case 9963777U: 
#line 414
  ctl->value = (__s32 )port->ctl_contrast;
#line 415
  goto ldv_51943;
  case 9963778U: 
#line 417
  ctl->value = (__s32 )port->ctl_saturation;
#line 418
  goto ldv_51943;
  case 9963779U: 
#line 420
  ctl->value = (__s32 )port->ctl_hue;
#line 421
  goto ldv_51943;
  case 9963803U: 
#line 423
  ctl->value = (__s32 )port->ctl_sharpness;
#line 424
  goto ldv_51943;
  case 9963781U: 
#line 426
  ctl->value = (__s32 )port->ctl_volume;
#line 427
  goto ldv_51943;
  default: ;
#line 429
  return (-22);
  }
  ldv_51943: ;
#line 432
  return (0);
}
}
#line 435 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_s_ctrl(struct file *file , void *priv , struct v4l2_control *ctl ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 438
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 439
  port = fh->port;
#line 440
  dev = port->dev;
#line 441
  ret = 0;
#line 443
  if ((saa_debug & 1024U) != 0U) {
#line 443
    printk("\017%s: %s(id=%d, value=%d)\n", (char *)(& dev->name), "vidioc_s_ctrl",
           ctl->id, ctl->value);
  } else {

  }
#line 446
  switch (ctl->id) {
  case 9963776U: ;
#line 448
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 449
    port->ctl_brightness = (u16 )ctl->value;
#line 450
    saa7164_api_set_usercontrol(port, 2);
  } else {
#line 453
    ret = -22;
  }
#line 454
  goto ldv_51961;
  case 9963777U: ;
#line 456
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 457
    port->ctl_contrast = (u16 )ctl->value;
#line 458
    saa7164_api_set_usercontrol(port, 3);
  } else {
#line 460
    ret = -22;
  }
#line 461
  goto ldv_51961;
  case 9963778U: ;
#line 463
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 464
    port->ctl_saturation = (u16 )ctl->value;
#line 465
    saa7164_api_set_usercontrol(port, 7);
  } else {
#line 468
    ret = -22;
  }
#line 469
  goto ldv_51961;
  case 9963779U: ;
#line 471
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 472
    port->ctl_hue = (u16 )ctl->value;
#line 473
    saa7164_api_set_usercontrol(port, 6);
  } else {
#line 475
    ret = -22;
  }
#line 476
  goto ldv_51961;
  case 9963803U: ;
#line 478
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 479
    port->ctl_sharpness = (u16 )ctl->value;
#line 480
    saa7164_api_set_usercontrol(port, 8);
  } else {
#line 482
    ret = -22;
  }
#line 483
  goto ldv_51961;
  case 9963781U: ;
#line 485
  if (ctl->value >= -83 && ctl->value <= 24) {
#line 486
    port->ctl_volume = (s8 )ctl->value;
#line 487
    saa7164_api_set_audio_volume(port, (int )port->ctl_volume);
  } else {
#line 489
    ret = -22;
  }
#line 490
  goto ldv_51961;
  default: 
#line 492
  ret = -22;
  }
  ldv_51961: ;
#line 495
  return (ret);
}
}
#line 498 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_get_ctrl(struct saa7164_port *port , struct v4l2_ext_control *ctrl ) 
{ 
  struct saa7164_encoder_params *params ;

  {
#line 501
  params = & port->encoder_params;
#line 503
  switch (ctrl->id) {
  case 10029519U: 
#line 505
  ctrl->__annonCompField63.value = (__s32 )params->bitrate;
#line 506
  goto ldv_51974;
  case 10029312U: 
#line 508
  ctrl->__annonCompField63.value = (__s32 )params->stream_type;
#line 509
  goto ldv_51974;
  case 10029421U: 
#line 511
  ctrl->__annonCompField63.value = (__s32 )params->ctl_mute;
#line 512
  goto ldv_51974;
  case 10029513U: 
#line 514
  ctrl->__annonCompField63.value = (__s32 )params->ctl_aspect;
#line 515
  goto ldv_51974;
  case 10029518U: 
#line 517
  ctrl->__annonCompField63.value = (__s32 )params->bitrate_mode;
#line 518
  goto ldv_51974;
  case 10029514U: 
#line 520
  ctrl->__annonCompField63.value = (__s32 )params->refdist;
#line 521
  goto ldv_51974;
  case 10029520U: 
#line 523
  ctrl->__annonCompField63.value = (__s32 )params->bitrate_peak;
#line 524
  goto ldv_51974;
  case 10029515U: 
#line 526
  ctrl->__annonCompField63.value = (__s32 )params->gop_size;
#line 527
  goto ldv_51974;
  default: ;
#line 529
  return (-22);
  }
  ldv_51974: ;
#line 531
  return (0);
}
}
#line 534 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_g_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctrls ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  int i ;
  int err ;
  struct v4l2_ext_control *ctrl ;

  {
#line 537
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 538
  port = fh->port;
#line 539
  err = 0;
#line 541
  if (ctrls->ctrl_class == 10027008U) {
#line 542
    i = 0;
#line 542
    goto ldv_51995;
    ldv_51994: 
#line 543
    ctrl = ctrls->controls + (unsigned long )i;
#line 545
    err = saa7164_get_ctrl(port, ctrl);
#line 546
    if (err != 0) {
#line 547
      ctrls->error_idx = (__u32 )i;
#line 548
      goto ldv_51993;
    } else {

    }
#line 542
    i = i + 1;
    ldv_51995: ;
#line 542
    if ((__u32 )i < ctrls->count) {
#line 544
      goto ldv_51994;
    } else {

    }
    ldv_51993: ;
#line 551
    return (err);
  } else {

  }
#line 555
  return (-22);
}
}
#line 558 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_try_ctrl(struct v4l2_ext_control *ctrl , int ac3 ) 
{ 
  int ret ;

  {
#line 560
  ret = -22;
#line 562
  switch (ctrl->id) {
  case 10029519U: ;
#line 564
  if (ctrl->__annonCompField63.value > 999999 && ctrl->__annonCompField63.value <= 6500000) {
#line 566
    ret = 0;
  } else {

  }
#line 567
  goto ldv_52002;
  case 10029312U: ;
#line 569
  if (ctrl->__annonCompField63.value == 0 || ctrl->__annonCompField63.value == 1) {
#line 571
    ret = 0;
  } else {

  }
#line 572
  goto ldv_52002;
  case 10029421U: ;
#line 574
  if (ctrl->__annonCompField63.value >= 0 && ctrl->__annonCompField63.value <= 1) {
#line 576
    ret = 0;
  } else {

  }
#line 577
  goto ldv_52002;
  case 10029513U: ;
#line 579
  if (ctrl->__annonCompField63.value >= 0 && ctrl->__annonCompField63.value <= 3) {
#line 581
    ret = 0;
  } else {

  }
#line 582
  goto ldv_52002;
  case 10029515U: ;
#line 584
  if (ctrl->__annonCompField63.value >= 0 && ctrl->__annonCompField63.value <= 255) {
#line 586
    ret = 0;
  } else {

  }
#line 587
  goto ldv_52002;
  case 10029518U: ;
#line 589
  if (ctrl->__annonCompField63.value == 0 || ctrl->__annonCompField63.value == 1) {
#line 591
    ret = 0;
  } else {

  }
#line 592
  goto ldv_52002;
  case 10029514U: ;
#line 594
  if (ctrl->__annonCompField63.value > 0 && ctrl->__annonCompField63.value <= 3) {
#line 596
    ret = 0;
  } else {

  }
#line 597
  goto ldv_52002;
  case 10029520U: ;
#line 599
  if (ctrl->__annonCompField63.value > 999999 && ctrl->__annonCompField63.value <= 6500000) {
#line 601
    ret = 0;
  } else {

  }
#line 602
  goto ldv_52002;
  default: 
#line 604
  ret = -22;
  }
  ldv_52002: ;
#line 607
  return (ret);
}
}
#line 610 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_try_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctrls ) 
{ 
  int i ;
  int err ;
  struct v4l2_ext_control *ctrl ;

  {
#line 613
  err = 0;
#line 615
  if (ctrls->ctrl_class == 10027008U) {
#line 616
    i = 0;
#line 616
    goto ldv_52021;
    ldv_52020: 
#line 617
    ctrl = ctrls->controls + (unsigned long )i;
#line 619
    err = saa7164_try_ctrl(ctrl, 0);
#line 620
    if (err != 0) {
#line 621
      ctrls->error_idx = (__u32 )i;
#line 622
      goto ldv_52019;
    } else {

    }
#line 616
    i = i + 1;
    ldv_52021: ;
#line 616
    if ((__u32 )i < ctrls->count) {
#line 618
      goto ldv_52020;
    } else {

    }
    ldv_52019: ;
#line 625
    return (err);
  } else {

  }
#line 628
  return (-22);
}
}
#line 631 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_set_ctrl(struct saa7164_port *port , struct v4l2_ext_control *ctrl ) 
{ 
  struct saa7164_encoder_params *params ;
  int ret ;

  {
#line 634
  params = & port->encoder_params;
#line 635
  ret = 0;
#line 637
  switch (ctrl->id) {
  case 10029519U: 
#line 639
  params->bitrate = (u32 )ctrl->__annonCompField63.value;
#line 640
  goto ldv_52029;
  case 10029312U: 
#line 642
  params->stream_type = (u32 )ctrl->__annonCompField63.value;
#line 643
  goto ldv_52029;
  case 10029421U: 
#line 645
  params->ctl_mute = (u32 )ctrl->__annonCompField63.value;
#line 646
  ret = saa7164_api_audio_mute(port, (int )params->ctl_mute);
#line 647
  if (ret != 0) {
#line 648
    printk("\v%s() error, ret = 0x%x\n", "saa7164_set_ctrl", ret);
#line 650
    ret = -5;
  } else {

  }
#line 652
  goto ldv_52029;
  case 10029513U: 
#line 654
  params->ctl_aspect = (u32 )ctrl->__annonCompField63.value;
#line 655
  ret = saa7164_api_set_aspect_ratio(port);
#line 656
  if (ret != 0) {
#line 657
    printk("\v%s() error, ret = 0x%x\n", "saa7164_set_ctrl", ret);
#line 659
    ret = -5;
  } else {

  }
#line 661
  goto ldv_52029;
  case 10029518U: 
#line 663
  params->bitrate_mode = (u32 )ctrl->__annonCompField63.value;
#line 664
  goto ldv_52029;
  case 10029514U: 
#line 666
  params->refdist = (u32 )ctrl->__annonCompField63.value;
#line 667
  goto ldv_52029;
  case 10029520U: 
#line 669
  params->bitrate_peak = (u32 )ctrl->__annonCompField63.value;
#line 670
  goto ldv_52029;
  case 10029515U: 
#line 672
  params->gop_size = (u32 )ctrl->__annonCompField63.value;
#line 673
  goto ldv_52029;
  default: ;
#line 675
  return (-22);
  }
  ldv_52029: ;
#line 680
  return (ret);
}
}
#line 683 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_s_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctrls ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  int i ;
  int err ;
  struct v4l2_ext_control *ctrl ;

  {
#line 686
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 687
  port = fh->port;
#line 688
  err = 0;
#line 690
  if (ctrls->ctrl_class == 10027008U) {
#line 691
    i = 0;
#line 691
    goto ldv_52051;
    ldv_52050: 
#line 692
    ctrl = ctrls->controls + (unsigned long )i;
#line 694
    err = saa7164_try_ctrl(ctrl, 0);
#line 695
    if (err != 0) {
#line 696
      ctrls->error_idx = (__u32 )i;
#line 697
      goto ldv_52049;
    } else {

    }
#line 699
    err = saa7164_set_ctrl(port, ctrl);
#line 700
    if (err != 0) {
#line 701
      ctrls->error_idx = (__u32 )i;
#line 702
      goto ldv_52049;
    } else {

    }
#line 691
    i = i + 1;
    ldv_52051: ;
#line 691
    if ((__u32 )i < ctrls->count) {
#line 693
      goto ldv_52050;
    } else {

    }
    ldv_52049: ;
#line 705
    return (err);
  } else {

  }
#line 709
  return (-22);
}
}
#line 712 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_querycap(struct file *file , void *priv , struct v4l2_capability *cap ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  char const   *tmp ;

  {
#line 715
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 716
  port = fh->port;
#line 717
  dev = port->dev;
#line 719
  strcpy((char *)(& cap->driver), (char const   *)(& dev->name));
#line 720
  strlcpy((char *)(& cap->card), (char const   *)saa7164_boards[dev->board].name,
          32UL);
#line 722
  tmp = pci_name((struct pci_dev  const  *)dev->pci);
#line 722
  sprintf((char *)(& cap->bus_info), "PCI:%s", tmp);
#line 724
  cap->device_caps = 16842753U;
#line 729
  cap->capabilities = cap->device_caps | 2147483664U;
#line 733
  return (0);
}
}
#line 736 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_enum_fmt_vid_cap(struct file *file , void *priv , struct v4l2_fmtdesc *f ) 
{ 


  {
#line 739
  if (f->index != 0U) {
#line 740
    return (-22);
  } else {

  }
#line 742
  strlcpy((char *)(& f->description), "MPEG", 32UL);
#line 743
  f->pixelformat = 1195724877U;
#line 745
  return (0);
}
}
#line 748 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_g_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 751
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 752
  port = fh->port;
#line 753
  dev = port->dev;
#line 755
  f->fmt.pix.pixelformat = 1195724877U;
#line 756
  f->fmt.pix.bytesperline = 0U;
#line 757
  f->fmt.pix.sizeimage = port->ts_packet_size * port->ts_packet_count;
#line 759
  f->fmt.pix.colorspace = 0U;
#line 760
  f->fmt.pix.width = port->width;
#line 761
  f->fmt.pix.height = port->height;
#line 763
  if ((saa_debug & 1024U) != 0U) {
#line 763
    printk("\017%s: VIDIOC_G_FMT: w: %d, h: %d\n", (char *)(& dev->name), port->width,
           port->height);
  } else {

  }
#line 766
  return (0);
}
}
#line 769 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_try_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 772
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 773
  port = fh->port;
#line 774
  dev = port->dev;
#line 776
  f->fmt.pix.pixelformat = 1195724877U;
#line 777
  f->fmt.pix.bytesperline = 0U;
#line 778
  f->fmt.pix.sizeimage = port->ts_packet_size * port->ts_packet_count;
#line 780
  f->fmt.pix.colorspace = 0U;
#line 781
  if ((saa_debug & 1024U) != 0U) {
#line 781
    printk("\017%s: VIDIOC_TRY_FMT: w: %d, h: %d\n", (char *)(& dev->name), port->width,
           port->height);
  } else {

  }
#line 783
  return (0);
}
}
#line 786 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_s_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 789
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 790
  port = fh->port;
#line 791
  dev = port->dev;
#line 793
  f->fmt.pix.pixelformat = 1195724877U;
#line 794
  f->fmt.pix.bytesperline = 0U;
#line 795
  f->fmt.pix.sizeimage = port->ts_packet_size * port->ts_packet_count;
#line 797
  f->fmt.pix.colorspace = 0U;
#line 799
  if ((saa_debug & 1024U) != 0U) {
#line 799
    printk("\017%s: VIDIOC_S_FMT: w: %d, h: %d, f: %d\n", (char *)(& dev->name), f->fmt.pix.width,
           f->fmt.pix.height, f->fmt.pix.field);
  } else {

  }
#line 802
  return (0);
}
}
#line 805 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int fill_queryctrl(struct saa7164_encoder_params *params , struct v4l2_queryctrl *c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 808
  switch (c->id) {
  case 9963776U: 
#line 810
  tmp = v4l2_ctrl_query_fill(c, 0, 255, 1, 127);
#line 810
  return (tmp);
  case 9963777U: 
#line 812
  tmp___0 = v4l2_ctrl_query_fill(c, 0, 255, 1, 66);
#line 812
  return (tmp___0);
  case 9963778U: 
#line 814
  tmp___1 = v4l2_ctrl_query_fill(c, 0, 255, 1, 62);
#line 814
  return (tmp___1);
  case 9963779U: 
#line 816
  tmp___2 = v4l2_ctrl_query_fill(c, 0, 255, 1, 128);
#line 816
  return (tmp___2);
  case 9963803U: 
#line 818
  tmp___3 = v4l2_ctrl_query_fill(c, 0, 15, 1, 8);
#line 818
  return (tmp___3);
  case 10029421U: 
#line 820
  tmp___4 = v4l2_ctrl_query_fill(c, 0, 1, 1, 0);
#line 820
  return (tmp___4);
  case 9963781U: 
#line 822
  tmp___5 = v4l2_ctrl_query_fill(c, -83, 24, 1, 20);
#line 822
  return (tmp___5);
  case 10029519U: 
#line 824
  tmp___6 = v4l2_ctrl_query_fill(c, 1000000, 6500000, 100000, 5000000);
#line 824
  return (tmp___6);
  case 10029312U: 
#line 828
  tmp___7 = v4l2_ctrl_query_fill(c, 0, 1, 1, 0);
#line 828
  return (tmp___7);
  case 10029513U: 
#line 833
  tmp___8 = v4l2_ctrl_query_fill(c, 0, 3, 1, 1);
#line 833
  return (tmp___8);
  case 10029515U: 
#line 838
  tmp___9 = v4l2_ctrl_query_fill(c, 1, 255, 1, 15);
#line 838
  return (tmp___9);
  case 10029518U: 
#line 840
  tmp___10 = v4l2_ctrl_query_fill(c, 0, 1, 1, 0);
#line 840
  return (tmp___10);
  case 10029514U: 
#line 845
  tmp___11 = v4l2_ctrl_query_fill(c, 1, 3, 1, 1);
#line 845
  return (tmp___11);
  case 10029520U: 
#line 848
  tmp___12 = v4l2_ctrl_query_fill(c, 1000000, 6500000, 100000, 5000000);
#line 848
  return (tmp___12);
  default: ;
#line 852
  return (-22);
  }
}
}
#line 856 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int vidioc_queryctrl(struct file *file , void *priv , struct v4l2_queryctrl *c ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  int i ;
  int next ;
  u32 id ;
  int tmp ;

  {
#line 859
  fh = (struct saa7164_encoder_fh *)priv;
#line 860
  port = fh->port;
#line 862
  id = c->id;
#line 864
  memset((void *)c, 0, 68UL);
#line 866
  next = (int )id < 0;
#line 867
  c->id = id & 2147483647U;
#line 869
  i = 0;
#line 869
  goto ldv_52123;
  ldv_52122: ;
#line 870
  if (next != 0) {
#line 871
    if (c->id < (__u32 )saa7164_v4l2_ctrls[i]) {
#line 872
      c->id = saa7164_v4l2_ctrls[i];
    } else {
#line 874
      goto ldv_52120;
    }
  } else {

  }
#line 877
  if (c->id == (__u32 )saa7164_v4l2_ctrls[i]) {
#line 878
    tmp = fill_queryctrl(& port->encoder_params, c);
#line 878
    return (tmp);
  } else {

  }
#line 880
  if (c->id < (__u32 )saa7164_v4l2_ctrls[i]) {
#line 881
    goto ldv_52121;
  } else {

  }
  ldv_52120: 
#line 869
  i = i + 1;
  ldv_52123: ;
#line 869
  if ((unsigned int )i <= 14U) {
#line 871
    goto ldv_52122;
  } else {

  }
  ldv_52121: ;
#line 884
  return (-22);
}
}
#line 887 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_encoder_stop_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 889
  dev = port->dev;
#line 892
  ret = saa7164_api_transition_port(port, 0);
#line 893
  if (ret != 0 && ret != 38) {
#line 894
    printk("\v%s() stop transition failed, ret = 0x%x\n", "saa7164_encoder_stop_port",
           ret);
#line 896
    ret = -5;
  } else {
#line 898
    if ((saa_debug & 1024U) != 0U) {
#line 898
      printk("\017%s: %s()    Stopped\n", (char *)(& dev->name), "saa7164_encoder_stop_port");
    } else {

    }
#line 899
    ret = 0;
  }
#line 902
  return (ret);
}
}
#line 905 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_encoder_acquire_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 907
  dev = port->dev;
#line 910
  ret = saa7164_api_transition_port(port, 1);
#line 911
  if (ret != 0 && ret != 38) {
#line 912
    printk("\v%s() acquire transition failed, ret = 0x%x\n", "saa7164_encoder_acquire_port",
           ret);
#line 914
    ret = -5;
  } else {
#line 916
    if ((saa_debug & 1024U) != 0U) {
#line 916
      printk("\017%s: %s() Acquired\n", (char *)(& dev->name), "saa7164_encoder_acquire_port");
    } else {

    }
#line 917
    ret = 0;
  }
#line 920
  return (ret);
}
}
#line 923 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_encoder_pause_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 925
  dev = port->dev;
#line 928
  ret = saa7164_api_transition_port(port, 2);
#line 929
  if (ret != 0 && ret != 38) {
#line 930
    printk("\v%s() pause transition failed, ret = 0x%x\n", "saa7164_encoder_pause_port",
           ret);
#line 932
    ret = -5;
  } else {
#line 934
    if ((saa_debug & 1024U) != 0U) {
#line 934
      printk("\017%s: %s()   Paused\n", (char *)(& dev->name), "saa7164_encoder_pause_port");
    } else {

    }
#line 935
    ret = 0;
  }
#line 938
  return (ret);
}
}
#line 947 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_encoder_stop_streaming(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct saa7164_user_buffer *ubuf ;
  struct list_head *c ;
  struct list_head *n ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 949
  dev = port->dev;
#line 955
  if ((saa_debug & 1024U) != 0U) {
#line 955
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_encoder_stop_streaming",
           port->nr);
  } else {

  }
#line 957
  ret = saa7164_encoder_pause_port(port);
#line 958
  ret = saa7164_encoder_acquire_port(port);
#line 959
  ret = saa7164_encoder_stop_port(port);
#line 961
  if ((saa_debug & 1024U) != 0U) {
#line 961
    printk("\017%s: %s(port=%d) Hardware stopped\n", (char *)(& dev->name), "saa7164_encoder_stop_streaming",
           port->nr);
  } else {

  }
#line 965
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 968
  c = port->dmaqueue.list.next;
#line 968
  n = c->next;
#line 968
  goto ldv_52155;
  ldv_52154: 
#line 969
  __mptr = (struct list_head  const  *)c;
#line 969
  buf = (struct saa7164_buffer *)__mptr;
#line 970
  buf->flags = 1;
#line 971
  buf->pos = 0U;
#line 968
  c = n;
#line 968
  n = c->next;
  ldv_52155: ;
#line 968
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )c) {
#line 970
    goto ldv_52154;
  } else {

  }
#line 974
  c = port->list_buf_used.list.next;
#line 974
  n = c->next;
#line 974
  goto ldv_52160;
  ldv_52159: 
#line 975
  __mptr___0 = (struct list_head  const  *)c;
#line 975
  ubuf = (struct saa7164_user_buffer *)__mptr___0;
#line 976
  ubuf->pos = 0U;
#line 977
  list_move_tail(& ubuf->list, & port->list_buf_free.list);
#line 974
  c = n;
#line 974
  n = c->next;
  ldv_52160: ;
#line 974
  if ((unsigned long )(& port->list_buf_used.list) != (unsigned long )c) {
#line 976
    goto ldv_52159;
  } else {

  }
#line 980
  mutex_unlock(& port->dmaqueue_lock);
#line 983
  saa7164_encoder_buffers_dealloc(port);
#line 985
  if ((saa_debug & 1024U) != 0U) {
#line 985
    printk("\017%s: %s(port=%d) Released\n", (char *)(& dev->name), "saa7164_encoder_stop_streaming",
           port->nr);
  } else {

  }
#line 987
  return (ret);
}
}
#line 990 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int saa7164_encoder_start_streaming(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int result ;
  int ret ;

  {
#line 992
  dev = port->dev;
#line 993
  ret = 0;
#line 995
  if ((saa_debug & 1024U) != 0U) {
#line 995
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_encoder_start_streaming",
           port->nr);
  } else {

  }
#line 997
  port->done_first_interrupt = 0U;
#line 1003
  saa7164_encoder_buffers_alloc(port);
#line 1006
  saa7164_api_set_encoder(port);
#line 1007
  saa7164_api_get_encoder(port);
#line 1010
  saa7164_buffer_cfg_port(port);
#line 1013
  result = saa7164_api_transition_port(port, 1);
#line 1014
  if (result != 0 && result != 38) {
#line 1015
    printk("\v%s() acquire transition failed, res = 0x%x\n", "saa7164_encoder_start_streaming",
           result);
#line 1019
    result = saa7164_api_transition_port(port, 0);
#line 1020
    if (result != 0 && result != 38) {
#line 1021
      printk("\v%s() acquire/forced stop transition failed, res = 0x%x\n", "saa7164_encoder_start_streaming",
             result);
    } else {

    }
#line 1024
    ret = -5;
#line 1025
    goto out;
  } else
#line 1027
  if ((saa_debug & 1024U) != 0U) {
#line 1027
    printk("\017%s: %s()   Acquired\n", (char *)(& dev->name), "saa7164_encoder_start_streaming");
  } else {

  }
#line 1030
  result = saa7164_api_transition_port(port, 2);
#line 1031
  if (result != 0 && result != 38) {
#line 1032
    printk("\v%s() pause transition failed, res = 0x%x\n", "saa7164_encoder_start_streaming",
           result);
#line 1036
    result = saa7164_api_transition_port(port, 0);
#line 1037
    if (result != 0 && result != 38) {
#line 1038
      printk("\v%s() pause/forced stop transition failed, res = 0x%x\n", "saa7164_encoder_start_streaming",
             result);
    } else {

    }
#line 1042
    ret = -5;
#line 1043
    goto out;
  } else
#line 1045
  if ((saa_debug & 1024U) != 0U) {
#line 1045
    printk("\017%s: %s()   Paused\n", (char *)(& dev->name), "saa7164_encoder_start_streaming");
  } else {

  }
#line 1048
  result = saa7164_api_transition_port(port, 3);
#line 1049
  if (result != 0 && result != 38) {
#line 1050
    printk("\v%s() run transition failed, result = 0x%x\n", "saa7164_encoder_start_streaming",
           result);
#line 1054
    result = saa7164_api_transition_port(port, 0);
#line 1055
    if (result != 0 && result != 38) {
#line 1056
      printk("\v%s() run/forced stop transition failed, res = 0x%x\n", "saa7164_encoder_start_streaming",
             result);
    } else {

    }
#line 1060
    ret = -5;
  } else
#line 1062
  if ((saa_debug & 1024U) != 0U) {
#line 1062
    printk("\017%s: %s()   Running\n", (char *)(& dev->name), "saa7164_encoder_start_streaming");
  } else {

  }
  out: ;
#line 1065
  return (ret);
}
}
#line 1068 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int fops_open(struct file *file ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_port *port ;
  struct saa7164_encoder_fh *fh ;
  struct video_device *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1074
  tmp = video_devdata(file);
#line 1074
  tmp___0 = video_get_drvdata(tmp);
#line 1074
  port = (struct saa7164_port *)tmp___0;
#line 1075
  if ((unsigned long )port == (unsigned long )((struct saa7164_port *)0)) {
#line 1076
    return (-19);
  } else {

  }
#line 1078
  dev = port->dev;
#line 1080
  if ((saa_debug & 1024U) != 0U) {
#line 1080
    printk("\017%s: %s()\n", (char *)(& dev->name), "fops_open");
  } else {

  }
#line 1083
  tmp___1 = kzalloc(16UL, 208U);
#line 1083
  fh = (struct saa7164_encoder_fh *)tmp___1;
#line 1084
  if ((unsigned long )fh == (unsigned long )((struct saa7164_encoder_fh *)0)) {
#line 1085
    return (-12);
  } else {

  }
#line 1087
  file->private_data = (void *)fh;
#line 1088
  fh->port = port;
#line 1090
  return (0);
}
}
#line 1093 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static int fops_release(struct file *file ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  int tmp ;
  int tmp___0 ;

  {
#line 1095
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 1096
  port = fh->port;
#line 1097
  dev = port->dev;
#line 1099
  if ((saa_debug & 1024U) != 0U) {
#line 1099
    printk("\017%s: %s()\n", (char *)(& dev->name), "fops_release");
  } else {

  }
#line 1102
  tmp___0 = atomic_cmpxchg(& fh->v4l_reading, 1, 0);
#line 1102
  if (tmp___0 == 1) {
#line 1103
    tmp = atomic_sub_return(1, & port->v4l_reader_count);
#line 1103
    if (tmp == 0) {
#line 1105
      saa7164_encoder_stop_streaming(port);
    } else {

    }
  } else {

  }
#line 1109
  file->private_data = (void *)0;
#line 1110
  kfree((void const   *)fh);
#line 1112
  return (0);
}
}
#line 1116 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static struct saa7164_user_buffer *saa7164_enc_next_buf(struct saa7164_port *port ) 
{ 
  struct saa7164_user_buffer *ubuf ;
  struct saa7164_dev *dev ;
  u32 crc ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1118
  ubuf = (struct saa7164_user_buffer *)0;
#line 1119
  dev = port->dev;
#line 1122
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 1123
  tmp = list_empty((struct list_head  const  *)(& port->list_buf_used.list));
#line 1123
  if (tmp == 0) {
#line 1124
    __mptr = (struct list_head  const  *)port->list_buf_used.list.next;
#line 1124
    ubuf = (struct saa7164_user_buffer *)__mptr;
#line 1127
    if (crc_checking != 0U) {
#line 1128
      crc = crc32_le(0U, (unsigned char const   *)ubuf->data, (size_t )ubuf->actual_size);
#line 1129
      if (ubuf->crc != crc) {
#line 1130
        printk("\v%s() ubuf %p crc became invalid, was 0x%x became 0x%x\n", "saa7164_enc_next_buf",
               ubuf, ubuf->crc, crc);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1138
  mutex_unlock(& port->dmaqueue_lock);
#line 1140
  if ((saa_debug & 1024U) != 0U) {
#line 1140
    printk("\017%s: %s() returns %p\n", (char *)(& dev->name), "saa7164_enc_next_buf",
           ubuf);
  } else {

  }
#line 1142
  return (ubuf);
}
}
#line 1145 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static ssize_t fops_read(struct file *file , char *buffer , size_t count , loff_t *pos ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_user_buffer *ubuf ;
  struct saa7164_dev *dev ;
  int ret ;
  int rem ;
  int cnt ;
  u8 *p ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___3 ;
  struct saa7164_user_buffer *tmp___4 ;
  struct saa7164_user_buffer *tmp___5 ;
  unsigned long tmp___6 ;
  int __ret___1 ;
  wait_queue_t __wait___0 ;
  long __ret___2 ;
  long __int___0 ;
  long tmp___7 ;
  struct saa7164_user_buffer *tmp___8 ;
  struct saa7164_user_buffer *tmp___9 ;

  {
#line 1148
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 1149
  port = fh->port;
#line 1150
  ubuf = (struct saa7164_user_buffer *)0;
#line 1151
  dev = port->dev;
#line 1152
  ret = 0;
#line 1156
  port->last_read_msecs_diff = port->last_read_msecs;
#line 1157
  tmp = jiffies_to_msecs(jiffies);
#line 1157
  port->last_read_msecs = (u64 )tmp;
#line 1158
  port->last_read_msecs_diff = port->last_read_msecs - port->last_read_msecs_diff;
#line 1161
  saa7164_histogram_update(& port->read_interval, (u32 )port->last_read_msecs_diff);
#line 1164
  if (*pos != 0LL) {
#line 1165
    printk("\v%s() ESPIPE\n", "fops_read");
#line 1166
    return (-29L);
  } else {

  }
#line 1169
  tmp___2 = atomic_cmpxchg(& fh->v4l_reading, 0, 1);
#line 1169
  if (tmp___2 == 0) {
#line 1170
    tmp___1 = atomic_add_return(1, & port->v4l_reader_count);
#line 1170
    if (tmp___1 == 1) {
#line 1172
      tmp___0 = saa7164_encoder_initialize(port);
#line 1172
      if (tmp___0 < 0) {
#line 1173
        printk("\v%s() EINVAL\n", "fops_read");
#line 1174
        return (-22L);
      } else {

      }
#line 1177
      saa7164_encoder_start_streaming(port);
#line 1178
      msleep(200U);
    } else {

    }
  } else {

  }
#line 1183
  if ((file->f_flags & 2048U) == 0U) {
#line 1184
    __ret = 0;
#line 1184
    __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c",
                  1185, 0);
#line 1184
    tmp___5 = saa7164_enc_next_buf(port);
#line 1184
    if ((unsigned long )tmp___5 == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1184
      __ret___0 = 0L;
#line 1184
      INIT_LIST_HEAD(& __wait.task_list);
#line 1184
      __wait.flags = 0U;
      ldv_52214: 
#line 1184
      tmp___3 = prepare_to_wait_event(& port->wait_read, & __wait, 1);
#line 1184
      __int = tmp___3;
#line 1184
      tmp___4 = saa7164_enc_next_buf(port);
#line 1184
      if ((unsigned long )tmp___4 != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1184
        goto ldv_52213;
      } else {

      }
#line 1184
      if (__int != 0L) {
#line 1184
        __ret___0 = __int;
#line 1184
        goto ldv_52213;
      } else {

      }
#line 1184
      schedule();
#line 1184
      goto ldv_52214;
      ldv_52213: 
#line 1184
      finish_wait(& port->wait_read, & __wait);
#line 1184
      __ret = (int )__ret___0;
    } else {

    }
#line 1184
    if (__ret != 0) {
#line 1186
      printk("\v%s() ERESTARTSYS\n", "fops_read");
#line 1187
      return (-512L);
    } else {

    }
  } else {

  }
#line 1192
  ubuf = saa7164_enc_next_buf(port);
#line 1194
  goto ldv_52229;
  ldv_52228: 
#line 1197
  rem = (int )(ubuf->actual_size - ubuf->pos);
#line 1198
  cnt = (int )(count < (size_t )rem ? count : (size_t )rem);
#line 1200
  p = ubuf->data + (unsigned long )ubuf->pos;
#line 1202
  if ((saa_debug & 1024U) != 0U) {
#line 1202
    printk("\017%s: %s() count=%d cnt=%d rem=%d buf=%p buf->pos=%d\n", (char *)(& dev->name),
           "fops_read", (int )count, cnt, rem, ubuf, ubuf->pos);
  } else {

  }
#line 1206
  tmp___6 = copy_to_user((void *)buffer, (void const   *)p, (unsigned long )cnt);
#line 1206
  if (tmp___6 != 0UL) {
#line 1207
    printk("\v%s() copy_to_user failed\n", "fops_read");
#line 1208
    if (ret == 0) {
#line 1209
      printk("\v%s() EFAULT\n", "fops_read");
#line 1210
      ret = -14;
    } else {

    }
#line 1212
    goto err;
  } else {

  }
#line 1215
  ubuf->pos = ubuf->pos + (u32 )cnt;
#line 1216
  count = count - (size_t )cnt;
#line 1217
  buffer = buffer + (unsigned long )cnt;
#line 1218
  ret = ret + cnt;
#line 1220
  if (ubuf->pos > ubuf->actual_size) {
#line 1221
    printk("\vread() pos > actual, huh?\n");
  } else {

  }
#line 1223
  if (ubuf->pos == ubuf->actual_size) {
#line 1228
    ubuf->pos = 0U;
#line 1230
    mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 1231
    list_move_tail(& ubuf->list, & port->list_buf_free.list);
#line 1232
    mutex_unlock(& port->dmaqueue_lock);
#line 1235
    if ((file->f_flags & 2048U) == 0U) {
#line 1236
      __ret___1 = 0;
#line 1236
      __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c",
                    1237, 0);
#line 1236
      tmp___9 = saa7164_enc_next_buf(port);
#line 1236
      if ((unsigned long )tmp___9 == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1236
        __ret___2 = 0L;
#line 1236
        INIT_LIST_HEAD(& __wait___0.task_list);
#line 1236
        __wait___0.flags = 0U;
        ldv_52224: 
#line 1236
        tmp___7 = prepare_to_wait_event(& port->wait_read, & __wait___0, 1);
#line 1236
        __int___0 = tmp___7;
#line 1236
        tmp___8 = saa7164_enc_next_buf(port);
#line 1236
        if ((unsigned long )tmp___8 != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1236
          goto ldv_52223;
        } else {

        }
#line 1236
        if (__int___0 != 0L) {
#line 1236
          __ret___2 = __int___0;
#line 1236
          goto ldv_52223;
        } else {

        }
#line 1236
        schedule();
#line 1236
        goto ldv_52224;
        ldv_52223: 
#line 1236
        finish_wait(& port->wait_read, & __wait___0);
#line 1236
        __ret___1 = (int )__ret___2;
      } else {

      }
#line 1236
      if (__ret___1 != 0) {
#line 1238
        goto ldv_52227;
      } else {

      }
    } else {

    }
#line 1241
    ubuf = saa7164_enc_next_buf(port);
  } else {

  }
  ldv_52229: ;
#line 1194
  if (count != 0UL && (unsigned long )ubuf != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1196
    goto ldv_52228;
  } else {

  }
  ldv_52227: ;
  err: ;
#line 1245
  if (ret == 0 && (unsigned long )ubuf == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1246
    ret = -11;
  } else {

  }
#line 1248
  return ((ssize_t )ret);
}
}
#line 1251 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static unsigned int fops_poll(struct file *file , poll_table *wait ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;
  unsigned int mask ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___4 ;
  struct saa7164_user_buffer *tmp___5 ;
  struct saa7164_user_buffer *tmp___6 ;
  int tmp___7 ;

  {
#line 1253
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 1255
  port = fh->port;
#line 1256
  mask = 0U;
#line 1258
  port->last_poll_msecs_diff = port->last_poll_msecs;
#line 1259
  tmp = jiffies_to_msecs(jiffies);
#line 1259
  port->last_poll_msecs = (u64 )tmp;
#line 1260
  port->last_poll_msecs_diff = port->last_poll_msecs - port->last_poll_msecs_diff;
#line 1263
  saa7164_histogram_update(& port->poll_interval, (u32 )port->last_poll_msecs_diff);
#line 1266
  tmp___0 = video_is_registered(port->v4l_device);
#line 1266
  if (tmp___0 == 0) {
#line 1267
    return (4294967291U);
  } else {

  }
#line 1269
  tmp___3 = atomic_cmpxchg(& fh->v4l_reading, 0, 1);
#line 1269
  if (tmp___3 == 0) {
#line 1270
    tmp___2 = atomic_add_return(1, & port->v4l_reader_count);
#line 1270
    if (tmp___2 == 1) {
#line 1271
      tmp___1 = saa7164_encoder_initialize(port);
#line 1271
      if (tmp___1 < 0) {
#line 1272
        return (4294967274U);
      } else {

      }
#line 1273
      saa7164_encoder_start_streaming(port);
#line 1274
      msleep(200U);
    } else {

    }
  } else {

  }
#line 1279
  if ((file->f_flags & 2048U) == 0U) {
#line 1280
    __ret = 0;
#line 1280
    __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c",
                  1281, 0);
#line 1280
    tmp___6 = saa7164_enc_next_buf(port);
#line 1280
    if ((unsigned long )tmp___6 == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1280
      __ret___0 = 0L;
#line 1280
      INIT_LIST_HEAD(& __wait.task_list);
#line 1280
      __wait.flags = 0U;
      ldv_52243: 
#line 1280
      tmp___4 = prepare_to_wait_event(& port->wait_read, & __wait, 1);
#line 1280
      __int = tmp___4;
#line 1280
      tmp___5 = saa7164_enc_next_buf(port);
#line 1280
      if ((unsigned long )tmp___5 != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1280
        goto ldv_52242;
      } else {

      }
#line 1280
      if (__int != 0L) {
#line 1280
        __ret___0 = __int;
#line 1280
        goto ldv_52242;
      } else {

      }
#line 1280
      schedule();
#line 1280
      goto ldv_52243;
      ldv_52242: 
#line 1280
      finish_wait(& port->wait_read, & __wait);
#line 1280
      __ret = (int )__ret___0;
    } else {

    }
#line 1280
    if (__ret != 0) {
#line 1282
      return (4294966784U);
    } else {

    }
  } else {

  }
#line 1287
  tmp___7 = list_empty((struct list_head  const  *)(& port->list_buf_used.list));
#line 1287
  if (tmp___7 == 0) {
#line 1288
    mask = mask | 65U;
  } else {

  }
#line 1290
  return (mask);
}
}
#line 1293 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static struct v4l2_file_operations  const  mpeg_fops  = 
#line 1293
     {& __this_module, & fops_read, 0, & fops_poll, & video_ioctl2, 0, 0, 0, & fops_open,
    & fops_release};
#line 1302 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static struct v4l2_ioctl_ops  const  mpeg_ioctl_ops  = 
#line 1302
     {& vidioc_querycap, & vidioc_enum_fmt_vid_cap, 0, 0, 0, 0, 0, & vidioc_g_fmt_vid_cap,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_s_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & vidioc_try_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, & vidioc_g_std, & vidioc_s_std, 0, & vidioc_enum_input, & vidioc_g_input,
    & vidioc_s_input, 0, 0, 0, & vidioc_queryctrl, 0, & vidioc_g_ctrl, & vidioc_s_ctrl,
    & vidioc_g_ext_ctrls, & vidioc_s_ext_ctrls, & vidioc_try_ext_ctrls, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_g_tuner, & vidioc_s_tuner,
    & vidioc_g_frequency, & vidioc_s_frequency, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0};
#line 1325 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static struct video_device saa7164_mpeg_template  = 
#line 1325
     {{{0, 0}, 0, 0U, 0, 0U, 0U, 0UL, 0U, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, 0, 0, 0, 0, 0, 0, {{0U, 0U}}}, & mpeg_fops, {0, 0, {0, {0,
                                                                                0},
                                                                            0, 0,
                                                                            0, 0,
                                                                            {{0}},
                                                                            {{{0L},
                                                                              {0,
                                                                               0},
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                                             {{0,
                                                                               0},
                                                                              0UL,
                                                                              0, 0UL,
                                                                              0U,
                                                                              0, 0,
                                                                              0, {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0},
                                                                              {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}},
                                                                             0, 0},
                                                                            (unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0},
                                                                     0, 0, {{0}, {{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                            {0, 0},
                                                                            0, 0,
                                                                            {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}},
                                                                     0, 0, 0, 0, {{0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  {{{{{0}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0},
                                                                                  {0U,
                                                                                   {{{{{{0}},
                                                                                       0U,
                                                                                       0U,
                                                                                       0,
                                                                                       {0,
                                                                                        {0,
                                                                                         0},
                                                                                        0,
                                                                                        0,
                                                                                        0UL}}}},
                                                                                    {0,
                                                                                     0}}},
                                                                                  0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  {{0,
                                                                                    0},
                                                                                   0UL,
                                                                                   0,
                                                                                   0UL,
                                                                                   0U,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   {(char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0},
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}},
                                                                                  0UL,
                                                                                  {{0L},
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}},
                                                                                  {{{{{{0}},
                                                                                      0U,
                                                                                      0U,
                                                                                      0,
                                                                                      {0,
                                                                                       {0,
                                                                                        0},
                                                                                       0,
                                                                                       0,
                                                                                       0UL}}}},
                                                                                   {0,
                                                                                    0}},
                                                                                  0,
                                                                                  {0},
                                                                                  {0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0,
                                                                                  0,
                                                                                  0},
                                                                     0, 0, 0, 0, 0ULL,
                                                                     0UL, 0, {0, 0},
                                                                     0, 0, {0, 0},
                                                                     0, 0, 0U, 0U,
                                                                     {{{{{0}}, 0U,
                                                                        0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                     {0, 0}, {0, {0,
                                                                                  0},
                                                                              {{0}}},
                                                                     0, 0, 0, 0, (_Bool)0,
                                                                     (_Bool)0}, 0,
    0, 0, 0, 0, 0, {'s', 'a', 'a', '7', '1', '6', '4', '\000'}, 0, 0, -1, (unsigned short)0,
    0UL, 0, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 28672ULL, 0,
    & mpeg_ioctl_ops, {0UL, 0UL, 0UL}, {0UL, 0UL, 0UL}, 0};
#line 1333 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
static struct video_device *saa7164_encoder_alloc(struct saa7164_port *port , struct pci_dev *pci ,
                                                  struct video_device *template ,
                                                  char *type ) 
{ 
  struct video_device *vfd ;
  struct saa7164_dev *dev ;

  {
#line 1340
  dev = port->dev;
#line 1342
  if ((saa_debug & 1024U) != 0U) {
#line 1342
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_encoder_alloc");
  } else {

  }
#line 1344
  vfd = video_device_alloc();
#line 1345
  if ((unsigned long )vfd == (unsigned long )((struct video_device *)0)) {
#line 1346
    return ((struct video_device *)0);
  } else {

  }
#line 1348
  *vfd = *template;
#line 1349
  snprintf((char *)(& vfd->name), 32UL, "%s %s (%s)", (char *)(& dev->name), type,
           saa7164_boards[dev->board].name);
#line 1352
  vfd->v4l2_dev = & dev->v4l2_dev;
#line 1353
  vfd->release = & video_device_release;
#line 1354
  return (vfd);
}
}
#line 1357 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
int saa7164_encoder_register(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int result ;

  {
#line 1359
  dev = port->dev;
#line 1360
  result = -19;
#line 1362
  if ((saa_debug & 1024U) != 0U) {
#line 1362
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_encoder_register");
  } else {

  }
#line 1364
  if ((unsigned int )port->type != 2U) {
#line 1365
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"),
                         "i" (1365), "i" (12UL));
    ldv_52264: ;
#line 1365
    goto ldv_52264;
  } else {

  }
#line 1368
  if (port->hwcfg.BARLocation == 0U) {
#line 1369
    printk("\v%s() failed (errno = %d), NO PCI configuration\n", "saa7164_encoder_register",
           result);
#line 1372
    result = -12;
#line 1373
    goto failed;
  } else {

  }
#line 1378
  port->encodernorm = saa7164_tvnorms[0];
#line 1379
  port->width = 720U;
#line 1380
  port->mux_input = 1U;
#line 1381
  port->video_format = 2U;
#line 1382
  port->audio_format = 0U;
#line 1383
  port->video_resolution = 0U;
#line 1384
  port->ctl_brightness = 127U;
#line 1385
  port->ctl_contrast = 66U;
#line 1386
  port->ctl_hue = 128U;
#line 1387
  port->ctl_saturation = 62U;
#line 1388
  port->ctl_sharpness = 8U;
#line 1389
  port->encoder_params.bitrate = 5000000U;
#line 1390
  port->encoder_params.bitrate_peak = 5000000U;
#line 1391
  port->encoder_params.bitrate_mode = 1U;
#line 1392
  port->encoder_params.stream_type = 0U;
#line 1393
  port->encoder_params.ctl_mute = 0U;
#line 1394
  port->encoder_params.ctl_aspect = 1U;
#line 1395
  port->encoder_params.refdist = 1U;
#line 1396
  port->encoder_params.gop_size = 15U;
#line 1397
  port->std = 4096ULL;
#line 1399
  if ((port->encodernorm.id & 63744ULL) != 0ULL) {
#line 1400
    port->height = 480U;
  } else {
#line 1402
    port->height = 576U;
  }
#line 1405
  port->v4l_device = saa7164_encoder_alloc(port, dev->pci, & saa7164_mpeg_template,
                                           (char *)"mpeg");
#line 1408
  if ((unsigned long )port->v4l_device == (unsigned long )((struct video_device *)0)) {
#line 1409
    printk("\016%s: can\'t allocate mpeg device\n", (char *)(& dev->name));
#line 1411
    result = -12;
#line 1412
    goto failed;
  } else {

  }
#line 1415
  video_set_drvdata(port->v4l_device, (void *)port);
#line 1416
  result = video_register_device(port->v4l_device, 0, -1);
#line 1418
  if (result < 0) {
#line 1419
    printk("\016%s: can\'t register mpeg device\n", (char *)(& dev->name));
#line 1424
    goto failed;
  } else {

  }
#line 1427
  printk("\016%s: registered device video%d [mpeg]\n", (char *)(& dev->name), (int )(port->v4l_device)->num);
#line 1431
  saa7164_api_set_videomux(port);
#line 1432
  saa7164_api_set_usercontrol(port, 2);
#line 1433
  saa7164_api_set_usercontrol(port, 3);
#line 1434
  saa7164_api_set_usercontrol(port, 6);
#line 1435
  saa7164_api_set_usercontrol(port, 7);
#line 1436
  saa7164_api_set_usercontrol(port, 8);
#line 1437
  saa7164_api_audio_mute(port, 0);
#line 1438
  saa7164_api_set_audio_volume(port, 20);
#line 1439
  saa7164_api_set_aspect_ratio(port);
#line 1442
  saa7164_api_set_audio_detection(port, 0);
#line 1444
  saa7164_api_set_encoder(port);
#line 1445
  saa7164_api_get_encoder(port);
#line 1447
  result = 0;
  failed: ;
#line 1449
  return (result);
}
}
#line 1452 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"
void saa7164_encoder_unregister(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;

  {
#line 1454
  dev = port->dev;
#line 1456
  if ((saa_debug & 1024U) != 0U) {
#line 1456
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_encoder_unregister",
           port->nr);
  } else {

  }
#line 1458
  if ((unsigned int )port->type != 2U) {
#line 1459
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.c"),
                         "i" (1459), "i" (12UL));
    ldv_52271: ;
#line 1459
    goto ldv_52271;
  } else {

  }
#line 1461
  if ((unsigned long )port->v4l_device != (unsigned long )((struct video_device *)0)) {
#line 1462
    if ((port->v4l_device)->minor != -1) {
#line 1463
      video_unregister_device(port->v4l_device);
    } else {
#line 1465
      video_device_release(port->v4l_device);
    }
#line 1467
    port->v4l_device = (struct video_device *)0;
  } else {

  }
#line 1470
  if ((saa_debug & 1024U) != 0U) {
#line 1470
    printk("\017%s: %s(port=%d) done\n", (char *)(& dev->name), "saa7164_encoder_unregister",
           port->nr);
  } else {

  }
#line 1471
  return;
}
}
#line 143 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
int ldv_retval_2  ;
#line 146 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
void ldv_initialize_v4l2_file_operations_9(void) 
{ 
  void *tmp ;

  {
#line 147
  tmp = __VERIFIER_nondet_pointer();
#line 147
  mpeg_fops_group0 = (struct file *)tmp;
#line 148
  return;
}
}
#line 150 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_8(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 151
  tmp = ldv_init_zalloc(32UL);
#line 151
  mpeg_ioctl_ops_group2 = (struct v4l2_ext_controls *)tmp;
#line 152
  tmp___0 = ldv_init_zalloc(208UL);
#line 152
  mpeg_ioctl_ops_group1 = (struct v4l2_format *)tmp___0;
#line 153
  tmp___1 = ldv_init_zalloc(8UL);
#line 153
  mpeg_ioctl_ops_group0 = (struct v4l2_control *)tmp___1;
#line 154
  tmp___2 = __VERIFIER_nondet_pointer();
#line 154
  mpeg_ioctl_ops_group3 = (struct file *)tmp___2;
#line 155
  return;
}
}
#line 157 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  struct v4l2_tuner *ldvarg75 ;
  void *tmp ;
  struct v4l2_tuner *ldvarg82 ;
  void *tmp___0 ;
  void *ldvarg76 ;
  void *tmp___1 ;
  void *ldvarg74 ;
  void *tmp___2 ;
  void *ldvarg61 ;
  void *tmp___3 ;
  void *ldvarg54 ;
  void *tmp___4 ;
  void *ldvarg68 ;
  void *tmp___5 ;
  void *ldvarg78 ;
  void *tmp___6 ;
  void *ldvarg70 ;
  void *tmp___7 ;
  struct v4l2_queryctrl *ldvarg73 ;
  void *tmp___8 ;
  void *ldvarg63 ;
  void *tmp___9 ;
  void *ldvarg81 ;
  void *tmp___10 ;
  struct v4l2_frequency *ldvarg66 ;
  void *tmp___11 ;
  void *ldvarg55 ;
  void *tmp___12 ;
  void *ldvarg79 ;
  void *tmp___13 ;
  void *ldvarg65 ;
  void *tmp___14 ;
  void *ldvarg57 ;
  void *tmp___15 ;
  struct v4l2_capability *ldvarg62 ;
  void *tmp___16 ;
  void *ldvarg59 ;
  void *tmp___17 ;
  void *ldvarg80 ;
  void *tmp___18 ;
  struct v4l2_frequency *ldvarg60 ;
  void *tmp___19 ;
  void *ldvarg69 ;
  void *tmp___20 ;
  void *ldvarg83 ;
  void *tmp___21 ;
  unsigned int *ldvarg64 ;
  void *tmp___22 ;
  unsigned int ldvarg53 ;
  v4l2_std_id *ldvarg58 ;
  void *tmp___23 ;
  struct v4l2_input *ldvarg56 ;
  void *tmp___24 ;
  void *ldvarg72 ;
  void *tmp___25 ;
  struct v4l2_fmtdesc *ldvarg71 ;
  void *tmp___26 ;
  void *ldvarg67 ;
  void *tmp___27 ;
  void *ldvarg84 ;
  void *tmp___28 ;
  v4l2_std_id ldvarg77 ;
  int tmp___29 ;

  {
#line 158
  tmp = ldv_init_zalloc(84UL);
#line 158
  ldvarg75 = (struct v4l2_tuner *)tmp;
#line 159
  tmp___0 = ldv_init_zalloc(84UL);
#line 159
  ldvarg82 = (struct v4l2_tuner *)tmp___0;
#line 160
  tmp___1 = ldv_init_zalloc(1UL);
#line 160
  ldvarg76 = tmp___1;
#line 161
  tmp___2 = ldv_init_zalloc(1UL);
#line 161
  ldvarg74 = tmp___2;
#line 162
  tmp___3 = ldv_init_zalloc(1UL);
#line 162
  ldvarg61 = tmp___3;
#line 163
  tmp___4 = ldv_init_zalloc(1UL);
#line 163
  ldvarg54 = tmp___4;
#line 164
  tmp___5 = ldv_init_zalloc(1UL);
#line 164
  ldvarg68 = tmp___5;
#line 165
  tmp___6 = ldv_init_zalloc(1UL);
#line 165
  ldvarg78 = tmp___6;
#line 166
  tmp___7 = ldv_init_zalloc(1UL);
#line 166
  ldvarg70 = tmp___7;
#line 167
  tmp___8 = ldv_init_zalloc(68UL);
#line 167
  ldvarg73 = (struct v4l2_queryctrl *)tmp___8;
#line 168
  tmp___9 = ldv_init_zalloc(1UL);
#line 168
  ldvarg63 = tmp___9;
#line 169
  tmp___10 = ldv_init_zalloc(1UL);
#line 169
  ldvarg81 = tmp___10;
#line 170
  tmp___11 = ldv_init_zalloc(44UL);
#line 170
  ldvarg66 = (struct v4l2_frequency *)tmp___11;
#line 171
  tmp___12 = ldv_init_zalloc(1UL);
#line 171
  ldvarg55 = tmp___12;
#line 172
  tmp___13 = ldv_init_zalloc(1UL);
#line 172
  ldvarg79 = tmp___13;
#line 173
  tmp___14 = ldv_init_zalloc(1UL);
#line 173
  ldvarg65 = tmp___14;
#line 174
  tmp___15 = ldv_init_zalloc(1UL);
#line 174
  ldvarg57 = tmp___15;
#line 175
  tmp___16 = ldv_init_zalloc(104UL);
#line 175
  ldvarg62 = (struct v4l2_capability *)tmp___16;
#line 176
  tmp___17 = ldv_init_zalloc(1UL);
#line 176
  ldvarg59 = tmp___17;
#line 177
  tmp___18 = ldv_init_zalloc(1UL);
#line 177
  ldvarg80 = tmp___18;
#line 178
  tmp___19 = ldv_init_zalloc(44UL);
#line 178
  ldvarg60 = (struct v4l2_frequency *)tmp___19;
#line 179
  tmp___20 = ldv_init_zalloc(1UL);
#line 179
  ldvarg69 = tmp___20;
#line 180
  tmp___21 = ldv_init_zalloc(1UL);
#line 180
  ldvarg83 = tmp___21;
#line 181
  tmp___22 = ldv_init_zalloc(4UL);
#line 181
  ldvarg64 = (unsigned int *)tmp___22;
#line 183
  tmp___23 = ldv_init_zalloc(8UL);
#line 183
  ldvarg58 = (v4l2_std_id *)tmp___23;
#line 184
  tmp___24 = ldv_init_zalloc(80UL);
#line 184
  ldvarg56 = (struct v4l2_input *)tmp___24;
#line 185
  tmp___25 = ldv_init_zalloc(1UL);
#line 185
  ldvarg72 = tmp___25;
#line 186
  tmp___26 = ldv_init_zalloc(64UL);
#line 186
  ldvarg71 = (struct v4l2_fmtdesc *)tmp___26;
#line 187
  tmp___27 = ldv_init_zalloc(1UL);
#line 187
  ldvarg67 = tmp___27;
#line 188
  tmp___28 = ldv_init_zalloc(1UL);
#line 188
  ldvarg84 = tmp___28;
#line 182
  ldv_memset((void *)(& ldvarg53), 0, 4UL);
#line 189
  ldv_memset((void *)(& ldvarg77), 0, 8UL);
#line 191
  tmp___29 = __VERIFIER_nondet_int();
#line 191
  switch (tmp___29) {
  case 0: ;
#line 194
  if (ldv_state_variable_8 == 1) {
#line 196
    vidioc_s_ctrl(mpeg_ioctl_ops_group3, ldvarg84, mpeg_ioctl_ops_group0);
#line 198
    ldv_state_variable_8 = 1;
  } else {

  }
#line 201
  goto ldv_52315;
  case 1: ;
#line 204
  if (ldv_state_variable_8 == 1) {
#line 206
    vidioc_g_tuner(mpeg_ioctl_ops_group3, ldvarg83, ldvarg82);
#line 208
    ldv_state_variable_8 = 1;
  } else {

  }
#line 211
  goto ldv_52315;
  case 2: ;
#line 214
  if (ldv_state_variable_8 == 1) {
#line 216
    vidioc_g_ext_ctrls(mpeg_ioctl_ops_group3, ldvarg81, mpeg_ioctl_ops_group2);
#line 218
    ldv_state_variable_8 = 1;
  } else {

  }
#line 221
  goto ldv_52315;
  case 3: ;
#line 224
  if (ldv_state_variable_8 == 1) {
#line 226
    vidioc_g_ctrl(mpeg_ioctl_ops_group3, ldvarg80, mpeg_ioctl_ops_group0);
#line 228
    ldv_state_variable_8 = 1;
  } else {

  }
#line 231
  goto ldv_52315;
  case 4: ;
#line 234
  if (ldv_state_variable_8 == 1) {
#line 236
    vidioc_try_fmt_vid_cap(mpeg_ioctl_ops_group3, ldvarg79, mpeg_ioctl_ops_group1);
#line 238
    ldv_state_variable_8 = 1;
  } else {

  }
#line 241
  goto ldv_52315;
  case 5: ;
#line 244
  if (ldv_state_variable_8 == 1) {
#line 246
    vidioc_s_std(mpeg_ioctl_ops_group3, ldvarg78, ldvarg77);
#line 248
    ldv_state_variable_8 = 1;
  } else {

  }
#line 251
  goto ldv_52315;
  case 6: ;
#line 254
  if (ldv_state_variable_8 == 1) {
#line 256
    vidioc_s_tuner(mpeg_ioctl_ops_group3, ldvarg76, (struct v4l2_tuner  const  *)ldvarg75);
#line 258
    ldv_state_variable_8 = 1;
  } else {

  }
#line 261
  goto ldv_52315;
  case 7: ;
#line 264
  if (ldv_state_variable_8 == 1) {
#line 266
    vidioc_queryctrl(mpeg_ioctl_ops_group3, ldvarg74, ldvarg73);
#line 268
    ldv_state_variable_8 = 1;
  } else {

  }
#line 271
  goto ldv_52315;
  case 8: ;
#line 274
  if (ldv_state_variable_8 == 1) {
#line 276
    vidioc_enum_fmt_vid_cap(mpeg_ioctl_ops_group3, ldvarg72, ldvarg71);
#line 278
    ldv_state_variable_8 = 1;
  } else {

  }
#line 281
  goto ldv_52315;
  case 9: ;
#line 284
  if (ldv_state_variable_8 == 1) {
#line 286
    vidioc_try_ext_ctrls(mpeg_ioctl_ops_group3, ldvarg70, mpeg_ioctl_ops_group2);
#line 288
    ldv_state_variable_8 = 1;
  } else {

  }
#line 291
  goto ldv_52315;
  case 10: ;
#line 294
  if (ldv_state_variable_8 == 1) {
#line 296
    vidioc_s_fmt_vid_cap(mpeg_ioctl_ops_group3, ldvarg69, mpeg_ioctl_ops_group1);
#line 298
    ldv_state_variable_8 = 1;
  } else {

  }
#line 301
  goto ldv_52315;
  case 11: ;
#line 304
  if (ldv_state_variable_8 == 1) {
#line 306
    vidioc_g_fmt_vid_cap(mpeg_ioctl_ops_group3, ldvarg68, mpeg_ioctl_ops_group1);
#line 308
    ldv_state_variable_8 = 1;
  } else {

  }
#line 311
  goto ldv_52315;
  case 12: ;
#line 314
  if (ldv_state_variable_8 == 1) {
#line 316
    vidioc_g_frequency(mpeg_ioctl_ops_group3, ldvarg67, ldvarg66);
#line 318
    ldv_state_variable_8 = 1;
  } else {

  }
#line 321
  goto ldv_52315;
  case 13: ;
#line 324
  if (ldv_state_variable_8 == 1) {
#line 326
    vidioc_g_input(mpeg_ioctl_ops_group3, ldvarg65, ldvarg64);
#line 328
    ldv_state_variable_8 = 1;
  } else {

  }
#line 331
  goto ldv_52315;
  case 14: ;
#line 334
  if (ldv_state_variable_8 == 1) {
#line 336
    vidioc_querycap(mpeg_ioctl_ops_group3, ldvarg63, ldvarg62);
#line 338
    ldv_state_variable_8 = 1;
  } else {

  }
#line 341
  goto ldv_52315;
  case 15: ;
#line 344
  if (ldv_state_variable_8 == 1) {
#line 346
    vidioc_s_frequency(mpeg_ioctl_ops_group3, ldvarg61, (struct v4l2_frequency  const  *)ldvarg60);
#line 348
    ldv_state_variable_8 = 1;
  } else {

  }
#line 351
  goto ldv_52315;
  case 16: ;
#line 354
  if (ldv_state_variable_8 == 1) {
#line 356
    vidioc_g_std(mpeg_ioctl_ops_group3, ldvarg59, ldvarg58);
#line 358
    ldv_state_variable_8 = 1;
  } else {

  }
#line 361
  goto ldv_52315;
  case 17: ;
#line 364
  if (ldv_state_variable_8 == 1) {
#line 366
    vidioc_enum_input(mpeg_ioctl_ops_group3, ldvarg57, ldvarg56);
#line 368
    ldv_state_variable_8 = 1;
  } else {

  }
#line 371
  goto ldv_52315;
  case 18: ;
#line 374
  if (ldv_state_variable_8 == 1) {
#line 376
    vidioc_s_ext_ctrls(mpeg_ioctl_ops_group3, ldvarg55, mpeg_ioctl_ops_group2);
#line 378
    ldv_state_variable_8 = 1;
  } else {

  }
#line 381
  goto ldv_52315;
  case 19: ;
#line 384
  if (ldv_state_variable_8 == 1) {
#line 386
    vidioc_s_input(mpeg_ioctl_ops_group3, ldvarg54, ldvarg53);
#line 388
    ldv_state_variable_8 = 1;
  } else {

  }
#line 391
  goto ldv_52315;
  default: 
#line 392
  ldv_stop();
  }
  ldv_52315: ;
#line 396
  return;
}
}
#line 398 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  size_t ldvarg46 ;
  char *ldvarg47 ;
  void *tmp ;
  struct poll_table_struct *ldvarg44 ;
  void *tmp___0 ;
  unsigned long ldvarg42 ;
  unsigned int ldvarg43 ;
  loff_t *ldvarg45 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 400
  tmp = ldv_init_zalloc(1UL);
#line 400
  ldvarg47 = (char *)tmp;
#line 401
  tmp___0 = ldv_init_zalloc(16UL);
#line 401
  ldvarg44 = (struct poll_table_struct *)tmp___0;
#line 404
  tmp___1 = ldv_init_zalloc(8UL);
#line 404
  ldvarg45 = (loff_t *)tmp___1;
#line 399
  ldv_memset((void *)(& ldvarg46), 0, 8UL);
#line 402
  ldv_memset((void *)(& ldvarg42), 0, 8UL);
#line 403
  ldv_memset((void *)(& ldvarg43), 0, 4UL);
#line 406
  tmp___2 = __VERIFIER_nondet_int();
#line 406
  switch (tmp___2) {
  case 0: ;
#line 409
  if (ldv_state_variable_9 == 2) {
#line 411
    fops_release(mpeg_fops_group0);
#line 413
    ldv_state_variable_9 = 1;
#line 414
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 417
  goto ldv_52346;
  case 1: ;
#line 420
  if (ldv_state_variable_9 == 2) {
#line 422
    fops_read(mpeg_fops_group0, ldvarg47, ldvarg46, ldvarg45);
#line 424
    ldv_state_variable_9 = 2;
  } else {

  }
#line 427
  goto ldv_52346;
  case 2: ;
#line 430
  if (ldv_state_variable_9 == 1) {
#line 432
    fops_poll(mpeg_fops_group0, ldvarg44);
#line 434
    ldv_state_variable_9 = 1;
  } else {

  }
#line 437
  if (ldv_state_variable_9 == 2) {
#line 439
    fops_poll(mpeg_fops_group0, ldvarg44);
#line 441
    ldv_state_variable_9 = 2;
  } else {

  }
#line 444
  goto ldv_52346;
  case 3: ;
#line 447
  if (ldv_state_variable_9 == 1) {
#line 449
    ldv_retval_2 = fops_open(mpeg_fops_group0);
#line 451
    if (ldv_retval_2 == 0) {
#line 452
      ldv_state_variable_9 = 2;
#line 453
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 457
  goto ldv_52346;
  case 4: ;
#line 460
  if (ldv_state_variable_9 == 1) {
#line 462
    video_ioctl2(mpeg_fops_group0, ldvarg43, ldvarg42);
#line 464
    ldv_state_variable_9 = 1;
  } else {

  }
#line 467
  if (ldv_state_variable_9 == 2) {
#line 469
    video_ioctl2(mpeg_fops_group0, ldvarg43, ldvarg42);
#line 471
    ldv_state_variable_9 = 2;
  } else {

  }
#line 474
  goto ldv_52346;
  default: 
#line 475
  ldv_stop();
  }
  ldv_52346: ;
#line 479
  return;
}
}
#line 593 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
bool ldv_queue_work_on_439(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 597
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 597
  ldv_func_res = tmp;
#line 599
  activate_work_3(ldv_func_arg3, 2);
#line 601
  return (ldv_func_res);
}
}
#line 604 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
bool ldv_queue_delayed_work_on_440(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 608
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 608
  ldv_func_res = tmp;
#line 610
  activate_work_3(& ldv_func_arg3->work, 2);
#line 612
  return (ldv_func_res);
}
}
#line 615 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
bool ldv_queue_work_on_441(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 619
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 619
  ldv_func_res = tmp;
#line 621
  activate_work_3(ldv_func_arg3, 2);
#line 623
  return (ldv_func_res);
}
}
#line 626 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
void ldv_flush_workqueue_442(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 629
  flush_workqueue(ldv_func_arg1);
#line 631
  call_and_disable_all_3(2);
#line 632
  return;
}
}
#line 634 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
bool ldv_queue_delayed_work_on_443(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 638
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 638
  ldv_func_res = tmp;
#line 640
  activate_work_3(& ldv_func_arg3->work, 2);
#line 642
  return (ldv_func_res);
}
}
#line 680 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
void *ldv_kmem_cache_alloc_449(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 683
  ldv_check_alloc_flags(flags);
#line 684
  tmp = ldv_undef_ptr();
#line 684
  return (tmp);
}
}
#line 722 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
int ldv_pskb_expand_head_455(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 725
  ldv_check_alloc_flags(flags);
#line 726
  tmp = ldv_undef_ptr();
#line 726
  return ((int )((long )tmp));
}
}
#line 736 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
struct sk_buff *ldv_skb_clone_457(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 739
  ldv_check_alloc_flags(flags);
#line 740
  tmp = ldv_undef_ptr();
#line 740
  return ((struct sk_buff *)tmp);
}
}
#line 750 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
struct sk_buff *ldv_skb_copy_459(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 753
  ldv_check_alloc_flags(flags);
#line 754
  tmp = ldv_undef_ptr();
#line 754
  return ((struct sk_buff *)tmp);
}
}
#line 757 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_460(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 760
  ldv_check_alloc_flags(flags);
#line 761
  tmp = ldv_undef_ptr();
#line 761
  return ((struct sk_buff *)tmp);
}
}
#line 764 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_461(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 767
  ldv_check_alloc_flags(flags);
#line 768
  tmp = ldv_undef_ptr();
#line 768
  return ((struct sk_buff *)tmp);
}
}
#line 771 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_462(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 774
  ldv_check_alloc_flags(flags);
#line 775
  tmp = ldv_undef_ptr();
#line 775
  return ((struct sk_buff *)tmp);
}
}
#line 778 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
int ldv_pskb_expand_head_463(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 781
  ldv_check_alloc_flags(flags);
#line 782
  tmp = ldv_undef_ptr();
#line 782
  return ((int )((long )tmp));
}
}
#line 785 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
int ldv_pskb_expand_head_464(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 788
  ldv_check_alloc_flags(flags);
#line 789
  tmp = ldv_undef_ptr();
#line 789
  return ((int )((long )tmp));
}
}
#line 792 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-encoder.o.c.prepared"
struct sk_buff *ldv_skb_clone_465(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 795
  ldv_check_alloc_flags(flags);
#line 796
  tmp = ldv_undef_ptr();
#line 796
  return ((struct sk_buff *)tmp);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_485(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_487(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_486(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_489(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_488(struct workqueue_struct *ldv_func_arg1 ) ;
#line 293 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_495(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 849 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_503(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 853
struct sk_buff *ldv_skb_clone_511(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 858
struct sk_buff *ldv_skb_copy_505(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 871
int ldv_pskb_expand_head_501(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 875
int ldv_pskb_expand_head_509(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 879
int ldv_pskb_expand_head_510(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2148
struct sk_buff *ldv___netdev_alloc_skb_506(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2152
struct sk_buff *ldv___netdev_alloc_skb_507(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2156
struct sk_buff *ldv___netdev_alloc_skb_508(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 24 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static struct saa7164_tvnorm saa7164_tvnorms___0[2U]  = {      {(char *)"NTSC-M", 4096ULL}, 
        {(char *)"NTSC-JP", 8192ULL}};
#line 34 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static u32 const   saa7164_v4l2_ctrls___0[1U]  = {      0U};
#line 41 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static void saa7164_vbi_configure(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;

  {
#line 43
  dev = port->dev;
#line 44
  if ((saa_debug & 2048U) != 0U) {
#line 44
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_vbi_configure");
  } else {

  }
#line 46
  port->vbi_params.width = port->width;
#line 47
  port->vbi_params.height = port->height;
#line 48
  port->vbi_params.is_50hz = (port->encodernorm.id & 16713471ULL) != 0ULL;
#line 52
  saa7164_api_initialize_dif(port);
#line 63
  if ((saa_debug & 2048U) != 0U) {
#line 63
    printk("\017%s: %s() ends\n", (char *)(& dev->name), "saa7164_vbi_configure");
  } else {

  }
#line 64
  return;
}
}
#line 66 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_buffers_dealloc(struct saa7164_port *port ) 
{ 
  struct list_head *c ;
  struct list_head *n ;
  struct list_head *p ;
  struct list_head *q ;
  struct list_head *l ;
  struct list_head *v ;
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct saa7164_user_buffer *ubuf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 69
  dev = port->dev;
#line 74
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 76
  if ((saa_debug & 2048U) != 0U) {
#line 76
    printk("\017%s: %s(port=%d) dmaqueue\n", (char *)(& dev->name), "saa7164_vbi_buffers_dealloc",
           port->nr);
  } else {

  }
#line 77
  c = port->dmaqueue.list.next;
#line 77
  n = c->next;
#line 77
  goto ldv_51812;
  ldv_51811: 
#line 78
  __mptr = (struct list_head  const  *)c;
#line 78
  buf = (struct saa7164_buffer *)__mptr;
#line 79
  list_del(c);
#line 80
  saa7164_buffer_dealloc(buf);
#line 77
  c = n;
#line 77
  n = c->next;
  ldv_51812: ;
#line 77
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )c) {
#line 79
    goto ldv_51811;
  } else {

  }

#line 83
  if ((saa_debug & 2048U) != 0U) {
#line 83
    printk("\017%s: %s(port=%d) used\n", (char *)(& dev->name), "saa7164_vbi_buffers_dealloc",
           port->nr);
  } else {

  }
#line 84
  p = port->list_buf_used.list.next;
#line 84
  q = p->next;
#line 84
  goto ldv_51817;
  ldv_51816: 
#line 85
  __mptr___0 = (struct list_head  const  *)p;
#line 85
  ubuf = (struct saa7164_user_buffer *)__mptr___0;
#line 86
  list_del(p);
#line 87
  saa7164_buffer_dealloc_user(ubuf);
#line 84
  p = q;
#line 84
  q = p->next;
  ldv_51817: ;
#line 84
  if ((unsigned long )(& port->list_buf_used.list) != (unsigned long )p) {
#line 86
    goto ldv_51816;
  } else {

  }

#line 90
  if ((saa_debug & 2048U) != 0U) {
#line 90
    printk("\017%s: %s(port=%d) free\n", (char *)(& dev->name), "saa7164_vbi_buffers_dealloc",
           port->nr);
  } else {

  }
#line 91
  l = port->list_buf_free.list.next;
#line 91
  v = l->next;
#line 91
  goto ldv_51822;
  ldv_51821: 
#line 92
  __mptr___1 = (struct list_head  const  *)l;
#line 92
  ubuf = (struct saa7164_user_buffer *)__mptr___1;
#line 93
  list_del(l);
#line 94
  saa7164_buffer_dealloc_user(ubuf);
#line 91
  l = v;
#line 91
  v = l->next;
  ldv_51822: ;
#line 91
  if ((unsigned long )(& port->list_buf_free.list) != (unsigned long )l) {
#line 93
    goto ldv_51821;
  } else {

  }
#line 97
  mutex_unlock(& port->dmaqueue_lock);
#line 98
  if ((saa_debug & 2048U) != 0U) {
#line 98
    printk("\017%s: %s(port=%d) done\n", (char *)(& dev->name), "saa7164_vbi_buffers_dealloc",
           port->nr);
  } else {

  }
#line 100
  return (0);
}
}
#line 104 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_buffers_alloc(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct saa7164_user_buffer *ubuf ;
  struct tmHWStreamParameters *params ;
  int result ;
  int i ;
  int len ;

  {
#line 106
  dev = port->dev;
#line 109
  params = & port->hw_streamingparams;
#line 110
  result = -19;
#line 111
  len = 0;
#line 113
  if ((saa_debug & 2048U) != 0U) {
#line 113
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_vbi_buffers_alloc");
  } else {

  }
#line 117
  params->samplesperline = 1440U;
#line 118
  params->numberoflines = 12U;
#line 119
  params->numberoflines = 18U;
#line 120
  params->pitch = 1600U;
#line 121
  params->pitch = 1440U;
#line 122
  params->numpagetables = (params->numberoflines * params->pitch) / 4096U + 2U;
#line 124
  params->bitspersample = 8U;
#line 125
  params->linethreshold = 0U;
#line 126
  params->pagetablelistvirt = (u64 **)0ULL;
#line 127
  params->pagetablelistphys = (u64 *)0ULL;
#line 128
  params->numpagetableentries = (u32 )port->hwcfg.buffercount;
#line 131
  i = 0;
#line 131
  goto ldv_51837;
  ldv_51836: 
#line 132
  buf = saa7164_buffer_alloc(port, params->numberoflines * params->pitch);
#line 136
  if ((unsigned long )buf == (unsigned long )((struct saa7164_buffer *)0)) {
#line 137
    printk("\v%s() failed (errno = %d), unable to allocate buffer\n", "saa7164_vbi_buffers_alloc",
           result);
#line 140
    result = -12;
#line 141
    goto failed;
  } else {
#line 144
    mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 145
    list_add_tail(& buf->list, & port->dmaqueue.list);
#line 146
    mutex_unlock(& port->dmaqueue_lock);
  }
#line 131
  i = i + 1;
  ldv_51837: ;
#line 131
  if ((int )port->hwcfg.buffercount > i) {
#line 133
    goto ldv_51836;
  } else {

  }
#line 154
  len = (int )(params->numberoflines * params->pitch);
#line 156
  if (vbi_buffers <= 15U) {
#line 157
    vbi_buffers = 16U;
  } else {

  }
#line 158
  if (vbi_buffers > 512U) {
#line 159
    vbi_buffers = 512U;
  } else {

  }
#line 161
  i = 0;
#line 161
  goto ldv_51840;
  ldv_51839: 
#line 163
  ubuf = saa7164_buffer_alloc_user(dev, (u32 )len);
#line 164
  if ((unsigned long )ubuf != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 165
    mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 166
    list_add_tail(& ubuf->list, & port->list_buf_free.list);
#line 167
    mutex_unlock(& port->dmaqueue_lock);
  } else {

  }
#line 161
  i = i + 1;
  ldv_51840: ;
#line 161
  if ((unsigned int )i < vbi_buffers) {
#line 163
    goto ldv_51839;
  } else {

  }
#line 172
  result = 0;
  failed: ;
#line 175
  return (result);
}
}
#line 179 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_initialize(struct saa7164_port *port ) 
{ 


  {
#line 181
  saa7164_vbi_configure(port);
#line 182
  return (0);
}
}
#line 186 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_s_std___0(struct file *file , void *priv , v4l2_std_id id ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  unsigned int i ;

  {
#line 188
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 189
  port = fh->port;
#line 190
  dev = port->dev;
#line 193
  if ((saa_debug & 2048U) != 0U) {
#line 193
    printk("\017%s: %s(id=0x%x)\n", (char *)(& dev->name), "vidioc_s_std", (unsigned int )id);
  } else {

  }
#line 195
  i = 0U;
#line 195
  goto ldv_51859;
  ldv_51858: ;
#line 196
  if ((saa7164_tvnorms___0[i].id & id) != 0ULL) {
#line 197
    goto ldv_51857;
  } else {

  }
#line 195
  i = i + 1U;
  ldv_51859: ;
#line 195
  if (i <= 1U) {
#line 197
    goto ldv_51858;
  } else {

  }
  ldv_51857: ;
#line 199
  if (i == 2U) {
#line 200
    return (-22);
  } else {

  }
#line 202
  port->encodernorm = saa7164_tvnorms___0[i];
#line 203
  port->std = id;
#line 208
  saa7164_api_set_audio_std(port);
#line 210
  if ((saa_debug & 2048U) != 0U) {
#line 210
    printk("\017%s: %s(id=0x%x) OK\n", (char *)(& dev->name), "vidioc_s_std", (unsigned int )id);
  } else {

  }
#line 212
  return (0);
}
}
#line 215 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_g_std___0(struct file *file , void *priv , v4l2_std_id *id ) 
{ 
  struct saa7164_encoder_fh *fh ;
  struct saa7164_port *port ;

  {
#line 217
  fh = (struct saa7164_encoder_fh *)file->private_data;
#line 218
  port = fh->port;
#line 220
  *id = port->std;
#line 221
  return (0);
}
}
#line 224 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_enum_input___0(struct file *file , void *priv , struct v4l2_input *i ) 
{ 
  int n ;
  char *inputs[7U] ;

  {
#line 229
  inputs[0] = (char *)"tuner";
#line 229
  inputs[1] = (char *)"composite";
#line 229
  inputs[2] = (char *)"svideo";
#line 229
  inputs[3] = (char *)"aux";
#line 229
  inputs[4] = (char *)"composite 2";
#line 229
  inputs[5] = (char *)"svideo 2";
#line 229
  inputs[6] = (char *)"aux 2";
#line 232
  if (i->index > 6U) {
#line 233
    return (-22);
  } else {

  }
#line 235
  strcpy((char *)(& i->name), (char const   *)inputs[i->index]);
#line 237
  if (i->index == 0U) {
#line 238
    i->type = 1U;
  } else {
#line 240
    i->type = 2U;
  }
#line 242
  n = 0;
#line 242
  goto ldv_51879;
  ldv_51878: 
#line 243
  i->std = i->std | saa7164_tvnorms___0[n].id;
#line 242
  n = n + 1;
  ldv_51879: ;
#line 242
  if ((unsigned int )n <= 1U) {
#line 244
    goto ldv_51878;
  } else {

  }

#line 245
  return (0);
}
}
#line 248 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_g_input___0(struct file *file , void *priv , unsigned int *i ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  int tmp ;

  {
#line 250
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 251
  port = fh->port;
#line 252
  dev = port->dev;
#line 254
  tmp = saa7164_api_get_videomux(port);
#line 254
  if (tmp != 0) {
#line 255
    return (-5);
  } else {

  }
#line 257
  *i = (unsigned int )((int )port->mux_input + -1);
#line 259
  if ((saa_debug & 2048U) != 0U) {
#line 259
    printk("\017%s: %s() input=%d\n", (char *)(& dev->name), "vidioc_g_input", *i);
  } else {

  }
#line 261
  return (0);
}
}
#line 264 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_s_input___0(struct file *file , void *priv , unsigned int i ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  int tmp ;

  {
#line 266
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 267
  port = fh->port;
#line 268
  dev = port->dev;
#line 270
  if ((saa_debug & 2048U) != 0U) {
#line 270
    printk("\017%s: %s() input=%d\n", (char *)(& dev->name), "vidioc_s_input", i);
  } else {

  }
#line 272
  if (i > 6U) {
#line 273
    return (-22);
  } else {

  }
#line 275
  port->mux_input = (unsigned int )((u8 )i) + 1U;
#line 277
  tmp = saa7164_api_set_videomux(port);
#line 277
  if (tmp != 0) {
#line 278
    return (-5);
  } else {

  }
#line 280
  return (0);
}
}
#line 283 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_g_tuner___0(struct file *file , void *priv , struct v4l2_tuner *t ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 286
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 287
  port = fh->port;
#line 288
  dev = port->dev;
#line 290
  if (t->index != 0U) {
#line 291
    return (-22);
  } else {

  }
#line 293
  strcpy((char *)(& t->name), "tuner");
#line 294
  t->type = 2U;
#line 295
  t->capability = 18U;
#line 297
  if ((saa_debug & 2048U) != 0U) {
#line 297
    printk("\017%s: VIDIOC_G_TUNER: tuner type %d\n", (char *)(& dev->name), t->type);
  } else {

  }
#line 299
  return (0);
}
}
#line 302 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_s_tuner___0(struct file *file , void *priv , struct v4l2_tuner  const  *t ) 
{ 


  {
#line 306
  return (0);
}
}
#line 309 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_g_frequency___0(struct file *file , void *priv , struct v4l2_frequency *f ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;

  {
#line 312
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 313
  port = fh->port;
#line 315
  f->type = 2U;
#line 316
  f->frequency = port->freq;
#line 318
  return (0);
}
}
#line 321 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_s_frequency___0(struct file *file , void *priv , struct v4l2_frequency  const  *f ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  struct saa7164_port *tsport ;
  struct dvb_frontend *fe ;
  struct analog_parameters params ;

  {
#line 324
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 325
  port = fh->port;
#line 326
  dev = port->dev;
#line 331
  params.frequency = f->frequency;
#line 331
  params.mode = 2U;
#line 331
  params.audmode = 1U;
#line 331
  params.std = port->encodernorm.id;
#line 339
  if ((saa_debug & 2048U) != 0U) {
#line 339
    printk("\017%s: %s() frequency=%d tuner=%d\n", (char *)(& dev->name), "vidioc_s_frequency",
           f->frequency, f->tuner);
  } else {

  }
#line 342
  if ((unsigned int )f->tuner != 0U) {
#line 343
    return (-22);
  } else {

  }
#line 345
  if ((unsigned int )f->type != 2U) {
#line 346
    return (-22);
  } else {

  }
#line 348
  port->freq = f->frequency;
#line 351
  if (port->nr == 4) {
#line 352
    tsport = (struct saa7164_port *)(& dev->ports);
  } else
#line 354
  if (port->nr == 5) {
#line 355
    tsport = (struct saa7164_port *)(& dev->ports) + 1UL;
  } else {
#line 357
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"),
                         "i" (357), "i" (12UL));
    ldv_51931: ;
#line 357
    goto ldv_51931;
  }
#line 359
  fe = tsport->dvb.frontend;
#line 361
  if ((unsigned long )fe != (unsigned long )((struct dvb_frontend *)0) && (unsigned long )fe->ops.tuner_ops.set_analog_params != (unsigned long )((int (*)(struct dvb_frontend * ,
                                                                                                                                                           struct analog_parameters * ))0)) {
#line 362
    (*(fe->ops.tuner_ops.set_analog_params))(fe, & params);
  } else {
#line 364
    printk("\v%s() No analog tuner, aborting\n", "vidioc_s_frequency");
  }
#line 366
  saa7164_vbi_initialize(port);
#line 368
  return (0);
}
}
#line 371 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_g_ctrl___0(struct file *file , void *priv , struct v4l2_control *ctl ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 374
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 375
  port = fh->port;
#line 376
  dev = port->dev;
#line 378
  if ((saa_debug & 2048U) != 0U) {
#line 378
    printk("\017%s: %s(id=%d, value=%d)\n", (char *)(& dev->name), "vidioc_g_ctrl",
           ctl->id, ctl->value);
  } else {

  }
#line 381
  switch (ctl->id) {
  case 9963776U: 
#line 383
  ctl->value = (__s32 )port->ctl_brightness;
#line 384
  goto ldv_51942;
  case 9963777U: 
#line 386
  ctl->value = (__s32 )port->ctl_contrast;
#line 387
  goto ldv_51942;
  case 9963778U: 
#line 389
  ctl->value = (__s32 )port->ctl_saturation;
#line 390
  goto ldv_51942;
  case 9963779U: 
#line 392
  ctl->value = (__s32 )port->ctl_hue;
#line 393
  goto ldv_51942;
  case 9963803U: 
#line 395
  ctl->value = (__s32 )port->ctl_sharpness;
#line 396
  goto ldv_51942;
  case 9963781U: 
#line 398
  ctl->value = (__s32 )port->ctl_volume;
#line 399
  goto ldv_51942;
  default: ;
#line 401
  return (-22);
  }
  ldv_51942: ;
#line 404
  return (0);
}
}
#line 407 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_s_ctrl___0(struct file *file , void *priv , struct v4l2_control *ctl ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 410
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 411
  port = fh->port;
#line 412
  dev = port->dev;
#line 413
  ret = 0;
#line 415
  if ((saa_debug & 2048U) != 0U) {
#line 415
    printk("\017%s: %s(id=%d, value=%d)\n", (char *)(& dev->name), "vidioc_s_ctrl",
           ctl->id, ctl->value);
  } else {

  }
#line 418
  switch (ctl->id) {
  case 9963776U: ;
#line 420
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 421
    port->ctl_brightness = (u16 )ctl->value;
#line 422
    saa7164_api_set_usercontrol(port, 2);
  } else {
#line 425
    ret = -22;
  }
#line 426
  goto ldv_51960;
  case 9963777U: ;
#line 428
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 429
    port->ctl_contrast = (u16 )ctl->value;
#line 430
    saa7164_api_set_usercontrol(port, 3);
  } else {
#line 432
    ret = -22;
  }
#line 433
  goto ldv_51960;
  case 9963778U: ;
#line 435
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 436
    port->ctl_saturation = (u16 )ctl->value;
#line 437
    saa7164_api_set_usercontrol(port, 7);
  } else {
#line 440
    ret = -22;
  }
#line 441
  goto ldv_51960;
  case 9963779U: ;
#line 443
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 444
    port->ctl_hue = (u16 )ctl->value;
#line 445
    saa7164_api_set_usercontrol(port, 6);
  } else {
#line 447
    ret = -22;
  }
#line 448
  goto ldv_51960;
  case 9963803U: ;
#line 450
  if (ctl->value >= 0 && ctl->value <= 255) {
#line 451
    port->ctl_sharpness = (u16 )ctl->value;
#line 452
    saa7164_api_set_usercontrol(port, 8);
  } else {
#line 454
    ret = -22;
  }
#line 455
  goto ldv_51960;
  case 9963781U: ;
#line 457
  if (ctl->value >= -83 && ctl->value <= 24) {
#line 458
    port->ctl_volume = (s8 )ctl->value;
#line 459
    saa7164_api_set_audio_volume(port, (int )port->ctl_volume);
  } else {
#line 461
    ret = -22;
  }
#line 462
  goto ldv_51960;
  default: 
#line 464
  ret = -22;
  }
  ldv_51960: ;
#line 467
  return (ret);
}
}
#line 470 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_get_ctrl___0(struct saa7164_port *port , struct v4l2_ext_control *ctrl ) 
{ 
  struct saa7164_vbi_params *params ;

  {
#line 473
  params = & port->vbi_params;
#line 475
  switch (ctrl->id) {
  case 10029312U: 
#line 477
  ctrl->__annonCompField63.value = (__s32 )params->stream_type;
#line 478
  goto ldv_51973;
  case 10029421U: 
#line 480
  ctrl->__annonCompField63.value = (__s32 )params->ctl_mute;
#line 481
  goto ldv_51973;
  case 10029513U: 
#line 483
  ctrl->__annonCompField63.value = (__s32 )params->ctl_aspect;
#line 484
  goto ldv_51973;
  case 10029514U: 
#line 486
  ctrl->__annonCompField63.value = (__s32 )params->refdist;
#line 487
  goto ldv_51973;
  case 10029515U: 
#line 489
  ctrl->__annonCompField63.value = (__s32 )params->gop_size;
#line 490
  goto ldv_51973;
  default: ;
#line 492
  return (-22);
  }
  ldv_51973: ;
#line 494
  return (0);
}
}
#line 497 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_g_ext_ctrls___0(struct file *file , void *priv , struct v4l2_ext_controls *ctrls ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  int i ;
  int err ;
  struct v4l2_ext_control *ctrl ;

  {
#line 500
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 501
  port = fh->port;
#line 502
  err = 0;
#line 504
  if (ctrls->ctrl_class == 10027008U) {
#line 505
    i = 0;
#line 505
    goto ldv_51991;
    ldv_51990: 
#line 506
    ctrl = ctrls->controls + (unsigned long )i;
#line 508
    err = saa7164_get_ctrl___0(port, ctrl);
#line 509
    if (err != 0) {
#line 510
      ctrls->error_idx = (__u32 )i;
#line 511
      goto ldv_51989;
    } else {

    }
#line 505
    i = i + 1;
    ldv_51991: ;
#line 505
    if ((__u32 )i < ctrls->count) {
#line 507
      goto ldv_51990;
    } else {

    }
    ldv_51989: ;
#line 514
    return (err);
  } else {

  }
#line 518
  return (-22);
}
}
#line 521 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_try_ctrl___0(struct v4l2_ext_control *ctrl , int ac3 ) 
{ 
  int ret ;

  {
#line 523
  ret = -22;
#line 525
  switch (ctrl->id) {
  case 10029312U: ;
#line 527
  if (ctrl->__annonCompField63.value == 0 || ctrl->__annonCompField63.value == 1) {
#line 529
    ret = 0;
  } else {

  }
#line 530
  goto ldv_51998;
  case 10029421U: ;
#line 532
  if (ctrl->__annonCompField63.value >= 0 && ctrl->__annonCompField63.value <= 1) {
#line 534
    ret = 0;
  } else {

  }
#line 535
  goto ldv_51998;
  case 10029513U: ;
#line 537
  if (ctrl->__annonCompField63.value >= 0 && ctrl->__annonCompField63.value <= 3) {
#line 539
    ret = 0;
  } else {

  }
#line 540
  goto ldv_51998;
  case 10029515U: ;
#line 542
  if (ctrl->__annonCompField63.value >= 0 && ctrl->__annonCompField63.value <= 255) {
#line 544
    ret = 0;
  } else {

  }
#line 545
  goto ldv_51998;
  case 10029514U: ;
#line 547
  if (ctrl->__annonCompField63.value > 0 && ctrl->__annonCompField63.value <= 3) {
#line 549
    ret = 0;
  } else {

  }
#line 550
  goto ldv_51998;
  default: 
#line 552
  ret = -22;
  }
  ldv_51998: ;
#line 555
  return (ret);
}
}
#line 558 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_try_ext_ctrls___0(struct file *file , void *priv , struct v4l2_ext_controls *ctrls ) 
{ 
  int i ;
  int err ;
  struct v4l2_ext_control *ctrl ;

  {
#line 561
  err = 0;
#line 563
  if (ctrls->ctrl_class == 10027008U) {
#line 564
    i = 0;
#line 564
    goto ldv_52014;
    ldv_52013: 
#line 565
    ctrl = ctrls->controls + (unsigned long )i;
#line 567
    err = saa7164_try_ctrl___0(ctrl, 0);
#line 568
    if (err != 0) {
#line 569
      ctrls->error_idx = (__u32 )i;
#line 570
      goto ldv_52012;
    } else {

    }
#line 564
    i = i + 1;
    ldv_52014: ;
#line 564
    if ((__u32 )i < ctrls->count) {
#line 566
      goto ldv_52013;
    } else {

    }
    ldv_52012: ;
#line 573
    return (err);
  } else {

  }
#line 576
  return (-22);
}
}
#line 579 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_set_ctrl___0(struct saa7164_port *port , struct v4l2_ext_control *ctrl ) 
{ 
  struct saa7164_vbi_params *params ;
  int ret ;

  {
#line 582
  params = & port->vbi_params;
#line 583
  ret = 0;
#line 585
  switch (ctrl->id) {
  case 10029312U: 
#line 587
  params->stream_type = (u32 )ctrl->__annonCompField63.value;
#line 588
  goto ldv_52022;
  case 10029421U: 
#line 590
  params->ctl_mute = (u32 )ctrl->__annonCompField63.value;
#line 591
  ret = saa7164_api_audio_mute(port, (int )params->ctl_mute);
#line 592
  if (ret != 0) {
#line 593
    printk("\v%s() error, ret = 0x%x\n", "saa7164_set_ctrl", ret);
#line 595
    ret = -5;
  } else {

  }
#line 597
  goto ldv_52022;
  case 10029513U: 
#line 599
  params->ctl_aspect = (u32 )ctrl->__annonCompField63.value;
#line 600
  ret = saa7164_api_set_aspect_ratio(port);
#line 601
  if (ret != 0) {
#line 602
    printk("\v%s() error, ret = 0x%x\n", "saa7164_set_ctrl", ret);
#line 604
    ret = -5;
  } else {

  }
#line 606
  goto ldv_52022;
  case 10029514U: 
#line 608
  params->refdist = (u32 )ctrl->__annonCompField63.value;
#line 609
  goto ldv_52022;
  case 10029515U: 
#line 611
  params->gop_size = (u32 )ctrl->__annonCompField63.value;
#line 612
  goto ldv_52022;
  default: ;
#line 614
  return (-22);
  }
  ldv_52022: ;
#line 619
  return (ret);
}
}
#line 622 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_s_ext_ctrls___0(struct file *file , void *priv , struct v4l2_ext_controls *ctrls ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  int i ;
  int err ;
  struct v4l2_ext_control *ctrl ;

  {
#line 625
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 626
  port = fh->port;
#line 627
  err = 0;
#line 629
  if (ctrls->ctrl_class == 10027008U) {
#line 630
    i = 0;
#line 630
    goto ldv_52041;
    ldv_52040: 
#line 631
    ctrl = ctrls->controls + (unsigned long )i;
#line 633
    err = saa7164_try_ctrl___0(ctrl, 0);
#line 634
    if (err != 0) {
#line 635
      ctrls->error_idx = (__u32 )i;
#line 636
      goto ldv_52039;
    } else {

    }
#line 638
    err = saa7164_set_ctrl___0(port, ctrl);
#line 639
    if (err != 0) {
#line 640
      ctrls->error_idx = (__u32 )i;
#line 641
      goto ldv_52039;
    } else {

    }
#line 630
    i = i + 1;
    ldv_52041: ;
#line 630
    if ((__u32 )i < ctrls->count) {
#line 632
      goto ldv_52040;
    } else {

    }
    ldv_52039: ;
#line 644
    return (err);
  } else {

  }
#line 648
  return (-22);
}
}
#line 651 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_querycap___0(struct file *file , void *priv , struct v4l2_capability *cap ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  char const   *tmp ;

  {
#line 654
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 655
  port = fh->port;
#line 656
  dev = port->dev;
#line 658
  strcpy((char *)(& cap->driver), (char const   *)(& dev->name));
#line 659
  strlcpy((char *)(& cap->card), (char const   *)saa7164_boards[dev->board].name,
          32UL);
#line 661
  tmp = pci_name((struct pci_dev  const  *)dev->pci);
#line 661
  sprintf((char *)(& cap->bus_info), "PCI:%s", tmp);
#line 663
  cap->device_caps = 16842768U;
#line 668
  cap->capabilities = cap->device_caps | 2147483649U;
#line 672
  return (0);
}
}
#line 675 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_enum_fmt_vid_cap___0(struct file *file , void *priv , struct v4l2_fmtdesc *f ) 
{ 


  {
#line 678
  if (f->index != 0U) {
#line 679
    return (-22);
  } else {

  }
#line 681
  strlcpy((char *)(& f->description), "VBI", 32UL);
#line 682
  f->pixelformat = 1195724877U;
#line 684
  return (0);
}
}
#line 687 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_g_fmt_vid_cap___0(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 690
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 691
  port = fh->port;
#line 692
  dev = port->dev;
#line 694
  f->fmt.pix.pixelformat = 1195724877U;
#line 695
  f->fmt.pix.bytesperline = 0U;
#line 696
  f->fmt.pix.sizeimage = port->ts_packet_size * port->ts_packet_count;
#line 698
  f->fmt.pix.colorspace = 0U;
#line 699
  f->fmt.pix.width = port->width;
#line 700
  f->fmt.pix.height = port->height;
#line 702
  if ((saa_debug & 2048U) != 0U) {
#line 702
    printk("\017%s: VIDIOC_G_FMT: w: %d, h: %d\n", (char *)(& dev->name), port->width,
           port->height);
  } else {

  }
#line 705
  return (0);
}
}
#line 708 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_try_fmt_vid_cap___0(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 711
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 712
  port = fh->port;
#line 713
  dev = port->dev;
#line 715
  f->fmt.pix.pixelformat = 1195724877U;
#line 716
  f->fmt.pix.bytesperline = 0U;
#line 717
  f->fmt.pix.sizeimage = port->ts_packet_size * port->ts_packet_count;
#line 719
  f->fmt.pix.colorspace = 0U;
#line 720
  if ((saa_debug & 2048U) != 0U) {
#line 720
    printk("\017%s: VIDIOC_TRY_FMT: w: %d, h: %d\n", (char *)(& dev->name), port->width,
           port->height);
  } else {

  }
#line 722
  return (0);
}
}
#line 725 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_s_fmt_vid_cap___0(struct file *file , void *priv , struct v4l2_format *f ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;

  {
#line 728
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 729
  port = fh->port;
#line 730
  dev = port->dev;
#line 732
  f->fmt.pix.pixelformat = 1195724877U;
#line 733
  f->fmt.pix.bytesperline = 0U;
#line 734
  f->fmt.pix.sizeimage = port->ts_packet_size * port->ts_packet_count;
#line 736
  f->fmt.pix.colorspace = 0U;
#line 738
  if ((saa_debug & 2048U) != 0U) {
#line 738
    printk("\017%s: VIDIOC_S_FMT: w: %d, h: %d, f: %d\n", (char *)(& dev->name), f->fmt.pix.width,
           f->fmt.pix.height, f->fmt.pix.field);
  } else {

  }
#line 741
  return (0);
}
}
#line 744 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int fill_queryctrl___0(struct saa7164_vbi_params *params , struct v4l2_queryctrl *c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 747
  switch (c->id) {
  case 9963776U: 
#line 749
  tmp = v4l2_ctrl_query_fill(c, 0, 255, 1, 127);
#line 749
  return (tmp);
  case 9963777U: 
#line 751
  tmp___0 = v4l2_ctrl_query_fill(c, 0, 255, 1, 66);
#line 751
  return (tmp___0);
  case 9963778U: 
#line 753
  tmp___1 = v4l2_ctrl_query_fill(c, 0, 255, 1, 62);
#line 753
  return (tmp___1);
  case 9963779U: 
#line 755
  tmp___2 = v4l2_ctrl_query_fill(c, 0, 255, 1, 128);
#line 755
  return (tmp___2);
  case 9963803U: 
#line 757
  tmp___3 = v4l2_ctrl_query_fill(c, 0, 15, 1, 8);
#line 757
  return (tmp___3);
  case 10029421U: 
#line 759
  tmp___4 = v4l2_ctrl_query_fill(c, 0, 1, 1, 0);
#line 759
  return (tmp___4);
  case 9963781U: 
#line 761
  tmp___5 = v4l2_ctrl_query_fill(c, -83, 24, 1, 20);
#line 761
  return (tmp___5);
  case 10029312U: 
#line 763
  tmp___6 = v4l2_ctrl_query_fill(c, 0, 1, 1, 0);
#line 763
  return (tmp___6);
  case 10029513U: 
#line 768
  tmp___7 = v4l2_ctrl_query_fill(c, 0, 3, 1, 1);
#line 768
  return (tmp___7);
  case 10029515U: 
#line 773
  tmp___8 = v4l2_ctrl_query_fill(c, 1, 255, 1, 15);
#line 773
  return (tmp___8);
  case 10029514U: 
#line 775
  tmp___9 = v4l2_ctrl_query_fill(c, 1, 3, 1, 1);
#line 775
  return (tmp___9);
  default: ;
#line 778
  return (-22);
  }
}
}
#line 782 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int vidioc_queryctrl___0(struct file *file , void *priv , struct v4l2_queryctrl *c ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  int i ;
  int next ;
  u32 id ;
  int tmp ;

  {
#line 785
  fh = (struct saa7164_vbi_fh *)priv;
#line 786
  port = fh->port;
#line 788
  id = c->id;
#line 790
  memset((void *)c, 0, 68UL);
#line 792
  next = (int )id < 0;
#line 793
  c->id = id & 2147483647U;
#line 795
  i = 0;
#line 795
  goto ldv_52110;
  ldv_52109: ;
#line 796
  if (next != 0) {
#line 797
    if (c->id < (__u32 )saa7164_v4l2_ctrls___0[i]) {
#line 798
      c->id = saa7164_v4l2_ctrls___0[i];
    } else {
#line 800
      goto ldv_52107;
    }
  } else {

  }
#line 803
  if (c->id == (__u32 )saa7164_v4l2_ctrls___0[i]) {
#line 804
    tmp = fill_queryctrl___0(& port->vbi_params, c);
#line 804
    return (tmp);
  } else {

  }
#line 806
  if (c->id < (__u32 )saa7164_v4l2_ctrls___0[i]) {
#line 807
    goto ldv_52108;
  } else {

  }
  ldv_52107: 
#line 795
  i = i + 1;
  ldv_52110: ;
#line 795
  if (i == 0) {
#line 797
    goto ldv_52109;
  } else {

  }
  ldv_52108: ;
#line 810
  return (-22);
}
}
#line 813 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_stop_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 815
  dev = port->dev;
#line 818
  ret = saa7164_api_transition_port(port, 0);
#line 819
  if (ret != 0 && ret != 38) {
#line 820
    printk("\v%s() stop transition failed, ret = 0x%x\n", "saa7164_vbi_stop_port",
           ret);
#line 822
    ret = -5;
  } else {
#line 824
    if ((saa_debug & 2048U) != 0U) {
#line 824
      printk("\017%s: %s()    Stopped\n", (char *)(& dev->name), "saa7164_vbi_stop_port");
    } else {

    }
#line 825
    ret = 0;
  }
#line 828
  return (ret);
}
}
#line 831 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_acquire_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 833
  dev = port->dev;
#line 836
  ret = saa7164_api_transition_port(port, 1);
#line 837
  if (ret != 0 && ret != 38) {
#line 838
    printk("\v%s() acquire transition failed, ret = 0x%x\n", "saa7164_vbi_acquire_port",
           ret);
#line 840
    ret = -5;
  } else {
#line 842
    if ((saa_debug & 2048U) != 0U) {
#line 842
      printk("\017%s: %s() Acquired\n", (char *)(& dev->name), "saa7164_vbi_acquire_port");
    } else {

    }
#line 843
    ret = 0;
  }
#line 846
  return (ret);
}
}
#line 849 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_pause_port(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int ret ;

  {
#line 851
  dev = port->dev;
#line 854
  ret = saa7164_api_transition_port(port, 2);
#line 855
  if (ret != 0 && ret != 38) {
#line 856
    printk("\v%s() pause transition failed, ret = 0x%x\n", "saa7164_vbi_pause_port",
           ret);
#line 858
    ret = -5;
  } else {
#line 860
    if ((saa_debug & 2048U) != 0U) {
#line 860
      printk("\017%s: %s()   Paused\n", (char *)(& dev->name), "saa7164_vbi_pause_port");
    } else {

    }
#line 861
    ret = 0;
  }
#line 864
  return (ret);
}
}
#line 873 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_stop_streaming(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_buffer *buf ;
  struct saa7164_user_buffer *ubuf ;
  struct list_head *c ;
  struct list_head *n ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 875
  dev = port->dev;
#line 881
  if ((saa_debug & 2048U) != 0U) {
#line 881
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_vbi_stop_streaming",
           port->nr);
  } else {

  }
#line 883
  ret = saa7164_vbi_pause_port(port);
#line 884
  ret = saa7164_vbi_acquire_port(port);
#line 885
  ret = saa7164_vbi_stop_port(port);
#line 887
  if ((saa_debug & 2048U) != 0U) {
#line 887
    printk("\017%s: %s(port=%d) Hardware stopped\n", (char *)(& dev->name), "saa7164_vbi_stop_streaming",
           port->nr);
  } else {

  }
#line 891
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 894
  c = port->dmaqueue.list.next;
#line 894
  n = c->next;
#line 894
  goto ldv_52142;
  ldv_52141: 
#line 895
  __mptr = (struct list_head  const  *)c;
#line 895
  buf = (struct saa7164_buffer *)__mptr;
#line 896
  buf->flags = 1;
#line 897
  buf->pos = 0U;
#line 894
  c = n;
#line 894
  n = c->next;
  ldv_52142: ;
#line 894
  if ((unsigned long )(& port->dmaqueue.list) != (unsigned long )c) {
#line 896
    goto ldv_52141;
  } else {

  }
#line 900
  c = port->list_buf_used.list.next;
#line 900
  n = c->next;
#line 900
  goto ldv_52147;
  ldv_52146: 
#line 901
  __mptr___0 = (struct list_head  const  *)c;
#line 901
  ubuf = (struct saa7164_user_buffer *)__mptr___0;
#line 902
  ubuf->pos = 0U;
#line 903
  list_move_tail(& ubuf->list, & port->list_buf_free.list);
#line 900
  c = n;
#line 900
  n = c->next;
  ldv_52147: ;
#line 900
  if ((unsigned long )(& port->list_buf_used.list) != (unsigned long )c) {
#line 902
    goto ldv_52146;
  } else {

  }
#line 906
  mutex_unlock(& port->dmaqueue_lock);
#line 909
  saa7164_vbi_buffers_dealloc(port);
#line 911
  if ((saa_debug & 2048U) != 0U) {
#line 911
    printk("\017%s: %s(port=%d) Released\n", (char *)(& dev->name), "saa7164_vbi_stop_streaming",
           port->nr);
  } else {

  }
#line 913
  return (ret);
}
}
#line 916 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_start_streaming(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int result ;
  int ret ;
  int tmp ;

  {
#line 918
  dev = port->dev;
#line 919
  ret = 0;
#line 921
  if ((saa_debug & 2048U) != 0U) {
#line 921
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_vbi_start_streaming",
           port->nr);
  } else {

  }
#line 923
  port->done_first_interrupt = 0U;
#line 929
  saa7164_vbi_buffers_alloc(port);
#line 938
  saa7164_buffer_cfg_port(port);
#line 941
  tmp = saa7164_api_set_vbi_format(port);
#line 941
  if (tmp != 0) {
#line 942
    printk("\v%s() No supported VBI format\n", "saa7164_vbi_start_streaming");
#line 943
    ret = -5;
#line 944
    goto out;
  } else {

  }
#line 948
  result = saa7164_api_transition_port(port, 1);
#line 949
  if (result != 0 && result != 38) {
#line 950
    printk("\v%s() acquire transition failed, res = 0x%x\n", "saa7164_vbi_start_streaming",
           result);
#line 953
    ret = -5;
#line 954
    goto out;
  } else
#line 956
  if ((saa_debug & 2048U) != 0U) {
#line 956
    printk("\017%s: %s()   Acquired\n", (char *)(& dev->name), "saa7164_vbi_start_streaming");
  } else {

  }
#line 959
  result = saa7164_api_transition_port(port, 2);
#line 960
  if (result != 0 && result != 38) {
#line 961
    printk("\v%s() pause transition failed, res = 0x%x\n", "saa7164_vbi_start_streaming",
           result);
#line 965
    result = saa7164_vbi_stop_port(port);
#line 966
    if (result != 0) {
#line 967
      printk("\v%s() pause/forced stop transition failed, res = 0x%x\n", "saa7164_vbi_start_streaming",
             result);
    } else {

    }
#line 971
    ret = -5;
#line 972
    goto out;
  } else
#line 974
  if ((saa_debug & 2048U) != 0U) {
#line 974
    printk("\017%s: %s()   Paused\n", (char *)(& dev->name), "saa7164_vbi_start_streaming");
  } else {

  }
#line 977
  result = saa7164_api_transition_port(port, 3);
#line 978
  if (result != 0 && result != 38) {
#line 979
    printk("\v%s() run transition failed, result = 0x%x\n", "saa7164_vbi_start_streaming",
           result);
#line 983
    result = saa7164_vbi_acquire_port(port);
#line 984
    result = saa7164_vbi_stop_port(port);
#line 985
    if (result != 0) {
#line 986
      printk("\v%s() run/forced stop transition failed, res = 0x%x\n", "saa7164_vbi_start_streaming",
             result);
    } else {

    }
#line 990
    ret = -5;
  } else
#line 992
  if ((saa_debug & 2048U) != 0U) {
#line 992
    printk("\017%s: %s()   Running\n", (char *)(& dev->name), "saa7164_vbi_start_streaming");
  } else {

  }
  out: ;
#line 995
  return (ret);
}
}
#line 998 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int saa7164_vbi_fmt(struct file *file , void *priv , struct v4l2_format *f ) 
{ 


  {
#line 1002
  f->fmt.vbi.samples_per_line = 1600U;
#line 1003
  f->fmt.vbi.samples_per_line = 1440U;
#line 1004
  f->fmt.vbi.sampling_rate = 27000000U;
#line 1005
  f->fmt.vbi.sample_format = 1497715271U;
#line 1006
  f->fmt.vbi.offset = 0U;
#line 1007
  f->fmt.vbi.flags = 0U;
#line 1008
  f->fmt.vbi.start[0] = 10;
#line 1009
  f->fmt.vbi.count[0] = 18U;
#line 1010
  f->fmt.vbi.start[1] = 274;
#line 1011
  f->fmt.vbi.count[1] = 18U;
#line 1012
  return (0);
}
}
#line 1015 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int fops_open___0(struct file *file ) 
{ 
  struct saa7164_dev *dev ;
  struct saa7164_port *port ;
  struct saa7164_vbi_fh *fh ;
  struct video_device *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1021
  tmp = video_devdata(file);
#line 1021
  tmp___0 = video_get_drvdata(tmp);
#line 1021
  port = (struct saa7164_port *)tmp___0;
#line 1022
  if ((unsigned long )port == (unsigned long )((struct saa7164_port *)0)) {
#line 1023
    return (-19);
  } else {

  }
#line 1025
  dev = port->dev;
#line 1027
  if ((saa_debug & 2048U) != 0U) {
#line 1027
    printk("\017%s: %s()\n", (char *)(& dev->name), "fops_open");
  } else {

  }
#line 1030
  tmp___1 = kzalloc(16UL, 208U);
#line 1030
  fh = (struct saa7164_vbi_fh *)tmp___1;
#line 1031
  if ((unsigned long )fh == (unsigned long )((struct saa7164_vbi_fh *)0)) {
#line 1032
    return (-12);
  } else {

  }
#line 1034
  file->private_data = (void *)fh;
#line 1035
  fh->port = port;
#line 1037
  return (0);
}
}
#line 1040 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static int fops_release___0(struct file *file ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_dev *dev ;
  int tmp ;
  int tmp___0 ;

  {
#line 1042
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 1043
  port = fh->port;
#line 1044
  dev = port->dev;
#line 1046
  if ((saa_debug & 2048U) != 0U) {
#line 1046
    printk("\017%s: %s()\n", (char *)(& dev->name), "fops_release");
  } else {

  }
#line 1049
  tmp___0 = atomic_cmpxchg(& fh->v4l_reading, 1, 0);
#line 1049
  if (tmp___0 == 1) {
#line 1050
    tmp = atomic_sub_return(1, & port->v4l_reader_count);
#line 1050
    if (tmp == 0) {
#line 1052
      saa7164_vbi_stop_streaming(port);
    } else {

    }
  } else {

  }
#line 1056
  file->private_data = (void *)0;
#line 1057
  kfree((void const   *)fh);
#line 1059
  return (0);
}
}
#line 1063 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static struct saa7164_user_buffer *saa7164_vbi_next_buf(struct saa7164_port *port ) 
{ 
  struct saa7164_user_buffer *ubuf ;
  struct saa7164_dev *dev ;
  u32 crc ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1065
  ubuf = (struct saa7164_user_buffer *)0;
#line 1066
  dev = port->dev;
#line 1069
  mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 1070
  tmp = list_empty((struct list_head  const  *)(& port->list_buf_used.list));
#line 1070
  if (tmp == 0) {
#line 1071
    __mptr = (struct list_head  const  *)port->list_buf_used.list.next;
#line 1071
    ubuf = (struct saa7164_user_buffer *)__mptr;
#line 1074
    if (crc_checking != 0U) {
#line 1075
      crc = crc32_le(0U, (unsigned char const   *)ubuf->data, (size_t )ubuf->actual_size);
#line 1076
      if (ubuf->crc != crc) {
#line 1077
        printk("\v%s() ubuf %p crc became invalid, was 0x%x became 0x%x\n", "saa7164_vbi_next_buf",
               ubuf, ubuf->crc, crc);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1084
  mutex_unlock(& port->dmaqueue_lock);
#line 1086
  if ((saa_debug & 2048U) != 0U) {
#line 1086
    printk("\017%s: %s() returns %p\n", (char *)(& dev->name), "saa7164_vbi_next_buf",
           ubuf);
  } else {

  }
#line 1088
  return (ubuf);
}
}
#line 1091 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static ssize_t fops_read___0(struct file *file , char *buffer , size_t count , loff_t *pos ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  struct saa7164_user_buffer *ubuf ;
  struct saa7164_dev *dev ;
  int ret ;
  int rem ;
  int cnt ;
  u8 *p ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___3 ;
  struct saa7164_user_buffer *tmp___4 ;
  struct saa7164_user_buffer *tmp___5 ;
  unsigned long tmp___6 ;
  int __ret___1 ;
  wait_queue_t __wait___0 ;
  long __ret___2 ;
  long __int___0 ;
  long tmp___7 ;
  struct saa7164_user_buffer *tmp___8 ;
  struct saa7164_user_buffer *tmp___9 ;

  {
#line 1094
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 1095
  port = fh->port;
#line 1096
  ubuf = (struct saa7164_user_buffer *)0;
#line 1097
  dev = port->dev;
#line 1098
  ret = 0;
#line 1102
  port->last_read_msecs_diff = port->last_read_msecs;
#line 1103
  tmp = jiffies_to_msecs(jiffies);
#line 1103
  port->last_read_msecs = (u64 )tmp;
#line 1104
  port->last_read_msecs_diff = port->last_read_msecs - port->last_read_msecs_diff;
#line 1107
  saa7164_histogram_update(& port->read_interval, (u32 )port->last_read_msecs_diff);
#line 1110
  if (*pos != 0LL) {
#line 1111
    printk("\v%s() ESPIPE\n", "fops_read");
#line 1112
    return (-29L);
  } else {

  }
#line 1115
  tmp___2 = atomic_cmpxchg(& fh->v4l_reading, 0, 1);
#line 1115
  if (tmp___2 == 0) {
#line 1116
    tmp___1 = atomic_add_return(1, & port->v4l_reader_count);
#line 1116
    if (tmp___1 == 1) {
#line 1118
      tmp___0 = saa7164_vbi_initialize(port);
#line 1118
      if (tmp___0 < 0) {
#line 1119
        printk("\v%s() EINVAL\n", "fops_read");
#line 1120
        return (-22L);
      } else {

      }
#line 1123
      saa7164_vbi_start_streaming(port);
#line 1124
      msleep(200U);
    } else {

    }
  } else {

  }
#line 1129
  if ((file->f_flags & 2048U) == 0U) {
#line 1130
    __ret = 0;
#line 1130
    __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c",
                  1131, 0);
#line 1130
    tmp___5 = saa7164_vbi_next_buf(port);
#line 1130
    if ((unsigned long )tmp___5 == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1130
      __ret___0 = 0L;
#line 1130
      INIT_LIST_HEAD(& __wait.task_list);
#line 1130
      __wait.flags = 0U;
      ldv_52206: 
#line 1130
      tmp___3 = prepare_to_wait_event(& port->wait_read, & __wait, 1);
#line 1130
      __int = tmp___3;
#line 1130
      tmp___4 = saa7164_vbi_next_buf(port);
#line 1130
      if ((unsigned long )tmp___4 != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1130
        goto ldv_52205;
      } else {

      }
#line 1130
      if (__int != 0L) {
#line 1130
        __ret___0 = __int;
#line 1130
        goto ldv_52205;
      } else {

      }
#line 1130
      schedule();
#line 1130
      goto ldv_52206;
      ldv_52205: 
#line 1130
      finish_wait(& port->wait_read, & __wait);
#line 1130
      __ret = (int )__ret___0;
    } else {

    }
#line 1130
    if (__ret != 0) {
#line 1132
      printk("\v%s() ERESTARTSYS\n", "fops_read");
#line 1133
      return (-512L);
    } else {

    }
  } else {

  }
#line 1138
  ubuf = saa7164_vbi_next_buf(port);
#line 1140
  goto ldv_52221;
  ldv_52220: 
#line 1143
  rem = (int )(ubuf->actual_size - ubuf->pos);
#line 1144
  cnt = (int )(count < (size_t )rem ? count : (size_t )rem);
#line 1146
  p = ubuf->data + (unsigned long )ubuf->pos;
#line 1148
  if ((saa_debug & 2048U) != 0U) {
#line 1148
    printk("\017%s: %s() count=%d cnt=%d rem=%d buf=%p buf->pos=%d\n", (char *)(& dev->name),
           "fops_read", (int )count, cnt, rem, ubuf, ubuf->pos);
  } else {

  }
#line 1152
  tmp___6 = copy_to_user((void *)buffer, (void const   *)p, (unsigned long )cnt);
#line 1152
  if (tmp___6 != 0UL) {
#line 1153
    printk("\v%s() copy_to_user failed\n", "fops_read");
#line 1154
    if (ret == 0) {
#line 1155
      printk("\v%s() EFAULT\n", "fops_read");
#line 1156
      ret = -14;
    } else {

    }
#line 1158
    goto err;
  } else {

  }
#line 1161
  ubuf->pos = ubuf->pos + (u32 )cnt;
#line 1162
  count = count - (size_t )cnt;
#line 1163
  buffer = buffer + (unsigned long )cnt;
#line 1164
  ret = ret + cnt;
#line 1166
  if (ubuf->pos > ubuf->actual_size) {
#line 1167
    printk("\vread() pos > actual, huh?\n");
  } else {

  }
#line 1169
  if (ubuf->pos == ubuf->actual_size) {
#line 1174
    ubuf->pos = 0U;
#line 1176
    mutex_lock_nested(& port->dmaqueue_lock, 0U);
#line 1177
    list_move_tail(& ubuf->list, & port->list_buf_free.list);
#line 1178
    mutex_unlock(& port->dmaqueue_lock);
#line 1181
    if ((file->f_flags & 2048U) == 0U) {
#line 1182
      __ret___1 = 0;
#line 1182
      __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c",
                    1183, 0);
#line 1182
      tmp___9 = saa7164_vbi_next_buf(port);
#line 1182
      if ((unsigned long )tmp___9 == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1182
        __ret___2 = 0L;
#line 1182
        INIT_LIST_HEAD(& __wait___0.task_list);
#line 1182
        __wait___0.flags = 0U;
        ldv_52216: 
#line 1182
        tmp___7 = prepare_to_wait_event(& port->wait_read, & __wait___0, 1);
#line 1182
        __int___0 = tmp___7;
#line 1182
        tmp___8 = saa7164_vbi_next_buf(port);
#line 1182
        if ((unsigned long )tmp___8 != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1182
          goto ldv_52215;
        } else {

        }
#line 1182
        if (__int___0 != 0L) {
#line 1182
          __ret___2 = __int___0;
#line 1182
          goto ldv_52215;
        } else {

        }
#line 1182
        schedule();
#line 1182
        goto ldv_52216;
        ldv_52215: 
#line 1182
        finish_wait(& port->wait_read, & __wait___0);
#line 1182
        __ret___1 = (int )__ret___2;
      } else {

      }
#line 1182
      if (__ret___1 != 0) {
#line 1184
        goto ldv_52219;
      } else {

      }
    } else {

    }
#line 1187
    ubuf = saa7164_vbi_next_buf(port);
  } else {

  }
  ldv_52221: ;
#line 1140
  if (count != 0UL && (unsigned long )ubuf != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1142
    goto ldv_52220;
  } else {

  }
  ldv_52219: ;
  err: ;
#line 1191
  if (ret == 0 && (unsigned long )ubuf == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1192
    printk("\v%s() EAGAIN\n", "fops_read");
#line 1193
    ret = -11;
  } else {

  }
#line 1196
  return ((ssize_t )ret);
}
}
#line 1199 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static unsigned int fops_poll___0(struct file *file , poll_table *wait ) 
{ 
  struct saa7164_vbi_fh *fh ;
  struct saa7164_port *port ;
  unsigned int mask ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___4 ;
  struct saa7164_user_buffer *tmp___5 ;
  struct saa7164_user_buffer *tmp___6 ;
  int tmp___7 ;

  {
#line 1201
  fh = (struct saa7164_vbi_fh *)file->private_data;
#line 1202
  port = fh->port;
#line 1203
  mask = 0U;
#line 1205
  port->last_poll_msecs_diff = port->last_poll_msecs;
#line 1206
  tmp = jiffies_to_msecs(jiffies);
#line 1206
  port->last_poll_msecs = (u64 )tmp;
#line 1207
  port->last_poll_msecs_diff = port->last_poll_msecs - port->last_poll_msecs_diff;
#line 1210
  saa7164_histogram_update(& port->poll_interval, (u32 )port->last_poll_msecs_diff);
#line 1213
  tmp___0 = video_is_registered(port->v4l_device);
#line 1213
  if (tmp___0 == 0) {
#line 1214
    return (4294967291U);
  } else {

  }
#line 1216
  tmp___3 = atomic_cmpxchg(& fh->v4l_reading, 0, 1);
#line 1216
  if (tmp___3 == 0) {
#line 1217
    tmp___2 = atomic_add_return(1, & port->v4l_reader_count);
#line 1217
    if (tmp___2 == 1) {
#line 1218
      tmp___1 = saa7164_vbi_initialize(port);
#line 1218
      if (tmp___1 < 0) {
#line 1219
        return (4294967274U);
      } else {

      }
#line 1220
      saa7164_vbi_start_streaming(port);
#line 1221
      msleep(200U);
    } else {

    }
  } else {

  }
#line 1226
  if ((file->f_flags & 2048U) == 0U) {
#line 1227
    __ret = 0;
#line 1227
    __might_sleep("/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c",
                  1228, 0);
#line 1227
    tmp___6 = saa7164_vbi_next_buf(port);
#line 1227
    if ((unsigned long )tmp___6 == (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1227
      __ret___0 = 0L;
#line 1227
      INIT_LIST_HEAD(& __wait.task_list);
#line 1227
      __wait.flags = 0U;
      ldv_52235: 
#line 1227
      tmp___4 = prepare_to_wait_event(& port->wait_read, & __wait, 1);
#line 1227
      __int = tmp___4;
#line 1227
      tmp___5 = saa7164_vbi_next_buf(port);
#line 1227
      if ((unsigned long )tmp___5 != (unsigned long )((struct saa7164_user_buffer *)0)) {
#line 1227
        goto ldv_52234;
      } else {

      }
#line 1227
      if (__int != 0L) {
#line 1227
        __ret___0 = __int;
#line 1227
        goto ldv_52234;
      } else {

      }
#line 1227
      schedule();
#line 1227
      goto ldv_52235;
      ldv_52234: 
#line 1227
      finish_wait(& port->wait_read, & __wait);
#line 1227
      __ret = (int )__ret___0;
    } else {

    }
#line 1227
    if (__ret != 0) {
#line 1229
      return (4294966784U);
    } else {

    }
  } else {

  }
#line 1234
  tmp___7 = list_empty((struct list_head  const  *)(& port->list_buf_used.list));
#line 1234
  if (tmp___7 == 0) {
#line 1235
    mask = mask | 65U;
  } else {

  }
#line 1237
  return (mask);
}
}
#line 1239 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static struct v4l2_file_operations  const  vbi_fops  = 
#line 1239
     {& __this_module, & fops_read___0, 0, & fops_poll___0, & video_ioctl2, 0, 0, 0,
    & fops_open___0, & fops_release___0};
#line 1248 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static struct v4l2_ioctl_ops  const  vbi_ioctl_ops  = 
#line 1248
     {& vidioc_querycap___0, & vidioc_enum_fmt_vid_cap___0, 0, 0, 0, 0, 0, & vidioc_g_fmt_vid_cap___0,
    0, 0, 0, & saa7164_vbi_fmt, 0, 0, 0, 0, 0, 0, & vidioc_s_fmt_vid_cap___0, 0, 0,
    0, & saa7164_vbi_fmt, 0, 0, 0, 0, 0, 0, & vidioc_try_fmt_vid_cap___0, 0, 0, 0,
    & saa7164_vbi_fmt, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_g_std___0,
    & vidioc_s_std___0, 0, & vidioc_enum_input___0, & vidioc_g_input___0, & vidioc_s_input___0,
    0, 0, 0, & vidioc_queryctrl___0, 0, & vidioc_g_ctrl___0, & vidioc_s_ctrl___0,
    & vidioc_g_ext_ctrls___0, & vidioc_s_ext_ctrls___0, & vidioc_try_ext_ctrls___0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_g_tuner___0,
    & vidioc_s_tuner___0, & vidioc_g_frequency___0, & vidioc_s_frequency___0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1274 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static struct video_device saa7164_vbi_template  = 
#line 1274
     {{{0, 0}, 0, 0U, 0, 0U, 0U, 0UL, 0U, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, 0, 0, 0, 0, 0, 0, {{0U, 0U}}}, & vbi_fops, {0, 0, {0, {0,
                                                                               0},
                                                                           0, 0, 0,
                                                                           0, {{0}},
                                                                           {{{0L},
                                                                             {0, 0},
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                            {{0, 0},
                                                                             0UL,
                                                                             0, 0UL,
                                                                             0U, 0,
                                                                             0, 0,
                                                                             {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                                                             {0, {0,
                                                                                  0},
                                                                              0, 0,
                                                                              0UL}},
                                                                            0, 0},
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0},
                                                                    0, 0, {{0}, {{{{{0}},
                                                                                   0U,
                                                                                   0U,
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}}}},
                                                                           {0, 0},
                                                                           0, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                                    0, 0, 0, 0, {{0},
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0,
                                                                                 {{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0},
                                                                                 {0U,
                                                                                  {{{{{{0}},
                                                                                      0U,
                                                                                      0U,
                                                                                      0,
                                                                                      {0,
                                                                                       {0,
                                                                                        0},
                                                                                       0,
                                                                                       0,
                                                                                       0UL}}}},
                                                                                   {0,
                                                                                    0}}},
                                                                                 0,
                                                                                 (_Bool)0,
                                                                                 (_Bool)0,
                                                                                 {{0,
                                                                                   0},
                                                                                  0UL,
                                                                                  0,
                                                                                  0UL,
                                                                                  0U,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  {(char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0},
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}},
                                                                                 0UL,
                                                                                 {{0L},
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}},
                                                                                 {{{{{{0}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0}},
                                                                                 0,
                                                                                 {0},
                                                                                 {0},
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0UL,
                                                                                 0UL,
                                                                                 0UL,
                                                                                 0UL,
                                                                                 0,
                                                                                 0,
                                                                                 0},
                                                                    0, 0, 0, 0, 0ULL,
                                                                    0UL, 0, {0, 0},
                                                                    0, 0, {0, 0},
                                                                    0, 0, 0U, 0U,
                                                                    {{{{{0}}, 0U,
                                                                       0U, 0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                                    {0, 0}, {0, {0,
                                                                                 0},
                                                                             {{0}}},
                                                                    0, 0, 0, 0, (_Bool)0,
                                                                    (_Bool)0}, 0,
    0, 0, 0, 0, 0, {'s', 'a', 'a', '7', '1', '6', '4', '\000'}, 0, 0, -1, (unsigned short)0,
    0UL, 0, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 28672ULL, 0,
    & vbi_ioctl_ops, {0UL, 0UL, 0UL}, {0UL, 0UL, 0UL}, 0};
#line 1282 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
static struct video_device *saa7164_vbi_alloc(struct saa7164_port *port , struct pci_dev *pci ,
                                              struct video_device *template , char *type ) 
{ 
  struct video_device *vfd ;
  struct saa7164_dev *dev ;

  {
#line 1289
  dev = port->dev;
#line 1291
  if ((saa_debug & 2048U) != 0U) {
#line 1291
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_vbi_alloc");
  } else {

  }
#line 1293
  vfd = video_device_alloc();
#line 1294
  if ((unsigned long )vfd == (unsigned long )((struct video_device *)0)) {
#line 1295
    return ((struct video_device *)0);
  } else {

  }
#line 1297
  *vfd = *template;
#line 1298
  snprintf((char *)(& vfd->name), 32UL, "%s %s (%s)", (char *)(& dev->name), type,
           saa7164_boards[dev->board].name);
#line 1301
  vfd->v4l2_dev = & dev->v4l2_dev;
#line 1302
  vfd->release = & video_device_release;
#line 1303
  return (vfd);
}
}
#line 1306 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
int saa7164_vbi_register(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;
  int result ;

  {
#line 1308
  dev = port->dev;
#line 1309
  result = -19;
#line 1311
  if ((saa_debug & 2048U) != 0U) {
#line 1311
    printk("\017%s: %s()\n", (char *)(& dev->name), "saa7164_vbi_register");
  } else {

  }
#line 1313
  if ((unsigned int )port->type != 3U) {
#line 1314
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"),
                         "i" (1314), "i" (12UL));
    ldv_52256: ;
#line 1314
    goto ldv_52256;
  } else {

  }
#line 1317
  if (port->hwcfg.BARLocation == 0U) {
#line 1318
    printk("\v%s() failed (errno = %d), NO PCI configuration\n", "saa7164_vbi_register",
           result);
#line 1321
    result = -12;
#line 1322
    goto failed;
  } else {

  }
#line 1328
  port->v4l_device = saa7164_vbi_alloc(port, dev->pci, & saa7164_vbi_template, (char *)"vbi");
#line 1331
  if ((unsigned long )port->v4l_device == (unsigned long )((struct video_device *)0)) {
#line 1332
    printk("\016%s: can\'t allocate vbi device\n", (char *)(& dev->name));
#line 1334
    result = -12;
#line 1335
    goto failed;
  } else {

  }
#line 1338
  port->std = 4096ULL;
#line 1339
  video_set_drvdata(port->v4l_device, (void *)port);
#line 1340
  result = video_register_device(port->v4l_device, 1, -1);
#line 1342
  if (result < 0) {
#line 1343
    printk("\016%s: can\'t register vbi device\n", (char *)(& dev->name));
#line 1348
    goto failed;
  } else {

  }
#line 1351
  printk("\016%s: registered device vbi%d [vbi]\n", (char *)(& dev->name), (int )(port->v4l_device)->num);
#line 1356
  result = 0;
  failed: ;
#line 1358
  return (result);
}
}
#line 1361 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"
void saa7164_vbi_unregister(struct saa7164_port *port ) 
{ 
  struct saa7164_dev *dev ;

  {
#line 1363
  dev = port->dev;
#line 1365
  if ((saa_debug & 2048U) != 0U) {
#line 1365
    printk("\017%s: %s(port=%d)\n", (char *)(& dev->name), "saa7164_vbi_unregister",
           port->nr);
  } else {

  }
#line 1367
  if ((unsigned int )port->type != 3U) {
#line 1368
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.c"),
                         "i" (1368), "i" (12UL));
    ldv_52263: ;
#line 1368
    goto ldv_52263;
  } else {

  }
#line 1370
  if ((unsigned long )port->v4l_device != (unsigned long )((struct video_device *)0)) {
#line 1371
    if ((port->v4l_device)->minor != -1) {
#line 1372
      video_unregister_device(port->v4l_device);
    } else {
#line 1374
      video_device_release(port->v4l_device);
    }
#line 1376
    port->v4l_device = (struct video_device *)0;
  } else {

  }
#line 1378
  return;
}
}
#line 143 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
int ldv_retval_1  ;
#line 146 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
void ldv_initialize_v4l2_file_operations_7(void) 
{ 
  void *tmp ;

  {
#line 147
  tmp = __VERIFIER_nondet_pointer();
#line 147
  vbi_fops_group0 = (struct file *)tmp;
#line 148
  return;
}
}
#line 150 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_6(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 151
  tmp = ldv_init_zalloc(208UL);
#line 151
  vbi_ioctl_ops_group2 = (struct v4l2_format *)tmp;
#line 152
  tmp___0 = ldv_init_zalloc(32UL);
#line 152
  vbi_ioctl_ops_group1 = (struct v4l2_ext_controls *)tmp___0;
#line 153
  tmp___1 = ldv_init_zalloc(8UL);
#line 153
  vbi_ioctl_ops_group0 = (struct v4l2_control *)tmp___1;
#line 154
  tmp___2 = __VERIFIER_nondet_pointer();
#line 154
  vbi_ioctl_ops_group3 = (struct file *)tmp___2;
#line 155
  return;
}
}
#line 157 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
void ldv_main_exported_6(void) 
{ 
  struct v4l2_fmtdesc *ldvarg19 ;
  void *tmp ;
  void *ldvarg22 ;
  void *tmp___0 ;
  void *ldvarg25 ;
  void *tmp___1 ;
  void *ldvarg17 ;
  void *tmp___2 ;
  struct v4l2_queryctrl *ldvarg21 ;
  void *tmp___3 ;
  void *ldvarg30 ;
  void *tmp___4 ;
  void *ldvarg15 ;
  void *tmp___5 ;
  void *ldvarg27 ;
  void *tmp___6 ;
  v4l2_std_id ldvarg26 ;
  void *ldvarg9 ;
  void *tmp___7 ;
  struct v4l2_capability *ldvarg10 ;
  void *tmp___8 ;
  void *ldvarg13 ;
  void *tmp___9 ;
  struct v4l2_frequency *ldvarg8 ;
  void *tmp___10 ;
  void *ldvarg3 ;
  void *tmp___11 ;
  void *ldvarg31 ;
  void *tmp___12 ;
  void *ldvarg20 ;
  void *tmp___13 ;
  void *ldvarg2 ;
  void *tmp___14 ;
  void *ldvarg28 ;
  void *tmp___15 ;
  void *ldvarg34 ;
  void *tmp___16 ;
  struct v4l2_frequency *ldvarg14 ;
  void *tmp___17 ;
  struct v4l2_input *ldvarg4 ;
  void *tmp___18 ;
  v4l2_std_id *ldvarg6 ;
  void *tmp___19 ;
  void *ldvarg16 ;
  void *tmp___20 ;
  void *ldvarg33 ;
  void *tmp___21 ;
  void *ldvarg5 ;
  void *tmp___22 ;
  void *ldvarg0 ;
  void *tmp___23 ;
  struct v4l2_tuner *ldvarg24 ;
  void *tmp___24 ;
  void *ldvarg29 ;
  void *tmp___25 ;
  unsigned int ldvarg1 ;
  unsigned int *ldvarg12 ;
  void *tmp___26 ;
  void *ldvarg23 ;
  void *tmp___27 ;
  void *ldvarg7 ;
  void *tmp___28 ;
  struct v4l2_tuner *ldvarg32 ;
  void *tmp___29 ;
  void *ldvarg11 ;
  void *tmp___30 ;
  void *ldvarg18 ;
  void *tmp___31 ;
  int tmp___32 ;

  {
#line 158
  tmp = ldv_init_zalloc(64UL);
#line 158
  ldvarg19 = (struct v4l2_fmtdesc *)tmp;
#line 159
  tmp___0 = ldv_init_zalloc(1UL);
#line 159
  ldvarg22 = tmp___0;
#line 160
  tmp___1 = ldv_init_zalloc(1UL);
#line 160
  ldvarg25 = tmp___1;
#line 161
  tmp___2 = ldv_init_zalloc(1UL);
#line 161
  ldvarg17 = tmp___2;
#line 162
  tmp___3 = ldv_init_zalloc(68UL);
#line 162
  ldvarg21 = (struct v4l2_queryctrl *)tmp___3;
#line 163
  tmp___4 = ldv_init_zalloc(1UL);
#line 163
  ldvarg30 = tmp___4;
#line 164
  tmp___5 = ldv_init_zalloc(1UL);
#line 164
  ldvarg15 = tmp___5;
#line 165
  tmp___6 = ldv_init_zalloc(1UL);
#line 165
  ldvarg27 = tmp___6;
#line 167
  tmp___7 = ldv_init_zalloc(1UL);
#line 167
  ldvarg9 = tmp___7;
#line 168
  tmp___8 = ldv_init_zalloc(104UL);
#line 168
  ldvarg10 = (struct v4l2_capability *)tmp___8;
#line 169
  tmp___9 = ldv_init_zalloc(1UL);
#line 169
  ldvarg13 = tmp___9;
#line 170
  tmp___10 = ldv_init_zalloc(44UL);
#line 170
  ldvarg8 = (struct v4l2_frequency *)tmp___10;
#line 171
  tmp___11 = ldv_init_zalloc(1UL);
#line 171
  ldvarg3 = tmp___11;
#line 172
  tmp___12 = ldv_init_zalloc(1UL);
#line 172
  ldvarg31 = tmp___12;
#line 173
  tmp___13 = ldv_init_zalloc(1UL);
#line 173
  ldvarg20 = tmp___13;
#line 174
  tmp___14 = ldv_init_zalloc(1UL);
#line 174
  ldvarg2 = tmp___14;
#line 175
  tmp___15 = ldv_init_zalloc(1UL);
#line 175
  ldvarg28 = tmp___15;
#line 176
  tmp___16 = ldv_init_zalloc(1UL);
#line 176
  ldvarg34 = tmp___16;
#line 177
  tmp___17 = ldv_init_zalloc(44UL);
#line 177
  ldvarg14 = (struct v4l2_frequency *)tmp___17;
#line 178
  tmp___18 = ldv_init_zalloc(80UL);
#line 178
  ldvarg4 = (struct v4l2_input *)tmp___18;
#line 179
  tmp___19 = ldv_init_zalloc(8UL);
#line 179
  ldvarg6 = (v4l2_std_id *)tmp___19;
#line 180
  tmp___20 = ldv_init_zalloc(1UL);
#line 180
  ldvarg16 = tmp___20;
#line 181
  tmp___21 = ldv_init_zalloc(1UL);
#line 181
  ldvarg33 = tmp___21;
#line 182
  tmp___22 = ldv_init_zalloc(1UL);
#line 182
  ldvarg5 = tmp___22;
#line 183
  tmp___23 = ldv_init_zalloc(1UL);
#line 183
  ldvarg0 = tmp___23;
#line 184
  tmp___24 = ldv_init_zalloc(84UL);
#line 184
  ldvarg24 = (struct v4l2_tuner *)tmp___24;
#line 185
  tmp___25 = ldv_init_zalloc(1UL);
#line 185
  ldvarg29 = tmp___25;
#line 187
  tmp___26 = ldv_init_zalloc(4UL);
#line 187
  ldvarg12 = (unsigned int *)tmp___26;
#line 188
  tmp___27 = ldv_init_zalloc(1UL);
#line 188
  ldvarg23 = tmp___27;
#line 189
  tmp___28 = ldv_init_zalloc(1UL);
#line 189
  ldvarg7 = tmp___28;
#line 190
  tmp___29 = ldv_init_zalloc(84UL);
#line 190
  ldvarg32 = (struct v4l2_tuner *)tmp___29;
#line 191
  tmp___30 = ldv_init_zalloc(1UL);
#line 191
  ldvarg11 = tmp___30;
#line 192
  tmp___31 = ldv_init_zalloc(1UL);
#line 192
  ldvarg18 = tmp___31;
#line 166
  ldv_memset((void *)(& ldvarg26), 0, 8UL);
#line 186
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
#line 194
  tmp___32 = __VERIFIER_nondet_int();
#line 194
  switch (tmp___32) {
  case 0: ;
#line 197
  if (ldv_state_variable_6 == 1) {
#line 199
    vidioc_s_ctrl___0(vbi_ioctl_ops_group3, ldvarg34, vbi_ioctl_ops_group0);
#line 201
    ldv_state_variable_6 = 1;
  } else {

  }
#line 204
  goto ldv_52310;
  case 1: ;
#line 207
  if (ldv_state_variable_6 == 1) {
#line 209
    vidioc_g_tuner___0(vbi_ioctl_ops_group3, ldvarg33, ldvarg32);
#line 211
    ldv_state_variable_6 = 1;
  } else {

  }
#line 214
  goto ldv_52310;
  case 2: ;
#line 217
  if (ldv_state_variable_6 == 1) {
#line 219
    vidioc_g_ext_ctrls___0(vbi_ioctl_ops_group3, ldvarg31, vbi_ioctl_ops_group1);
#line 221
    ldv_state_variable_6 = 1;
  } else {

  }
#line 224
  goto ldv_52310;
  case 3: ;
#line 227
  if (ldv_state_variable_6 == 1) {
#line 229
    saa7164_vbi_fmt(vbi_ioctl_ops_group3, ldvarg30, vbi_ioctl_ops_group2);
#line 231
    ldv_state_variable_6 = 1;
  } else {

  }
#line 234
  goto ldv_52310;
  case 4: ;
#line 237
  if (ldv_state_variable_6 == 1) {
#line 239
    vidioc_g_ctrl___0(vbi_ioctl_ops_group3, ldvarg29, vbi_ioctl_ops_group0);
#line 241
    ldv_state_variable_6 = 1;
  } else {

  }
#line 244
  goto ldv_52310;
  case 5: ;
#line 247
  if (ldv_state_variable_6 == 1) {
#line 249
    vidioc_try_fmt_vid_cap___0(vbi_ioctl_ops_group3, ldvarg28, vbi_ioctl_ops_group2);
#line 251
    ldv_state_variable_6 = 1;
  } else {

  }
#line 254
  goto ldv_52310;
  case 6: ;
#line 257
  if (ldv_state_variable_6 == 1) {
#line 259
    vidioc_s_std___0(vbi_ioctl_ops_group3, ldvarg27, ldvarg26);
#line 261
    ldv_state_variable_6 = 1;
  } else {

  }
#line 264
  goto ldv_52310;
  case 7: ;
#line 267
  if (ldv_state_variable_6 == 1) {
#line 269
    vidioc_s_tuner___0(vbi_ioctl_ops_group3, ldvarg25, (struct v4l2_tuner  const  *)ldvarg24);
#line 271
    ldv_state_variable_6 = 1;
  } else {

  }
#line 274
  goto ldv_52310;
  case 8: ;
#line 277
  if (ldv_state_variable_6 == 1) {
#line 279
    saa7164_vbi_fmt(vbi_ioctl_ops_group3, ldvarg23, vbi_ioctl_ops_group2);
#line 281
    ldv_state_variable_6 = 1;
  } else {

  }
#line 284
  goto ldv_52310;
  case 9: ;
#line 287
  if (ldv_state_variable_6 == 1) {
#line 289
    vidioc_queryctrl___0(vbi_ioctl_ops_group3, ldvarg22, ldvarg21);
#line 291
    ldv_state_variable_6 = 1;
  } else {

  }
#line 294
  goto ldv_52310;
  case 10: ;
#line 297
  if (ldv_state_variable_6 == 1) {
#line 299
    vidioc_enum_fmt_vid_cap___0(vbi_ioctl_ops_group3, ldvarg20, ldvarg19);
#line 301
    ldv_state_variable_6 = 1;
  } else {

  }
#line 304
  goto ldv_52310;
  case 11: ;
#line 307
  if (ldv_state_variable_6 == 1) {
#line 309
    vidioc_try_ext_ctrls___0(vbi_ioctl_ops_group3, ldvarg18, vbi_ioctl_ops_group1);
#line 311
    ldv_state_variable_6 = 1;
  } else {

  }
#line 314
  goto ldv_52310;
  case 12: ;
#line 317
  if (ldv_state_variable_6 == 1) {
#line 319
    vidioc_s_fmt_vid_cap___0(vbi_ioctl_ops_group3, ldvarg17, vbi_ioctl_ops_group2);
#line 321
    ldv_state_variable_6 = 1;
  } else {

  }
#line 324
  goto ldv_52310;
  case 13: ;
#line 327
  if (ldv_state_variable_6 == 1) {
#line 329
    vidioc_g_fmt_vid_cap___0(vbi_ioctl_ops_group3, ldvarg16, vbi_ioctl_ops_group2);
#line 331
    ldv_state_variable_6 = 1;
  } else {

  }
#line 334
  goto ldv_52310;
  case 14: ;
#line 337
  if (ldv_state_variable_6 == 1) {
#line 339
    vidioc_g_frequency___0(vbi_ioctl_ops_group3, ldvarg15, ldvarg14);
#line 341
    ldv_state_variable_6 = 1;
  } else {

  }
#line 344
  goto ldv_52310;
  case 15: ;
#line 347
  if (ldv_state_variable_6 == 1) {
#line 349
    vidioc_g_input___0(vbi_ioctl_ops_group3, ldvarg13, ldvarg12);
#line 351
    ldv_state_variable_6 = 1;
  } else {

  }
#line 354
  goto ldv_52310;
  case 16: ;
#line 357
  if (ldv_state_variable_6 == 1) {
#line 359
    vidioc_querycap___0(vbi_ioctl_ops_group3, ldvarg11, ldvarg10);
#line 361
    ldv_state_variable_6 = 1;
  } else {

  }
#line 364
  goto ldv_52310;
  case 17: ;
#line 367
  if (ldv_state_variable_6 == 1) {
#line 369
    vidioc_s_frequency___0(vbi_ioctl_ops_group3, ldvarg9, (struct v4l2_frequency  const  *)ldvarg8);
#line 371
    ldv_state_variable_6 = 1;
  } else {

  }
#line 374
  goto ldv_52310;
  case 18: ;
#line 377
  if (ldv_state_variable_6 == 1) {
#line 379
    vidioc_g_std___0(vbi_ioctl_ops_group3, ldvarg7, ldvarg6);
#line 381
    ldv_state_variable_6 = 1;
  } else {

  }
#line 384
  goto ldv_52310;
  case 19: ;
#line 387
  if (ldv_state_variable_6 == 1) {
#line 389
    vidioc_enum_input___0(vbi_ioctl_ops_group3, ldvarg5, ldvarg4);
#line 391
    ldv_state_variable_6 = 1;
  } else {

  }
#line 394
  goto ldv_52310;
  case 20: ;
#line 397
  if (ldv_state_variable_6 == 1) {
#line 399
    vidioc_s_ext_ctrls___0(vbi_ioctl_ops_group3, ldvarg3, vbi_ioctl_ops_group1);
#line 401
    ldv_state_variable_6 = 1;
  } else {

  }
#line 404
  goto ldv_52310;
  case 21: ;
#line 407
  if (ldv_state_variable_6 == 1) {
#line 409
    vidioc_s_input___0(vbi_ioctl_ops_group3, ldvarg2, ldvarg1);
#line 411
    ldv_state_variable_6 = 1;
  } else {

  }
#line 414
  goto ldv_52310;
  case 22: ;
#line 417
  if (ldv_state_variable_6 == 1) {
#line 419
    saa7164_vbi_fmt(vbi_ioctl_ops_group3, ldvarg0, vbi_ioctl_ops_group2);
#line 421
    ldv_state_variable_6 = 1;
  } else {

  }
#line 424
  goto ldv_52310;
  default: 
#line 425
  ldv_stop();
  }
  ldv_52310: ;
#line 429
  return;
}
}
#line 431 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  struct poll_table_struct *ldvarg38 ;
  void *tmp ;
  size_t ldvarg40 ;
  unsigned long ldvarg36 ;
  char *ldvarg41 ;
  void *tmp___0 ;
  unsigned int ldvarg37 ;
  loff_t *ldvarg39 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 432
  tmp = ldv_init_zalloc(16UL);
#line 432
  ldvarg38 = (struct poll_table_struct *)tmp;
#line 435
  tmp___0 = ldv_init_zalloc(1UL);
#line 435
  ldvarg41 = (char *)tmp___0;
#line 437
  tmp___1 = ldv_init_zalloc(8UL);
#line 437
  ldvarg39 = (loff_t *)tmp___1;
#line 433
  ldv_memset((void *)(& ldvarg40), 0, 8UL);
#line 434
  ldv_memset((void *)(& ldvarg36), 0, 8UL);
#line 436
  ldv_memset((void *)(& ldvarg37), 0, 4UL);
#line 439
  tmp___2 = __VERIFIER_nondet_int();
#line 439
  switch (tmp___2) {
  case 0: ;
#line 442
  if (ldv_state_variable_7 == 1) {
#line 444
    ldv_retval_1 = fops_open___0(vbi_fops_group0);
#line 446
    if (ldv_retval_1 == 0) {
#line 447
      ldv_state_variable_7 = 2;
#line 448
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 452
  goto ldv_52344;
  case 1: ;
#line 455
  if (ldv_state_variable_7 == 2) {
#line 457
    fops_release___0(vbi_fops_group0);
#line 459
    ldv_state_variable_7 = 1;
#line 460
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 463
  goto ldv_52344;
  case 2: ;
#line 466
  if (ldv_state_variable_7 == 2) {
#line 468
    fops_read___0(vbi_fops_group0, ldvarg41, ldvarg40, ldvarg39);
#line 470
    ldv_state_variable_7 = 2;
  } else {

  }
#line 473
  goto ldv_52344;
  case 3: ;
#line 476
  if (ldv_state_variable_7 == 1) {
#line 478
    fops_poll___0(vbi_fops_group0, ldvarg38);
#line 480
    ldv_state_variable_7 = 1;
  } else {

  }
#line 483
  if (ldv_state_variable_7 == 2) {
#line 485
    fops_poll___0(vbi_fops_group0, ldvarg38);
#line 487
    ldv_state_variable_7 = 2;
  } else {

  }
#line 490
  goto ldv_52344;
  case 4: ;
#line 493
  if (ldv_state_variable_7 == 1) {
#line 495
    video_ioctl2(vbi_fops_group0, ldvarg37, ldvarg36);
#line 497
    ldv_state_variable_7 = 1;
  } else {

  }
#line 500
  if (ldv_state_variable_7 == 2) {
#line 502
    video_ioctl2(vbi_fops_group0, ldvarg37, ldvarg36);
#line 504
    ldv_state_variable_7 = 2;
  } else {

  }
#line 507
  goto ldv_52344;
  default: 
#line 508
  ldv_stop();
  }
  ldv_52344: ;
#line 512
  return;
}
}
#line 626 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
bool ldv_queue_work_on_485(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 630
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 630
  ldv_func_res = tmp;
#line 632
  activate_work_3(ldv_func_arg3, 2);
#line 634
  return (ldv_func_res);
}
}
#line 637 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
bool ldv_queue_delayed_work_on_486(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 641
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 641
  ldv_func_res = tmp;
#line 643
  activate_work_3(& ldv_func_arg3->work, 2);
#line 645
  return (ldv_func_res);
}
}
#line 648 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
bool ldv_queue_work_on_487(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 652
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 652
  ldv_func_res = tmp;
#line 654
  activate_work_3(ldv_func_arg3, 2);
#line 656
  return (ldv_func_res);
}
}
#line 659 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
void ldv_flush_workqueue_488(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 662
  flush_workqueue(ldv_func_arg1);
#line 664
  call_and_disable_all_3(2);
#line 665
  return;
}
}
#line 667 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
bool ldv_queue_delayed_work_on_489(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 671
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 671
  ldv_func_res = tmp;
#line 673
  activate_work_3(& ldv_func_arg3->work, 2);
#line 675
  return (ldv_func_res);
}
}
#line 713 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
void *ldv_kmem_cache_alloc_495(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 716
  ldv_check_alloc_flags(flags);
#line 717
  tmp = ldv_undef_ptr();
#line 717
  return (tmp);
}
}
#line 755 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
int ldv_pskb_expand_head_501(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 758
  ldv_check_alloc_flags(flags);
#line 759
  tmp = ldv_undef_ptr();
#line 759
  return ((int )((long )tmp));
}
}
#line 769 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
struct sk_buff *ldv_skb_clone_503(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 772
  ldv_check_alloc_flags(flags);
#line 773
  tmp = ldv_undef_ptr();
#line 773
  return ((struct sk_buff *)tmp);
}
}
#line 783 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
struct sk_buff *ldv_skb_copy_505(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 786
  ldv_check_alloc_flags(flags);
#line 787
  tmp = ldv_undef_ptr();
#line 787
  return ((struct sk_buff *)tmp);
}
}
#line 790 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_506(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 793
  ldv_check_alloc_flags(flags);
#line 794
  tmp = ldv_undef_ptr();
#line 794
  return ((struct sk_buff *)tmp);
}
}
#line 797 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_507(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 800
  ldv_check_alloc_flags(flags);
#line 801
  tmp = ldv_undef_ptr();
#line 801
  return ((struct sk_buff *)tmp);
}
}
#line 804 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_508(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 807
  ldv_check_alloc_flags(flags);
#line 808
  tmp = ldv_undef_ptr();
#line 808
  return ((struct sk_buff *)tmp);
}
}
#line 811 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
int ldv_pskb_expand_head_509(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 814
  ldv_check_alloc_flags(flags);
#line 815
  tmp = ldv_undef_ptr();
#line 815
  return ((int )((long )tmp));
}
}
#line 818 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
int ldv_pskb_expand_head_510(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 821
  ldv_check_alloc_flags(flags);
#line 822
  tmp = ldv_undef_ptr();
#line 822
  return ((int )((long )tmp));
}
}
#line 825 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/dscv/ri/43_2a/drivers/media/pci/saa7164/saa7164-vbi.o.c.prepared"
struct sk_buff *ldv_skb_clone_511(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 828
  ldv_check_alloc_flags(flags);
#line 829
  tmp = ldv_undef_ptr();
#line 829
  return ((struct sk_buff *)tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 20 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin != 0 && (flags & 16U) != 0U) {
#line 27
    ldv_error();
  } else {

  }
#line 31
  return;
}
}
#line 30
extern struct page *ldv_some_page(void) ;
#line 33 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page *tmp ;

  {
#line 36
  if (ldv_spin != 0 && (flags & 16U) != 0U) {
#line 36
    ldv_error();
  } else {

  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin != 0) {
#line 45
    ldv_error();
  } else {

  }
#line 49
  return;
}
}
#line 49 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/home/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--43_2a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6706/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock != 0) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
