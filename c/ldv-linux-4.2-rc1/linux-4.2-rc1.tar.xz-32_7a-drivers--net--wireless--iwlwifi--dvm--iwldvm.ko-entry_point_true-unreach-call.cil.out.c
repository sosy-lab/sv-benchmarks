extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 36 "include/uapi/linux/types.h"
typedef __u64 __le64;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 428 "./arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 197 "./arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 687 "include/linux/list.h"
struct lockdep_map;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 328 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "./arch/x86/include/asm/paravirt.h"
struct static_key;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timespec;
#line 104
struct compat_timespec;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 105
struct pollfd;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 59 "include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
};
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 106 "include/linux/debugobjects.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 246 "include/linux/timer.h"
struct hrtimer;
#line 247
enum hrtimer_restart;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1170 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1120 "include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_47 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_46 {
   struct __anonstruct____missing_field_name_47 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_46 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 616
struct vm_area_struct;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 796 "include/linux/mmzone.h"
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 60 "include/linux/kmemleak.h"
struct kmem_cache;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct inode;
#line 34
struct dentry;
#line 35
struct user_namespace;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369 "include/linux/cred.h"
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 369 "include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 31
struct kernfs_node;
#line 32
struct kernfs_ops;
#line 33
struct kernfs_open_file;
#line 75 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270
struct kernfs_root;
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct ieee80211_sta;
#line 117
struct iwl_priv;
#line 141
struct iwl_op_mode;
#line 324
struct ieee80211_hw;
#line 348
struct ieee80211_supported_band;
#line 135 "./arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
struct iattr;
#line 54
struct super_block;
#line 55
struct file_system_type;
#line 56
struct kernfs_open_node;
#line 57
struct kernfs_iattrs;
#line 80 "include/linux/elf.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_209 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_209 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_210 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_210 __annonCompField57 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 158 "include/linux/kmemcheck.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_217 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38
struct kiocb;
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 217 "./include/uapi/asm-generic/fcntl.h"
enum ldv_17888 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_17888 socket_state;
#line 54
struct poll_table_struct;
#line 55
struct net;
#line 72
struct fasync_struct;
#line 72 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 176
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1284 "include/linux/device.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 380 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_218 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_218 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_223 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_224 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_223 __annonCompField62 ;
   union __anonunion____missing_field_name_224 __annonCompField63 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_227 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_226 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_227 __annonCompField64 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_226 __annonCompField65 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_230 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_229 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_230 __annonCompField66 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_228 {
   struct __anonstruct____missing_field_name_229 __annonCompField67 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_232 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_231 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_232 __annonCompField69 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_233 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_234 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_235 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_228 __annonCompField68 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_231 __annonCompField70 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_233 __annonCompField71 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_234 __annonCompField72 ;
   union __anonunion____missing_field_name_235 __annonCompField73 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_237 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_237 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_238 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_238 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_239 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_239 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_240 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_240 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_241 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_241 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_242 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_242 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_243 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_243 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_244 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_244 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_245 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_246 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_245 ifr_ifrn ;
   union __anonunion_ifr_ifru_246 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_251 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_250 {
   struct __anonstruct____missing_field_name_251 __annonCompField74 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_250 __annonCompField75 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_253 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_252 {
   struct __anonstruct____missing_field_name_253 __annonCompField76 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_252 __annonCompField77 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_254 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_254 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_258 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_257 {
   struct __anonstruct____missing_field_name_258 __annonCompField78 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_257 __annonCompField79 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 62
struct kstatfs;
#line 63
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_262 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_262 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_263 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_263 __annonCompField81 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_266 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_267 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_268 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_266 __annonCompField82 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_267 __annonCompField83 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_268 __annonCompField84 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_269 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_269 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_271 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_270 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_271 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_270 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118
struct proc_dir_entry;
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_302 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_302 possible_net_t;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 657 "include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 338 "include/linux/mii.h"
enum ldv_27999 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_27999 phy_interface_t;
#line 126
enum ldv_28053 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_28053 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_315 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_317 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_315 adj_list ;
   struct __anonstruct_all_adj_list_316 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_317 __annonCompField94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 143 "include/linux/ieee80211.h"
struct ieee80211_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   u8 addr4[6U] ;
};
#line 677 "include/linux/ieee80211.h"
struct ieee80211_msrment_ie {
   u8 token ;
   u8 mode ;
   u8 type ;
   u8 request[0U] ;
};
#line 700 "include/linux/ieee80211.h"
struct ieee80211_ext_chansw_ie {
   u8 mode ;
   u8 new_operating_class ;
   u8 new_ch_num ;
   u8 count ;
};
#line 831 "include/linux/ieee80211.h"
struct ieee80211_tpc_report_ie {
   u8 tx_power ;
   u8 link_margin ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_auth_327 {
   __le16 auth_alg ;
   __le16 auth_transaction ;
   __le16 status_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_deauth_328 {
   __le16 reason_code ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_assoc_req_329 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_assoc_resp_330 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_reassoc_resp_331 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_reassoc_req_332 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 current_ap[6U] ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_disassoc_333 {
   __le16 reason_code ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_beacon_334 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_probe_req_335 {
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_probe_resp_336 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_wme_action_339 {
   u8 action_code ;
   u8 dialog_token ;
   u8 status_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_chan_switch_340 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_ext_chan_switch_341 {
   u8 action_code ;
   struct ieee80211_ext_chansw_ie data ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_measurement_342 {
   u8 action_code ;
   u8 dialog_token ;
   u8 element_id ;
   u8 length ;
   struct ieee80211_msrment_ie msr_elem ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_addba_req_343 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capab ;
   __le16 timeout ;
   __le16 start_seq_num ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_addba_resp_344 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 status ;
   __le16 capab ;
   __le16 timeout ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_delba_345 {
   u8 action_code ;
   __le16 params ;
   __le16 reason_code ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_self_prot_346 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_mesh_action_347 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_sa_query_348 {
   u8 action ;
   u8 trans_id[2U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_ht_smps_349 {
   u8 action ;
   u8 smps_control ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_ht_notify_cw_350 {
   u8 action_code ;
   u8 chanwidth ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_tdls_discover_resp_351 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capability ;
   u8 variable[0U] ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_vht_opmode_notif_352 {
   u8 action_code ;
   u8 operating_mode ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_tpc_report_353 {
   u8 action_code ;
   u8 dialog_token ;
   u8 tpc_elem_id ;
   u8 tpc_elem_length ;
   struct ieee80211_tpc_report_ie tpc ;
};
#line 856 "include/linux/ieee80211.h"
union __anonunion_u_338 {
   struct __anonstruct_wme_action_339 wme_action ;
   struct __anonstruct_chan_switch_340 chan_switch ;
   struct __anonstruct_ext_chan_switch_341 ext_chan_switch ;
   struct __anonstruct_measurement_342 measurement ;
   struct __anonstruct_addba_req_343 addba_req ;
   struct __anonstruct_addba_resp_344 addba_resp ;
   struct __anonstruct_delba_345 delba ;
   struct __anonstruct_self_prot_346 self_prot ;
   struct __anonstruct_mesh_action_347 mesh_action ;
   struct __anonstruct_sa_query_348 sa_query ;
   struct __anonstruct_ht_smps_349 ht_smps ;
   struct __anonstruct_ht_notify_cw_350 ht_notify_cw ;
   struct __anonstruct_tdls_discover_resp_351 tdls_discover_resp ;
   struct __anonstruct_vht_opmode_notif_352 vht_opmode_notif ;
   struct __anonstruct_tpc_report_353 tpc_report ;
};
#line 856 "include/linux/ieee80211.h"
struct __anonstruct_action_337 {
   u8 category ;
   union __anonunion_u_338 u ;
};
#line 856 "include/linux/ieee80211.h"
union __anonunion_u_326 {
   struct __anonstruct_auth_327 auth ;
   struct __anonstruct_deauth_328 deauth ;
   struct __anonstruct_assoc_req_329 assoc_req ;
   struct __anonstruct_assoc_resp_330 assoc_resp ;
   struct __anonstruct_reassoc_resp_331 reassoc_resp ;
   struct __anonstruct_reassoc_req_332 reassoc_req ;
   struct __anonstruct_disassoc_333 disassoc ;
   struct __anonstruct_beacon_334 beacon ;
   struct __anonstruct_probe_req_335 probe_req ;
   struct __anonstruct_probe_resp_336 probe_resp ;
   struct __anonstruct_action_337 action ;
};
#line 856 "include/linux/ieee80211.h"
struct ieee80211_mgmt {
   __le16 frame_control ;
   __le16 duration ;
   u8 da[6U] ;
   u8 sa[6U] ;
   u8 bssid[6U] ;
   __le16 seq_ctrl ;
   union __anonunion_u_326 u ;
};
#line 1161 "include/linux/ieee80211.h"
struct ieee80211_p2p_noa_desc {
   u8 count ;
   __le32 duration ;
   __le32 interval ;
   __le32 start_time ;
};
#line 1180 "include/linux/ieee80211.h"
struct ieee80211_p2p_noa_attr {
   u8 index ;
   u8 oppps_ctwindow ;
   struct ieee80211_p2p_noa_desc desc[4U] ;
};
#line 1204 "include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};
#line 1229 "include/linux/ieee80211.h"
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};
#line 1354 "include/linux/ieee80211.h"
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};
#line 1435 "include/linux/ieee80211.h"
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};
#line 470 "include/linux/debugfs.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NUM_NL80211_IFTYPES = 12,
    NL80211_IFTYPE_MAX = 11
} ;
#line 2431 "./include/uapi/linux/nl80211.h"
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
} ;
#line 2484
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
} ;
#line 2491
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
} ;
#line 2607
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
} ;
#line 2618
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
} ;
#line 2650
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
} ;
#line 2668
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
} ;
#line 3596
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
} ;
#line 3734 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};
#line 3871 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};
#line 3883 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};
#line 4131
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
} ;
#line 4153 "./include/uapi/linux/nl80211.h"
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};
#line 4581
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
} ;
#line 4587 "./include/uapi/linux/nl80211.h"
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
#line 99 "include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
#line 185 "include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
#line 190 "include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};
#line 197 "include/net/regulatory.h"
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};
#line 205
struct wiphy;
#line 206
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
} ;
#line 228 "include/net/regulatory.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};
#line 207 "include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
#line 269 "include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
#line 289 "include/net/cfg80211.h"
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};
#line 305 "include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};
#line 387 "include/net/cfg80211.h"
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};
#line 608 "include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};
#line 671 "include/net/cfg80211.h"
struct mac_address {
   u8 addr[6U] ;
};
#line 1395 "include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};
#line 1428 "include/net/cfg80211.h"
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};
#line 1491 "include/net/cfg80211.h"
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};
#line 1499 "include/net/cfg80211.h"
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   u32 delay ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   struct ieee80211_channel *channels[0U] ;
};
#line 1561
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
} ;
#line 1766 "include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 const   *ssid ;
   u8 const   *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const   *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};
#line 1814 "include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const   *bssid ;
   u8 const   *bssid_hint ;
   u8 const   *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const   *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
#line 1916 "include/net/cfg80211.h"
struct cfg80211_pkt_pattern {
   u8 const   *mask ;
   u8 const   *pattern ;
   int pattern_len ;
   int pkt_offset ;
};
#line 1933 "include/net/cfg80211.h"
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const   *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const   *wake_data ;
   u8 const   *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};
#line 1968 "include/net/cfg80211.h"
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
   struct cfg80211_sched_scan_request *nd_config ;
};
#line 2736 "include/net/cfg80211.h"
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};
#line 2797 "include/net/cfg80211.h"
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit  const  *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};
#line 2869 "include/net/cfg80211.h"
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};
#line 2885 "include/net/cfg80211.h"
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature  const  *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};
#line 2910 "include/net/cfg80211.h"
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   int max_nd_match_sets ;
   struct wiphy_wowlan_tcp_support  const  *tcp ;
};
#line 2935 "include/net/cfg80211.h"
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};
#line 2960 "include/net/cfg80211.h"
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy * , struct wireless_dev * , void const   * , int  ) ;
};
#line 2981 "include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes  const  *mgmt_stypes ;
   struct ieee80211_iface_combination  const  *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[1U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const   *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support  const  *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const   *extended_capabilities ;
   u8 const   *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const   *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy * , struct regulatory_request * ) ;
   struct ieee80211_regdomain  const  *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap  const  *ht_capa_mod_mask ;
   struct ieee80211_vht_cap  const  *vht_capa_mod_mask ;
   possible_net_t _net ;
   struct iw_handler_def  const  *wext ;
   struct wiphy_coalesce_support  const  *coalesce ;
   struct wiphy_vendor_command  const  *vendor_commands ;
   struct nl80211_vendor_cmd_info  const  *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};
#line 3369
struct cfg80211_conn;
#line 3370
struct cfg80211_internal_bss;
#line 3371
struct cfg80211_cached_keys;
#line 3372 "include/net/cfg80211.h"
struct __anonstruct_wext_366 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const   *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};
#line 3372 "include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_366 wext ;
};
#line 187 "include/net/mac80211.h"
struct ieee80211_chanctx_conf {
   struct cfg80211_chan_def def ;
   struct cfg80211_chan_def min_def ;
   u8 rx_chains_static ;
   u8 rx_chains_dynamic ;
   bool radar_enabled ;
   u8 drv_priv[0U] ;
};
#line 229
struct ieee80211_vif;
#line 436 "include/net/mac80211.h"
struct ieee80211_bss_conf {
   u8 const   *bssid ;
   bool assoc ;
   bool ibss_joined ;
   bool ibss_creator ;
   u16 aid ;
   bool use_cts_prot ;
   bool use_short_preamble ;
   bool use_short_slot ;
   bool enable_beacon ;
   u8 dtim_period ;
   u16 beacon_int ;
   u16 assoc_capability ;
   u64 sync_tsf ;
   u32 sync_device_ts ;
   u8 sync_dtim_count ;
   u32 basic_rates ;
   struct ieee80211_rate *beacon_rate ;
   int mcast_rate[3U] ;
   u16 ht_operation_mode ;
   s32 cqm_rssi_thold ;
   u32 cqm_rssi_hyst ;
   struct cfg80211_chan_def chandef ;
   __be32 arp_addr_list[4U] ;
   int arp_addr_cnt ;
   bool qos ;
   bool idle ;
   bool ps ;
   u8 ssid[32U] ;
   size_t ssid_len ;
   bool hidden_ssid ;
   int txpower ;
   enum nl80211_tx_power_setting txpower_type ;
   struct ieee80211_p2p_noa_attr p2p_noa_attr ;
};
#line 598 "include/net/mac80211.h"
struct ieee80211_tx_rate {
   s8 idx ;
   unsigned char count : 5 ;
   unsigned short flags : 11 ;
};
#line 819 "include/net/mac80211.h"
struct __anonstruct____missing_field_name_371 {
   struct ieee80211_tx_rate rates[4U] ;
   s8 rts_cts_rate_idx ;
   unsigned char use_rts : 1 ;
   unsigned char use_cts_prot : 1 ;
   unsigned char short_preamble : 1 ;
   unsigned char skip_table : 1 ;
};
#line 819 "include/net/mac80211.h"
union __anonunion____missing_field_name_370 {
   struct __anonstruct____missing_field_name_371 __annonCompField96 ;
   unsigned long jiffies ;
};
#line 819
struct ieee80211_key_conf;
#line 819 "include/net/mac80211.h"
struct __anonstruct_control_369 {
   union __anonunion____missing_field_name_370 __annonCompField97 ;
   struct ieee80211_vif *vif ;
   struct ieee80211_key_conf *hw_key ;
   u32 flags ;
};
#line 819 "include/net/mac80211.h"
struct __anonstruct_ack_372 {
   u64 cookie ;
};
#line 819 "include/net/mac80211.h"
struct __anonstruct_status_373 {
   struct ieee80211_tx_rate rates[4U] ;
   s32 ack_signal ;
   u8 ampdu_ack_len ;
   u8 ampdu_len ;
   u8 antenna ;
   u16 tx_time ;
   void *status_driver_data[2U] ;
};
#line 819 "include/net/mac80211.h"
struct __anonstruct____missing_field_name_374 {
   struct ieee80211_tx_rate driver_rates[4U] ;
   u8 pad[4U] ;
   void *rate_driver_data[3U] ;
};
#line 819 "include/net/mac80211.h"
union __anonunion____missing_field_name_368 {
   struct __anonstruct_control_369 control ;
   struct __anonstruct_ack_372 ack ;
   struct __anonstruct_status_373 status ;
   struct __anonstruct____missing_field_name_374 __annonCompField98 ;
   void *driver_data[5U] ;
};
#line 819 "include/net/mac80211.h"
struct ieee80211_tx_info {
   u32 flags ;
   u8 band ;
   u8 hw_queue ;
   u16 ack_frame_id ;
   union __anonunion____missing_field_name_368 __annonCompField99 ;
};
#line 1174
enum ieee80211_smps_mode {
    IEEE80211_SMPS_AUTOMATIC = 0,
    IEEE80211_SMPS_OFF = 1,
    IEEE80211_SMPS_STATIC = 2,
    IEEE80211_SMPS_DYNAMIC = 3,
    IEEE80211_SMPS_NUM_MODES = 4
} ;
#line 1182 "include/net/mac80211.h"
struct ieee80211_conf {
   u32 flags ;
   int power_level ;
   int dynamic_ps_timeout ;
   int max_sleep_period ;
   u16 listen_interval ;
   u8 ps_dtim_period ;
   u8 long_frame_max_tx_count ;
   u8 short_frame_max_tx_count ;
   struct cfg80211_chan_def chandef ;
   bool radar_enabled ;
   enum ieee80211_smps_mode smps_mode ;
};
#line 1285 "include/net/mac80211.h"
struct ieee80211_channel_switch {
   u64 timestamp ;
   u32 device_timestamp ;
   bool block_tx ;
   struct cfg80211_chan_def chandef ;
   u8 count ;
};
#line 1316
struct ieee80211_txq;
#line 1316 "include/net/mac80211.h"
struct ieee80211_vif {
   enum nl80211_iftype type ;
   struct ieee80211_bss_conf bss_conf ;
   u8 addr[6U] ;
   bool p2p ;
   bool csa_active ;
   u8 cab_queue ;
   u8 hw_queue[4U] ;
   struct ieee80211_txq *txq ;
   struct ieee80211_chanctx_conf *chanctx_conf ;
   u32 driver_flags ;
   struct dentry *debugfs_dir ;
   u8 drv_priv[0U] ;
};
#line 1432 "include/net/mac80211.h"
struct ieee80211_key_conf {
   atomic64_t tx_pn ;
   u32 cipher ;
   u8 icv_len ;
   u8 iv_len ;
   u8 hw_key_idx ;
   u8 flags ;
   s8 keyidx ;
   u8 keylen ;
   u8 key[0U] ;
};
#line 1547 "include/net/mac80211.h"
struct ieee80211_cipher_scheme {
   u32 cipher ;
   u16 iftype ;
   u8 hdr_len ;
   u8 pn_len ;
   u8 pn_off ;
   u8 key_idx_off ;
   u8 key_idx_mask ;
   u8 key_idx_shift ;
   u8 mic_len ;
};
#line 1590
enum ieee80211_sta_rx_bandwidth {
    IEEE80211_STA_RX_BW_20 = 0,
    IEEE80211_STA_RX_BW_40 = 1,
    IEEE80211_STA_RX_BW_80 = 2,
    IEEE80211_STA_RX_BW_160 = 3
} ;
#line 1597 "include/net/mac80211.h"
struct __anonstruct_rate_382 {
   s8 idx ;
   u8 count ;
   u8 count_cts ;
   u8 count_rts ;
   u16 flags ;
};
#line 1597 "include/net/mac80211.h"
struct ieee80211_sta_rates {
   struct callback_head callback_head ;
   struct __anonstruct_rate_382 rate[4U] ;
};
#line 1645 "include/net/mac80211.h"
struct ieee80211_sta {
   u32 supp_rates[3U] ;
   u8 addr[6U] ;
   u16 aid ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
   bool wme ;
   u8 uapsd_queues ;
   u8 max_sp ;
   u8 rx_nss ;
   enum ieee80211_sta_rx_bandwidth bandwidth ;
   enum ieee80211_smps_mode smps_mode ;
   struct ieee80211_sta_rates *rates ;
   bool tdls ;
   bool tdls_initiator ;
   bool mfp ;
   struct ieee80211_txq *txq[16U] ;
   u8 drv_priv[0U] ;
};
#line 1726 "include/net/mac80211.h"
struct ieee80211_txq {
   struct ieee80211_vif *vif ;
   struct ieee80211_sta *sta ;
   u8 tid ;
   u8 ac ;
   u8 drv_priv[0U] ;
};
#line 1781 "include/net/mac80211.h"
struct ieee80211_hw {
   struct ieee80211_conf conf ;
   struct wiphy *wiphy ;
   char const   *rate_control_algorithm ;
   void *priv ;
   unsigned long flags[1U] ;
   unsigned int extra_tx_headroom ;
   unsigned int extra_beacon_tailroom ;
   int vif_data_size ;
   int sta_data_size ;
   int chanctx_data_size ;
   int txq_data_size ;
   u16 queues ;
   u16 max_listen_interval ;
   s8 max_signal ;
   u8 max_rates ;
   u8 max_report_rates ;
   u8 max_rate_tries ;
   u8 max_rx_aggregation_subframes ;
   u8 max_tx_aggregation_subframes ;
   u8 offchannel_tx_hw_queue ;
   u8 radiotap_mcs_details ;
   u16 radiotap_vht_details ;
   netdev_features_t netdev_features ;
   u8 uapsd_queues ;
   u8 uapsd_max_sp_len ;
   u8 n_cipher_schemes ;
   struct ieee80211_cipher_scheme  const  *cipher_schemes ;
   int txq_ac_max_pending ;
};
#line 71 "drivers/net/wireless/iwlwifi/dvm/../iwl-modparams.h"
struct iwl_mod_params;
#line 88 "drivers/net/wireless/iwlwifi/dvm/../iwl-modparams.h"
struct iwl_mod_params {
   int sw_crypto ;
   unsigned int disable_11n ;
   int amsdu_size_8K ;
   bool restart_fw ;
   bool bt_coex_active ;
   int led_mode ;
   bool power_save ;
   int power_level ;
   u32 debug_level ;
   int ant_coupling ;
   char *nvm_file ;
   bool uapsd_disable ;
   bool d0i3_disable ;
   bool lar_disable ;
   bool fw_monitor ;
};
#line 79 "drivers/net/wireless/iwlwifi/dvm/../iwl-debug.h"
enum iwl_device_family {
    IWL_DEVICE_FAMILY_UNDEFINED = 0,
    IWL_DEVICE_FAMILY_1000 = 1,
    IWL_DEVICE_FAMILY_100 = 2,
    IWL_DEVICE_FAMILY_2000 = 3,
    IWL_DEVICE_FAMILY_2030 = 4,
    IWL_DEVICE_FAMILY_105 = 5,
    IWL_DEVICE_FAMILY_135 = 6,
    IWL_DEVICE_FAMILY_5000 = 7,
    IWL_DEVICE_FAMILY_5150 = 8,
    IWL_DEVICE_FAMILY_6000 = 9,
    IWL_DEVICE_FAMILY_6000i = 10,
    IWL_DEVICE_FAMILY_6005 = 11,
    IWL_DEVICE_FAMILY_6030 = 12,
    IWL_DEVICE_FAMILY_6050 = 13,
    IWL_DEVICE_FAMILY_6150 = 14,
    IWL_DEVICE_FAMILY_7000 = 15,
    IWL_DEVICE_FAMILY_8000 = 16
} ;
#line 99 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
enum iwl_led_mode {
    IWL_LED_DEFAULT = 0,
    IWL_LED_RF_STATE = 1,
    IWL_LED_BLINK = 2,
    IWL_LED_DISABLE = 3
} ;
#line 151 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
struct iwl_base_params {
   int eeprom_size ;
   int num_of_queues ;
   u32 pll_cfg_val ;
   u16 const   max_ll_items ;
   bool const   shadow_ram_support ;
   u16 led_compensation ;
   unsigned int wd_timeout ;
   u32 max_event_log_size ;
   bool const   shadow_reg_enable ;
   bool const   pcie_l1_allowed ;
   bool const   apmg_wake_up_wa ;
   bool const   scd_chain_ext_wa ;
};
#line 181 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
struct iwl_ht_params {
   enum ieee80211_smps_mode smps_mode ;
   bool const   ht_greenfield_support ;
   bool const   stbc ;
   bool const   ldpc ;
   bool use_rts_for_aggregation ;
   u8 ht40_bands ;
};
#line 196 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
struct iwl_tt_tx_backoff {
   s32 temperature ;
   u32 backoff ;
};
#line 206 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
struct iwl_tt_params {
   s32 ct_kill_entry ;
   s32 ct_kill_exit ;
   u32 ct_kill_duration ;
   s32 dynamic_smps_entry ;
   s32 dynamic_smps_exit ;
   s32 tx_protection_entry ;
   s32 tx_protection_exit ;
   struct iwl_tt_tx_backoff tx_backoff[6U] ;
   bool support_ct_kill ;
   bool support_dynamic_smps ;
   bool support_tx_protection ;
   bool support_tx_backoff ;
};
#line 239 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
struct iwl_eeprom_params {
   u8 const   regulatory_bands[7U] ;
   bool enhanced_txpower ;
};
#line 262 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
struct iwl_pwr_tx_backoff {
   u32 pwr ;
   u32 backoff ;
};
#line 271 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
struct iwl_cfg {
   char const   *name ;
   char const   *fw_name_pre ;
   unsigned int const   ucode_api_max ;
   unsigned int const   ucode_api_ok ;
   unsigned int const   ucode_api_min ;
   enum iwl_device_family  const  device_family ;
   u32 const   max_data_size ;
   u32 const   max_inst_size ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   u8 non_shared_ant ;
   bool bt_shared_single_ant ;
   u16 nvm_ver ;
   u16 nvm_calib_ver ;
   struct iwl_base_params  const  *base_params ;
   struct iwl_ht_params  const  *ht_params ;
   struct iwl_eeprom_params  const  *eeprom_params ;
   enum iwl_led_mode led_mode ;
   bool const   rx_with_siso_diversity ;
   bool const   internal_wimax_coex ;
   bool const   host_interrupt_operation_mode ;
   bool high_temp ;
   bool d0i3 ;
   u8 nvm_hw_section_num ;
   bool lp_xtal_workaround ;
   struct iwl_pwr_tx_backoff  const  *pwr_tx_backoffs ;
   bool no_power_up_nic_in_init ;
   char const   *default_nvm_file_B_step ;
   char const   *default_nvm_file_C_step ;
   unsigned int max_rx_agg_size ;
   bool disable_dummy_notification ;
   unsigned int max_tx_agg_size ;
   unsigned int max_ht_ampdu_exponent ;
   unsigned int max_vht_ampdu_exponent ;
   u32 const   dccm_offset ;
   u32 const   dccm_len ;
   u32 const   dccm2_offset ;
   u32 const   dccm2_len ;
   u32 const   smem_offset ;
   u32 const   smem_len ;
   struct iwl_tt_params  const  *thermal_params ;
   bool apmg_not_supported ;
};
#line 300 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw-file.h"
struct iwl_tlv_calib_ctrl {
   __le32 flow_trigger ;
   __le32 event_trigger ;
};
#line 415 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw-file.h"
struct iwl_fw_dbg_reg_op {
   u8 op ;
   u8 reserved[3U] ;
   __le32 addr ;
   __le32 val ;
};
#line 437 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw-file.h"
struct iwl_fw_dbg_dest_tlv {
   u8 version ;
   u8 monitor_mode ;
   u8 size_power ;
   u8 reserved ;
   __le32 base_reg ;
   __le32 end_reg ;
   __le32 write_ptr_reg ;
   __le32 wrap_count ;
   u8 base_shift ;
   u8 end_shift ;
   struct iwl_fw_dbg_reg_op reg_ops[0U] ;
};
#line 475 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw-file.h"
struct iwl_fw_dbg_conf_hcmd {
   u8 id ;
   u8 reserved ;
   __le16 len ;
   u8 data[0U] ;
};
#line 497 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw-file.h"
struct iwl_fw_dbg_trigger_tlv {
   __le32 id ;
   __le32 vif_type ;
   __le32 stop_conf_ids ;
   __le32 stop_delay ;
   u8 mode ;
   u8 start_conf_id ;
   __le16 occurrences ;
   __le32 reserved[2U] ;
   u8 data[0U] ;
};
#line 701 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw-file.h"
struct iwl_fw_dbg_conf_tlv {
   u8 id ;
   u8 usniffer ;
   u8 reserved ;
   u8 num_of_hcmds ;
   struct iwl_fw_dbg_conf_hcmd hcmd ;
};
#line 286 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw-error-dump.h"
enum iwl_ucode_type {
    IWL_UCODE_REGULAR = 0,
    IWL_UCODE_INIT = 1,
    IWL_UCODE_WOWLAN = 2,
    IWL_UCODE_REGULAR_USNIFFER = 3,
    IWL_UCODE_TYPE_MAX = 4
} ;
#line 299 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw-error-dump.h"
struct iwl_ucode_capabilities {
   u32 max_probe_length ;
   u32 n_scan_channels ;
   u32 standard_phy_calibration_size ;
   u32 flags ;
   unsigned long _api[1U] ;
   unsigned long _capa[1U] ;
};
#line 125 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw.h"
struct fw_desc {
   void const   *data ;
   u32 len ;
   u32 offset ;
};
#line 132 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw.h"
struct fw_img {
   struct fw_desc sec[12U] ;
   bool is_dual_cpus ;
};
#line 137 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw.h"
struct iwl_sf_region {
   u32 addr ;
   u32 size ;
};
#line 152 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw.h"
struct iwl_fw {
   u32 ucode_ver ;
   char fw_version[32U] ;
   struct fw_img img[4U] ;
   struct iwl_ucode_capabilities ucode_capa ;
   bool enhance_sensitivity_table ;
   u32 init_evtlog_ptr ;
   u32 init_evtlog_size ;
   u32 init_errlog_ptr ;
   u32 inst_evtlog_ptr ;
   u32 inst_evtlog_size ;
   u32 inst_errlog_ptr ;
   struct iwl_tlv_calib_ctrl default_calib[4U] ;
   u32 phy_config ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   bool mvm_fw ;
   struct ieee80211_cipher_scheme cs[1U] ;
   u8 human_readable[64U] ;
   u32 sdio_adma_addr ;
   struct iwl_fw_dbg_dest_tlv *dbg_dest_tlv ;
   struct iwl_fw_dbg_conf_tlv *dbg_conf_tlv[32U] ;
   size_t dbg_conf_tlv_len[32U] ;
   struct iwl_fw_dbg_trigger_tlv *dbg_trigger_tlv[12U] ;
   size_t dbg_trigger_tlv_len[12U] ;
   u8 dbg_dest_reg_num ;
};
#line 253
struct iwl_trans;
#line 254
struct iwl_device_cmd;
#line 255
struct iwl_rx_cmd_buffer;
#line 256 "drivers/net/wireless/iwlwifi/dvm/../iwl-fw.h"
struct iwl_op_mode_ops {
   struct iwl_op_mode *(*start)(struct iwl_trans * , struct iwl_cfg  const  * , struct iwl_fw  const  * ,
                                struct dentry * ) ;
   void (*stop)(struct iwl_op_mode * ) ;
   int (*rx)(struct iwl_op_mode * , struct iwl_rx_cmd_buffer * , struct iwl_device_cmd * ) ;
   void (*napi_add)(struct iwl_op_mode * , struct napi_struct * , struct net_device * ,
                    int (*)(struct napi_struct * , int  ) , int  ) ;
   void (*queue_full)(struct iwl_op_mode * , int  ) ;
   void (*queue_not_full)(struct iwl_op_mode * , int  ) ;
   bool (*hw_rf_kill)(struct iwl_op_mode * , bool  ) ;
   void (*free_skb)(struct iwl_op_mode * , struct sk_buff * ) ;
   void (*nic_error)(struct iwl_op_mode * ) ;
   void (*cmd_queue_full)(struct iwl_op_mode * ) ;
   void (*nic_config)(struct iwl_op_mode * ) ;
   void (*wimax_active)(struct iwl_op_mode * ) ;
   int (*enter_d0i3)(struct iwl_op_mode * ) ;
   int (*exit_d0i3)(struct iwl_op_mode * ) ;
};
#line 172 "drivers/net/wireless/iwlwifi/dvm/../iwl-op-mode.h"
struct iwl_op_mode {
   struct iwl_op_mode_ops  const  *ops ;
   char op_mode_specific[0U] ;
};
#line 273 "drivers/net/wireless/iwlwifi/dvm/../iwl-op-mode.h"
struct iwl_cmd_header {
   u8 cmd ;
   u8 flags ;
   __le16 sequence ;
};
#line 156 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_rx_packet {
   __le32 len_n_flags ;
   struct iwl_cmd_header hdr ;
   u8 data[] ;
};
#line 200 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_device_cmd {
   struct iwl_cmd_header hdr ;
   u8 payload[320U] ;
};
#line 233 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_host_cmd {
   void const   *data[2U] ;
   struct iwl_rx_packet *resp_pkt ;
   unsigned long _rx_page_addr ;
   u32 _rx_page_order ;
   int handler_status ;
   u32 flags ;
   u16 len[2U] ;
   u8 dataflags[2U] ;
   u8 id ;
};
#line 288 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_rx_cmd_buffer {
   struct page *_page ;
   int _offset ;
   bool _page_stolen ;
   u32 _rx_page_order ;
   unsigned int truesize ;
};
#line 318
enum iwl_d3_status {
    IWL_D3_STATUS_ALIVE = 0,
    IWL_D3_STATUS_RESET = 1
} ;
#line 334 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_trans_config {
   struct iwl_op_mode *op_mode ;
   u8 cmd_queue ;
   u8 cmd_fifo ;
   unsigned int cmd_q_wdg_timeout ;
   u8 const   *no_reclaim_cmds ;
   unsigned int n_no_reclaim_cmds ;
   bool rx_buf_size_8k ;
   bool bc_table_dword ;
   bool scd_set_active ;
   char const   * const  *command_names ;
   u32 sdio_adma_addr ;
};
#line 403 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_trans_dump_data {
   u32 len ;
   u8 data[] ;
};
#line 408 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_trans_txq_scd_cfg {
   u8 fifo ;
   s8 sta_id ;
   u8 tid ;
   bool aggregate ;
   int frame_limit ;
};
#line 418 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_trans_ops {
   int (*start_hw)(struct iwl_trans * , bool  ) ;
   void (*op_mode_leave)(struct iwl_trans * ) ;
   int (*start_fw)(struct iwl_trans * , struct fw_img  const  * , bool  ) ;
   int (*update_sf)(struct iwl_trans * , struct iwl_sf_region * ) ;
   void (*fw_alive)(struct iwl_trans * , u32  ) ;
   void (*stop_device)(struct iwl_trans * , bool  ) ;
   void (*d3_suspend)(struct iwl_trans * , bool  ) ;
   int (*d3_resume)(struct iwl_trans * , enum iwl_d3_status * , bool  ) ;
   int (*send_cmd)(struct iwl_trans * , struct iwl_host_cmd * ) ;
   int (*tx)(struct iwl_trans * , struct sk_buff * , struct iwl_device_cmd * , int  ) ;
   void (*reclaim)(struct iwl_trans * , int  , int  , struct sk_buff_head * ) ;
   void (*txq_enable)(struct iwl_trans * , int  , u16  , struct iwl_trans_txq_scd_cfg  const  * ,
                      unsigned int  ) ;
   void (*txq_disable)(struct iwl_trans * , int  , bool  ) ;
   int (*dbgfs_register)(struct iwl_trans * , struct dentry * ) ;
   int (*wait_tx_queue_empty)(struct iwl_trans * , u32  ) ;
   void (*freeze_txq_timer)(struct iwl_trans * , unsigned long  , bool  ) ;
   void (*write8)(struct iwl_trans * , u32  , u8  ) ;
   void (*write32)(struct iwl_trans * , u32  , u32  ) ;
   u32 (*read32)(struct iwl_trans * , u32  ) ;
   u32 (*read_prph)(struct iwl_trans * , u32  ) ;
   void (*write_prph)(struct iwl_trans * , u32  , u32  ) ;
   int (*read_mem)(struct iwl_trans * , u32  , void * , int  ) ;
   int (*write_mem)(struct iwl_trans * , u32  , void const   * , int  ) ;
   void (*configure)(struct iwl_trans * , struct iwl_trans_config  const  * ) ;
   void (*set_pmi)(struct iwl_trans * , bool  ) ;
   bool (*grab_nic_access)(struct iwl_trans * , bool  , unsigned long * ) ;
   void (*release_nic_access)(struct iwl_trans * , unsigned long * ) ;
   void (*set_bits_mask)(struct iwl_trans * , u32  , u32  , u32  ) ;
   void (*ref)(struct iwl_trans * ) ;
   void (*unref)(struct iwl_trans * ) ;
   void (*suspend)(struct iwl_trans * ) ;
   void (*resume)(struct iwl_trans * ) ;
   struct iwl_trans_dump_data *(*dump_data)(struct iwl_trans * ) ;
};
#line 552
enum iwl_trans_state {
    IWL_TRANS_NO_FW = 0,
    IWL_TRANS_FW_ALIVE = 1
} ;
#line 557
enum iwl_d0i3_mode {
    IWL_D0I3_MODE_OFF = 0,
    IWL_D0I3_MODE_ON_IDLE = 1,
    IWL_D0I3_MODE_ON_SUSPEND = 2
} ;
#line 563 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
struct iwl_trans {
   struct iwl_trans_ops  const  *ops ;
   struct iwl_op_mode *op_mode ;
   struct iwl_cfg  const  *cfg ;
   enum iwl_trans_state state ;
   unsigned long status ;
   struct device *dev ;
   u32 hw_rev ;
   u32 hw_id ;
   char hw_id_str[52U] ;
   u8 rx_mpdu_cmd ;
   u8 rx_mpdu_cmd_hdr_size ;
   bool pm_support ;
   bool ltr_enabled ;
   struct kmem_cache *dev_cmd_pool ;
   size_t dev_cmd_headroom ;
   char dev_cmd_pool_name[50U] ;
   struct dentry *dbgfs_dir ;
   struct lockdep_map sync_cmd_lockdep_map ;
   u64 dflt_pwr_limit ;
   struct iwl_fw_dbg_dest_tlv  const  *dbg_dest_tlv ;
   struct iwl_fw_dbg_conf_tlv  const  *dbg_conf_tlv[32U] ;
   struct iwl_fw_dbg_trigger_tlv * const  *dbg_trigger_tlv ;
   u8 dbg_dest_reg_num ;
   enum iwl_d0i3_mode d0i3_mode ;
   bool wowlan_d0i3 ;
   char trans_specific[0U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-eeprom-read.h"
struct iwl_nvm_data {
   int n_hw_addrs ;
   u8 hw_addr[6U] ;
   u8 calib_version ;
   __le16 calib_voltage ;
   __le16 raw_temperature ;
   __le16 kelvin_temperature ;
   __le16 kelvin_voltage ;
   __le16 xtal_calib[2U] ;
   bool sku_cap_band_24GHz_enable ;
   bool sku_cap_band_52GHz_enable ;
   bool sku_cap_11n_enable ;
   bool sku_cap_11ac_enable ;
   bool sku_cap_amt_enable ;
   bool sku_cap_ipan_enable ;
   bool sku_cap_mimo_disabled ;
   u16 radio_cfg_type ;
   u8 radio_cfg_step ;
   u8 radio_cfg_dash ;
   u8 radio_cfg_pnum ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   u32 nvm_version ;
   s8 max_tx_pwr_half_dbm ;
   bool lar_enabled ;
   struct ieee80211_supported_band bands[3U] ;
   struct ieee80211_channel channels[] ;
};
#line 59 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 30 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 38 "include/linux/tracepoint.h"
struct trace_enum_map {
   char const   *system ;
   char const   *enum_string ;
   unsigned long enum_value ;
};
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_390 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_392 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_398 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_400 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h"
union __anonunion___u_418 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h"
union __anonunion___u_420 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 55 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h"
union __anonunion___u_422 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 55 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h"
union __anonunion___u_424 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 118 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h"
union __anonunion___u_466 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 118 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h"
union __anonunion___u_468 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 180 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h"
union __anonunion___u_470 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 180 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h"
union __anonunion___u_472 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 166 "drivers/net/wireless/iwlwifi/dvm/../iwl-drv.h"
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
} ;
#line 172
struct led_trigger;
#line 172 "drivers/net/wireless/iwlwifi/dvm/../iwl-drv.h"
struct led_classdev {
   char const   *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev * , enum led_brightness  ) ;
   int (*brightness_set_sync)(struct led_classdev * , enum led_brightness  ) ;
   enum led_brightness (*brightness_get)(struct led_classdev * ) ;
   int (*blink_set)(struct led_classdev * , unsigned long * , unsigned long * ) ;
   struct device *dev ;
   struct attribute_group  const  **groups ;
   struct list_head node ;
   char const   *default_trigger ;
   unsigned long blink_delay_on ;
   unsigned long blink_delay_off ;
   struct timer_list blink_timer ;
   int blink_brightness ;
   void (*flash_resume)(struct led_classdev * ) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};
#line 200 "include/linux/leds.h"
struct led_trigger {
   char const   *name ;
   void (*activate)(struct led_classdev * ) ;
   void (*deactivate)(struct led_classdev * ) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};
#line 384 "include/linux/leds.h"
struct iwl_notif_wait_data {
   struct list_head notif_waits ;
   spinlock_t notif_wait_lock ;
   wait_queue_head_t notif_waitq ;
};
#line 360 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_tx_ant_config_cmd {
   __le32 valid ;
};
#line 370 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_error_event_table {
   u32 valid ;
   u32 error_id ;
   u32 pc ;
   u32 blink1 ;
   u32 blink2 ;
   u32 ilink1 ;
   u32 ilink2 ;
   u32 data1 ;
   u32 data2 ;
   u32 line ;
   u32 bcon_time ;
   u32 tsf_low ;
   u32 tsf_hi ;
   u32 gp1 ;
   u32 gp2 ;
   u32 gp3 ;
   u32 ucode_ver ;
   u32 hw_ver ;
   u32 brd_ver ;
   u32 log_pc ;
   u32 frame_ptr ;
   u32 stack_ptr ;
   u32 hcmd ;
   u32 isr0 ;
   u32 isr1 ;
   u32 isr2 ;
   u32 isr3 ;
   u32 isr4 ;
   u32 isr_pref ;
   u32 wait_event ;
   u32 l2p_control ;
   u32 l2p_duration ;
   u32 l2p_mhvalid ;
   u32 l2p_addr_match ;
   u32 lmpm_pmg_sel ;
   u32 u_timestamp ;
   u32 flow_handler ;
};
#line 514 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_rxon_cmd {
   u8 node_addr[6U] ;
   __le16 reserved1 ;
   u8 bssid_addr[6U] ;
   __le16 reserved2 ;
   u8 wlap_bssid_addr[6U] ;
   __le16 reserved3 ;
   u8 dev_type ;
   u8 air_propagation ;
   __le16 rx_chain ;
   u8 ofdm_basic_rates ;
   u8 cck_basic_rates ;
   __le16 assoc_id ;
   __le32 flags ;
   __le32 filter_flags ;
   __le16 channel ;
   u8 ofdm_ht_single_stream_basic_rates ;
   u8 ofdm_ht_dual_stream_basic_rates ;
   u8 ofdm_ht_triple_stream_basic_rates ;
   u8 reserved5 ;
   __le16 acquisition_data ;
   __le16 reserved6 ;
};
#line 659 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_rxon_time_cmd {
   __le64 timestamp ;
   __le16 beacon_interval ;
   __le16 atim_window ;
   __le32 beacon_init_val ;
   __le16 listen_interval ;
   u8 dtim_period ;
   u8 delta_cp_bss_tbtts ;
};
#line 729 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_ac_qos {
   __le16 cw_min ;
   __le16 cw_max ;
   u8 aifsn ;
   u8 reserved1 ;
   __le16 edca_txop ;
};
#line 759 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_qosparam_cmd {
   __le32 qos_flags ;
   struct iwl_ac_qos ac[4U] ;
};
#line 778 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_keyinfo {
   __le16 key_flags ;
   u8 tkip_rx_tsc_byte2 ;
   u8 reserved1 ;
   __le16 tkip_rx_ttak[5U] ;
   u8 key_offset ;
   u8 reserved2 ;
   u8 key[16U] ;
   __le64 tx_secur_seq_cnt ;
   __le64 hw_tkip_mic_rx_key ;
   __le64 hw_tkip_mic_tx_key ;
};
#line 854 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct sta_id_modify {
   u8 addr[6U] ;
   __le16 reserved1 ;
   u8 sta_id ;
   u8 modify_mask ;
   __le16 reserved2 ;
};
#line 874 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_addsta_cmd {
   u8 mode ;
   u8 reserved[3U] ;
   struct sta_id_modify sta ;
   struct iwl_keyinfo key ;
   __le32 station_flags ;
   __le32 station_flags_msk ;
   __le16 tid_disable_tx ;
   __le16 legacy_reserved ;
   u8 add_immediate_ba_tid ;
   u8 remove_immediate_ba_tid ;
   __le16 add_immediate_ba_ssn ;
   __le16 sleep_tx_count ;
   __le16 reserved2 ;
};
#line 1018 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wep_key {
   u8 key_index ;
   u8 key_offset ;
   u8 reserved1[2U] ;
   u8 key_size ;
   u8 reserved2[3U] ;
   u8 key[16U] ;
};
#line 1103 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_rx_phy_res {
   u8 non_cfg_phy_cnt ;
   u8 cfg_phy_cnt ;
   u8 stat_id ;
   u8 reserved1 ;
   __le64 timestamp ;
   __le32 beacon_time_stamp ;
   __le16 phy_flags ;
   __le16 channel ;
   u8 non_cfg_phy_buf[32U] ;
   __le32 rate_n_flags ;
   __le16 byte_count ;
   __le16 frame_time ;
};
#line 1128 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_dram_scratch {
   u8 try_cnt ;
   u8 bt_kill_cnt ;
   __le16 reserved ;
};
#line 1242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
union __anonunion_stop_time_473 {
   __le32 life_time ;
   __le32 attempt ;
};
#line 1242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
union __anonunion_timeout_474 {
   __le16 pm_frame_timeout ;
   __le16 attempt_duration ;
};
#line 1242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_tx_cmd {
   __le16 len ;
   __le16 next_frame_len ;
   __le32 tx_flags ;
   struct iwl_dram_scratch scratch ;
   __le32 rate_n_flags ;
   u8 sta_id ;
   u8 sec_ctl ;
   u8 initial_rate_index ;
   u8 reserved ;
   u8 key[16U] ;
   __le16 next_frame_flags ;
   __le16 reserved2 ;
   union __anonunion_stop_time_473 stop_time ;
   __le32 dram_lsb_ptr ;
   u8 dram_msb_ptr ;
   u8 rts_retry_limit ;
   u8 data_retry_limit ;
   u8 tid_tspec ;
   union __anonunion_timeout_474 timeout ;
   __le16 driver_txop ;
   u8 payload[0U] ;
   struct ieee80211_hdr hdr[0U] ;
};
#line 1524 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_link_qual_general_params {
   u8 flags ;
   u8 mimo_delimiter ;
   u8 single_stream_ant_msk ;
   u8 dual_stream_ant_msk ;
   u8 start_rate_index[4U] ;
};
#line 1575 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_link_qual_agg_params {
   __le16 agg_time_limit ;
   u8 agg_dis_start_th ;
   u8 agg_frame_cnt_limit ;
   __le32 reserved ;
};
#line 1618 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct __anonstruct_rs_table_475 {
   __le32 rate_n_flags ;
};
#line 1618 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_link_quality_cmd {
   u8 sta_id ;
   u8 reserved1 ;
   __le16 control ;
   struct iwl_link_qual_general_params general_params ;
   struct iwl_link_qual_agg_params agg_params ;
   struct __anonstruct_rs_table_475 rs_table[16U] ;
   __le32 reserved2 ;
};
#line 1826 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_bt_cmd {
   u8 flags ;
   u8 lead_time ;
   u8 max_kill ;
   u8 reserved ;
   __le32 kill_ack_mask ;
   __le32 kill_cts_mask ;
};
#line 2062 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_measurement_histogram {
   __le32 ofdm[8U] ;
   __le32 cck[8U] ;
};
#line 2087 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_spectrum_notification {
   u8 id ;
   u8 token ;
   u8 channel_index ;
   u8 state ;
   __le32 start_time ;
   u8 band ;
   u8 channel ;
   u8 type ;
   u8 reserved1 ;
   __le32 cca_ofdm ;
   __le32 cca_cck ;
   __le32 cca_time ;
   u8 basic_type ;
   u8 reserved2[3U] ;
   struct iwl_measurement_histogram histogram ;
   __le32 stop_time ;
   __le32 status ;
};
#line 2114 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_powertable_cmd {
   __le16 flags ;
   u8 keep_alive_seconds ;
   u8 debug_flags ;
   __le32 rx_data_timeout ;
   __le32 tx_data_timeout ;
   __le32 sleep_interval[5U] ;
   __le32 keep_alive_beacons ;
};
#line 2224 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_ct_kill_config {
   __le32 reserved ;
   __le32 critical_temperature_M ;
   __le32 critical_temperature_R ;
};
#line 2235 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_ct_kill_throttling_config {
   __le32 critical_temperature_exit ;
   __le32 reserved ;
   __le32 critical_temperature_enter ;
};
#line 2495 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_tx_beacon_cmd {
   struct iwl_tx_cmd tx ;
   __le16 tim_idx ;
   u8 tim_size ;
   u8 reserved1 ;
   struct ieee80211_hdr frame[0U] ;
};
#line 2533 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_dbg {
   __le32 burst_check ;
   __le32 burst_count ;
   __le32 wait_for_silence_timeout_cnt ;
   __le32 reserved[3U] ;
};
#line 2542 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_rx_phy {
   __le32 ina_cnt ;
   __le32 fina_cnt ;
   __le32 plcp_err ;
   __le32 crc32_err ;
   __le32 overrun_err ;
   __le32 early_overrun_err ;
   __le32 crc32_good ;
   __le32 false_alarm_cnt ;
   __le32 fina_sync_err_cnt ;
   __le32 sfd_timeout ;
   __le32 fina_timeout ;
   __le32 unresponded_rts ;
   __le32 rxe_frame_limit_overrun ;
   __le32 sent_ack_cnt ;
   __le32 sent_cts_cnt ;
   __le32 sent_ba_rsp_cnt ;
   __le32 dsp_self_kill ;
   __le32 mh_format_err ;
   __le32 re_acq_main_rssi_sum ;
   __le32 reserved3 ;
};
#line 2565 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_rx_ht_phy {
   __le32 plcp_err ;
   __le32 overrun_err ;
   __le32 early_overrun_err ;
   __le32 crc32_good ;
   __le32 crc32_err ;
   __le32 mh_format_err ;
   __le32 agg_crc32_good ;
   __le32 agg_mpdu_cnt ;
   __le32 agg_cnt ;
   __le32 unsupport_mcs ;
};
#line 2578 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_rx_non_phy {
   __le32 bogus_cts ;
   __le32 bogus_ack ;
   __le32 non_bssid_frames ;
   __le32 filtered_frames ;
   __le32 non_channel_beacons ;
   __le32 channel_beacons ;
   __le32 num_missed_bcon ;
   __le32 adc_rx_saturation_time ;
   __le32 ina_detection_search_time ;
   __le32 beacon_silence_rssi_a ;
   __le32 beacon_silence_rssi_b ;
   __le32 beacon_silence_rssi_c ;
   __le32 interference_data_flag ;
   __le32 channel_load ;
   __le32 dsp_false_alarms ;
   __le32 beacon_rssi_a ;
   __le32 beacon_rssi_b ;
   __le32 beacon_rssi_c ;
   __le32 beacon_energy_a ;
   __le32 beacon_energy_b ;
   __le32 beacon_energy_c ;
};
#line 2634 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_tx_power {
   u8 ant_a ;
   u8 ant_b ;
   u8 ant_c ;
   u8 reserved ;
};
#line 2648 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_tx_non_phy_agg {
   __le32 ba_timeout ;
   __le32 ba_reschedule_frames ;
   __le32 scd_query_agg_frame_cnt ;
   __le32 scd_query_no_agg ;
   __le32 scd_query_agg ;
   __le32 scd_query_mismatch ;
   __le32 frame_not_ready ;
   __le32 underrun ;
   __le32 bt_prio_kill ;
   __le32 rx_ba_rsp_cnt ;
};
#line 2661 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_tx {
   __le32 preamble_cnt ;
   __le32 rx_detected_cnt ;
   __le32 bt_prio_defer_cnt ;
   __le32 bt_prio_kill_cnt ;
   __le32 few_bytes_cnt ;
   __le32 cts_timeout ;
   __le32 ack_timeout ;
   __le32 expected_ack_cnt ;
   __le32 actual_ack_cnt ;
   __le32 dump_msdu_cnt ;
   __le32 burst_abort_next_frame_mismatch_cnt ;
   __le32 burst_abort_missing_next_frame_cnt ;
   __le32 cts_timeout_collision ;
   __le32 ack_or_ba_timeout_collision ;
   struct statistics_tx_non_phy_agg agg ;
   struct statistics_tx_power tx_power ;
   __le32 reserved1 ;
};
#line 2686 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_div {
   __le32 tx_on_a ;
   __le32 tx_on_b ;
   __le32 exec_time ;
   __le32 probe_time ;
   __le32 reserved1 ;
   __le32 reserved2 ;
};
#line 2696 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_general_common {
   __le32 temperature ;
   __le32 temperature_m ;
   struct statistics_dbg dbg ;
   __le32 sleep_time ;
   __le32 slots_out ;
   __le32 slots_idle ;
   __le32 ttl_timestamp ;
   struct statistics_div div ;
   __le32 rx_enable_counter ;
   __le32 num_of_sos_states ;
};
#line 2714 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_bt_activity {
   __le32 hi_priority_tx_req_cnt ;
   __le32 hi_priority_tx_denied_cnt ;
   __le32 lo_priority_tx_req_cnt ;
   __le32 lo_priority_tx_denied_cnt ;
   __le32 hi_priority_rx_req_cnt ;
   __le32 hi_priority_rx_denied_cnt ;
   __le32 lo_priority_rx_req_cnt ;
   __le32 lo_priority_rx_denied_cnt ;
};
#line 2740 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_statistics_cmd {
   __le32 configuration_flags ;
};
#line 3109 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_cfg_elmnt_s {
   __le32 is_enable ;
   __le32 start ;
   __le32 send_res ;
   __le32 apply_res ;
   __le32 reserved ;
};
#line 3196 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_cfg_status_s {
   struct iwl_calib_cfg_elmnt_s once ;
   struct iwl_calib_cfg_elmnt_s perd ;
   __le32 flags ;
};
#line 3202 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_cfg_cmd {
   struct iwl_calib_cfg_status_s ucd_calib_cfg ;
   struct iwl_calib_cfg_status_s drv_calib_cfg ;
   __le32 reserved1 ;
};
#line 4007 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_power_mgr {
   struct iwl_powertable_cmd sleep_cmd ;
   struct iwl_powertable_cmd sleep_cmd_next ;
   int debug_sleep_level_override ;
   bool bus_pm ;
};
#line 425 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
enum iwl_antenna_ok {
    IWL_ANT_OK_NONE = 0,
    IWL_ANT_OK_SINGLE = 1,
    IWL_ANT_OK_MULTI = 2
} ;
#line 431
enum iwl_tt_state {
    IWL_TI_0 = 0,
    IWL_TI_1 = 1,
    IWL_TI_2 = 2,
    IWL_TI_CT_KILL = 3,
    IWL_TI_STATE_MAX = 4
} ;
#line 439 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
struct iwl_tt_restriction {
   enum iwl_antenna_ok tx_stream ;
   enum iwl_antenna_ok rx_stream ;
   bool is_ht ;
};
#line 68 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/tt.h"
struct iwl_tt_trans {
   enum iwl_tt_state next_state ;
   u32 tt_low ;
   u32 tt_high ;
};
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/tt.h"
struct iwl_tt_mgmt {
   enum iwl_tt_state state ;
   bool advanced_tt ;
   u8 tt_power_mode ;
   bool ct_kill_toggle ;
   s32 tt_previous_temp ;
   struct iwl_tt_restriction *restriction ;
   struct iwl_tt_trans *transaction ;
   struct timer_list ct_kill_exit_tm ;
   struct timer_list ct_kill_waiting_tm ;
};
#line 113 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_ht_config {
   bool single_chain_sufficient ;
   enum ieee80211_smps_mode smps ;
};
#line 118 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_qos_info {
   int qos_active ;
   struct iwl_qosparam_cmd def_qos_parm ;
};
#line 124
enum iwl_agg_state {
    IWL_AGG_OFF = 0,
    IWL_AGG_STARTING = 1,
    IWL_AGG_ON = 2,
    IWL_EMPTYING_HW_QUEUE_ADDBA = 3,
    IWL_EMPTYING_HW_QUEUE_DELBA = 4
} ;
#line 132 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_ht_agg {
   u32 rate_n_flags ;
   enum iwl_agg_state state ;
   u16 txq_id ;
   u16 ssn ;
   bool wait_for_ba ;
};
#line 172 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_tid_data {
   u16 seq_number ;
   u16 next_reclaimed ;
   struct iwl_ht_agg agg ;
};
#line 188 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_station_entry {
   struct iwl_addsta_cmd sta ;
   u8 used ;
   u8 ctxid ;
   struct iwl_link_quality_cmd *lq ;
};
#line 200
struct iwl_rxon_context;
#line 228 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_sensitivity_ranges {
   u16 min_nrg_cck ;
   u16 nrg_th_cck ;
   u16 nrg_th_ofdm ;
   u16 auto_corr_min_ofdm ;
   u16 auto_corr_min_ofdm_mrc ;
   u16 auto_corr_min_ofdm_x1 ;
   u16 auto_corr_min_ofdm_mrc_x1 ;
   u16 auto_corr_max_ofdm ;
   u16 auto_corr_max_ofdm_mrc ;
   u16 auto_corr_max_ofdm_x1 ;
   u16 auto_corr_max_ofdm_mrc_x1 ;
   u16 auto_corr_max_cck ;
   u16 auto_corr_max_cck_mrc ;
   u16 auto_corr_min_cck ;
   u16 auto_corr_min_cck_mrc ;
   u16 barker_corr_th_min ;
   u16 barker_corr_th_min_mrc ;
   u16 nrg_th_cca ;
};
#line 288 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_sensitivity_data {
   u32 auto_corr_ofdm ;
   u32 auto_corr_ofdm_mrc ;
   u32 auto_corr_ofdm_x1 ;
   u32 auto_corr_ofdm_mrc_x1 ;
   u32 auto_corr_cck ;
   u32 auto_corr_cck_mrc ;
   u32 last_bad_plcp_cnt_ofdm ;
   u32 last_fa_cnt_ofdm ;
   u32 last_bad_plcp_cnt_cck ;
   u32 last_fa_cnt_cck ;
   u32 nrg_curr_state ;
   u32 nrg_prev_state ;
   u32 nrg_value[10U] ;
   u8 nrg_silence_rssi[20U] ;
   u32 nrg_silence_ref ;
   u32 nrg_energy_idx ;
   u32 nrg_silence_idx ;
   u32 nrg_th_cck ;
   s32 nrg_auto_corr_silence_diff ;
   u32 num_in_cck_no_fa ;
   u32 nrg_th_ofdm ;
   u16 barker_corr_th_min ;
   u16 barker_corr_th_min_mrc ;
   u16 nrg_th_cca ;
};
#line 361 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_chain_noise_data {
   u32 active_chains ;
   u32 chain_noise_a ;
   u32 chain_noise_b ;
   u32 chain_noise_c ;
   u32 chain_signal_a ;
   u32 chain_signal_b ;
   u32 chain_signal_c ;
   u16 beacon_count ;
   u8 disconn_array[3U] ;
   u8 delta_gain_code[3U] ;
   u8 radio_write ;
   u8 state ;
};
#line 382 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct reply_tx_error_statistics {
   u32 pp_delay ;
   u32 pp_few_bytes ;
   u32 pp_bt_prio ;
   u32 pp_quiet_period ;
   u32 pp_calc_ttak ;
   u32 int_crossed_retry ;
   u32 short_limit ;
   u32 long_limit ;
   u32 fifo_underrun ;
   u32 drain_flow ;
   u32 rfkill_flush ;
   u32 life_expire ;
   u32 dest_ps ;
   u32 host_abort ;
   u32 bt_retry ;
   u32 sta_invalid ;
   u32 frag_drop ;
   u32 tid_disable ;
   u32 fifo_flush ;
   u32 insuff_cf_poll ;
   u32 fail_hw_drop ;
   u32 sta_color_mismatch ;
   u32 unknown ;
};
#line 409 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct reply_agg_tx_error_statistics {
   u32 underrun ;
   u32 bt_prio ;
   u32 few_bytes ;
   u32 abort ;
   u32 last_sent_ttl ;
   u32 last_sent_try ;
   u32 last_sent_bt_kill ;
   u32 scd_query ;
   u32 bad_crc32 ;
   u32 response ;
   u32 dump_tx ;
   u32 delay_tx ;
   u32 unknown ;
};
#line 426 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_event_log {
   bool ucode_trace ;
   u32 num_wraps ;
   u32 next_entry ;
   int non_wraps_count ;
   int wraps_once_count ;
   int wraps_more_count ;
};
#line 452 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_rf_reset {
   int reset_request_count ;
   int reset_success_count ;
   int reset_reject_count ;
   unsigned long last_reset_jiffies ;
};
#line 469
enum iwl_rxon_context_id {
    IWL_RXON_CTX_BSS = 0,
    IWL_RXON_CTX_PAN = 1,
    NUM_IWL_RXON_CTX = 2
} ;
#line 475 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct __anonstruct_ht_479 {
   bool non_gf_sta_present ;
   u8 protection ;
   bool enabled ;
   bool is_40mhz ;
   u8 extension_chan_offset ;
};
#line 475 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_rxon_context {
   struct ieee80211_vif *vif ;
   u8 mcast_queue ;
   u8 ac_to_queue[4U] ;
   u8 ac_to_fifo[4U] ;
   bool always_active ;
   bool is_active ;
   bool ht_need_multiple_chains ;
   enum iwl_rxon_context_id ctxid ;
   u32 interface_modes ;
   u32 exclusive_interface_modes ;
   u8 unused_devtype ;
   u8 ap_devtype ;
   u8 ibss_devtype ;
   u8 station_devtype ;
   struct iwl_rxon_cmd  const  active ;
   struct iwl_rxon_cmd staging ;
   struct iwl_rxon_time_cmd timing ;
   struct iwl_qos_info qos_data ;
   u8 bcast_sta_id ;
   u8 ap_sta_id ;
   u8 rxon_cmd ;
   u8 rxon_assoc_cmd ;
   u8 rxon_timing_cmd ;
   u8 qos_cmd ;
   u8 wep_key_cmd ;
   struct iwl_wep_key wep_keys[4U] ;
   u8 key_mapping_keys ;
   __le32 station_flags ;
   int beacon_int ;
   struct __anonstruct_ht_479 ht ;
};
#line 539
enum iwl_scan_type {
    IWL_SCAN_NORMAL = 0,
    IWL_SCAN_RADIO_RESET = 1
} ;
#line 544 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_hw_params {
   u8 tx_chains_num ;
   u8 rx_chains_num ;
   bool use_rts_for_aggregation ;
   u32 ct_kill_threshold ;
   u32 ct_kill_exit_threshold ;
   struct iwl_sensitivity_ranges  const  *sens ;
};
#line 567 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_dvm_bt_params {
   bool advanced_bt_coexist ;
   u8 bt_init_traffic_load ;
   u32 bt_prio_boost ;
   u16 agg_time_limit ;
   bool bt_sco_disable ;
   bool bt_session_2 ;
};
#line 584 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_dvm_cfg {
   void (*set_hw_params)(struct iwl_priv * ) ;
   int (*set_channel_switch)(struct iwl_priv * , struct ieee80211_channel_switch * ) ;
   void (*nic_config)(struct iwl_priv * ) ;
   void (*temperature)(struct iwl_priv * ) ;
   struct iwl_dvm_bt_params  const  *bt_params ;
   s32 chain_noise_scale ;
   u8 plcp_delta_threshold ;
   bool adv_thermal_throttle ;
   bool support_ct_kill_exit ;
   bool hd_v2 ;
   bool no_idle_support ;
   bool need_temp_offset_calib ;
   bool no_xtal_calib ;
   bool temp_offset_v2 ;
   bool adv_pm ;
};
#line 624 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_wipan_noa_data {
   struct callback_head callback_head ;
   u32 length ;
   u8 data[] ;
};
#line 638 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct __anonstruct_statistics_480 {
   __le32 flag ;
   struct statistics_general_common common ;
   struct statistics_rx_non_phy rx_non_phy ;
   struct statistics_rx_phy rx_ofdm ;
   struct statistics_rx_ht_phy rx_ofdm_ht ;
   struct statistics_rx_phy rx_cck ;
   struct statistics_tx tx ;
   struct statistics_bt_activity bt_activity ;
   __le32 num_bt_kills ;
   __le32 accum_num_bt_kills ;
   spinlock_t lock ;
};
#line 638 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct __anonstruct_accum_stats_481 {
   struct statistics_general_common common ;
   struct statistics_rx_non_phy rx_non_phy ;
   struct statistics_rx_phy rx_ofdm ;
   struct statistics_rx_ht_phy rx_ofdm_ht ;
   struct statistics_rx_phy rx_cck ;
   struct statistics_tx tx ;
   struct statistics_bt_activity bt_activity ;
};
#line 638 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct __anonstruct_delta_stats_482 {
   struct statistics_general_common common ;
   struct statistics_rx_non_phy rx_non_phy ;
   struct statistics_rx_phy rx_ofdm ;
   struct statistics_rx_ht_phy rx_ofdm_ht ;
   struct statistics_rx_phy rx_cck ;
   struct statistics_tx tx ;
   struct statistics_bt_activity bt_activity ;
};
#line 638 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct __anonstruct_max_delta_stats_483 {
   struct statistics_general_common common ;
   struct statistics_rx_non_phy rx_non_phy ;
   struct statistics_rx_phy rx_ofdm ;
   struct statistics_rx_ht_phy rx_ofdm_ht ;
   struct statistics_rx_phy rx_cck ;
   struct statistics_tx tx ;
   struct statistics_bt_activity bt_activity ;
};
#line 638 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct __anonstruct_device_pointers_484 {
   u32 error_event_table ;
   u32 log_event_table ;
};
#line 638 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_priv {
   struct iwl_trans *trans ;
   struct device *dev ;
   struct iwl_cfg  const  *cfg ;
   struct iwl_fw  const  *fw ;
   struct iwl_dvm_cfg  const  *lib ;
   unsigned long status ;
   spinlock_t sta_lock ;
   struct mutex mutex ;
   unsigned long transport_queue_stop ;
   bool passive_no_rx ;
   u8 queue_to_mac80211[32U] ;
   atomic_t queue_stop_count[32U] ;
   unsigned long agg_q_alloc[1U] ;
   struct ieee80211_hw *hw ;
   struct list_head calib_results ;
   struct workqueue_struct *workqueue ;
   struct iwl_hw_params hw_params ;
   enum ieee80211_band band ;
   u8 valid_contexts ;
   int (*rx_handlers[255U])(struct iwl_priv * , struct iwl_rx_cmd_buffer * , struct iwl_device_cmd * ) ;
   struct iwl_notif_wait_data notif_wait ;
   struct iwl_spectrum_notification measure_report ;
   u8 measurement_status ;
   u32 ucode_beacon_time ;
   int missed_beacon_threshold ;
   u32 ibss_manager ;
   unsigned long rx_statistics_jiffies ;
   u32 rx_handlers_stats[255U] ;
   struct iwl_rf_reset rf_reset ;
   unsigned long reload_jiffies ;
   int reload_count ;
   bool ucode_loaded ;
   u8 plcp_delta_threshold ;
   s32 temperature ;
   s32 last_temperature ;
   struct iwl_wipan_noa_data *noa_data ;
   unsigned long scan_start ;
   unsigned long scan_start_tsf ;
   void *scan_cmd ;
   enum ieee80211_band scan_band ;
   struct cfg80211_scan_request *scan_request ;
   struct ieee80211_vif *scan_vif ;
   enum iwl_scan_type scan_type ;
   u8 scan_tx_ant[3U] ;
   u8 mgmt_tx_ant ;
   u8 sta_key_max_num ;
   bool new_scan_threshold_behaviour ;
   bool wowlan ;
   struct mac_address addresses[2U] ;
   struct iwl_rxon_context contexts[2U] ;
   __le16 switch_channel ;
   u8 start_calib ;
   struct iwl_sensitivity_data sensitivity_data ;
   struct iwl_chain_noise_data chain_noise_data ;
   __le16 sensitivity_tbl[11U] ;
   __le16 enhance_sensitivity_tbl[12U] ;
   struct iwl_ht_config current_ht_config ;
   u8 retry_rate ;
   int activity_timer_active ;
   struct iwl_power_mgr power_data ;
   struct iwl_tt_mgmt thermal_throttle ;
   int num_stations ;
   struct iwl_station_entry stations[16U] ;
   unsigned long ucode_key_table ;
   struct iwl_tid_data tid_data[16U][8U] ;
   atomic_t num_aux_in_flight ;
   u8 mac80211_registered ;
   u8 is_open ;
   enum nl80211_iftype iw_mode ;
   u64 timestamp ;
   struct __anonstruct_statistics_480 statistics ;
   struct __anonstruct_accum_stats_481 accum_stats ;
   struct __anonstruct_delta_stats_482 delta_stats ;
   struct __anonstruct_max_delta_stats_483 max_delta_stats ;
   u8 agg_tids_count ;
   struct iwl_rx_phy_res last_phy_res ;
   u32 ampdu_ref ;
   bool last_phy_res_valid ;
   u8 phy_calib_chain_noise_reset_cmd ;
   u8 phy_calib_chain_noise_gain_cmd ;
   struct reply_tx_error_statistics reply_tx_stats ;
   struct reply_agg_tx_error_statistics reply_agg_tx_stats ;
   u8 bt_enable_flag ;
   u8 bt_status ;
   u8 bt_traffic_load ;
   u8 last_bt_traffic_load ;
   bool bt_ch_announce ;
   bool bt_full_concurrent ;
   bool bt_ant_couple_ok ;
   __le32 kill_ack_mask ;
   __le32 kill_cts_mask ;
   __le16 bt_valid ;
   bool reduced_txpower ;
   u16 bt_on_thresh ;
   u16 bt_duration ;
   u16 dynamic_frag_thresh ;
   u8 bt_ci_compliance ;
   struct work_struct bt_traffic_change_work ;
   bool bt_enable_pspoll ;
   struct iwl_rxon_context *cur_rssi_ctx ;
   bool bt_is_sco ;
   struct work_struct restart ;
   struct work_struct scan_completed ;
   struct work_struct abort_scan ;
   struct work_struct beacon_update ;
   struct iwl_rxon_context *beacon_ctx ;
   struct sk_buff *beacon_skb ;
   void *beacon_cmd ;
   struct work_struct tt_work ;
   struct work_struct ct_enter ;
   struct work_struct ct_exit ;
   struct work_struct start_internal_scan ;
   struct work_struct tx_flush ;
   struct work_struct bt_full_concurrency ;
   struct work_struct bt_runtime_config ;
   struct delayed_work scan_check ;
   s8 tx_power_user_lmt ;
   s8 tx_power_next ;
   struct dentry *debugfs_dir ;
   u32 dbgfs_sram_offset ;
   u32 dbgfs_sram_len ;
   bool disable_ht40 ;
   void *wowlan_sram ;
   struct iwl_nvm_data *nvm_data ;
   u8 *eeprom_blob ;
   size_t eeprom_blob_size ;
   struct work_struct txpower_work ;
   u32 calib_disabled ;
   struct work_struct run_time_calib_work ;
   struct timer_list statistics_periodic ;
   struct timer_list ucode_trace ;
   struct iwl_event_log event_log ;
   struct led_classdev led ;
   unsigned long blink_on ;
   unsigned long blink_off ;
   bool led_registered ;
   u8 kck[16U] ;
   u8 kek[16U] ;
   __le64 replay_ctr ;
   __le16 last_seq_ctl ;
   bool have_rekey_data ;
   struct wiphy_wowlan_support wowlan_support ;
   struct __anonstruct_device_pointers_484 device_pointers ;
   enum iwl_ucode_type cur_ucode ;
};
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
struct __anonstruct_read_486 {
   u32 capacity ;
   u32 mode ;
   u32 wrap_counter ;
   u32 write_counter ;
};
#line 1066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
union __anonunion___u_488 {
   struct iwl_wipan_noa_data *__val ;
   char __c[1U] ;
};
#line 1476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
struct __anonstruct_advanced_lookup_490 {
   char *name ;
   u8 num ;
};
#line 2803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 2814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 2825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 2844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 2879 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 2962 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 2973 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 3024 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef bool ldv_func_ret_type___6;
#line 3035 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef bool ldv_func_ret_type___7;
#line 3046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef bool ldv_func_ret_type___8;
#line 3057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef bool ldv_func_ret_type___9;
#line 3068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef int ldv_func_ret_type___10;
#line 3079 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
typedef int ldv_func_ret_type___11;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 584 "include/net/mac80211.h"
enum mac80211_rate_control_flags {
    IEEE80211_TX_RC_USE_RTS_CTS = 1,
    IEEE80211_TX_RC_USE_CTS_PROTECT = 2,
    IEEE80211_TX_RC_USE_SHORT_PREAMBLE = 4,
    IEEE80211_TX_RC_MCS = 8,
    IEEE80211_TX_RC_GREEN_FIELD = 16,
    IEEE80211_TX_RC_40_MHZ_WIDTH = 32,
    IEEE80211_TX_RC_DUP_DATA = 64,
    IEEE80211_TX_RC_SHORT_GI = 128,
    IEEE80211_TX_RC_VHT_MCS = 256,
    IEEE80211_TX_RC_80_MHZ_WIDTH = 512,
    IEEE80211_TX_RC_160_MHZ_WIDTH = 1024
} ;
#line 5076 "include/net/mac80211.h"
struct ieee80211_tx_rate_control {
   struct ieee80211_hw *hw ;
   struct ieee80211_supported_band *sband ;
   struct ieee80211_bss_conf *bss_conf ;
   struct sk_buff *skb ;
   struct ieee80211_tx_rate reported_rate ;
   bool rts ;
   bool short_preamble ;
   u8 max_rate_idx ;
   u32 rate_idx_mask ;
   u8 *rate_idx_mcs_mask ;
   bool bss ;
};
#line 5114 "include/net/mac80211.h"
struct rate_control_ops {
   char const   *name ;
   void *(*alloc)(struct ieee80211_hw * , struct dentry * ) ;
   void (*free)(void * ) ;
   void *(*alloc_sta)(void * , struct ieee80211_sta * , gfp_t  ) ;
   void (*rate_init)(void * , struct ieee80211_supported_band * , struct cfg80211_chan_def * ,
                     struct ieee80211_sta * , void * ) ;
   void (*rate_update)(void * , struct ieee80211_supported_band * , struct cfg80211_chan_def * ,
                       struct ieee80211_sta * , void * , u32  ) ;
   void (*free_sta)(void * , struct ieee80211_sta * , void * ) ;
   void (*tx_status_noskb)(void * , struct ieee80211_supported_band * , struct ieee80211_sta * ,
                           void * , struct ieee80211_tx_info * ) ;
   void (*tx_status)(void * , struct ieee80211_supported_band * , struct ieee80211_sta * ,
                     void * , struct sk_buff * ) ;
   void (*get_rate)(void * , struct ieee80211_sta * , void * , struct ieee80211_tx_rate_control * ) ;
   void (*add_sta_debugfs)(void * , void * , struct dentry * ) ;
   void (*remove_sta_debugfs)(void * , void * ) ;
   u32 (*get_expected_throughput)(void * ) ;
};
#line 46 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/power.h"
struct iwl_rate_info {
   u8 plcp ;
   u8 plcp_siso ;
   u8 plcp_mimo2 ;
   u8 plcp_mimo3 ;
   u8 ieee ;
   u8 prev_ieee ;
   u8 next_ieee ;
   u8 prev_rs ;
   u8 next_rs ;
   u8 prev_rs_tgg ;
   u8 next_rs_tgg ;
};
#line 265 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
enum iwl_table_type {
    LQ_NONE = 0,
    LQ_G = 1,
    LQ_A = 2,
    LQ_SISO = 3,
    LQ_MIMO2 = 4,
    LQ_MIMO3 = 5,
    LQ_MAX = 6
} ;
#line 275 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
struct iwl_rate_mcs_info {
   char mbps[12U] ;
   char mcs[12U] ;
};
#line 291 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
struct iwl_rate_scale_data {
   u64 data ;
   s32 success_counter ;
   s32 success_ratio ;
   s32 counter ;
   s32 average_tpt ;
   unsigned long stamp ;
};
#line 303 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
struct iwl_scale_tbl_info {
   enum iwl_table_type lq_type ;
   u8 ant_type ;
   u8 is_SGI ;
   u8 is_ht40 ;
   u8 is_dup ;
   u8 action ;
   u8 max_search ;
   u16 const   *expected_tpt ;
   u32 current_rate ;
   struct iwl_rate_scale_data win[13U] ;
};
#line 322 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
struct iwl_traffic_load {
   unsigned long time_stamp ;
   u32 packet_count[20U] ;
   u32 total ;
   u8 queue_count ;
   u8 head ;
};
#line 333 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
struct iwl_lq_sta {
   u8 active_tbl ;
   u8 enable_counter ;
   u8 stay_in_tbl ;
   u8 search_better_tbl ;
   s32 last_tpt ;
   u32 table_count_limit ;
   u32 max_failure_limit ;
   u32 max_success_limit ;
   u32 table_count ;
   u32 total_failed ;
   u32 total_success ;
   u64 flush_timer ;
   u8 action_counter ;
   u8 is_green ;
   u8 is_dup ;
   enum ieee80211_band band ;
   u32 supp_rates ;
   u16 active_legacy_rate ;
   u16 active_siso_rate ;
   u16 active_mimo2_rate ;
   u16 active_mimo3_rate ;
   s8 max_rate_idx ;
   u8 missed_rate_counter ;
   struct iwl_link_quality_cmd lq ;
   struct iwl_scale_tbl_info lq_info[2U] ;
   struct iwl_traffic_load load[8U] ;
   u8 tx_agg_tid_en ;
   struct dentry *rs_sta_dbgfs_scale_table_file ;
   struct dentry *rs_sta_dbgfs_stats_table_file ;
   struct dentry *rs_sta_dbgfs_rate_scale_data_file ;
   struct dentry *rs_sta_dbgfs_tx_agg_tid_en_file ;
   u32 dbg_fixed_rate ;
   struct iwl_priv *drv ;
   int last_txrate_idx ;
   u32 last_rate_n_flags ;
   u8 is_agg ;
   u8 last_bt_traffic ;
};
#line 200 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_station_priv {
   struct iwl_rxon_context *ctx ;
   struct iwl_lq_sta lq_sta ;
   atomic_t pending_frames ;
   bool client ;
   bool asleep ;
   u8 max_agg_bufsize ;
   u8 sta_id ;
};
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 500 "include/linux/debugfs.h"
struct nl80211_sta_flag_update {
   __u32 mask ;
   __u32 set ;
};
#line 2524 "./include/uapi/linux/nl80211.h"
enum nl80211_mesh_power_mode {
    NL80211_MESH_POWER_UNKNOWN = 0,
    NL80211_MESH_POWER_ACTIVE = 1,
    NL80211_MESH_POWER_LIGHT_SLEEP = 2,
    NL80211_MESH_POWER_DEEP_SLEEP = 3,
    __NL80211_MESH_POWER_AFTER_LAST = 4,
    NL80211_MESH_POWER_MAX = 3
} ;
#line 2600
enum nl80211_channel_type {
    NL80211_CHAN_NO_HT = 0,
    NL80211_CHAN_HT20 = 1,
    NL80211_CHAN_HT40MINUS = 2,
    NL80211_CHAN_HT40PLUS = 3
} ;
#line 3559
enum nl80211_txrate_gi {
    NL80211_TXRATE_DEFAULT_GI = 0,
    NL80211_TXRATE_FORCE_SGI = 1,
    NL80211_TXRATE_FORCE_LGI = 2
} ;
#line 561 "include/net/cfg80211.h"
struct survey_info {
   struct ieee80211_channel *channel ;
   u64 time ;
   u64 time_busy ;
   u64 time_ext_busy ;
   u64 time_rx ;
   u64 time_tx ;
   u64 time_scan ;
   u32 filled ;
   s8 noise ;
};
#line 914 "include/net/cfg80211.h"
struct rate_info {
   u8 flags ;
   u8 mcs ;
   u16 legacy ;
   u8 nss ;
   u8 bw ;
};
#line 964 "include/net/cfg80211.h"
struct sta_bss_parameters {
   u8 flags ;
   u8 dtim_period ;
   u16 beacon_interval ;
};
#line 989 "include/net/cfg80211.h"
struct cfg80211_tid_stats {
   u32 filled ;
   u64 rx_msdu ;
   u64 tx_msdu ;
   u64 tx_msdu_retries ;
   u64 tx_msdu_failed ;
};
#line 1007 "include/net/cfg80211.h"
struct station_info {
   u32 filled ;
   u32 connected_time ;
   u32 inactive_time ;
   u64 rx_bytes ;
   u64 tx_bytes ;
   u16 llid ;
   u16 plid ;
   u8 plink_state ;
   s8 signal ;
   s8 signal_avg ;
   u8 chains ;
   s8 chain_signal[4U] ;
   s8 chain_signal_avg[4U] ;
   struct rate_info txrate ;
   struct rate_info rxrate ;
   u32 rx_packets ;
   u32 tx_packets ;
   u32 tx_retries ;
   u32 tx_failed ;
   u32 rx_dropped_misc ;
   struct sta_bss_parameters bss_param ;
   struct nl80211_sta_flag_update sta_flags ;
   int generation ;
   u8 const   *assoc_req_ies ;
   size_t assoc_req_ies_len ;
   u32 beacon_loss_count ;
   s64 t_offset ;
   enum nl80211_mesh_power_mode local_pm ;
   enum nl80211_mesh_power_mode peer_pm ;
   enum nl80211_mesh_power_mode nonpeer_pm ;
   u32 expected_throughput ;
   u64 rx_beacon ;
   u8 rx_beacon_signal_avg ;
   struct cfg80211_tid_stats pertid[17U] ;
};
#line 1882 "include/net/cfg80211.h"
struct __anonstruct_control_365 {
   u32 legacy ;
   u8 ht_mcs[10U] ;
   u16 vht_mcs[8U] ;
   enum nl80211_txrate_gi gi ;
};
#line 1882 "include/net/cfg80211.h"
struct cfg80211_bitrate_mask {
   struct __anonstruct_control_365 control[3U] ;
};
#line 2025 "include/net/cfg80211.h"
struct cfg80211_wowlan_nd_match {
   struct cfg80211_ssid ssid ;
   int n_channels ;
   u32 channels[] ;
};
#line 2040 "include/net/cfg80211.h"
struct cfg80211_wowlan_nd_info {
   int n_matches ;
   struct cfg80211_wowlan_nd_match *matches[] ;
};
#line 2054 "include/net/cfg80211.h"
struct cfg80211_wowlan_wakeup {
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   bool packet_80211 ;
   bool tcp_match ;
   bool tcp_connlost ;
   bool tcp_nomoretokens ;
   s32 pattern_idx ;
   u32 packet_present_len ;
   u32 packet_len ;
   void const   *packet ;
   struct cfg80211_wowlan_nd_info *net_detect ;
};
#line 2086 "include/net/cfg80211.h"
struct cfg80211_gtk_rekey_data {
   u8 const   *kek ;
   u8 const   *kck ;
   u8 const   *replay_ctr ;
};
#line 5227 "include/net/cfg80211.h"
struct ieee80211_tx_queue_params {
   u16 txop ;
   u16 cw_min ;
   u16 cw_max ;
   u8 aifs ;
   bool acm ;
   bool uapsd ;
};
#line 172 "include/net/mac80211.h"
struct ieee80211_low_level_stats {
   unsigned int dot11ACKFailureCount ;
   unsigned int dot11RTSFailureCount ;
   unsigned int dot11FCSErrorCount ;
   unsigned int dot11RTSSuccessCount ;
};
#line 224
enum ieee80211_chanctx_switch_mode {
    CHANCTX_SWMODE_REASSIGN_VIF = 0,
    CHANCTX_SWMODE_SWAP_CONTEXTS = 1
} ;
#line 229 "include/net/mac80211.h"
struct ieee80211_vif_chanctx_switch {
   struct ieee80211_vif *vif ;
   struct ieee80211_chanctx_conf *old_ctx ;
   struct ieee80211_chanctx_conf *new_ctx ;
};
#line 287
enum ieee80211_event_type {
    RSSI_EVENT = 0,
    MLME_EVENT = 1,
    BAR_RX_EVENT = 2,
    BA_FRAME_TIMEOUT = 3
} ;
#line 294
enum ieee80211_rssi_event_data {
    RSSI_EVENT_HIGH = 0,
    RSSI_EVENT_LOW = 1
} ;
#line 299 "include/net/mac80211.h"
struct ieee80211_rssi_event {
   enum ieee80211_rssi_event_data data ;
};
#line 369
enum ieee80211_mlme_event_data {
    AUTH_EVENT = 0,
    ASSOC_EVENT = 1,
    DEAUTH_RX_EVENT = 2,
    DEAUTH_TX_EVENT = 3
} ;
#line 376
enum ieee80211_mlme_event_status {
    MLME_SUCCESS = 0,
    MLME_DENIED = 1,
    MLME_TIMEOUT = 2
} ;
#line 382 "include/net/mac80211.h"
struct ieee80211_mlme_event {
   enum ieee80211_mlme_event_data data ;
   enum ieee80211_mlme_event_status status ;
   u16 reason ;
};
#line 407 "include/net/mac80211.h"
struct ieee80211_ba_event {
   struct ieee80211_sta *sta ;
   u16 tid ;
   u16 ssn ;
};
#line 419 "include/net/mac80211.h"
union __anonunion_u_367 {
   struct ieee80211_rssi_event rssi ;
   struct ieee80211_mlme_event mlme ;
   struct ieee80211_ba_event ba ;
};
#line 419 "include/net/mac80211.h"
struct ieee80211_event {
   enum ieee80211_event_type type ;
   union __anonunion_u_367 u ;
};
#line 896 "include/net/mac80211.h"
struct ieee80211_scan_ies {
   u8 const   *ies[3U] ;
   size_t len[3U] ;
   u8 const   *common_ies ;
   size_t common_ie_len ;
};
#line 1506 "include/net/mac80211.h"
struct __anonstruct_tkip_376 {
   u32 iv32 ;
   u16 iv16 ;
};
#line 1506 "include/net/mac80211.h"
struct __anonstruct_ccmp_377 {
   u8 pn[6U] ;
};
#line 1506 "include/net/mac80211.h"
struct __anonstruct_aes_cmac_378 {
   u8 pn[6U] ;
};
#line 1506 "include/net/mac80211.h"
struct __anonstruct_aes_gmac_379 {
   u8 pn[6U] ;
};
#line 1506 "include/net/mac80211.h"
struct __anonstruct_gcmp_380 {
   u8 pn[6U] ;
};
#line 1506 "include/net/mac80211.h"
struct __anonstruct_hw_381 {
   u8 seq[16U] ;
   u8 seq_len ;
};
#line 1506 "include/net/mac80211.h"
union __anonunion____missing_field_name_375 {
   struct __anonstruct_tkip_376 tkip ;
   struct __anonstruct_ccmp_377 ccmp ;
   struct __anonstruct_aes_cmac_378 aes_cmac ;
   struct __anonstruct_aes_gmac_379 aes_gmac ;
   struct __anonstruct_gcmp_380 gcmp ;
   struct __anonstruct_hw_381 hw ;
};
#line 1506 "include/net/mac80211.h"
struct ieee80211_key_seq {
   union __anonunion____missing_field_name_375 __annonCompField100 ;
};
#line 1577
enum set_key_cmd {
    SET_KEY = 0,
    DISABLE_KEY = 1
} ;
#line 1582
enum ieee80211_sta_state {
    IEEE80211_STA_NOTEXIST = 0,
    IEEE80211_STA_NONE = 1,
    IEEE80211_STA_AUTH = 2,
    IEEE80211_STA_ASSOC = 3,
    IEEE80211_STA_AUTHORIZED = 4
} ;
#line 1703
enum sta_notify_cmd {
    STA_NOTIFY_SLEEP = 0,
    STA_NOTIFY_AWAKE = 1
} ;
#line 1708 "include/net/mac80211.h"
struct ieee80211_tx_control {
   struct ieee80211_sta *sta ;
};
#line 1748
enum ieee80211_hw_flags {
    IEEE80211_HW_HAS_RATE_CONTROL = 0,
    IEEE80211_HW_RX_INCLUDES_FCS = 1,
    IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING = 2,
    IEEE80211_HW_SIGNAL_UNSPEC = 3,
    IEEE80211_HW_SIGNAL_DBM = 4,
    IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC = 5,
    IEEE80211_HW_SPECTRUM_MGMT = 6,
    IEEE80211_HW_AMPDU_AGGREGATION = 7,
    IEEE80211_HW_SUPPORTS_PS = 8,
    IEEE80211_HW_PS_NULLFUNC_STACK = 9,
    IEEE80211_HW_SUPPORTS_DYNAMIC_PS = 10,
    IEEE80211_HW_MFP_CAPABLE = 11,
    IEEE80211_HW_WANT_MONITOR_VIF = 12,
    IEEE80211_HW_NO_AUTO_VIF = 13,
    IEEE80211_HW_SW_CRYPTO_CONTROL = 14,
    IEEE80211_HW_SUPPORT_FAST_XMIT = 15,
    IEEE80211_HW_REPORTS_TX_ACK_STATUS = 16,
    IEEE80211_HW_CONNECTION_MONITOR = 17,
    IEEE80211_HW_QUEUE_CONTROL = 18,
    IEEE80211_HW_SUPPORTS_PER_STA_GTK = 19,
    IEEE80211_HW_AP_LINK_PS = 20,
    IEEE80211_HW_TX_AMPDU_SETUP_IN_HW = 21,
    IEEE80211_HW_SUPPORTS_RC_TABLE = 22,
    IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF = 23,
    IEEE80211_HW_TIMING_BEACON_ONLY = 24,
    IEEE80211_HW_SUPPORTS_HT_CCK_RATES = 25,
    IEEE80211_HW_CHANCTX_STA_CSA = 26,
    IEEE80211_HW_SUPPORTS_CLONED_SKBS = 27,
    IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS = 28,
    NUM_IEEE80211_HW_FLAGS = 29
} ;
#line 2070 "include/net/mac80211.h"
struct ieee80211_scan_request {
   struct ieee80211_scan_ies ies ;
   struct cfg80211_scan_request req ;
};
#line 2084 "include/net/mac80211.h"
struct ieee80211_tdls_ch_sw_params {
   struct ieee80211_sta *sta ;
   struct cfg80211_chan_def *chandef ;
   u8 action_code ;
   u32 status ;
   u32 timestamp ;
   u16 switch_time ;
   u16 switch_timeout ;
   struct sk_buff *tmpl_skb ;
   u32 ch_sw_tm_ie ;
};
#line 2194
enum ieee80211_ampdu_mlme_action {
    IEEE80211_AMPDU_RX_START = 0,
    IEEE80211_AMPDU_RX_STOP = 1,
    IEEE80211_AMPDU_TX_START = 2,
    IEEE80211_AMPDU_TX_STOP_CONT = 3,
    IEEE80211_AMPDU_TX_STOP_FLUSH = 4,
    IEEE80211_AMPDU_TX_STOP_FLUSH_CONT = 5,
    IEEE80211_AMPDU_TX_OPERATIONAL = 6
} ;
#line 2204
enum ieee80211_frame_release_type {
    IEEE80211_FRAME_RELEASE_PSPOLL = 0,
    IEEE80211_FRAME_RELEASE_UAPSD = 1
} ;
#line 2216
enum ieee80211_roc_type {
    IEEE80211_ROC_TYPE_NORMAL = 0,
    IEEE80211_ROC_TYPE_MGMT_TX = 1
} ;
#line 2221
enum ieee80211_reconfig_type {
    IEEE80211_RECONFIG_TYPE_RESTART = 0,
    IEEE80211_RECONFIG_TYPE_SUSPEND = 1
} ;
#line 2226 "include/net/mac80211.h"
struct ieee80211_ops {
   void (*tx)(struct ieee80211_hw * , struct ieee80211_tx_control * , struct sk_buff * ) ;
   int (*start)(struct ieee80211_hw * ) ;
   void (*stop)(struct ieee80211_hw * ) ;
   int (*suspend)(struct ieee80211_hw * , struct cfg80211_wowlan * ) ;
   int (*resume)(struct ieee80211_hw * ) ;
   void (*set_wakeup)(struct ieee80211_hw * , bool  ) ;
   int (*add_interface)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*change_interface)(struct ieee80211_hw * , struct ieee80211_vif * , enum nl80211_iftype  ,
                           bool  ) ;
   void (*remove_interface)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*config)(struct ieee80211_hw * , u32  ) ;
   void (*bss_info_changed)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_bss_conf * ,
                            u32  ) ;
   int (*start_ap)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*stop_ap)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   u64 (*prepare_multicast)(struct ieee80211_hw * , struct netdev_hw_addr_list * ) ;
   void (*configure_filter)(struct ieee80211_hw * , unsigned int  , unsigned int * ,
                            u64  ) ;
   int (*set_tim)(struct ieee80211_hw * , struct ieee80211_sta * , bool  ) ;
   int (*set_key)(struct ieee80211_hw * , enum set_key_cmd  , struct ieee80211_vif * ,
                  struct ieee80211_sta * , struct ieee80211_key_conf * ) ;
   void (*update_tkip_key)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_key_conf * ,
                           struct ieee80211_sta * , u32  , u16 * ) ;
   void (*set_rekey_data)(struct ieee80211_hw * , struct ieee80211_vif * , struct cfg80211_gtk_rekey_data * ) ;
   void (*set_default_unicast_key)(struct ieee80211_hw * , struct ieee80211_vif * ,
                                   int  ) ;
   int (*hw_scan)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_scan_request * ) ;
   void (*cancel_hw_scan)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*sched_scan_start)(struct ieee80211_hw * , struct ieee80211_vif * , struct cfg80211_sched_scan_request * ,
                           struct ieee80211_scan_ies * ) ;
   int (*sched_scan_stop)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*sw_scan_start)(struct ieee80211_hw * , struct ieee80211_vif * , u8 const   * ) ;
   void (*sw_scan_complete)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*get_stats)(struct ieee80211_hw * , struct ieee80211_low_level_stats * ) ;
   void (*get_key_seq)(struct ieee80211_hw * , struct ieee80211_key_conf * , struct ieee80211_key_seq * ) ;
   int (*set_frag_threshold)(struct ieee80211_hw * , u32  ) ;
   int (*set_rts_threshold)(struct ieee80211_hw * , u32  ) ;
   int (*sta_add)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ) ;
   int (*sta_remove)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ) ;
   void (*sta_add_debugfs)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                           struct dentry * ) ;
   void (*sta_remove_debugfs)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                              struct dentry * ) ;
   void (*sta_notify)(struct ieee80211_hw * , struct ieee80211_vif * , enum sta_notify_cmd  ,
                      struct ieee80211_sta * ) ;
   int (*sta_state)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                    enum ieee80211_sta_state  , enum ieee80211_sta_state  ) ;
   void (*sta_pre_rcu_remove)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ) ;
   void (*sta_rc_update)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                         u32  ) ;
   void (*sta_rate_tbl_update)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ) ;
   void (*sta_statistics)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                          struct station_info * ) ;
   int (*conf_tx)(struct ieee80211_hw * , struct ieee80211_vif * , u16  , struct ieee80211_tx_queue_params  const  * ) ;
   u64 (*get_tsf)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*set_tsf)(struct ieee80211_hw * , struct ieee80211_vif * , u64  ) ;
   void (*reset_tsf)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*tx_last_beacon)(struct ieee80211_hw * ) ;
   int (*ampdu_action)(struct ieee80211_hw * , struct ieee80211_vif * , enum ieee80211_ampdu_mlme_action  ,
                       struct ieee80211_sta * , u16  , u16 * , u8  ) ;
   int (*get_survey)(struct ieee80211_hw * , int  , struct survey_info * ) ;
   void (*rfkill_poll)(struct ieee80211_hw * ) ;
   void (*set_coverage_class)(struct ieee80211_hw * , s16  ) ;
   int (*testmode_cmd)(struct ieee80211_hw * , struct ieee80211_vif * , void * , int  ) ;
   int (*testmode_dump)(struct ieee80211_hw * , struct sk_buff * , struct netlink_callback * ,
                        void * , int  ) ;
   void (*flush)(struct ieee80211_hw * , struct ieee80211_vif * , u32  , bool  ) ;
   void (*channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_channel_switch * ) ;
   int (*set_antenna)(struct ieee80211_hw * , u32  , u32  ) ;
   int (*get_antenna)(struct ieee80211_hw * , u32 * , u32 * ) ;
   int (*remain_on_channel)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_channel * ,
                            int  , enum ieee80211_roc_type  ) ;
   int (*cancel_remain_on_channel)(struct ieee80211_hw * ) ;
   int (*set_ringparam)(struct ieee80211_hw * , u32  , u32  ) ;
   void (*get_ringparam)(struct ieee80211_hw * , u32 * , u32 * , u32 * , u32 * ) ;
   bool (*tx_frames_pending)(struct ieee80211_hw * ) ;
   int (*set_bitrate_mask)(struct ieee80211_hw * , struct ieee80211_vif * , struct cfg80211_bitrate_mask  const  * ) ;
   void (*event_callback)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_event  const  * ) ;
   void (*allow_buffered_frames)(struct ieee80211_hw * , struct ieee80211_sta * ,
                                 u16  , int  , enum ieee80211_frame_release_type  ,
                                 bool  ) ;
   void (*release_buffered_frames)(struct ieee80211_hw * , struct ieee80211_sta * ,
                                   u16  , int  , enum ieee80211_frame_release_type  ,
                                   bool  ) ;
   int (*get_et_sset_count)(struct ieee80211_hw * , struct ieee80211_vif * , int  ) ;
   void (*get_et_stats)(struct ieee80211_hw * , struct ieee80211_vif * , struct ethtool_stats * ,
                        u64 * ) ;
   void (*get_et_strings)(struct ieee80211_hw * , struct ieee80211_vif * , u32  ,
                          u8 * ) ;
   void (*mgd_prepare_tx)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*mgd_protect_tdls_discover)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*add_chanctx)(struct ieee80211_hw * , struct ieee80211_chanctx_conf * ) ;
   void (*remove_chanctx)(struct ieee80211_hw * , struct ieee80211_chanctx_conf * ) ;
   void (*change_chanctx)(struct ieee80211_hw * , struct ieee80211_chanctx_conf * ,
                          u32  ) ;
   int (*assign_vif_chanctx)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_chanctx_conf * ) ;
   void (*unassign_vif_chanctx)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_chanctx_conf * ) ;
   int (*switch_vif_chanctx)(struct ieee80211_hw * , struct ieee80211_vif_chanctx_switch * ,
                             int  , enum ieee80211_chanctx_switch_mode  ) ;
   void (*reconfig_complete)(struct ieee80211_hw * , enum ieee80211_reconfig_type  ) ;
   void (*ipv6_addr_change)(struct ieee80211_hw * , struct ieee80211_vif * , struct inet6_dev * ) ;
   void (*channel_switch_beacon)(struct ieee80211_hw * , struct ieee80211_vif * ,
                                 struct cfg80211_chan_def * ) ;
   int (*pre_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_channel_switch * ) ;
   int (*post_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*join_ibss)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*leave_ibss)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   u32 (*get_expected_throughput)(struct ieee80211_sta * ) ;
   int (*get_txpower)(struct ieee80211_hw * , struct ieee80211_vif * , int * ) ;
   int (*tdls_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                              u8  , struct cfg80211_chan_def * , struct sk_buff * ,
                              u32  ) ;
   void (*tdls_cancel_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * ,
                                      struct ieee80211_sta * ) ;
   void (*tdls_recv_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * ,
                                    struct ieee80211_tdls_ch_sw_params * ) ;
   void (*wake_tx_queue)(struct ieee80211_hw * , struct ieee80211_txq * ) ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_398___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_400___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 74 "drivers/net/wireless/iwlwifi/dvm/../iwl-notif-wait.h"
struct iwl_notification_wait {
   struct list_head list ;
   bool (*fn)(struct iwl_notif_wait_data * , struct iwl_rx_packet * , void * ) ;
   void *fn_data ;
   u8 cmds[5U] ;
   u8 n_cmds ;
   bool triggered ;
   bool aborted ;
};
#line 3819 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct tkip_sc {
   __le16 iv16 ;
   __le16 pad ;
   __le32 iv32 ;
};
#line 3830 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_tkip_rsc_tsc {
   struct tkip_sc unicast_rsc[16U] ;
   struct tkip_sc multicast_rsc[16U] ;
   struct tkip_sc tsc ;
};
#line 3836 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct aes_sc {
   __le64 pn ;
};
#line 3840 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_aes_rsc_tsc {
   struct aes_sc unicast_rsc[16U] ;
   struct aes_sc multicast_rsc[16U] ;
   struct aes_sc tsc ;
};
#line 3846 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
union iwlagn_all_tsc_rsc {
   struct iwlagn_tkip_rsc_tsc tkip ;
   struct iwlagn_aes_rsc_tsc aes ;
};
#line 3894 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_wowlan_status {
   __le64 replay_ctr ;
   __le32 rekey_status ;
   __le32 wakeup_reason ;
   u8 pattern_number ;
   u8 reserved1 ;
   __le16 qos_seq_ctr[8U] ;
   __le16 non_qos_seq_ctr ;
   __le16 reserved2 ;
   union iwlagn_all_tsc_rsc tsc_rsc ;
   __le16 reserved3 ;
};
#line 217 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
struct iwl_vif_priv {
   struct iwl_rxon_context *ctx ;
   u8 ibss_bssid_sta_id ;
};
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
struct iwl_resume_data {
   struct iwl_priv *priv ;
   struct iwlagn_wowlan_status *cmd ;
   bool valid ;
};
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
struct error_table_start {
   u32 valid ;
   u32 error_id ;
};
#line 857
enum ldv_36117 {
    NONE = 0,
    ADD = 1,
    REMOVE = 2,
    HT_RATE_INIT = 3,
    ADD_RATE_INIT = 4
} ;
#line 1434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
typedef struct ieee80211_hw *ldv_func_ret_type___12;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 471 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_alive_resp {
   u8 ucode_minor ;
   u8 ucode_major ;
   __le16 reserved1 ;
   u8 sw_rev[8U] ;
   u8 ver_type ;
   u8 ver_subtype ;
   __le16 reserved2 ;
   __le32 log_event_table_ptr ;
   __le32 error_event_table_ptr ;
   __le32 timestamp ;
   __le32 is_valid ;
};
#line 3208 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_hdr {
   u8 op_code ;
   u8 first_group ;
   u8 groups_num ;
   u8 data_valid ;
};
#line 3220 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_xtal_freq_cmd {
   struct iwl_calib_hdr hdr ;
   u8 cap_pin1 ;
   u8 cap_pin2 ;
   u8 pad[2U] ;
};
#line 3227 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_temperature_offset_cmd {
   struct iwl_calib_hdr hdr ;
   __le16 radio_sensor_offset ;
   __le16 reserved ;
};
#line 3234 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_temperature_offset_v2_cmd {
   struct iwl_calib_hdr hdr ;
   __le16 radio_sensor_offset_high ;
   __le16 radio_sensor_offset_low ;
   __le16 burntVoltageRef ;
   __le16 reserved ;
};
#line 3299 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wimax_coex_event_entry {
   u8 request_prio ;
   u8 win_medium_prio ;
   u8 reserved ;
   u8 flags ;
};
#line 3415 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wimax_coex_cmd {
   u8 flags ;
   u8 reserved[3U] ;
   struct iwl_wimax_coex_event_entry sta_prio[16U] ;
};
#line 3734 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_bt_coex_prio_table_cmd {
   u8 prio_tbl[16U] ;
};
#line 3751 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_bt_coex_prot_env_cmd {
   u8 action ;
   u8 type ;
   u8 reserved[2U] ;
};
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
struct iwl_alive_data {
   bool valid ;
   u8 subtype ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 1379 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct agg_tx_status {
   __le16 status ;
   __le16 sequence ;
};
#line 1439 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_tx_resp {
   u8 frame_count ;
   u8 bt_kill_count ;
   u8 failure_rts ;
   u8 failure_frame ;
   __le32 rate_n_flags ;
   __le16 wireless_media_time ;
   u8 pa_status ;
   u8 pa_integ_res_a[3U] ;
   u8 pa_integ_res_b[3U] ;
   u8 pa_integ_res_C[3U] ;
   __le32 tfd_info ;
   __le16 seq_ctl ;
   __le16 byte_cnt ;
   u8 tlc_info ;
   u8 ra_tid ;
   __le16 frame_ctrl ;
   struct agg_tx_status status ;
};
#line 1502 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_compressed_ba_resp {
   __le32 sta_addr_lo32 ;
   __le16 sta_addr_hi16 ;
   __le16 reserved ;
   u8 sta_id ;
   u8 tid ;
   __le16 seq_ctl ;
   __le64 bitmap ;
   __le16 scd_flow ;
   __le16 scd_ssn ;
   u8 txed ;
   u8 txed_2_done ;
   __le16 reserved1 ;
};
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
union __anonunion___u_482 {
   struct iwl_wipan_noa_data *__val ;
   char __c[1U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 346 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_tx_power_dbm_cmd {
   s8 global_lmt ;
   u8 flags ;
   s8 srv_chan_lmt ;
   u8 reserved ;
};
#line 966 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_txfifo_flush_cmd_v3 {
   __le32 queue_control ;
   __le16 flush_control ;
   __le16 reserved ;
};
#line 1013 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_txfifo_flush_cmd_v2 {
   __le16 queue_control ;
   __le16 flush_control ;
};
#line 1889 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_basic_bt_cmd {
   u8 flags ;
   u8 ledtime ;
   u8 max_kill ;
   u8 bt3_timer_t7_value ;
   __le32 kill_ack_mask ;
   __le32 kill_cts_mask ;
   u8 bt3_prio_sample_time ;
   u8 bt3_timer_t2_value ;
   __le16 bt4_reaction_time ;
   __le32 bt3_lookup_table[12U] ;
   u8 reduce_txpower ;
   u8 reserved ;
   __le16 valid ;
};
#line 1965 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_bt_cmd_v1 {
   struct iwl_basic_bt_cmd basic ;
   u8 prio_boost ;
   u8 tx_prio_boost ;
   __le16 rx_prio_boost ;
};
#line 1976 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_bt_cmd_v2 {
   struct iwl_basic_bt_cmd basic ;
   __le32 prio_boost ;
   u8 reserved ;
   u8 tx_prio_boost ;
   __le16 rx_prio_boost ;
};
#line 3487 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_bt_uart_msg {
   u8 header ;
   u8 frame1 ;
   u8 frame2 ;
   u8 frame3 ;
   u8 frame4 ;
   u8 frame5 ;
   u8 frame6 ;
   u8 frame7 ;
};
#line 3694 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_bt_coex_profile_notif {
   struct iwl_bt_uart_msg last_bt_uart_msg ;
   u8 bt_status ;
   u8 bt_traffic_load ;
   u8 bt_ci_compliance ;
   u8 reserved ;
};
#line 3768 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_d3_config_cmd {
   __le32 min_sleep_time ;
   __le32 wakeup_flags ;
};
#line 3776 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_wowlan_pattern {
   u8 mask[16U] ;
   u8 pattern[128U] ;
   u8 mask_size ;
   u8 pattern_size ;
   __le16 reserved ;
};
#line 3790 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_wowlan_patterns_cmd {
   __le32 n_patterns ;
   struct iwlagn_wowlan_pattern patterns[] ;
};
#line 3809 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_wowlan_wakeup_filter_cmd {
   __le32 enabled ;
   __le16 non_qos_seq ;
   __le16 reserved ;
   __le16 qos_seq[8U] ;
};
#line 3851 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_wowlan_rsc_tsc_params_cmd {
   union iwlagn_all_tsc_rsc all_tsc_rsc ;
};
#line 3855 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_mic_keys {
   u8 tx[8U] ;
   u8 rx_unicast[8U] ;
   u8 rx_mcast[8U] ;
};
#line 3866 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_p1k_cache {
   __le16 p1k[5U] ;
};
#line 3870 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_wowlan_tkip_params_cmd {
   struct iwlagn_mic_keys mic_keys ;
   struct iwlagn_p1k_cache tx ;
   struct iwlagn_p1k_cache rx_uni[2U] ;
   struct iwlagn_p1k_cache rx_multi[2U] ;
};
#line 3879 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_wowlan_kek_kck_material_cmd {
   u8 kck[32U] ;
   u8 kek[32U] ;
   __le16 kck_len ;
   __le16 kek_len ;
   __le64 replay_ctr ;
};
#line 908 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
struct wowlan_key_data {
   struct iwl_rxon_context *ctx ;
   struct iwlagn_wowlan_rsc_tsc_params_cmd *rsc_tsc ;
   struct iwlagn_wowlan_tkip_params_cmd *tkip ;
   u8 const   *bssid ;
   bool error ;
   bool use_rsc_tsc ;
   bool use_tkip ;
};
#line 858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
typedef bool ldv_func_ret_type___13;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 2828 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_sensitivity_cmd {
   __le16 control ;
   __le16 table[11U] ;
};
#line 3077 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_enhance_sensitivity_cmd {
   __le16 control ;
   __le16 enhance_table[23U] ;
};
#line 3248 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_chain_noise_gain_cmd {
   struct iwl_calib_hdr hdr ;
   u8 delta_gain_1 ;
   u8 delta_gain_2 ;
   u8 pad[2U] ;
};
#line 492 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
struct iwl_calib_result {
   struct list_head list ;
   size_t cmd_len ;
   struct iwl_calib_hdr hdr ;
};
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
struct statistics_general_data {
   u32 beacon_silence_rssi_a ;
   u32 beacon_silence_rssi_b ;
   u32 beacon_silence_rssi_c ;
   u32 beacon_energy_a ;
   u32 beacon_energy_b ;
   u32 beacon_energy_c ;
};
#line 259 "include/linux/timer.h"
enum hrtimer_restart;
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_386 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_388 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_394 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_396 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 1424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
typedef int ldv_func_ret_type___14;
#line 1435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
typedef int ldv_func_ret_type___15;
#line 1462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
typedef int ldv_func_ret_type___16;
#line 1489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
typedef int ldv_func_ret_type___17;
#line 1522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
typedef bool ldv_func_ret_type___18;
#line 1533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
typedef bool ldv_func_ret_type___19;
#line 1544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
typedef bool ldv_func_ret_type___20;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 936 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_add_sta_resp {
   u8 status ;
};
#line 948 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_rem_sta_resp {
   u8 status ;
};
#line 956 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_rem_sta_cmd {
   u8 num_sta ;
   u8 reserved[3U] ;
   u8 addr[6U] ;
   u8 reserved2[2U] ;
};
#line 1030 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wep_cmd {
   u8 num_keys ;
   u8 global_key_type ;
   u8 flags ;
   u8 reserved ;
   struct iwl_wep_key key[0U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 923 "include/net/mac80211.h"
struct ieee80211_rx_status;
#line 997 "include/net/mac80211.h"
struct ieee80211_rx_status {
   u64 mactime ;
   u32 device_timestamp ;
   u32 ampdu_reference ;
   u32 flag ;
   u16 freq ;
   u8 vht_flag ;
   u8 rate_idx ;
   u8 vht_nss ;
   u8 rx_flags ;
   u8 band ;
   u8 antenna ;
   s8 signal ;
   u8 chains ;
   s8 chain_signal[4U] ;
   u8 ampdu_delimiter_crc ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_387 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_389 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 485 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_error_resp {
   __le32 error_type ;
   u8 cmd_id ;
   u8 reserved1 ;
   __le16 bad_cmd_seq_num ;
   __le32 error_info ;
   __le64 timestamp ;
};
#line 720 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_csa_notification {
   __le16 band ;
   __le16 channel ;
   __le32 status ;
};
#line 1038 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_non_cfg_phy {
   __le32 non_cfg_phy[8U] ;
};
#line 1123 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_rx_mpdu_res_start {
   __le16 byte_count ;
   __le16 reserved ;
};
#line 2179 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_sleep_notification {
   u8 pm_sleep_mode ;
   u8 pm_wakeup_src ;
   __le16 reserved ;
   __le32 sleep_time ;
   __le32 tsf_low ;
   __le32 bcon_timer ;
};
#line 2217 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_card_state_notif {
   __le32 flags ;
};
#line 2477 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwlagn_beacon_notif {
   struct iwlagn_tx_resp beacon_notify_hdr ;
   __le32 low_tsf ;
   __le32 high_tsf ;
   __le32 ibss_mgr_status ;
};
#line 2613 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_rx_non_phy_bt {
   struct statistics_rx_non_phy common ;
   __le32 num_bt_kills ;
   __le32 reserved[2U] ;
};
#line 2620 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_rx {
   struct statistics_rx_phy ofdm ;
   struct statistics_rx_phy cck ;
   struct statistics_rx_non_phy general ;
   struct statistics_rx_ht_phy ofdm_ht ;
};
#line 2627 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_rx_bt {
   struct statistics_rx_phy ofdm ;
   struct statistics_rx_phy cck ;
   struct statistics_rx_non_phy_bt general ;
   struct statistics_rx_ht_phy ofdm_ht ;
};
#line 2727 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_general {
   struct statistics_general_common common ;
   __le32 reserved2 ;
   __le32 reserved3 ;
};
#line 2733 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct statistics_general_bt {
   struct statistics_general_common common ;
   struct statistics_bt_activity activity ;
   __le32 reserved2 ;
   __le32 reserved3 ;
};
#line 2765 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_notif_statistics {
   __le32 flag ;
   struct statistics_rx rx ;
   struct statistics_tx tx ;
   struct statistics_general general ;
};
#line 2790 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_bt_notif_statistics {
   __le32 flag ;
   struct statistics_rx_bt rx ;
   struct statistics_tx tx ;
   struct statistics_general_bt general ;
};
#line 2797 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_missed_beacon_notif {
   __le32 consecutive_missed_beacons ;
   __le32 total_missed_becons ;
   __le32 num_expected_beacons ;
   __le32 num_recvd_beacons ;
};
#line 3975 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wipan_noa_descriptor {
   u8 count ;
   __le32 duration ;
   __le32 interval ;
   __le32 starttime ;
};
#line 3993 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wipan_noa_attribute {
   u8 id ;
   __le16 length ;
   u8 index ;
   u8 ct_window ;
   struct iwl_wipan_noa_descriptor descr0 ;
   struct iwl_wipan_noa_descriptor descr1 ;
   u8 reserved ;
};
#line 4002 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wipan_noa_notification {
   u32 noa_active ;
   struct iwl_wipan_noa_attribute noa_attribute ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 72 "drivers/net/wireless/iwlwifi/dvm/../iwl-modparams.h"
enum iwl_power_level {
    IWL_POWER_INDEX_1 = 0,
    IWL_POWER_INDEX_2 = 1,
    IWL_POWER_INDEX_3 = 2,
    IWL_POWER_INDEX_4 = 3,
    IWL_POWER_INDEX_5 = 4,
    IWL_POWER_NUM = 5
} ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
struct iwl_power_vec_entry {
   struct iwl_powertable_cmd cmd ;
   u8 no_dtim ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 2242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_scan_channel {
   __le32 type ;
   __le16 channel ;
   u8 tx_gain ;
   u8 dsp_atten ;
   __le16 active_dwell ;
   __le16 passive_dwell ;
};
#line 2287 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_ssid_ie {
   u8 id ;
   u8 len ;
   u8 ssid[32U] ;
};
#line 2308 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_scan_cmd {
   __le16 len ;
   u8 scan_flags ;
   u8 channel_count ;
   __le16 quiet_time ;
   __le16 quiet_plcp_th ;
   __le16 good_CRC_th ;
   __le16 rx_chain ;
   __le32 max_out_time ;
   __le32 suspend_time ;
   __le32 flags ;
   __le32 filter_flags ;
   struct iwl_tx_cmd tx_cmd ;
   struct iwl_ssid_ie direct_scan[20U] ;
   u8 data[0U] ;
};
#line 2412 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_scanreq_notification {
   __le32 status ;
};
#line 2424 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_scanstart_notification {
   __le32 tsf_low ;
   __le32 tsf_high ;
   __le32 beacon_timer ;
   u8 channel ;
   u8 band ;
   u8 reserved[2U] ;
   __le32 status ;
};
#line 2437 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_scanresults_notification {
   u8 channel ;
   u8 band ;
   u8 probe_status ;
   u8 num_probe_not_sent ;
   __le32 tsf_low ;
   __le32 tsf_high ;
   __le32 statistics[1U] ;
};
#line 2460 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_scancomplete_notification {
   u8 scanned_channels ;
   u8 status ;
   u8 bt_status ;
   u8 last_channel ;
   __le32 tsf_low ;
   __le32 tsf_high ;
};
#line 1257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
typedef bool ldv_func_ret_type___21;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 641 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_rxon_assoc_cmd {
   __le32 flags ;
   __le32 filter_flags ;
   u8 ofdm_basic_rates ;
   u8 cck_basic_rates ;
   __le16 reserved1 ;
   u8 ofdm_ht_single_stream_basic_rates ;
   u8 ofdm_ht_dual_stream_basic_rates ;
   u8 ofdm_ht_triple_stream_basic_rates ;
   u8 reserved2 ;
   __le16 rx_chain_select_flags ;
   __le16 acquisition_data ;
   __le32 reserved3 ;
};
#line 3242 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_calib_chain_noise_reset_cmd {
   struct iwl_calib_hdr hdr ;
   u8 data[0U] ;
};
#line 3912 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wipan_slot {
   __le16 width ;
   u8 type ;
   u8 reserved ;
};
#line 3934 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_wipan_params_cmd {
   __le16 flags ;
   u8 reserved ;
   u8 num_slots ;
   struct iwl_wipan_slot slots[10U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_383 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_385 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 675 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl5000_channel_switch_cmd {
   u8 band ;
   u8 expect_beacon ;
   __le16 channel ;
   __le32 rxon_flags ;
   __le32 rxon_filter_flags ;
   __le32 switch_time ;
   __le32 reserved[2U][26U] ;
};
#line 699 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl6000_channel_switch_cmd {
   u8 band ;
   u8 expect_beacon ;
   __le16 channel ;
   __le32 rxon_flags ;
   __le32 rxon_filter_flags ;
   __le32 switch_time ;
   __le32 reserved[3U][26U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 3518 "include/net/mac80211.h"
struct ieee80211_tpt_blink {
   int throughput ;
   int blink_time ;
};
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_390___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_392___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_398___1 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 69 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_400___1 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 3256 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/commands.h"
struct iwl_led_cmd {
   __le32 interval ;
   u8 id ;
   u8 off ;
   u8 on ;
   u8 reserved ;
};
#line 243 "include/linux/timer.h"
enum hrtimer_restart;
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_386___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
union __anonunion___u_388___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 201 "include/linux/compiler.h"
__inline static void __read_once_size(void const volatile   *p , void *res , int size ) 
{ 


  {
#line 203
  switch (size) {
  case 1: 
#line 204
  *((__u8 *)res) = *((__u8 volatile   *)p);
#line 204
  goto ldv_880;
  case 2: 
#line 205
  *((__u16 *)res) = *((__u16 volatile   *)p);
#line 205
  goto ldv_880;
  case 4: 
#line 206
  *((__u32 *)res) = *((__u32 volatile   *)p);
#line 206
  goto ldv_880;
  case 8: 
#line 207
  *((__u64 *)res) = *((__u64 volatile   *)p);
#line 207
  goto ldv_880;
  default: 
#line 209
  __asm__  volatile   ("": : : "memory");
#line 210
  __builtin_memcpy(res, (void const   *)p, (unsigned long )size);
#line 211
  __asm__  volatile   ("": : : "memory");
  }
  ldv_880: ;
#line 214
  return;
}
}
#line 369 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 409
extern int scnprintf(char * , size_t  , char const   *  , ...) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4801: ;
#line 831
    goto ldv_4801;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 151 "./arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 153
  return ((flags & 512UL) == 0UL);
}
}
#line 15 "./arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5596: ;
#line 157
  return (__ret + i);
}
}
#line 167 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
#line 169
  tmp = atomic_add_return(- i, v);
#line 169
  return (tmp);
}
}
#line 10 "include/linux/debug_locks.h"
extern int debug_locks ;
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 342
extern int lock_is_held(struct lockdep_map * ) ;
#line 545
extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 173
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_13(struct mutex *ldv_func_arg1 ) ;
#line 178
extern void mutex_unlock(struct mutex * ) ;
#line 181
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 21
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_19(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_21(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_28(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
#line 58
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
#line 67
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 71
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 80
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 81
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 84
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 93
void ldv_mutex_lock_mutex_of_iwl_priv(struct mutex *lock ) ;
#line 97
void ldv_mutex_unlock_mutex_of_iwl_priv(struct mutex *lock ) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6544;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6544;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6544;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6544;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6544: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6601;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6601;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6601;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6601;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6601: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6613;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6613;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6613;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6613;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6613: ;
#line 79
  return;
}
}
#line 97 "include/linux/jump_label.h"
__inline static int static_key_count(struct static_key *key ) 
{ 
  int tmp ;

  {
#line 99
  tmp = atomic_read((atomic_t const   *)(& key->enabled));
#line 99
  return (tmp);
}
}
#line 162 "include/linux/jump_label.h"
__inline static bool static_key_false(struct static_key *key ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 164
  tmp = static_key_count(key);
#line 164
  tmp___0 = ldv__builtin_expect(tmp > 0, 0L);
#line 164
  if (tmp___0 != 0L) {
#line 165
    return (1);
  } else {

  }
#line 166
  return (0);
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 30 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 42
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField17.rlock);
}
}
#line 315 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 317
  _raw_spin_lock_bh(& lock->__annonCompField17.rlock);
#line 318
  return;
}
}
#line 360 "include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 362
  _raw_spin_unlock_bh(& lock->__annonCompField17.rlock);
#line 363
  return;
}
}
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 284
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 292
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_23(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_24(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_34(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_35(struct timer_list *ldv_func_arg1 ) ;
#line 104 "include/linux/rcutree.h"
extern bool rcu_is_watching(void) ;
#line 437 "include/linux/rcupdate.h"
extern bool rcu_lockdep_current_cpu_online(void) ;
#line 459
extern struct lockdep_map rcu_sched_lock_map ;
#line 461
extern int debug_lockdep_rcu_enabled(void) ;
#line 498 "include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 500
  lockdep_opinion = 0;
#line 502
  tmp = debug_lockdep_rcu_enabled();
#line 502
  if (tmp == 0) {
#line 503
    return (1);
  } else {

  }
#line 504
  tmp___0 = rcu_is_watching();
#line 504
  if (tmp___0) {
#line 504
    tmp___1 = 0;
  } else {
#line 504
    tmp___1 = 1;
  }
#line 504
  if (tmp___1) {
#line 505
    return (0);
  } else {

  }
#line 506
  tmp___2 = rcu_lockdep_current_cpu_online();
#line 506
  if (tmp___2) {
#line 506
    tmp___3 = 0;
  } else {
#line 506
    tmp___3 = 1;
  }
#line 506
  if (tmp___3) {
#line 507
    return (0);
  } else {

  }
#line 508
  if (debug_locks != 0) {
#line 509
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
#line 510
  if (lockdep_opinion != 0) {
#line 510
    tmp___6 = 1;
  } else {
#line 510
    tmp___4 = preempt_count();
#line 510
    if (tmp___4 != 0) {
#line 510
      tmp___6 = 1;
    } else {
#line 510
      _flags = arch_local_save_flags();
#line 510
      tmp___5 = arch_irqs_disabled_flags(_flags);
#line 510
      if (tmp___5 != 0) {
#line 510
        tmp___6 = 1;
      } else {
#line 510
        tmp___6 = 0;
      }
    }
  }
#line 510
  return (tmp___6);
}
}
#line 969 "include/linux/rcupdate.h"
__inline static void rcu_read_lock_sched_notrace(void) 
{ 


  {
#line 971
  __preempt_count_add(1);
#line 971
  __asm__  volatile   ("": : : "memory");
#line 973
  return;
}
}
#line 990 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock_sched_notrace(void) 
{ 


  {
#line 993
  __asm__  volatile   ("": : : "memory");
#line 993
  __preempt_count_sub(1);
#line 994
  return;
}
}
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_36(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_39(struct workqueue_struct *ldv_func_arg1 ) ;
#line 437
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 441
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 445
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 447
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 451
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 460
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 463
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
void ldv_flush_workqueue_38(struct workqueue_struct *ldv_func_arg1 ) ;
#line 476
extern bool cancel_work_sync(struct work_struct * ) ;
#line 479
bool ldv_cancel_work_sync_30(struct work_struct *ldv_func_arg1 ) ;
#line 483
bool ldv_cancel_work_sync_31(struct work_struct *ldv_func_arg1 ) ;
#line 487
bool ldv_cancel_work_sync_32(struct work_struct *ldv_func_arg1 ) ;
#line 491
bool ldv_cancel_work_sync_33(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_5(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 291
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_9_2  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_47  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_20  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_12_3  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_ucode_rx_stats_ops_group1  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct ieee80211_sta *rs_ops_group1  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_16_0  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_1_1  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_txfifo_flush_ops_group1  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_14_2  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_9_3  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_reply_tx_error_ops_group2  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_echo_test_ops_group2  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_14_0  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_13_3  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_54  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_14  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_37  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_17  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_51  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_10_1  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_7_2  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_66  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_19  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_4_3  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_27  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_9  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_missed_beacon_ops_group1  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_13_0  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_7_1  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_15_3  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_protection_mode_ops_group1  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *rs_sta_dbgfs_scale_table_ops_group1  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_42  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_3_3  ;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_15_0  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_11_0  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_4_0  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_6050_cfg_group0  ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_6005_cfg_group0  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_7  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_18_3  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_nvm_ops_group2  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_55  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_wowlan_sram_ops_group2  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_disable_ht40_ops_group1  ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_1_3  ;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_4_0  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_12_3  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_7_2  ;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_plcp_delta_ops_group1  ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_64  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_26  ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_power_save_status_ops_group2  ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_13_1  ;
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_28  ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_rxon_flags_ops_group2  ;
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_7_0  ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_sram_ops_group1  ;
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_18_0  ;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_op_mode *iwl_dvm_ops_group0  ;
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_16_1  ;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_6_0  ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_ucode_tx_stats_ops_group2  ;
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_current_sleep_command_ops_group1  ;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_8_3  ;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_thermal_throttling_ops_group2  ;
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_58  ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_15_1  ;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_sleep_level_override_ops_group2  ;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_13_2  ;
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_wowlan_sram_ops_group1  ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_14_3  ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_5_2  ;
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_7_1  ;
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_31  ;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_nvm_ops_group1  ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_6_2  ;
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_echo_test_ops_group1  ;
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_68  ;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_16_3  ;
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_2_1  ;
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_8  ;
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_46  ;
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_sleep_level_override_ops_group1  ;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_15  ;
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_log_event_ops_group2  ;
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_txfifo_flush_ops_group2  ;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_8_0  ;
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_rf_reset_ops_group2  ;
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_14_2  ;
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_21  ;
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_33  ;
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_13_2  ;
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_8_0  ;
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_temperature_ops_group2  ;
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_ucode_general_stats_ops_group2  ;
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct dentry *rs_ops_group2  ;
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_17_3  ;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_15_0  ;
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_69  ;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_18_1  ;
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_14_3  ;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_protection_mode_ops_group2  ;
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_rxon_flags_ops_group1  ;
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_stations_ops_group2  ;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_3_0  ;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_11_1  ;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_10_0  ;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_65  ;
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_6000_cfg_group0  ;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_12_2  ;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_15_3  ;
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_fw_restart_ops_group1  ;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_5000_cfg_group0  ;
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_62  ;
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_41  ;
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_5_3  ;
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_bt_traffic_ops_group2  ;
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_17_2  ;
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_40  ;
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_105_cfg_group0  ;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_6_1  ;
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_thermal_throttling_ops_group1  ;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_6030_cfg_group0  ;
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_10  ;
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_7_0  ;
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_16_2  ;
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_12_0  ;
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_4_1  ;
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_power_save_status_ops_group1  ;
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_63  ;
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_10_1  ;
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *rs_sta_dbgfs_rate_scale_data_ops_group1  ;
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_7_3  ;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_stations_ops_group1  ;
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_2  ;
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_25  ;
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_2_0  ;
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_10_0  ;
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_2030_cfg_group0  ;
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_ucode_general_stats_ops_group1  ;
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_18_2  ;
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_4_2  ;
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_11  ;
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_1_2  ;
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_5150_cfg_group0  ;
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_18  ;
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_5_0  ;
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_17_3  ;
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_9_1  ;
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_2_2  ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_current_sleep_command_ops_group2  ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_32  ;
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_11_3  ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_ucode_bt_stats_ops_group1  ;
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_11_2  ;
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_30  ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_fw_restart_ops_group2  ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_8_1  ;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_0  ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_45  ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_rx_handlers_ops_group2  ;
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_12  ;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_13_1  ;
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_22  ;
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_29  ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_8_1  ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_ucode_rx_stats_ops_group2  ;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_61  ;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_6_0  ;
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_9_0  ;
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_bt_traffic_ops_group1  ;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_6_1  ;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ref_cnt  ;
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_channels_ops_group1  ;
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_10_3  ;
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_8_3  ;
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_16_2  ;
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_23  ;
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_15_2  ;
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_17_1  ;
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_calib_disabled_ops_group2  ;
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_59  ;
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_6  ;
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_5_0  ;
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_15_1  ;
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_50  ;
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_4_2  ;
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_16_1  ;
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_clear_ucode_statistics_ops_group1  ;
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_17_2  ;
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_ucode_tracing_ops_group2  ;
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_sensitivity_ops_group2  ;
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *rs_sta_dbgfs_rate_scale_data_ops_group2  ;
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_44  ;
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_channels_ops_group2  ;
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_38  ;
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_18_3  ;
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_39  ;
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_log_event_ops_group1  ;
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_5_1  ;
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_56  ;
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_3  ;
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_12_1  ;
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_status_ops_group1  ;
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_52  ;
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_11_0  ;
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_1_0  ;
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_16_3  ;
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_chain_noise_ops_group1  ;
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_11_2  ;
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_1000_cfg_group0  ;
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_4  ;
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_9_0  ;
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_temperature_ops_group1  ;
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_9_3  ;
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_10_2  ;
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_60  ;
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_36  ;
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_9_2  ;
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_13_0  ;
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_6_3  ;
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_48  ;
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_5_2  ;
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_9_1  ;
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_15_2  ;
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_5  ;
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_5_3  ;
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_14_1  ;
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_13  ;
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_17_0  ;
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_qos_ops_group2  ;
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_18_2  ;
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *rs_sta_dbgfs_stats_table_ops_group1  ;
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_17_0  ;
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_3_2  ;
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct ieee80211_hw *iwlagn_hw_ops_group0  ;
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_13_3  ;
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_18_0  ;
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_plcp_delta_ops_group2  ;
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_11_1  ;
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_status_ops_group2  ;
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_49  ;
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_rx_handlers_ops_group1  ;
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_24  ;
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_7_3  ;
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_rxon_filter_flags_ops_group2  ;
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_12_0  ;
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_14_0  ;
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_clear_ucode_statistics_ops_group2  ;
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_ucode_tracing_ops_group1  ;
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_1  ;
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_sram_ops_group2  ;
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *rs_sta_dbgfs_scale_table_ops_group2  ;
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_12_1  ;
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct iwl_priv *iwl_dvm_2000_cfg_group0  ;
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_6_2  ;
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_10_2  ;
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_qos_ops_group1  ;
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct ieee80211_supported_band *rs_ops_group0  ;
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_8_2  ;
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_18_1  ;
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_4_3  ;
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_3_1  ;
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_16  ;
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_12_2  ;
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_43  ;
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_5_1  ;
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct timer_list *ldv_timer_list_16_0  ;
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_57  ;
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_6_3  ;
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_sensitivity_ops_group1  ;
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_calib_disabled_ops_group1  ;
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_missed_beacon_ops_group2  ;
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_67  ;
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_53  ;
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_ucode_bt_stats_ops_group2  ;
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_timer_17_1  ;
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_rf_reset_ops_group1  ;
#line 370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_rxon_filter_flags_ops_group1  ;
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_14_1  ;
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_8_2  ;
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_4_1  ;
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_34  ;
#line 376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_ucode_tx_stats_ops_group1  ;
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_disable_ht40_ops_group2  ;
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_2_3  ;
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct inode *iwl_dbgfs_reply_tx_error_ops_group1  ;
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_work_10_3  ;
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *iwl_dbgfs_chain_noise_ops_group2  ;
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct file *rs_sta_dbgfs_stats_table_ops_group2  ;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_state_variable_35  ;
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
struct work_struct *ldv_work_struct_11_3  ;
#line 385
void ldv_file_operations_20(void) ;
#line 386
void activate_work_5(struct work_struct *work , int state ) ;
#line 387
void ldv_initialize_iwl_dvm_cfg_62(void) ;
#line 388
void ldv_file_operations_26(void) ;
#line 389
void ldv_file_operations_66(void) ;
#line 391
void ldv_file_operations_41(void) ;
#line 392
void timer_init_17(void) ;
#line 393
void disable_suitable_timer_16(struct timer_list *timer ) ;
#line 395
void work_init_9(void) ;
#line 396
void work_init_5(void) ;
#line 398
void ldv_file_operations_40(void) ;
#line 399
void call_and_disable_all_4(int state ) ;
#line 400
void ldv_initialize_iwl_dvm_cfg_63(void) ;
#line 402
void ldv_initialize_iwl_dvm_cfg_56(void) ;
#line 403
void activate_work_1(struct work_struct *work , int state ) ;
#line 404
int reg_timer_18(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 405
void ldv_initialize_iwl_dvm_cfg_54(void) ;
#line 406
void call_and_disable_work_3(struct work_struct *work ) ;
#line 407
void activate_pending_timer_18(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 409
void disable_work_7(struct work_struct *work ) ;
#line 410
void disable_work_3(struct work_struct *work ) ;
#line 413
void ldv_initialize_iwl_dvm_cfg_59(void) ;
#line 414
void ldv_file_operations_24(void) ;
#line 416
void ldv_file_operations_50(void) ;
#line 417
void work_init_1(void) ;
#line 419
void ldv_initialize_iwl_dvm_cfg_57(void) ;
#line 421
void invoke_work_4(void) ;
#line 424
void ldv_file_operations_51(void) ;
#line 426
void activate_suitable_timer_15(struct timer_list *timer , unsigned long data ) ;
#line 427
void activate_work_6(struct work_struct *work , int state ) ;
#line 428
void ldv_file_operations_34(void) ;
#line 429
void ldv_file_operations_39(void) ;
#line 430
void disable_suitable_timer_18(struct timer_list *timer ) ;
#line 432
int reg_timer_15(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 433
void ldv_initialize_iwl_op_mode_ops_69(void) ;
#line 434
void timer_init_16(void) ;
#line 435
void work_init_8(void) ;
#line 436
void activate_work_2(struct work_struct *work , int state ) ;
#line 437
void work_init_14(void) ;
#line 440
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 441
void ldv_file_operations_31(void) ;
#line 443
void work_init_10(void) ;
#line 444
void invoke_work_5(void) ;
#line 445
void timer_init_18(void) ;
#line 448
void ldv_file_operations_29(void) ;
#line 449
void disable_work_4(struct work_struct *work ) ;
#line 450
void work_init_13(void) ;
#line 451
void work_init_4(void) ;
#line 452
void ldv_file_operations_42(void) ;
#line 455
void invoke_work_1(void) ;
#line 456
void ldv_initialize_iwl_dvm_cfg_61(void) ;
#line 457
void activate_suitable_timer_16(struct timer_list *timer , unsigned long data ) ;
#line 459
void ldv_file_operations_33(void) ;
#line 462
void call_and_disable_all_3(int state ) ;
#line 463
void ldv_file_operations_48(void) ;
#line 464
void call_and_disable_work_4(struct work_struct *work ) ;
#line 465
void ldv_file_operations_30(void) ;
#line 466
void ldv_file_operations_23(void) ;
#line 468
void ldv_file_operations_19(void) ;
#line 469
void ldv_file_operations_49(void) ;
#line 470
void work_init_3(void) ;
#line 471
void call_and_disable_all_7(int state ) ;
#line 473
void ldv_file_operations_32(void) ;
#line 474
void call_and_disable_work_1(struct work_struct *work ) ;
#line 476
void invoke_work_6(void) ;
#line 477
void work_init_11(void) ;
#line 480
void call_and_disable_all_2(int state ) ;
#line 481
void ldv_file_operations_68(void) ;
#line 484
void activate_work_3(struct work_struct *work , int state ) ;
#line 485
void choose_timer_15(void) ;
#line 486
void ldv_file_operations_25(void) ;
#line 487
void ldv_file_operations_45(void) ;
#line 488
void activate_pending_timer_16(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 489
void ldv_file_operations_28(void) ;
#line 490
void work_init_7(void) ;
#line 491
void ldv_file_operations_43(void) ;
#line 493
void disable_work_5(struct work_struct *work ) ;
#line 494
void ldv_file_operations_38(void) ;
#line 495
void timer_init_15(void) ;
#line 496
void ldv_file_operations_22(void) ;
#line 498
void ldv_file_operations_35(void) ;
#line 500
void disable_work_1(struct work_struct *work ) ;
#line 501
void call_and_disable_all_6(int state ) ;
#line 502
void ldv_initialize_iwl_dvm_cfg_55(void) ;
#line 504
int reg_timer_16(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 505
void call_and_disable_work_5(struct work_struct *work ) ;
#line 506
void ldv_timer_15(int state , struct timer_list *timer ) ;
#line 507
void ldv_file_operations_46(void) ;
#line 509
void invoke_work_2(void) ;
#line 510
void ldv_initialize_iwl_dvm_cfg_60(void) ;
#line 511
void choose_timer_16(void) ;
#line 512
void ldv_initialize_iwl_dvm_cfg_58(void) ;
#line 515
void ldv_initialize_rate_control_ops_65(void) ;
#line 516
void activate_work_4(struct work_struct *work , int state ) ;
#line 517
void call_and_disable_all_5(int state ) ;
#line 519
void ldv_timer_16(int state , struct timer_list *timer ) ;
#line 520
void work_init_2(void) ;
#line 521
void call_and_disable_all_1(int state ) ;
#line 522
void ldv_file_operations_44(void) ;
#line 525
void disable_work_6(struct work_struct *work ) ;
#line 526
void work_init_6(void) ;
#line 527
void ldv_file_operations_37(void) ;
#line 528
void work_init_12(void) ;
#line 529
void ldv_file_operations_67(void) ;
#line 530
void disable_suitable_timer_15(struct timer_list *timer ) ;
#line 532
void ldv_file_operations_21(void) ;
#line 533
void ldv_file_operations_36(void) ;
#line 535
void activate_work_7(struct work_struct *work , int state ) ;
#line 537
void ldv_file_operations_27(void) ;
#line 539
void disable_work_2(struct work_struct *work ) ;
#line 540
void invoke_work_3(void) ;
#line 543
void call_and_disable_work_6(struct work_struct *work ) ;
#line 545
void ldv_file_operations_52(void) ;
#line 546
void call_and_disable_work_2(struct work_struct *work ) ;
#line 547
void ldv_file_operations_47(void) ;
#line 548
void ldv_file_operations_53(void) ;
#line 775 "include/linux/skbuff.h"
extern void consume_skb(struct sk_buff * ) ;
#line 3281 "include/net/cfg80211.h"
__inline static void set_wiphy_dev(struct wiphy *wiphy , struct device *dev ) 
{ 


  {
#line 3283
  wiphy->dev.parent = dev;
#line 3284
  return;
}
}
#line 4257
extern void wiphy_rfkill_set_hw_state(struct wiphy * , bool  ) ;
#line 918 "include/net/mac80211.h"
__inline static struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb ) 
{ 


  {
#line 920
  return ((struct ieee80211_tx_info *)(& skb->cb));
}
}
#line 2131 "include/net/mac80211.h"
__inline static void SET_IEEE80211_DEV(struct ieee80211_hw *hw , struct device *dev ) 
{ 


  {
#line 2133
  set_wiphy_dev(hw->wiphy, dev);
#line 2134
  return;
}
}
#line 2182
extern void ieee80211_free_txskb(struct ieee80211_hw * , struct sk_buff * ) ;
#line 3682
extern void ieee80211_free_hw(struct ieee80211_hw * ) ;
#line 3685
void ldv_ieee80211_free_hw_37(struct ieee80211_hw *ldv_func_arg1 ) ;
#line 3689
void ldv_ieee80211_free_hw_40(struct ieee80211_hw *ldv_func_arg1 ) ;
#line 3696
extern void ieee80211_restart_hw(struct ieee80211_hw * ) ;
#line 3709
extern void ieee80211_napi_add(struct ieee80211_hw * , struct napi_struct * , struct net_device * ,
                               int (*)(struct napi_struct * , int  ) , int  ) ;
#line 4020
extern struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw * , struct ieee80211_vif * ,
                                                u16 * , u16 * ) ;
#line 4033 "include/net/mac80211.h"
__inline static struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw , struct ieee80211_vif *vif ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4036
  tmp = ieee80211_beacon_get_tim(hw, vif, (u16 *)0U, (u16 *)0U);
#line 4036
  return (tmp);
}
}
#line 4466
extern void ieee80211_wake_queue(struct ieee80211_hw * , int  ) ;
#line 4475
extern void ieee80211_stop_queue(struct ieee80211_hw * , int  ) ;
#line 4495
extern void ieee80211_stop_queues(struct ieee80211_hw * ) ;
#line 4503
extern void ieee80211_wake_queues(struct ieee80211_hw * ) ;
#line 71 "drivers/net/wireless/iwlwifi/dvm/../iwl-modparams.h"
extern struct iwl_mod_params iwlwifi_mod_params ;
#line 35 "drivers/net/wireless/iwlwifi/dvm/../iwl-debug.h"
__inline static bool iwl_have_debug_level(u32 level ) 
{ 


  {
#line 38
  return ((iwlwifi_mod_params.debug_level & level) != 0U);
}
}
#line 44
extern void __iwl_err(struct device * , bool  , bool  , char const   *  , ...) ;
#line 46
extern void __iwl_warn(struct device * , char const   *  , ...) ;
#line 47
extern void __iwl_info(struct device * , char const   *  , ...) ;
#line 78
extern void __iwl_dbg(struct device * , u32  , bool  , char const   * , char const   * 
                      , ...) ;
#line 145 "drivers/net/wireless/iwlwifi/dvm/../iwl-config.h"
__inline static u8 num_of_ant(u8 mask ) 
{ 


  {
#line 147
  return ((((unsigned int )mask & 1U) + (unsigned int )(((unsigned long )mask & 2UL) != 0UL)) + (unsigned int )(((unsigned long )mask & 4UL) != 0UL));
}
}
#line 170 "drivers/net/wireless/iwlwifi/dvm/../iwl-op-mode.h"
extern int iwl_opmode_register(char const   * , struct iwl_op_mode_ops  const  * ) ;
#line 171
extern void iwl_opmode_deregister(char const   * ) ;
#line 651 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_configure(struct iwl_trans *trans , struct iwl_trans_config  const  *trans_cfg ) 
{ 


  {
#line 654
  trans->op_mode = trans_cfg->op_mode;
#line 656
  (*((trans->ops)->configure))(trans, trans_cfg);
#line 657
  return;
}
}
#line 666 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static int iwl_trans_start_hw(struct iwl_trans *trans ) 
{ 
  int tmp ;

  {
#line 668
  tmp = (*((trans->ops)->start_hw))(trans, 1);
#line 668
  return (tmp);
}
}
#line 671 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_op_mode_leave(struct iwl_trans *trans ) 
{ 


  {
#line 673
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 673, 0);
#line 675
  if ((unsigned long )(trans->ops)->op_mode_leave != (unsigned long )((void (*/* const  */)(struct iwl_trans * ))0)) {
#line 676
    (*((trans->ops)->op_mode_leave))(trans);
  } else {

  }
#line 678
  trans->op_mode = (struct iwl_op_mode *)0;
#line 680
  trans->state = 0;
#line 681
  return;
}
}
#line 715 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void _iwl_trans_stop_device(struct iwl_trans *trans , bool low_power ) 
{ 


  {
#line 718
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 718, 0);
#line 720
  (*((trans->ops)->stop_device))(trans, (int )low_power);
#line 722
  trans->state = 0;
#line 723
  return;
}
}
#line 725 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_stop_device(struct iwl_trans *trans ) 
{ 


  {
#line 727
  _iwl_trans_stop_device(trans, 1);
#line 728
  return;
}
}
#line 816 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_free_tx_cmd(struct iwl_trans *trans , struct iwl_device_cmd *dev_cmd ) 
{ 
  u8 *dev_cmd_ptr ;

  {
#line 819
  dev_cmd_ptr = (u8 *)dev_cmd + - trans->dev_cmd_headroom;
#line 821
  kmem_cache_free(trans->dev_cmd_pool, (void *)dev_cmd_ptr);
#line 822
  return;
}
}
#line 926 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_write32(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
#line 928
  (*((trans->ops)->write32))(trans, ofs, val);
#line 929
  return;
}
}
#line 931 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static u32 iwl_trans_read32(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 tmp ;

  {
#line 933
  tmp = (*((trans->ops)->read32))(trans, ofs);
#line 933
  return (tmp);
}
}
#line 947 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static int iwl_trans_read_mem(struct iwl_trans *trans , u32 addr , void *buf ,
                                       int dwords ) 
{ 
  int tmp ;

  {
#line 950
  tmp = (*((trans->ops)->read_mem))(trans, addr, buf, dwords);
#line 950
  return (tmp);
}
}
#line 960 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static u32 iwl_trans_read_mem32(struct iwl_trans *trans , u32 addr ) 
{ 
  u32 value ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 964
  tmp = iwl_trans_read_mem(trans, addr, (void *)(& value), 1);
#line 964
  __ret_warn_on = tmp != 0;
#line 964
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 964
  if (tmp___0 != 0L) {
#line 964
    warn_slowpath_null("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 964);
  } else {

  }
#line 964
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 964
  if (tmp___1 != 0L) {
#line 965
    return (2779096485U);
  } else {

  }
#line 967
  return (value);
}
}
#line 989 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_set_bits_mask(struct iwl_trans *trans , u32 reg , u32 mask ,
                                             u32 value ) 
{ 


  {
#line 991
  (*((trans->ops)->set_bits_mask))(trans, reg, mask, value);
#line 992
  return;
}
}
#line 999 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_release_nic_access(struct iwl_trans *trans , unsigned long *flags ) 
{ 


  {
#line 1001
  (*((trans->ops)->release_nic_access))(trans, flags);
#line 1003
  return;
}
}
#line 68 "drivers/net/wireless/iwlwifi/dvm/../iwl-eeprom-read.h"
extern int iwl_read_eeprom(struct iwl_trans * , u8 ** , size_t * ) ;
#line 119 "drivers/net/wireless/iwlwifi/dvm/../iwl-eeprom-parse.h"
extern struct iwl_nvm_data *iwl_parse_eeprom_data(struct device * , struct iwl_cfg  const  * ,
                                                  u8 const   * , size_t  ) ;
#line 126 "drivers/net/wireless/iwlwifi/dvm/../iwl-eeprom-parse.h"
__inline static void iwl_free_nvm_data(struct iwl_nvm_data *data ) 
{ 


  {
#line 128
  kfree((void const   *)data);
#line 129
  return;
}
}
#line 131
extern int iwl_nvm_check_version(struct iwl_nvm_data * , struct iwl_trans * ) ;
#line 50 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
extern struct tracepoint __tracepoint_iwlwifi_dev_ioread32 ;
#line 50 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32(struct device  const  *dev , u32 offs ,
                                                u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_390 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_392 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 35
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ioread32.key);
#line 35
  if ((int )tmp___1) {
#line 35
    rcu_read_lock_sched_notrace();
#line 35
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                     (void *)(& __u.__c), 8);
#line 35
    _________p1 = __u.__val;
#line 35
    ________p1 = _________p1;
#line 35
    tmp = debug_lockdep_rcu_enabled();
#line 35
    if (tmp != 0 && ! __warned) {
#line 35
      tmp___0 = rcu_read_lock_sched_held();
#line 35
      if (tmp___0 == 0) {
#line 35
        __warned = 1;
#line 35
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               50, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 35
    it_func_ptr = ________p1;
#line 35
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51545: 
#line 35
      it_func = it_func_ptr->func;
#line 35
      __data = it_func_ptr->data;
#line 35
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 35
      it_func_ptr = it_func_ptr + 1;
#line 35
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 37
        goto ldv_51545;
      } else {

      }

    } else {

    }
#line 35
    rcu_read_unlock_sched_notrace();
  } else {

  }
#line 35
  rcu_read_lock_sched_notrace();
#line 35
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 35
  _________p1___0 = __u___0.__val;
#line 35
  ________p1___0 = _________p1___0;
#line 35
  tmp___2 = debug_lockdep_rcu_enabled();
#line 35
  if (tmp___2 != 0 && ! __warned___0) {
#line 35
    tmp___3 = rcu_read_lock_sched_held();
#line 35
    if (tmp___3 == 0) {
#line 35
      __warned___0 = 1;
#line 35
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             50, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 35
  rcu_read_unlock_sched_notrace();
#line 37
  return;
}
}
#line 84
extern struct tracepoint __tracepoint_iwlwifi_dev_iowrite32 ;
#line 84 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32(struct device  const  *dev , u32 offs ,
                                                 u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_398 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_400 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 69
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite32.key);
#line 69
  if ((int )tmp___1) {
#line 69
    rcu_read_lock_sched_notrace();
#line 69
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
#line 69
    _________p1 = __u.__val;
#line 69
    ________p1 = _________p1;
#line 69
    tmp = debug_lockdep_rcu_enabled();
#line 69
    if (tmp != 0 && ! __warned) {
#line 69
      tmp___0 = rcu_read_lock_sched_held();
#line 69
      if (tmp___0 == 0) {
#line 69
        __warned = 1;
#line 69
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 69
    it_func_ptr = ________p1;
#line 69
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51667: 
#line 69
      it_func = it_func_ptr->func;
#line 69
      __data = it_func_ptr->data;
#line 69
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 69
      it_func_ptr = it_func_ptr + 1;
#line 69
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 71
        goto ldv_51667;
      } else {

      }

    } else {

    }
#line 69
    rcu_read_unlock_sched_notrace();
  } else {

  }
#line 69
  rcu_read_lock_sched_notrace();
#line 69
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 69
  _________p1___0 = __u___0.__val;
#line 69
  ________p1___0 = _________p1___0;
#line 69
  tmp___2 = debug_lockdep_rcu_enabled();
#line 69
  if (tmp___2 != 0 && ! __warned___0) {
#line 69
    tmp___3 = rcu_read_lock_sched_held();
#line 69
    if (tmp___3 == 0) {
#line 69
      __warned___0 = 1;
#line 69
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 69
  rcu_read_unlock_sched_notrace();
#line 71
  return;
}
}
#line 53 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h"
extern struct tracepoint __tracepoint_iwlwifi_dev_ucode_cont_event ;
#line 53 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h"
__inline static void trace_iwlwifi_dev_ucode_cont_event(struct device  const  *dev ,
                                                        u32 time , u32 data , u32 ev ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_418 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_420 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 35
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ucode_cont_event.key);
#line 35
  if ((int )tmp___1) {
#line 35
    rcu_read_lock_sched_notrace();
#line 35
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_cont_event.funcs),
                     (void *)(& __u.__c), 8);
#line 35
    _________p1 = __u.__val;
#line 35
    ________p1 = _________p1;
#line 35
    tmp = debug_lockdep_rcu_enabled();
#line 35
    if (tmp != 0 && ! __warned) {
#line 35
      tmp___0 = rcu_read_lock_sched_held();
#line 35
      if (tmp___0 == 0) {
#line 35
        __warned = 1;
#line 35
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h",
                               53, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 35
    it_func_ptr = ________p1;
#line 35
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51964: 
#line 35
      it_func = it_func_ptr->func;
#line 35
      __data = it_func_ptr->data;
#line 35
      (*((void (*)(void * , struct device  const  * , u32  , u32  , u32  ))it_func))(__data,
                                                                                     dev,
                                                                                     time,
                                                                                     data,
                                                                                     ev);
#line 35
      it_func_ptr = it_func_ptr + 1;
#line 35
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 37
        goto ldv_51964;
      } else {

      }

    } else {

    }
#line 35
    rcu_read_unlock_sched_notrace();
  } else {

  }
#line 35
  rcu_read_lock_sched_notrace();
#line 35
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_cont_event.funcs),
                   (void *)(& __u___0.__c), 8);
#line 35
  _________p1___0 = __u___0.__val;
#line 35
  ________p1___0 = _________p1___0;
#line 35
  tmp___2 = debug_lockdep_rcu_enabled();
#line 35
  if (tmp___2 != 0 && ! __warned___0) {
#line 35
    tmp___3 = rcu_read_lock_sched_held();
#line 35
    if (tmp___3 == 0) {
#line 35
      __warned___0 = 1;
#line 35
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h",
                             53, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 35
  rcu_read_unlock_sched_notrace();
#line 37
  return;
}
}
#line 74
extern struct tracepoint __tracepoint_iwlwifi_dev_ucode_wrap_event ;
#line 74 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h"
__inline static void trace_iwlwifi_dev_ucode_wrap_event(struct device  const  *dev ,
                                                        u32 wraps , u32 n_entry ,
                                                        u32 p_entry ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_422 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_424 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 55
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ucode_wrap_event.key);
#line 55
  if ((int )tmp___1) {
#line 55
    rcu_read_lock_sched_notrace();
#line 55
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_wrap_event.funcs),
                     (void *)(& __u.__c), 8);
#line 55
    _________p1 = __u.__val;
#line 55
    ________p1 = _________p1;
#line 55
    tmp = debug_lockdep_rcu_enabled();
#line 55
    if (tmp != 0 && ! __warned) {
#line 55
      tmp___0 = rcu_read_lock_sched_held();
#line 55
      if (tmp___0 == 0) {
#line 55
        __warned = 1;
#line 55
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h",
                               74, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 55
    it_func_ptr = ________p1;
#line 55
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_52030: 
#line 55
      it_func = it_func_ptr->func;
#line 55
      __data = it_func_ptr->data;
#line 55
      (*((void (*)(void * , struct device  const  * , u32  , u32  , u32  ))it_func))(__data,
                                                                                     dev,
                                                                                     wraps,
                                                                                     n_entry,
                                                                                     p_entry);
#line 55
      it_func_ptr = it_func_ptr + 1;
#line 55
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 57
        goto ldv_52030;
      } else {

      }

    } else {

    }
#line 55
    rcu_read_unlock_sched_notrace();
  } else {

  }
#line 55
  rcu_read_lock_sched_notrace();
#line 55
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_wrap_event.funcs),
                   (void *)(& __u___0.__c), 8);
#line 55
  _________p1___0 = __u___0.__val;
#line 55
  ________p1___0 = _________p1___0;
#line 55
  tmp___2 = debug_lockdep_rcu_enabled();
#line 55
  if (tmp___2 != 0 && ! __warned___0) {
#line 55
    tmp___3 = rcu_read_lock_sched_held();
#line 55
    if (tmp___3 == 0) {
#line 55
      __warned___0 = 1;
#line 55
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h",
                             74, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 55
  rcu_read_unlock_sched_notrace();
#line 57
  return;
}
}
#line 178 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h"
extern struct tracepoint __tracepoint_iwlwifi_dev_ucode_error ;
#line 178 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h"
__inline static void trace_iwlwifi_dev_ucode_error(struct device  const  *dev , u32 desc ,
                                                   u32 tsf_low , u32 data1 , u32 data2 ,
                                                   u32 line , u32 blink1 , u32 blink2 ,
                                                   u32 ilink1 , u32 ilink2 , u32 bcon_time ,
                                                   u32 gp1 , u32 gp2 , u32 gp3 , u32 major ,
                                                   u32 minor , u32 hw_ver , u32 brd_ver ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_466 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_468 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 118
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ucode_error.key);
#line 118
  if ((int )tmp___1) {
#line 118
    rcu_read_lock_sched_notrace();
#line 118
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_error.funcs),
                     (void *)(& __u.__c), 8);
#line 118
    _________p1 = __u.__val;
#line 118
    ________p1 = _________p1;
#line 118
    tmp = debug_lockdep_rcu_enabled();
#line 118
    if (tmp != 0 && ! __warned) {
#line 118
      tmp___0 = rcu_read_lock_sched_held();
#line 118
      if (tmp___0 == 0) {
#line 118
        __warned = 1;
#line 118
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h",
                               178, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 118
    it_func_ptr = ________p1;
#line 118
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_52744: 
#line 118
      it_func = it_func_ptr->func;
#line 118
      __data = it_func_ptr->data;
#line 118
      (*((void (*)(void * , struct device  const  * , u32  , u32  , u32  , u32  ,
                   u32  , u32  , u32  , u32  , u32  , u32  , u32  , u32  , u32  ,
                   u32  , u32  , u32  , u32  ))it_func))(__data, dev, desc, tsf_low,
                                                         data1, data2, line, blink1,
                                                         blink2, ilink1, ilink2, bcon_time,
                                                         gp1, gp2, gp3, major, minor,
                                                         hw_ver, brd_ver);
#line 118
      it_func_ptr = it_func_ptr + 1;
#line 118
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 120
        goto ldv_52744;
      } else {

      }

    } else {

    }
#line 118
    rcu_read_unlock_sched_notrace();
  } else {

  }
#line 118
  rcu_read_lock_sched_notrace();
#line 118
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_error.funcs),
                   (void *)(& __u___0.__c), 8);
#line 118
  _________p1___0 = __u___0.__val;
#line 118
  ________p1___0 = _________p1___0;
#line 118
  tmp___2 = debug_lockdep_rcu_enabled();
#line 118
  if (tmp___2 != 0 && ! __warned___0) {
#line 118
    tmp___3 = rcu_read_lock_sched_held();
#line 118
    if (tmp___3 == 0) {
#line 118
      __warned___0 = 1;
#line 118
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h",
                             178, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 118
  rcu_read_unlock_sched_notrace();
#line 120
  return;
}
}
#line 198
extern struct tracepoint __tracepoint_iwlwifi_dev_ucode_event ;
#line 198 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h"
__inline static void trace_iwlwifi_dev_ucode_event(struct device  const  *dev , u32 time ,
                                                   u32 data , u32 ev ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_470 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_472 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 180
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ucode_event.key);
#line 180
  if ((int )tmp___1) {
#line 180
    rcu_read_lock_sched_notrace();
#line 180
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_event.funcs),
                     (void *)(& __u.__c), 8);
#line 180
    _________p1 = __u.__val;
#line 180
    ________p1 = _________p1;
#line 180
    tmp = debug_lockdep_rcu_enabled();
#line 180
    if (tmp != 0 && ! __warned) {
#line 180
      tmp___0 = rcu_read_lock_sched_held();
#line 180
      if (tmp___0 == 0) {
#line 180
        __warned = 1;
#line 180
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h",
                               198, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 180
    it_func_ptr = ________p1;
#line 180
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_52852: 
#line 180
      it_func = it_func_ptr->func;
#line 180
      __data = it_func_ptr->data;
#line 180
      (*((void (*)(void * , struct device  const  * , u32  , u32  , u32  ))it_func))(__data,
                                                                                     dev,
                                                                                     time,
                                                                                     data,
                                                                                     ev);
#line 180
      it_func_ptr = it_func_ptr + 1;
#line 180
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 182
        goto ldv_52852;
      } else {

      }

    } else {

    }
#line 180
    rcu_read_unlock_sched_notrace();
  } else {

  }
#line 180
  rcu_read_lock_sched_notrace();
#line 180
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_event.funcs),
                   (void *)(& __u___0.__c), 8);
#line 180
  _________p1___0 = __u___0.__val;
#line 180
  ________p1___0 = _________p1___0;
#line 180
  tmp___2 = debug_lockdep_rcu_enabled();
#line 180
  if (tmp___2 != 0 && ! __warned___0) {
#line 180
    tmp___3 = rcu_read_lock_sched_held();
#line 180
    if (tmp___3 == 0) {
#line 180
      __warned___0 = 1;
#line 180
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h",
                             198, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 180
  rcu_read_unlock_sched_notrace();
#line 182
  return;
}
}
#line 41 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static void iwl_write32(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
#line 43
  trace_iwlwifi_dev_iowrite32((struct device  const  *)trans->dev, ofs, val);
#line 44
  iwl_trans_write32(trans, ofs, val);
#line 45
  return;
}
}
#line 47 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static u32 iwl_read32(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 val ;
  u32 tmp ;

  {
#line 49
  tmp = iwl_trans_read32(trans, ofs);
#line 49
  val = tmp;
#line 50
  trace_iwlwifi_dev_ioread32((struct device  const  *)trans->dev, ofs, val);
#line 51
  return (val);
}
}
#line 54 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static void iwl_set_bit(struct iwl_trans *trans , u32 reg , u32 mask ) 
{ 


  {
#line 56
  iwl_trans_set_bits_mask(trans, reg, mask, mask);
#line 57
  return;
}
}
#line 80
extern void iwl_set_bits_mask_prph(struct iwl_trans * , u32  , u32  , u32  ) ;
#line 118 "drivers/net/wireless/iwlwifi/dvm/../iwl-notif-wait.h"
extern void iwl_abort_notification_waits(struct iwl_notif_wait_data * ) ;
#line 42 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/power.h"
int iwl_power_update_mode(struct iwl_priv *priv , bool force ) ;
#line 43
void iwl_power_initialize(struct iwl_priv *priv ) ;
#line 416 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
int iwlagn_rate_control_register(void) ;
#line 424
void iwlagn_rate_control_unregister(void) ;
#line 125 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/tt.h"
void iwl_tt_initialize(struct iwl_priv *priv ) ;
#line 126
void iwl_tt_exit(struct iwl_priv *priv ) ;
#line 273 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
void iwl_update_chain_flags(struct iwl_priv *priv ) ;
#line 928 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
__inline static int iwl_is_associated_ctx(struct iwl_rxon_context *ctx ) 
{ 


  {
#line 930
  return (((unsigned int )ctx->active.filter_flags & 32U) != 0U);
}
}
#line 68 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/calib.h"
void iwl_chain_noise_calibration(struct iwl_priv *priv ) ;
#line 69
void iwl_sensitivity_calibration(struct iwl_priv *priv ) ;
#line 72
void iwl_reset_run_time_calib(struct iwl_priv *priv ) ;
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
struct iwl_dvm_cfg  const  iwl_dvm_1000_cfg ;
#line 80
struct iwl_dvm_cfg  const  iwl_dvm_2000_cfg ;
#line 81
struct iwl_dvm_cfg  const  iwl_dvm_105_cfg ;
#line 82
struct iwl_dvm_cfg  const  iwl_dvm_2030_cfg ;
#line 83
struct iwl_dvm_cfg  const  iwl_dvm_5000_cfg ;
#line 84
struct iwl_dvm_cfg  const  iwl_dvm_5150_cfg ;
#line 85
struct iwl_dvm_cfg  const  iwl_dvm_6000_cfg ;
#line 86
struct iwl_dvm_cfg  const  iwl_dvm_6005_cfg ;
#line 87
struct iwl_dvm_cfg  const  iwl_dvm_6050_cfg ;
#line 88
struct iwl_dvm_cfg  const  iwl_dvm_6030_cfg ;
#line 122
void iwl_down(struct iwl_priv *priv ) ;
#line 123
void iwl_cancel_deferred_work(struct iwl_priv *priv ) ;
#line 124
void iwlagn_prepare_restart(struct iwl_priv *priv ) ;
#line 125
int iwl_rx_dispatch(struct iwl_op_mode *op_mode , struct iwl_rx_cmd_buffer *rxb ,
                    struct iwl_device_cmd *cmd ) ;
#line 129
bool iwl_check_for_ct_kill(struct iwl_priv *priv ) ;
#line 131
void iwlagn_lift_passive_no_rx(struct iwl_priv *priv ) ;
#line 134
struct ieee80211_hw *iwl_alloc_all(void) ;
#line 135
int iwlagn_mac_setup_register(struct iwl_priv *priv , struct iwl_ucode_capabilities  const  *capa ) ;
#line 137
void iwlagn_mac_unregister(struct iwl_priv *priv ) ;
#line 140
int iwl_dvm_send_cmd(struct iwl_priv *priv , struct iwl_host_cmd *cmd ) ;
#line 141
int iwl_dvm_send_cmd_pdu(struct iwl_priv *priv , u8 id , u32 flags , u16 len , void const   *data ) ;
#line 145
void iwl_connection_init_rx_config(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
#line 148
int iwlagn_commit_rxon(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
#line 149
void iwlagn_set_rxon_chain(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
#line 166
int iwl_send_bt_env(struct iwl_priv *priv , u8 action , u8 type ) ;
#line 167
void iwl_send_prio_tbl(struct iwl_priv *priv ) ;
#line 175
void iwl_calib_free_results(struct iwl_priv *priv ) ;
#line 176
int iwl_dump_nic_event_log(struct iwl_priv *priv , bool full_log , char **buf ) ;
#line 178
int iwlagn_hw_valid_rtc_data_addr(u32 addr ) ;
#line 184
void iwlagn_dev_txfifo_flush(struct iwl_priv *priv ) ;
#line 185
int iwlagn_send_beacon_cmd(struct iwl_priv *priv ) ;
#line 186
int iwl_send_statistics_request(struct iwl_priv *priv , u8 flags , bool clear ) ;
#line 203
void iwl_setup_rx_handlers(struct iwl_priv *priv ) ;
#line 248
u8 iwl_toggle_tx_ant(struct iwl_priv *priv , u8 ant , u8 valid ) ;
#line 253
void iwl_init_scan_params(struct iwl_priv *priv ) ;
#line 255
void iwl_scan_cancel_timeout(struct iwl_priv *priv , unsigned long ms ) ;
#line 259
void iwl_setup_scan_deferred_work(struct iwl_priv *priv ) ;
#line 260
void iwl_cancel_scan_deferred_work(struct iwl_priv *priv ) ;
#line 279
void iwlagn_send_advance_bt_config(struct iwl_priv *priv ) ;
#line 284
void iwlagn_bt_setup_deferred_work(struct iwl_priv *priv ) ;
#line 285
void iwlagn_bt_cancel_deferred_work(struct iwl_priv *priv ) ;
#line 317
void iwl_clear_ucode_stations(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
#line 319
void iwl_dealloc_bcast_stations(struct iwl_priv *priv ) ;
#line 385 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static u32 iwl_ant_idx_to_flags(u8 ant_idx ) 
{ 


  {
#line 387
  return ((u32 )(1UL << (int )ant_idx) << 14U);
}
}
#line 395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static __le32 iwl_hw_set_rate_n_flags(u8 rate , u32 flags ) 
{ 


  {
#line 397
  return ((u32 )rate | flags);
}
}
#line 400
int iwl_alive_start(struct iwl_priv *priv ) ;
#line 403
void iwl_print_rx_config_cmd(struct iwl_priv *priv , enum iwl_rxon_context_id ctxid ) ;
#line 414 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static int iwl_is_ready(struct iwl_priv *priv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 417
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
#line 417
  if (tmp != 0) {
#line 417
    tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 417
    if (tmp___0 == 0) {
#line 417
      tmp___1 = 1;
    } else {
#line 417
      tmp___1 = 0;
    }
  } else {
#line 417
    tmp___1 = 0;
  }
#line 417
  return (tmp___1);
}
}
#line 426 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static int iwl_is_rfkill(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
#line 428
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
#line 428
  return (tmp);
}
}
#line 436 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static int iwl_is_ready_rf(struct iwl_priv *priv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 438
  tmp = iwl_is_rfkill(priv);
#line 438
  if (tmp != 0) {
#line 439
    return (0);
  } else {

  }
#line 441
  tmp___0 = iwl_is_ready(priv);
#line 441
  return (tmp___0);
}
}
#line 454
int iwl_dbgfs_register(struct iwl_priv *priv , struct dentry *dbgfs_dir ) ;
#line 483
char const   * const  iwl_dvm_cmd_strings[255U] ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static struct iwl_op_mode_ops  const  iwl_dvm_ops ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
void iwl_update_chain_flags(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;

  {
#line 78
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 78
  goto ldv_55434;
  ldv_55433: ;
#line 78
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 79
    iwlagn_set_rxon_chain(priv, ctx);
#line 80
    if ((int )((unsigned short )ctx->active.rx_chain) != (int )ctx->staging.rx_chain) {
#line 81
      iwlagn_commit_rxon(priv, ctx);
    } else {

    }
  } else {

  }
#line 78
  ctx = ctx + 1;
  ldv_55434: ;
#line 78
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 80
    goto ldv_55433;
  } else {

  }

#line 85
  return;
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_set_beacon_tim(struct iwl_priv *priv , struct iwl_tx_beacon_cmd *tx_beacon_cmd ,
                               u8 *beacon , u32 frame_size ) 
{ 
  u16 tim_idx ;
  struct ieee80211_mgmt *mgmt ;

  {
#line 91
  mgmt = (struct ieee80211_mgmt *)beacon;
#line 97
  tim_idx = (int )((u16 )((long )(& mgmt->u.beacon.variable))) - (int )((u16 )((long )beacon));
#line 100
  goto ldv_55445;
  ldv_55444: 
#line 102
  tim_idx = (unsigned int )((int )((u16 )*(beacon + ((unsigned long )tim_idx + 1UL))) + (int )tim_idx) + 2U;
  ldv_55445: ;
#line 100
  if ((u32 )tim_idx < frame_size - 2U && (unsigned int )*(beacon + (unsigned long )tim_idx) != 5U) {
#line 103
    goto ldv_55444;
  } else {

  }

#line 105
  if ((u32 )tim_idx < frame_size - 1U && (unsigned int )*(beacon + (unsigned long )tim_idx) == 5U) {
#line 106
    tx_beacon_cmd->tim_idx = tim_idx;
#line 107
    tx_beacon_cmd->tim_size = *(beacon + ((unsigned long )tim_idx + 1UL));
  } else {
#line 109
    __iwl_warn(priv->dev, "Unable to find TIM Element in beacon\n");
  }
#line 110
  return;
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
int iwlagn_send_beacon_cmd(struct iwl_priv *priv ) 
{ 
  struct iwl_tx_beacon_cmd *tx_beacon_cmd ;
  struct iwl_host_cmd cmd ;
  struct ieee80211_tx_info *info ;
  u32 frame_size ;
  u32 rate_flags ;
  u32 rate ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 115
  cmd.data[0] = 0;
#line 115
  cmd.data[1] = 0;
#line 115
  cmd.resp_pkt = 0;
#line 115
  cmd._rx_page_addr = 0UL;
#line 115
  cmd._rx_page_order = 0U;
#line 115
  cmd.handler_status = 0;
#line 115
  cmd.flags = 0U;
#line 115
  cmd.len[0] = (unsigned short)0;
#line 115
  cmd.len[1] = (unsigned short)0;
#line 115
  cmd.dataflags[0] = (unsigned char)0;
#line 115
  cmd.dataflags[1] = (unsigned char)0;
#line 115
  cmd.id = 145U;
#line 128
  if (debug_locks != 0) {
#line 128
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 128
    if (tmp == 0) {
#line 128
      tmp___0 = 1;
    } else {
#line 128
      tmp___0 = 0;
    }
  } else {
#line 128
    tmp___0 = 0;
  }
#line 128
  __ret_warn_on = tmp___0;
#line 128
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 128
  if (tmp___1 != 0L) {
#line 128
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       128);
  } else {

  }
#line 128
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 130
  if ((unsigned long )priv->beacon_ctx == (unsigned long )((struct iwl_rxon_context *)0)) {
#line 131
    __iwl_err(priv->dev, 0, 0, "trying to build beacon w/o beacon context!\n");
#line 132
    return (0);
  } else {

  }
#line 135
  __ret_warn_on___0 = (unsigned long )priv->beacon_skb == (unsigned long )((struct sk_buff *)0);
#line 135
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 135
  if (tmp___2 != 0L) {
#line 135
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       135);
  } else {

  }
#line 135
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 135
  if (tmp___3 != 0L) {
#line 136
    return (-22);
  } else {

  }
#line 139
  if ((unsigned long )priv->beacon_cmd == (unsigned long )((void *)0)) {
#line 140
    priv->beacon_cmd = kzalloc(60UL, 208U);
  } else {

  }
#line 141
  tx_beacon_cmd = (struct iwl_tx_beacon_cmd *)priv->beacon_cmd;
#line 142
  if ((unsigned long )tx_beacon_cmd == (unsigned long )((struct iwl_tx_beacon_cmd *)0)) {
#line 143
    return (-12);
  } else {

  }
#line 145
  frame_size = (priv->beacon_skb)->len;
#line 148
  tx_beacon_cmd->tx.len = (unsigned short )frame_size;
#line 149
  tx_beacon_cmd->tx.sta_id = (priv->beacon_ctx)->bcast_sta_id;
#line 150
  tx_beacon_cmd->tx.stop_time.life_time = 4294967295U;
#line 151
  tx_beacon_cmd->tx.tx_flags = 73744U;
#line 155
  iwl_set_beacon_tim(priv, tx_beacon_cmd, (priv->beacon_skb)->data, frame_size);
#line 159
  info = IEEE80211_SKB_CB(priv->beacon_skb);
#line 166
  if ((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].idx < 0 || ((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags & 8) != 0) {
#line 168
    rate = 0U;
  } else {
#line 170
    rate = (u32 )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].idx;
  }
#line 172
  priv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, (int )priv->mgmt_tx_ant, (int )(priv->nvm_data)->valid_tx_ant);
#line 174
  rate_flags = iwl_ant_idx_to_flags((int )priv->mgmt_tx_ant);
#line 177
  if ((unsigned int )info->band == 1U) {
#line 178
    rate = rate + 4U;
  } else
#line 179
  if (rate <= 3U) {
#line 180
    rate_flags = rate_flags | 512U;
  } else {

  }
#line 182
  tx_beacon_cmd->tx.rate_n_flags = iwl_hw_set_rate_n_flags((int )((u8 )rate), rate_flags);
#line 186
  cmd.len[0] = 60U;
#line 187
  cmd.data[0] = (void const   *)tx_beacon_cmd;
#line 188
  cmd.dataflags[0] = 1U;
#line 189
  cmd.len[1] = (u16 )frame_size;
#line 190
  cmd.data[1] = (void const   *)(priv->beacon_skb)->data;
#line 191
  cmd.dataflags[1] = 1U;
#line 193
  tmp___4 = iwl_dvm_send_cmd(priv, & cmd);
#line 193
  return (tmp___4);
}
}
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_bg_beacon_update(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct sk_buff *beacon ;

  {
#line 199
  __mptr = (struct work_struct  const  *)work;
#line 199
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd040UL;
#line 202
  ldv_mutex_lock_17(& priv->mutex);
#line 203
  if ((unsigned long )priv->beacon_ctx == (unsigned long )((struct iwl_rxon_context *)0)) {
#line 204
    __iwl_err(priv->dev, 0, 0, "updating beacon w/o beacon context!\n");
#line 205
    goto out;
  } else {

  }
#line 208
  if ((unsigned int )((priv->beacon_ctx)->vif)->type != 3U) {
#line 215
    goto out;
  } else {

  }
#line 219
  beacon = ieee80211_beacon_get(priv->hw, (priv->beacon_ctx)->vif);
#line 220
  if ((unsigned long )beacon == (unsigned long )((struct sk_buff *)0)) {
#line 221
    __iwl_err(priv->dev, 0, 0, "update beacon failed -- keeping old\n");
#line 222
    goto out;
  } else {

  }
#line 226
  consume_skb(priv->beacon_skb);
#line 228
  priv->beacon_skb = beacon;
#line 230
  iwlagn_send_beacon_cmd(priv);
  out: 
#line 232
  ldv_mutex_unlock_18(& priv->mutex);
#line 233
  return;
}
}
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_bg_bt_runtime_config(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 238
  __mptr = (struct work_struct  const  *)work;
#line 238
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcdf8UL;
#line 240
  ldv_mutex_lock_19(& priv->mutex);
#line 241
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 241
  if (tmp != 0) {
#line 242
    goto out;
  } else {

  }
#line 245
  tmp___0 = iwl_is_ready_rf(priv);
#line 245
  if (tmp___0 == 0) {
#line 246
    goto out;
  } else {

  }
#line 248
  iwlagn_send_advance_bt_config(priv);
  out: 
#line 250
  ldv_mutex_unlock_20(& priv->mutex);
#line 251
  return;
}
}
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_bg_bt_full_concurrency(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct iwl_rxon_context *ctx ;
  int tmp ;
  int tmp___0 ;

  {
#line 256
  __mptr = (struct work_struct  const  *)work;
#line 256
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffce48UL;
#line 259
  ldv_mutex_lock_21(& priv->mutex);
#line 261
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 261
  if (tmp != 0) {
#line 262
    goto out;
  } else {

  }
#line 265
  tmp___0 = iwl_is_ready_rf(priv);
#line 265
  if (tmp___0 == 0) {
#line 266
    goto out;
  } else {

  }
#line 268
  __iwl_dbg(priv->dev, 1U, 0, "iwl_bg_bt_full_concurrency", "BT coex in %s mode\n",
            (int )priv->bt_full_concurrent ? (char *)"full concurrency" : (char *)"3-wire");
#line 276
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 276
  goto ldv_55485;
  ldv_55484: ;
#line 276
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 277
    iwlagn_set_rxon_chain(priv, ctx);
#line 278
    iwlagn_commit_rxon(priv, ctx);
  } else {

  }
#line 276
  ctx = ctx + 1;
  ldv_55485: ;
#line 276
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 278
    goto ldv_55484;
  } else {

  }
#line 281
  iwlagn_send_advance_bt_config(priv);
  out: 
#line 283
  ldv_mutex_unlock_22(& priv->mutex);
#line 284
  return;
}
}
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
int iwl_send_statistics_request(struct iwl_priv *priv , u8 flags , bool clear ) 
{ 
  struct iwl_statistics_cmd statistics_cmd ;
  int tmp ;
  int tmp___0 ;

  {
#line 288
  statistics_cmd.configuration_flags = (int )clear ? 1U : 0U;
#line 293
  if ((int )flags & 1) {
#line 294
    tmp = iwl_dvm_send_cmd_pdu(priv, 156, 1U, 4, (void const   *)(& statistics_cmd));
#line 294
    return (tmp);
  } else {
#line 299
    tmp___0 = iwl_dvm_send_cmd_pdu(priv, 156, 0U, 4, (void const   *)(& statistics_cmd));
#line 299
    return (tmp___0);
  }
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_bg_statistics_periodic(unsigned long data ) 
{ 
  struct iwl_priv *priv ;
  int tmp ;
  int tmp___0 ;

  {
#line 316
  priv = (struct iwl_priv *)data;
#line 318
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 318
  if (tmp != 0) {
#line 319
    return;
  } else {

  }
#line 322
  tmp___0 = iwl_is_ready_rf(priv);
#line 322
  if (tmp___0 == 0) {
#line 323
    return;
  } else {

  }
#line 325
  iwl_send_statistics_request(priv, 1, 0);
#line 326
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_print_cont_event_trace(struct iwl_priv *priv , u32 base , u32 start_idx ,
                                       u32 num_events , u32 capacity , u32 mode ) 
{ 
  u32 i ;
  u32 ptr ;
  u32 ev ;
  u32 time ;
  u32 data ;
  unsigned long reg_flags ;
  bool tmp ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 338
  if (mode == 0U) {
#line 339
    ptr = (start_idx * 8U + base) + 16U;
  } else {
#line 341
    ptr = (start_idx * 12U + base) + 16U;
  }
#line 344
  tmp = (*(((priv->trans)->ops)->grab_nic_access))(priv->trans, 0, & reg_flags);
#line 344
  tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 344
  if (tmp___0 == 0L) {
#line 345
    return;
  } else {

  }
#line 348
  iwl_write32(priv->trans, 1036U, ptr);
#line 356
  __ret_warn_on = capacity - start_idx < num_events;
#line 356
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 356
  if (tmp___1 != 0L) {
#line 356
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       356);
  } else {

  }
#line 356
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 356
  if (tmp___2 != 0L) {
#line 357
    num_events = capacity - start_idx;
  } else {

  }
#line 363
  i = 0U;
#line 363
  goto ldv_55514;
  ldv_55513: 
#line 364
  ev = iwl_read32(priv->trans, 1052U);
#line 365
  time = iwl_read32(priv->trans, 1052U);
#line 366
  if (mode == 0U) {
#line 367
    trace_iwlwifi_dev_ucode_cont_event((struct device  const  *)(priv->trans)->dev,
                                       0U, time, ev);
  } else {
#line 370
    data = iwl_read32(priv->trans, 1052U);
#line 371
    trace_iwlwifi_dev_ucode_cont_event((struct device  const  *)(priv->trans)->dev,
                                       time, data, ev);
  }
#line 363
  i = i + 1U;
  ldv_55514: ;
#line 363
  if (i < num_events) {
#line 365
    goto ldv_55513;
  } else {

  }
#line 376
  iwl_trans_release_nic_access(priv->trans, & reg_flags);
#line 377
  return;
}
}
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_continuous_event_trace(struct iwl_priv *priv ) 
{ 
  u32 capacity ;
  struct __anonstruct_read_486 read ;
  u32 base ;
  u32 mode ;
  u32 num_wraps ;
  u32 next_entry ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 393
  base = priv->device_pointers.log_event_table;
#line 394
  tmp = iwlagn_hw_valid_rtc_data_addr(base);
#line 394
  if (tmp != 0) {
#line 395
    iwl_trans_read_mem(priv->trans, base, (void *)(& read), 4);
#line 397
    capacity = read.capacity;
#line 398
    mode = read.mode;
#line 399
    num_wraps = read.wrap_counter;
#line 400
    next_entry = read.write_counter;
  } else {
#line 402
    return;
  }
#line 409
  tmp___0 = ldv__builtin_expect(next_entry == capacity, 0L);
#line 409
  if (tmp___0 != 0L) {
#line 410
    next_entry = 0U;
  } else {

  }
#line 419
  tmp___1 = ldv__builtin_expect((long )(priv->event_log.next_entry > next_entry && priv->event_log.num_wraps == num_wraps),
                             0L);
#line 419
  if (tmp___1 != 0L) {
#line 421
    num_wraps = num_wraps + 1U;
  } else {

  }
#line 423
  if (priv->event_log.num_wraps == num_wraps) {
#line 424
    iwl_print_cont_event_trace(priv, base, priv->event_log.next_entry, next_entry - priv->event_log.next_entry,
                               capacity, mode);
#line 429
    priv->event_log.non_wraps_count = priv->event_log.non_wraps_count + 1;
  } else {
#line 431
    if (num_wraps - priv->event_log.num_wraps > 1U) {
#line 432
      priv->event_log.wraps_more_count = priv->event_log.wraps_more_count + 1;
    } else {
#line 434
      priv->event_log.wraps_once_count = priv->event_log.wraps_once_count + 1;
    }
#line 436
    trace_iwlwifi_dev_ucode_wrap_event((struct device  const  *)(priv->trans)->dev,
                                       num_wraps - priv->event_log.num_wraps, next_entry,
                                       priv->event_log.next_entry);
#line 440
    if (priv->event_log.next_entry > next_entry) {
#line 441
      iwl_print_cont_event_trace(priv, base, priv->event_log.next_entry, capacity - priv->event_log.next_entry,
                                 capacity, mode);
#line 446
      iwl_print_cont_event_trace(priv, base, 0U, next_entry, capacity, mode);
    } else {
#line 449
      iwl_print_cont_event_trace(priv, base, next_entry, capacity - next_entry, capacity,
                                 mode);
#line 454
      iwl_print_cont_event_trace(priv, base, 0U, next_entry, capacity, mode);
    }
  }
#line 459
  priv->event_log.num_wraps = num_wraps;
#line 460
  priv->event_log.next_entry = next_entry;
#line 461
  return;
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_bg_ucode_trace(unsigned long data ) 
{ 
  struct iwl_priv *priv ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 473
  priv = (struct iwl_priv *)data;
#line 475
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 475
  if (tmp != 0) {
#line 476
    return;
  } else {

  }
#line 478
  if ((int )priv->event_log.ucode_trace) {
#line 479
    iwl_continuous_event_trace(priv);
#line 481
    tmp___0 = msecs_to_jiffies(10U);
#line 481
    ldv_mod_timer_23(& priv->ucode_trace, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 484
  return;
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_bg_tx_flush(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 489
  __mptr = (struct work_struct  const  *)work;
#line 489
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffce98UL;
#line 491
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 491
  if (tmp != 0) {
#line 492
    return;
  } else {

  }
#line 495
  tmp___0 = iwl_is_ready_rf(priv);
#line 495
  if (tmp___0 == 0) {
#line 496
    return;
  } else {

  }
#line 498
  __iwl_dbg(priv->dev, 1U, 0, "iwl_bg_tx_flush", "device request: flush all tx frames\n");
#line 499
  iwlagn_dev_txfifo_flush(priv);
#line 500
  return;
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static u8 const   iwlagn_bss_ac_to_fifo[4U]  = {      3U,      2U,      1U,      0U};
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static u8 const   iwlagn_bss_ac_to_queue[4U]  = {      0U,      1U,      2U,      3U};
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static u8 const   iwlagn_pan_ac_to_fifo[4U]  = {      5U,      2U,      4U,      0U};
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static u8 const   iwlagn_pan_ac_to_queue[4U]  = {      7U,      6U,      5U,      4U};
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_init_context(struct iwl_priv *priv , u32 ucode_flags ) 
{ 
  int i ;

  {
#line 536
  priv->valid_contexts = 1U;
#line 537
  if ((int )ucode_flags & 1) {
#line 538
    priv->valid_contexts = (u8 )((unsigned int )priv->valid_contexts | 2U);
  } else {

  }
#line 540
  i = 0;
#line 540
  goto ldv_55551;
  ldv_55550: 
#line 541
  priv->contexts[i].ctxid = (enum iwl_rxon_context_id )i;
#line 540
  i = i + 1;
  ldv_55551: ;
#line 540
  if (i <= 1) {
#line 542
    goto ldv_55550;
  } else {

  }
#line 543
  priv->contexts[0].always_active = 1;
#line 544
  priv->contexts[0].is_active = 1;
#line 545
  priv->contexts[0].rxon_cmd = 16U;
#line 546
  priv->contexts[0].rxon_timing_cmd = 20U;
#line 547
  priv->contexts[0].rxon_assoc_cmd = 17U;
#line 548
  priv->contexts[0].qos_cmd = 19U;
#line 549
  priv->contexts[0].ap_sta_id = 0U;
#line 550
  priv->contexts[0].wep_key_cmd = 32U;
#line 551
  priv->contexts[0].bcast_sta_id = 15U;
#line 552
  priv->contexts[0].exclusive_interface_modes = 66U;
#line 554
  priv->contexts[0].interface_modes = 4U;
#line 556
  priv->contexts[0].ap_devtype = 1U;
#line 557
  priv->contexts[0].ibss_devtype = 4U;
#line 558
  priv->contexts[0].station_devtype = 3U;
#line 559
  priv->contexts[0].unused_devtype = 3U;
#line 560
  memcpy((void *)(& priv->contexts[0].ac_to_queue), (void const   *)(& iwlagn_bss_ac_to_queue),
           4UL);
#line 562
  memcpy((void *)(& priv->contexts[0].ac_to_fifo), (void const   *)(& iwlagn_bss_ac_to_fifo),
           4UL);
#line 565
  priv->contexts[1].rxon_cmd = 179U;
#line 566
  priv->contexts[1].rxon_timing_cmd = 180U;
#line 568
  priv->contexts[1].rxon_assoc_cmd = 182U;
#line 570
  priv->contexts[1].qos_cmd = 183U;
#line 571
  priv->contexts[1].ap_sta_id = 1U;
#line 572
  priv->contexts[1].wep_key_cmd = 184U;
#line 573
  priv->contexts[1].bcast_sta_id = 14U;
#line 574
  priv->contexts[1].station_flags = 8192U;
#line 575
  priv->contexts[1].interface_modes = 12U;
#line 578
  priv->contexts[1].ap_devtype = 7U;
#line 579
  priv->contexts[1].station_devtype = 8U;
#line 580
  priv->contexts[1].unused_devtype = 9U;
#line 581
  memcpy((void *)(& priv->contexts[1].ac_to_queue), (void const   *)(& iwlagn_pan_ac_to_queue),
           4UL);
#line 583
  memcpy((void *)(& priv->contexts[1].ac_to_fifo), (void const   *)(& iwlagn_pan_ac_to_fifo),
           4UL);
#line 585
  priv->contexts[1].mcast_queue = 8U;
#line 586
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_rf_kill_ct_config(struct iwl_priv *priv ) 
{ 
  struct iwl_ct_kill_config cmd ;
  struct iwl_ct_kill_throttling_config adv_cmd ;
  int ret ;

  {
#line 594
  ret = 0;
#line 596
  iwl_write32(priv->trans, 92U, 8U);
#line 599
  priv->thermal_throttle.ct_kill_toggle = 0;
#line 601
  if ((int )(priv->lib)->support_ct_kill_exit) {
#line 602
    adv_cmd.critical_temperature_enter = priv->hw_params.ct_kill_threshold;
#line 604
    adv_cmd.critical_temperature_exit = priv->hw_params.ct_kill_exit_threshold;
#line 607
    ret = iwl_dvm_send_cmd_pdu(priv, 164, 0U, 12, (void const   *)(& adv_cmd));
#line 610
    if (ret != 0) {
#line 611
      __iwl_err(priv->dev, 0, 0, "REPLY_CT_KILL_CONFIG_CMD failed\n");
    } else {
#line 613
      __iwl_dbg(priv->dev, 1U, 0, "iwl_rf_kill_ct_config", "REPLY_CT_KILL_CONFIG_CMD succeeded, critical temperature enter is %d,exit is %d\n",
                priv->hw_params.ct_kill_threshold, priv->hw_params.ct_kill_exit_threshold);
    }
  } else {
#line 619
    cmd.critical_temperature_R = priv->hw_params.ct_kill_threshold;
#line 622
    ret = iwl_dvm_send_cmd_pdu(priv, 164, 0U, 12, (void const   *)(& cmd));
#line 625
    if (ret != 0) {
#line 626
      __iwl_err(priv->dev, 0, 0, "REPLY_CT_KILL_CONFIG_CMD failed\n");
    } else {
#line 628
      __iwl_dbg(priv->dev, 1U, 0, "iwl_rf_kill_ct_config", "REPLY_CT_KILL_CONFIG_CMD succeeded, critical temperature is %d\n",
                priv->hw_params.ct_kill_threshold);
    }
  }
#line 630
  return;
}
}
#line 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static int iwlagn_send_calib_cfg_rt(struct iwl_priv *priv , u32 cfg ) 
{ 
  struct iwl_calib_cfg_cmd calib_cfg_cmd ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 638
  cmd.data[0] = (void const   *)(& calib_cfg_cmd);
#line 638
  tmp = 1U;
#line 638
  while (1) {
#line 638
    if (tmp >= 2U) {
#line 638
      break;
    } else {

    }
#line 638
    cmd.data[tmp] = 0;
#line 638
    tmp = tmp + 1U;
  }
#line 638
  cmd.resp_pkt = 0;
#line 638
  cmd._rx_page_addr = 0UL;
#line 638
  cmd._rx_page_order = 0U;
#line 638
  cmd.handler_status = 0;
#line 638
  cmd.flags = 0U;
#line 638
  cmd.len[0] = 92U;
#line 638
  tmp___0 = 1U;
#line 638
  while (1) {
#line 638
    if (tmp___0 >= 2U) {
#line 638
      break;
    } else {

    }
#line 638
    cmd.len[tmp___0] = (unsigned short)0;
#line 638
    tmp___0 = tmp___0 + 1U;
  }
#line 638
  cmd.dataflags[0] = (unsigned char)0;
#line 638
  cmd.dataflags[1] = (unsigned char)0;
#line 638
  cmd.id = 101U;
#line 644
  memset((void *)(& calib_cfg_cmd), 0, 92UL);
#line 645
  calib_cfg_cmd.ucd_calib_cfg.once.is_enable = 1503U;
#line 646
  calib_cfg_cmd.ucd_calib_cfg.once.start = cfg;
#line 648
  tmp___1 = iwl_dvm_send_cmd(priv, & cmd);
#line 648
  return (tmp___1);
}
}
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static int iwlagn_send_tx_ant_config(struct iwl_priv *priv , u8 valid_tx_ant ) 
{ 
  struct iwl_tx_ant_config_cmd tx_ant_cmd ;
  int tmp ;

  {
#line 654
  tx_ant_cmd.valid = (unsigned int )valid_tx_ant;
#line 658
  if (((unsigned int )(priv->fw)->ucode_ver & 65280U) >> 8 > 1U) {
#line 659
    __iwl_dbg(priv->dev, 4U, 0, "iwlagn_send_tx_ant_config", "select valid tx ant: %u\n",
              (int )valid_tx_ant);
#line 660
    tmp = iwl_dvm_send_cmd_pdu(priv, 152, 0U, 4, (void const   *)(& tx_ant_cmd));
#line 660
    return (tmp);
  } else {
#line 664
    __iwl_dbg(priv->dev, 4U, 0, "iwlagn_send_tx_ant_config", "TX_ANT_CONFIGURATION_CMD not supported\n");
#line 665
    return (-95);
  }
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_send_bt_config(struct iwl_priv *priv ) 
{ 
  struct iwl_bt_cmd bt_cmd ;
  int tmp ;

  {
#line 671
  bt_cmd.flags = (unsigned char)0;
#line 671
  bt_cmd.lead_time = 30U;
#line 671
  bt_cmd.max_kill = 5U;
#line 671
  bt_cmd.reserved = (unsigned char)0;
#line 671
  bt_cmd.kill_ack_mask = 0U;
#line 671
  bt_cmd.kill_cts_mask = 0U;
#line 678
  if (! iwlwifi_mod_params.bt_coex_active) {
#line 679
    bt_cmd.flags = 0U;
  } else {
#line 681
    bt_cmd.flags = 3U;
  }
#line 683
  priv->bt_enable_flag = bt_cmd.flags;
#line 684
  __iwl_dbg(priv->dev, 1U, 0, "iwl_send_bt_config", "BT coex %s\n", (unsigned int )bt_cmd.flags == 0U ? (char *)"disable" : (char *)"active");
#line 687
  tmp = iwl_dvm_send_cmd_pdu(priv, 155, 0U, 12, (void const   *)(& bt_cmd));
#line 687
  if (tmp != 0) {
#line 689
    __iwl_err(priv->dev, 0, 0, "failed to send BT Coex Config\n");
  } else {

  }
#line 690
  return;
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
int iwl_alive_start(struct iwl_priv *priv ) 
{ 
  int ret ;
  struct iwl_rxon_context *ctx ;
  int tmp ;
  struct iwl_rxon_cmd *active_rxon ;
  struct iwl_rxon_context *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 699
  ret = 0;
#line 700
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 702
  __iwl_dbg(priv->dev, 1U, 0, "iwl_alive_start", "Runtime Alive received.\n");
#line 705
  set_bit(2L, (unsigned long volatile   *)(& priv->status));
#line 707
  tmp = iwl_is_rfkill(priv);
#line 707
  if (tmp != 0) {
#line 708
    return (-132);
  } else {

  }
#line 710
  if ((int )priv->event_log.ucode_trace) {
#line 712
    ldv_mod_timer_24(& priv->ucode_trace, jiffies);
  } else {

  }
#line 716
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 719
    if ((int )((priv->lib)->bt_params)->bt_sco_disable) {
#line 720
      priv->bt_enable_pspoll = 0;
    } else {
#line 722
      priv->bt_enable_pspoll = 1;
    }
#line 724
    priv->bt_valid = 255U;
#line 725
    priv->kill_ack_mask = 4294901760U;
#line 726
    priv->kill_cts_mask = 4294901760U;
#line 727
    iwlagn_send_advance_bt_config(priv);
#line 728
    priv->bt_valid = 1U;
#line 729
    priv->cur_rssi_ctx = (struct iwl_rxon_context *)0;
#line 731
    iwl_send_prio_tbl(priv);
#line 734
    ret = iwl_send_bt_env(priv, 1, 1);
#line 736
    if (ret != 0) {
#line 737
      return (ret);
    } else {

    }
#line 738
    ret = iwl_send_bt_env(priv, 0, 1);
#line 740
    if (ret != 0) {
#line 741
      return (ret);
    } else {

    }
  } else
#line 742
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
#line 746
    iwl_send_bt_config(priv);
  } else {

  }
#line 752
  iwlagn_send_calib_cfg_rt(priv, 2U);
#line 754
  ieee80211_wake_queues(priv->hw);
#line 757
  iwlagn_send_tx_ant_config(priv, (int )(priv->nvm_data)->valid_tx_ant);
#line 759
  tmp___1 = iwl_is_associated_ctx(ctx);
#line 759
  if (tmp___1 != 0 && ! priv->wowlan) {
#line 760
    active_rxon = (struct iwl_rxon_cmd *)(& ctx->active);
#line 763
    ctx->staging.filter_flags = ctx->staging.filter_flags | 32U;
#line 764
    active_rxon->filter_flags = active_rxon->filter_flags & 4294967263U;
  } else {
#line 768
    tmp___0 = (struct iwl_rxon_context *)(& priv->contexts);
#line 768
    goto ldv_55586;
    ldv_55585: ;
#line 768
    if ((int )((unsigned long )priv->valid_contexts >> (int )tmp___0->ctxid) & 1) {
#line 769
      iwl_connection_init_rx_config(priv, tmp___0);
    } else {

    }
#line 768
    tmp___0 = tmp___0 + 1;
    ldv_55586: ;
#line 768
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp___0) {
#line 770
      goto ldv_55585;
    } else {

    }
#line 771
    iwlagn_set_rxon_chain(priv, ctx);
  }
#line 774
  if (! priv->wowlan) {
#line 776
    iwl_reset_run_time_calib(priv);
  } else {

  }
#line 779
  set_bit(3L, (unsigned long volatile   *)(& priv->status));
#line 782
  ret = iwlagn_commit_rxon(priv, ctx);
#line 783
  if (ret != 0) {
#line 784
    return (ret);
  } else {

  }
#line 787
  iwl_rf_kill_ct_config(priv);
#line 789
  __iwl_dbg(priv->dev, 1U, 0, "iwl_alive_start", "ALIVE processing complete.\n");
#line 791
  tmp___2 = iwl_power_update_mode(priv, 1);
#line 791
  return (tmp___2);
}
}
#line 803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_clear_driver_stations(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;

  {
#line 807
  spin_lock_bh(& priv->sta_lock);
#line 808
  memset((void *)(& priv->stations), 0, 1664UL);
#line 809
  priv->num_stations = 0;
#line 811
  priv->ucode_key_table = 0UL;
#line 813
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 813
  goto ldv_55593;
  ldv_55592: ;
#line 813
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 821
    memset((void *)(& ctx->wep_keys), 0, 96UL);
#line 822
    ctx->key_mapping_keys = 0U;
  } else {

  }
#line 813
  ctx = ctx + 1;
  ldv_55593: ;
#line 813
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 815
    goto ldv_55592;
  } else {

  }
#line 825
  spin_unlock_bh(& priv->sta_lock);
#line 826
  return;
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
void iwl_down(struct iwl_priv *priv ) 
{ 
  int exit_pending ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 832
  __iwl_dbg(priv->dev, 1U, 0, "iwl_down", "iwlwifi is going down\n");
#line 834
  if (debug_locks != 0) {
#line 834
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 834
    if (tmp == 0) {
#line 834
      tmp___0 = 1;
    } else {
#line 834
      tmp___0 = 0;
    }
  } else {
#line 834
    tmp___0 = 0;
  }
#line 834
  __ret_warn_on = tmp___0;
#line 834
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 834
  if (tmp___1 != 0L) {
#line 834
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       834);
  } else {

  }
#line 834
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 836
  iwl_scan_cancel_timeout(priv, 200UL);
#line 838
  exit_pending = test_and_set_bit(5L, (unsigned long volatile   *)(& priv->status));
#line 841
  iwl_clear_ucode_stations(priv, (struct iwl_rxon_context *)0);
#line 842
  iwl_dealloc_bcast_stations(priv);
#line 843
  iwl_clear_driver_stations(priv);
#line 846
  priv->bt_status = 0U;
#line 847
  priv->cur_rssi_ctx = (struct iwl_rxon_context *)0;
#line 848
  priv->bt_is_sco = 0;
#line 849
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
#line 850
    priv->bt_traffic_load = ((priv->lib)->bt_params)->bt_init_traffic_load;
  } else {
#line 853
    priv->bt_traffic_load = 0U;
  }
#line 854
  priv->bt_full_concurrent = 0;
#line 855
  priv->bt_ci_compliance = 0U;
#line 859
  if (exit_pending == 0) {
#line 860
    clear_bit(5L, (unsigned long volatile   *)(& priv->status));
  } else {

  }
#line 862
  if ((unsigned int )priv->mac80211_registered != 0U) {
#line 863
    ieee80211_stop_queues(priv->hw);
  } else {

  }
#line 865
  priv->ucode_loaded = 0;
#line 866
  iwl_trans_stop_device(priv->trans);
#line 869
  atomic_set(& priv->num_aux_in_flight, 0);
#line 872
  tmp___2 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
#line 872
  tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->status));
#line 872
  tmp___4 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 872
  priv->status = priv->status & (unsigned long )((tmp___2 | (tmp___3 << 10)) | (tmp___4 << 5));
#line 879
  consume_skb(priv->beacon_skb);
#line 880
  priv->beacon_skb = (struct sk_buff *)0;
#line 881
  return;
}
}
#line 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_bg_run_time_calib_work(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 891
  __mptr = (struct work_struct  const  *)work;
#line 891
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcc30UL;
#line 894
  ldv_mutex_lock_25(& priv->mutex);
#line 896
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 896
  if (tmp != 0) {
#line 898
    ldv_mutex_unlock_26(& priv->mutex);
#line 899
    return;
  } else {
#line 896
    tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 896
    if (tmp___0 != 0) {
#line 898
      ldv_mutex_unlock_26(& priv->mutex);
#line 899
      return;
    } else {

    }
  }
#line 902
  if ((unsigned int )priv->start_calib != 0U) {
#line 903
    iwl_chain_noise_calibration(priv);
#line 904
    iwl_sensitivity_calibration(priv);
  } else {

  }
#line 907
  ldv_mutex_unlock_27(& priv->mutex);
#line 908
  return;
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
void iwlagn_prepare_restart(struct iwl_priv *priv ) 
{ 
  bool bt_full_concurrent ;
  u8 bt_ci_compliance ;
  u8 bt_load ;
  u8 bt_status ;
  bool bt_is_sco ;
  int i ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 919
  if (debug_locks != 0) {
#line 919
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 919
    if (tmp == 0) {
#line 919
      tmp___0 = 1;
    } else {
#line 919
      tmp___0 = 0;
    }
  } else {
#line 919
    tmp___0 = 0;
  }
#line 919
  __ret_warn_on = tmp___0;
#line 919
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 919
  if (tmp___1 != 0L) {
#line 919
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       919);
  } else {

  }
#line 919
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 921
  priv->is_open = 0U;
#line 932
  bt_full_concurrent = priv->bt_full_concurrent;
#line 933
  bt_ci_compliance = priv->bt_ci_compliance;
#line 934
  bt_load = priv->bt_traffic_load;
#line 935
  bt_status = priv->bt_status;
#line 936
  bt_is_sco = priv->bt_is_sco;
#line 938
  iwl_down(priv);
#line 940
  priv->bt_full_concurrent = bt_full_concurrent;
#line 941
  priv->bt_ci_compliance = bt_ci_compliance;
#line 942
  priv->bt_traffic_load = bt_load;
#line 943
  priv->bt_status = bt_status;
#line 944
  priv->bt_is_sco = bt_is_sco;
#line 947
  i = 11;
#line 947
  goto ldv_55620;
  ldv_55619: 
#line 948
  priv->queue_to_mac80211[i] = 255U;
#line 947
  i = i + 1;
  ldv_55620: ;
#line 947
  if (i <= 31) {
#line 949
    goto ldv_55619;
  } else {

  }
#line 950
  i = 0;
#line 950
  goto ldv_55623;
  ldv_55622: 
#line 951
  atomic_set((atomic_t *)(& priv->queue_stop_count) + (unsigned long )i, 0);
#line 950
  i = i + 1;
  ldv_55623: ;
#line 950
  if (i <= 31) {
#line 952
    goto ldv_55622;
  } else {

  }
#line 953
  memset((void *)(& priv->agg_q_alloc), 0, 8UL);
#line 954
  return;
}
}
#line 956 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_bg_restart(struct work_struct *data ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 958
  __mptr = (struct work_struct  const  *)data;
#line 958
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd130UL;
#line 960
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 960
  if (tmp != 0) {
#line 961
    return;
  } else {

  }
#line 963
  tmp___1 = test_and_clear_bit(10L, (unsigned long volatile   *)(& priv->status));
#line 963
  if (tmp___1 != 0) {
#line 964
    ldv_mutex_lock_28(& priv->mutex);
#line 965
    iwlagn_prepare_restart(priv);
#line 966
    ldv_mutex_unlock_29(& priv->mutex);
#line 967
    iwl_cancel_deferred_work(priv);
#line 968
    if ((unsigned int )priv->mac80211_registered != 0U) {
#line 969
      ieee80211_restart_hw(priv->hw);
    } else {
#line 971
      __iwl_err(priv->dev, 0, 0, "Cannot request restart before registrating with mac80211\n");
    }
  } else {
#line 974
    __ret_warn_on = 1;
#line 974
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 974
    if (tmp___0 != 0L) {
#line 974
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                         974);
    } else {

    }
#line 974
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 976
  return;
}
}
#line 984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_setup_deferred_work(struct iwl_priv *priv ) 
{ 
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___2 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___3 ;
  atomic_long_t __constr_expr_3 ;
  struct lock_class_key __key___4 ;
  atomic_long_t __constr_expr_4 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_5 ;

  {
#line 986
  __lock_name = "\"%s\"\"iwlwifi\"";
#line 986
  tmp = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)"iwlwifi");
#line 986
  priv->workqueue = tmp;
#line 988
  __init_work(& priv->restart, 0);
#line 988
  __constr_expr_0.counter = 137438953408L;
#line 988
  priv->restart.data = __constr_expr_0;
#line 988
  lockdep_init_map(& priv->restart.lockdep_map, "(&priv->restart)", & __key___0, 0);
#line 988
  INIT_LIST_HEAD(& priv->restart.entry);
#line 988
  priv->restart.func = & iwl_bg_restart;
#line 989
  __init_work(& priv->beacon_update, 0);
#line 989
  __constr_expr_1.counter = 137438953408L;
#line 989
  priv->beacon_update.data = __constr_expr_1;
#line 989
  lockdep_init_map(& priv->beacon_update.lockdep_map, "(&priv->beacon_update)", & __key___1,
                   0);
#line 989
  INIT_LIST_HEAD(& priv->beacon_update.entry);
#line 989
  priv->beacon_update.func = & iwl_bg_beacon_update;
#line 990
  __init_work(& priv->run_time_calib_work, 0);
#line 990
  __constr_expr_2.counter = 137438953408L;
#line 990
  priv->run_time_calib_work.data = __constr_expr_2;
#line 990
  lockdep_init_map(& priv->run_time_calib_work.lockdep_map, "(&priv->run_time_calib_work)",
                   & __key___2, 0);
#line 990
  INIT_LIST_HEAD(& priv->run_time_calib_work.entry);
#line 990
  priv->run_time_calib_work.func = & iwl_bg_run_time_calib_work;
#line 991
  __init_work(& priv->tx_flush, 0);
#line 991
  __constr_expr_3.counter = 137438953408L;
#line 991
  priv->tx_flush.data = __constr_expr_3;
#line 991
  lockdep_init_map(& priv->tx_flush.lockdep_map, "(&priv->tx_flush)", & __key___3,
                   0);
#line 991
  INIT_LIST_HEAD(& priv->tx_flush.entry);
#line 991
  priv->tx_flush.func = & iwl_bg_tx_flush;
#line 992
  __init_work(& priv->bt_full_concurrency, 0);
#line 992
  __constr_expr_4.counter = 137438953408L;
#line 992
  priv->bt_full_concurrency.data = __constr_expr_4;
#line 992
  lockdep_init_map(& priv->bt_full_concurrency.lockdep_map, "(&priv->bt_full_concurrency)",
                   & __key___4, 0);
#line 992
  INIT_LIST_HEAD(& priv->bt_full_concurrency.entry);
#line 992
  priv->bt_full_concurrency.func = & iwl_bg_bt_full_concurrency;
#line 993
  __init_work(& priv->bt_runtime_config, 0);
#line 993
  __constr_expr_5.counter = 137438953408L;
#line 993
  priv->bt_runtime_config.data = __constr_expr_5;
#line 993
  lockdep_init_map(& priv->bt_runtime_config.lockdep_map, "(&priv->bt_runtime_config)",
                   & __key___5, 0);
#line 993
  INIT_LIST_HEAD(& priv->bt_runtime_config.entry);
#line 993
  priv->bt_runtime_config.func = & iwl_bg_bt_runtime_config;
#line 995
  iwl_setup_scan_deferred_work(priv);
#line 997
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
#line 998
    iwlagn_bt_setup_deferred_work(priv);
  } else {

  }
#line 1000
  reg_timer_18(& priv->statistics_periodic, & iwl_bg_statistics_periodic, (unsigned long )priv);
#line 1003
  reg_timer_18(& priv->ucode_trace, & iwl_bg_ucode_trace, (unsigned long )priv);
#line 1004
  return;
}
}
#line 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
void iwl_cancel_deferred_work(struct iwl_priv *priv ) 
{ 


  {
#line 1009
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
#line 1010
    iwlagn_bt_cancel_deferred_work(priv);
  } else {

  }
#line 1012
  ldv_cancel_work_sync_30(& priv->run_time_calib_work);
#line 1013
  ldv_cancel_work_sync_31(& priv->beacon_update);
#line 1015
  iwl_cancel_scan_deferred_work(priv);
#line 1017
  ldv_cancel_work_sync_32(& priv->bt_full_concurrency);
#line 1018
  ldv_cancel_work_sync_33(& priv->bt_runtime_config);
#line 1020
  ldv_del_timer_sync_34(& priv->statistics_periodic);
#line 1021
  ldv_del_timer_sync_35(& priv->ucode_trace);
#line 1022
  return;
}
}
#line 1024 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static int iwl_init_drv(struct iwl_priv *priv ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 1026
  spinlock_check(& priv->sta_lock);
#line 1026
  __raw_spin_lock_init(& priv->sta_lock.__annonCompField17.rlock, "&(&priv->sta_lock)->rlock",
                       & __key);
#line 1028
  __mutex_init(& priv->mutex, "&priv->mutex", & __key___0);
#line 1030
  INIT_LIST_HEAD(& priv->calib_results);
#line 1032
  priv->band = 0;
#line 1034
  priv->plcp_delta_threshold = (priv->lib)->plcp_delta_threshold;
#line 1036
  priv->iw_mode = 2;
#line 1037
  priv->current_ht_config.smps = 2;
#line 1038
  priv->missed_beacon_threshold = 5;
#line 1039
  priv->agg_tids_count = 0U;
#line 1041
  priv->rx_statistics_jiffies = jiffies;
#line 1044
  iwlagn_set_rxon_chain(priv, (struct iwl_rxon_context *)(& priv->contexts));
#line 1046
  iwl_init_scan_params(priv);
#line 1049
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 1051
    priv->kill_ack_mask = 4294901760U;
#line 1052
    priv->kill_cts_mask = 4294901760U;
#line 1053
    priv->bt_valid = 255U;
#line 1054
    priv->bt_on_thresh = 4U;
#line 1055
    priv->bt_duration = 625U;
#line 1056
    priv->dynamic_frag_thresh = 0U;
  } else {

  }
#line 1059
  return (0);
}
}
#line 1062 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_uninit_drv(struct iwl_priv *priv ) 
{ 
  struct iwl_wipan_noa_data *________p1 ;
  struct iwl_wipan_noa_data *_________p1 ;
  union __anonunion___u_488 __u ;
  int tmp ;

  {
#line 1064
  kfree((void const   *)priv->scan_cmd);
#line 1065
  kfree((void const   *)priv->beacon_cmd);
#line 1066
  __read_once_size((void const volatile   *)(& priv->noa_data), (void *)(& __u.__c),
                   8);
#line 1066
  _________p1 = __u.__val;
#line 1066
  ________p1 = _________p1;
#line 1066
  tmp = debug_lockdep_rcu_enabled();
#line 1066
  kfree((void const   *)________p1);
#line 1067
  iwl_calib_free_results(priv);
#line 1069
  kfree((void const   *)priv->wowlan_sram);
#line 1070
  return;
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
#line 1075
  if ((unsigned long )(priv->cfg)->ht_params != (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) {
#line 1076
    priv->hw_params.use_rts_for_aggregation = ((priv->cfg)->ht_params)->use_rts_for_aggregation;
  } else {

  }
#line 1080
  (*((priv->lib)->set_hw_params))(priv);
#line 1081
  return;
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_option_config(struct iwl_priv *priv ) 
{ 


  {
#line 1089
  __iwl_info(priv->dev, "CONFIG_IWLWIFI_DEBUG enabled\n");
#line 1095
  __iwl_info(priv->dev, "CONFIG_IWLWIFI_DEBUGFS enabled\n");
#line 1101
  __iwl_info(priv->dev, "CONFIG_IWLWIFI_DEVICE_TRACING enabled\n");
#line 1102
  return;
}
}
#line 1107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static int iwl_eeprom_init_hw_params(struct iwl_priv *priv ) 
{ 
  struct iwl_nvm_data *data ;

  {
#line 1109
  data = priv->nvm_data;
#line 1111
  if ((int )data->sku_cap_11n_enable && (unsigned long )(priv->cfg)->ht_params == (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) {
#line 1113
    __iwl_err(priv->dev, 0, 0, "Invalid 11n configuration\n");
#line 1114
    return (-22);
  } else {

  }
#line 1117
  if ((! data->sku_cap_11n_enable && ! data->sku_cap_band_24GHz_enable) && ! data->sku_cap_band_52GHz_enable) {
#line 1119
    __iwl_err(priv->dev, 0, 0, "Invalid device sku\n");
#line 1120
    return (-22);
  } else {

  }
#line 1123
  __iwl_dbg(priv->dev, 1U, 0, "iwl_eeprom_init_hw_params", "Device SKU: 24GHz %s %s, 52GHz %s %s, 11.n %s %s\n",
            (int )data->sku_cap_band_24GHz_enable ? (char *)"" : (char *)"NOT", (char *)"enabled",
            (int )data->sku_cap_band_52GHz_enable ? (char *)"" : (char *)"NOT", (char *)"enabled",
            (int )data->sku_cap_11n_enable ? (char *)"" : (char *)"NOT", (char *)"enabled");
#line 1129
  priv->hw_params.tx_chains_num = num_of_ant((int )data->valid_tx_ant);
#line 1131
  if ((int )(priv->cfg)->rx_with_siso_diversity) {
#line 1132
    priv->hw_params.rx_chains_num = 1U;
  } else {
#line 1134
    priv->hw_params.rx_chains_num = num_of_ant((int )data->valid_rx_ant);
  }
#line 1137
  __iwl_dbg(priv->dev, 1U, 0, "iwl_eeprom_init_hw_params", "Valid Tx ant: 0x%X, Valid Rx ant: 0x%X\n",
            (int )data->valid_tx_ant, (int )data->valid_rx_ant);
#line 1141
  return (0);
}
}
#line 1144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans , struct iwl_cfg  const  *cfg ,
                                                 struct iwl_fw  const  *fw , struct dentry *dbgfs_dir ) 
{ 
  struct iwl_priv *priv ;
  struct ieee80211_hw *hw ;
  struct iwl_op_mode *op_mode ;
  u16 num_mac ;
  u32 ucode_flags ;
  struct iwl_trans_config trans_cfg ;
  u8 no_reclaim_cmds[5U] ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  struct lock_class_key __key ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1154
  trans_cfg.op_mode = 0;
#line 1154
  trans_cfg.cmd_queue = (unsigned char)0;
#line 1154
  trans_cfg.cmd_fifo = (unsigned char)0;
#line 1154
  trans_cfg.cmd_q_wdg_timeout = 0U;
#line 1154
  trans_cfg.no_reclaim_cmds = 0;
#line 1154
  trans_cfg.n_no_reclaim_cmds = 0U;
#line 1154
  trans_cfg.rx_buf_size_8k = (_Bool)0;
#line 1154
  trans_cfg.bc_table_dword = (_Bool)0;
#line 1154
  trans_cfg.scd_set_active = (_Bool)0;
#line 1154
  trans_cfg.command_names = 0;
#line 1154
  trans_cfg.sdio_adma_addr = 0U;
#line 1155
  no_reclaim_cmds[0] = 192U;
#line 1155
  no_reclaim_cmds[1] = 193U;
#line 1155
  no_reclaim_cmds[2] = 197U;
#line 1155
  no_reclaim_cmds[3] = 157U;
#line 1155
  no_reclaim_cmds[4] = 28U;
#line 1167
  hw = iwl_alloc_all();
#line 1168
  if ((unsigned long )hw == (unsigned long )((struct ieee80211_hw *)0)) {
#line 1169
    printk("\viwldvm: %s: Cannot allocate network device\n", cfg->name);
#line 1170
    goto out;
  } else {

  }
#line 1173
  op_mode = (struct iwl_op_mode *)hw->priv;
#line 1174
  op_mode->ops = & iwl_dvm_ops;
#line 1175
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1176
  priv->trans = trans;
#line 1177
  priv->dev = trans->dev;
#line 1178
  priv->cfg = cfg;
#line 1179
  priv->fw = fw;
#line 1181
  switch ((unsigned int )(priv->cfg)->device_family) {
  case 1U: ;
  case 2U: 
#line 1184
  priv->lib = & iwl_dvm_1000_cfg;
#line 1185
  goto ldv_55700;
  case 3U: 
#line 1187
  priv->lib = & iwl_dvm_2000_cfg;
#line 1188
  goto ldv_55700;
  case 5U: 
#line 1190
  priv->lib = & iwl_dvm_105_cfg;
#line 1191
  goto ldv_55700;
  case 4U: ;
  case 6U: 
#line 1194
  priv->lib = & iwl_dvm_2030_cfg;
#line 1195
  goto ldv_55700;
  case 7U: 
#line 1197
  priv->lib = & iwl_dvm_5000_cfg;
#line 1198
  goto ldv_55700;
  case 8U: 
#line 1200
  priv->lib = & iwl_dvm_5150_cfg;
#line 1201
  goto ldv_55700;
  case 9U: ;
  case 10U: 
#line 1204
  priv->lib = & iwl_dvm_6000_cfg;
#line 1205
  goto ldv_55700;
  case 11U: 
#line 1207
  priv->lib = & iwl_dvm_6005_cfg;
#line 1208
  goto ldv_55700;
  case 13U: ;
  case 14U: 
#line 1211
  priv->lib = & iwl_dvm_6050_cfg;
#line 1212
  goto ldv_55700;
  case 12U: 
#line 1214
  priv->lib = & iwl_dvm_6030_cfg;
#line 1215
  goto ldv_55700;
  default: ;
#line 1217
  goto ldv_55700;
  }
  ldv_55700: 
#line 1220
  __ret_warn_on = (unsigned long )priv->lib == (unsigned long )((struct iwl_dvm_cfg  const  *)0);
#line 1220
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1220
  if (tmp != 0L) {
#line 1220
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       1220);
  } else {

  }
#line 1220
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1220
  if (tmp___0 != 0L) {
#line 1221
    goto out_free_hw;
  } else {

  }
#line 1227
  trans_cfg.op_mode = op_mode;
#line 1228
  trans_cfg.no_reclaim_cmds = (u8 const   *)(& no_reclaim_cmds);
#line 1229
  trans_cfg.n_no_reclaim_cmds = 5U;
#line 1230
  trans_cfg.rx_buf_size_8k = iwlwifi_mod_params.amsdu_size_8K != 0;
#line 1231
  trans_cfg.cmd_q_wdg_timeout = 0U;
#line 1233
  trans_cfg.command_names = (char const   * const  *)(& iwl_dvm_cmd_strings);
#line 1234
  trans_cfg.cmd_fifo = 7U;
#line 1236
  __ret_warn_on___0 = (unsigned int )((priv->cfg)->base_params)->num_of_queues > 64U;
#line 1236
  tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1236
  if (tmp___1 != 0L) {
#line 1236
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       1237);
  } else {

  }
#line 1236
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1239
  ucode_flags = fw->ucode_capa.flags;
#line 1241
  if ((int )ucode_flags & 1) {
#line 1242
    priv->sta_key_max_num = 16U;
#line 1243
    trans_cfg.cmd_queue = 9U;
  } else {
#line 1245
    priv->sta_key_max_num = 8U;
#line 1246
    trans_cfg.cmd_queue = 4U;
  }
#line 1250
  iwl_trans_configure(priv->trans, (struct iwl_trans_config  const  *)(& trans_cfg));
#line 1252
  trans->rx_mpdu_cmd = 193U;
#line 1253
  trans->rx_mpdu_cmd_hdr_size = 4U;
#line 1257
  SET_IEEE80211_DEV(priv->hw, (priv->trans)->dev);
#line 1259
  iwl_option_config(priv);
#line 1261
  __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_start", "*** LOAD DRIVER ***\n");
#line 1264
  priv->bt_ant_couple_ok = iwlwifi_mod_params.ant_coupling > 35;
#line 1270
  priv->bt_ch_announce = 1;
#line 1271
  __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_start", "BT channel inhibition is %s\n",
            (int )priv->bt_ch_announce ? (char *)"On" : (char *)"Off");
#line 1277
  spinlock_check(& priv->statistics.lock);
#line 1277
  __raw_spin_lock_init(& priv->statistics.lock.__annonCompField17.rlock, "&(&priv->statistics.lock)->rlock",
                       & __key);
#line 1282
  __iwl_info(priv->dev, "Detected %s, REV=0x%X\n", (priv->cfg)->name, (priv->trans)->hw_rev);
#line 1285
  tmp___2 = iwl_trans_start_hw(priv->trans);
#line 1285
  if (tmp___2 != 0) {
#line 1286
    goto out_free_hw;
  } else {

  }
#line 1289
  tmp___3 = iwl_read_eeprom(priv->trans, & priv->eeprom_blob, & priv->eeprom_blob_size);
#line 1289
  if (tmp___3 != 0) {
#line 1291
    __iwl_err(priv->dev, 0, 0, "Unable to init EEPROM\n");
#line 1292
    goto out_free_hw;
  } else {

  }
#line 1296
  iwl_trans_stop_device(priv->trans);
#line 1298
  priv->nvm_data = iwl_parse_eeprom_data((priv->trans)->dev, priv->cfg, (u8 const   *)priv->eeprom_blob,
                                         priv->eeprom_blob_size);
#line 1301
  if ((unsigned long )priv->nvm_data == (unsigned long )((struct iwl_nvm_data *)0)) {
#line 1302
    goto out_free_eeprom_blob;
  } else {

  }
#line 1304
  tmp___4 = iwl_nvm_check_version(priv->nvm_data, priv->trans);
#line 1304
  if (tmp___4 != 0) {
#line 1305
    goto out_free_eeprom;
  } else {

  }
#line 1307
  tmp___5 = iwl_eeprom_init_hw_params(priv);
#line 1307
  if (tmp___5 != 0) {
#line 1308
    goto out_free_eeprom;
  } else {

  }
#line 1311
  memcpy((void *)(& priv->addresses[0].addr), (void const   *)(& (priv->nvm_data)->hw_addr),
           6UL);
#line 1312
  __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_start", "MAC address: %pM\n", (u8 *)(& priv->addresses[0].addr));
#line 1313
  ((priv->hw)->wiphy)->addresses = (struct mac_address *)(& priv->addresses);
#line 1314
  ((priv->hw)->wiphy)->n_addresses = 1U;
#line 1315
  num_mac = (u16 )(priv->nvm_data)->n_hw_addrs;
#line 1316
  if ((unsigned int )num_mac > 1U) {
#line 1317
    memcpy((void *)(& priv->addresses[1].addr), (void const   *)(& priv->addresses[0].addr),
             6UL);
#line 1319
    priv->addresses[1].addr[5] = (u8 )((int )priv->addresses[1].addr[5] + 1);
#line 1320
    ((priv->hw)->wiphy)->n_addresses = (u16 )((int )((priv->hw)->wiphy)->n_addresses + 1);
  } else {

  }
#line 1326
  iwl_set_hw_params(priv);
#line 1328
  if (! (priv->nvm_data)->sku_cap_ipan_enable) {
#line 1329
    __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_start", "Your EEPROM disabled PAN\n");
#line 1330
    ucode_flags = ucode_flags & 4294967294U;
#line 1335
    priv->sta_key_max_num = 8U;
#line 1336
    trans_cfg.cmd_queue = 4U;
#line 1339
    iwl_trans_configure(priv->trans, (struct iwl_trans_config  const  *)(& trans_cfg));
  } else {

  }
#line 1345
  i = 0;
#line 1345
  goto ldv_55726;
  ldv_55725: 
#line 1346
  priv->queue_to_mac80211[i] = 255U;
#line 1347
  if ((i <= 10 && i != 4) && i != 9) {
#line 1350
    priv->queue_to_mac80211[i] = (u8 )i;
  } else {

  }
#line 1351
  atomic_set((atomic_t *)(& priv->queue_stop_count) + (unsigned long )i, 0);
#line 1345
  i = i + 1;
  ldv_55726: ;
#line 1345
  if (i <= 31) {
#line 1347
    goto ldv_55725;
  } else {

  }
#line 1354
  tmp___6 = iwl_init_drv(priv);
#line 1354
  if (tmp___6 != 0) {
#line 1355
    goto out_free_eeprom;
  } else {

  }
#line 1362
  iwl_setup_deferred_work(priv);
#line 1363
  iwl_setup_rx_handlers(priv);
#line 1365
  iwl_power_initialize(priv);
#line 1366
  iwl_tt_initialize(priv);
#line 1368
  snprintf((char *)(& ((priv->hw)->wiphy)->fw_version), 32UL, "%s", (char const   *)(& fw->fw_version));
#line 1372
  priv->new_scan_threshold_behaviour = (ucode_flags & 2U) != 0U;
#line 1375
  priv->phy_calib_chain_noise_reset_cmd = (u8 )fw->ucode_capa.standard_phy_calibration_size;
#line 1377
  priv->phy_calib_chain_noise_gain_cmd = (unsigned int )((u8 )fw->ucode_capa.standard_phy_calibration_size) + 1U;
#line 1381
  iwl_init_context(priv, ucode_flags);
#line 1388
  tmp___7 = iwlagn_mac_setup_register(priv, & fw->ucode_capa);
#line 1388
  if (tmp___7 != 0) {
#line 1389
    goto out_destroy_workqueue;
  } else {

  }
#line 1391
  tmp___8 = iwl_dbgfs_register(priv, dbgfs_dir);
#line 1391
  if (tmp___8 != 0) {
#line 1392
    goto out_mac80211_unregister;
  } else {

  }
#line 1394
  return (op_mode);
  out_mac80211_unregister: 
#line 1397
  iwlagn_mac_unregister(priv);
  out_destroy_workqueue: 
#line 1399
  iwl_tt_exit(priv);
#line 1400
  iwl_cancel_deferred_work(priv);
#line 1401
  ldv_destroy_workqueue_36(priv->workqueue);
#line 1402
  priv->workqueue = (struct workqueue_struct *)0;
#line 1403
  iwl_uninit_drv(priv);
  out_free_eeprom_blob: 
#line 1405
  kfree((void const   *)priv->eeprom_blob);
  out_free_eeprom: 
#line 1407
  iwl_free_nvm_data(priv->nvm_data);
  out_free_hw: 
#line 1409
  ldv_ieee80211_free_hw_37(priv->hw);
  out: 
#line 1411
  op_mode = (struct iwl_op_mode *)0;
#line 1412
  return (op_mode);
}
}
#line 1415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_op_mode_dvm_stop(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;

  {
#line 1417
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1419
  __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_stop", "*** UNLOAD DRIVER ***\n");
#line 1421
  iwlagn_mac_unregister(priv);
#line 1423
  iwl_tt_exit(priv);
#line 1425
  kfree((void const   *)priv->eeprom_blob);
#line 1426
  iwl_free_nvm_data(priv->nvm_data);
#line 1429
  ldv_flush_workqueue_38(priv->workqueue);
#line 1434
  ldv_destroy_workqueue_39(priv->workqueue);
#line 1435
  priv->workqueue = (struct workqueue_struct *)0;
#line 1437
  iwl_uninit_drv(priv);
#line 1439
  consume_skb(priv->beacon_skb);
#line 1441
  iwl_trans_op_mode_leave(priv->trans);
#line 1442
  ldv_ieee80211_free_hw_40(priv->hw);
#line 1443
  return;
}
}
#line 1445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static char const   * const  desc_lookup_text[28U]  = 
#line 1445
  {      "OK",      "FAIL",      "BAD_PARAM",      "BAD_CHECKSUM", 
        "NMI_INTERRUPT_WDG",      "SYSASSERT",      "FATAL_ERROR",      "BAD_COMMAND", 
        "HW_ERROR_TUNE_LOCK",      "HW_ERROR_TEMPERATURE",      "ILLEGAL_CHAN_FREQ",      "VCC_NOT_STABLE", 
        "FH_ERROR",      "NMI_INTERRUPT_HOST",      "NMI_INTERRUPT_ACTION_PT",      "NMI_INTERRUPT_UNKNOWN", 
        "UCODE_VERSION_MISMATCH",      "HW_ERROR_ABS_LOCK",      "HW_ERROR_CAL_LOCK_FAIL",      "NMI_INTERRUPT_INST_ACTION_PT", 
        "NMI_INTERRUPT_DATA_ACTION_PT",      "NMI_TRM_HW_ER",      "NMI_INTERRUPT_TRM",      "NMI_INTERRUPT_BREAK_POINT", 
        "DEBUG_0",      "DEBUG_1",      "DEBUG_2",      "DEBUG_3"};
#line 1476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static struct __anonstruct_advanced_lookup_490 advanced_lookup[16U]  = 
#line 1476
  {      {(char *)"NMI_INTERRUPT_WDG", 52U}, 
        {(char *)"SYSASSERT", 53U}, 
        {(char *)"UCODE_VERSION_MISMATCH", 55U}, 
        {(char *)"BAD_COMMAND", 56U}, 
        {(char *)"NMI_INTERRUPT_DATA_ACTION_PT", 60U}, 
        {(char *)"FATAL_ERROR", 61U}, 
        {(char *)"NMI_TRM_HW_ERR", 70U}, 
        {(char *)"NMI_INTERRUPT_TRM", 76U}, 
        {(char *)"NMI_INTERRUPT_BREAK_POINT", 84U}, 
        {(char *)"NMI_INTERRUPT_WDG_RXF_FULL", 92U}, 
        {(char *)"NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL", 100U}, 
        {(char *)"NMI_INTERRUPT_HOST", 102U}, 
        {(char *)"NMI_INTERRUPT_ACTION_PT", 124U}, 
        {(char *)"NMI_INTERRUPT_UNKNOWN", 132U}, 
        {(char *)"NMI_INTERRUPT_INST_ACTION_PT", 134U}, 
        {(char *)"ADVANCED_SYSASSERT", 0U}};
#line 1495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static char const   *desc_lookup(u32 num ) 
{ 
  int i ;
  int max ;

  {
#line 1498
  max = 28;
#line 1500
  if ((u32 )max > num) {
#line 1501
    return ((char const   *)desc_lookup_text[num]);
  } else {

  }
#line 1503
  max = 15;
#line 1504
  i = 0;
#line 1504
  goto ldv_55751;
  ldv_55750: ;
#line 1505
  if ((u32 )advanced_lookup[i].num == num) {
#line 1506
    goto ldv_55749;
  } else {

  }
#line 1504
  i = i + 1;
  ldv_55751: ;
#line 1504
  if (i < max) {
#line 1506
    goto ldv_55750;
  } else {

  }
  ldv_55749: ;
#line 1508
  return ((char const   *)advanced_lookup[i].name);
}
}
#line 1514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_dump_nic_error_log(struct iwl_priv *priv ) 
{ 
  struct iwl_trans *trans ;
  u32 base ;
  struct iwl_error_event_table table ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 1516
  trans = priv->trans;
#line 1520
  base = priv->device_pointers.error_event_table;
#line 1521
  if ((unsigned int )priv->cur_ucode == 1U) {
#line 1522
    if (base == 0U) {
#line 1523
      base = (priv->fw)->init_errlog_ptr;
    } else {

    }
  } else
#line 1525
  if (base == 0U) {
#line 1526
    base = (priv->fw)->inst_errlog_ptr;
  } else {

  }
#line 1529
  tmp = iwlagn_hw_valid_rtc_data_addr(base);
#line 1529
  if (tmp == 0) {
#line 1530
    __iwl_err(priv->dev, 0, 0, "Not valid error log pointer 0x%08X for %s uCode\n",
              base, (unsigned int )priv->cur_ucode == 1U ? (char *)"Init" : (char *)"RT");
#line 1535
    return;
  } else {

  }
#line 1539
  iwl_trans_read_mem(trans, base, (void *)(& table), 37);
#line 1541
  if ((unsigned long )table.valid * 28UL > 3UL) {
#line 1542
    __iwl_err(trans->dev, 0, 0, "Start IWL Error Log Dump:\n");
#line 1543
    __iwl_err(trans->dev, 0, 0, "Status: 0x%08lX, count: %d\n", priv->status, table.valid);
  } else {

  }
#line 1547
  trace_iwlwifi_dev_ucode_error((struct device  const  *)trans->dev, table.error_id,
                                table.tsf_low, table.data1, table.data2, table.line,
                                table.blink1, table.blink2, table.ilink1, table.ilink2,
                                table.bcon_time, table.gp1, table.gp2, table.gp3,
                                table.ucode_ver, table.hw_ver, 0U, table.brd_ver);
#line 1553
  tmp___0 = desc_lookup(table.error_id);
#line 1553
  __iwl_err(priv->dev, 0, 0, "0x%08X | %-28s\n", table.error_id, tmp___0);
#line 1555
  __iwl_err(priv->dev, 0, 0, "0x%08X | uPc\n", table.pc);
#line 1556
  __iwl_err(priv->dev, 0, 0, "0x%08X | branchlink1\n", table.blink1);
#line 1557
  __iwl_err(priv->dev, 0, 0, "0x%08X | branchlink2\n", table.blink2);
#line 1558
  __iwl_err(priv->dev, 0, 0, "0x%08X | interruptlink1\n", table.ilink1);
#line 1559
  __iwl_err(priv->dev, 0, 0, "0x%08X | interruptlink2\n", table.ilink2);
#line 1560
  __iwl_err(priv->dev, 0, 0, "0x%08X | data1\n", table.data1);
#line 1561
  __iwl_err(priv->dev, 0, 0, "0x%08X | data2\n", table.data2);
#line 1562
  __iwl_err(priv->dev, 0, 0, "0x%08X | line\n", table.line);
#line 1563
  __iwl_err(priv->dev, 0, 0, "0x%08X | beacon time\n", table.bcon_time);
#line 1564
  __iwl_err(priv->dev, 0, 0, "0x%08X | tsf low\n", table.tsf_low);
#line 1565
  __iwl_err(priv->dev, 0, 0, "0x%08X | tsf hi\n", table.tsf_hi);
#line 1566
  __iwl_err(priv->dev, 0, 0, "0x%08X | time gp1\n", table.gp1);
#line 1567
  __iwl_err(priv->dev, 0, 0, "0x%08X | time gp2\n", table.gp2);
#line 1568
  __iwl_err(priv->dev, 0, 0, "0x%08X | time gp3\n", table.gp3);
#line 1569
  __iwl_err(priv->dev, 0, 0, "0x%08X | uCode version\n", table.ucode_ver);
#line 1570
  __iwl_err(priv->dev, 0, 0, "0x%08X | hw version\n", table.hw_ver);
#line 1571
  __iwl_err(priv->dev, 0, 0, "0x%08X | board version\n", table.brd_ver);
#line 1572
  __iwl_err(priv->dev, 0, 0, "0x%08X | hcmd\n", table.hcmd);
#line 1573
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr0\n", table.isr0);
#line 1574
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr1\n", table.isr1);
#line 1575
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr2\n", table.isr2);
#line 1576
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr3\n", table.isr3);
#line 1577
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr4\n", table.isr4);
#line 1578
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr_pref\n", table.isr_pref);
#line 1579
  __iwl_err(priv->dev, 0, 0, "0x%08X | wait_event\n", table.wait_event);
#line 1580
  __iwl_err(priv->dev, 0, 0, "0x%08X | l2p_control\n", table.l2p_control);
#line 1581
  __iwl_err(priv->dev, 0, 0, "0x%08X | l2p_duration\n", table.l2p_duration);
#line 1582
  __iwl_err(priv->dev, 0, 0, "0x%08X | l2p_mhvalid\n", table.l2p_mhvalid);
#line 1583
  __iwl_err(priv->dev, 0, 0, "0x%08X | l2p_addr_match\n", table.l2p_addr_match);
#line 1584
  __iwl_err(priv->dev, 0, 0, "0x%08X | lmpm_pmg_sel\n", table.lmpm_pmg_sel);
#line 1585
  __iwl_err(priv->dev, 0, 0, "0x%08X | timestamp\n", table.u_timestamp);
#line 1586
  __iwl_err(priv->dev, 0, 0, "0x%08X | flow_handler\n", table.flow_handler);
#line 1587
  return;
}
}
#line 1595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static int iwl_print_event_log(struct iwl_priv *priv , u32 start_idx , u32 num_events ,
                               u32 mode , int pos , char **buf , size_t bufsz ) 
{ 
  u32 i ;
  u32 base ;
  u32 event_size ;
  u32 ptr ;
  u32 ev ;
  u32 time ;
  u32 data ;
  unsigned long reg_flags ;
  struct iwl_trans *trans ;
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1606
  trans = priv->trans;
#line 1608
  if (num_events == 0U) {
#line 1609
    return (pos);
  } else {

  }
#line 1611
  base = priv->device_pointers.log_event_table;
#line 1612
  if ((unsigned int )priv->cur_ucode == 1U) {
#line 1613
    if (base == 0U) {
#line 1614
      base = (priv->fw)->init_evtlog_ptr;
    } else {

    }
  } else
#line 1616
  if (base == 0U) {
#line 1617
    base = (priv->fw)->inst_evtlog_ptr;
  } else {

  }
#line 1620
  if (mode == 0U) {
#line 1621
    event_size = 8U;
  } else {
#line 1623
    event_size = 12U;
  }
#line 1625
  ptr = (start_idx * event_size + base) + 16U;
#line 1628
  tmp = (*((trans->ops)->grab_nic_access))(trans, 0, & reg_flags);
#line 1628
  tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 1628
  if (tmp___0 == 0L) {
#line 1629
    return (pos);
  } else {

  }
#line 1632
  iwl_write32(trans, 1036U, ptr);
#line 1636
  i = 0U;
#line 1636
  goto ldv_55777;
  ldv_55776: 
#line 1637
  ev = iwl_read32(trans, 1052U);
#line 1638
  time = iwl_read32(trans, 1052U);
#line 1639
  if (mode == 0U) {
#line 1641
    if (bufsz != 0UL) {
#line 1642
      tmp___1 = scnprintf(*buf + (unsigned long )pos, bufsz - (size_t )pos, "EVT_LOG:0x%08x:%04u\n",
                          time, ev);
#line 1642
      pos = tmp___1 + pos;
    } else {
#line 1646
      trace_iwlwifi_dev_ucode_event((struct device  const  *)trans->dev, 0U, time,
                                    ev);
#line 1648
      __iwl_err(priv->dev, 0, 0, "EVT_LOG:0x%08x:%04u\n", time, ev);
    }
  } else {
#line 1652
    data = iwl_read32(trans, 1052U);
#line 1653
    if (bufsz != 0UL) {
#line 1654
      tmp___2 = scnprintf(*buf + (unsigned long )pos, bufsz - (size_t )pos, "EVT_LOGT:%010u:0x%08x:%04u\n",
                          time, data, ev);
#line 1654
      pos = tmp___2 + pos;
    } else {
#line 1658
      __iwl_err(priv->dev, 0, 0, "EVT_LOGT:%010u:0x%08x:%04u\n", time, data, ev);
#line 1660
      trace_iwlwifi_dev_ucode_event((struct device  const  *)trans->dev, time, data,
                                    ev);
    }
  }
#line 1636
  i = i + 1U;
  ldv_55777: ;
#line 1636
  if (i < num_events) {
#line 1638
    goto ldv_55776;
  } else {

  }
#line 1667
  iwl_trans_release_nic_access(trans, & reg_flags);
#line 1668
  return (pos);
}
}
#line 1674 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static int iwl_print_last_event_logs(struct iwl_priv *priv , u32 capacity , u32 num_wraps ,
                                     u32 next_entry , u32 size , u32 mode , int pos ,
                                     char **buf , size_t bufsz ) 
{ 


  {
#line 1683
  if (num_wraps != 0U) {
#line 1684
    if (next_entry < size) {
#line 1685
      pos = iwl_print_event_log(priv, (next_entry - size) + capacity, size - next_entry,
                                mode, pos, buf, bufsz);
#line 1689
      pos = iwl_print_event_log(priv, 0U, next_entry, mode, pos, buf, bufsz);
    } else {
#line 1693
      pos = iwl_print_event_log(priv, next_entry - size, size, mode, pos, buf, bufsz);
    }
  } else
#line 1696
  if (next_entry < size) {
#line 1697
    pos = iwl_print_event_log(priv, 0U, next_entry, mode, pos, buf, bufsz);
  } else {
#line 1700
    pos = iwl_print_event_log(priv, next_entry - size, size, mode, pos, buf, bufsz);
  }
#line 1704
  return (pos);
}
}
#line 1709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
int iwl_dump_nic_event_log(struct iwl_priv *priv , bool full_log , char **buf ) 
{ 
  u32 base ;
  u32 capacity ;
  u32 mode ;
  u32 num_wraps ;
  u32 next_entry ;
  u32 size ;
  u32 logsize ;
  int pos ;
  size_t bufsz ;
  struct iwl_trans *trans ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  bool tmp___3 ;

  {
#line 1719
  pos = 0;
#line 1720
  bufsz = 0UL;
#line 1721
  trans = priv->trans;
#line 1723
  base = priv->device_pointers.log_event_table;
#line 1724
  if ((unsigned int )priv->cur_ucode == 1U) {
#line 1725
    logsize = (priv->fw)->init_evtlog_size;
#line 1726
    if (base == 0U) {
#line 1727
      base = (priv->fw)->init_evtlog_ptr;
    } else {

    }
  } else {
#line 1729
    logsize = (priv->fw)->inst_evtlog_size;
#line 1730
    if (base == 0U) {
#line 1731
      base = (priv->fw)->inst_evtlog_ptr;
    } else {

    }
  }
#line 1734
  tmp = iwlagn_hw_valid_rtc_data_addr(base);
#line 1734
  if (tmp == 0) {
#line 1735
    __iwl_err(priv->dev, 0, 0, "Invalid event log pointer 0x%08X for %s uCode\n",
              base, (unsigned int )priv->cur_ucode == 1U ? (char *)"Init" : (char *)"RT");
#line 1740
    return (-22);
  } else {

  }
#line 1744
  capacity = iwl_trans_read_mem32(trans, base);
#line 1745
  mode = iwl_trans_read_mem32(trans, base + 4U);
#line 1746
  num_wraps = iwl_trans_read_mem32(trans, base + 8U);
#line 1747
  next_entry = iwl_trans_read_mem32(trans, base + 12U);
#line 1749
  if (capacity > logsize) {
#line 1750
    __iwl_err(priv->dev, 0, 0, "Log capacity %d is bogus, limit to %d entries\n",
              capacity, logsize);
#line 1752
    capacity = logsize;
  } else {

  }
#line 1755
  if (next_entry > logsize) {
#line 1756
    __iwl_err(priv->dev, 0, 0, "Log write index %d is bogus, limit to %d\n", next_entry,
              logsize);
#line 1758
    next_entry = logsize;
  } else {

  }
#line 1761
  size = num_wraps != 0U ? capacity : next_entry;
#line 1764
  if (size == 0U) {
#line 1765
    __iwl_err(trans->dev, 0, 0, "Start IWL Event Log Dump: nothing in log\n");
#line 1766
    return (pos);
  } else {

  }
#line 1769
  tmp___0 = iwl_have_debug_level(262144U);
#line 1769
  if (tmp___0) {
#line 1769
    tmp___1 = 0;
  } else {
#line 1769
    tmp___1 = 1;
  }
#line 1769
  if (tmp___1 && ! full_log) {
#line 1770
    size = 20U < size ? 20U : size;
  } else {

  }
#line 1772
  __iwl_err(priv->dev, 0, 0, "Start IWL Event Log Dump: display last %u entries\n",
            size);
#line 1776
  if ((unsigned long )buf != (unsigned long )((char **)0)) {
#line 1777
    if ((int )full_log) {
#line 1778
      bufsz = (size_t )(capacity * 48U);
    } else {
#line 1780
      bufsz = (size_t )(size * 48U);
    }
#line 1781
    tmp___2 = kmalloc(bufsz, 208U);
#line 1781
    *buf = (char *)tmp___2;
#line 1782
    if ((unsigned long )*buf == (unsigned long )((char *)0)) {
#line 1783
      return (-12);
    } else {

    }
  } else {

  }
#line 1785
  tmp___3 = iwl_have_debug_level(262144U);
#line 1785
  if ((int )tmp___3 || (int )full_log) {
#line 1791
    if (num_wraps != 0U) {
#line 1792
      pos = iwl_print_event_log(priv, next_entry, capacity - next_entry, mode, pos,
                                buf, bufsz);
    } else {

    }
#line 1796
    pos = iwl_print_event_log(priv, 0U, next_entry, mode, pos, buf, bufsz);
  } else {
#line 1799
    pos = iwl_print_last_event_logs(priv, capacity, num_wraps, next_entry, size, mode,
                                    pos, buf, bufsz);
  }
#line 1807
  return (pos);
}
}
#line 1810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwlagn_fw_error(struct iwl_priv *priv , bool ondemand ) 
{ 
  unsigned int reload_msec ;
  unsigned long reload_jiffies ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1815
  tmp = iwl_have_debug_level(262144U);
#line 1815
  if ((int )tmp) {
#line 1816
    iwl_print_rx_config_cmd(priv, 0);
  } else {

  }
#line 1819
  priv->ucode_loaded = 0;
#line 1822
  set_bit(10L, (unsigned long volatile   *)(& priv->status));
#line 1824
  iwl_abort_notification_waits(& priv->notif_wait);
#line 1828
  clear_bit(3L, (unsigned long volatile   *)(& priv->status));
#line 1830
  if (! ondemand) {
#line 1837
    reload_jiffies = jiffies;
#line 1838
    reload_msec = jiffies_to_msecs((unsigned long const   )((long )reload_jiffies - (long )priv->reload_jiffies));
#line 1840
    priv->reload_jiffies = reload_jiffies;
#line 1841
    if (reload_msec <= 1000U) {
#line 1842
      priv->reload_count = priv->reload_count + 1;
#line 1843
      if (priv->reload_count > 3) {
#line 1844
        __iwl_err(priv->dev, 0, 0, "BUG_ON, Stop restarting\n");
#line 1845
        return;
      } else {

      }
    } else {
#line 1848
      priv->reload_count = 0;
    }
  } else {

  }
#line 1851
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 1851
  if (tmp___0 == 0) {
#line 1852
    if ((int )iwlwifi_mod_params.restart_fw) {
#line 1853
      __iwl_dbg(priv->dev, 262144U, 0, "iwlagn_fw_error", "Restarting adapter due to uCode error.\n");
#line 1855
      queue_work(priv->workqueue, & priv->restart);
    } else {
#line 1857
      __iwl_dbg(priv->dev, 262144U, 0, "iwlagn_fw_error", "Detected FW error, but not restarting\n");
    }
  } else {

  }
#line 1858
  return;
}
}
#line 1862 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_nic_error(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;

  {
#line 1864
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1866
  __iwl_err(priv->dev, 0, 0, "Loaded firmware version: %s\n", (char const   *)(& (priv->fw)->fw_version));
#line 1869
  iwl_dump_nic_error_log(priv);
#line 1870
  iwl_dump_nic_event_log(priv, 0, (char **)0);
#line 1872
  iwlagn_fw_error(priv, 0);
#line 1873
  return;
}
}
#line 1875 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_cmd_queue_full(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1877
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1879
  tmp = iwl_check_for_ct_kill(priv);
#line 1879
  if (tmp) {
#line 1879
    tmp___0 = 0;
  } else {
#line 1879
    tmp___0 = 1;
  }
#line 1879
  if (tmp___0) {
#line 1880
    __iwl_err(priv->dev, 0, 0, "Restarting adapter queue is full\n");
#line 1881
    iwlagn_fw_error(priv, 0);
  } else {

  }
#line 1883
  return;
}
}
#line 1887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_nic_config(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;
  u32 reg_val ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 1889
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1892
  iwl_trans_set_bits_mask(priv->trans, 0U, 15U, (priv->trans)->hw_rev & 15U);
#line 1901
  if ((unsigned int )(priv->nvm_data)->radio_cfg_type <= 3U) {
#line 1902
    reg_val = (u32 )((((int )(priv->nvm_data)->radio_cfg_type << 10) | ((int )(priv->nvm_data)->radio_cfg_step << 14)) | ((int )(priv->nvm_data)->radio_cfg_dash << 12));
#line 1910
    iwl_trans_set_bits_mask(priv->trans, 0U, 64512U, reg_val);
#line 1916
    __iwl_info(priv->dev, "Radio type=0x%x-0x%x-0x%x\n", (int )(priv->nvm_data)->radio_cfg_type,
               (int )(priv->nvm_data)->radio_cfg_step, (int )(priv->nvm_data)->radio_cfg_dash);
  } else {
#line 1921
    __ret_warn_on = 1;
#line 1921
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1921
    if (tmp != 0L) {
#line 1921
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                         1921);
    } else {

    }
#line 1921
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 1925
  iwl_set_bit(priv->trans, 0U, 768U);
#line 1933
  iwl_set_bits_mask_prph(priv->trans, 12300U, 4194304U, 4290772991U);
#line 1937
  if ((unsigned long )(priv->lib)->nic_config != (unsigned long )((void (*/* const  */)(struct iwl_priv * ))0)) {
#line 1938
    (*((priv->lib)->nic_config))(priv);
  } else {

  }
#line 1939
  return;
}
}
#line 1941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_wimax_active(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;

  {
#line 1943
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1945
  clear_bit(3L, (unsigned long volatile   *)(& priv->status));
#line 1946
  __iwl_err(priv->dev, 0, 0, "RF is used by WiMAX\n");
#line 1947
  return;
}
}
#line 1949 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_stop_sw_queue(struct iwl_op_mode *op_mode , int queue ) 
{ 
  struct iwl_priv *priv ;
  int mq ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 1951
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1952
  mq = (int )priv->queue_to_mac80211[queue];
#line 1954
  __ret_warn_once = mq == 255;
#line 1954
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1954
  if (tmp___1 != 0L) {
#line 1954
    __ret_warn_on = ! __warned;
#line 1954
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1954
    if (tmp != 0L) {
#line 1954
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                         1954);
    } else {

    }
#line 1954
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1954
    if (tmp___0 != 0L) {
#line 1954
      __warned = 1;
    } else {

    }
  } else {

  }
#line 1954
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1954
  if (tmp___2 != 0L) {
#line 1955
    return;
  } else {

  }
#line 1957
  tmp___3 = atomic_add_return(1, (atomic_t *)(& priv->queue_stop_count) + (unsigned long )mq);
#line 1957
  if (tmp___3 > 1) {
#line 1958
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwl_stop_sw_queue", "queue %d (mac80211 %d) already stopped\n",
              queue, mq);
#line 1961
    return;
  } else {

  }
#line 1964
  set_bit((long )mq, (unsigned long volatile   *)(& priv->transport_queue_stop));
#line 1965
  ieee80211_stop_queue(priv->hw, mq);
#line 1966
  return;
}
}
#line 1968 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_wake_sw_queue(struct iwl_op_mode *op_mode , int queue ) 
{ 
  struct iwl_priv *priv ;
  int mq ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 1970
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1971
  mq = (int )priv->queue_to_mac80211[queue];
#line 1973
  __ret_warn_once = mq == 255;
#line 1973
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1973
  if (tmp___1 != 0L) {
#line 1973
    __ret_warn_on = ! __warned;
#line 1973
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1973
    if (tmp != 0L) {
#line 1973
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c",
                         1973);
    } else {

    }
#line 1973
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1973
    if (tmp___0 != 0L) {
#line 1973
      __warned = 1;
    } else {

    }
  } else {

  }
#line 1973
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1973
  if (tmp___2 != 0L) {
#line 1974
    return;
  } else {

  }
#line 1976
  tmp___3 = atomic_sub_return(1, (atomic_t *)(& priv->queue_stop_count) + (unsigned long )mq);
#line 1976
  if (tmp___3 > 0) {
#line 1977
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwl_wake_sw_queue", "queue %d (mac80211 %d) already awake\n",
              queue, mq);
#line 1980
    return;
  } else {

  }
#line 1983
  clear_bit((long )mq, (unsigned long volatile   *)(& priv->transport_queue_stop));
#line 1985
  if (! priv->passive_no_rx) {
#line 1986
    ieee80211_wake_queue(priv->hw, mq);
  } else {

  }
#line 1987
  return;
}
}
#line 1989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
void iwlagn_lift_passive_no_rx(struct iwl_priv *priv ) 
{ 
  int mq ;
  int tmp ;

  {
#line 1993
  if (! priv->passive_no_rx) {
#line 1994
    return;
  } else {

  }
#line 1996
  mq = 0;
#line 1996
  goto ldv_55861;
  ldv_55860: 
#line 1997
  tmp = variable_test_bit((long )mq, (unsigned long const volatile   *)(& priv->transport_queue_stop));
#line 1997
  if (tmp == 0) {
#line 1998
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_lift_passive_no_rx", "Wake queue %d\n",
              mq);
#line 1999
    ieee80211_wake_queue(priv->hw, mq);
  } else {
#line 2001
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_lift_passive_no_rx", "Don\'t wake queue %d\n",
              mq);
  }
#line 1996
  mq = mq + 1;
  ldv_55861: ;
#line 1996
  if (mq <= 10) {
#line 1998
    goto ldv_55860;
  } else {

  }
#line 2005
  priv->passive_no_rx = 0;
#line 2006
  return;
}
}
#line 2008 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_free_skb(struct iwl_op_mode *op_mode , struct sk_buff *skb ) 
{ 
  struct iwl_priv *priv ;
  struct ieee80211_tx_info *info ;

  {
#line 2010
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 2013
  info = IEEE80211_SKB_CB(skb);
#line 2014
  iwl_trans_free_tx_cmd(priv->trans, (struct iwl_device_cmd *)info->__annonCompField99.driver_data[1]);
#line 2015
  ieee80211_free_txskb(priv->hw, skb);
#line 2016
  return;
}
}
#line 2018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static bool iwl_set_hw_rfkill_state(struct iwl_op_mode *op_mode , bool state ) 
{ 
  struct iwl_priv *priv ;

  {
#line 2020
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 2022
  if ((int )state) {
#line 2023
    set_bit(0L, (unsigned long volatile   *)(& priv->status));
  } else {
#line 2025
    clear_bit(0L, (unsigned long volatile   *)(& priv->status));
  }
#line 2027
  wiphy_rfkill_set_hw_state((priv->hw)->wiphy, (int )state);
#line 2029
  return (0);
}
}
#line 2032 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_napi_add(struct iwl_op_mode *op_mode , struct napi_struct *napi ,
                         struct net_device *napi_dev , int (*poll)(struct napi_struct * ,
                                                                   int  ) , int weight ) 
{ 
  struct iwl_priv *priv ;

  {
#line 2038
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 2040
  ieee80211_napi_add(priv->hw, napi, napi_dev, poll, weight);
#line 2041
  return;
}
}
#line 2043 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static struct iwl_op_mode_ops  const  iwl_dvm_ops  = 
#line 2043
     {& iwl_op_mode_dvm_start, & iwl_op_mode_dvm_stop, & iwl_rx_dispatch, & iwl_napi_add,
    & iwl_stop_sw_queue, & iwl_wake_sw_queue, & iwl_set_hw_rfkill_state, & iwl_free_skb,
    & iwl_nic_error, & iwl_cmd_queue_full, & iwl_nic_config, & iwl_wimax_active, 0,
    0};
#line 2063 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static int iwl_init(void) 
{ 
  int ret ;

  {
#line 2068
  ret = iwlagn_rate_control_register();
#line 2069
  if (ret != 0) {
#line 2070
    printk("\viwldvm: Unable to register rate control algorithm: %d\n", ret);
#line 2071
    return (ret);
  } else {

  }
#line 2074
  ret = iwl_opmode_register("iwldvm", & iwl_dvm_ops);
#line 2075
  if (ret != 0) {
#line 2076
    printk("\viwldvm: Unable to register op_mode: %d\n", ret);
#line 2077
    iwlagn_rate_control_unregister();
  } else {

  }
#line 2080
  return (ret);
}
}
#line 2084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.c"
static void iwl_exit(void) 
{ 


  {
#line 2086
  iwl_opmode_deregister("iwldvm");
#line 2087
  iwlagn_rate_control_unregister();
#line 2088
  return;
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
extern void ldv_initialize(void) ;
#line 551
void ldv_check_final_state(void) ;
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_retval_30  ;
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_work_5(struct work_struct *work , int state ) 
{ 


  {
#line 556
  if (ldv_work_5_0 == 0) {
#line 557
    ldv_work_struct_5_0 = work;
#line 558
    ldv_work_5_0 = state;
#line 559
    return;
  } else {

  }
#line 562
  if (ldv_work_5_1 == 0) {
#line 563
    ldv_work_struct_5_1 = work;
#line 564
    ldv_work_5_1 = state;
#line 565
    return;
  } else {

  }
#line 568
  if (ldv_work_5_2 == 0) {
#line 569
    ldv_work_struct_5_2 = work;
#line 570
    ldv_work_5_2 = state;
#line 571
    return;
  } else {

  }
#line 574
  if (ldv_work_5_3 == 0) {
#line 575
    ldv_work_struct_5_3 = work;
#line 576
    ldv_work_5_3 = state;
#line 577
    return;
  } else {

  }
#line 579
  return;
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void disable_suitable_timer_16(struct timer_list *timer ) 
{ 


  {
#line 583
  if (ldv_timer_16_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_16_0) {
#line 584
    ldv_timer_16_0 = 0;
#line 585
    return;
  } else {

  }
#line 587
  if (ldv_timer_16_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_16_1) {
#line 588
    ldv_timer_16_1 = 0;
#line 589
    return;
  } else {

  }
#line 591
  if (ldv_timer_16_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_16_2) {
#line 592
    ldv_timer_16_2 = 0;
#line 593
    return;
  } else {

  }
#line 595
  if (ldv_timer_16_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_16_3) {
#line 596
    ldv_timer_16_3 = 0;
#line 597
    return;
  } else {

  }
#line 599
  return;
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void work_init_5(void) 
{ 


  {
#line 604
  ldv_work_5_0 = 0;
#line 605
  ldv_work_5_1 = 0;
#line 606
  ldv_work_5_2 = 0;
#line 607
  ldv_work_5_3 = 0;
#line 608
  return;
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_all_4(int state ) 
{ 


  {
#line 613
  if (ldv_work_4_0 == state) {
#line 614
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
#line 615
  if (ldv_work_4_1 == state) {
#line 616
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
#line 617
  if (ldv_work_4_2 == state) {
#line 618
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
#line 619
  if (ldv_work_4_3 == state) {
#line 620
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
#line 621
  return;
}
}
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 625
  if (ldv_work_1_0 == 0) {
#line 626
    ldv_work_struct_1_0 = work;
#line 627
    ldv_work_1_0 = state;
#line 628
    return;
  } else {

  }
#line 631
  if (ldv_work_1_1 == 0) {
#line 632
    ldv_work_struct_1_1 = work;
#line 633
    ldv_work_1_1 = state;
#line 634
    return;
  } else {

  }
#line 637
  if (ldv_work_1_2 == 0) {
#line 638
    ldv_work_struct_1_2 = work;
#line 639
    ldv_work_1_2 = state;
#line 640
    return;
  } else {

  }
#line 643
  if (ldv_work_1_3 == 0) {
#line 644
    ldv_work_struct_1_3 = work;
#line 645
    ldv_work_1_3 = state;
#line 646
    return;
  } else {

  }
#line 648
  return;
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 654
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 656
    iwl_bg_run_time_calib_work(work);
#line 657
    ldv_work_3_0 = 1;
#line 658
    return;
  } else {

  }
#line 660
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 662
    iwl_bg_run_time_calib_work(work);
#line 663
    ldv_work_3_1 = 1;
#line 664
    return;
  } else {

  }
#line 666
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 668
    iwl_bg_run_time_calib_work(work);
#line 669
    ldv_work_3_2 = 1;
#line 670
    return;
  } else {

  }
#line 672
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 674
    iwl_bg_run_time_calib_work(work);
#line 675
    ldv_work_3_3 = 1;
#line 676
    return;
  } else {

  }
#line 678
  return;
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 683
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 685
    ldv_work_3_0 = 1;
  } else {

  }
#line 687
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 689
    ldv_work_3_1 = 1;
  } else {

  }
#line 691
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 693
    ldv_work_3_2 = 1;
  } else {

  }
#line 695
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 697
    ldv_work_3_3 = 1;
  } else {

  }
#line 698
  return;
}
}
#line 702 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 703
  ldv_work_1_0 = 0;
#line 704
  ldv_work_1_1 = 0;
#line 705
  ldv_work_1_2 = 0;
#line 706
  ldv_work_1_3 = 0;
#line 707
  return;
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void invoke_work_4(void) 
{ 
  int tmp ;

  {
#line 712
  tmp = __VERIFIER_nondet_int();
#line 712
  switch (tmp) {
  case 0: ;
#line 714
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
#line 715
    ldv_work_4_0 = 4;
#line 716
    iwl_bg_tx_flush(ldv_work_struct_4_0);
#line 717
    ldv_work_4_0 = 1;
  } else {

  }
#line 720
  goto ldv_55941;
  case 1: ;
#line 722
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
#line 723
    ldv_work_4_1 = 4;
#line 724
    iwl_bg_tx_flush(ldv_work_struct_4_0);
#line 725
    ldv_work_4_1 = 1;
  } else {

  }
#line 728
  goto ldv_55941;
  case 2: ;
#line 730
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
#line 731
    ldv_work_4_2 = 4;
#line 732
    iwl_bg_tx_flush(ldv_work_struct_4_0);
#line 733
    ldv_work_4_2 = 1;
  } else {

  }
#line 736
  goto ldv_55941;
  case 3: ;
#line 738
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
#line 739
    ldv_work_4_3 = 4;
#line 740
    iwl_bg_tx_flush(ldv_work_struct_4_0);
#line 741
    ldv_work_4_3 = 1;
  } else {

  }
#line 744
  goto ldv_55941;
  default: 
#line 745
  ldv_stop();
  }
  ldv_55941: ;
#line 747
  return;
}
}
#line 751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_suitable_timer_15(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 752
  if (ldv_timer_15_0 == 0 || ldv_timer_15_0 == 2) {
#line 753
    ldv_timer_list_15_0 = timer;
#line 754
    ldv_timer_list_15_0->data = data;
#line 755
    ldv_timer_15_0 = 1;
#line 756
    return;
  } else {

  }
#line 758
  if (ldv_timer_15_1 == 0 || ldv_timer_15_1 == 2) {
#line 759
    ldv_timer_list_15_1 = timer;
#line 760
    ldv_timer_list_15_1->data = data;
#line 761
    ldv_timer_15_1 = 1;
#line 762
    return;
  } else {

  }
#line 764
  if (ldv_timer_15_2 == 0 || ldv_timer_15_2 == 2) {
#line 765
    ldv_timer_list_15_2 = timer;
#line 766
    ldv_timer_list_15_2->data = data;
#line 767
    ldv_timer_15_2 = 1;
#line 768
    return;
  } else {

  }
#line 770
  if (ldv_timer_15_3 == 0 || ldv_timer_15_3 == 2) {
#line 771
    ldv_timer_list_15_3 = timer;
#line 772
    ldv_timer_list_15_3->data = data;
#line 773
    ldv_timer_15_3 = 1;
#line 774
    return;
  } else {

  }
#line 776
  return;
}
}
#line 780 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_work_6(struct work_struct *work , int state ) 
{ 


  {
#line 781
  if (ldv_work_6_0 == 0) {
#line 782
    ldv_work_struct_6_0 = work;
#line 783
    ldv_work_6_0 = state;
#line 784
    return;
  } else {

  }
#line 787
  if (ldv_work_6_1 == 0) {
#line 788
    ldv_work_struct_6_1 = work;
#line 789
    ldv_work_6_1 = state;
#line 790
    return;
  } else {

  }
#line 793
  if (ldv_work_6_2 == 0) {
#line 794
    ldv_work_struct_6_2 = work;
#line 795
    ldv_work_6_2 = state;
#line 796
    return;
  } else {

  }
#line 799
  if (ldv_work_6_3 == 0) {
#line 800
    ldv_work_struct_6_3 = work;
#line 801
    ldv_work_6_3 = state;
#line 802
    return;
  } else {

  }
#line 804
  return;
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int reg_timer_15(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 808
  if ((unsigned long )function == (unsigned long )(& iwl_bg_statistics_periodic)) {
#line 809
    activate_suitable_timer_15(timer, data);
  } else {

  }
#line 810
  return (0);
}
}
#line 814 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_initialize_iwl_op_mode_ops_69(void) 
{ 
  void *tmp ;

  {
#line 815
  tmp = ldv_init_zalloc(8UL);
#line 815
  iwl_dvm_ops_group0 = (struct iwl_op_mode *)tmp;
#line 816
  return;
}
}
#line 818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void timer_init_16(void) 
{ 


  {
#line 819
  ldv_timer_16_0 = 0;
#line 820
  ldv_timer_16_1 = 0;
#line 821
  ldv_timer_16_2 = 0;
#line 822
  ldv_timer_16_3 = 0;
#line 823
  return;
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 827
  if (ldv_work_2_0 == 0) {
#line 828
    ldv_work_struct_2_0 = work;
#line 829
    ldv_work_2_0 = state;
#line 830
    return;
  } else {

  }
#line 833
  if (ldv_work_2_1 == 0) {
#line 834
    ldv_work_struct_2_1 = work;
#line 835
    ldv_work_2_1 = state;
#line 836
    return;
  } else {

  }
#line 839
  if (ldv_work_2_2 == 0) {
#line 840
    ldv_work_struct_2_2 = work;
#line 841
    ldv_work_2_2 = state;
#line 842
    return;
  } else {

  }
#line 845
  if (ldv_work_2_3 == 0) {
#line 846
    ldv_work_struct_2_3 = work;
#line 847
    ldv_work_2_3 = state;
#line 848
    return;
  } else {

  }
#line 850
  return;
}
}
#line 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 854
  if ((unsigned long )ldv_timer_list_15_0 == (unsigned long )timer) {
#line 855
    if (ldv_timer_15_0 == 2 || pending_flag != 0) {
#line 856
      ldv_timer_list_15_0 = timer;
#line 857
      ldv_timer_list_15_0->data = data;
#line 858
      ldv_timer_15_0 = 1;
    } else {

    }
#line 860
    return;
  } else {

  }
#line 863
  if ((unsigned long )ldv_timer_list_15_1 == (unsigned long )timer) {
#line 864
    if (ldv_timer_15_1 == 2 || pending_flag != 0) {
#line 865
      ldv_timer_list_15_1 = timer;
#line 866
      ldv_timer_list_15_1->data = data;
#line 867
      ldv_timer_15_1 = 1;
    } else {

    }
#line 869
    return;
  } else {

  }
#line 872
  if ((unsigned long )ldv_timer_list_15_2 == (unsigned long )timer) {
#line 873
    if (ldv_timer_15_2 == 2 || pending_flag != 0) {
#line 874
      ldv_timer_list_15_2 = timer;
#line 875
      ldv_timer_list_15_2->data = data;
#line 876
      ldv_timer_15_2 = 1;
    } else {

    }
#line 878
    return;
  } else {

  }
#line 881
  if ((unsigned long )ldv_timer_list_15_3 == (unsigned long )timer) {
#line 882
    if (ldv_timer_15_3 == 2 || pending_flag != 0) {
#line 883
      ldv_timer_list_15_3 = timer;
#line 884
      ldv_timer_list_15_3->data = data;
#line 885
      ldv_timer_15_3 = 1;
    } else {

    }
#line 887
    return;
  } else {

  }
#line 889
  activate_suitable_timer_15(timer, data);
#line 890
  return;
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void invoke_work_5(void) 
{ 
  int tmp ;

  {
#line 895
  tmp = __VERIFIER_nondet_int();
#line 895
  switch (tmp) {
  case 0: ;
#line 897
  if (ldv_work_5_0 == 2 || ldv_work_5_0 == 3) {
#line 898
    ldv_work_5_0 = 4;
#line 899
    iwl_bg_bt_full_concurrency(ldv_work_struct_5_0);
#line 900
    ldv_work_5_0 = 1;
  } else {

  }
#line 903
  goto ldv_55981;
  case 1: ;
#line 905
  if (ldv_work_5_1 == 2 || ldv_work_5_1 == 3) {
#line 906
    ldv_work_5_1 = 4;
#line 907
    iwl_bg_bt_full_concurrency(ldv_work_struct_5_0);
#line 908
    ldv_work_5_1 = 1;
  } else {

  }
#line 911
  goto ldv_55981;
  case 2: ;
#line 913
  if (ldv_work_5_2 == 2 || ldv_work_5_2 == 3) {
#line 914
    ldv_work_5_2 = 4;
#line 915
    iwl_bg_bt_full_concurrency(ldv_work_struct_5_0);
#line 916
    ldv_work_5_2 = 1;
  } else {

  }
#line 919
  goto ldv_55981;
  case 3: ;
#line 921
  if (ldv_work_5_3 == 2 || ldv_work_5_3 == 3) {
#line 922
    ldv_work_5_3 = 4;
#line 923
    iwl_bg_bt_full_concurrency(ldv_work_struct_5_0);
#line 924
    ldv_work_5_3 = 1;
  } else {

  }
#line 927
  goto ldv_55981;
  default: 
#line 928
  ldv_stop();
  }
  ldv_55981: ;
#line 930
  return;
}
}
#line 934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void disable_work_4(struct work_struct *work ) 
{ 


  {
#line 936
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
#line 938
    ldv_work_4_0 = 1;
  } else {

  }
#line 940
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
#line 942
    ldv_work_4_1 = 1;
  } else {

  }
#line 944
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
#line 946
    ldv_work_4_2 = 1;
  } else {

  }
#line 948
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
#line 950
    ldv_work_4_3 = 1;
  } else {

  }
#line 951
  return;
}
}
#line 955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void work_init_4(void) 
{ 


  {
#line 956
  ldv_work_4_0 = 0;
#line 957
  ldv_work_4_1 = 0;
#line 958
  ldv_work_4_2 = 0;
#line 959
  ldv_work_4_3 = 0;
#line 960
  return;
}
}
#line 963 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 965
  tmp = __VERIFIER_nondet_int();
#line 965
  switch (tmp) {
  case 0: ;
#line 967
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 968
    ldv_work_1_0 = 4;
#line 969
    iwl_bg_restart(ldv_work_struct_1_0);
#line 970
    ldv_work_1_0 = 1;
  } else {

  }
#line 973
  goto ldv_55998;
  case 1: ;
#line 975
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 976
    ldv_work_1_1 = 4;
#line 977
    iwl_bg_restart(ldv_work_struct_1_0);
#line 978
    ldv_work_1_1 = 1;
  } else {

  }
#line 981
  goto ldv_55998;
  case 2: ;
#line 983
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 984
    ldv_work_1_2 = 4;
#line 985
    iwl_bg_restart(ldv_work_struct_1_0);
#line 986
    ldv_work_1_2 = 1;
  } else {

  }
#line 989
  goto ldv_55998;
  case 3: ;
#line 991
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 992
    ldv_work_1_3 = 4;
#line 993
    iwl_bg_restart(ldv_work_struct_1_0);
#line 994
    ldv_work_1_3 = 1;
  } else {

  }
#line 997
  goto ldv_55998;
  default: 
#line 998
  ldv_stop();
  }
  ldv_55998: ;
#line 1000
  return;
}
}
#line 1004 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_suitable_timer_16(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 1005
  if (ldv_timer_16_0 == 0 || ldv_timer_16_0 == 2) {
#line 1006
    ldv_timer_list_16_0 = timer;
#line 1007
    ldv_timer_list_16_0->data = data;
#line 1008
    ldv_timer_16_0 = 1;
#line 1009
    return;
  } else {

  }
#line 1011
  if (ldv_timer_16_1 == 0 || ldv_timer_16_1 == 2) {
#line 1012
    ldv_timer_list_16_1 = timer;
#line 1013
    ldv_timer_list_16_1->data = data;
#line 1014
    ldv_timer_16_1 = 1;
#line 1015
    return;
  } else {

  }
#line 1017
  if (ldv_timer_16_2 == 0 || ldv_timer_16_2 == 2) {
#line 1018
    ldv_timer_list_16_2 = timer;
#line 1019
    ldv_timer_list_16_2->data = data;
#line 1020
    ldv_timer_16_2 = 1;
#line 1021
    return;
  } else {

  }
#line 1023
  if (ldv_timer_16_3 == 0 || ldv_timer_16_3 == 2) {
#line 1024
    ldv_timer_list_16_3 = timer;
#line 1025
    ldv_timer_list_16_3->data = data;
#line 1026
    ldv_timer_16_3 = 1;
#line 1027
    return;
  } else {

  }
#line 1029
  return;
}
}
#line 1033 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 1035
  if (ldv_work_3_0 == state) {
#line 1036
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 1037
  if (ldv_work_3_1 == state) {
#line 1038
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 1039
  if (ldv_work_3_2 == state) {
#line 1040
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 1041
  if (ldv_work_3_3 == state) {
#line 1042
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 1043
  return;
}
}
#line 1046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
#line 1049
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
#line 1051
    iwl_bg_tx_flush(work);
#line 1052
    ldv_work_4_0 = 1;
#line 1053
    return;
  } else {

  }
#line 1055
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
#line 1057
    iwl_bg_tx_flush(work);
#line 1058
    ldv_work_4_1 = 1;
#line 1059
    return;
  } else {

  }
#line 1061
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
#line 1063
    iwl_bg_tx_flush(work);
#line 1064
    ldv_work_4_2 = 1;
#line 1065
    return;
  } else {

  }
#line 1067
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
#line 1069
    iwl_bg_tx_flush(work);
#line 1070
    ldv_work_4_3 = 1;
#line 1071
    return;
  } else {

  }
#line 1073
  return;
}
}
#line 1076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 1077
  ldv_work_3_0 = 0;
#line 1078
  ldv_work_3_1 = 0;
#line 1079
  ldv_work_3_2 = 0;
#line 1080
  ldv_work_3_3 = 0;
#line 1081
  return;
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 1087
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 1089
    iwl_bg_restart(work);
#line 1090
    ldv_work_1_0 = 1;
#line 1091
    return;
  } else {

  }
#line 1093
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 1095
    iwl_bg_restart(work);
#line 1096
    ldv_work_1_1 = 1;
#line 1097
    return;
  } else {

  }
#line 1099
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 1101
    iwl_bg_restart(work);
#line 1102
    ldv_work_1_2 = 1;
#line 1103
    return;
  } else {

  }
#line 1105
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 1107
    iwl_bg_restart(work);
#line 1108
    ldv_work_1_3 = 1;
#line 1109
    return;
  } else {

  }
#line 1111
  return;
}
}
#line 1114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void invoke_work_6(void) 
{ 
  int tmp ;

  {
#line 1116
  tmp = __VERIFIER_nondet_int();
#line 1116
  switch (tmp) {
  case 0: ;
#line 1118
  if (ldv_work_6_0 == 2 || ldv_work_6_0 == 3) {
#line 1119
    ldv_work_6_0 = 4;
#line 1120
    iwl_bg_bt_runtime_config(ldv_work_struct_6_0);
#line 1121
    ldv_work_6_0 = 1;
  } else {

  }
#line 1124
  goto ldv_56029;
  case 1: ;
#line 1126
  if (ldv_work_6_1 == 2 || ldv_work_6_1 == 3) {
#line 1127
    ldv_work_6_1 = 4;
#line 1128
    iwl_bg_bt_runtime_config(ldv_work_struct_6_0);
#line 1129
    ldv_work_6_1 = 1;
  } else {

  }
#line 1132
  goto ldv_56029;
  case 2: ;
#line 1134
  if (ldv_work_6_2 == 2 || ldv_work_6_2 == 3) {
#line 1135
    ldv_work_6_2 = 4;
#line 1136
    iwl_bg_bt_runtime_config(ldv_work_struct_6_0);
#line 1137
    ldv_work_6_2 = 1;
  } else {

  }
#line 1140
  goto ldv_56029;
  case 3: ;
#line 1142
  if (ldv_work_6_3 == 2 || ldv_work_6_3 == 3) {
#line 1143
    ldv_work_6_3 = 4;
#line 1144
    iwl_bg_bt_runtime_config(ldv_work_struct_6_0);
#line 1145
    ldv_work_6_3 = 1;
  } else {

  }
#line 1148
  goto ldv_56029;
  default: 
#line 1149
  ldv_stop();
  }
  ldv_56029: ;
#line 1151
  return;
}
}
#line 1155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 1157
  if (ldv_work_2_0 == state) {
#line 1158
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 1159
  if (ldv_work_2_1 == state) {
#line 1160
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 1161
  if (ldv_work_2_2 == state) {
#line 1162
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 1163
  if (ldv_work_2_3 == state) {
#line 1164
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 1165
  return;
}
}
#line 1168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 1169
  if (ldv_work_3_0 == 0) {
#line 1170
    ldv_work_struct_3_0 = work;
#line 1171
    ldv_work_3_0 = state;
#line 1172
    return;
  } else {

  }
#line 1175
  if (ldv_work_3_1 == 0) {
#line 1176
    ldv_work_struct_3_1 = work;
#line 1177
    ldv_work_3_1 = state;
#line 1178
    return;
  } else {

  }
#line 1181
  if (ldv_work_3_2 == 0) {
#line 1182
    ldv_work_struct_3_2 = work;
#line 1183
    ldv_work_3_2 = state;
#line 1184
    return;
  } else {

  }
#line 1187
  if (ldv_work_3_3 == 0) {
#line 1188
    ldv_work_struct_3_3 = work;
#line 1189
    ldv_work_3_3 = state;
#line 1190
    return;
  } else {

  }
#line 1192
  return;
}
}
#line 1195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void choose_timer_15(void) 
{ 
  int tmp ;

  {
#line 1196
  tmp = __VERIFIER_nondet_int();
#line 1196
  switch (tmp) {
  case 0: ;
#line 1198
  if (ldv_timer_15_0 == 1) {
#line 1199
    ldv_timer_15_0 = 2;
#line 1200
    ldv_timer_15(ldv_timer_15_0, ldv_timer_list_15_0);
  } else {

  }
#line 1203
  goto ldv_56045;
  case 1: ;
#line 1205
  if (ldv_timer_15_1 == 1) {
#line 1206
    ldv_timer_15_1 = 2;
#line 1207
    ldv_timer_15(ldv_timer_15_1, ldv_timer_list_15_1);
  } else {

  }
#line 1210
  goto ldv_56045;
  case 2: ;
#line 1212
  if (ldv_timer_15_2 == 1) {
#line 1213
    ldv_timer_15_2 = 2;
#line 1214
    ldv_timer_15(ldv_timer_15_2, ldv_timer_list_15_2);
  } else {

  }
#line 1217
  goto ldv_56045;
  case 3: ;
#line 1219
  if (ldv_timer_15_3 == 1) {
#line 1220
    ldv_timer_15_3 = 2;
#line 1221
    ldv_timer_15(ldv_timer_15_3, ldv_timer_list_15_3);
  } else {

  }
#line 1224
  goto ldv_56045;
  default: 
#line 1225
  ldv_stop();
  }
  ldv_56045: ;
#line 1227
  return;
}
}
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_pending_timer_16(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 1232
  if ((unsigned long )ldv_timer_list_16_0 == (unsigned long )timer) {
#line 1233
    if (ldv_timer_16_0 == 2 || pending_flag != 0) {
#line 1234
      ldv_timer_list_16_0 = timer;
#line 1235
      ldv_timer_list_16_0->data = data;
#line 1236
      ldv_timer_16_0 = 1;
    } else {

    }
#line 1238
    return;
  } else {

  }
#line 1241
  if ((unsigned long )ldv_timer_list_16_1 == (unsigned long )timer) {
#line 1242
    if (ldv_timer_16_1 == 2 || pending_flag != 0) {
#line 1243
      ldv_timer_list_16_1 = timer;
#line 1244
      ldv_timer_list_16_1->data = data;
#line 1245
      ldv_timer_16_1 = 1;
    } else {

    }
#line 1247
    return;
  } else {

  }
#line 1250
  if ((unsigned long )ldv_timer_list_16_2 == (unsigned long )timer) {
#line 1251
    if (ldv_timer_16_2 == 2 || pending_flag != 0) {
#line 1252
      ldv_timer_list_16_2 = timer;
#line 1253
      ldv_timer_list_16_2->data = data;
#line 1254
      ldv_timer_16_2 = 1;
    } else {

    }
#line 1256
    return;
  } else {

  }
#line 1259
  if ((unsigned long )ldv_timer_list_16_3 == (unsigned long )timer) {
#line 1260
    if (ldv_timer_16_3 == 2 || pending_flag != 0) {
#line 1261
      ldv_timer_list_16_3 = timer;
#line 1262
      ldv_timer_list_16_3->data = data;
#line 1263
      ldv_timer_16_3 = 1;
    } else {

    }
#line 1265
    return;
  } else {

  }
#line 1267
  activate_suitable_timer_16(timer, data);
#line 1268
  return;
}
}
#line 1271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void disable_work_5(struct work_struct *work ) 
{ 


  {
#line 1273
  if ((ldv_work_5_0 == 3 || ldv_work_5_0 == 2) && (unsigned long )ldv_work_struct_5_0 == (unsigned long )work) {
#line 1275
    ldv_work_5_0 = 1;
  } else {

  }
#line 1277
  if ((ldv_work_5_1 == 3 || ldv_work_5_1 == 2) && (unsigned long )ldv_work_struct_5_1 == (unsigned long )work) {
#line 1279
    ldv_work_5_1 = 1;
  } else {

  }
#line 1281
  if ((ldv_work_5_2 == 3 || ldv_work_5_2 == 2) && (unsigned long )ldv_work_struct_5_2 == (unsigned long )work) {
#line 1283
    ldv_work_5_2 = 1;
  } else {

  }
#line 1285
  if ((ldv_work_5_3 == 3 || ldv_work_5_3 == 2) && (unsigned long )ldv_work_struct_5_3 == (unsigned long )work) {
#line 1287
    ldv_work_5_3 = 1;
  } else {

  }
#line 1288
  return;
}
}
#line 1292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void timer_init_15(void) 
{ 


  {
#line 1293
  ldv_timer_15_0 = 0;
#line 1294
  ldv_timer_15_1 = 0;
#line 1295
  ldv_timer_15_2 = 0;
#line 1296
  ldv_timer_15_3 = 0;
#line 1297
  return;
}
}
#line 1300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 1302
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 1304
    ldv_work_1_0 = 1;
  } else {

  }
#line 1306
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 1308
    ldv_work_1_1 = 1;
  } else {

  }
#line 1310
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 1312
    ldv_work_1_2 = 1;
  } else {

  }
#line 1314
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 1316
    ldv_work_1_3 = 1;
  } else {

  }
#line 1317
  return;
}
}
#line 1321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_all_6(int state ) 
{ 


  {
#line 1323
  if (ldv_work_6_0 == state) {
#line 1324
    call_and_disable_work_6(ldv_work_struct_6_0);
  } else {

  }
#line 1325
  if (ldv_work_6_1 == state) {
#line 1326
    call_and_disable_work_6(ldv_work_struct_6_1);
  } else {

  }
#line 1327
  if (ldv_work_6_2 == state) {
#line 1328
    call_and_disable_work_6(ldv_work_struct_6_2);
  } else {

  }
#line 1329
  if (ldv_work_6_3 == state) {
#line 1330
    call_and_disable_work_6(ldv_work_struct_6_3);
  } else {

  }
#line 1331
  return;
}
}
#line 1334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int reg_timer_16(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 1335
  if ((unsigned long )function == (unsigned long )(& iwl_bg_ucode_trace)) {
#line 1336
    activate_suitable_timer_16(timer, data);
  } else {

  }
#line 1337
  return (0);
}
}
#line 1341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_work_5(struct work_struct *work ) 
{ 


  {
#line 1344
  if ((ldv_work_5_0 == 2 || ldv_work_5_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_0) {
#line 1346
    iwl_bg_bt_full_concurrency(work);
#line 1347
    ldv_work_5_0 = 1;
#line 1348
    return;
  } else {

  }
#line 1350
  if ((ldv_work_5_1 == 2 || ldv_work_5_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_1) {
#line 1352
    iwl_bg_bt_full_concurrency(work);
#line 1353
    ldv_work_5_1 = 1;
#line 1354
    return;
  } else {

  }
#line 1356
  if ((ldv_work_5_2 == 2 || ldv_work_5_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_2) {
#line 1358
    iwl_bg_bt_full_concurrency(work);
#line 1359
    ldv_work_5_2 = 1;
#line 1360
    return;
  } else {

  }
#line 1362
  if ((ldv_work_5_3 == 2 || ldv_work_5_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_3) {
#line 1364
    iwl_bg_bt_full_concurrency(work);
#line 1365
    ldv_work_5_3 = 1;
#line 1366
    return;
  } else {

  }
#line 1368
  return;
}
}
#line 1371 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_timer_15(int state , struct timer_list *timer ) 
{ 


  {
#line 1372
  LDV_IN_INTERRUPT = 2;
#line 1373
  iwl_bg_statistics_periodic(timer->data);
#line 1374
  LDV_IN_INTERRUPT = 1;
#line 1375
  return;
}
}
#line 1378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 1380
  tmp = __VERIFIER_nondet_int();
#line 1380
  switch (tmp) {
  case 0: ;
#line 1382
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 1383
    ldv_work_2_0 = 4;
#line 1384
    iwl_bg_beacon_update(ldv_work_struct_2_0);
#line 1385
    ldv_work_2_0 = 1;
  } else {

  }
#line 1388
  goto ldv_56088;
  case 1: ;
#line 1390
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 1391
    ldv_work_2_1 = 4;
#line 1392
    iwl_bg_beacon_update(ldv_work_struct_2_0);
#line 1393
    ldv_work_2_1 = 1;
  } else {

  }
#line 1396
  goto ldv_56088;
  case 2: ;
#line 1398
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 1399
    ldv_work_2_2 = 4;
#line 1400
    iwl_bg_beacon_update(ldv_work_struct_2_0);
#line 1401
    ldv_work_2_2 = 1;
  } else {

  }
#line 1404
  goto ldv_56088;
  case 3: ;
#line 1406
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 1407
    ldv_work_2_3 = 4;
#line 1408
    iwl_bg_beacon_update(ldv_work_struct_2_0);
#line 1409
    ldv_work_2_3 = 1;
  } else {

  }
#line 1412
  goto ldv_56088;
  default: 
#line 1413
  ldv_stop();
  }
  ldv_56088: ;
#line 1415
  return;
}
}
#line 1419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void choose_timer_16(void) 
{ 
  int tmp ;

  {
#line 1420
  tmp = __VERIFIER_nondet_int();
#line 1420
  switch (tmp) {
  case 0: ;
#line 1422
  if (ldv_timer_16_0 == 1) {
#line 1423
    ldv_timer_16_0 = 2;
#line 1424
    ldv_timer_16(ldv_timer_16_0, ldv_timer_list_16_0);
  } else {

  }
#line 1427
  goto ldv_56097;
  case 1: ;
#line 1429
  if (ldv_timer_16_1 == 1) {
#line 1430
    ldv_timer_16_1 = 2;
#line 1431
    ldv_timer_16(ldv_timer_16_1, ldv_timer_list_16_1);
  } else {

  }
#line 1434
  goto ldv_56097;
  case 2: ;
#line 1436
  if (ldv_timer_16_2 == 1) {
#line 1437
    ldv_timer_16_2 = 2;
#line 1438
    ldv_timer_16(ldv_timer_16_2, ldv_timer_list_16_2);
  } else {

  }
#line 1441
  goto ldv_56097;
  case 3: ;
#line 1443
  if (ldv_timer_16_3 == 1) {
#line 1444
    ldv_timer_16_3 = 2;
#line 1445
    ldv_timer_16(ldv_timer_16_3, ldv_timer_list_16_3);
  } else {

  }
#line 1448
  goto ldv_56097;
  default: 
#line 1449
  ldv_stop();
  }
  ldv_56097: ;
#line 1451
  return;
}
}
#line 1455 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
#line 1456
  if (ldv_work_4_0 == 0) {
#line 1457
    ldv_work_struct_4_0 = work;
#line 1458
    ldv_work_4_0 = state;
#line 1459
    return;
  } else {

  }
#line 1462
  if (ldv_work_4_1 == 0) {
#line 1463
    ldv_work_struct_4_1 = work;
#line 1464
    ldv_work_4_1 = state;
#line 1465
    return;
  } else {

  }
#line 1468
  if (ldv_work_4_2 == 0) {
#line 1469
    ldv_work_struct_4_2 = work;
#line 1470
    ldv_work_4_2 = state;
#line 1471
    return;
  } else {

  }
#line 1474
  if (ldv_work_4_3 == 0) {
#line 1475
    ldv_work_struct_4_3 = work;
#line 1476
    ldv_work_4_3 = state;
#line 1477
    return;
  } else {

  }
#line 1479
  return;
}
}
#line 1482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_all_5(int state ) 
{ 


  {
#line 1484
  if (ldv_work_5_0 == state) {
#line 1485
    call_and_disable_work_5(ldv_work_struct_5_0);
  } else {

  }
#line 1486
  if (ldv_work_5_1 == state) {
#line 1487
    call_and_disable_work_5(ldv_work_struct_5_1);
  } else {

  }
#line 1488
  if (ldv_work_5_2 == state) {
#line 1489
    call_and_disable_work_5(ldv_work_struct_5_2);
  } else {

  }
#line 1490
  if (ldv_work_5_3 == state) {
#line 1491
    call_and_disable_work_5(ldv_work_struct_5_3);
  } else {

  }
#line 1492
  return;
}
}
#line 1495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_timer_16(int state , struct timer_list *timer ) 
{ 


  {
#line 1496
  LDV_IN_INTERRUPT = 2;
#line 1497
  iwl_bg_ucode_trace(timer->data);
#line 1498
  LDV_IN_INTERRUPT = 1;
#line 1499
  return;
}
}
#line 1502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 1503
  ldv_work_2_0 = 0;
#line 1504
  ldv_work_2_1 = 0;
#line 1505
  ldv_work_2_2 = 0;
#line 1506
  ldv_work_2_3 = 0;
#line 1507
  return;
}
}
#line 1510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 1512
  if (ldv_work_1_0 == state) {
#line 1513
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 1514
  if (ldv_work_1_1 == state) {
#line 1515
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 1516
  if (ldv_work_1_2 == state) {
#line 1517
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 1518
  if (ldv_work_1_3 == state) {
#line 1519
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 1520
  return;
}
}
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void disable_work_6(struct work_struct *work ) 
{ 


  {
#line 1525
  if ((ldv_work_6_0 == 3 || ldv_work_6_0 == 2) && (unsigned long )ldv_work_struct_6_0 == (unsigned long )work) {
#line 1527
    ldv_work_6_0 = 1;
  } else {

  }
#line 1529
  if ((ldv_work_6_1 == 3 || ldv_work_6_1 == 2) && (unsigned long )ldv_work_struct_6_1 == (unsigned long )work) {
#line 1531
    ldv_work_6_1 = 1;
  } else {

  }
#line 1533
  if ((ldv_work_6_2 == 3 || ldv_work_6_2 == 2) && (unsigned long )ldv_work_struct_6_2 == (unsigned long )work) {
#line 1535
    ldv_work_6_2 = 1;
  } else {

  }
#line 1537
  if ((ldv_work_6_3 == 3 || ldv_work_6_3 == 2) && (unsigned long )ldv_work_struct_6_3 == (unsigned long )work) {
#line 1539
    ldv_work_6_3 = 1;
  } else {

  }
#line 1540
  return;
}
}
#line 1544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void work_init_6(void) 
{ 


  {
#line 1545
  ldv_work_6_0 = 0;
#line 1546
  ldv_work_6_1 = 0;
#line 1547
  ldv_work_6_2 = 0;
#line 1548
  ldv_work_6_3 = 0;
#line 1549
  return;
}
}
#line 1552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void disable_suitable_timer_15(struct timer_list *timer ) 
{ 


  {
#line 1553
  if (ldv_timer_15_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_0) {
#line 1554
    ldv_timer_15_0 = 0;
#line 1555
    return;
  } else {

  }
#line 1557
  if (ldv_timer_15_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_1) {
#line 1558
    ldv_timer_15_1 = 0;
#line 1559
    return;
  } else {

  }
#line 1561
  if (ldv_timer_15_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_2) {
#line 1562
    ldv_timer_15_2 = 0;
#line 1563
    return;
  } else {

  }
#line 1565
  if (ldv_timer_15_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_3) {
#line 1566
    ldv_timer_15_3 = 0;
#line 1567
    return;
  } else {

  }
#line 1569
  return;
}
}
#line 1573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 1575
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 1577
    ldv_work_2_0 = 1;
  } else {

  }
#line 1579
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 1581
    ldv_work_2_1 = 1;
  } else {

  }
#line 1583
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 1585
    ldv_work_2_2 = 1;
  } else {

  }
#line 1587
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 1589
    ldv_work_2_3 = 1;
  } else {

  }
#line 1590
  return;
}
}
#line 1594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 1596
  tmp = __VERIFIER_nondet_int();
#line 1596
  switch (tmp) {
  case 0: ;
#line 1598
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 1599
    ldv_work_3_0 = 4;
#line 1600
    iwl_bg_run_time_calib_work(ldv_work_struct_3_0);
#line 1601
    ldv_work_3_0 = 1;
  } else {

  }
#line 1604
  goto ldv_56137;
  case 1: ;
#line 1606
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 1607
    ldv_work_3_1 = 4;
#line 1608
    iwl_bg_run_time_calib_work(ldv_work_struct_3_0);
#line 1609
    ldv_work_3_1 = 1;
  } else {

  }
#line 1612
  goto ldv_56137;
  case 2: ;
#line 1614
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 1615
    ldv_work_3_2 = 4;
#line 1616
    iwl_bg_run_time_calib_work(ldv_work_struct_3_0);
#line 1617
    ldv_work_3_2 = 1;
  } else {

  }
#line 1620
  goto ldv_56137;
  case 3: ;
#line 1622
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 1623
    ldv_work_3_3 = 4;
#line 1624
    iwl_bg_run_time_calib_work(ldv_work_struct_3_0);
#line 1625
    ldv_work_3_3 = 1;
  } else {

  }
#line 1628
  goto ldv_56137;
  default: 
#line 1629
  ldv_stop();
  }
  ldv_56137: ;
#line 1631
  return;
}
}
#line 1636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_work_6(struct work_struct *work ) 
{ 


  {
#line 1639
  if ((ldv_work_6_0 == 2 || ldv_work_6_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_0) {
#line 1641
    iwl_bg_bt_runtime_config(work);
#line 1642
    ldv_work_6_0 = 1;
#line 1643
    return;
  } else {

  }
#line 1645
  if ((ldv_work_6_1 == 2 || ldv_work_6_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_1) {
#line 1647
    iwl_bg_bt_runtime_config(work);
#line 1648
    ldv_work_6_1 = 1;
#line 1649
    return;
  } else {

  }
#line 1651
  if ((ldv_work_6_2 == 2 || ldv_work_6_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_2) {
#line 1653
    iwl_bg_bt_runtime_config(work);
#line 1654
    ldv_work_6_2 = 1;
#line 1655
    return;
  } else {

  }
#line 1657
  if ((ldv_work_6_3 == 2 || ldv_work_6_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_3) {
#line 1659
    iwl_bg_bt_runtime_config(work);
#line 1660
    ldv_work_6_3 = 1;
#line 1661
    return;
  } else {

  }
#line 1663
  return;
}
}
#line 1666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 1669
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 1671
    iwl_bg_beacon_update(work);
#line 1672
    ldv_work_2_0 = 1;
#line 1673
    return;
  } else {

  }
#line 1675
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 1677
    iwl_bg_beacon_update(work);
#line 1678
    ldv_work_2_1 = 1;
#line 1679
    return;
  } else {

  }
#line 1681
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 1683
    iwl_bg_beacon_update(work);
#line 1684
    ldv_work_2_2 = 1;
#line 1685
    return;
  } else {

  }
#line 1687
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 1689
    iwl_bg_beacon_update(work);
#line 1690
    ldv_work_2_3 = 1;
#line 1691
    return;
  } else {

  }
#line 1693
  return;
}
}
#line 1697
void ldv_main_exported_67(void) ;
#line 1698
void ldv_main_exported_66(void) ;
#line 1699
void ldv_main_exported_68(void) ;
#line 1700
void ldv_main_exported_65(void) ;
#line 1701
void ldv_main_exported_33(void) ;
#line 1702
void ldv_main_exported_32(void) ;
#line 1703
void ldv_main_exported_21(void) ;
#line 1704
void ldv_main_exported_26(void) ;
#line 1705
void ldv_main_exported_30(void) ;
#line 1706
void ldv_main_exported_44(void) ;
#line 1707
void ldv_main_exported_25(void) ;
#line 1708
void ldv_main_exported_27(void) ;
#line 1709
void ldv_main_exported_28(void) ;
#line 1710
void ldv_main_exported_40(void) ;
#line 1711
void ldv_main_exported_20(void) ;
#line 1712
void ldv_main_exported_49(void) ;
#line 1713
void ldv_main_exported_24(void) ;
#line 1714
void ldv_main_exported_31(void) ;
#line 1715
void ldv_main_exported_35(void) ;
#line 1716
void ldv_main_exported_53(void) ;
#line 1717
void ldv_main_exported_48(void) ;
#line 1718
void ldv_main_exported_22(void) ;
#line 1719
void ldv_main_exported_42(void) ;
#line 1720
void ldv_main_exported_46(void) ;
#line 1721
void ldv_main_exported_23(void) ;
#line 1722
void ldv_main_exported_29(void) ;
#line 1723
void ldv_main_exported_50(void) ;
#line 1724
void ldv_main_exported_39(void) ;
#line 1725
void ldv_main_exported_36(void) ;
#line 1726
void ldv_main_exported_51(void) ;
#line 1727
void ldv_main_exported_41(void) ;
#line 1728
void ldv_main_exported_47(void) ;
#line 1729
void ldv_main_exported_52(void) ;
#line 1730
void ldv_main_exported_38(void) ;
#line 1731
void ldv_main_exported_34(void) ;
#line 1732
void ldv_main_exported_37(void) ;
#line 1733
void ldv_main_exported_45(void) ;
#line 1734
void ldv_main_exported_19(void) ;
#line 1735
void ldv_main_exported_43(void) ;
#line 1736
void ldv_main_exported_63(void) ;
#line 1737
void ldv_main_exported_57(void) ;
#line 1738
void ldv_main_exported_61(void) ;
#line 1739
void ldv_main_exported_58(void) ;
#line 1740
void ldv_main_exported_59(void) ;
#line 1741
void ldv_main_exported_60(void) ;
#line 1742
void ldv_main_exported_56(void) ;
#line 1743
void ldv_main_exported_62(void) ;
#line 1744
void ldv_main_exported_54(void) ;
#line 1745
void ldv_main_exported_55(void) ;
#line 1748
void ldv_main_exported_64(void) ;
#line 1752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int main(void) 
{ 
  bool ldvarg230 ;
  int ldvarg225 ;
  struct iwl_fw *ldvarg234 ;
  void *tmp ;
  int ldvarg229 ;
  struct iwl_rx_cmd_buffer *ldvarg228 ;
  void *tmp___0 ;
  struct iwl_device_cmd *ldvarg227 ;
  void *tmp___1 ;
  struct sk_buff *ldvarg231 ;
  void *tmp___2 ;
  int ldvarg226 ;
  struct iwl_trans *ldvarg233 ;
  void *tmp___3 ;
  int (*ldvarg222)(struct napi_struct * , int  ) ;
  struct napi_struct *ldvarg224 ;
  void *tmp___4 ;
  struct net_device *ldvarg223 ;
  void *tmp___5 ;
  struct iwl_cfg *ldvarg235 ;
  void *tmp___6 ;
  struct dentry *ldvarg232 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1757
  tmp = ldv_init_zalloc(1744UL);
#line 1757
  ldvarg234 = (struct iwl_fw *)tmp;
#line 1759
  tmp___0 = ldv_init_zalloc(24UL);
#line 1759
  ldvarg228 = (struct iwl_rx_cmd_buffer *)tmp___0;
#line 1760
  tmp___1 = ldv_init_zalloc(324UL);
#line 1760
  ldvarg227 = (struct iwl_device_cmd *)tmp___1;
#line 1761
  tmp___2 = ldv_init_zalloc(232UL);
#line 1761
  ldvarg231 = (struct sk_buff *)tmp___2;
#line 1763
  tmp___3 = ldv_init_zalloc(536UL);
#line 1763
  ldvarg233 = (struct iwl_trans *)tmp___3;
#line 1765
  tmp___4 = ldv_init_zalloc(280UL);
#line 1765
  ldvarg224 = (struct napi_struct *)tmp___4;
#line 1766
  tmp___5 = ldv_init_zalloc(3008UL);
#line 1766
  ldvarg223 = (struct net_device *)tmp___5;
#line 1767
  tmp___6 = ldv_init_zalloc(184UL);
#line 1767
  ldvarg235 = (struct iwl_cfg *)tmp___6;
#line 1768
  tmp___7 = ldv_init_zalloc(320UL);
#line 1768
  ldvarg232 = (struct dentry *)tmp___7;
#line 1753
  ldv_initialize();
#line 1755
  ldv_memset((void *)(& ldvarg230), 0, 1UL);
#line 1756
  ldv_memset((void *)(& ldvarg225), 0, 4UL);
#line 1758
  ldv_memset((void *)(& ldvarg229), 0, 4UL);
#line 1762
  ldv_memset((void *)(& ldvarg226), 0, 4UL);
#line 1764
  ldv_memset((void *)(& ldvarg222), 0, 8UL);
#line 1770
  ldv_state_variable_33 = 0;
#line 1771
  ldv_state_variable_32 = 0;
#line 1772
  ldv_state_variable_63 = 0;
#line 1773
  ldv_state_variable_21 = 0;
#line 1775
  work_init_7();
#line 1777
  ldv_state_variable_7 = 1;
#line 1778
  ldv_state_variable_26 = 0;
#line 1780
  timer_init_18();
#line 1782
  ldv_state_variable_18 = 1;
#line 1784
  timer_init_16();
#line 1786
  ldv_state_variable_16 = 1;
#line 1787
  ldv_state_variable_44 = 0;
#line 1788
  ldv_state_variable_55 = 0;
#line 1789
  ldv_state_variable_27 = 0;
#line 1790
  ldv_state_variable_57 = 0;
#line 1791
  ldv_state_variable_61 = 0;
#line 1792
  ldv_state_variable_20 = 0;
#line 1794
  work_init_10();
#line 1796
  ldv_state_variable_10 = 1;
#line 1797
  ldv_state_variable_31 = 0;
#line 1798
  ldv_state_variable_35 = 0;
#line 1800
  work_init_11();
#line 1802
  ldv_state_variable_11 = 1;
#line 1803
  ldv_state_variable_48 = 0;
#line 1804
  ldv_state_variable_65 = 0;
#line 1805
  ldv_state_variable_29 = 0;
#line 1806
  ldv_state_variable_50 = 0;
#line 1807
  ldv_state_variable_39 = 0;
#line 1808
  ldv_state_variable_64 = 0;
#line 1809
  ldv_state_variable_58 = 0;
#line 1810
  ldv_state_variable_41 = 0;
#line 1812
  work_init_12();
#line 1814
  ldv_state_variable_12 = 1;
#line 1816
  timer_init_15();
#line 1818
  ldv_state_variable_15 = 1;
#line 1819
  ldv_state_variable_52 = 0;
#line 1820
  ldv_state_variable_60 = 0;
#line 1821
  ldv_state_variable_56 = 0;
#line 1822
  ldv_state_variable_66 = 0;
#line 1823
  ldv_state_variable_45 = 0;
#line 1824
  ldv_state_variable_19 = 0;
#line 1825
  ldv_state_variable_62 = 0;
#line 1826
  ldv_state_variable_54 = 0;
#line 1827
  ldv_state_variable_67 = 0;
#line 1828
  ldv_state_variable_68 = 0;
#line 1830
  work_init_2();
#line 1832
  ldv_state_variable_2 = 1;
#line 1834
  timer_init_17();
#line 1836
  ldv_state_variable_17 = 1;
#line 1838
  work_init_1();
#line 1840
  ldv_state_variable_1 = 1;
#line 1841
  ldv_state_variable_30 = 0;
#line 1842
  ldv_state_variable_25 = 0;
#line 1843
  ldv_state_variable_28 = 0;
#line 1844
  ldv_state_variable_40 = 0;
#line 1846
  work_init_14();
#line 1848
  ldv_state_variable_14 = 1;
#line 1849
  ldv_state_variable_69 = 0;
#line 1850
  ldv_state_variable_59 = 0;
#line 1851
  ldv_state_variable_49 = 0;
#line 1852
  ldv_state_variable_24 = 0;
#line 1853
  ldv_state_variable_53 = 0;
#line 1854
  ldv_state_variable_22 = 0;
#line 1855
  ldv_state_variable_42 = 0;
#line 1856
  ref_cnt = 0;
#line 1857
  ldv_state_variable_0 = 1;
#line 1858
  ldv_state_variable_46 = 0;
#line 1859
  ldv_state_variable_23 = 0;
#line 1861
  work_init_13();
#line 1863
  ldv_state_variable_13 = 1;
#line 1865
  work_init_6();
#line 1867
  ldv_state_variable_6 = 1;
#line 1869
  work_init_3();
#line 1871
  ldv_state_variable_3 = 1;
#line 1872
  ldv_state_variable_36 = 0;
#line 1874
  work_init_9();
#line 1876
  ldv_state_variable_9 = 1;
#line 1877
  ldv_state_variable_51 = 0;
#line 1878
  ldv_state_variable_47 = 0;
#line 1880
  work_init_8();
#line 1882
  ldv_state_variable_8 = 1;
#line 1883
  ldv_state_variable_38 = 0;
#line 1885
  work_init_4();
#line 1887
  ldv_state_variable_4 = 1;
#line 1888
  ldv_state_variable_34 = 0;
#line 1889
  ldv_state_variable_37 = 0;
#line 1890
  ldv_state_variable_43 = 0;
#line 1892
  work_init_5();
#line 1894
  ldv_state_variable_5 = 1;
  ldv_56370: 
#line 1896
  tmp___8 = __VERIFIER_nondet_int();
#line 1896
  switch (tmp___8) {
  case 0: ;
#line 1900
  if (ldv_state_variable_33 != 0) {
#line 1901
    ldv_main_exported_33();
  } else {

  }
#line 1904
  goto ldv_56280;
  case 1: ;
#line 1908
  if (ldv_state_variable_32 != 0) {
#line 1909
    ldv_main_exported_32();
  } else {

  }
#line 1912
  goto ldv_56280;
  case 2: ;
#line 1916
  if (ldv_state_variable_63 != 0) {
#line 1917
    ldv_main_exported_63();
  } else {

  }
#line 1920
  goto ldv_56280;
  case 3: ;
#line 1924
  if (ldv_state_variable_21 != 0) {
#line 1925
    ldv_main_exported_21();
  } else {

  }
#line 1928
  goto ldv_56280;
  case 4: ;
#line 1935
  goto ldv_56280;
  case 5: ;
#line 1939
  if (ldv_state_variable_26 != 0) {
#line 1940
    ldv_main_exported_26();
  } else {

  }
#line 1943
  goto ldv_56280;
  case 6: ;
#line 1950
  goto ldv_56280;
  case 7: ;
#line 1954
  if (ldv_state_variable_16 != 0) {
#line 1955
    choose_timer_16();
  } else {

  }
#line 1958
  goto ldv_56280;
  case 8: ;
#line 1962
  if (ldv_state_variable_44 != 0) {
#line 1963
    ldv_main_exported_44();
  } else {

  }
#line 1966
  goto ldv_56280;
  case 9: ;
#line 1970
  if (ldv_state_variable_55 != 0) {
#line 1971
    ldv_main_exported_55();
  } else {

  }
#line 1974
  goto ldv_56280;
  case 10: ;
#line 1978
  if (ldv_state_variable_27 != 0) {
#line 1979
    ldv_main_exported_27();
  } else {

  }
#line 1982
  goto ldv_56280;
  case 11: ;
#line 1986
  if (ldv_state_variable_57 != 0) {
#line 1987
    ldv_main_exported_57();
  } else {

  }
#line 1990
  goto ldv_56280;
  case 12: ;
#line 1994
  if (ldv_state_variable_61 != 0) {
#line 1995
    ldv_main_exported_61();
  } else {

  }
#line 1998
  goto ldv_56280;
  case 13: ;
#line 2002
  if (ldv_state_variable_20 != 0) {
#line 2003
    ldv_main_exported_20();
  } else {

  }
#line 2006
  goto ldv_56280;
  case 14: ;
#line 2013
  goto ldv_56280;
  case 15: ;
#line 2017
  if (ldv_state_variable_31 != 0) {
#line 2018
    ldv_main_exported_31();
  } else {

  }
#line 2021
  goto ldv_56280;
  case 16: ;
#line 2025
  if (ldv_state_variable_35 != 0) {
#line 2026
    ldv_main_exported_35();
  } else {

  }
#line 2029
  goto ldv_56280;
  case 17: ;
#line 2036
  goto ldv_56280;
  case 18: ;
#line 2040
  if (ldv_state_variable_48 != 0) {
#line 2041
    ldv_main_exported_48();
  } else {

  }
#line 2044
  goto ldv_56280;
  case 19: ;
#line 2048
  if (ldv_state_variable_65 != 0) {
#line 2049
    ldv_main_exported_65();
  } else {

  }
#line 2052
  goto ldv_56280;
  case 20: ;
#line 2056
  if (ldv_state_variable_29 != 0) {
#line 2057
    ldv_main_exported_29();
  } else {

  }
#line 2060
  goto ldv_56280;
  case 21: ;
#line 2064
  if (ldv_state_variable_50 != 0) {
#line 2065
    ldv_main_exported_50();
  } else {

  }
#line 2068
  goto ldv_56280;
  case 22: ;
#line 2072
  if (ldv_state_variable_39 != 0) {
#line 2073
    ldv_main_exported_39();
  } else {

  }
#line 2076
  goto ldv_56280;
  case 23: ;
#line 2080
  if (ldv_state_variable_64 != 0) {
#line 2081
    ldv_main_exported_64();
  } else {

  }
#line 2084
  goto ldv_56280;
  case 24: ;
#line 2088
  if (ldv_state_variable_58 != 0) {
#line 2089
    ldv_main_exported_58();
  } else {

  }
#line 2092
  goto ldv_56280;
  case 25: ;
#line 2096
  if (ldv_state_variable_41 != 0) {
#line 2097
    ldv_main_exported_41();
  } else {

  }
#line 2100
  goto ldv_56280;
  case 26: ;
#line 2107
  goto ldv_56280;
  case 27: ;
#line 2111
  if (ldv_state_variable_15 != 0) {
#line 2112
    choose_timer_15();
  } else {

  }
#line 2115
  goto ldv_56280;
  case 28: ;
#line 2119
  if (ldv_state_variable_52 != 0) {
#line 2120
    ldv_main_exported_52();
  } else {

  }
#line 2123
  goto ldv_56280;
  case 29: ;
#line 2127
  if (ldv_state_variable_60 != 0) {
#line 2128
    ldv_main_exported_60();
  } else {

  }
#line 2131
  goto ldv_56280;
  case 30: ;
#line 2135
  if (ldv_state_variable_56 != 0) {
#line 2136
    ldv_main_exported_56();
  } else {

  }
#line 2139
  goto ldv_56280;
  case 31: ;
#line 2143
  if (ldv_state_variable_66 != 0) {
#line 2144
    ldv_main_exported_66();
  } else {

  }
#line 2147
  goto ldv_56280;
  case 32: ;
#line 2151
  if (ldv_state_variable_45 != 0) {
#line 2152
    ldv_main_exported_45();
  } else {

  }
#line 2155
  goto ldv_56280;
  case 33: ;
#line 2159
  if (ldv_state_variable_19 != 0) {
#line 2160
    ldv_main_exported_19();
  } else {

  }
#line 2163
  goto ldv_56280;
  case 34: ;
#line 2167
  if (ldv_state_variable_62 != 0) {
#line 2168
    ldv_main_exported_62();
  } else {

  }
#line 2171
  goto ldv_56280;
  case 35: ;
#line 2175
  if (ldv_state_variable_54 != 0) {
#line 2176
    ldv_main_exported_54();
  } else {

  }
#line 2179
  goto ldv_56280;
  case 36: ;
#line 2183
  if (ldv_state_variable_67 != 0) {
#line 2184
    ldv_main_exported_67();
  } else {

  }
#line 2187
  goto ldv_56280;
  case 37: ;
#line 2191
  if (ldv_state_variable_68 != 0) {
#line 2192
    ldv_main_exported_68();
  } else {

  }
#line 2195
  goto ldv_56280;
  case 38: ;
#line 2199
  if (ldv_state_variable_2 != 0) {
#line 2200
    invoke_work_2();
  } else {

  }
#line 2203
  goto ldv_56280;
  case 39: ;
#line 2210
  goto ldv_56280;
  case 40: ;
#line 2214
  if (ldv_state_variable_1 != 0) {
#line 2215
    invoke_work_1();
  } else {

  }
#line 2218
  goto ldv_56280;
  case 41: ;
#line 2222
  if (ldv_state_variable_30 != 0) {
#line 2223
    ldv_main_exported_30();
  } else {

  }
#line 2226
  goto ldv_56280;
  case 42: ;
#line 2230
  if (ldv_state_variable_25 != 0) {
#line 2231
    ldv_main_exported_25();
  } else {

  }
#line 2234
  goto ldv_56280;
  case 43: ;
#line 2238
  if (ldv_state_variable_28 != 0) {
#line 2239
    ldv_main_exported_28();
  } else {

  }
#line 2242
  goto ldv_56280;
  case 44: ;
#line 2246
  if (ldv_state_variable_40 != 0) {
#line 2247
    ldv_main_exported_40();
  } else {

  }
#line 2250
  goto ldv_56280;
  case 45: ;
#line 2257
  goto ldv_56280;
  case 46: ;
#line 2261
  if (ldv_state_variable_69 != 0) {
#line 2262
    tmp___9 = __VERIFIER_nondet_int();
#line 2262
    switch (tmp___9) {
    case 0: ;
#line 2265
    if (ldv_state_variable_69 == 1) {
#line 2267
      iwl_nic_error(iwl_dvm_ops_group0);
#line 2269
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2272
    if (ldv_state_variable_69 == 2) {
#line 2274
      iwl_nic_error(iwl_dvm_ops_group0);
#line 2276
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2279
    goto ldv_56328;
    case 1: ;
#line 2282
    if (ldv_state_variable_69 == 1) {
#line 2284
      iwl_op_mode_dvm_start(ldvarg233, (struct iwl_cfg  const  *)ldvarg235, (struct iwl_fw  const  *)ldvarg234,
                            ldvarg232);
#line 2286
      ldv_state_variable_69 = 2;
#line 2287
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 2290
    goto ldv_56328;
    case 2: ;
#line 2293
    if (ldv_state_variable_69 == 1) {
#line 2295
      iwl_cmd_queue_full(iwl_dvm_ops_group0);
#line 2297
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2300
    if (ldv_state_variable_69 == 2) {
#line 2302
      iwl_cmd_queue_full(iwl_dvm_ops_group0);
#line 2304
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2307
    goto ldv_56328;
    case 3: ;
#line 2310
    if (ldv_state_variable_69 == 1) {
#line 2312
      iwl_free_skb(iwl_dvm_ops_group0, ldvarg231);
#line 2314
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2317
    if (ldv_state_variable_69 == 2) {
#line 2319
      iwl_free_skb(iwl_dvm_ops_group0, ldvarg231);
#line 2321
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2324
    goto ldv_56328;
    case 4: ;
#line 2327
    if (ldv_state_variable_69 == 1) {
#line 2329
      iwl_wimax_active(iwl_dvm_ops_group0);
#line 2331
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2334
    if (ldv_state_variable_69 == 2) {
#line 2336
      iwl_wimax_active(iwl_dvm_ops_group0);
#line 2338
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2341
    goto ldv_56328;
    case 5: ;
#line 2344
    if (ldv_state_variable_69 == 1) {
#line 2346
      iwl_set_hw_rfkill_state(iwl_dvm_ops_group0, (int )ldvarg230);
#line 2348
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2351
    if (ldv_state_variable_69 == 2) {
#line 2353
      iwl_set_hw_rfkill_state(iwl_dvm_ops_group0, (int )ldvarg230);
#line 2355
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2358
    goto ldv_56328;
    case 6: ;
#line 2361
    if (ldv_state_variable_69 == 1) {
#line 2363
      iwl_stop_sw_queue(iwl_dvm_ops_group0, ldvarg229);
#line 2365
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2368
    if (ldv_state_variable_69 == 2) {
#line 2370
      iwl_stop_sw_queue(iwl_dvm_ops_group0, ldvarg229);
#line 2372
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2375
    goto ldv_56328;
    case 7: ;
#line 2378
    if (ldv_state_variable_69 == 1) {
#line 2380
      iwl_rx_dispatch(iwl_dvm_ops_group0, ldvarg228, ldvarg227);
#line 2382
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2385
    if (ldv_state_variable_69 == 2) {
#line 2387
      iwl_rx_dispatch(iwl_dvm_ops_group0, ldvarg228, ldvarg227);
#line 2389
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2392
    goto ldv_56328;
    case 8: ;
#line 2395
    if (ldv_state_variable_69 == 2) {
#line 2397
      iwl_op_mode_dvm_stop(iwl_dvm_ops_group0);
#line 2399
      ldv_state_variable_69 = 1;
#line 2400
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2403
    goto ldv_56328;
    case 9: ;
#line 2406
    if (ldv_state_variable_69 == 1) {
#line 2408
      iwl_nic_config(iwl_dvm_ops_group0);
#line 2410
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2413
    if (ldv_state_variable_69 == 2) {
#line 2415
      iwl_nic_config(iwl_dvm_ops_group0);
#line 2417
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2420
    goto ldv_56328;
    case 10: ;
#line 2423
    if (ldv_state_variable_69 == 1) {
#line 2425
      iwl_wake_sw_queue(iwl_dvm_ops_group0, ldvarg226);
#line 2427
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2430
    if (ldv_state_variable_69 == 2) {
#line 2432
      iwl_wake_sw_queue(iwl_dvm_ops_group0, ldvarg226);
#line 2434
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2437
    goto ldv_56328;
    case 11: ;
#line 2440
    if (ldv_state_variable_69 == 1) {
#line 2442
      iwl_napi_add(iwl_dvm_ops_group0, ldvarg224, ldvarg223, ldvarg222, ldvarg225);
#line 2444
      ldv_state_variable_69 = 1;
    } else {

    }
#line 2447
    if (ldv_state_variable_69 == 2) {
#line 2449
      iwl_napi_add(iwl_dvm_ops_group0, ldvarg224, ldvarg223, ldvarg222, ldvarg225);
#line 2451
      ldv_state_variable_69 = 2;
    } else {

    }
#line 2454
    goto ldv_56328;
    default: 
#line 2455
    ldv_stop();
    }
    ldv_56328: ;
  } else {

  }
#line 2459
  goto ldv_56280;
  case 47: ;
#line 2463
  if (ldv_state_variable_59 != 0) {
#line 2464
    ldv_main_exported_59();
  } else {

  }
#line 2467
  goto ldv_56280;
  case 48: ;
#line 2471
  if (ldv_state_variable_49 != 0) {
#line 2472
    ldv_main_exported_49();
  } else {

  }
#line 2475
  goto ldv_56280;
  case 49: ;
#line 2479
  if (ldv_state_variable_24 != 0) {
#line 2480
    ldv_main_exported_24();
  } else {

  }
#line 2483
  goto ldv_56280;
  case 50: ;
#line 2487
  if (ldv_state_variable_53 != 0) {
#line 2488
    ldv_main_exported_53();
  } else {

  }
#line 2491
  goto ldv_56280;
  case 51: ;
#line 2495
  if (ldv_state_variable_22 != 0) {
#line 2496
    ldv_main_exported_22();
  } else {

  }
#line 2499
  goto ldv_56280;
  case 52: ;
#line 2503
  if (ldv_state_variable_42 != 0) {
#line 2504
    ldv_main_exported_42();
  } else {

  }
#line 2507
  goto ldv_56280;
  case 53: ;
#line 2511
  if (ldv_state_variable_0 != 0) {
#line 2512
    tmp___10 = __VERIFIER_nondet_int();
#line 2512
    switch (tmp___10) {
    case 0: ;
#line 2515
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 2517
      iwl_exit();
#line 2518
      ldv_state_variable_0 = 3;
#line 2519
      goto ldv_final;
    } else {

    }
#line 2522
    goto ldv_56350;
    case 1: ;
#line 2525
    if (ldv_state_variable_0 == 1) {
#line 2527
      ldv_retval_30 = iwl_init();
#line 2528
      if (ldv_retval_30 != 0) {
#line 2529
        ldv_state_variable_0 = 3;
#line 2530
        goto ldv_final;
      } else {

      }
#line 2533
      if (ldv_retval_30 == 0) {
#line 2534
        ldv_state_variable_0 = 2;
#line 2535
        ldv_state_variable_54 = 1;
#line 2536
        ldv_initialize_iwl_dvm_cfg_54();
#line 2537
        ldv_state_variable_62 = 1;
#line 2538
        ldv_initialize_iwl_dvm_cfg_62();
#line 2539
        ldv_state_variable_43 = 1;
#line 2540
        ldv_file_operations_43();
#line 2541
        ldv_state_variable_19 = 1;
#line 2542
        ldv_file_operations_19();
#line 2543
        ldv_state_variable_45 = 1;
#line 2544
        ldv_file_operations_45();
#line 2545
        ldv_state_variable_37 = 1;
#line 2546
        ldv_file_operations_37();
#line 2547
        ldv_state_variable_66 = 1;
#line 2548
        ldv_file_operations_66();
#line 2549
        ldv_state_variable_56 = 1;
#line 2550
        ldv_initialize_iwl_dvm_cfg_56();
#line 2551
        ldv_state_variable_34 = 1;
#line 2552
        ldv_file_operations_34();
#line 2553
        ldv_state_variable_60 = 1;
#line 2554
        ldv_initialize_iwl_dvm_cfg_60();
#line 2555
        ldv_state_variable_38 = 1;
#line 2556
        ldv_file_operations_38();
#line 2557
        ldv_state_variable_52 = 1;
#line 2558
        ldv_file_operations_52();
#line 2559
        ldv_state_variable_47 = 1;
#line 2560
        ldv_file_operations_47();
#line 2561
        ldv_state_variable_41 = 1;
#line 2562
        ldv_file_operations_41();
#line 2563
        ldv_state_variable_58 = 1;
#line 2564
        ldv_initialize_iwl_dvm_cfg_58();
#line 2565
        ldv_state_variable_51 = 1;
#line 2566
        ldv_file_operations_51();
#line 2567
        ldv_state_variable_36 = 1;
#line 2568
        ldv_file_operations_36();
#line 2569
        ldv_state_variable_39 = 1;
#line 2570
        ldv_file_operations_39();
#line 2571
        ldv_state_variable_50 = 1;
#line 2572
        ldv_file_operations_50();
#line 2573
        ldv_state_variable_29 = 1;
#line 2574
        ldv_file_operations_29();
#line 2575
        ldv_state_variable_65 = 1;
#line 2576
        ldv_initialize_rate_control_ops_65();
#line 2577
        ldv_state_variable_23 = 1;
#line 2578
        ldv_file_operations_23();
#line 2579
        ldv_state_variable_46 = 1;
#line 2580
        ldv_file_operations_46();
#line 2581
        ldv_state_variable_42 = 1;
#line 2582
        ldv_file_operations_42();
#line 2583
        ldv_state_variable_22 = 1;
#line 2584
        ldv_file_operations_22();
#line 2585
        ldv_state_variable_48 = 1;
#line 2586
        ldv_file_operations_48();
#line 2587
        ldv_state_variable_53 = 1;
#line 2588
        ldv_file_operations_53();
#line 2589
        ldv_state_variable_35 = 1;
#line 2590
        ldv_file_operations_35();
#line 2591
        ldv_state_variable_31 = 1;
#line 2592
        ldv_file_operations_31();
#line 2593
        ldv_state_variable_24 = 1;
#line 2594
        ldv_file_operations_24();
#line 2595
        ldv_state_variable_49 = 1;
#line 2596
        ldv_file_operations_49();
#line 2597
        ldv_state_variable_59 = 1;
#line 2598
        ldv_initialize_iwl_dvm_cfg_59();
#line 2599
        ldv_state_variable_69 = 1;
#line 2600
        ldv_initialize_iwl_op_mode_ops_69();
#line 2601
        ldv_state_variable_20 = 1;
#line 2602
        ldv_file_operations_20();
#line 2603
        ldv_state_variable_61 = 1;
#line 2604
        ldv_initialize_iwl_dvm_cfg_61();
#line 2605
        ldv_state_variable_40 = 1;
#line 2606
        ldv_file_operations_40();
#line 2607
        ldv_state_variable_57 = 1;
#line 2608
        ldv_initialize_iwl_dvm_cfg_57();
#line 2609
        ldv_state_variable_28 = 1;
#line 2610
        ldv_file_operations_28();
#line 2611
        ldv_state_variable_27 = 1;
#line 2612
        ldv_file_operations_27();
#line 2613
        ldv_state_variable_25 = 1;
#line 2614
        ldv_file_operations_25();
#line 2615
        ldv_state_variable_55 = 1;
#line 2616
        ldv_initialize_iwl_dvm_cfg_55();
#line 2617
        ldv_state_variable_44 = 1;
#line 2618
        ldv_file_operations_44();
#line 2619
        ldv_state_variable_30 = 1;
#line 2620
        ldv_file_operations_30();
#line 2621
        ldv_state_variable_26 = 1;
#line 2622
        ldv_file_operations_26();
#line 2623
        ldv_state_variable_68 = 1;
#line 2624
        ldv_file_operations_68();
#line 2625
        ldv_state_variable_21 = 1;
#line 2626
        ldv_file_operations_21();
#line 2627
        ldv_state_variable_63 = 1;
#line 2628
        ldv_initialize_iwl_dvm_cfg_63();
#line 2629
        ldv_state_variable_32 = 1;
#line 2630
        ldv_file_operations_32();
#line 2631
        ldv_state_variable_33 = 1;
#line 2632
        ldv_file_operations_33();
#line 2633
        ldv_state_variable_67 = 1;
#line 2634
        ldv_file_operations_67();
      } else {

      }
    } else {

    }
#line 2638
    goto ldv_56350;
    default: 
#line 2639
    ldv_stop();
    }
    ldv_56350: ;
  } else {

  }
#line 2643
  goto ldv_56280;
  case 54: ;
#line 2647
  if (ldv_state_variable_46 != 0) {
#line 2648
    ldv_main_exported_46();
  } else {

  }
#line 2651
  goto ldv_56280;
  case 55: ;
#line 2655
  if (ldv_state_variable_23 != 0) {
#line 2656
    ldv_main_exported_23();
  } else {

  }
#line 2659
  goto ldv_56280;
  case 56: ;
#line 2666
  goto ldv_56280;
  case 57: ;
#line 2670
  if (ldv_state_variable_6 != 0) {
#line 2671
    invoke_work_6();
  } else {

  }
#line 2674
  goto ldv_56280;
  case 58: ;
#line 2678
  if (ldv_state_variable_3 != 0) {
#line 2679
    invoke_work_3();
  } else {

  }
#line 2682
  goto ldv_56280;
  case 59: ;
#line 2686
  if (ldv_state_variable_36 != 0) {
#line 2687
    ldv_main_exported_36();
  } else {

  }
#line 2690
  goto ldv_56280;
  case 60: ;
#line 2697
  goto ldv_56280;
  case 61: ;
#line 2701
  if (ldv_state_variable_51 != 0) {
#line 2702
    ldv_main_exported_51();
  } else {

  }
#line 2705
  goto ldv_56280;
  case 62: ;
#line 2709
  if (ldv_state_variable_47 != 0) {
#line 2710
    ldv_main_exported_47();
  } else {

  }
#line 2713
  goto ldv_56280;
  case 63: ;
#line 2720
  goto ldv_56280;
  case 64: ;
#line 2724
  if (ldv_state_variable_38 != 0) {
#line 2725
    ldv_main_exported_38();
  } else {

  }
#line 2728
  goto ldv_56280;
  case 65: ;
#line 2732
  if (ldv_state_variable_4 != 0) {
#line 2733
    invoke_work_4();
  } else {

  }
#line 2736
  goto ldv_56280;
  case 66: ;
#line 2740
  if (ldv_state_variable_34 != 0) {
#line 2741
    ldv_main_exported_34();
  } else {

  }
#line 2744
  goto ldv_56280;
  case 67: ;
#line 2748
  if (ldv_state_variable_37 != 0) {
#line 2749
    ldv_main_exported_37();
  } else {

  }
#line 2752
  goto ldv_56280;
  case 68: ;
#line 2756
  if (ldv_state_variable_43 != 0) {
#line 2757
    ldv_main_exported_43();
  } else {

  }
#line 2760
  goto ldv_56280;
  case 69: ;
#line 2764
  if (ldv_state_variable_5 != 0) {
#line 2765
    invoke_work_5();
  } else {

  }
#line 2768
  goto ldv_56280;
  default: 
#line 2769
  ldv_stop();
  }
  ldv_56280: ;
#line 2771
  goto ldv_56370;
  ldv_final: 
#line 2773
  ldv_check_final_state();
#line 2774
  return 0;
}
}
#line 2801 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 2805
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2805
  ldv_func_res = tmp;
#line 2807
  activate_work_7(ldv_func_arg3, 2);
#line 2809
  return (ldv_func_res);
}
}
#line 2812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 2816
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2816
  ldv_func_res = tmp;
#line 2818
  activate_work_7(& ldv_func_arg3->work, 2);
#line 2820
  return (ldv_func_res);
}
}
#line 2823 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 2827
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2827
  ldv_func_res = tmp;
#line 2829
  activate_work_7(ldv_func_arg3, 2);
#line 2831
  return (ldv_func_res);
}
}
#line 2834 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2837
  flush_workqueue(ldv_func_arg1);
#line 2839
  call_and_disable_all_7(2);
#line 2840
  return;
}
}
#line 2842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 2846
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2846
  ldv_func_res = tmp;
#line 2848
  activate_work_7(& ldv_func_arg3->work, 2);
#line 2850
  return (ldv_func_res);
}
}
#line 2853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2856
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2858
  mutex_lock(ldv_func_arg1);
#line 2859
  return;
}
}
#line 2861 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2864
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2866
  mutex_unlock(ldv_func_arg1);
#line 2867
  return;
}
}
#line 2869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2872
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 2874
  mutex_lock(ldv_func_arg1);
#line 2875
  return;
}
}
#line 2877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_mutex_trylock_13(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2881
  tmp = mutex_trylock(ldv_func_arg1);
#line 2881
  ldv_func_res = tmp;
#line 2883
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 2883
  return (tmp___0);
#line 2885
  return (ldv_func_res);
}
}
#line 2888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2891
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 2893
  mutex_unlock(ldv_func_arg1);
#line 2894
  return;
}
}
#line 2896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2899
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 2901
  mutex_unlock(ldv_func_arg1);
#line 2902
  return;
}
}
#line 2904 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2907
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 2909
  mutex_lock(ldv_func_arg1);
#line 2910
  return;
}
}
#line 2912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2915
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 2917
  mutex_lock(ldv_func_arg1);
#line 2918
  return;
}
}
#line 2920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2923
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 2925
  mutex_unlock(ldv_func_arg1);
#line 2926
  return;
}
}
#line 2928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_lock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2931
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 2933
  mutex_lock(ldv_func_arg1);
#line 2934
  return;
}
}
#line 2936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2939
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 2941
  mutex_unlock(ldv_func_arg1);
#line 2942
  return;
}
}
#line 2944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_lock_21(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2947
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 2949
  mutex_lock(ldv_func_arg1);
#line 2950
  return;
}
}
#line 2952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2955
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 2957
  mutex_unlock(ldv_func_arg1);
#line 2958
  return;
}
}
#line 2960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_mod_timer_23(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 2964
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2964
  ldv_func_res = tmp;
#line 2966
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
#line 2968
  return (ldv_func_res);
}
}
#line 2971 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_mod_timer_24(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 2975
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2975
  ldv_func_res = tmp;
#line 2977
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
#line 2979
  return (ldv_func_res);
}
}
#line 2982 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2985
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 2987
  mutex_lock(ldv_func_arg1);
#line 2988
  return;
}
}
#line 2990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2993
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 2995
  mutex_unlock(ldv_func_arg1);
#line 2996
  return;
}
}
#line 2998 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3001
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3003
  mutex_unlock(ldv_func_arg1);
#line 3004
  return;
}
}
#line 3006 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_lock_28(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3009
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3011
  mutex_lock(ldv_func_arg1);
#line 3012
  return;
}
}
#line 3014 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3017
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3019
  mutex_unlock(ldv_func_arg1);
#line 3020
  return;
}
}
#line 3022 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
bool ldv_cancel_work_sync_30(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 3026
  tmp = cancel_work_sync(ldv_func_arg1);
#line 3026
  ldv_func_res = tmp;
#line 3028
  disable_work_7(ldv_func_arg1);
#line 3030
  return (ldv_func_res);
}
}
#line 3033 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
bool ldv_cancel_work_sync_31(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
#line 3037
  tmp = cancel_work_sync(ldv_func_arg1);
#line 3037
  ldv_func_res = tmp;
#line 3039
  disable_work_7(ldv_func_arg1);
#line 3041
  return (ldv_func_res);
}
}
#line 3044 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
bool ldv_cancel_work_sync_32(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
#line 3048
  tmp = cancel_work_sync(ldv_func_arg1);
#line 3048
  ldv_func_res = tmp;
#line 3050
  disable_work_7(ldv_func_arg1);
#line 3052
  return (ldv_func_res);
}
}
#line 3055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
bool ldv_cancel_work_sync_33(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  bool tmp ;

  {
#line 3059
  tmp = cancel_work_sync(ldv_func_arg1);
#line 3059
  ldv_func_res = tmp;
#line 3061
  disable_work_7(ldv_func_arg1);
#line 3063
  return (ldv_func_res);
}
}
#line 3066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_del_timer_sync_34(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 3070
  tmp = del_timer_sync(ldv_func_arg1);
#line 3070
  ldv_func_res = tmp;
#line 3072
  disable_suitable_timer_18(ldv_func_arg1);
#line 3074
  return (ldv_func_res);
}
}
#line 3077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
int ldv_del_timer_sync_35(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 3081
  tmp = del_timer_sync(ldv_func_arg1);
#line 3081
  ldv_func_res = tmp;
#line 3083
  disable_suitable_timer_18(ldv_func_arg1);
#line 3085
  return (ldv_func_res);
}
}
#line 3088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_destroy_workqueue_36(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 3091
  destroy_workqueue(ldv_func_arg1);
#line 3093
  call_and_disable_all_7(2);
#line 3094
  return;
}
}
#line 3096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_ieee80211_free_hw_37(struct ieee80211_hw *ldv_func_arg1 ) 
{ 


  {
#line 3099
  ieee80211_free_hw(ldv_func_arg1);
#line 3101
  if ((unsigned long )iwlagn_hw_ops_group0 == (unsigned long )ldv_func_arg1) {
#line 3102
    ldv_state_variable_64 = 0;
  } else {

  }
#line 3103
  return;
}
}
#line 3106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_flush_workqueue_38(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 3109
  flush_workqueue(ldv_func_arg1);
#line 3111
  call_and_disable_all_7(2);
#line 3112
  return;
}
}
#line 3114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_destroy_workqueue_39(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 3117
  destroy_workqueue(ldv_func_arg1);
#line 3119
  call_and_disable_all_7(2);
#line 3120
  return;
}
}
#line 3122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/main.o.c.prepared"
void ldv_ieee80211_free_hw_40(struct ieee80211_hw *ldv_func_arg1 ) 
{ 


  {
#line 3125
  ieee80211_free_hw(ldv_func_arg1);
#line 3127
  if ((unsigned long )iwlagn_hw_ops_group0 == (unsigned long )ldv_func_arg1) {
#line 3128
    ldv_state_variable_64 = 0;
  } else {

  }
#line 3129
  return;
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 42
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 402
extern int sprintf(char * , char const   *  , ...) ;
#line 417
extern int sscanf(char const   * , char const   *  , ...) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_89(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_87(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_mutex_lock_86(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_88(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_92(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_82(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_85(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_84(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_81(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 650 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 672
extern void __copy_from_user_overflow(void) ;
#line 693 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 695
  tmp = __builtin_object_size((void const   *)to, 0);
#line 695
  sz = (int )tmp;
#line 697
  __might_fault("./arch/x86/include/asm/uaccess.h", 697);
#line 717
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 717
  if (tmp___0 != 0L) {
#line 718
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 722
    __copy_from_user_overflow();
  }
#line 724
  return (n);
}
}
#line 271 "include/linux/ieee80211.h"
__inline static int ieee80211_has_a4(__le16 fc ) 
{ 
  __le16 tmp ;

  {
#line 273
  tmp = 768U;
#line 274
  return (((int )fc & (int )tmp) == (int )tmp);
}
}
#line 355 "include/linux/ieee80211.h"
__inline static int ieee80211_is_data(__le16 fc ) 
{ 


  {
#line 357
  return (((int )fc & 12) == 8);
}
}
#line 365 "include/linux/ieee80211.h"
__inline static int ieee80211_is_data_qos(__le16 fc ) 
{ 


  {
#line 371
  return (((int )fc & 140) == 136);
}
}
#line 2329 "include/linux/ieee80211.h"
__inline static u8 *ieee80211_get_qos_ctl(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;

  {
#line 2331
  tmp = ieee80211_has_a4((int )hdr->frame_control);
#line 2331
  if (tmp != 0) {
#line 2332
    return ((u8 *)hdr + 30UL);
  } else {
#line 2334
    return ((u8 *)hdr + 24UL);
  }
}
}
#line 2536 "include/linux/fs.h"
extern loff_t default_llseek(struct file * , loff_t  , int  ) ;
#line 2801
extern int simple_open(struct inode * , struct file * ) ;
#line 2832
extern ssize_t simple_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
#line 49 "include/linux/debugfs.h"
extern struct dentry *debugfs_create_file(char const   * , umode_t  , struct dentry * ,
                                          void * , struct file_operations  const  * ) ;
#line 68
extern void debugfs_remove(struct dentry * ) ;
#line 74
extern struct dentry *debugfs_create_u8(char const   * , umode_t  , struct dentry * ,
                                        u8 * ) ;
#line 4694 "include/net/mac80211.h"
extern int ieee80211_start_tx_ba_session(struct ieee80211_sta * , u16  , u16  ) ;
#line 4721
extern int ieee80211_stop_tx_ba_session(struct ieee80211_sta * , u16  ) ;
#line 5148 "include/net/mac80211.h"
__inline static int rate_supported(struct ieee80211_sta *sta , enum ieee80211_band band ,
                                   int index ) 
{ 


  {
#line 5152
  return ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0) || (int )((unsigned long )sta->supp_rates[(unsigned int )band] >> index) & 1);
}
}
#line 5173
extern bool rate_control_send_low(struct ieee80211_sta * , void * , struct ieee80211_tx_rate_control * ) ;
#line 5179 "include/net/mac80211.h"
__inline static s8 rate_lowest_index(struct ieee80211_supported_band *sband , struct ieee80211_sta *sta ) 
{ 
  int i ;
  int tmp ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 5184
  i = 0;
#line 5184
  goto ldv_48905;
  ldv_48904: 
#line 5185
  tmp = rate_supported(sta, sband->band, i);
#line 5185
  if (tmp != 0) {
#line 5186
    return ((s8 )i);
  } else {

  }
#line 5184
  i = i + 1;
  ldv_48905: ;
#line 5184
  if (sband->n_bitrates > i) {
#line 5186
    goto ldv_48904;
  } else {

  }
#line 5189
  __ret_warn_once = 1;
#line 5189
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 5189
  if (tmp___2 != 0L) {
#line 5189
    __ret_warn_on = ! __warned;
#line 5189
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 5189
    if (tmp___0 != 0L) {
#line 5189
      warn_slowpath_null("include/net/mac80211.h", 5189);
    } else {

    }
#line 5189
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 5189
    if (tmp___1 != 0L) {
#line 5189
      __warned = 1;
    } else {

    }
  } else {

  }
#line 5189
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 5192
  return (0);
}
}
#line 5223
extern int ieee80211_rate_control_register(struct rate_control_ops  const  * ) ;
#line 5224
extern void ieee80211_rate_control_unregister(struct rate_control_ops  const  * ) ;
#line 5253 "include/net/mac80211.h"
__inline static bool conf_is_ht(struct ieee80211_conf *conf ) 
{ 


  {
#line 5255
  return ((bool )(((unsigned int )conf->chandef.width != 6U && (unsigned int )conf->chandef.width != 7U) && (unsigned int )conf->chandef.width != 0U));
}
}
#line 264 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
struct iwl_rate_info  const  iwl_rates[13U] ;
#line 392 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/rs.h"
__inline static u8 first_antenna(u8 mask ) 
{ 


  {
#line 394
  if ((int )mask & 1) {
#line 395
    return (1U);
  } else {

  }
#line 396
  if (((unsigned long )mask & 2UL) != 0UL) {
#line 397
    return (2U);
  } else {

  }
#line 398
  return (4U);
}
}
#line 403
void iwl_rs_rate_init(struct iwl_priv *priv , struct ieee80211_sta *sta , u8 sta_id ) ;
#line 119 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/tt.h"
bool iwl_ht_enabled(struct iwl_priv *priv ) ;
#line 120
enum iwl_antenna_ok iwl_tx_ant_restriction(struct iwl_priv *priv ) ;
#line 333 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
int iwl_send_lq_cmd(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct iwl_link_quality_cmd *lq ,
                    u8 flags , bool init ) ;
#line 340
bool iwl_is_ht40_tx_allowed(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct ieee80211_sta *sta ) ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u8 rs_ht_to_legacy[13U]  = 
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
  {      4U,      4U,      4U,      4U, 
        4U,      4U,      5U,      6U, 
        7U,      8U,      9U,      10U, 
        11U};
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u8 const   ant_toggle_lookup[8U]  = 
#line 65
  {      0U,      2U,      4U,      6U, 
        1U,      3U,      5U,      7U};
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
struct iwl_rate_info  const  iwl_rates[13U]  = 
#line 97
  {      {10U, 24U, 24U, 24U, 2U, 13U, 1U, 13U, 1U, 13U, 1U}, 
        {20U, 24U, 24U, 24U, 4U, 0U, 2U, 0U, 2U, 0U, 2U}, 
        {55U, 24U, 24U, 24U, 11U, 1U, 4U, 1U, 3U, 1U, 3U}, 
        {110U, 24U, 24U, 24U, 22U, 5U, 6U, 5U, 6U, 2U, 7U}, 
        {13U, 0U, 8U, 16U, 12U, 2U, 5U, 2U, 3U, 2U, 3U}, 
        {15U, 0U, 8U, 16U, 18U, 4U, 3U, 4U, 3U, 2U, 3U}, 
        {5U, 1U, 9U, 17U, 24U, 3U, 7U, 3U, 7U, 3U, 7U}, 
        {7U, 2U, 10U, 18U, 36U, 6U, 8U, 6U, 8U, 3U, 8U}, 
        {9U, 3U, 11U, 19U, 48U, 7U, 9U, 7U, 9U, 7U, 9U}, 
        {11U, 4U, 12U, 20U, 72U, 8U, 10U, 8U, 10U, 8U, 10U}, 
        {1U, 5U, 13U, 21U, 96U, 9U, 11U, 9U, 11U, 9U, 11U}, 
        {3U, 6U, 14U, 22U, 108U, 10U, 13U, 10U, 13U, 10U, 13U}, 
        {3U, 7U, 15U, 23U, 120U, 10U, 13U, 10U, 13U, 10U, 13U}};
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
__inline static u8 rs_extract_rate(u32 rate_n_flags ) 
{ 


  {
#line 116
  return ((u8 )rate_n_flags);
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int iwl_hwrate_to_plcp_idx(u32 rate_n_flags ) 
{ 
  int idx ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 121
  idx = 0;
#line 124
  if ((rate_n_flags & 256U) != 0U) {
#line 125
    tmp = rs_extract_rate(rate_n_flags);
#line 125
    idx = (int )tmp;
#line 127
    if (idx > 15) {
#line 128
      idx = idx + -16;
    } else
#line 129
    if (idx > 7) {
#line 130
      idx = idx + -8;
    } else {

    }
#line 132
    idx = idx + 4;
#line 134
    if (idx > 4) {
#line 135
      idx = idx + 1;
    } else {

    }
#line 136
    if (idx > 3 && idx <= 12) {
#line 137
      return (idx);
    } else {

    }
  } else {
#line 141
    idx = 0;
#line 141
    goto ldv_52877;
    ldv_52876: 
#line 142
    tmp___0 = rs_extract_rate(rate_n_flags);
#line 142
    if ((int )((unsigned char )iwl_rates[idx].plcp) == (int )tmp___0) {
#line 144
      return (idx);
    } else {

    }
#line 141
    idx = idx + 1;
    ldv_52877: ;
#line 141
    if ((unsigned int )idx <= 12U) {
#line 143
      goto ldv_52876;
    } else {

    }

  }
#line 147
  return (-1);
}
}
#line 150
static void rs_rate_scale_perform(struct iwl_priv *priv , struct sk_buff *skb , struct ieee80211_sta *sta ,
                                  struct iwl_lq_sta *lq_sta ) ;
#line 154
static void rs_fill_link_cmd(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta , u32 new_rate ) ;
#line 156
static void rs_stay_in_table(struct iwl_lq_sta *lq_sta , bool force_search ) ;
#line 160
static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta , u32 *rate_n_flags , int index ) ;
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 const   expected_tpt_legacy[13U]  = 
#line 179
  {      7U,      13U,      35U,      58U, 
        40U,      57U,      72U,      98U, 
        121U,      154U,      177U,      186U, 
        0U};
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 const   expected_tpt_siso20MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            42U,        0U,        76U,        102U, 
            124U,        159U,        183U,        193U, 
            202U}, 
   {        0U,        0U,        0U,        0U, 
            46U,        0U,        82U,        110U, 
            132U,        168U,        192U,        202U, 
            210U}, 
   {        0U,        0U,        0U,        0U, 
            47U,        0U,        91U,        133U, 
            171U,        242U,        305U,        334U, 
            362U}, 
   {        0U,        0U,        0U,        0U, 
            52U,        0U,        101U,        145U, 
            187U,        264U,        330U,        361U, 
            390U}};
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 const   expected_tpt_siso40MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            77U,        0U,        127U,        160U, 
            184U,        220U,        242U,        250U, 
            257U}, 
   {        0U,        0U,        0U,        0U, 
            83U,        0U,        135U,        169U, 
            193U,        229U,        250U,        257U, 
            264U}, 
   {        0U,        0U,        0U,        0U, 
            94U,        0U,        177U,        249U, 
            313U,        423U,        512U,        550U, 
            586U}, 
   {        0U,        0U,        0U,        0U, 
            104U,        0U,        193U,        270U, 
            338U,        454U,        545U,        584U, 
            620U}};
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 const   expected_tpt_mimo2_20MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            74U,        0U,        123U,        155U, 
            179U,        214U,        236U,        244U, 
            251U}, 
   {        0U,        0U,        0U,        0U, 
            81U,        0U,        131U,        164U, 
            188U,        223U,        243U,        251U, 
            257U}, 
   {        0U,        0U,        0U,        0U, 
            89U,        0U,        167U,        235U, 
            296U,        402U,        488U,        526U, 
            560U}, 
   {        0U,        0U,        0U,        0U, 
            97U,        0U,        182U,        255U, 
            320U,        431U,        520U,        558U, 
            593U}};
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 const   expected_tpt_mimo2_40MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            123U,        0U,        182U,        214U, 
            235U,        264U,        279U,        285U, 
            289U}, 
   {        0U,        0U,        0U,        0U, 
            131U,        0U,        191U,        222U, 
            242U,        270U,        284U,        289U, 
            293U}, 
   {        0U,        0U,        0U,        0U, 
            171U,        0U,        305U,        410U, 
            496U,        634U,        731U,        771U, 
            805U}, 
   {        0U,        0U,        0U,        0U, 
            186U,        0U,        329U,        439U, 
            527U,        667U,        764U,        803U, 
            838U}};
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 const   expected_tpt_mimo3_20MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            99U,        0U,        153U,        186U, 
            208U,        239U,        256U,        263U, 
            268U}, 
   {        0U,        0U,        0U,        0U, 
            106U,        0U,        162U,        194U, 
            215U,        246U,        262U,        268U, 
            273U}, 
   {        0U,        0U,        0U,        0U, 
            134U,        0U,        249U,        346U, 
            431U,        574U,        685U,        732U, 
            775U}, 
   {        0U,        0U,        0U,        0U, 
            148U,        0U,        272U,        376U, 
            465U,        614U,        727U,        775U, 
            818U}};
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 const   expected_tpt_mimo3_40MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            152U,        0U,        211U,        239U, 
            255U,        279U,        290U,        294U, 
            297U}, 
   {        0U,        0U,        0U,        0U, 
            160U,        0U,        219U,        245U, 
            261U,        284U,        294U,        297U, 
            300U}, 
   {        0U,        0U,        0U,        0U, 
            254U,        0U,        443U,        584U, 
            695U,        868U,        984U,        1030U, 
            1070U}, 
   {        0U,        0U,        0U,        0U, 
            277U,        0U,        478U,        624U, 
            737U,        911U,        1026U,        1070U, 
            1109U}};
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static struct iwl_rate_mcs_info  const  iwl_rate_mcs[13U]  = 
#line 226
  {      {{'1', '\000'}, {'B', 'P', 'S', 'K', ' ', 'D', 'S', 'S', 'S', '\000'}}, 
        {{'2', '\000'}, {'Q', 'P', 'S', 'K', ' ', 'D', 'S', 'S', 'S', '\000'}}, 
        {{'5', '.', '5', '\000'}, {'B', 'P', 'S', 'K', ' ', 'C', 'C', 'K', '\000'}}, 
        {{'1', '1', '\000'}, {'Q', 'P', 'S', 'K', ' ', 'C', 'C', 'K', '\000'}}, 
        {{'6', '\000'}, {'B', 'P', 'S', 'K', ' ', '1', '/', '2', '\000'}}, 
        {{'9', '\000'}, {'B', 'P', 'S', 'K', ' ', '1', '/', '2', '\000'}}, 
        {{'1', '2', '\000'}, {'Q', 'P', 'S', 'K', ' ', '1', '/', '2', '\000'}}, 
        {{'1', '8', '\000'}, {'Q', 'P', 'S', 'K', ' ', '3', '/', '4', '\000'}}, 
        {{'2', '4', '\000'}, {'1', '6', 'Q', 'A', 'M', ' ', '1', '/', '2', '\000'}}, 
        {{'3', '6', '\000'}, {'1', '6', 'Q', 'A', 'M', ' ', '3', '/', '4', '\000'}}, 
        {{'4', '8', '\000'}, {'6', '4', 'Q', 'A', 'M', ' ', '2', '/', '3', '\000'}}, 
        {{'5', '4', '\000'}, {'6', '4', 'Q', 'A', 'M', ' ', '3', '/', '4', '\000'}}, 
        {{'6', '0', '\000'}, {'6', '4', 'Q', 'A', 'M', ' ', '5', '/', '6', '\000'}}};
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_rate_scale_clear_window(struct iwl_rate_scale_data *window ) 
{ 


  {
#line 246
  window->data = 0ULL;
#line 247
  window->success_counter = 0;
#line 248
  window->success_ratio = -1;
#line 249
  window->counter = 0;
#line 250
  window->average_tpt = -1;
#line 251
  window->stamp = 0UL;
#line 252
  return;
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
__inline static u8 rs_is_valid_ant(u8 valid_antenna , u8 ant_type ) 
{ 


  {
#line 256
  return (((int )ant_type & (int )valid_antenna) == (int )ant_type);
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_tl_rm_old_stats(struct iwl_traffic_load *tl , u32 curr_time ) 
{ 
  u32 oldest_time ;

  {
#line 266
  oldest_time = curr_time - 950U;
#line 268
  goto ldv_52916;
  ldv_52915: 
#line 270
  tl->total = tl->total - tl->packet_count[(int )tl->head];
#line 271
  tl->packet_count[(int )tl->head] = 0U;
#line 272
  tl->time_stamp = tl->time_stamp + 50UL;
#line 273
  tl->queue_count = (u8 )((int )tl->queue_count - 1);
#line 274
  tl->head = (u8 )((int )tl->head + 1);
#line 275
  if ((unsigned int )tl->head > 19U) {
#line 276
    tl->head = 0U;
  } else {

  }
  ldv_52916: ;
#line 268
  if ((unsigned int )tl->queue_count != 0U && tl->time_stamp < (unsigned long )oldest_time) {
#line 271
    goto ldv_52915;
  } else {

  }

#line 276
  return;
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u8 rs_tl_add_packet(struct iwl_lq_sta *lq_data , struct ieee80211_hdr *hdr ) 
{ 
  u32 curr_time ;
  unsigned int tmp ;
  u32 time_diff ;
  s32 index ;
  struct iwl_traffic_load *tl ;
  u8 tid ;
  u8 *qc ;
  u8 *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 287
  tmp = jiffies_to_msecs(jiffies);
#line 287
  curr_time = tmp;
#line 290
  tl = (struct iwl_traffic_load *)0;
#line 293
  tmp___1 = ieee80211_is_data_qos((int )hdr->frame_control);
#line 293
  if (tmp___1 != 0) {
#line 294
    tmp___0 = ieee80211_get_qos_ctl(hdr);
#line 294
    qc = tmp___0;
#line 295
    tid = (unsigned int )*qc & 15U;
  } else {
#line 297
    return (8U);
  }
#line 299
  tmp___2 = ldv__builtin_expect((unsigned int )tid > 7U, 0L);
#line 299
  if (tmp___2 != 0L) {
#line 300
    return (8U);
  } else {

  }
#line 302
  tl = (struct iwl_traffic_load *)(& lq_data->load) + (unsigned long )tid;
#line 304
  curr_time = curr_time - curr_time % 5U;
#line 307
  if ((unsigned int )tl->queue_count == 0U) {
#line 308
    tl->total = 1U;
#line 309
    tl->time_stamp = (unsigned long )curr_time;
#line 310
    tl->queue_count = 1U;
#line 311
    tl->head = 0U;
#line 312
    tl->packet_count[0] = 1U;
#line 313
    return (8U);
  } else {

  }
#line 316
  time_diff = curr_time - (u32 )tl->time_stamp;
#line 317
  index = (s32 )(time_diff / 50U);
#line 321
  if (index > 19) {
#line 322
    rs_tl_rm_old_stats(tl, curr_time);
  } else {

  }
#line 324
  index = ((s32 )tl->head + index) % 20;
#line 325
  tl->packet_count[index] = tl->packet_count[index] + 1U;
#line 326
  tl->total = tl->total + 1U;
#line 328
  if (index + 1 > (int )tl->queue_count) {
#line 329
    tl->queue_count = (unsigned int )((u8 )index) + 1U;
  } else {

  }
#line 331
  return (tid);
}
}
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_program_fix_rate(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ) 
{ 
  struct iwl_station_priv *sta_priv ;
  struct iwl_lq_sta  const  *__mptr ;
  struct iwl_rxon_context *ctx ;

  {
#line 345
  __mptr = (struct iwl_lq_sta  const  *)lq_sta;
#line 345
  sta_priv = (struct iwl_station_priv *)__mptr + 0xfffffffffffffff8UL;
#line 346
  ctx = sta_priv->ctx;
#line 348
  lq_sta->active_legacy_rate = 4095U;
#line 349
  lq_sta->active_siso_rate = 8144U;
#line 350
  lq_sta->active_mimo2_rate = 8144U;
#line 351
  lq_sta->active_mimo3_rate = 8144U;
#line 353
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_program_fix_rate", "sta_id %d rate 0x%X\n",
            (int )lq_sta->lq.sta_id, lq_sta->dbg_fixed_rate);
#line 356
  if (lq_sta->dbg_fixed_rate != 0U) {
#line 357
    rs_fill_link_cmd((struct iwl_priv *)0, lq_sta, lq_sta->dbg_fixed_rate);
#line 358
    iwl_send_lq_cmd(lq_sta->drv, ctx, & lq_sta->lq, 1, 0);
  } else {

  }
#line 360
  return;
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u32 rs_tl_get_load(struct iwl_lq_sta *lq_data , u8 tid ) 
{ 
  u32 curr_time ;
  unsigned int tmp ;
  u32 time_diff ;
  s32 index ;
  struct iwl_traffic_load *tl ;

  {
#line 369
  tmp = jiffies_to_msecs(jiffies);
#line 369
  curr_time = tmp;
#line 372
  tl = (struct iwl_traffic_load *)0;
#line 374
  if ((unsigned int )tid > 7U) {
#line 375
    return (0U);
  } else {

  }
#line 377
  tl = (struct iwl_traffic_load *)(& lq_data->load) + (unsigned long )tid;
#line 379
  curr_time = curr_time - curr_time % 5U;
#line 381
  if ((unsigned int )tl->queue_count == 0U) {
#line 382
    return (0U);
  } else {

  }
#line 384
  time_diff = curr_time - (u32 )tl->time_stamp;
#line 385
  index = (s32 )(time_diff / 50U);
#line 389
  if (index > 19) {
#line 390
    rs_tl_rm_old_stats(tl, curr_time);
  } else {

  }
#line 392
  return (tl->total);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_tl_turn_on_agg_for_tid(struct iwl_priv *priv , struct iwl_lq_sta *lq_data ,
                                     u8 tid , struct ieee80211_sta *sta ) 
{ 
  int ret ;
  u32 load ;

  {
#line 399
  ret = -11;
#line 406
  if ((unsigned int )priv->bt_traffic_load > 1U) {
#line 407
    __iwl_dbg(priv->dev, 32768U, 0, "rs_tl_turn_on_agg_for_tid", "BT traffic (%d), no aggregation allowed\n",
              (int )priv->bt_traffic_load);
#line 410
    return (ret);
  } else {

  }
#line 413
  load = rs_tl_get_load(lq_data, (int )tid);
#line 415
  __iwl_dbg(priv->dev, 67108864U, 0, "rs_tl_turn_on_agg_for_tid", "Starting Tx agg: STA: %pM tid: %d\n",
            (u8 *)(& sta->addr), (int )tid);
#line 417
  ret = ieee80211_start_tx_ba_session(sta, (int )tid, 5000);
#line 418
  if (ret == -11) {
#line 424
    __iwl_err(priv->dev, 0, 0, "Fail start Tx agg on tid: %d\n", (int )tid);
#line 426
    ieee80211_stop_tx_ba_session(sta, (int )tid);
  } else {

  }
#line 428
  return (ret);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_tl_turn_on_agg(struct iwl_priv *priv , u8 tid , struct iwl_lq_sta *lq_data ,
                              struct ieee80211_sta *sta ) 
{ 


  {
#line 435
  if ((unsigned int )tid <= 7U) {
#line 436
    rs_tl_turn_on_agg_for_tid(priv, lq_data, (int )tid, sta);
  } else {
#line 438
    __iwl_err(priv->dev, 0, 0, "tid exceeds max TID count: %d/%d\n", (int )tid, 8);
  }
#line 439
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
__inline static int get_num_of_ant_from_rate(u32 rate_n_flags ) 
{ 


  {
#line 444
  return ((((rate_n_flags & 16384U) != 0U) + ((rate_n_flags & 32768U) != 0U)) + ((rate_n_flags & 65536U) != 0U));
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static s32 get_expected_tpt(struct iwl_scale_tbl_info *tbl , int rs_index ) 
{ 


  {
#line 455
  if ((unsigned long )tbl->expected_tpt != (unsigned long )((u16 const   *)0U)) {
#line 456
    return ((s32 )*(tbl->expected_tpt + (unsigned long )rs_index));
  } else {

  }
#line 457
  return (0);
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_collect_tx_data(struct iwl_scale_tbl_info *tbl , int scale_index , int attempts ,
                              int successes ) 
{ 
  struct iwl_rate_scale_data *window ;
  u64 mask ;
  s32 fail_count ;
  s32 tpt ;

  {
#line 470
  window = (struct iwl_rate_scale_data *)0;
#line 471
  mask = 2305843009213693952ULL;
#line 474
  if (scale_index < 0 || scale_index > 12) {
#line 475
    return (-22);
  } else {

  }
#line 478
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )scale_index;
#line 481
  tpt = get_expected_tpt(tbl, scale_index);
#line 491
  goto ldv_52978;
  ldv_52977: ;
#line 492
  if (window->counter > 61) {
#line 495
    window->counter = 61;
#line 497
    if ((window->data & mask) != 0ULL) {
#line 498
      window->data = window->data & ~ mask;
#line 499
      window->success_counter = window->success_counter - 1;
    } else {

    }
  } else {

  }
#line 504
  window->counter = window->counter + 1;
#line 507
  window->data = window->data << 1;
#line 510
  if (successes > 0) {
#line 511
    window->success_counter = window->success_counter + 1;
#line 512
    window->data = window->data | 1ULL;
#line 513
    successes = successes - 1;
  } else {

  }
#line 516
  attempts = attempts - 1;
  ldv_52978: ;
#line 491
  if (attempts > 0) {
#line 493
    goto ldv_52977;
  } else {

  }

#line 520
  if (window->counter > 0) {
#line 521
    window->success_ratio = (window->success_counter * 12800) / window->counter;
  } else {
#line 524
    window->success_ratio = -1;
  }
#line 526
  fail_count = window->counter - window->success_counter;
#line 529
  if (fail_count > 5 || window->success_counter > 7) {
#line 531
    window->average_tpt = (window->success_ratio * tpt + 64) / 128;
  } else {
#line 533
    window->average_tpt = -1;
  }
#line 536
  window->stamp = jiffies;
#line 538
  return (0);
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u32 rate_n_flags_from_tbl(struct iwl_priv *priv , struct iwl_scale_tbl_info *tbl ,
                                 int index , u8 use_green ) 
{ 
  u32 rate_n_flags ;

  {
#line 549
  rate_n_flags = 0U;
#line 551
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
#line 552
    rate_n_flags = (u32 )iwl_rates[index].plcp;
#line 553
    if (index >= 0 && index <= 3) {
#line 554
      rate_n_flags = rate_n_flags | 512U;
    } else {

    }
  } else
#line 556
  if ((unsigned int )tbl->lq_type == 3U || ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
#line 557
    if (index > 12) {
#line 558
      __iwl_err(priv->dev, 0, 0, "Invalid HT rate index %d\n", index);
#line 559
      index = 12;
    } else {

    }
#line 561
    rate_n_flags = 256U;
#line 563
    if ((unsigned int )tbl->lq_type == 3U) {
#line 564
      rate_n_flags = (u32 )iwl_rates[index].plcp_siso | rate_n_flags;
    } else
#line 565
    if ((unsigned int )tbl->lq_type == 4U) {
#line 566
      rate_n_flags = (u32 )iwl_rates[index].plcp_mimo2 | rate_n_flags;
    } else {
#line 568
      rate_n_flags = (u32 )iwl_rates[index].plcp_mimo3 | rate_n_flags;
    }
  } else {
#line 570
    __iwl_err(priv->dev, 0, 0, "Invalid tbl->lq_type %d\n", (unsigned int )tbl->lq_type);
  }
#line 573
  rate_n_flags = ((u32 )((int )tbl->ant_type << 14) & 114688U) | rate_n_flags;
#line 576
  if ((unsigned int )tbl->lq_type == 3U || ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
#line 577
    if ((unsigned int )tbl->is_ht40 != 0U) {
#line 578
      if ((unsigned int )tbl->is_dup != 0U) {
#line 579
        rate_n_flags = rate_n_flags | 4096U;
      } else {
#line 581
        rate_n_flags = rate_n_flags | 2048U;
      }
    } else {

    }
#line 583
    if ((unsigned int )tbl->is_SGI != 0U) {
#line 584
      rate_n_flags = rate_n_flags | 8192U;
    } else {

    }
#line 586
    if ((unsigned int )use_green != 0U) {
#line 587
      rate_n_flags = rate_n_flags | 1024U;
#line 588
      if ((unsigned int )tbl->lq_type == 3U && (unsigned int )tbl->is_SGI != 0U) {
#line 589
        rate_n_flags = rate_n_flags & 4294959103U;
#line 590
        __iwl_err(priv->dev, 0, 0, "GF was set with SGI:SISO\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 594
  return (rate_n_flags);
}
}
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_get_tbl_info_from_mcs(u32 const   rate_n_flags , enum ieee80211_band band ,
                                    struct iwl_scale_tbl_info *tbl , int *rate_idx ) 
{ 
  u32 ant_msk ;
  u8 num_of_ant___0 ;
  int tmp ;
  u8 mcs ;

  {
#line 606
  ant_msk = (unsigned int )rate_n_flags & 114688U;
#line 607
  tmp = get_num_of_ant_from_rate(rate_n_flags);
#line 607
  num_of_ant___0 = (u8 )tmp;
#line 610
  memset((void *)tbl, 0, 448UL);
#line 611
  *rate_idx = iwl_hwrate_to_plcp_idx(rate_n_flags);
#line 613
  if (*rate_idx == 13) {
#line 614
    *rate_idx = -1;
#line 615
    return (-22);
  } else {

  }
#line 617
  tbl->is_SGI = 0U;
#line 618
  tbl->is_ht40 = 0U;
#line 619
  tbl->is_dup = 0U;
#line 620
  tbl->ant_type = (u8 )(ant_msk >> 14);
#line 621
  tbl->lq_type = 0;
#line 622
  tbl->max_search = 6U;
#line 625
  if (((unsigned int )rate_n_flags & 256U) == 0U) {
#line 626
    if ((unsigned int )num_of_ant___0 == 1U) {
#line 627
      if ((unsigned int )band == 1U) {
#line 628
        tbl->lq_type = 2;
      } else {
#line 630
        tbl->lq_type = 1;
      }
    } else {

    }
  } else {
#line 634
    if (((unsigned int )rate_n_flags & 8192U) != 0U) {
#line 635
      tbl->is_SGI = 1U;
    } else {

    }
#line 637
    if (((unsigned int )rate_n_flags & 2048U) != 0U || ((unsigned int )rate_n_flags & 4096U) != 0U) {
#line 639
      tbl->is_ht40 = 1U;
    } else {

    }
#line 641
    if (((unsigned int )rate_n_flags & 4096U) != 0U) {
#line 642
      tbl->is_dup = 1U;
    } else {

    }
#line 644
    mcs = rs_extract_rate(rate_n_flags);
#line 647
    if ((unsigned int )mcs <= 7U) {
#line 648
      if ((unsigned int )num_of_ant___0 == 1U) {
#line 649
        tbl->lq_type = 3;
      } else {

      }
    } else
#line 651
    if ((unsigned int )mcs <= 15U) {
#line 652
      if ((unsigned int )num_of_ant___0 == 2U) {
#line 653
        tbl->lq_type = 4;
      } else {

      }
    } else
#line 656
    if ((unsigned int )num_of_ant___0 == 3U) {
#line 657
      tbl->max_search = 8U;
#line 658
      tbl->lq_type = 5;
    } else {

    }
  }
#line 662
  return (0);
}
}
#line 667 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_toggle_antenna(u32 valid_ant , u32 *rate_n_flags , struct iwl_scale_tbl_info *tbl ) 
{ 
  u8 new_ant_type ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 672
  if ((unsigned int )tbl->ant_type == 0U || (unsigned int )tbl->ant_type > 7U) {
#line 673
    return (0);
  } else {

  }
#line 675
  tmp = rs_is_valid_ant((int )((u8 )valid_ant), (int )tbl->ant_type);
#line 675
  if ((unsigned int )tmp == 0U) {
#line 676
    return (0);
  } else {

  }
#line 678
  new_ant_type = ant_toggle_lookup[(int )tbl->ant_type];
#line 680
  goto ldv_53003;
  ldv_53002: 
#line 682
  new_ant_type = ant_toggle_lookup[(int )new_ant_type];
  ldv_53003: ;
#line 680
  if ((int )tbl->ant_type != (int )new_ant_type) {
#line 680
    tmp___0 = rs_is_valid_ant((int )((u8 )valid_ant), (int )new_ant_type);
#line 680
    if ((unsigned int )tmp___0 == 0U) {
#line 683
      goto ldv_53002;
    } else {
#line 686
      goto ldv_53004;
    }
  } else {

  }
  ldv_53004: ;
#line 684
  if ((int )tbl->ant_type == (int )new_ant_type) {
#line 685
    return (0);
  } else {

  }
#line 687
  tbl->ant_type = new_ant_type;
#line 688
  *rate_n_flags = *rate_n_flags & 4294852607U;
#line 689
  *rate_n_flags = *rate_n_flags | (u32 )((int )new_ant_type << 14);
#line 690
  return (1);
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static bool rs_use_green(struct ieee80211_sta *sta ) 
{ 


  {
#line 706
  return (0);
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 rs_get_supported_rates(struct iwl_lq_sta *lq_sta , struct ieee80211_hdr *hdr ,
                                  enum iwl_table_type rate_type ) 
{ 


  {
#line 720
  if ((unsigned int )rate_type == 1U || (unsigned int )rate_type == 2U) {
#line 721
    return (lq_sta->active_legacy_rate);
  } else
#line 723
  if ((unsigned int )rate_type == 3U) {
#line 724
    return (lq_sta->active_siso_rate);
  } else
#line 725
  if ((unsigned int )rate_type == 4U) {
#line 726
    return (lq_sta->active_mimo2_rate);
  } else {
#line 728
    return (lq_sta->active_mimo3_rate);
  }
}
}
#line 732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u16 rs_get_adjacent_rate(struct iwl_priv *priv , u8 index , u16 rate_mask ,
                                int rate_type ) 
{ 
  u8 high ;
  u8 low ;
  int i ;
  u32 mask ;

  {
#line 735
  high = 13U;
#line 736
  low = 13U;
#line 740
  if (rate_type == 2 || (rate_type != 1 && rate_type != 2)) {
#line 745
    i = (int )index + -1;
#line 746
    mask = (u32 )(1 << i);
#line 746
    goto ldv_53025;
    ldv_53024: ;
#line 747
    if (((u32 )rate_mask & mask) != 0U) {
#line 748
      low = (u8 )i;
#line 749
      goto ldv_53023;
    } else {

    }
#line 746
    i = i - 1;
#line 746
    mask = mask >> 1;
    ldv_53025: ;
#line 746
    if (i >= 0) {
#line 748
      goto ldv_53024;
    } else {

    }
    ldv_53023: 
#line 754
    i = (int )index + 1;
#line 755
    mask = (u32 )(1 << i);
#line 755
    goto ldv_53028;
    ldv_53027: ;
#line 756
    if (((u32 )rate_mask & mask) != 0U) {
#line 757
      high = (u8 )i;
#line 758
      goto ldv_53026;
    } else {

    }
#line 755
    i = i + 1;
#line 755
    mask = mask << 1;
    ldv_53028: ;
#line 755
    if (i <= 12) {
#line 757
      goto ldv_53027;
    } else {

    }
    ldv_53026: ;
#line 762
    return ((u16 )((int )((short )((int )high << 8)) | (int )((short )low)));
  } else {

  }
#line 765
  low = index;
#line 766
  goto ldv_53032;
  ldv_53031: 
#line 767
  low = iwl_rates[(int )low].prev_rs;
#line 768
  if ((unsigned int )low == 13U) {
#line 769
    goto ldv_53029;
  } else {

  }
#line 770
  if (((int )rate_mask >> (int )low) & 1) {
#line 771
    goto ldv_53029;
  } else {

  }
#line 772
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_get_adjacent_rate", "Skipping masked lower rate: %d\n",
            (int )low);
  ldv_53032: ;
#line 766
  if ((unsigned int )low != 13U) {
#line 768
    goto ldv_53031;
  } else {

  }
  ldv_53029: 
#line 775
  high = index;
#line 776
  goto ldv_53035;
  ldv_53034: 
#line 777
  high = iwl_rates[(int )high].next_rs;
#line 778
  if ((unsigned int )high == 13U) {
#line 779
    goto ldv_53033;
  } else {

  }
#line 780
  if (((int )rate_mask >> (int )high) & 1) {
#line 781
    goto ldv_53033;
  } else {

  }
#line 782
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_get_adjacent_rate", "Skipping masked higher rate: %d\n",
            (int )high);
  ldv_53035: ;
#line 776
  if ((unsigned int )high != 13U) {
#line 778
    goto ldv_53034;
  } else {

  }
  ldv_53033: ;
#line 785
  return ((u16 )((int )((short )((int )high << 8)) | (int )((short )low)));
}
}
#line 788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static u32 rs_get_lower_rate(struct iwl_lq_sta *lq_sta , struct iwl_scale_tbl_info *tbl ,
                             u8 scale_index , u8 ht_possible ) 
{ 
  s32 low ;
  u16 rate_mask ;
  u16 high_low ;
  u8 switch_to_legacy ;
  u8 is_green ;
  struct iwl_priv *priv ;
  u8 tmp ;
  u32 tmp___0 ;

  {
#line 795
  switch_to_legacy = 0U;
#line 796
  is_green = lq_sta->is_green;
#line 797
  priv = lq_sta->drv;
#line 802
  if (((unsigned int )tbl->lq_type != 1U && (unsigned int )tbl->lq_type != 2U) && ((unsigned int )ht_possible == 0U || (unsigned int )scale_index == 0U)) {
#line 803
    switch_to_legacy = 1U;
#line 804
    scale_index = rs_ht_to_legacy[(int )scale_index];
#line 805
    if ((unsigned int )lq_sta->band == 1U) {
#line 806
      tbl->lq_type = 2;
    } else {
#line 808
      tbl->lq_type = 1;
    }
#line 810
    tmp = num_of_ant((int )tbl->ant_type);
#line 810
    if ((unsigned int )tmp > 1U) {
#line 811
      tbl->ant_type = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
    } else {

    }
#line 814
    tbl->is_ht40 = 0U;
#line 815
    tbl->is_SGI = 0U;
#line 816
    tbl->max_search = 6U;
  } else {

  }
#line 819
  rate_mask = rs_get_supported_rates(lq_sta, (struct ieee80211_hdr *)0, tbl->lq_type);
#line 822
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
#line 824
    if ((unsigned int )lq_sta->band == 1U) {
#line 825
      rate_mask = ((int )((unsigned short )lq_sta->supp_rates) << 4U) & (int )rate_mask;
    } else {
#line 828
      rate_mask = (int )((unsigned short )lq_sta->supp_rates) & (int )rate_mask;
    }
  } else {

  }
#line 832
  if ((unsigned int )switch_to_legacy != 0U && ((int )rate_mask >> (int )scale_index) & 1) {
#line 833
    low = (s32 )scale_index;
#line 834
    goto out;
  } else {

  }
#line 837
  high_low = rs_get_adjacent_rate(lq_sta->drv, (int )scale_index, (int )rate_mask,
                                  (int )tbl->lq_type);
#line 839
  low = (int )high_low & 255;
#line 841
  if (low == 13) {
#line 842
    low = (s32 )scale_index;
  } else {

  }
  out: 
#line 845
  tmp___0 = rate_n_flags_from_tbl(lq_sta->drv, tbl, low, (int )is_green);
#line 845
  return (tmp___0);
}
}
#line 851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static bool table_type_matches(struct iwl_scale_tbl_info *a , struct iwl_scale_tbl_info *b ) 
{ 


  {
#line 854
  return ((bool )(((unsigned int )a->lq_type == (unsigned int )b->lq_type && (int )a->ant_type == (int )b->ant_type) && (int )a->is_SGI == (int )b->is_SGI));
}
}
#line 858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_bt_update_lq(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct iwl_lq_sta *lq_sta ) 
{ 
  struct iwl_scale_tbl_info *tbl ;
  bool full_concurrent ;

  {
#line 862
  full_concurrent = priv->bt_full_concurrent;
#line 864
  if ((int )priv->bt_ant_couple_ok) {
#line 869
    if ((unsigned int )priv->bt_ci_compliance != 0U && (int )priv->bt_ant_couple_ok) {
#line 870
      full_concurrent = 1;
    } else {
#line 872
      full_concurrent = 0;
    }
  } else {

  }
#line 874
  if ((int )priv->bt_traffic_load != (int )priv->last_bt_traffic_load || (int )priv->bt_full_concurrent != (int )full_concurrent) {
#line 876
    priv->bt_full_concurrent = full_concurrent;
#line 877
    priv->last_bt_traffic_load = priv->bt_traffic_load;
#line 880
    tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 881
    rs_fill_link_cmd(priv, lq_sta, tbl->current_rate);
#line 882
    iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 1, 0);
#line 884
    queue_work___0(priv->workqueue, & priv->bt_full_concurrency);
  } else {

  }
#line 886
  return;
}
}
#line 891 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_tx_status(void *priv_r , struct ieee80211_supported_band *sband , struct ieee80211_sta *sta ,
                         void *priv_sta , struct sk_buff *skb ) 
{ 
  int legacy_success ;
  int retries ;
  int rs_index ;
  int mac_index ;
  int i ;
  struct iwl_lq_sta *lq_sta ;
  struct iwl_link_quality_cmd *table ;
  struct ieee80211_hdr *hdr ;
  struct iwl_op_mode *op_mode ;
  struct iwl_priv *priv ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp ;
  enum mac80211_rate_control_flags mac_flags ;
  u32 tx_rate ;
  struct iwl_scale_tbl_info tbl_type ;
  struct iwl_scale_tbl_info *curr_tbl ;
  struct iwl_scale_tbl_info *other_tbl ;
  struct iwl_scale_tbl_info *tmp_tbl ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int _min1 ;
  int _min2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
#line 898
  lq_sta = (struct iwl_lq_sta *)priv_sta;
#line 900
  hdr = (struct ieee80211_hdr *)skb->data;
#line 901
  op_mode = (struct iwl_op_mode *)priv_r;
#line 902
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 903
  tmp = IEEE80211_SKB_CB(skb);
#line 903
  info = tmp;
#line 908
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 909
  ctx = sta_priv->ctx;
#line 911
  __iwl_dbg(priv->dev, 1048576U, 1, "rs_tx_status", "get frame ack response, update rate scale window\n");
#line 914
  if ((unsigned long )lq_sta == (unsigned long )((struct iwl_lq_sta *)0)) {
#line 915
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "Station rate scaling not created yet.\n");
#line 916
    return;
  } else
#line 917
  if ((unsigned long )lq_sta->drv == (unsigned long )((struct iwl_priv *)0)) {
#line 918
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "Rate scaling not initialized yet.\n");
#line 919
    return;
  } else {

  }
#line 922
  tmp___0 = ieee80211_is_data((int )hdr->frame_control);
#line 922
  if (tmp___0 == 0 || (info->flags & 4U) != 0U) {
#line 924
    return;
  } else {

  }
#line 927
  if ((info->flags & 64U) != 0U && (info->flags & 1024U) == 0U) {
#line 929
    return;
  } else {

  }
#line 939
  table = & lq_sta->lq;
#line 940
  tx_rate = table->rs_table[0].rate_n_flags;
#line 941
  rs_get_tbl_info_from_mcs(tx_rate, priv->band, & tbl_type, & rs_index);
#line 942
  if ((unsigned int )priv->band == 1U) {
#line 943
    rs_index = rs_index + -4;
  } else {

  }
#line 944
  mac_flags = (enum mac80211_rate_control_flags )info->__annonCompField99.status.rates[0].flags;
#line 945
  mac_index = (int )info->__annonCompField99.status.rates[0].idx;
#line 947
  if (((unsigned int )mac_flags & 8U) != 0U) {
#line 948
    mac_index = mac_index & 7;
#line 949
    if (mac_index > 0) {
#line 950
      mac_index = mac_index + 1;
    } else {

    }
#line 955
    if ((unsigned int )priv->band == 0U) {
#line 956
      mac_index = mac_index + 4;
    } else {

    }
  } else {

  }
#line 959
  if (((((((mac_index < 0 || (int )tbl_type.is_SGI != (((unsigned int )mac_flags & 128U) != 0U)) || (int )tbl_type.is_ht40 != (((unsigned int )mac_flags & 32U) != 0U)) || (int )tbl_type.is_dup != (((unsigned int )mac_flags & 64U) != 0U)) || (int )tbl_type.ant_type != (int )info->__annonCompField99.status.antenna) || ((tx_rate & 256U) != 0U) ^ (((unsigned int )mac_flags & 8U) != 0U)) || ((tx_rate & 1024U) != 0U) ^ (((unsigned int )mac_flags & 16U) != 0U)) || rs_index != mac_index) {
#line 967
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "initial rate %d does not match %d (0x%x)\n",
              mac_index, rs_index, tx_rate);
#line 973
    lq_sta->missed_rate_counter = (u8 )((int )lq_sta->missed_rate_counter + 1);
#line 974
    if ((unsigned int )lq_sta->missed_rate_counter > 15U) {
#line 975
      lq_sta->missed_rate_counter = 0U;
#line 976
      iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 1, 0);
    } else {

    }
#line 979
    return;
  } else {
#line 982
    lq_sta->missed_rate_counter = 0U;
  }
#line 985
  tmp___2 = table_type_matches(& tbl_type, (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl);
#line 985
  if ((int )tmp___2) {
#line 987
    curr_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 988
    other_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
  } else {
#line 989
    tmp___1 = table_type_matches(& tbl_type, (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl));
#line 989
    if ((int )tmp___1) {
#line 991
      curr_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
#line 992
      other_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
    } else {
#line 994
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "Neither active nor search matches tx rate\n");
#line 995
      tmp_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 996
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "active- lq:%x, ant:%x, SGI:%d\n",
                (unsigned int )tmp_tbl->lq_type, (int )tmp_tbl->ant_type, (int )tmp_tbl->is_SGI);
#line 998
      tmp_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
#line 999
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "search- lq:%x, ant:%x, SGI:%d\n",
                (unsigned int )tmp_tbl->lq_type, (int )tmp_tbl->ant_type, (int )tmp_tbl->is_SGI);
#line 1001
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "actual- lq:%x, ant:%x, SGI:%d\n",
                (unsigned int )tbl_type.lq_type, (int )tbl_type.ant_type, (int )tbl_type.is_SGI);
#line 1007
      rs_stay_in_table(lq_sta, 1);
#line 1008
      goto done;
    }
  }
#line 1018
  if ((info->flags & 1024U) != 0U) {
#line 1019
    tx_rate = table->rs_table[0].rate_n_flags;
#line 1020
    rs_get_tbl_info_from_mcs(tx_rate, priv->band, & tbl_type, & rs_index);
#line 1022
    rs_collect_tx_data(curr_tbl, rs_index, (int )info->__annonCompField99.status.ampdu_len,
                       (int )info->__annonCompField99.status.ampdu_ack_len);
#line 1027
    if ((unsigned int )lq_sta->stay_in_tbl != 0U) {
#line 1028
      lq_sta->total_success = lq_sta->total_success + (u32 )info->__annonCompField99.status.ampdu_ack_len;
#line 1029
      lq_sta->total_failed = lq_sta->total_failed + (u32 )((int )info->__annonCompField99.status.ampdu_len - (int )info->__annonCompField99.status.ampdu_ack_len);
    } else {

    }
  } else {
#line 1036
    retries = (int )info->__annonCompField99.status.rates[0].count + -1;
#line 1038
    _min1 = retries;
#line 1038
    _min2 = 15;
#line 1038
    retries = _min1 < _min2 ? _min1 : _min2;
#line 1041
    legacy_success = (info->flags & 512U) != 0U;
#line 1043
    i = 0;
#line 1043
    goto ldv_53093;
    ldv_53092: 
#line 1044
    tx_rate = table->rs_table[i].rate_n_flags;
#line 1045
    rs_get_tbl_info_from_mcs(tx_rate, priv->band, & tbl_type, & rs_index);
#line 1051
    tmp___4 = table_type_matches(& tbl_type, curr_tbl);
#line 1051
    if ((int )tmp___4) {
#line 1052
      tmp_tbl = curr_tbl;
    } else {
#line 1053
      tmp___3 = table_type_matches(& tbl_type, other_tbl);
#line 1053
      if ((int )tmp___3) {
#line 1054
        tmp_tbl = other_tbl;
      } else {
#line 1056
        goto ldv_53091;
      }
    }
#line 1057
    rs_collect_tx_data(tmp_tbl, rs_index, 1, i >= retries ? legacy_success : 0);
    ldv_53091: 
#line 1043
    i = i + 1;
    ldv_53093: ;
#line 1043
    if (i <= retries) {
#line 1045
      goto ldv_53092;
    } else {

    }

#line 1062
    if ((unsigned int )lq_sta->stay_in_tbl != 0U) {
#line 1063
      lq_sta->total_success = lq_sta->total_success + (u32 )legacy_success;
#line 1064
      lq_sta->total_failed = lq_sta->total_failed + (u32 )((1 - legacy_success) + retries);
    } else {

    }
  }
#line 1068
  lq_sta->last_rate_n_flags = tx_rate;
  done: ;
#line 1071
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0) && sta->supp_rates[(unsigned int )sband->band] != 0U) {
#line 1072
    rs_rate_scale_perform(priv, skb, sta, lq_sta);
  } else {

  }
#line 1074
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 1075
    rs_bt_update_lq(priv, ctx, lq_sta);
  } else {

  }
#line 1076
  return;
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_set_stay_in_table(struct iwl_priv *priv , u8 is_legacy , struct iwl_lq_sta *lq_sta ) 
{ 


  {
#line 1089
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_set_stay_in_table", "we are staying in the same table\n");
#line 1090
  lq_sta->stay_in_tbl = 1U;
#line 1091
  if ((unsigned int )is_legacy != 0U) {
#line 1092
    lq_sta->table_count_limit = 160U;
#line 1093
    lq_sta->max_failure_limit = 160U;
#line 1094
    lq_sta->max_success_limit = 480U;
  } else {
#line 1096
    lq_sta->table_count_limit = 1500U;
#line 1097
    lq_sta->max_failure_limit = 400U;
#line 1098
    lq_sta->max_success_limit = 4500U;
  }
#line 1100
  lq_sta->table_count = 0U;
#line 1101
  lq_sta->total_failed = 0U;
#line 1102
  lq_sta->total_success = 0U;
#line 1103
  lq_sta->flush_timer = (u64 )jiffies;
#line 1104
  lq_sta->action_counter = 0U;
#line 1105
  return;
}
}
#line 1110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_set_expected_tpt_table(struct iwl_lq_sta *lq_sta , struct iwl_scale_tbl_info *tbl ) 
{ 
  u16 const   (*ht_tbl_pointer)[13U] ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1117
  __ret_warn_once = ((unsigned int )tbl->lq_type != 1U && (unsigned int )tbl->lq_type != 2U) && ((unsigned int )tbl->lq_type != 3U && ((unsigned int )tbl->lq_type != 4U && (unsigned int )tbl->lq_type != 5U));
#line 1117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1117
  if (tmp___1 != 0L) {
#line 1117
    __ret_warn_on = ! __warned;
#line 1117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1117
    if (tmp != 0L) {
#line 1117
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c",
                         1117);
    } else {

    }
#line 1117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1117
    if (tmp___0 != 0L) {
#line 1117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 1117
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1117
  if (tmp___2 != 0L) {
#line 1118
    tbl->expected_tpt = (u16 const   *)(& expected_tpt_legacy);
#line 1119
    return;
  } else {

  }
#line 1123
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
#line 1124
    tbl->expected_tpt = (u16 const   *)(& expected_tpt_legacy);
#line 1125
    return;
  } else {

  }
#line 1131
  if ((unsigned int )tbl->lq_type == 3U && ((unsigned int )tbl->is_ht40 == 0U || (unsigned int )lq_sta->is_dup != 0U)) {
#line 1132
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_siso20MHz);
  } else
#line 1133
  if ((unsigned int )tbl->lq_type == 3U) {
#line 1134
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_siso40MHz);
  } else
#line 1135
  if ((unsigned int )tbl->lq_type == 4U && ((unsigned int )tbl->is_ht40 == 0U || (unsigned int )lq_sta->is_dup != 0U)) {
#line 1136
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_mimo2_20MHz);
  } else
#line 1137
  if ((unsigned int )tbl->lq_type == 4U) {
#line 1138
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_mimo2_40MHz);
  } else
#line 1139
  if ((unsigned int )tbl->lq_type == 5U && ((unsigned int )tbl->is_ht40 == 0U || (unsigned int )lq_sta->is_dup != 0U)) {
#line 1140
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_mimo3_20MHz);
  } else {
#line 1142
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_mimo3_40MHz);
  }
#line 1144
  if ((unsigned int )tbl->is_SGI == 0U && (unsigned int )lq_sta->is_agg == 0U) {
#line 1145
    tbl->expected_tpt = (u16 const   *)ht_tbl_pointer;
  } else
#line 1146
  if ((unsigned int )tbl->is_SGI != 0U && (unsigned int )lq_sta->is_agg == 0U) {
#line 1147
    tbl->expected_tpt = (u16 const   *)ht_tbl_pointer + 1U;
  } else
#line 1148
  if ((unsigned int )tbl->is_SGI == 0U && (unsigned int )lq_sta->is_agg != 0U) {
#line 1149
    tbl->expected_tpt = (u16 const   *)ht_tbl_pointer + 2U;
  } else {
#line 1151
    tbl->expected_tpt = (u16 const   *)ht_tbl_pointer + 3U;
  }
#line 1152
  return;
}
}
#line 1166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static s32 rs_get_best_rate(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta , struct iwl_scale_tbl_info *tbl ,
                            u16 rate_mask , s8 index ) 
{ 
  struct iwl_scale_tbl_info *active_tbl ;
  s32 active_sr ;
  s32 active_tpt ;
  u16 const   *tpt_tbl ;
  s32 new_rate ;
  s32 high ;
  s32 low ;
  s32 start_hi ;
  u16 high_low ;
  s8 rate ;

  {
#line 1172
  active_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 1174
  active_sr = active_tbl->win[(int )index].success_ratio;
#line 1175
  active_tpt = (s32 )*(active_tbl->expected_tpt + (unsigned long )index);
#line 1177
  tpt_tbl = tbl->expected_tpt;
#line 1181
  rate = index;
#line 1183
  start_hi = 13;
#line 1183
  low = start_hi;
#line 1183
  high = low;
#line 1183
  new_rate = high;
  ldv_53129: 
#line 1186
  high_low = rs_get_adjacent_rate(priv, (int )((u8 )rate), (int )rate_mask, (int )tbl->lq_type);
#line 1189
  low = (int )high_low & 255;
#line 1190
  high = ((int )high_low >> 8) & 255;
#line 1207
  if (((int )*(tpt_tbl + (unsigned long )rate) * 100 > lq_sta->last_tpt && ((active_sr > 1920 && active_sr <= 10880) && (s32 )*(tpt_tbl + (unsigned long )rate) <= active_tpt)) || (active_sr > 10879 && (s32 )*(tpt_tbl + (unsigned long )rate) > active_tpt)) {
#line 1217
    if (start_hi != 13) {
#line 1218
      new_rate = start_hi;
#line 1219
      goto ldv_53128;
    } else {

    }
#line 1222
    new_rate = (s32 )rate;
#line 1225
    if (low != 13) {
#line 1226
      rate = (s8 )low;
    } else {
#line 1230
      goto ldv_53128;
    }
  } else
#line 1237
  if (new_rate != 13) {
#line 1238
    goto ldv_53128;
  } else
#line 1241
  if (high != 13) {
#line 1242
    start_hi = high;
#line 1243
    rate = (s8 )high;
  } else {
#line 1247
    new_rate = (s32 )rate;
#line 1248
    goto ldv_53128;
  }
#line 1251
  goto ldv_53129;
  ldv_53128: ;
#line 1253
  return (new_rate);
}
}
#line 1259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_switch_to_mimo2(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                              struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                              struct iwl_scale_tbl_info *tbl , int index ) 
{ 
  u16 rate_mask ;
  s32 rate ;
  s8 is_green ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 1267
  is_green = (s8 )lq_sta->is_green;
#line 1268
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 1269
  ctx = sta_priv->ctx;
#line 1271
  tmp = conf_is_ht(conf);
#line 1271
  if (tmp) {
#line 1271
    tmp___0 = 0;
  } else {
#line 1271
    tmp___0 = 1;
  }
#line 1271
  if (tmp___0 || ! sta->ht_cap.ht_supported) {
#line 1272
    return (-1);
  } else {

  }
#line 1274
  if ((unsigned int )sta->smps_mode == 2U) {
#line 1275
    return (-1);
  } else {

  }
#line 1278
  if ((unsigned int )priv->hw_params.tx_chains_num <= 1U) {
#line 1279
    return (-1);
  } else {

  }
#line 1281
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo2", "LQ: try to switch to MIMO2\n");
#line 1283
  tbl->lq_type = 4;
#line 1284
  tbl->is_dup = lq_sta->is_dup;
#line 1285
  tbl->action = 0U;
#line 1286
  tbl->max_search = 6U;
#line 1287
  rate_mask = lq_sta->active_mimo2_rate;
#line 1289
  tmp___1 = iwl_is_ht40_tx_allowed(priv, ctx, sta);
#line 1289
  if ((int )tmp___1) {
#line 1290
    tbl->is_ht40 = 1U;
  } else {
#line 1292
    tbl->is_ht40 = 0U;
  }
#line 1294
  rs_set_expected_tpt_table(lq_sta, tbl);
#line 1296
  rate = rs_get_best_rate(priv, lq_sta, tbl, (int )rate_mask, (int )((s8 )index));
#line 1298
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo2", "LQ: MIMO2 best rate %d mask %X\n",
            rate, (int )rate_mask);
#line 1299
  if (rate == 13 || (((int )rate_mask >> rate) & 1) == 0) {
#line 1300
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo2", "Can\'t switch with index %d rate mask %x\n",
              rate, (int )rate_mask);
#line 1302
    return (-1);
  } else {

  }
#line 1304
  tbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, (int )((u8 )is_green));
#line 1306
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo2", "LQ: Switch to new mcs %X index is green %X\n",
            tbl->current_rate, (int )is_green);
#line 1308
  return (0);
}
}
#line 1314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_switch_to_mimo3(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                              struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                              struct iwl_scale_tbl_info *tbl , int index ) 
{ 
  u16 rate_mask ;
  s32 rate ;
  s8 is_green ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 1322
  is_green = (s8 )lq_sta->is_green;
#line 1323
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 1324
  ctx = sta_priv->ctx;
#line 1326
  tmp = conf_is_ht(conf);
#line 1326
  if (tmp) {
#line 1326
    tmp___0 = 0;
  } else {
#line 1326
    tmp___0 = 1;
  }
#line 1326
  if (tmp___0 || ! sta->ht_cap.ht_supported) {
#line 1327
    return (-1);
  } else {

  }
#line 1329
  if ((unsigned int )sta->smps_mode == 2U) {
#line 1330
    return (-1);
  } else {

  }
#line 1333
  if ((unsigned int )priv->hw_params.tx_chains_num <= 2U) {
#line 1334
    return (-1);
  } else {

  }
#line 1336
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo3", "LQ: try to switch to MIMO3\n");
#line 1338
  tbl->lq_type = 5;
#line 1339
  tbl->is_dup = lq_sta->is_dup;
#line 1340
  tbl->action = 0U;
#line 1341
  tbl->max_search = 8U;
#line 1342
  rate_mask = lq_sta->active_mimo3_rate;
#line 1344
  tmp___1 = iwl_is_ht40_tx_allowed(priv, ctx, sta);
#line 1344
  if ((int )tmp___1) {
#line 1345
    tbl->is_ht40 = 1U;
  } else {
#line 1347
    tbl->is_ht40 = 0U;
  }
#line 1349
  rs_set_expected_tpt_table(lq_sta, tbl);
#line 1351
  rate = rs_get_best_rate(priv, lq_sta, tbl, (int )rate_mask, (int )((s8 )index));
#line 1353
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo3", "LQ: MIMO3 best rate %d mask %X\n",
            rate, (int )rate_mask);
#line 1355
  if (rate == 13 || (((int )rate_mask >> rate) & 1) == 0) {
#line 1356
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo3", "Can\'t switch with index %d rate mask %x\n",
              rate, (int )rate_mask);
#line 1358
    return (-1);
  } else {

  }
#line 1360
  tbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, (int )((u8 )is_green));
#line 1362
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo3", "LQ: Switch to new mcs %X index is green %X\n",
            tbl->current_rate, (int )is_green);
#line 1364
  return (0);
}
}
#line 1370 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_switch_to_siso(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta , struct ieee80211_conf *conf ,
                             struct ieee80211_sta *sta , struct iwl_scale_tbl_info *tbl ,
                             int index ) 
{ 
  u16 rate_mask ;
  u8 is_green ;
  s32 rate ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 1377
  is_green = lq_sta->is_green;
#line 1379
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 1380
  ctx = sta_priv->ctx;
#line 1382
  tmp = conf_is_ht(conf);
#line 1382
  if (tmp) {
#line 1382
    tmp___0 = 0;
  } else {
#line 1382
    tmp___0 = 1;
  }
#line 1382
  if (tmp___0 || ! sta->ht_cap.ht_supported) {
#line 1383
    return (-1);
  } else {

  }
#line 1385
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_siso", "LQ: try to switch to SISO\n");
#line 1387
  tbl->is_dup = lq_sta->is_dup;
#line 1388
  tbl->lq_type = 3;
#line 1389
  tbl->action = 0U;
#line 1390
  tbl->max_search = 6U;
#line 1391
  rate_mask = lq_sta->active_siso_rate;
#line 1393
  tmp___1 = iwl_is_ht40_tx_allowed(priv, ctx, sta);
#line 1393
  if ((int )tmp___1) {
#line 1394
    tbl->is_ht40 = 1U;
  } else {
#line 1396
    tbl->is_ht40 = 0U;
  }
#line 1398
  if ((unsigned int )is_green != 0U) {
#line 1399
    tbl->is_SGI = 0U;
  } else {

  }
#line 1401
  rs_set_expected_tpt_table(lq_sta, tbl);
#line 1402
  rate = rs_get_best_rate(priv, lq_sta, tbl, (int )rate_mask, (int )((s8 )index));
#line 1404
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_siso", "LQ: get best rate %d mask %X\n",
            rate, (int )rate_mask);
#line 1405
  if (rate == 13 || (((int )rate_mask >> rate) & 1) == 0) {
#line 1406
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_siso", "can not switch with index %d rate mask %x\n",
              rate, (int )rate_mask);
#line 1408
    return (-1);
  } else {

  }
#line 1410
  tbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, (int )is_green);
#line 1411
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_siso", "LQ: Switch to new mcs %X index is green %X\n",
            tbl->current_rate, (int )is_green);
#line 1413
  return (0);
}
}
#line 1419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_move_legacy_other(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                                struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                                int index ) 
{ 
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *search_tbl ;
  struct iwl_rate_scale_data *window ;
  u32 sz ;
  u8 start_action ;
  u8 valid_tx_ant ;
  u8 tx_chains_num ;
  int ret ;
  u8 update_search_tbl_counter ;
  enum iwl_antenna_ok tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;

  {
#line 1425
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 1426
  search_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
#line 1428
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
#line 1429
  sz = 32U;
#line 1432
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
#line 1433
  tx_chains_num = priv->hw_params.tx_chains_num;
#line 1434
  ret = 0;
#line 1435
  update_search_tbl_counter = 0U;
#line 1437
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
#line 1440
  goto ldv_53189;
  case 1: ;
#line 1443
  if ((unsigned int )tbl->action == 1U) {
#line 1444
    tbl->action = 2U;
  } else {

  }
#line 1445
  goto ldv_53189;
  case 2: ;
  case 3: 
#line 1449
  valid_tx_ant = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 1451
  if ((unsigned int )tbl->action != 0U && (unsigned int )tbl->action != 2U) {
#line 1453
    tbl->action = 2U;
  } else {

  }
#line 1454
  goto ldv_53189;
  default: 
#line 1456
  __iwl_err(priv->dev, 0, 0, "Invalid BT load %d\n", (int )priv->bt_traffic_load);
#line 1457
  goto ldv_53189;
  }
  ldv_53189: 
#line 1460
  tmp___0 = iwl_ht_enabled(priv);
#line 1460
  if (tmp___0) {
#line 1460
    tmp___1 = 0;
  } else {
#line 1460
    tmp___1 = 1;
  }
#line 1460
  if (tmp___1) {
#line 1462
    tbl->action = 0U;
  } else {
#line 1463
    tmp = iwl_tx_ant_restriction(priv);
#line 1463
    if ((unsigned int )tmp == 1U && (unsigned int )tbl->action > 2U) {
#line 1465
      tbl->action = 2U;
    } else {

    }
  }
#line 1468
  if ((int )priv->bt_full_concurrent) {
#line 1469
    tmp___2 = iwl_ht_enabled(priv);
#line 1469
    if (tmp___2) {
#line 1469
      tmp___3 = 0;
    } else {
#line 1469
      tmp___3 = 1;
    }
#line 1469
    if (tmp___3) {
#line 1470
      tbl->action = 0U;
    } else
#line 1471
    if ((unsigned int )tbl->action != 0U) {
#line 1472
      tbl->action = 2U;
    } else {

    }
#line 1473
    valid_tx_ant = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  } else {

  }
#line 1477
  start_action = tbl->action;
  ldv_53205: 
#line 1479
  lq_sta->action_counter = (u8 )((int )lq_sta->action_counter + 1);
#line 1480
  switch ((int )tbl->action) {
  case 0: ;
  case 1: 
#line 1483
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_legacy_other", "LQ: Legacy toggle Antenna\n");
#line 1485
  if (((unsigned int )tbl->action == 0U && (unsigned int )tx_chains_num <= 1U) || ((unsigned int )tbl->action == 1U && (unsigned int )tx_chains_num <= 2U)) {
#line 1489
    goto ldv_53197;
  } else {

  }
#line 1492
  if ((window->success_ratio > 12799 && ! priv->bt_full_concurrent) && (unsigned int )priv->bt_traffic_load == 0U) {
#line 1496
    goto ldv_53197;
  } else {

  }
#line 1499
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1501
  tmp___4 = rs_toggle_antenna((u32 )valid_tx_ant, & search_tbl->current_rate, search_tbl);
#line 1501
  if (tmp___4 != 0) {
#line 1503
    update_search_tbl_counter = 1U;
#line 1504
    rs_set_expected_tpt_table(lq_sta, search_tbl);
#line 1505
    goto out;
  } else {

  }
#line 1507
  goto ldv_53197;
  case 2: 
#line 1509
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_legacy_other", "LQ: Legacy switch to SISO\n");
#line 1512
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1513
  search_tbl->is_SGI = 0U;
#line 1514
  ret = rs_switch_to_siso(priv, lq_sta, conf, sta, search_tbl, index);
#line 1516
  if (ret == 0) {
#line 1517
    lq_sta->action_counter = 0U;
#line 1518
    goto out;
  } else {

  }
#line 1521
  goto ldv_53197;
  case 3: ;
  case 4: ;
  case 5: 
#line 1525
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_legacy_other", "LQ: Legacy switch to MIMO2\n");
#line 1528
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1529
  search_tbl->is_SGI = 0U;
#line 1531
  if ((unsigned int )tbl->action == 3U) {
#line 1532
    search_tbl->ant_type = 3U;
  } else
#line 1533
  if ((unsigned int )tbl->action == 4U) {
#line 1534
    search_tbl->ant_type = 5U;
  } else {
#line 1536
    search_tbl->ant_type = 6U;
  }
#line 1538
  tmp___5 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
#line 1538
  if ((unsigned int )tmp___5 == 0U) {
#line 1539
    goto ldv_53197;
  } else {

  }
#line 1541
  ret = rs_switch_to_mimo2(priv, lq_sta, conf, sta, search_tbl, index);
#line 1543
  if (ret == 0) {
#line 1544
    lq_sta->action_counter = 0U;
#line 1545
    goto out;
  } else {

  }
#line 1547
  goto ldv_53197;
  case 6: 
#line 1550
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_legacy_other", "LQ: Legacy switch to MIMO3\n");
#line 1553
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1554
  search_tbl->is_SGI = 0U;
#line 1556
  search_tbl->ant_type = 7U;
#line 1558
  tmp___6 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
#line 1558
  if ((unsigned int )tmp___6 == 0U) {
#line 1559
    goto ldv_53197;
  } else {

  }
#line 1561
  ret = rs_switch_to_mimo3(priv, lq_sta, conf, sta, search_tbl, index);
#line 1563
  if (ret == 0) {
#line 1564
    lq_sta->action_counter = 0U;
#line 1565
    goto out;
  } else {

  }
#line 1567
  goto ldv_53197;
  }
  ldv_53197: 
#line 1569
  tbl->action = (u8 )((int )tbl->action + 1);
#line 1570
  if ((unsigned int )tbl->action > 6U) {
#line 1571
    tbl->action = 0U;
  } else {

  }
#line 1573
  if ((int )tbl->action == (int )start_action) {
#line 1574
    goto ldv_53204;
  } else {

  }
#line 1576
  goto ldv_53205;
  ldv_53204: 
#line 1577
  search_tbl->lq_type = 0;
#line 1578
  return (0);
  out: 
#line 1581
  lq_sta->search_better_tbl = 1U;
#line 1582
  tbl->action = (u8 )((int )tbl->action + 1);
#line 1583
  if ((unsigned int )tbl->action > 6U) {
#line 1584
    tbl->action = 0U;
  } else {

  }
#line 1585
  if ((unsigned int )update_search_tbl_counter != 0U) {
#line 1586
    search_tbl->action = tbl->action;
  } else {

  }
#line 1587
  return (0);
}
}
#line 1594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_move_siso_to_other(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                                 struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                                 int index ) 
{ 
  u8 is_green ;
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *search_tbl ;
  struct iwl_rate_scale_data *window ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  u32 sz ;
  u8 start_action ;
  u8 valid_tx_ant ;
  u8 tx_chains_num ;
  u8 update_search_tbl_counter ;
  int ret ;
  enum iwl_antenna_ok tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  s32 tpt ;
  u8 tmp___2 ;

  {
#line 1599
  is_green = lq_sta->is_green;
#line 1600
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 1601
  search_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
#line 1603
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
#line 1604
  ht_cap = & sta->ht_cap;
#line 1605
  sz = 32U;
#line 1608
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
#line 1609
  tx_chains_num = priv->hw_params.tx_chains_num;
#line 1610
  update_search_tbl_counter = 0U;
#line 1613
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
#line 1616
  goto ldv_53225;
  case 1: ;
#line 1619
  if ((unsigned int )tbl->action == 1U) {
#line 1620
    tbl->action = 2U;
  } else {

  }
#line 1621
  goto ldv_53225;
  case 2: ;
  case 3: 
#line 1625
  valid_tx_ant = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 1627
  if ((unsigned int )tbl->action != 0U) {
#line 1628
    tbl->action = 0U;
  } else {

  }
#line 1629
  goto ldv_53225;
  default: 
#line 1631
  __iwl_err(priv->dev, 0, 0, "Invalid BT load %d\n", (int )priv->bt_traffic_load);
#line 1632
  goto ldv_53225;
  }
  ldv_53225: 
#line 1635
  tmp = iwl_tx_ant_restriction(priv);
#line 1635
  if ((unsigned int )tmp == 1U && (unsigned int )tbl->action > 1U) {
#line 1638
    tbl->action = 0U;
  } else {

  }
#line 1642
  if ((int )priv->bt_full_concurrent) {
#line 1643
    valid_tx_ant = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 1645
    if ((unsigned int )tbl->action != 0U) {
#line 1646
      tbl->action = 0U;
    } else {

    }
  } else {

  }
#line 1649
  start_action = tbl->action;
  ldv_53242: 
#line 1651
  lq_sta->action_counter = (u8 )((int )lq_sta->action_counter + 1);
#line 1652
  switch ((int )tbl->action) {
  case 0: ;
  case 1: 
#line 1655
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_siso_to_other", "LQ: SISO toggle Antenna\n");
#line 1656
  if (((unsigned int )tbl->action == 0U && (unsigned int )tx_chains_num <= 1U) || ((unsigned int )tbl->action == 1U && (unsigned int )tx_chains_num <= 2U)) {
#line 1660
    goto ldv_53233;
  } else {

  }
#line 1662
  if ((window->success_ratio > 12799 && ! priv->bt_full_concurrent) && (unsigned int )priv->bt_traffic_load == 0U) {
#line 1666
    goto ldv_53233;
  } else {

  }
#line 1668
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1669
  tmp___0 = rs_toggle_antenna((u32 )valid_tx_ant, & search_tbl->current_rate, search_tbl);
#line 1669
  if (tmp___0 != 0) {
#line 1671
    update_search_tbl_counter = 1U;
#line 1672
    goto out;
  } else {

  }
#line 1674
  goto ldv_53233;
  case 2: ;
  case 3: ;
  case 4: 
#line 1678
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_siso_to_other", "LQ: SISO switch to MIMO2\n");
#line 1679
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1680
  search_tbl->is_SGI = 0U;
#line 1682
  if ((unsigned int )tbl->action == 2U) {
#line 1683
    search_tbl->ant_type = 3U;
  } else
#line 1684
  if ((unsigned int )tbl->action == 3U) {
#line 1685
    search_tbl->ant_type = 5U;
  } else {
#line 1687
    search_tbl->ant_type = 6U;
  }
#line 1689
  tmp___1 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
#line 1689
  if ((unsigned int )tmp___1 == 0U) {
#line 1690
    goto ldv_53233;
  } else {

  }
#line 1692
  ret = rs_switch_to_mimo2(priv, lq_sta, conf, sta, search_tbl, index);
#line 1694
  if (ret == 0) {
#line 1695
    goto out;
  } else {

  }
#line 1696
  goto ldv_53233;
  case 5: ;
#line 1698
  if ((unsigned int )tbl->is_ht40 == 0U && ((int )ht_cap->cap & 32) == 0) {
#line 1700
    goto ldv_53233;
  } else {

  }
#line 1701
  if ((unsigned int )tbl->is_ht40 != 0U && ((int )ht_cap->cap & 64) == 0) {
#line 1703
    goto ldv_53233;
  } else {

  }
#line 1705
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_siso_to_other", "LQ: SISO toggle SGI/NGI\n");
#line 1707
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1708
  if ((unsigned int )is_green != 0U) {
#line 1709
    if ((unsigned int )tbl->is_SGI == 0U) {
#line 1710
      goto ldv_53233;
    } else {
#line 1712
      __iwl_err(priv->dev, 0, 0, "SGI was set in GF+SISO\n");
    }
  } else {

  }
#line 1715
  search_tbl->is_SGI = (unsigned int )tbl->is_SGI == 0U;
#line 1716
  rs_set_expected_tpt_table(lq_sta, search_tbl);
#line 1717
  if ((unsigned int )tbl->is_SGI != 0U) {
#line 1718
    tpt = lq_sta->last_tpt / 100;
#line 1719
    if ((int )*(search_tbl->expected_tpt + (unsigned long )index) <= tpt) {
#line 1720
      goto ldv_53233;
    } else {

    }
  } else {

  }
#line 1722
  search_tbl->current_rate = rate_n_flags_from_tbl(priv, search_tbl, index, (int )is_green);
#line 1725
  update_search_tbl_counter = 1U;
#line 1726
  goto out;
  case 6: 
#line 1728
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_siso_to_other", "LQ: SISO switch to MIMO3\n");
#line 1729
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1730
  search_tbl->is_SGI = 0U;
#line 1731
  search_tbl->ant_type = 7U;
#line 1733
  tmp___2 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
#line 1733
  if ((unsigned int )tmp___2 == 0U) {
#line 1734
    goto ldv_53233;
  } else {

  }
#line 1736
  ret = rs_switch_to_mimo3(priv, lq_sta, conf, sta, search_tbl, index);
#line 1738
  if (ret == 0) {
#line 1739
    goto out;
  } else {

  }
#line 1740
  goto ldv_53233;
  }
  ldv_53233: 
#line 1742
  tbl->action = (u8 )((int )tbl->action + 1);
#line 1743
  if ((unsigned int )tbl->action > 6U) {
#line 1744
    tbl->action = 0U;
  } else {

  }
#line 1746
  if ((int )tbl->action == (int )start_action) {
#line 1747
    goto ldv_53241;
  } else {

  }
#line 1748
  goto ldv_53242;
  ldv_53241: 
#line 1749
  search_tbl->lq_type = 0;
#line 1750
  return (0);
  out: 
#line 1753
  lq_sta->search_better_tbl = 1U;
#line 1754
  tbl->action = (u8 )((int )tbl->action + 1);
#line 1755
  if ((unsigned int )tbl->action > 6U) {
#line 1756
    tbl->action = 0U;
  } else {

  }
#line 1757
  if ((unsigned int )update_search_tbl_counter != 0U) {
#line 1758
    search_tbl->action = tbl->action;
  } else {

  }
#line 1760
  return (0);
}
}
#line 1766 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_move_mimo2_to_other(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                                  struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                                  int index ) 
{ 
  s8 is_green ;
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *search_tbl ;
  struct iwl_rate_scale_data *window ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  u32 sz ;
  u8 start_action ;
  u8 valid_tx_ant ;
  u8 tx_chains_num ;
  u8 update_search_tbl_counter ;
  int ret ;
  enum iwl_antenna_ok tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  s32 tpt ;
  u8 tmp___2 ;

  {
#line 1771
  is_green = (s8 )lq_sta->is_green;
#line 1772
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 1773
  search_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
#line 1775
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
#line 1776
  ht_cap = & sta->ht_cap;
#line 1777
  sz = 32U;
#line 1780
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
#line 1781
  tx_chains_num = priv->hw_params.tx_chains_num;
#line 1782
  update_search_tbl_counter = 0U;
#line 1785
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
#line 1788
  goto ldv_53262;
  case 2: ;
  case 3: ;
#line 1792
  if ((unsigned int )tbl->action != 2U) {
#line 1793
    tbl->action = 2U;
  } else {

  }
#line 1794
  goto ldv_53262;
  case 1: ;
#line 1797
  if ((unsigned int )tbl->action == 3U || (unsigned int )tbl->action == 4U) {
#line 1799
    tbl->action = 2U;
  } else {

  }
#line 1800
  goto ldv_53262;
  default: 
#line 1802
  __iwl_err(priv->dev, 0, 0, "Invalid BT load %d\n", (int )priv->bt_traffic_load);
#line 1803
  goto ldv_53262;
  }
  ldv_53262: 
#line 1806
  tmp = iwl_tx_ant_restriction(priv);
#line 1806
  if ((unsigned int )tmp == 1U && ((unsigned int )tbl->action <= 1U || (unsigned int )tbl->action > 4U)) {
#line 1810
    tbl->action = 2U;
  } else {

  }
#line 1814
  if ((int )priv->bt_full_concurrent && ((unsigned int )tbl->action <= 1U || (unsigned int )tbl->action > 4U)) {
#line 1817
    tbl->action = 2U;
  } else {

  }
#line 1819
  start_action = tbl->action;
  ldv_53279: 
#line 1821
  lq_sta->action_counter = (u8 )((int )lq_sta->action_counter + 1);
#line 1822
  switch ((int )tbl->action) {
  case 0: ;
  case 1: 
#line 1825
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo2_to_other", "LQ: MIMO2 toggle Antennas\n");
#line 1827
  if ((unsigned int )tx_chains_num <= 2U) {
#line 1828
    goto ldv_53270;
  } else {

  }
#line 1830
  if (window->success_ratio > 12799) {
#line 1831
    goto ldv_53270;
  } else {

  }
#line 1833
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1834
  tmp___0 = rs_toggle_antenna((u32 )valid_tx_ant, & search_tbl->current_rate, search_tbl);
#line 1834
  if (tmp___0 != 0) {
#line 1836
    update_search_tbl_counter = 1U;
#line 1837
    goto out;
  } else {

  }
#line 1839
  goto ldv_53270;
  case 2: ;
  case 3: ;
  case 4: 
#line 1843
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo2_to_other", "LQ: MIMO2 switch to SISO\n");
#line 1846
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1848
  if ((unsigned int )tbl->action == 2U) {
#line 1849
    search_tbl->ant_type = 1U;
  } else
#line 1850
  if ((unsigned int )tbl->action == 3U) {
#line 1851
    search_tbl->ant_type = 2U;
  } else {
#line 1853
    search_tbl->ant_type = 4U;
  }
#line 1855
  tmp___1 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
#line 1855
  if ((unsigned int )tmp___1 == 0U) {
#line 1856
    goto ldv_53270;
  } else {

  }
#line 1858
  ret = rs_switch_to_siso(priv, lq_sta, conf, sta, search_tbl, index);
#line 1860
  if (ret == 0) {
#line 1861
    goto out;
  } else {

  }
#line 1863
  goto ldv_53270;
  case 5: ;
#line 1866
  if ((unsigned int )tbl->is_ht40 == 0U && ((int )ht_cap->cap & 32) == 0) {
#line 1868
    goto ldv_53270;
  } else {

  }
#line 1869
  if ((unsigned int )tbl->is_ht40 != 0U && ((int )ht_cap->cap & 64) == 0) {
#line 1871
    goto ldv_53270;
  } else {

  }
#line 1873
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo2_to_other", "LQ: MIMO2 toggle SGI/NGI\n");
#line 1876
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1877
  search_tbl->is_SGI = (unsigned int )tbl->is_SGI == 0U;
#line 1878
  rs_set_expected_tpt_table(lq_sta, search_tbl);
#line 1885
  if ((unsigned int )tbl->is_SGI != 0U) {
#line 1886
    tpt = lq_sta->last_tpt / 100;
#line 1887
    if ((int )*(search_tbl->expected_tpt + (unsigned long )index) <= tpt) {
#line 1888
      goto ldv_53270;
    } else {

    }
  } else {

  }
#line 1890
  search_tbl->current_rate = rate_n_flags_from_tbl(priv, search_tbl, index, (int )((u8 )is_green));
#line 1893
  update_search_tbl_counter = 1U;
#line 1894
  goto out;
  case 6: 
#line 1897
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo2_to_other", "LQ: MIMO2 switch to MIMO3\n");
#line 1898
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 1899
  search_tbl->is_SGI = 0U;
#line 1900
  search_tbl->ant_type = 7U;
#line 1902
  tmp___2 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
#line 1902
  if ((unsigned int )tmp___2 == 0U) {
#line 1903
    goto ldv_53270;
  } else {

  }
#line 1905
  ret = rs_switch_to_mimo3(priv, lq_sta, conf, sta, search_tbl, index);
#line 1907
  if (ret == 0) {
#line 1908
    goto out;
  } else {

  }
#line 1910
  goto ldv_53270;
  }
  ldv_53270: 
#line 1912
  tbl->action = (u8 )((int )tbl->action + 1);
#line 1913
  if ((unsigned int )tbl->action > 6U) {
#line 1914
    tbl->action = 0U;
  } else {

  }
#line 1916
  if ((int )tbl->action == (int )start_action) {
#line 1917
    goto ldv_53278;
  } else {

  }
#line 1918
  goto ldv_53279;
  ldv_53278: 
#line 1919
  search_tbl->lq_type = 0;
#line 1920
  return (0);
  out: 
#line 1922
  lq_sta->search_better_tbl = 1U;
#line 1923
  tbl->action = (u8 )((int )tbl->action + 1);
#line 1924
  if ((unsigned int )tbl->action > 6U) {
#line 1925
    tbl->action = 0U;
  } else {

  }
#line 1926
  if ((unsigned int )update_search_tbl_counter != 0U) {
#line 1927
    search_tbl->action = tbl->action;
  } else {

  }
#line 1929
  return (0);
}
}
#line 1936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static int rs_move_mimo3_to_other(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                                  struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                                  int index ) 
{ 
  s8 is_green ;
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *search_tbl ;
  struct iwl_rate_scale_data *window ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  u32 sz ;
  u8 start_action ;
  u8 valid_tx_ant ;
  u8 tx_chains_num ;
  int ret ;
  u8 update_search_tbl_counter ;
  enum iwl_antenna_ok tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  s32 tpt ;

  {
#line 1941
  is_green = (s8 )lq_sta->is_green;
#line 1942
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 1943
  search_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
#line 1945
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
#line 1946
  ht_cap = & sta->ht_cap;
#line 1947
  sz = 32U;
#line 1950
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
#line 1951
  tx_chains_num = priv->hw_params.tx_chains_num;
#line 1953
  update_search_tbl_counter = 0U;
#line 1955
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
#line 1958
  goto ldv_53299;
  case 2: ;
  case 3: ;
#line 1962
  if ((unsigned int )tbl->action != 2U) {
#line 1963
    tbl->action = 2U;
  } else {

  }
#line 1964
  goto ldv_53299;
  case 1: ;
#line 1967
  if ((unsigned int )tbl->action == 3U || (unsigned int )tbl->action == 4U) {
#line 1969
    tbl->action = 2U;
  } else {

  }
#line 1970
  goto ldv_53299;
  default: 
#line 1972
  __iwl_err(priv->dev, 0, 0, "Invalid BT load %d\n", (int )priv->bt_traffic_load);
#line 1973
  goto ldv_53299;
  }
  ldv_53299: 
#line 1976
  tmp = iwl_tx_ant_restriction(priv);
#line 1976
  if ((unsigned int )tmp == 1U && ((unsigned int )tbl->action <= 1U || (unsigned int )tbl->action > 4U)) {
#line 1980
    tbl->action = 2U;
  } else {

  }
#line 1984
  if ((int )priv->bt_full_concurrent && ((unsigned int )tbl->action <= 1U || (unsigned int )tbl->action > 4U)) {
#line 1987
    tbl->action = 2U;
  } else {

  }
#line 1989
  start_action = tbl->action;
  ldv_53318: 
#line 1991
  lq_sta->action_counter = (u8 )((int )lq_sta->action_counter + 1);
#line 1992
  switch ((int )tbl->action) {
  case 0: ;
  case 1: 
#line 1995
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo3_to_other", "LQ: MIMO3 toggle Antennas\n");
#line 1997
  if ((unsigned int )tx_chains_num <= 3U) {
#line 1998
    goto ldv_53307;
  } else {

  }
#line 2000
  if (window->success_ratio > 12799) {
#line 2001
    goto ldv_53307;
  } else {

  }
#line 2003
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 2004
  tmp___0 = rs_toggle_antenna((u32 )valid_tx_ant, & search_tbl->current_rate, search_tbl);
#line 2004
  if (tmp___0 != 0) {
#line 2006
    goto out;
  } else {

  }
#line 2007
  goto ldv_53307;
  case 2: ;
  case 3: ;
  case 4: 
#line 2011
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo3_to_other", "LQ: MIMO3 switch to SISO\n");
#line 2014
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 2016
  if ((unsigned int )tbl->action == 2U) {
#line 2017
    search_tbl->ant_type = 1U;
  } else
#line 2018
  if ((unsigned int )tbl->action == 3U) {
#line 2019
    search_tbl->ant_type = 2U;
  } else {
#line 2021
    search_tbl->ant_type = 4U;
  }
#line 2023
  tmp___1 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
#line 2023
  if ((unsigned int )tmp___1 == 0U) {
#line 2024
    goto ldv_53307;
  } else {

  }
#line 2026
  ret = rs_switch_to_siso(priv, lq_sta, conf, sta, search_tbl, index);
#line 2028
  if (ret == 0) {
#line 2029
    goto out;
  } else {

  }
#line 2031
  goto ldv_53307;
  case 5: ;
  case 6: ;
  case 7: 
#line 2036
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo3_to_other", "LQ: MIMO3 switch to MIMO2\n");
#line 2038
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 2039
  search_tbl->is_SGI = 0U;
#line 2040
  if ((unsigned int )tbl->action == 5U) {
#line 2041
    search_tbl->ant_type = 3U;
  } else
#line 2042
  if ((unsigned int )tbl->action == 6U) {
#line 2043
    search_tbl->ant_type = 5U;
  } else {
#line 2045
    search_tbl->ant_type = 6U;
  }
#line 2047
  tmp___2 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
#line 2047
  if ((unsigned int )tmp___2 == 0U) {
#line 2048
    goto ldv_53307;
  } else {

  }
#line 2050
  ret = rs_switch_to_mimo2(priv, lq_sta, conf, sta, search_tbl, index);
#line 2052
  if (ret == 0) {
#line 2053
    goto out;
  } else {

  }
#line 2055
  goto ldv_53307;
  case 8: ;
#line 2058
  if ((unsigned int )tbl->is_ht40 == 0U && ((int )ht_cap->cap & 32) == 0) {
#line 2060
    goto ldv_53307;
  } else {

  }
#line 2061
  if ((unsigned int )tbl->is_ht40 != 0U && ((int )ht_cap->cap & 64) == 0) {
#line 2063
    goto ldv_53307;
  } else {

  }
#line 2065
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo3_to_other", "LQ: MIMO3 toggle SGI/NGI\n");
#line 2068
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
#line 2069
  search_tbl->is_SGI = (unsigned int )tbl->is_SGI == 0U;
#line 2070
  rs_set_expected_tpt_table(lq_sta, search_tbl);
#line 2077
  if ((unsigned int )tbl->is_SGI != 0U) {
#line 2078
    tpt = lq_sta->last_tpt / 100;
#line 2079
    if ((int )*(search_tbl->expected_tpt + (unsigned long )index) <= tpt) {
#line 2080
      goto ldv_53307;
    } else {

    }
  } else {

  }
#line 2082
  search_tbl->current_rate = rate_n_flags_from_tbl(priv, search_tbl, index, (int )((u8 )is_green));
#line 2085
  update_search_tbl_counter = 1U;
#line 2086
  goto out;
  }
  ldv_53307: 
#line 2088
  tbl->action = (u8 )((int )tbl->action + 1);
#line 2089
  if ((unsigned int )tbl->action > 8U) {
#line 2090
    tbl->action = 0U;
  } else {

  }
#line 2092
  if ((int )tbl->action == (int )start_action) {
#line 2093
    goto ldv_53317;
  } else {

  }
#line 2094
  goto ldv_53318;
  ldv_53317: 
#line 2095
  search_tbl->lq_type = 0;
#line 2096
  return (0);
  out: 
#line 2098
  lq_sta->search_better_tbl = 1U;
#line 2099
  tbl->action = (u8 )((int )tbl->action + 1);
#line 2100
  if ((unsigned int )tbl->action > 8U) {
#line 2101
    tbl->action = 0U;
  } else {

  }
#line 2102
  if ((unsigned int )update_search_tbl_counter != 0U) {
#line 2103
    search_tbl->action = tbl->action;
  } else {

  }
#line 2105
  return (0);
}
}
#line 2116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_stay_in_table(struct iwl_lq_sta *lq_sta , bool force_search ) 
{ 
  struct iwl_scale_tbl_info *tbl ;
  int i ;
  int active_tbl ;
  int flush_interval_passed ;
  struct iwl_priv *priv ;

  {
#line 2121
  flush_interval_passed = 0;
#line 2124
  priv = lq_sta->drv;
#line 2125
  active_tbl = (int )lq_sta->active_tbl;
#line 2127
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )active_tbl;
#line 2130
  if ((unsigned int )lq_sta->stay_in_tbl != 0U) {
#line 2133
    if (lq_sta->flush_timer != 0ULL) {
#line 2135
      flush_interval_passed = (long )(((unsigned long )lq_sta->flush_timer - (unsigned long )jiffies) + 750UL) < 0L;
    } else {

    }
#line 2147
    if ((((int )force_search || lq_sta->total_failed > lq_sta->max_failure_limit) || lq_sta->total_success > lq_sta->max_success_limit) || (((unsigned int )lq_sta->search_better_tbl == 0U && lq_sta->flush_timer != 0ULL) && flush_interval_passed != 0)) {
#line 2152
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_stay_in_table", "LQ: stay is expired %d %d %d\n",
                lq_sta->total_failed, lq_sta->total_success, flush_interval_passed);
#line 2158
      lq_sta->stay_in_tbl = 0U;
#line 2159
      lq_sta->total_failed = 0U;
#line 2160
      lq_sta->total_success = 0U;
#line 2161
      lq_sta->flush_timer = 0ULL;
    } else {
#line 2170
      lq_sta->table_count = lq_sta->table_count + 1U;
#line 2171
      if (lq_sta->table_count >= lq_sta->table_count_limit) {
#line 2173
        lq_sta->table_count = 0U;
#line 2175
        __iwl_dbg(priv->dev, 1048576U, 0, "rs_stay_in_table", "LQ: stay in table clear win\n");
#line 2176
        i = 0;
#line 2176
        goto ldv_53336;
        ldv_53335: 
#line 2177
        rs_rate_scale_clear_window((struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )i);
#line 2176
        i = i + 1;
        ldv_53336: ;
#line 2176
        if (i <= 12) {
#line 2178
          goto ldv_53335;
        } else {

        }

      } else {

      }
    }
#line 2185
    if ((unsigned int )lq_sta->stay_in_tbl == 0U) {
#line 2186
      i = 0;
#line 2186
      goto ldv_53339;
      ldv_53338: 
#line 2187
      rs_rate_scale_clear_window((struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )i);
#line 2186
      i = i + 1;
      ldv_53339: ;
#line 2186
      if (i <= 12) {
#line 2188
        goto ldv_53338;
      } else {

      }

    } else {

    }
  } else {

  }
#line 2195
  return;
}
}
#line 2195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_update_rate_tbl(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                               struct iwl_lq_sta *lq_sta , struct iwl_scale_tbl_info *tbl ,
                               int index , u8 is_green ) 
{ 
  u32 rate ;

  {
#line 2204
  rate = rate_n_flags_from_tbl(priv, tbl, index, (int )is_green);
#line 2205
  rs_fill_link_cmd(priv, lq_sta, rate);
#line 2206
  iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 1, 0);
#line 2207
  return;
}
}
#line 2212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_rate_scale_perform(struct iwl_priv *priv , struct sk_buff *skb , struct ieee80211_sta *sta ,
                                  struct iwl_lq_sta *lq_sta ) 
{ 
  struct ieee80211_hw *hw ;
  struct ieee80211_conf *conf ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp ;
  struct ieee80211_hdr *hdr ;
  int low ;
  int high ;
  int index ;
  int i ;
  struct iwl_rate_scale_data *window ;
  int current_tpt ;
  int low_tpt ;
  int high_tpt ;
  u32 fail_count ;
  s8 scale_action ;
  u16 rate_mask ;
  u8 update_lq ;
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *tbl1 ;
  u16 rate_scale_index_msk ;
  u8 is_green ;
  u8 active_tbl ;
  u8 done_search ;
  u16 high_low ;
  s32 sr ;
  u8 tid ;
  struct iwl_tid_data *tid_data ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  int tmp___0 ;
  bool tmp___1 ;
  enum iwl_antenna_ok tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  enum iwl_antenna_ok tmp___5 ;
  enum iwl_antenna_ok tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  u8 sta_id ;
  bool tmp___9 ;

  {
#line 2217
  hw = priv->hw;
#line 2218
  conf = & hw->conf;
#line 2219
  tmp = IEEE80211_SKB_CB(skb);
#line 2219
  info = tmp;
#line 2220
  hdr = (struct ieee80211_hdr *)skb->data;
#line 2221
  low = 13;
#line 2222
  high = 13;
#line 2225
  window = (struct iwl_rate_scale_data *)0;
#line 2226
  current_tpt = -1;
#line 2227
  low_tpt = -1;
#line 2228
  high_tpt = -1;
#line 2230
  scale_action = 0;
#line 2232
  update_lq = 0U;
#line 2234
  rate_scale_index_msk = 0U;
#line 2235
  is_green = 0U;
#line 2236
  active_tbl = 0U;
#line 2237
  done_search = 0U;
#line 2240
  tid = 8U;
#line 2242
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 2243
  ctx = sta_priv->ctx;
#line 2245
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "rate scale calculate new rate for skb\n");
#line 2249
  tmp___0 = ieee80211_is_data((int )hdr->frame_control);
#line 2249
  if (tmp___0 == 0 || (info->flags & 4U) != 0U) {
#line 2251
    return;
  } else {

  }
#line 2253
  lq_sta->supp_rates = sta->supp_rates[(unsigned int )lq_sta->band];
#line 2255
  tid = rs_tl_add_packet(lq_sta, hdr);
#line 2256
  if ((unsigned int )tid != 8U && ((int )lq_sta->tx_agg_tid_en >> (int )tid) & 1) {
#line 2258
    tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )lq_sta->lq.sta_id + (unsigned long )tid);
#line 2259
    if ((unsigned int )tid_data->agg.state == 0U) {
#line 2260
      lq_sta->is_agg = 0U;
    } else {
#line 2262
      lq_sta->is_agg = 1U;
    }
  } else {
#line 2264
    lq_sta->is_agg = 0U;
  }
#line 2271
  if ((unsigned int )lq_sta->search_better_tbl == 0U) {
#line 2272
    active_tbl = lq_sta->active_tbl;
  } else {
#line 2274
    active_tbl = 1U - (unsigned int )lq_sta->active_tbl;
  }
#line 2276
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )active_tbl;
#line 2277
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
#line 2278
    lq_sta->is_green = 0U;
  } else {
#line 2280
    tmp___1 = rs_use_green(sta);
#line 2280
    lq_sta->is_green = (u8 )tmp___1;
  }
#line 2281
  is_green = lq_sta->is_green;
#line 2284
  index = lq_sta->last_txrate_idx;
#line 2286
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "Rate scale index %d for type %d\n",
            index, (unsigned int )tbl->lq_type);
#line 2290
  rate_mask = rs_get_supported_rates(lq_sta, hdr, tbl->lq_type);
#line 2292
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "mask 0x%04X\n", (int )rate_mask);
#line 2295
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
#line 2296
    if ((unsigned int )lq_sta->band == 1U) {
#line 2298
      rate_scale_index_msk = ((int )((unsigned short )lq_sta->supp_rates) << 4U) & (int )rate_mask;
    } else {
#line 2301
      rate_scale_index_msk = (int )((unsigned short )lq_sta->supp_rates) & (int )rate_mask;
    }
  } else {
#line 2305
    rate_scale_index_msk = rate_mask;
  }
#line 2307
  if ((unsigned int )rate_scale_index_msk == 0U) {
#line 2308
    rate_scale_index_msk = rate_mask;
  } else {

  }
#line 2310
  if ((((int )rate_scale_index_msk >> index) & 1) == 0) {
#line 2311
    __iwl_err(priv->dev, 0, 0, "Current Rate is not valid\n");
#line 2312
    if ((unsigned int )lq_sta->search_better_tbl != 0U) {
#line 2314
      tbl->lq_type = 0;
#line 2315
      lq_sta->search_better_tbl = 0U;
#line 2316
      tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 2318
      index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
#line 2319
      rs_update_rate_tbl(priv, ctx, lq_sta, tbl, index, (int )is_green);
    } else {

    }
#line 2322
    return;
  } else {

  }
#line 2326
  if ((unsigned long )tbl->expected_tpt == (unsigned long )((u16 const   *)0U)) {
#line 2327
    __iwl_err(priv->dev, 0, 0, "tbl->expected_tpt is NULL\n");
#line 2328
    return;
  } else {

  }
#line 2332
  if ((int )lq_sta->max_rate_idx != -1 && (int )lq_sta->max_rate_idx < index) {
#line 2334
    index = (int )lq_sta->max_rate_idx;
#line 2335
    update_lq = 1U;
#line 2336
    window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
#line 2337
    goto lq_update;
  } else {

  }
#line 2340
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
#line 2349
  fail_count = (u32 )(window->counter - window->success_counter);
#line 2350
  if (fail_count <= 5U && window->success_counter <= 7) {
#line 2352
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "LQ: still below TH. succ=%d total=%d for index %d\n",
              window->success_counter, window->counter, index);
#line 2357
    window->average_tpt = -1;
#line 2361
    rs_stay_in_table(lq_sta, 0);
#line 2363
    goto out;
  } else {

  }
#line 2367
  if (window->average_tpt != (window->success_ratio * (int )*(tbl->expected_tpt + (unsigned long )index) + 64) / 128) {
#line 2369
    __iwl_err(priv->dev, 0, 0, "expected_tpt should have been calculated by now\n");
#line 2370
    window->average_tpt = (window->success_ratio * (int )*(tbl->expected_tpt + (unsigned long )index) + 64) / 128;
  } else {

  }
#line 2375
  if ((unsigned int )lq_sta->search_better_tbl != 0U) {
#line 2375
    tmp___2 = iwl_tx_ant_restriction(priv);
#line 2375
    if ((unsigned int )tmp___2 == 2U) {
#line 2380
      if (window->average_tpt > lq_sta->last_tpt) {
#line 2382
        __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "LQ: SWITCHING TO NEW TABLE suc=%d cur-tpt=%d old-tpt=%d\n",
                  window->success_ratio, window->average_tpt, lq_sta->last_tpt);
#line 2388
        if ((unsigned int )tbl->lq_type != 1U && (unsigned int )tbl->lq_type != 2U) {
#line 2389
          lq_sta->enable_counter = 1U;
        } else {

        }
#line 2392
        lq_sta->active_tbl = active_tbl;
#line 2393
        current_tpt = window->average_tpt;
      } else {
#line 2398
        __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "LQ: GOING BACK TO THE OLD TABLE suc=%d cur-tpt=%d old-tpt=%d\n",
                  window->success_ratio, window->average_tpt, lq_sta->last_tpt);
#line 2405
        tbl->lq_type = 0;
#line 2408
        active_tbl = lq_sta->active_tbl;
#line 2409
        tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )active_tbl;
#line 2412
        index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
#line 2413
        current_tpt = lq_sta->last_tpt;
#line 2416
        update_lq = 1U;
      }
#line 2421
      lq_sta->search_better_tbl = 0U;
#line 2422
      done_search = 1U;
#line 2423
      goto lq_update;
    } else {

    }
  } else {

  }
#line 2428
  high_low = rs_get_adjacent_rate(priv, (int )((u8 )index), (int )rate_scale_index_msk,
                                  (int )tbl->lq_type);
#line 2430
  low = (int )high_low & 255;
#line 2431
  high = ((int )high_low >> 8) & 255;
#line 2434
  if ((int )lq_sta->max_rate_idx != -1 && (int )lq_sta->max_rate_idx < high) {
#line 2436
    high = 13;
  } else {

  }
#line 2438
  sr = window->success_ratio;
#line 2441
  current_tpt = window->average_tpt;
#line 2442
  if (low != 13) {
#line 2443
    low_tpt = tbl->win[low].average_tpt;
  } else {

  }
#line 2444
  if (high != 13) {
#line 2445
    high_tpt = tbl->win[high].average_tpt;
  } else {

  }
#line 2447
  scale_action = 0;
#line 2450
  if (sr <= 1920 || current_tpt == 0) {
#line 2451
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "decrease rate because of low success_ratio\n");
#line 2452
    scale_action = -1;
  } else
#line 2455
  if (low_tpt == -1 && high_tpt == -1) {
#line 2458
    if (high != 13 && sr > 6399) {
#line 2459
      scale_action = 1;
    } else
#line 2460
    if (low != 13) {
#line 2461
      scale_action = 0;
    } else {

    }
  } else
#line 2466
  if (((low_tpt != -1 && high_tpt != -1) && low_tpt < current_tpt) && high_tpt < current_tpt) {
#line 2470
    scale_action = 0;
  } else
#line 2476
  if (high_tpt != -1) {
#line 2478
    if (high_tpt > current_tpt && sr > 6399) {
#line 2480
      scale_action = 1;
    } else {
#line 2482
      scale_action = 0;
    }
  } else
#line 2486
  if (low_tpt != -1) {
#line 2488
    if (low_tpt > current_tpt) {
#line 2489
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "decrease rate because of low tpt\n");
#line 2491
      scale_action = -1;
    } else
#line 2492
    if (sr > 6399) {
#line 2493
      scale_action = 1;
    } else {

    }
  } else {

  }
#line 2500
  if (((int )scale_action == -1 && low != 13) && (sr > 10880 || (int )*(tbl->expected_tpt + (unsigned long )low) * 100 < current_tpt)) {
#line 2503
    scale_action = 0;
  } else {

  }
#line 2504
  tmp___3 = iwl_ht_enabled(priv);
#line 2504
  if (tmp___3) {
#line 2504
    tmp___4 = 0;
  } else {
#line 2504
    tmp___4 = 1;
  }
#line 2504
  if (tmp___4 && ((unsigned int )tbl->lq_type != 1U && (unsigned int )tbl->lq_type != 2U)) {
#line 2505
    scale_action = -1;
  } else {

  }
#line 2506
  tmp___5 = iwl_tx_ant_restriction(priv);
#line 2506
  if ((unsigned int )tmp___5 != 2U && ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
#line 2508
    scale_action = -1;
  } else {

  }
#line 2510
  if ((unsigned int )priv->bt_traffic_load > 1U && ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
#line 2512
    if ((int )lq_sta->last_bt_traffic > (int )priv->bt_traffic_load) {

    } else
#line 2518
    if ((int )lq_sta->last_bt_traffic <= (int )priv->bt_traffic_load) {
#line 2519
      scale_action = -1;
    } else {

    }
  } else {

  }
#line 2522
  lq_sta->last_bt_traffic = priv->bt_traffic_load;
#line 2524
  if ((unsigned int )priv->bt_traffic_load > 1U && ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
#line 2527
    rs_stay_in_table(lq_sta, 1);
#line 2528
    goto lq_update;
  } else {

  }
#line 2531
  switch ((int )scale_action) {
  case -1: ;
#line 2534
  if (low != 13) {
#line 2535
    update_lq = 1U;
#line 2536
    index = low;
  } else {

  }
#line 2539
  goto ldv_53388;
  case 1: ;
#line 2542
  if (high != 13) {
#line 2543
    update_lq = 1U;
#line 2544
    index = high;
  } else {

  }
#line 2547
  goto ldv_53388;
  case 0: ;
  default: ;
#line 2551
  goto ldv_53388;
  }
  ldv_53388: 
#line 2554
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "choose rate scale index %d action %d low %d high %d type %d\n",
            index, (int )scale_action, low, high, (unsigned int )tbl->lq_type);
  lq_update: ;
#line 2560
  if ((unsigned int )update_lq != 0U) {
#line 2561
    rs_update_rate_tbl(priv, ctx, lq_sta, tbl, index, (int )is_green);
  } else {

  }
#line 2563
  tmp___6 = iwl_tx_ant_restriction(priv);
#line 2563
  if ((unsigned int )tmp___6 == 2U) {
#line 2566
    rs_stay_in_table(lq_sta, 0);
  } else {

  }
#line 2574
  if ((((unsigned int )update_lq == 0U && (unsigned int )done_search == 0U) && (unsigned int )lq_sta->stay_in_tbl == 0U) && window->counter != 0) {
#line 2576
    lq_sta->last_tpt = current_tpt;
#line 2580
    if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
#line 2581
      rs_move_legacy_other(priv, lq_sta, conf, sta, index);
    } else
#line 2582
    if ((unsigned int )tbl->lq_type == 3U) {
#line 2583
      rs_move_siso_to_other(priv, lq_sta, conf, sta, index);
    } else
#line 2584
    if ((unsigned int )tbl->lq_type == 4U) {
#line 2585
      rs_move_mimo2_to_other(priv, lq_sta, conf, sta, index);
    } else {
#line 2587
      rs_move_mimo3_to_other(priv, lq_sta, conf, sta, index);
    }
#line 2590
    if ((unsigned int )lq_sta->search_better_tbl != 0U) {
#line 2592
      tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
#line 2593
      i = 0;
#line 2593
      goto ldv_53393;
      ldv_53392: 
#line 2594
      rs_rate_scale_clear_window((struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )i);
#line 2593
      i = i + 1;
      ldv_53393: ;
#line 2593
      if (i <= 12) {
#line 2595
        goto ldv_53392;
      } else {

      }
#line 2597
      index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
#line 2599
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "Switch current  mcs: %X index: %d\n",
                tbl->current_rate, index);
#line 2601
      rs_fill_link_cmd(priv, lq_sta, tbl->current_rate);
#line 2602
      iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 1, 0);
    } else {
#line 2604
      done_search = 1U;
    }
  } else {

  }
#line 2607
  if ((unsigned int )done_search != 0U && (unsigned int )lq_sta->stay_in_tbl == 0U) {
#line 2613
    tbl1 = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 2614
    if ((unsigned int )tbl1->lq_type == 1U || (unsigned int )tbl1->lq_type == 2U) {
#line 2614
      tmp___7 = conf_is_ht(conf);
#line 2614
      if (tmp___7) {
#line 2614
        tmp___8 = 0;
      } else {
#line 2614
        tmp___8 = 1;
      }
#line 2614
      if (tmp___8) {
#line 2614
        if ((int )lq_sta->action_counter > (int )tbl1->max_search) {
#line 2616
          __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "LQ: STAY in legacy table\n");
#line 2617
          rs_set_stay_in_table(priv, 1, lq_sta);
        } else {

        }
      } else {

      }
    } else {

    }
#line 2623
    if ((unsigned int )lq_sta->enable_counter != 0U && (int )lq_sta->action_counter >= (int )tbl1->max_search) {
#line 2623
      tmp___9 = iwl_ht_enabled(priv);
#line 2623
      if ((int )tmp___9) {
#line 2626
        if ((lq_sta->last_tpt > 0 && ((int )lq_sta->tx_agg_tid_en >> (int )tid) & 1) && (unsigned int )tid != 8U) {
#line 2629
          sta_id = lq_sta->lq.sta_id;
#line 2630
          tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
#line 2631
          if ((unsigned int )tid_data->agg.state == 0U) {
#line 2632
            __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "try to aggregate tid %d\n",
                      (int )tid);
#line 2635
            rs_tl_turn_on_agg(priv, (int )tid, lq_sta, sta);
          } else {

          }
        } else {

        }
#line 2639
        rs_set_stay_in_table(priv, 0, lq_sta);
      } else {

      }
    } else {

    }
  } else {

  }
  out: 
#line 2644
  tbl->current_rate = rate_n_flags_from_tbl(priv, tbl, index, (int )is_green);
#line 2645
  lq_sta->last_txrate_idx = index;
#line 2646
  return;
}
}
#line 2662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_initialize_lq(struct iwl_priv *priv , struct ieee80211_sta *sta , struct iwl_lq_sta *lq_sta ) 
{ 
  struct iwl_scale_tbl_info *tbl ;
  int rate_idx ;
  int i ;
  u32 rate ;
  u8 use_green ;
  bool tmp ;
  u8 active_tbl ;
  u8 valid_tx_ant ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  u8 tmp___0 ;

  {
#line 2670
  tmp = rs_use_green(sta);
#line 2670
  use_green = (u8 )tmp;
#line 2671
  active_tbl = 0U;
#line 2676
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0) || (unsigned long )lq_sta == (unsigned long )((struct iwl_lq_sta *)0)) {
#line 2677
    return;
  } else {

  }
#line 2679
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 2680
  ctx = sta_priv->ctx;
#line 2682
  i = lq_sta->last_txrate_idx;
#line 2684
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
#line 2686
  if ((unsigned int )lq_sta->search_better_tbl == 0U) {
#line 2687
    active_tbl = lq_sta->active_tbl;
  } else {
#line 2689
    active_tbl = 1U - (unsigned int )lq_sta->active_tbl;
  }
#line 2691
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )active_tbl;
#line 2693
  if (i < 0 || i > 12) {
#line 2694
    i = 0;
  } else {

  }
#line 2696
  rate = (u32 )iwl_rates[i].plcp;
#line 2697
  tbl->ant_type = first_antenna((int )valid_tx_ant);
#line 2698
  rate = (u32 )((int )tbl->ant_type << 14) | rate;
#line 2700
  if (i >= 0 && i <= 3) {
#line 2701
    rate = rate | 512U;
  } else {

  }
#line 2703
  rs_get_tbl_info_from_mcs(rate, priv->band, tbl, & rate_idx);
#line 2704
  tmp___0 = rs_is_valid_ant((int )valid_tx_ant, (int )tbl->ant_type);
#line 2704
  if ((unsigned int )tmp___0 == 0U) {
#line 2705
    rs_toggle_antenna((u32 )valid_tx_ant, & rate, tbl);
  } else {

  }
#line 2707
  rate = rate_n_flags_from_tbl(priv, tbl, rate_idx, (int )use_green);
#line 2708
  tbl->current_rate = rate;
#line 2709
  rs_set_expected_tpt_table(lq_sta, tbl);
#line 2710
  rs_fill_link_cmd((struct iwl_priv *)0, lq_sta, rate);
#line 2711
  priv->stations[(int )lq_sta->lq.sta_id].lq = & lq_sta->lq;
#line 2712
  iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 0, 1);
#line 2713
  return;
}
}
#line 2715 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_get_rate(void *priv_r , struct ieee80211_sta *sta , void *priv_sta ,
                        struct ieee80211_tx_rate_control *txrc ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_supported_band *sband ;
  struct iwl_op_mode *op_mode ;
  struct iwl_priv *priv ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp ;
  struct iwl_lq_sta *lq_sta ;
  int rate_idx ;
  bool tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  s8 tmp___3 ;

  {
#line 2719
  skb = txrc->skb;
#line 2720
  sband = txrc->sband;
#line 2721
  op_mode = (struct iwl_op_mode *)priv_r;
#line 2723
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 2724
  tmp = IEEE80211_SKB_CB(skb);
#line 2724
  info = tmp;
#line 2725
  lq_sta = (struct iwl_lq_sta *)priv_sta;
#line 2728
  __iwl_dbg(priv->dev, 1048576U, 1, "rs_get_rate", "rate scale calculate new rate for skb\n");
#line 2731
  if ((unsigned long )lq_sta != (unsigned long )((struct iwl_lq_sta *)0)) {
#line 2732
    lq_sta->max_rate_idx = (s8 )txrc->max_rate_idx;
#line 2733
    if ((unsigned int )sband->band == 1U && (int )lq_sta->max_rate_idx != -1) {
#line 2735
      lq_sta->max_rate_idx = (s8 )((unsigned int )((unsigned char )lq_sta->max_rate_idx) + 4U);
    } else {

    }
#line 2736
    if ((int )lq_sta->max_rate_idx < 0 || (int )lq_sta->max_rate_idx > 12) {
#line 2738
      lq_sta->max_rate_idx = -1;
    } else {

    }
  } else {

  }
#line 2742
  if ((unsigned long )lq_sta != (unsigned long )((struct iwl_lq_sta *)0) && (unsigned long )lq_sta->drv == (unsigned long )((struct iwl_priv *)0)) {
#line 2743
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_get_rate", "Rate scaling not initialized yet.\n");
#line 2744
    priv_sta = (void *)0;
  } else {

  }
#line 2748
  tmp___0 = rate_control_send_low(sta, priv_sta, txrc);
#line 2748
  if ((int )tmp___0) {
#line 2749
    return;
  } else {

  }
#line 2751
  rate_idx = lq_sta->last_txrate_idx;
#line 2753
  if ((lq_sta->last_rate_n_flags & 256U) != 0U) {
#line 2754
    rate_idx = rate_idx + -4;
#line 2756
    rate_idx = rate_idx > 0 ? rate_idx + -1 : 0;
#line 2757
    tmp___2 = rs_extract_rate(lq_sta->last_rate_n_flags);
#line 2757
    if ((unsigned int )tmp___2 > 15U) {
#line 2759
      rate_idx = rate_idx + 16;
    } else {
#line 2760
      tmp___1 = rs_extract_rate(lq_sta->last_rate_n_flags);
#line 2760
      if ((unsigned int )tmp___1 > 7U) {
#line 2762
        rate_idx = rate_idx + 8;
      } else {

      }
    }
#line 2763
    info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = 8U;
#line 2764
    if ((lq_sta->last_rate_n_flags & 8192U) != 0U) {
#line 2765
      info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = (unsigned short )((unsigned int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags | 128U);
    } else {

    }
#line 2766
    if ((lq_sta->last_rate_n_flags & 4096U) != 0U) {
#line 2767
      info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = (unsigned short )((unsigned int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags | 64U);
    } else {

    }
#line 2768
    if ((lq_sta->last_rate_n_flags & 2048U) != 0U) {
#line 2769
      info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = (unsigned short )((unsigned int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags | 32U);
    } else {

    }
#line 2770
    if ((lq_sta->last_rate_n_flags & 1024U) != 0U) {
#line 2771
      info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = (unsigned short )((unsigned int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags | 16U);
    } else {

    }
  } else {
#line 2774
    if ((rate_idx < 0 || rate_idx > 11) || ((unsigned int )sband->band == 1U && rate_idx <= 3)) {
#line 2777
      tmp___3 = rate_lowest_index(sband, sta);
#line 2777
      rate_idx = (int )tmp___3;
    } else
#line 2779
    if ((unsigned int )sband->band == 1U) {
#line 2780
      rate_idx = rate_idx + -4;
    } else {

    }
#line 2781
    info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = 0U;
  }
#line 2783
  info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].idx = (s8 )rate_idx;
#line 2784
  info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].count = 1U;
#line 2785
  return;
}
}
#line 2787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void *rs_alloc_sta(void *priv_rate , struct ieee80211_sta *sta , gfp_t gfp ) 
{ 
  struct iwl_station_priv *sta_priv ;
  struct iwl_op_mode *op_mode ;
  struct iwl_priv *priv ;

  {
#line 2790
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 2791
  op_mode = (struct iwl_op_mode *)priv_rate;
#line 2793
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 2795
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_alloc_sta", "create station rate scale window\n");
#line 2797
  return ((void *)(& sta_priv->lq_sta));
}
}
#line 2803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
void iwl_rs_rate_init(struct iwl_priv *priv , struct ieee80211_sta *sta , u8 sta_id ) 
{ 
  int i ;
  int j ;
  struct ieee80211_hw *hw ;
  struct ieee80211_conf *conf ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_lq_sta *lq_sta ;
  struct ieee80211_supported_band *sband ;
  unsigned long supp ;
  bool tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  s8 tmp___4 ;

  {
#line 2806
  hw = priv->hw;
#line 2807
  conf = & (priv->hw)->conf;
#line 2808
  ht_cap = & sta->ht_cap;
#line 2814
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 2815
  lq_sta = & sta_priv->lq_sta;
#line 2816
  sband = (hw->wiphy)->bands[(unsigned int )(conf->chandef.chan)->band];
#line 2819
  lq_sta->lq.sta_id = sta_id;
#line 2821
  j = 0;
#line 2821
  goto ldv_53451;
  ldv_53450: 
#line 2822
  i = 0;
#line 2822
  goto ldv_53448;
  ldv_53447: 
#line 2823
  rs_rate_scale_clear_window((struct iwl_rate_scale_data *)(& lq_sta->lq_info[j].win) + (unsigned long )i);
#line 2822
  i = i + 1;
  ldv_53448: ;
#line 2822
  if (i <= 12) {
#line 2824
    goto ldv_53447;
  } else {

  }
#line 2821
  j = j + 1;
  ldv_53451: ;
#line 2821
  if (j <= 1) {
#line 2823
    goto ldv_53450;
  } else {

  }
#line 2825
  lq_sta->flush_timer = 0ULL;
#line 2826
  lq_sta->supp_rates = sta->supp_rates[(unsigned int )sband->band];
#line 2828
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_rs_rate_init", "LQ: *** rate scale station global init for station %d ***\n",
            (int )sta_id);
#line 2835
  lq_sta->is_dup = 0U;
#line 2836
  lq_sta->max_rate_idx = -1;
#line 2837
  lq_sta->missed_rate_counter = 15U;
#line 2838
  tmp = rs_use_green(sta);
#line 2838
  lq_sta->is_green = (u8 )tmp;
#line 2839
  lq_sta->band = sband->band;
#line 2843
  supp = (unsigned long )sta->supp_rates[(unsigned int )sband->band];
#line 2844
  lq_sta->active_legacy_rate = 0U;
#line 2845
  tmp___0 = find_first_bit((unsigned long const   *)(& supp), 64UL);
#line 2845
  i = (int )tmp___0;
#line 2845
  goto ldv_53455;
  ldv_53454: 
#line 2846
  lq_sta->active_legacy_rate = (int )lq_sta->active_legacy_rate | (int )((u16 )(1UL << (int )(sband->bitrates + (unsigned long )i)->hw_value));
#line 2845
  tmp___1 = find_next_bit((unsigned long const   *)(& supp), 64UL, (unsigned long )(i + 1));
#line 2845
  i = (int )tmp___1;
  ldv_53455: ;
#line 2845
  if (i <= 63) {
#line 2847
    goto ldv_53454;
  } else {

  }
#line 2852
  lq_sta->active_siso_rate = (int )((u16 )ht_cap->mcs.rx_mask[0]) << 1U;
#line 2853
  lq_sta->active_siso_rate = (u16 )((int )((short )lq_sta->active_siso_rate) | ((int )((short )ht_cap->mcs.rx_mask[0]) & 1));
#line 2854
  lq_sta->active_siso_rate = (unsigned int )lq_sta->active_siso_rate & 65533U;
#line 2855
  lq_sta->active_siso_rate = (int )lq_sta->active_siso_rate << 4U;
#line 2858
  lq_sta->active_mimo2_rate = (int )((u16 )ht_cap->mcs.rx_mask[1]) << 1U;
#line 2859
  lq_sta->active_mimo2_rate = (u16 )((int )((short )lq_sta->active_mimo2_rate) | ((int )((short )ht_cap->mcs.rx_mask[1]) & 1));
#line 2860
  lq_sta->active_mimo2_rate = (unsigned int )lq_sta->active_mimo2_rate & 65533U;
#line 2861
  lq_sta->active_mimo2_rate = (int )lq_sta->active_mimo2_rate << 4U;
#line 2863
  lq_sta->active_mimo3_rate = (int )((u16 )ht_cap->mcs.rx_mask[2]) << 1U;
#line 2864
  lq_sta->active_mimo3_rate = (u16 )((int )((short )lq_sta->active_mimo3_rate) | ((int )((short )ht_cap->mcs.rx_mask[2]) & 1));
#line 2865
  lq_sta->active_mimo3_rate = (unsigned int )lq_sta->active_mimo3_rate & 65533U;
#line 2866
  lq_sta->active_mimo3_rate = (int )lq_sta->active_mimo3_rate << 4U;
#line 2868
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_rs_rate_init", "SISO-RATE=%X MIMO2-RATE=%X MIMO3-RATE=%X\n",
            (int )lq_sta->active_siso_rate, (int )lq_sta->active_mimo2_rate, (int )lq_sta->active_mimo3_rate);
#line 2874
  lq_sta->lq.general_params.single_stream_ant_msk = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 2876
  tmp___2 = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 2876
  lq_sta->lq.general_params.dual_stream_ant_msk = (u8 )((int )((signed char )(priv->nvm_data)->valid_tx_ant) & ~ ((int )((signed char )tmp___2)));
#line 2879
  if ((unsigned int )lq_sta->lq.general_params.dual_stream_ant_msk == 0U) {
#line 2880
    lq_sta->lq.general_params.dual_stream_ant_msk = 3U;
  } else {
#line 2881
    tmp___3 = num_of_ant((int )(priv->nvm_data)->valid_tx_ant);
#line 2881
    if ((unsigned int )tmp___3 == 2U) {
#line 2882
      lq_sta->lq.general_params.dual_stream_ant_msk = (priv->nvm_data)->valid_tx_ant;
    } else {

    }
  }
#line 2887
  lq_sta->tx_agg_tid_en = 255U;
#line 2888
  lq_sta->drv = priv;
#line 2891
  tmp___4 = rate_lowest_index(sband, sta);
#line 2891
  lq_sta->last_txrate_idx = (int )tmp___4;
#line 2892
  if ((unsigned int )sband->band == 1U) {
#line 2893
    lq_sta->last_txrate_idx = lq_sta->last_txrate_idx + 4;
  } else {

  }
#line 2894
  lq_sta->is_agg = 0U;
#line 2896
  lq_sta->dbg_fixed_rate = 0U;
#line 2899
  rs_initialize_lq(priv, sta, lq_sta);
#line 2900
  return;
}
}
#line 2902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_fill_link_cmd(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta , u32 new_rate ) 
{ 
  struct iwl_scale_tbl_info tbl_type ;
  int index ;
  int rate_idx ;
  int repeat_rate ;
  u8 ant_toggle_cnt ;
  u8 use_ht_possible ;
  u8 valid_tx_ant ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_lq_sta  const  *__mptr ;
  struct iwl_link_quality_cmd *lq_cmd ;
  int _min1 ;
  int _min2 ;
  u8 tmp ;
  u8 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2906
  index = 0;
#line 2908
  repeat_rate = 0;
#line 2909
  ant_toggle_cnt = 0U;
#line 2910
  use_ht_possible = 1U;
#line 2911
  valid_tx_ant = 0U;
#line 2913
  __mptr = (struct iwl_lq_sta  const  *)lq_sta;
#line 2913
  sta_priv = (struct iwl_station_priv *)__mptr + 0xfffffffffffffff8UL;
#line 2914
  lq_cmd = & lq_sta->lq;
#line 2917
  rs_dbgfs_set_mcs(lq_sta, & new_rate, index);
#line 2920
  rs_get_tbl_info_from_mcs(new_rate, lq_sta->band, & tbl_type, & rate_idx);
#line 2923
  if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0) && (int )priv->bt_full_concurrent) {
#line 2925
    tbl_type.ant_type = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  } else {

  }
#line 2930
  if ((unsigned int )tbl_type.lq_type == 1U || (unsigned int )tbl_type.lq_type == 2U) {
#line 2931
    ant_toggle_cnt = 1U;
#line 2932
    repeat_rate = 1;
  } else {
#line 2934
    _min1 = 3;
#line 2934
    _min2 = 2;
#line 2934
    repeat_rate = _min1 < _min2 ? _min1 : _min2;
  }
#line 2938
  lq_cmd->general_params.mimo_delimiter = (u8 )((unsigned int )tbl_type.lq_type == 4U || (unsigned int )tbl_type.lq_type == 5U);
#line 2942
  lq_cmd->rs_table[index].rate_n_flags = new_rate;
#line 2944
  tmp___0 = num_of_ant((int )tbl_type.ant_type);
#line 2944
  if ((unsigned int )tmp___0 == 1U) {
#line 2945
    lq_cmd->general_params.single_stream_ant_msk = tbl_type.ant_type;
  } else {
#line 2947
    tmp = num_of_ant((int )tbl_type.ant_type);
#line 2947
    if ((unsigned int )tmp == 2U) {
#line 2948
      lq_cmd->general_params.dual_stream_ant_msk = tbl_type.ant_type;
    } else {

    }
  }
#line 2952
  index = index + 1;
#line 2953
  repeat_rate = repeat_rate - 1;
#line 2954
  if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0)) {
#line 2955
    if ((int )priv->bt_full_concurrent) {
#line 2956
      valid_tx_ant = 1U;
    } else {
#line 2958
      valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
    }
  } else {

  }
#line 2962
  goto ldv_53480;
  ldv_53479: ;
#line 2966
  goto ldv_53477;
  ldv_53476: ;
#line 2967
  if ((unsigned int )tbl_type.lq_type == 1U || (unsigned int )tbl_type.lq_type == 2U) {
#line 2968
    if ((unsigned int )ant_toggle_cnt == 0U) {
#line 2969
      ant_toggle_cnt = (u8 )((int )ant_toggle_cnt + 1);
    } else
#line 2970
    if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0)) {
#line 2970
      tmp___1 = rs_toggle_antenna((u32 )valid_tx_ant, & new_rate, & tbl_type);
#line 2970
      if (tmp___1 != 0) {
#line 2973
        ant_toggle_cnt = 1U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 2977
  rs_dbgfs_set_mcs(lq_sta, & new_rate, index);
#line 2980
  lq_cmd->rs_table[index].rate_n_flags = new_rate;
#line 2982
  repeat_rate = repeat_rate - 1;
#line 2983
  index = index + 1;
  ldv_53477: ;
#line 2966
  if (repeat_rate > 0 && index <= 15) {
#line 2968
    goto ldv_53476;
  } else {

  }
#line 2986
  rs_get_tbl_info_from_mcs(new_rate, lq_sta->band, & tbl_type, & rate_idx);
#line 2989
  if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0) && (int )priv->bt_full_concurrent) {
#line 2991
    tbl_type.ant_type = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  } else {

  }
#line 2998
  if ((unsigned int )tbl_type.lq_type == 4U || (unsigned int )tbl_type.lq_type == 5U) {
#line 2999
    lq_cmd->general_params.mimo_delimiter = (u8 )index;
  } else {

  }
#line 3002
  new_rate = rs_get_lower_rate(lq_sta, & tbl_type, (int )((u8 )rate_idx), (int )use_ht_possible);
#line 3006
  if ((unsigned int )tbl_type.lq_type == 1U || (unsigned int )tbl_type.lq_type == 2U) {
#line 3007
    if ((unsigned int )ant_toggle_cnt == 0U) {
#line 3008
      ant_toggle_cnt = (u8 )((int )ant_toggle_cnt + 1);
    } else
#line 3009
    if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0)) {
#line 3009
      tmp___2 = rs_toggle_antenna((u32 )valid_tx_ant, & new_rate, & tbl_type);
#line 3009
      if (tmp___2 != 0) {
#line 3012
        ant_toggle_cnt = 1U;
      } else {

      }
    } else {

    }
#line 3014
    repeat_rate = 1;
  } else {
#line 3016
    repeat_rate = 3;
  }
#line 3021
  use_ht_possible = 0U;
#line 3024
  rs_dbgfs_set_mcs(lq_sta, & new_rate, index);
#line 3027
  lq_cmd->rs_table[index].rate_n_flags = new_rate;
#line 3029
  index = index + 1;
#line 3030
  repeat_rate = repeat_rate - 1;
  ldv_53480: ;
#line 2962
  if (index <= 15) {
#line 2964
    goto ldv_53479;
  } else {

  }
#line 3033
  lq_cmd->agg_params.agg_frame_cnt_limit = (int )sta_priv->max_agg_bufsize != 0 ? (u8 )((int )sta_priv->max_agg_bufsize) : 63U;
#line 3035
  lq_cmd->agg_params.agg_dis_start_th = 3U;
#line 3037
  lq_cmd->agg_params.agg_time_limit = 4000U;
#line 3043
  if ((((unsigned long )priv != (unsigned long )((struct iwl_priv *)0) && (unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) && (unsigned int )((unsigned short )((priv->lib)->bt_params)->agg_time_limit) != 0U) && (unsigned int )priv->bt_traffic_load > 1U) {
#line 3046
    lq_cmd->agg_params.agg_time_limit = ((priv->lib)->bt_params)->agg_time_limit;
  } else {

  }
#line 3048
  return;
}
}
#line 3050 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void *rs_alloc(struct ieee80211_hw *hw , struct dentry *debugfsdir ) 
{ 


  {
#line 3052
  return (hw->priv);
}
}
#line 3055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_free(void *priv_rate ) 
{ 


  {
#line 3057
  return;
}
}
#line 3060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_free_sta(void *priv_r , struct ieee80211_sta *sta , void *priv_sta ) 
{ 
  struct iwl_op_mode *op_mode ;
  struct iwl_priv *priv ;

  {
#line 3063
  op_mode = (struct iwl_op_mode *)priv_r;
#line 3064
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 3066
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_free_sta", "enter\n");
#line 3067
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_free_sta", "leave\n");
#line 3068
  return;
}
}
#line 3071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta , u32 *rate_n_flags , int index ) 
{ 
  struct iwl_priv *priv ;
  u8 valid_tx_ant ;
  u8 ant_sel_tx ;

  {
#line 3078
  priv = lq_sta->drv;
#line 3079
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
#line 3080
  if (lq_sta->dbg_fixed_rate != 0U) {
#line 3081
    ant_sel_tx = (u8 )((lq_sta->dbg_fixed_rate & 114688U) >> 14);
#line 3084
    if (((int )valid_tx_ant & (int )ant_sel_tx) == (int )ant_sel_tx) {
#line 3085
      *rate_n_flags = lq_sta->dbg_fixed_rate;
#line 3086
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_dbgfs_set_mcs", "Fixed rate ON\n");
    } else {
#line 3088
      lq_sta->dbg_fixed_rate = 0U;
#line 3089
      __iwl_err(priv->dev, 0, 0, "Invalid antenna selection 0x%X, Valid is 0x%X\n",
                (int )ant_sel_tx, (int )valid_tx_ant);
#line 3092
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_dbgfs_set_mcs", "Fixed rate OFF\n");
    }
  } else {
#line 3095
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_dbgfs_set_mcs", "Fixed rate OFF\n");
  }
#line 3096
  return;
}
}
#line 3099 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static ssize_t rs_sta_dbgfs_scale_table_write(struct file *file , char const   *user_buf ,
                                              size_t count , loff_t *ppos ) 
{ 
  struct iwl_lq_sta *lq_sta ;
  struct iwl_priv *priv ;
  char buf[64U] ;
  size_t buf_size ;
  u32 parsed_rate ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 3102
  lq_sta = (struct iwl_lq_sta *)file->private_data;
#line 3109
  priv = lq_sta->drv;
#line 3110
  memset((void *)(& buf), 0, 64UL);
#line 3111
  _min1 = count;
#line 3111
  _min2 = 63UL;
#line 3111
  buf_size = _min1 < _min2 ? _min1 : _min2;
#line 3112
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, buf_size);
#line 3112
  if (tmp != 0UL) {
#line 3113
    return (-14L);
  } else {

  }
#line 3115
  tmp___0 = sscanf((char const   *)(& buf), "%x", & parsed_rate);
#line 3115
  if (tmp___0 == 1) {
#line 3116
    lq_sta->dbg_fixed_rate = parsed_rate;
  } else {
#line 3118
    lq_sta->dbg_fixed_rate = 0U;
  }
#line 3120
  rs_program_fix_rate(priv, lq_sta);
#line 3122
  return ((ssize_t )count);
}
}
#line 3125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static ssize_t rs_sta_dbgfs_scale_table_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  char *buff ;
  int desc ;
  int i ;
  int index ;
  ssize_t ret ;
  struct iwl_lq_sta *lq_sta ;
  struct iwl_priv *priv ;
  struct iwl_scale_tbl_info *tbl ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 3129
  desc = 0;
#line 3130
  i = 0;
#line 3131
  index = 0;
#line 3134
  lq_sta = (struct iwl_lq_sta *)file->private_data;
#line 3136
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 3138
  priv = lq_sta->drv;
#line 3139
  tmp = kmalloc(1024UL, 208U);
#line 3139
  buff = (char *)tmp;
#line 3140
  if ((unsigned long )buff == (unsigned long )((char *)0)) {
#line 3141
    return (-12L);
  } else {

  }
#line 3143
  tmp___0 = sprintf(buff + (unsigned long )desc, "sta_id %d\n", (int )lq_sta->lq.sta_id);
#line 3143
  desc = tmp___0 + desc;
#line 3144
  tmp___1 = sprintf(buff + (unsigned long )desc, "failed=%d success=%d rate=0%X\n",
                    lq_sta->total_failed, lq_sta->total_success, (int )lq_sta->active_legacy_rate);
#line 3144
  desc = tmp___1 + desc;
#line 3147
  tmp___2 = sprintf(buff + (unsigned long )desc, "fixed rate 0x%X\n", lq_sta->dbg_fixed_rate);
#line 3147
  desc = tmp___2 + desc;
#line 3149
  tmp___3 = sprintf(buff + (unsigned long )desc, "valid_tx_ant %s%s%s\n", (int )(priv->nvm_data)->valid_tx_ant & 1 ? (char *)"ANT_A," : (char *)"",
                    ((unsigned long )(priv->nvm_data)->valid_tx_ant & 2UL) != 0UL ? (char *)"ANT_B," : (char *)"",
                    ((unsigned long )(priv->nvm_data)->valid_tx_ant & 4UL) != 0UL ? (char *)"ANT_C" : (char *)"");
#line 3149
  desc = tmp___3 + desc;
#line 3153
  tmp___4 = sprintf(buff + (unsigned long )desc, "lq type %s\n", (unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U ? (char *)"legacy" : (char *)"HT");
#line 3153
  desc = tmp___4 + desc;
#line 3155
  if ((unsigned int )tbl->lq_type == 3U || ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
#line 3156
    tmp___5 = sprintf(buff + (unsigned long )desc, " %s", (unsigned int )tbl->lq_type != 3U ? ((unsigned int )tbl->lq_type == 4U ? (char *)"MIMO2" : (char *)"MIMO3") : (char *)"SISO");
#line 3156
    desc = tmp___5 + desc;
#line 3159
    tmp___6 = sprintf(buff + (unsigned long )desc, " %s", (unsigned int )tbl->is_ht40 != 0U ? (char *)"40MHz" : (char *)"20MHz");
#line 3159
    desc = tmp___6 + desc;
#line 3161
    tmp___7 = sprintf(buff + (unsigned long )desc, " %s %s %s\n", (unsigned int )tbl->is_SGI != 0U ? (char *)"SGI" : (char *)"",
                      (unsigned int )lq_sta->is_green != 0U ? (char *)"GF enabled" : (char *)"",
                      (unsigned int )lq_sta->is_agg != 0U ? (char *)"AGG on" : (char *)"");
#line 3161
    desc = tmp___7 + desc;
  } else {

  }
#line 3166
  tmp___8 = sprintf(buff + (unsigned long )desc, "last tx rate=0x%X\n", lq_sta->last_rate_n_flags);
#line 3166
  desc = tmp___8 + desc;
#line 3168
  tmp___9 = sprintf(buff + (unsigned long )desc, "general:flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\n",
                    (int )lq_sta->lq.general_params.flags, (int )lq_sta->lq.general_params.mimo_delimiter,
                    (int )lq_sta->lq.general_params.single_stream_ant_msk, (int )lq_sta->lq.general_params.dual_stream_ant_msk);
#line 3168
  desc = tmp___9 + desc;
#line 3175
  tmp___10 = sprintf(buff + (unsigned long )desc, "agg:time_limit=%d dist_start_th=%d frame_cnt_limit=%d\n",
                     (int )lq_sta->lq.agg_params.agg_time_limit, (int )lq_sta->lq.agg_params.agg_dis_start_th,
                     (int )lq_sta->lq.agg_params.agg_frame_cnt_limit);
#line 3175
  desc = tmp___10 + desc;
#line 3181
  tmp___11 = sprintf(buff + (unsigned long )desc, "Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\n",
                     (int )lq_sta->lq.general_params.start_rate_index[0], (int )lq_sta->lq.general_params.start_rate_index[1],
                     (int )lq_sta->lq.general_params.start_rate_index[2], (int )lq_sta->lq.general_params.start_rate_index[3]);
#line 3181
  desc = tmp___11 + desc;
#line 3188
  i = 0;
#line 3188
  goto ldv_53535;
  ldv_53534: 
#line 3189
  index = iwl_hwrate_to_plcp_idx(lq_sta->lq.rs_table[i].rate_n_flags);
#line 3191
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
#line 3192
    tmp___12 = sprintf(buff + (unsigned long )desc, " rate[%d] 0x%X %smbps\n", i,
                       lq_sta->lq.rs_table[i].rate_n_flags, (char const   *)(& iwl_rate_mcs[index].mbps));
#line 3192
    desc = tmp___12 + desc;
  } else {
#line 3196
    tmp___13 = sprintf(buff + (unsigned long )desc, " rate[%d] 0x%X %smbps (%s)\n",
                       i, lq_sta->lq.rs_table[i].rate_n_flags, (char const   *)(& iwl_rate_mcs[index].mbps),
                       (char const   *)(& iwl_rate_mcs[index].mcs));
#line 3196
    desc = tmp___13 + desc;
  }
#line 3188
  i = i + 1;
  ldv_53535: ;
#line 3188
  if (i <= 15) {
#line 3190
    goto ldv_53534;
  } else {

  }
#line 3202
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buff,
                                (size_t )desc);
#line 3203
  kfree((void const   *)buff);
#line 3204
  return (ret);
}
}
#line 3207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static struct file_operations  const  rs_sta_dbgfs_scale_table_ops  = 
#line 3207
     {0, & default_llseek, & rs_sta_dbgfs_scale_table_read, & rs_sta_dbgfs_scale_table_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 3213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static ssize_t rs_sta_dbgfs_stats_table_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  char *buff ;
  int desc ;
  int i ;
  int j ;
  ssize_t ret ;
  struct iwl_lq_sta *lq_sta ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3217
  desc = 0;
#line 3221
  lq_sta = (struct iwl_lq_sta *)file->private_data;
#line 3223
  tmp = kmalloc(1024UL, 208U);
#line 3223
  buff = (char *)tmp;
#line 3224
  if ((unsigned long )buff == (unsigned long )((char *)0)) {
#line 3225
    return (-12L);
  } else {

  }
#line 3227
  i = 0;
#line 3227
  goto ldv_53554;
  ldv_53553: 
#line 3228
  tmp___0 = sprintf(buff + (unsigned long )desc, "%s type=%d SGI=%d HT40=%d DUP=%d GF=%d\nrate=0x%X\n",
                    (int )lq_sta->active_tbl == i ? (char *)"*" : (char *)"x", (unsigned int )lq_sta->lq_info[i].lq_type,
                    (int )lq_sta->lq_info[i].is_SGI, (int )lq_sta->lq_info[i].is_ht40,
                    (int )lq_sta->lq_info[i].is_dup, (int )lq_sta->is_green, lq_sta->lq_info[i].current_rate);
#line 3228
  desc = tmp___0 + desc;
#line 3238
  j = 0;
#line 3238
  goto ldv_53551;
  ldv_53550: 
#line 3239
  tmp___1 = sprintf(buff + (unsigned long )desc, "counter=%d success=%d %%=%d\n",
                    lq_sta->lq_info[i].win[j].counter, lq_sta->lq_info[i].win[j].success_counter,
                    lq_sta->lq_info[i].win[j].success_ratio);
#line 3239
  desc = tmp___1 + desc;
#line 3238
  j = j + 1;
  ldv_53551: ;
#line 3238
  if (j <= 12) {
#line 3240
    goto ldv_53550;
  } else {

  }
#line 3227
  i = i + 1;
  ldv_53554: ;
#line 3227
  if (i <= 1) {
#line 3229
    goto ldv_53553;
  } else {

  }
#line 3246
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buff,
                                (size_t )desc);
#line 3247
  kfree((void const   *)buff);
#line 3248
  return (ret);
}
}
#line 3251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static struct file_operations  const  rs_sta_dbgfs_stats_table_ops  = 
#line 3251
     {0, & default_llseek, & rs_sta_dbgfs_stats_table_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 3257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static ssize_t rs_sta_dbgfs_rate_scale_data_read(struct file *file , char *user_buf ,
                                                 size_t count , loff_t *ppos ) 
{ 
  struct iwl_lq_sta *lq_sta ;
  struct iwl_scale_tbl_info *tbl ;
  char buff[120U] ;
  int desc ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 3260
  lq_sta = (struct iwl_lq_sta *)file->private_data;
#line 3261
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
#line 3263
  desc = 0;
#line 3265
  if ((unsigned int )tbl->lq_type == 3U || ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
#line 3266
    tmp = sprintf((char *)(& buff) + (unsigned long )desc, "Bit Rate= %d Mb/s\n",
                  (int )*(tbl->expected_tpt + (unsigned long )lq_sta->last_txrate_idx));
#line 3266
    desc = tmp + desc;
  } else {
#line 3270
    tmp___0 = sprintf((char *)(& buff) + (unsigned long )desc, "Bit Rate= %d Mb/s\n",
                      (int )((unsigned char )iwl_rates[lq_sta->last_txrate_idx].ieee) >> 1);
#line 3270
    desc = tmp___0 + desc;
  }
#line 3274
  tmp___1 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buff),
                                    (size_t )desc);
#line 3274
  return (tmp___1);
}
}
#line 3277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static struct file_operations  const  rs_sta_dbgfs_rate_scale_data_ops  = 
#line 3277
     {0, & default_llseek, & rs_sta_dbgfs_rate_scale_data_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 3283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_add_debugfs(void *priv , void *priv_sta , struct dentry *dir ) 
{ 
  struct iwl_lq_sta *lq_sta ;

  {
#line 3286
  lq_sta = (struct iwl_lq_sta *)priv_sta;
#line 3287
  lq_sta->rs_sta_dbgfs_scale_table_file = debugfs_create_file("rate_scale_table",
                                                              384, dir, (void *)lq_sta,
                                                              & rs_sta_dbgfs_scale_table_ops);
#line 3290
  lq_sta->rs_sta_dbgfs_stats_table_file = debugfs_create_file("rate_stats_table",
                                                              256, dir, (void *)lq_sta,
                                                              & rs_sta_dbgfs_stats_table_ops);
#line 3293
  lq_sta->rs_sta_dbgfs_rate_scale_data_file = debugfs_create_file("rate_scale_data",
                                                                  256, dir, (void *)lq_sta,
                                                                  & rs_sta_dbgfs_rate_scale_data_ops);
#line 3296
  lq_sta->rs_sta_dbgfs_tx_agg_tid_en_file = debugfs_create_u8("tx_agg_tid_enable",
                                                              384, dir, & lq_sta->tx_agg_tid_en);
#line 3299
  return;
}
}
#line 3302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_remove_debugfs(void *priv , void *priv_sta ) 
{ 
  struct iwl_lq_sta *lq_sta ;

  {
#line 3304
  lq_sta = (struct iwl_lq_sta *)priv_sta;
#line 3305
  debugfs_remove(lq_sta->rs_sta_dbgfs_scale_table_file);
#line 3306
  debugfs_remove(lq_sta->rs_sta_dbgfs_stats_table_file);
#line 3307
  debugfs_remove(lq_sta->rs_sta_dbgfs_rate_scale_data_file);
#line 3308
  debugfs_remove(lq_sta->rs_sta_dbgfs_tx_agg_tid_en_file);
#line 3309
  return;
}
}
#line 3317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static void rs_rate_init_stub(void *priv_r , struct ieee80211_supported_band *sband ,
                              struct cfg80211_chan_def *chandef , struct ieee80211_sta *sta ,
                              void *priv_sta ) 
{ 


  {
#line 3319
  return;
}
}
#line 3323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
static struct rate_control_ops  const  rs_ops  = 
#line 3323
     {"iwl-agn-rs", & rs_alloc, & rs_free, & rs_alloc_sta, & rs_rate_init_stub, 0, & rs_free_sta,
    0, & rs_tx_status, & rs_get_rate, & rs_add_debugfs, & rs_remove_debugfs, 0};
#line 3338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
int iwlagn_rate_control_register(void) 
{ 
  int tmp ;

  {
#line 3340
  tmp = ieee80211_rate_control_register(& rs_ops);
#line 3340
  return (tmp);
}
}
#line 3343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.c"
void iwlagn_rate_control_unregister(void) 
{ 


  {
#line 3345
  ieee80211_rate_control_unregister(& rs_ops);
#line 3346
  return;
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
int ldv_retval_20  ;
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
int ldv_retval_19  ;
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
int ldv_retval_16  ;
#line 552
extern int ldv_release_67(void) ;
#line 553
extern int ldv_release_68(void) ;
#line 554
extern int ldv_release_66(void) ;
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_file_operations_66(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 558
  tmp = ldv_init_zalloc(1000UL);
#line 558
  rs_sta_dbgfs_rate_scale_data_ops_group1 = (struct inode *)tmp;
#line 559
  tmp___0 = ldv_init_zalloc(504UL);
#line 559
  rs_sta_dbgfs_rate_scale_data_ops_group2 = (struct file *)tmp___0;
#line 560
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_file_operations_68(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 564
  tmp = ldv_init_zalloc(1000UL);
#line 564
  rs_sta_dbgfs_scale_table_ops_group1 = (struct inode *)tmp;
#line 565
  tmp___0 = ldv_init_zalloc(504UL);
#line 565
  rs_sta_dbgfs_scale_table_ops_group2 = (struct file *)tmp___0;
#line 566
  return;
}
}
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_initialize_rate_control_ops_65(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 570
  tmp = ldv_init_zalloc(72UL);
#line 570
  rs_ops_group0 = (struct ieee80211_supported_band *)tmp;
#line 571
  tmp___0 = ldv_init_zalloc(216UL);
#line 571
  rs_ops_group1 = (struct ieee80211_sta *)tmp___0;
#line 572
  tmp___1 = ldv_init_zalloc(320UL);
#line 572
  rs_ops_group2 = (struct dentry *)tmp___1;
#line 573
  return;
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_file_operations_67(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 576
  tmp = ldv_init_zalloc(1000UL);
#line 576
  rs_sta_dbgfs_stats_table_ops_group1 = (struct inode *)tmp;
#line 577
  tmp___0 = ldv_init_zalloc(504UL);
#line 577
  rs_sta_dbgfs_stats_table_ops_group2 = (struct file *)tmp___0;
#line 578
  return;
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_main_exported_67(void) 
{ 
  int ldvarg186 ;
  loff_t *ldvarg188 ;
  void *tmp ;
  loff_t ldvarg187 ;
  size_t ldvarg189 ;
  char *ldvarg190 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 583
  tmp = ldv_init_zalloc(8UL);
#line 583
  ldvarg188 = (loff_t *)tmp;
#line 586
  tmp___0 = ldv_init_zalloc(1UL);
#line 586
  ldvarg190 = (char *)tmp___0;
#line 582
  ldv_memset((void *)(& ldvarg186), 0, 4UL);
#line 584
  ldv_memset((void *)(& ldvarg187), 0, 8UL);
#line 585
  ldv_memset((void *)(& ldvarg189), 0, 8UL);
#line 588
  tmp___1 = __VERIFIER_nondet_int();
#line 588
  switch (tmp___1) {
  case 0: ;
#line 591
  if (ldv_state_variable_67 == 2) {
#line 593
    rs_sta_dbgfs_stats_table_read(rs_sta_dbgfs_stats_table_ops_group2, ldvarg190,
                                  ldvarg189, ldvarg188);
#line 595
    ldv_state_variable_67 = 2;
  } else {

  }
#line 598
  goto ldv_53623;
  case 1: ;
#line 601
  if (ldv_state_variable_67 == 1) {
#line 603
    ldv_retval_19 = simple_open(rs_sta_dbgfs_stats_table_ops_group1, rs_sta_dbgfs_stats_table_ops_group2);
#line 604
    if (ldv_retval_19 == 0) {
#line 605
      ldv_state_variable_67 = 2;
#line 606
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 610
  goto ldv_53623;
  case 2: ;
#line 613
  if (ldv_state_variable_67 == 2) {
#line 615
    default_llseek(rs_sta_dbgfs_stats_table_ops_group2, ldvarg187, ldvarg186);
#line 617
    ldv_state_variable_67 = 2;
  } else {

  }
#line 620
  goto ldv_53623;
  case 3: ;
#line 623
  if (ldv_state_variable_67 == 2) {
#line 625
    ldv_release_67();
#line 626
    ldv_state_variable_67 = 1;
#line 627
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 630
  goto ldv_53623;
  default: 
#line 631
  ldv_stop();
  }
  ldv_53623: ;
#line 635
  return;
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_main_exported_66(void) 
{ 
  loff_t *ldvarg169 ;
  void *tmp ;
  loff_t ldvarg168 ;
  char *ldvarg171 ;
  void *tmp___0 ;
  size_t ldvarg170 ;
  int ldvarg167 ;
  int tmp___1 ;

  {
#line 638
  tmp = ldv_init_zalloc(8UL);
#line 638
  ldvarg169 = (loff_t *)tmp;
#line 640
  tmp___0 = ldv_init_zalloc(1UL);
#line 640
  ldvarg171 = (char *)tmp___0;
#line 639
  ldv_memset((void *)(& ldvarg168), 0, 8UL);
#line 641
  ldv_memset((void *)(& ldvarg170), 0, 8UL);
#line 642
  ldv_memset((void *)(& ldvarg167), 0, 4UL);
#line 644
  tmp___1 = __VERIFIER_nondet_int();
#line 644
  switch (tmp___1) {
  case 0: ;
#line 647
  if (ldv_state_variable_66 == 2) {
#line 649
    rs_sta_dbgfs_rate_scale_data_read(rs_sta_dbgfs_rate_scale_data_ops_group2, ldvarg171,
                                      ldvarg170, ldvarg169);
#line 651
    ldv_state_variable_66 = 2;
  } else {

  }
#line 654
  goto ldv_53637;
  case 1: ;
#line 657
  if (ldv_state_variable_66 == 1) {
#line 659
    ldv_retval_16 = simple_open(rs_sta_dbgfs_rate_scale_data_ops_group1, rs_sta_dbgfs_rate_scale_data_ops_group2);
#line 660
    if (ldv_retval_16 == 0) {
#line 661
      ldv_state_variable_66 = 2;
#line 662
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 666
  goto ldv_53637;
  case 2: ;
#line 669
  if (ldv_state_variable_66 == 2) {
#line 671
    default_llseek(rs_sta_dbgfs_rate_scale_data_ops_group2, ldvarg168, ldvarg167);
#line 673
    ldv_state_variable_66 = 2;
  } else {

  }
#line 676
  goto ldv_53637;
  case 3: ;
#line 679
  if (ldv_state_variable_66 == 2) {
#line 681
    ldv_release_66();
#line 682
    ldv_state_variable_66 = 1;
#line 683
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 686
  goto ldv_53637;
  default: 
#line 687
  ldv_stop();
  }
  ldv_53637: ;
#line 691
  return;
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_main_exported_68(void) 
{ 
  loff_t ldvarg192 ;
  char *ldvarg198 ;
  void *tmp ;
  loff_t *ldvarg193 ;
  void *tmp___0 ;
  size_t ldvarg197 ;
  size_t ldvarg194 ;
  loff_t *ldvarg196 ;
  void *tmp___1 ;
  char *ldvarg195 ;
  void *tmp___2 ;
  int ldvarg191 ;
  int tmp___3 ;

  {
#line 695
  tmp = ldv_init_zalloc(1UL);
#line 695
  ldvarg198 = (char *)tmp;
#line 696
  tmp___0 = ldv_init_zalloc(8UL);
#line 696
  ldvarg193 = (loff_t *)tmp___0;
#line 699
  tmp___1 = ldv_init_zalloc(8UL);
#line 699
  ldvarg196 = (loff_t *)tmp___1;
#line 700
  tmp___2 = ldv_init_zalloc(1UL);
#line 700
  ldvarg195 = (char *)tmp___2;
#line 694
  ldv_memset((void *)(& ldvarg192), 0, 8UL);
#line 697
  ldv_memset((void *)(& ldvarg197), 0, 8UL);
#line 698
  ldv_memset((void *)(& ldvarg194), 0, 8UL);
#line 701
  ldv_memset((void *)(& ldvarg191), 0, 4UL);
#line 703
  tmp___3 = __VERIFIER_nondet_int();
#line 703
  switch (tmp___3) {
  case 0: ;
#line 706
  if (ldv_state_variable_68 == 1) {
#line 708
    rs_sta_dbgfs_scale_table_write(rs_sta_dbgfs_scale_table_ops_group2, (char const   *)ldvarg198,
                                   ldvarg197, ldvarg196);
#line 710
    ldv_state_variable_68 = 1;
  } else {

  }
#line 713
  if (ldv_state_variable_68 == 2) {
#line 715
    rs_sta_dbgfs_scale_table_write(rs_sta_dbgfs_scale_table_ops_group2, (char const   *)ldvarg198,
                                   ldvarg197, ldvarg196);
#line 717
    ldv_state_variable_68 = 2;
  } else {

  }
#line 720
  goto ldv_53654;
  case 1: ;
#line 723
  if (ldv_state_variable_68 == 2) {
#line 725
    rs_sta_dbgfs_scale_table_read(rs_sta_dbgfs_scale_table_ops_group2, ldvarg195,
                                  ldvarg194, ldvarg193);
#line 727
    ldv_state_variable_68 = 2;
  } else {

  }
#line 730
  goto ldv_53654;
  case 2: ;
#line 733
  if (ldv_state_variable_68 == 1) {
#line 735
    ldv_retval_20 = simple_open(rs_sta_dbgfs_scale_table_ops_group1, rs_sta_dbgfs_scale_table_ops_group2);
#line 736
    if (ldv_retval_20 == 0) {
#line 737
      ldv_state_variable_68 = 2;
#line 738
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 742
  goto ldv_53654;
  case 3: ;
#line 745
  if (ldv_state_variable_68 == 2) {
#line 747
    default_llseek(rs_sta_dbgfs_scale_table_ops_group2, ldvarg192, ldvarg191);
#line 749
    ldv_state_variable_68 = 2;
  } else {

  }
#line 752
  goto ldv_53654;
  case 4: ;
#line 755
  if (ldv_state_variable_68 == 2) {
#line 757
    ldv_release_68();
#line 758
    ldv_state_variable_68 = 1;
#line 759
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 762
  goto ldv_53654;
  default: 
#line 763
  ldv_stop();
  }
  ldv_53654: ;
#line 767
  return;
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_main_exported_65(void) 
{ 
  void *ldvarg75 ;
  void *tmp ;
  struct sk_buff *ldvarg82 ;
  void *tmp___0 ;
  void *ldvarg76 ;
  void *tmp___1 ;
  void *ldvarg74 ;
  void *tmp___2 ;
  void *ldvarg69 ;
  void *tmp___3 ;
  void *ldvarg68 ;
  void *tmp___4 ;
  gfp_t ldvarg78 ;
  void *ldvarg70 ;
  void *tmp___5 ;
  void *ldvarg73 ;
  void *tmp___6 ;
  void *ldvarg85 ;
  void *tmp___7 ;
  void *ldvarg81 ;
  void *tmp___8 ;
  void *ldvarg83 ;
  void *tmp___9 ;
  void *ldvarg79 ;
  void *tmp___10 ;
  struct ieee80211_tx_rate_control *ldvarg72 ;
  void *tmp___11 ;
  void *ldvarg71 ;
  void *tmp___12 ;
  void *ldvarg80 ;
  void *tmp___13 ;
  struct ieee80211_hw *ldvarg67 ;
  void *tmp___14 ;
  struct cfg80211_chan_def *ldvarg84 ;
  void *tmp___15 ;
  void *ldvarg77 ;
  void *tmp___16 ;
  int tmp___17 ;

  {
#line 770
  tmp = ldv_init_zalloc(1UL);
#line 770
  ldvarg75 = tmp;
#line 771
  tmp___0 = ldv_init_zalloc(232UL);
#line 771
  ldvarg82 = (struct sk_buff *)tmp___0;
#line 772
  tmp___1 = ldv_init_zalloc(1UL);
#line 772
  ldvarg76 = tmp___1;
#line 773
  tmp___2 = ldv_init_zalloc(1UL);
#line 773
  ldvarg74 = tmp___2;
#line 774
  tmp___3 = ldv_init_zalloc(1UL);
#line 774
  ldvarg69 = tmp___3;
#line 775
  tmp___4 = ldv_init_zalloc(1UL);
#line 775
  ldvarg68 = tmp___4;
#line 777
  tmp___5 = ldv_init_zalloc(1UL);
#line 777
  ldvarg70 = tmp___5;
#line 778
  tmp___6 = ldv_init_zalloc(1UL);
#line 778
  ldvarg73 = tmp___6;
#line 779
  tmp___7 = ldv_init_zalloc(1UL);
#line 779
  ldvarg85 = tmp___7;
#line 780
  tmp___8 = ldv_init_zalloc(1UL);
#line 780
  ldvarg81 = tmp___8;
#line 781
  tmp___9 = ldv_init_zalloc(1UL);
#line 781
  ldvarg83 = tmp___9;
#line 782
  tmp___10 = ldv_init_zalloc(1UL);
#line 782
  ldvarg79 = tmp___10;
#line 783
  tmp___11 = ldv_init_zalloc(64UL);
#line 783
  ldvarg72 = (struct ieee80211_tx_rate_control *)tmp___11;
#line 784
  tmp___12 = ldv_init_zalloc(1UL);
#line 784
  ldvarg71 = tmp___12;
#line 785
  tmp___13 = ldv_init_zalloc(1UL);
#line 785
  ldvarg80 = tmp___13;
#line 786
  tmp___14 = ldv_init_zalloc(160UL);
#line 786
  ldvarg67 = (struct ieee80211_hw *)tmp___14;
#line 787
  tmp___15 = ldv_init_zalloc(24UL);
#line 787
  ldvarg84 = (struct cfg80211_chan_def *)tmp___15;
#line 788
  tmp___16 = ldv_init_zalloc(1UL);
#line 788
  ldvarg77 = tmp___16;
#line 776
  ldv_memset((void *)(& ldvarg78), 0, 4UL);
#line 790
  tmp___17 = __VERIFIER_nondet_int();
#line 790
  switch (tmp___17) {
  case 0: ;
#line 793
  if (ldv_state_variable_65 == 1) {
#line 795
    rs_rate_init_stub(ldvarg83, rs_ops_group0, ldvarg84, rs_ops_group1, ldvarg85);
#line 797
    ldv_state_variable_65 = 1;
  } else {

  }
#line 800
  goto ldv_53683;
  case 1: ;
#line 803
  if (ldv_state_variable_65 == 1) {
#line 805
    rs_tx_status(ldvarg81, rs_ops_group0, rs_ops_group1, ldvarg80, ldvarg82);
#line 807
    ldv_state_variable_65 = 1;
  } else {

  }
#line 810
  goto ldv_53683;
  case 2: ;
#line 813
  if (ldv_state_variable_65 == 1) {
#line 815
    rs_free(ldvarg79);
#line 817
    ldv_state_variable_65 = 1;
  } else {

  }
#line 820
  goto ldv_53683;
  case 3: ;
#line 823
  if (ldv_state_variable_65 == 1) {
#line 825
    rs_alloc_sta(ldvarg77, rs_ops_group1, ldvarg78);
#line 827
    ldv_state_variable_65 = 1;
  } else {

  }
#line 830
  goto ldv_53683;
  case 4: ;
#line 833
  if (ldv_state_variable_65 == 1) {
#line 835
    rs_free_sta(ldvarg75, rs_ops_group1, ldvarg76);
#line 837
    ldv_state_variable_65 = 1;
  } else {

  }
#line 840
  goto ldv_53683;
  case 5: ;
#line 843
  if (ldv_state_variable_65 == 1) {
#line 845
    rs_get_rate(ldvarg73, rs_ops_group1, ldvarg74, ldvarg72);
#line 847
    ldv_state_variable_65 = 1;
  } else {

  }
#line 850
  goto ldv_53683;
  case 6: ;
#line 853
  if (ldv_state_variable_65 == 1) {
#line 855
    rs_add_debugfs(ldvarg70, ldvarg71, rs_ops_group2);
#line 857
    ldv_state_variable_65 = 1;
  } else {

  }
#line 860
  goto ldv_53683;
  case 7: ;
#line 863
  if (ldv_state_variable_65 == 1) {
#line 865
    rs_remove_debugfs(ldvarg68, ldvarg69);
#line 867
    ldv_state_variable_65 = 1;
  } else {

  }
#line 870
  goto ldv_53683;
  case 8: ;
#line 873
  if (ldv_state_variable_65 == 1) {
#line 875
    rs_alloc(ldvarg67, rs_ops_group2);
#line 877
    ldv_state_variable_65 = 1;
  } else {

  }
#line 880
  goto ldv_53683;
  default: 
#line 881
  ldv_stop();
  }
  ldv_53683: ;
#line 885
  return;
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 914
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 914
  ldv_func_res = tmp;
#line 916
  activate_work_7(ldv_func_arg3, 2);
#line 918
  return (ldv_func_res);
}
}
#line 921 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
bool ldv_queue_delayed_work_on_82(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 925
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 925
  ldv_func_res = tmp;
#line 927
  activate_work_7(& ldv_func_arg3->work, 2);
#line 929
  return (ldv_func_res);
}
}
#line 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
bool ldv_queue_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 936
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 936
  ldv_func_res = tmp;
#line 938
  activate_work_7(ldv_func_arg3, 2);
#line 940
  return (ldv_func_res);
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_flush_workqueue_84(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 946
  flush_workqueue(ldv_func_arg1);
#line 948
  call_and_disable_all_7(2);
#line 949
  return;
}
}
#line 951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
bool ldv_queue_delayed_work_on_85(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 955
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 955
  ldv_func_res = tmp;
#line 957
  activate_work_7(& ldv_func_arg3->work, 2);
#line 959
  return (ldv_func_res);
}
}
#line 962 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_mutex_lock_86(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 965
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 967
  mutex_lock(ldv_func_arg1);
#line 968
  return;
}
}
#line 970 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_mutex_unlock_87(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 973
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 975
  mutex_unlock(ldv_func_arg1);
#line 976
  return;
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_mutex_lock_88(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 981
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 983
  mutex_lock(ldv_func_arg1);
#line 984
  return;
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
int ldv_mutex_trylock_89(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 990
  tmp = mutex_trylock(ldv_func_arg1);
#line 990
  ldv_func_res = tmp;
#line 992
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 992
  return (tmp___0);
#line 994
  return (ldv_func_res);
}
}
#line 997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1000
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1002
  mutex_unlock(ldv_func_arg1);
#line 1003
  return;
}
}
#line 1005 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1008
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1010
  mutex_unlock(ldv_func_arg1);
#line 1011
  return;
}
}
#line 1013 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rs.o.c.prepared"
void ldv_mutex_lock_92(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1016
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1018
  mutex_lock(ldv_func_arg1);
#line 1019
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 137 "./arch/x86/include/asm/bitops.h"
__inline static void __clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 139
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 140
  return;
}
}
#line 14 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 180 "include/uapi/linux/swab.h"
__inline static __u64 __swab64p(__u64 const   *p ) 
{ 
  __u64 tmp ;

  {
#line 185
  tmp = __fswab64(*p);
#line 185
  return (tmp);
}
}
#line 71 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __swab64p(p);
#line 73
  return (tmp);
}
}
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags___0(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4801: ;
#line 831
    goto ldv_4801;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_117(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_115(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_127(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_129(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_131(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_135(struct mutex *ldv_func_arg1 ) ;
#line 221
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) ;
#line 225
void ldv_mutex_unlock_139(struct mutex *ldv_func_arg1 ) ;
#line 229
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) ;
#line 233
void ldv_mutex_unlock_143(struct mutex *ldv_func_arg1 ) ;
#line 237
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) ;
#line 241
void ldv_mutex_unlock_147(struct mutex *ldv_func_arg1 ) ;
#line 245
void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) ;
#line 249
void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) ;
#line 253
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_114(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_116(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_120(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_121(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_123(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_126(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_128(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_130(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_132(struct mutex *ldv_func_arg1 ) ;
#line 57
void ldv_mutex_lock_134(struct mutex *ldv_func_arg1 ) ;
#line 61
void ldv_mutex_lock_136(struct mutex *ldv_func_arg1 ) ;
#line 65
void ldv_mutex_lock_138(struct mutex *ldv_func_arg1 ) ;
#line 69
void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) ;
#line 73
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) ;
#line 77
void ldv_mutex_lock_144(struct mutex *ldv_func_arg1 ) ;
#line 81
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) ;
#line 85
void ldv_mutex_lock_148(struct mutex *ldv_func_arg1 ) ;
#line 89
void ldv_mutex_lock_150(struct mutex *ldv_func_arg1 ) ;
#line 93
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count___0(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6628;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6628;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6628;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6628;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6628: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add___0(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6685;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6685;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6685;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6685;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6685: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub___0(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6697;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6697;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6697;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6697;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6697: ;
#line 79
  return;
}
}
#line 498 "include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held___0(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 500
  lockdep_opinion = 0;
#line 502
  tmp = debug_lockdep_rcu_enabled();
#line 502
  if (tmp == 0) {
#line 503
    return (1);
  } else {

  }
#line 504
  tmp___0 = rcu_is_watching();
#line 504
  if (tmp___0) {
#line 504
    tmp___1 = 0;
  } else {
#line 504
    tmp___1 = 1;
  }
#line 504
  if (tmp___1) {
#line 505
    return (0);
  } else {

  }
#line 506
  tmp___2 = rcu_lockdep_current_cpu_online();
#line 506
  if (tmp___2) {
#line 506
    tmp___3 = 0;
  } else {
#line 506
    tmp___3 = 1;
  }
#line 506
  if (tmp___3) {
#line 507
    return (0);
  } else {

  }
#line 508
  if (debug_locks != 0) {
#line 509
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
#line 510
  if (lockdep_opinion != 0) {
#line 510
    tmp___6 = 1;
  } else {
#line 510
    tmp___4 = preempt_count___0();
#line 510
    if (tmp___4 != 0) {
#line 510
      tmp___6 = 1;
    } else {
#line 510
      _flags = arch_local_save_flags___0();
#line 510
      tmp___5 = arch_irqs_disabled_flags(_flags);
#line 510
      if (tmp___5 != 0) {
#line 510
        tmp___6 = 1;
      } else {
#line 510
        tmp___6 = 0;
      }
    }
  }
#line 510
  return (tmp___6);
}
}
#line 969 "include/linux/rcupdate.h"
__inline static void rcu_read_lock_sched_notrace___0(void) 
{ 


  {
#line 971
  __preempt_count_add___0(1);
#line 971
  __asm__  volatile   ("": : : "memory");
#line 973
  return;
}
}
#line 990 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock_sched_notrace___0(void) 
{ 


  {
#line 993
  __asm__  volatile   ("": : : "memory");
#line 993
  __preempt_count_sub___0(1);
#line 994
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_109(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_111(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_110(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_113(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_112(struct workqueue_struct *ldv_func_arg1 ) ;
#line 459
void ldv_flush_workqueue_125(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___1(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_109(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_initialize_ieee80211_ops_64(void) ;
#line 81 "include/linux/pm_wakeup.h"
__inline static bool device_can_wakeup(struct device *dev ) 
{ 


  {
#line 83
  return ((int )dev->power.can_wakeup != 0);
}
}
#line 104
extern int device_set_wakeup_enable(struct device * , bool  ) ;
#line 411 "include/net/cfg80211.h"
__inline static enum nl80211_channel_type cfg80211_get_chandef_type(struct cfg80211_chan_def  const  *chandef ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 413
  switch ((unsigned int )chandef->width) {
  case 0U: ;
#line 415
  return (0);
  case 1U: ;
#line 417
  return (1);
  case 2U: ;
#line 419
  if ((unsigned int )chandef->center_freq1 > (unsigned int )(chandef->chan)->center_freq) {
#line 420
    return (3);
  } else {

  }
#line 421
  return (2);
  default: 
#line 423
  __ret_warn_on = 1;
#line 423
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 423
  if (tmp != 0L) {
#line 423
    warn_slowpath_null("include/net/cfg80211.h", 423);
  } else {

  }
#line 423
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 424
  return (0);
  }
}
}
#line 2065 "include/net/mac80211.h"
__inline static void _ieee80211_hw_set(struct ieee80211_hw *hw , enum ieee80211_hw_flags flg ) 
{ 


  {
#line 2068
  return;
}
}
#line 3481
extern struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t  , struct ieee80211_ops  const  * ,
                                                  char const   * ) ;
#line 3500 "include/net/mac80211.h"
__inline static struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len , struct ieee80211_ops  const  *ops ) 
{ 
  struct ieee80211_hw *tmp ;

  {
#line 3503
  tmp = ieee80211_alloc_hw_nm(priv_data_len, ops, (char const   *)0);
#line 3503
  return (tmp);
}
}
#line 3520
__inline static struct ieee80211_hw *ldv_ieee80211_alloc_hw_154(size_t priv_data_len ,
                                                                struct ieee80211_ops  const  *ops ) ;
#line 3521
extern int ieee80211_register_hw(struct ieee80211_hw * ) ;
#line 3671
extern void ieee80211_unregister_hw(struct ieee80211_hw * ) ;
#line 4805
extern void ieee80211_sta_block_awake(struct ieee80211_hw * , struct ieee80211_sta * ,
                                      bool  ) ;
#line 4947
extern void ieee80211_resume_disconnect(struct ieee80211_vif * ) ;
#line 4988
extern void ieee80211_chswitch_done(struct ieee80211_vif * , bool  ) ;
#line 5261 "include/net/mac80211.h"
__inline static enum nl80211_iftype ieee80211_iftype_p2p(enum nl80211_iftype type ,
                                                         bool p2p ) 
{ 


  {
#line 5263
  if ((int )p2p) {
#line 5264
    switch ((unsigned int )type) {
    case 2U: ;
#line 5266
    return (8);
    case 3U: ;
#line 5268
    return (9);
    default: ;
#line 5270
    goto ldv_50203;
    }
    ldv_50203: ;
  } else {

  }
#line 5273
  return (type);
}
}
#line 5277 "include/net/mac80211.h"
__inline static enum nl80211_iftype ieee80211_vif_type_p2p(struct ieee80211_vif *vif ) 
{ 
  enum nl80211_iftype tmp ;

  {
#line 5279
  tmp = ieee80211_iftype_p2p(vif->type, (int )vif->p2p);
#line 5279
  return (tmp);
}
}
#line 5308
extern void ieee80211_report_wowlan_wakeup(struct ieee80211_vif * , struct cfg80211_wowlan_wakeup * ,
                                           gfp_t  ) ;
#line 181 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static u32 iwl_rx_packet_len(struct iwl_rx_packet  const  *pkt ) 
{ 


  {
#line 183
  return ((u32 )pkt->len_n_flags & 16383U);
}
}
#line 186 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static u32 iwl_rx_packet_payload_len(struct iwl_rx_packet  const  *pkt ) 
{ 
  u32 tmp ;

  {
#line 188
  tmp = iwl_rx_packet_len(pkt);
#line 188
  return (tmp - 4U);
}
}
#line 730 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_d3_suspend(struct iwl_trans *trans , bool test ) 
{ 


  {
#line 732
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 732, 0);
#line 733
  (*((trans->ops)->d3_suspend))(trans, (int )test);
#line 734
  return;
}
}
#line 736 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static int iwl_trans_d3_resume(struct iwl_trans *trans , enum iwl_d3_status *status ,
                                        bool test ) 
{ 
  int tmp ;

  {
#line 740
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 740, 0);
#line 741
  tmp = (*((trans->ops)->d3_resume))(trans, status, (int )test);
#line 741
  return (tmp);
}
}
#line 906 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static int iwl_trans_wait_tx_queue_empty(struct iwl_trans *trans , u32 txqs ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 909
  tmp = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
#line 909
  if (tmp != 0L) {
#line 910
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_wait_tx_queue_empty",
              (unsigned int )trans->state);
  } else {

  }
#line 912
  tmp___0 = (*((trans->ops)->wait_tx_queue_empty))(trans, txqs);
#line 912
  return (tmp___0);
}
}
#line 84 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32___0(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_398___0 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_400___0 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 69
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite32.key);
#line 69
  if ((int )tmp___1) {
#line 69
    rcu_read_lock_sched_notrace___0();
#line 69
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
#line 69
    _________p1 = __u.__val;
#line 69
    ________p1 = _________p1;
#line 69
    tmp = debug_lockdep_rcu_enabled();
#line 69
    if (tmp != 0 && ! __warned) {
#line 69
      tmp___0 = rcu_read_lock_sched_held___0();
#line 69
      if (tmp___0 == 0) {
#line 69
        __warned = 1;
#line 69
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 69
    it_func_ptr = ________p1;
#line 69
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51684: 
#line 69
      it_func = it_func_ptr->func;
#line 69
      __data = it_func_ptr->data;
#line 69
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 69
      it_func_ptr = it_func_ptr + 1;
#line 69
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 71
        goto ldv_51684;
      } else {

      }

    } else {

    }
#line 69
    rcu_read_unlock_sched_notrace___0();
  } else {

  }
#line 69
  rcu_read_lock_sched_notrace___0();
#line 69
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 69
  _________p1___0 = __u___0.__val;
#line 69
  ________p1___0 = _________p1___0;
#line 69
  tmp___2 = debug_lockdep_rcu_enabled();
#line 69
  if (tmp___2 != 0 && ! __warned___0) {
#line 69
    tmp___3 = rcu_read_lock_sched_held___0();
#line 69
    if (tmp___3 == 0) {
#line 69
      __warned___0 = 1;
#line 69
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 69
  rcu_read_unlock_sched_notrace___0();
#line 71
  return;
}
}
#line 41 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static void iwl_write32___0(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
#line 43
  trace_iwlwifi_dev_iowrite32___0((struct device  const  *)trans->dev, ofs, val);
#line 44
  iwl_trans_write32(trans, ofs, val);
#line 45
  return;
}
}
#line 122 "drivers/net/wireless/iwlwifi/dvm/../iwl-notif-wait.h"
extern void iwl_init_notification_wait(struct iwl_notif_wait_data * , struct iwl_notification_wait * ,
                                       u8 const   * , int  , bool (*)(struct iwl_notif_wait_data * ,
                                                                      struct iwl_rx_packet * ,
                                                                      void * ) , void * ) ;
#line 130
extern int iwl_wait_notification(struct iwl_notif_wait_data * , struct iwl_notification_wait * ,
                                 unsigned long  ) ;
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/led.h"
void iwlagn_led_enable(struct iwl_priv *priv ) ;
#line 41
void iwl_leds_init(struct iwl_priv *priv ) ;
#line 42
void iwl_leds_exit(struct iwl_priv *priv ) ;
#line 916 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
__inline static struct iwl_rxon_context *iwl_rxon_ctx_from_vif(struct ieee80211_vif *vif ) 
{ 
  struct iwl_vif_priv *vif_priv ;

  {
#line 918
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
#line 920
  return (vif_priv->ctx);
}
}
#line 112 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
struct ieee80211_ops  const  iwlagn_hw_ops ;
#line 150
int iwlagn_mac_config(struct ieee80211_hw *hw , u32 changed ) ;
#line 151
void iwlagn_bss_info_changed(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                             struct ieee80211_bss_conf *bss_conf , u32 changes ) ;
#line 157
void iwl_set_rxon_ht(struct iwl_priv *priv , struct iwl_ht_config *ht_conf ) ;
#line 158
void iwl_set_rxon_channel(struct iwl_priv *priv , struct ieee80211_channel *ch , struct iwl_rxon_context *ctx ) ;
#line 160
void iwl_set_flags_for_band(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            enum ieee80211_band band , struct ieee80211_vif *vif ) ;
#line 169
int iwl_run_init_ucode(struct iwl_priv *priv ) ;
#line 170
int iwl_load_ucode_wait_alive(struct iwl_priv *priv , enum iwl_ucode_type ucode_type ) ;
#line 183
int iwlagn_txfifo_flush(struct iwl_priv *priv , u32 scd_q_msk ) ;
#line 198
int iwlagn_suspend(struct iwl_priv *priv , struct cfg80211_wowlan *wowlan ) ;
#line 204
void iwl_chswitch_done(struct iwl_priv *priv , bool is_success ) ;
#line 208
int iwlagn_tx_skb(struct iwl_priv *priv , struct ieee80211_sta *sta , struct sk_buff *skb ) ;
#line 211
int iwlagn_tx_agg_start(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                        u16 tid , u16 *ssn ) ;
#line 213
int iwlagn_tx_agg_oper(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                       u16 tid , u8 buf_size ) ;
#line 215
int iwlagn_tx_agg_stop(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                       u16 tid ) ;
#line 217
int iwlagn_tx_agg_flush(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                        u16 tid ) ;
#line 256
void iwl_force_scan_end(struct iwl_priv *priv ) ;
#line 261
int iwl_scan_initiate(struct iwl_priv *priv , struct ieee80211_vif *vif , enum iwl_scan_type scan_type ,
                      enum ieee80211_band band ) ;
#line 321
int iwl_send_add_sta(struct iwl_priv *priv , struct iwl_addsta_cmd *sta , u8 flags ) ;
#line 323
int iwl_add_station_common(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                           u8 const   *addr , bool is_ap , struct ieee80211_sta *sta ,
                           u8 *sta_id_r ) ;
#line 326
int iwl_remove_station(struct iwl_priv *priv , u8 const   sta_id , u8 const   *addr ) ;
#line 328
void iwl_deactivate_station(struct iwl_priv *priv , u8 const   sta_id , u8 const   *addr ) ;
#line 337
int iwl_sta_update_ht(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct ieee80211_sta *sta ) ;
#line 344 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static int iwl_sta_id(struct ieee80211_sta *sta ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
#line 346
  __ret_warn_on = (unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0);
#line 346
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 346
  if (tmp != 0L) {
#line 346
    warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h",
                       346);
  } else {

  }
#line 346
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 346
  if (tmp___0 != 0L) {
#line 347
    return (255);
  } else {

  }
#line 349
  return ((int )((struct iwl_station_priv *)(& sta->drv_priv))->sta_id);
}
}
#line 352
int iwlagn_alloc_bcast_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
#line 356
int iwl_remove_default_wep_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                               struct ieee80211_key_conf *keyconf ) ;
#line 359
int iwl_set_default_wep_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct ieee80211_key_conf *keyconf ) ;
#line 364
int iwl_set_dynamic_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct ieee80211_key_conf *keyconf ,
                        struct ieee80211_sta *sta ) ;
#line 367
int iwl_remove_dynamic_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                           struct ieee80211_key_conf *keyconf , struct ieee80211_sta *sta ) ;
#line 370
void iwl_update_tkip_key(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_key_conf *keyconf ,
                         struct ieee80211_sta *sta , u32 iv32 , u16 *phase1key ) ;
#line 375
int iwl_sta_rx_agg_start(struct iwl_priv *priv , struct ieee80211_sta *sta , int tid ,
                         u16 ssn ) ;
#line 377
int iwl_sta_rx_agg_stop(struct iwl_priv *priv , struct ieee80211_sta *sta , int tid ) ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static struct ieee80211_iface_limit  const  iwlagn_sta_ap_limits[2U]  = {      {1U, 4U}, 
        {1U, 8U}};
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static struct ieee80211_iface_limit  const  iwlagn_2sta_limits[1U]  = {      {2U, 4U}};
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static struct ieee80211_iface_combination  const  iwlagn_iface_combinations_dualmode[2U]  = {      {(struct ieee80211_iface_limit  const  *)(& iwlagn_sta_ap_limits),
      1U, 2U, 2U, 1, (unsigned char)0, (unsigned char)0}, 
        {(struct ieee80211_iface_limit  const  *)(& iwlagn_2sta_limits), 1U, 2U, 1U,
      (_Bool)0, (unsigned char)0, (unsigned char)0}};
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
int iwlagn_mac_setup_register(struct iwl_priv *priv , struct iwl_ucode_capabilities  const  *capa ) 
{ 
  int ret ;
  struct ieee80211_hw *hw ;
  struct iwl_rxon_context *ctx ;
  bool tmp ;

  {
#line 101
  hw = priv->hw;
#line 104
  hw->rate_control_algorithm = "iwl-agn-rs";
#line 107
  _ieee80211_hw_set(hw, 4);
#line 108
  _ieee80211_hw_set(hw, 7);
#line 109
  _ieee80211_hw_set(hw, 5);
#line 110
  _ieee80211_hw_set(hw, 6);
#line 111
  _ieee80211_hw_set(hw, 16);
#line 112
  _ieee80211_hw_set(hw, 18);
#line 113
  _ieee80211_hw_set(hw, 8);
#line 114
  _ieee80211_hw_set(hw, 10);
#line 115
  _ieee80211_hw_set(hw, 15);
#line 116
  _ieee80211_hw_set(hw, 12);
#line 118
  hw->offchannel_tx_hw_queue = 10U;
#line 119
  hw->radiotap_mcs_details = (u8 )((unsigned int )hw->radiotap_mcs_details | 8U);
#line 128
  if ((int )(priv->nvm_data)->sku_cap_11n_enable) {
#line 129
    (hw->wiphy)->features = (hw->wiphy)->features | 50331648U;
  } else {

  }
#line 137
  if (((unsigned int )(priv->fw)->ucode_capa.flags & 4U) != 0U && iwlwifi_mod_params.sw_crypto == 0) {
#line 139
    _ieee80211_hw_set(hw, 11);
  } else {

  }
#line 141
  hw->sta_data_size = 1904;
#line 142
  hw->vif_data_size = 16;
#line 144
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 144
  goto ldv_55486;
  ldv_55485: ;
#line 144
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 145
    (hw->wiphy)->interface_modes = (int )(hw->wiphy)->interface_modes | (int )((u16 )ctx->interface_modes);
#line 146
    (hw->wiphy)->interface_modes = (int )(hw->wiphy)->interface_modes | (int )((u16 )ctx->exclusive_interface_modes);
  } else {

  }
#line 144
  ctx = ctx + 1;
  ldv_55486: ;
#line 144
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 146
    goto ldv_55485;
  } else {

  }

#line 151
  if (((unsigned long )(hw->wiphy)->interface_modes & 8UL) != 0UL) {
#line 152
    (hw->wiphy)->iface_combinations = (struct ieee80211_iface_combination  const  *)(& iwlagn_iface_combinations_dualmode);
#line 154
    (hw->wiphy)->n_iface_combinations = 2;
  } else {

  }
#line 158
  (hw->wiphy)->flags = (hw->wiphy)->flags | 256U;
#line 159
  (hw->wiphy)->regulatory_flags = (hw->wiphy)->regulatory_flags | 5U;
#line 163
  if (((unsigned int )(priv->fw)->img[2].sec[0].len != 0U && (unsigned long )((priv->trans)->ops)->d3_suspend != (unsigned long )((void (*/* const  */)(struct iwl_trans * ,
                                                                                                                                                        bool  ))0)) && (unsigned long )((priv->trans)->ops)->d3_resume != (unsigned long )((int (*/* const  */)(struct iwl_trans * ,
                                                                                                                                                                                                                                                                enum iwl_d3_status * ,
                                                                                                                                                                                                                                                                bool  ))0)) {
#line 163
    tmp = device_can_wakeup((priv->trans)->dev);
#line 163
    if ((int )tmp) {
#line 167
      priv->wowlan_support.flags = 166U;
#line 171
      if (iwlwifi_mod_params.sw_crypto == 0) {
#line 172
        priv->wowlan_support.flags = priv->wowlan_support.flags | 24U;
      } else {

      }
#line 176
      priv->wowlan_support.n_patterns = 20;
#line 177
      priv->wowlan_support.pattern_min_len = 16;
#line 179
      priv->wowlan_support.pattern_max_len = 128;
#line 181
      (hw->wiphy)->wowlan = (struct wiphy_wowlan_support  const  *)(& priv->wowlan_support);
    } else {

    }
  } else {

  }
#line 185
  if ((int )iwlwifi_mod_params.power_save) {
#line 186
    (hw->wiphy)->flags = (hw->wiphy)->flags | 16U;
  } else {
#line 188
    (hw->wiphy)->flags = (hw->wiphy)->flags & 4294967279U;
  }
#line 190
  (hw->wiphy)->max_scan_ssids = 20U;
#line 192
  (hw->wiphy)->max_scan_ie_len = (unsigned int )((u16 )capa->max_probe_length) - 58U;
#line 198
  hw->queues = 11U;
#line 200
  hw->max_listen_interval = 10U;
#line 202
  if ((priv->nvm_data)->bands[0].n_channels != 0) {
#line 203
    ((priv->hw)->wiphy)->bands[0] = (struct ieee80211_supported_band *)(& (priv->nvm_data)->bands);
  } else {

  }
#line 205
  if ((priv->nvm_data)->bands[1].n_channels != 0) {
#line 206
    ((priv->hw)->wiphy)->bands[1] = (struct ieee80211_supported_band *)(& (priv->nvm_data)->bands) + 1UL;
  } else {

  }
#line 209
  (hw->wiphy)->hw_version = (priv->trans)->hw_id;
#line 211
  iwl_leds_init(priv);
#line 213
  ret = ieee80211_register_hw(priv->hw);
#line 214
  if (ret != 0) {
#line 215
    __iwl_err(priv->dev, 0, 0, "Failed to register hw (error %d)\n", ret);
#line 216
    iwl_leds_exit(priv);
#line 217
    return (ret);
  } else {

  }
#line 219
  priv->mac80211_registered = 1U;
#line 221
  return (0);
}
}
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
void iwlagn_mac_unregister(struct iwl_priv *priv ) 
{ 


  {
#line 226
  if ((unsigned int )priv->mac80211_registered == 0U) {
#line 227
    return;
  } else {

  }
#line 228
  iwl_leds_exit(priv);
#line 229
  ieee80211_unregister_hw(priv->hw);
#line 230
  priv->mac80211_registered = 0U;
#line 231
  return;
}
}
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int __iwl_up(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 238
  if (debug_locks != 0) {
#line 238
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 238
    if (tmp == 0) {
#line 238
      tmp___0 = 1;
    } else {
#line 238
      tmp___0 = 0;
    }
  } else {
#line 238
    tmp___0 = 0;
  }
#line 238
  __ret_warn_on = tmp___0;
#line 238
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 238
  if (tmp___1 != 0L) {
#line 238
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       238);
  } else {

  }
#line 238
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 240
  tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 240
  if (tmp___2 != 0) {
#line 241
    __iwl_warn(priv->dev, "Exit pending; will not bring the NIC up\n");
#line 242
    return (-5);
  } else {

  }
#line 245
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 245
  goto ldv_55501;
  ldv_55500: ;
#line 245
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 246
    ret = iwlagn_alloc_bcast_station(priv, ctx);
#line 247
    if (ret != 0) {
#line 248
      iwl_dealloc_bcast_stations(priv);
#line 249
      return (ret);
    } else {

    }
  } else {

  }
#line 245
  ctx = ctx + 1;
  ldv_55501: ;
#line 245
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 247
    goto ldv_55500;
  } else {

  }
#line 253
  ret = iwl_run_init_ucode(priv);
#line 254
  if (ret != 0) {
#line 255
    __iwl_err(priv->dev, 0, 0, "Failed to run INIT ucode: %d\n", ret);
#line 256
    goto error;
  } else {

  }
#line 259
  ret = iwl_load_ucode_wait_alive(priv, 0);
#line 260
  if (ret != 0) {
#line 261
    __iwl_err(priv->dev, 0, 0, "Failed to start RT ucode: %d\n", ret);
#line 262
    goto error;
  } else {

  }
#line 265
  ret = iwl_alive_start(priv);
#line 266
  if (ret != 0) {
#line 267
    goto error;
  } else {

  }
#line 268
  return (0);
  error: 
#line 271
  set_bit(5L, (unsigned long volatile   *)(& priv->status));
#line 272
  iwl_down(priv);
#line 273
  clear_bit(5L, (unsigned long volatile   *)(& priv->status));
#line 275
  __iwl_err(priv->dev, 0, 0, "Unable to initialize device.\n");
#line 276
  return (ret);
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_start(struct ieee80211_hw *hw ) 
{ 
  struct iwl_priv *priv ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 281
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 284
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_start", "enter\n");
#line 287
  ldv_mutex_lock_121(& priv->mutex);
#line 288
  ret = __iwl_up(priv);
#line 289
  ldv_mutex_unlock_122(& priv->mutex);
#line 290
  if (ret != 0) {
#line 291
    return (ret);
  } else {

  }
#line 293
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_start", "Start UP work done.\n");
#line 296
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
#line 296
  __ret_warn_on = tmp == 0;
#line 296
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 296
  if (tmp___0 != 0L) {
#line 296
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       296);
  } else {

  }
#line 296
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 296
  if (tmp___1 != 0L) {
#line 297
    ret = -5;
  } else {

  }
#line 299
  iwlagn_led_enable(priv);
#line 301
  priv->is_open = 1U;
#line 302
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_start", "leave\n");
#line 303
  return (0);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_stop(struct ieee80211_hw *hw ) 
{ 
  struct iwl_priv *priv ;

  {
#line 308
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 310
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_stop", "enter\n");
#line 312
  if ((unsigned int )priv->is_open == 0U) {
#line 313
    return;
  } else {

  }
#line 315
  priv->is_open = 0U;
#line 317
  ldv_mutex_lock_123(& priv->mutex);
#line 318
  iwl_down(priv);
#line 319
  ldv_mutex_unlock_124(& priv->mutex);
#line 321
  iwl_cancel_deferred_work(priv);
#line 323
  ldv_flush_workqueue_125(priv->workqueue);
#line 325
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_stop", "leave\n");
#line 326
  return;
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_set_rekey_data(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                      struct cfg80211_gtk_rekey_data *data ) 
{ 
  struct iwl_priv *priv ;

  {
#line 332
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 334
  if (iwlwifi_mod_params.sw_crypto != 0) {
#line 335
    return;
  } else {

  }
#line 337
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_rekey_data", "enter\n");
#line 338
  ldv_mutex_lock_126(& priv->mutex);
#line 340
  if ((unsigned long )priv->contexts[0].vif != (unsigned long )vif) {
#line 341
    goto out;
  } else {

  }
#line 343
  memcpy((void *)(& priv->kek), (void const   *)data->kek, 16UL);
#line 344
  memcpy((void *)(& priv->kck), (void const   *)data->kck, 16UL);
#line 345
  priv->replay_ctr = __be64_to_cpup((__be64 const   *)(& data->replay_ctr));
#line 347
  priv->have_rekey_data = 1;
  out: 
#line 350
  ldv_mutex_unlock_127(& priv->mutex);
#line 351
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_rekey_data", "leave\n");
#line 352
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_suspend(struct ieee80211_hw *hw , struct cfg80211_wowlan *wowlan ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 359
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 360
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 363
  __ret_warn_on = (unsigned long )wowlan == (unsigned long )((struct cfg80211_wowlan *)0);
#line 363
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 363
  if (tmp != 0L) {
#line 363
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       363);
  } else {

  }
#line 363
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 363
  if (tmp___0 != 0L) {
#line 364
    return (-22);
  } else {

  }
#line 366
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_suspend", "enter\n");
#line 367
  ldv_mutex_lock_128(& priv->mutex);
#line 370
  if ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0) || (unsigned int )(ctx->vif)->type != 2U) {
#line 372
    ret = 1;
#line 373
    goto out;
  } else {
#line 370
    tmp___1 = iwl_is_associated_ctx(ctx);
#line 370
    if (tmp___1 == 0) {
#line 372
      ret = 1;
#line 373
      goto out;
    } else {

    }
  }
#line 376
  ret = iwlagn_suspend(priv, wowlan);
#line 377
  if (ret != 0) {
#line 378
    goto error;
  } else {

  }
#line 381
  iwl_write32___0(priv->trans, 88U, 32U);
#line 384
  iwl_trans_d3_suspend(priv->trans, 0);
#line 386
  goto out;
  error: 
#line 389
  priv->wowlan = 0;
#line 390
  iwlagn_prepare_restart(priv);
#line 391
  ieee80211_restart_hw(priv->hw);
  out: 
#line 393
  ldv_mutex_unlock_129(& priv->mutex);
#line 394
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_suspend", "leave\n");
#line 396
  return (ret);
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static bool iwl_resume_status_fn(struct iwl_notif_wait_data *notif_wait , struct iwl_rx_packet *pkt ,
                                 void *data ) 
{ 
  struct iwl_resume_data *resume_data ;
  struct iwl_priv *priv ;
  u32 tmp ;

  {
#line 408
  resume_data = (struct iwl_resume_data *)data;
#line 409
  priv = resume_data->priv;
#line 411
  tmp = iwl_rx_packet_payload_len((struct iwl_rx_packet  const  *)pkt);
#line 411
  if (tmp != 304U) {
#line 412
    __iwl_err(priv->dev, 0, 0, "rx wrong size data\n");
#line 413
    return (1);
  } else {

  }
#line 415
  memcpy((void *)resume_data->cmd, (void const   *)(& pkt->data), 304UL);
#line 416
  resume_data->valid = 1;
#line 418
  return (1);
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_resume(struct ieee80211_hw *hw ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct ieee80211_vif *vif ;
  u32 base ;
  int ret ;
  enum iwl_d3_status d3_status ;
  struct error_table_start err_info ;
  struct iwl_notification_wait status_wait ;
  u8 status_cmd[1U] ;
  struct iwlagn_wowlan_status status_data ;
  struct iwl_resume_data resume_data ;
  struct cfg80211_wowlan_wakeup wakeup ;
  struct fw_img  const  *img ;
  int tmp ;
  u32 reasons ;
  struct cfg80211_wowlan_wakeup *wakeup_report ;

  {
#line 423
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 424
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 435
  status_cmd[0] = 229U;
#line 438
  status_data.replay_ctr = 0ULL;
#line 438
  status_data.rekey_status = 0U;
#line 438
  status_data.wakeup_reason = 0U;
#line 438
  status_data.pattern_number = (unsigned char)0;
#line 438
  status_data.reserved1 = (unsigned char)0;
#line 438
  status_data.qos_seq_ctr[0] = (unsigned short)0;
#line 438
  status_data.qos_seq_ctr[1] = (unsigned short)0;
#line 438
  status_data.qos_seq_ctr[2] = (unsigned short)0;
#line 438
  status_data.qos_seq_ctr[3] = (unsigned short)0;
#line 438
  status_data.qos_seq_ctr[4] = (unsigned short)0;
#line 438
  status_data.qos_seq_ctr[5] = (unsigned short)0;
#line 438
  status_data.qos_seq_ctr[6] = (unsigned short)0;
#line 438
  status_data.qos_seq_ctr[7] = (unsigned short)0;
#line 438
  status_data.non_qos_seq_ctr = (unsigned short)0;
#line 438
  status_data.reserved2 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[0].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[0].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[0].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[1].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[1].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[1].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[2].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[2].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[2].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[3].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[3].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[3].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[4].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[4].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[4].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[5].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[5].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[5].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[6].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[6].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[6].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[7].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[7].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[7].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[8].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[8].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[8].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[9].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[9].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[9].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[10].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[10].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[10].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[11].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[11].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[11].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[12].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[12].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[12].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[13].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[13].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[13].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[14].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[14].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[14].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[15].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[15].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.unicast_rsc[15].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[0].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[0].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[0].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[1].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[1].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[1].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[2].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[2].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[2].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[3].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[3].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[3].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[4].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[4].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[4].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[5].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[5].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[5].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[6].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[6].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[6].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[7].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[7].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[7].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[8].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[8].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[8].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[9].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[9].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[9].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[10].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[10].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[10].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[11].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[11].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[11].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[12].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[12].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[12].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[13].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[13].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[13].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[14].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[14].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[14].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[15].iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[15].pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.multicast_rsc[15].iv32 = 0U;
#line 438
  status_data.tsc_rsc.tkip.tsc.iv16 = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.tsc.pad = (unsigned short)0;
#line 438
  status_data.tsc_rsc.tkip.tsc.iv32 = 0U;
#line 438
  status_data.reserved3 = (unsigned short)0;
#line 439
  resume_data.priv = priv;
#line 439
  resume_data.cmd = & status_data;
#line 439
  resume_data.valid = 0;
#line 444
  wakeup.disconnect = (_Bool)0;
#line 444
  wakeup.magic_pkt = (_Bool)0;
#line 444
  wakeup.gtk_rekey_failure = (_Bool)0;
#line 444
  wakeup.eap_identity_req = (_Bool)0;
#line 444
  wakeup.four_way_handshake = (_Bool)0;
#line 444
  wakeup.rfkill_release = (_Bool)0;
#line 444
  wakeup.packet_80211 = (_Bool)0;
#line 444
  wakeup.tcp_match = (_Bool)0;
#line 444
  wakeup.tcp_connlost = (_Bool)0;
#line 444
  wakeup.tcp_nomoretokens = (_Bool)0;
#line 444
  wakeup.pattern_idx = -1;
#line 444
  wakeup.packet_present_len = 0U;
#line 444
  wakeup.packet_len = 0U;
#line 444
  wakeup.packet = 0;
#line 444
  wakeup.net_detect = 0;
#line 451
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_resume", "enter\n");
#line 452
  ldv_mutex_lock_130(& priv->mutex);
#line 455
  vif = ctx->vif;
#line 457
  ret = iwl_trans_d3_resume(priv->trans, & d3_status, 0);
#line 458
  if (ret != 0) {
#line 459
    goto out_unlock;
  } else {

  }
#line 461
  if ((unsigned int )d3_status != 0U) {
#line 462
    __iwl_info(priv->dev, "Device was reset during suspend\n");
#line 463
    goto out_unlock;
  } else {

  }
#line 467
  iwl_write32___0(priv->trans, 92U, 32U);
#line 470
  base = priv->device_pointers.error_event_table;
#line 471
  tmp = iwlagn_hw_valid_rtc_data_addr(base);
#line 471
  if (tmp == 0) {
#line 472
    __iwl_warn(priv->dev, "Invalid error table during resume!\n");
#line 473
    goto out_unlock;
  } else {

  }
#line 476
  iwl_trans_read_mem(priv->trans, base, (void *)(& err_info), 2);
#line 479
  if (err_info.valid != 0U) {
#line 480
    __iwl_info(priv->dev, "error table is valid (%d, 0x%x)\n", err_info.valid, err_info.error_id);
#line 482
    if (err_info.error_id == 135U) {
#line 483
      wakeup.rfkill_release = 1;
#line 484
      ieee80211_report_wowlan_wakeup(vif, & wakeup, 208U);
    } else {

    }
#line 487
    goto out_unlock;
  } else {

  }
#line 491
  img = (struct fw_img  const  *)(& (priv->fw)->img) + 2UL;
#line 492
  if ((unsigned long )priv->wowlan_sram == (unsigned long )((void *)0)) {
#line 493
    priv->wowlan_sram = kzalloc((size_t )img->sec[0].len, 208U);
  } else {

  }
#line 497
  if ((unsigned long )priv->wowlan_sram != (unsigned long )((void *)0)) {
#line 498
    iwl_trans_read_mem(priv->trans, 8388608U, priv->wowlan_sram, (int )((unsigned int )img->sec[0].len / 4U));
  } else {

  }
#line 511
  iwl_init_notification_wait(& priv->notif_wait, & status_wait, (u8 const   *)(& status_cmd),
                             1, & iwl_resume_status_fn, (void *)(& resume_data));
#line 515
  iwl_dvm_send_cmd_pdu(priv, 229, 1U, 0, (void const   *)0);
#line 516
  iwl_dvm_send_cmd_pdu(priv, 3, 1U, 0, (void const   *)0);
#line 519
  ret = iwl_wait_notification(& priv->notif_wait, & status_wait, 50UL);
#line 520
  if (ret != 0) {
#line 521
    goto out_unlock;
  } else {

  }
#line 523
  if ((int )resume_data.valid && (unsigned long )priv->contexts[0].vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 524
    reasons = status_data.wakeup_reason;
#line 527
    __iwl_info(priv->dev, "WoWLAN wakeup reason(s): 0x%.8x\n", reasons);
#line 529
    if (reasons != 0U) {
#line 530
      if ((int )reasons & 1) {
#line 531
        wakeup.magic_pkt = 1;
      } else {

      }
#line 532
      if ((reasons & 2U) != 0U) {
#line 533
        wakeup.pattern_idx = (s32 )status_data.pattern_number;
      } else {

      }
#line 534
      if ((reasons & 12U) != 0U) {
#line 536
        wakeup.disconnect = 1;
      } else {

      }
#line 537
      if ((reasons & 16U) != 0U) {
#line 538
        wakeup.gtk_rekey_failure = 1;
      } else {

      }
#line 539
      if ((reasons & 32U) != 0U) {
#line 540
        wakeup.eap_identity_req = 1;
      } else {

      }
#line 541
      if ((reasons & 64U) != 0U) {
#line 542
        wakeup.four_way_handshake = 1;
      } else {

      }
#line 543
      wakeup_report = & wakeup;
    } else {
#line 545
      wakeup_report = (struct cfg80211_wowlan_wakeup *)0;
    }
#line 548
    ieee80211_report_wowlan_wakeup(vif, wakeup_report, 208U);
  } else {

  }
#line 551
  priv->wowlan = 0;
#line 553
  iwlagn_prepare_restart(priv);
#line 555
  memset((void *)(& ctx->active), 0, 50UL);
#line 556
  iwl_connection_init_rx_config(priv, ctx);
#line 557
  iwlagn_set_rxon_chain(priv, ctx);
  out_unlock: 
#line 560
  ldv_mutex_unlock_131(& priv->mutex);
#line 561
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_resume", "leave\n");
#line 563
  ieee80211_resume_disconnect(vif);
#line 565
  return (1);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_set_wakeup(struct ieee80211_hw *hw , bool enabled ) 
{ 
  struct iwl_priv *priv ;

  {
#line 570
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 572
  device_set_wakeup_enable((priv->trans)->dev, (int )enabled);
#line 573
  return;
}
}
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_tx(struct ieee80211_hw *hw , struct ieee80211_tx_control *control ,
                          struct sk_buff *skb ) 
{ 
  struct iwl_priv *priv ;
  int tmp ;

  {
#line 580
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 582
  tmp = iwlagn_tx_skb(priv, control->sta, skb);
#line 582
  if (tmp != 0) {
#line 583
    ieee80211_free_txskb(hw, skb);
  } else {

  }
#line 584
  return;
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_update_tkip_key(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                       struct ieee80211_key_conf *keyconf , struct ieee80211_sta *sta ,
                                       u32 iv32 , u16 *phase1key ) 
{ 
  struct iwl_priv *priv ;

  {
#line 592
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 594
  iwl_update_tkip_key(priv, vif, keyconf, sta, iv32, phase1key);
#line 595
  return;
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_set_key(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                              struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_vif_priv *vif_priv ;
  struct iwl_rxon_context *ctx ;
  int ret ;
  bool is_default_wep_key ;

  {
#line 602
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 603
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
#line 604
  ctx = vif_priv->ctx;
#line 606
  is_default_wep_key = 0;
#line 608
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "enter\n");
#line 610
  if (iwlwifi_mod_params.sw_crypto != 0) {
#line 611
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "leave - hwcrypto disabled\n");
#line 612
    return (-95);
  } else {

  }
#line 615
  switch (key->cipher) {
  case 1027074U: 
#line 617
  key->flags = (u8 )((unsigned int )key->flags | 4U);
  case 1027076U: 
#line 620
  key->flags = (u8 )((unsigned int )key->flags | 2U);
#line 621
  goto ldv_55608;
  default: ;
#line 623
  goto ldv_55608;
  }
  ldv_55608: ;
#line 633
  if ((unsigned int )vif->type == 1U && ((int )key->flags & 8) == 0) {
#line 635
    key->hw_key_idx = 255U;
#line 636
    return (0);
  } else {

  }
#line 640
  if ((unsigned int )cmd == 1U && (unsigned int )key->hw_key_idx == 255U) {
#line 641
    return (0);
  } else {

  }
#line 643
  ldv_mutex_lock_132(& priv->mutex);
#line 644
  iwl_scan_cancel_timeout(priv, 100UL);
#line 654
  if ((key->cipher == 1027073U || key->cipher == 1027077U) && (unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) {
#line 656
    if ((unsigned int )cmd == 0U) {
#line 657
      is_default_wep_key = (unsigned int )ctx->key_mapping_keys == 0U;
    } else {
#line 659
      is_default_wep_key = (unsigned int )key->hw_key_idx == 254U;
    }
  } else {

  }
#line 664
  switch ((unsigned int )cmd) {
  case 0U: ;
#line 666
  if ((int )is_default_wep_key) {
#line 667
    ret = iwl_set_default_wep_key(priv, vif_priv->ctx, key);
#line 668
    goto ldv_55611;
  } else {

  }
#line 670
  ret = iwl_set_dynamic_key(priv, vif_priv->ctx, key, sta);
#line 671
  if (ret != 0) {
#line 676
    ret = 0;
#line 677
    key->hw_key_idx = 255U;
  } else {

  }
#line 680
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "enable hwcrypto key\n");
#line 681
  goto ldv_55611;
  case 1U: ;
#line 683
  if ((int )is_default_wep_key) {
#line 684
    ret = iwl_remove_default_wep_key(priv, ctx, key);
  } else {
#line 686
    ret = iwl_remove_dynamic_key(priv, ctx, key, sta);
  }
#line 688
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "disable hwcrypto key\n");
#line 689
  goto ldv_55611;
  default: 
#line 691
  ret = -22;
  }
  ldv_55611: 
#line 694
  ldv_mutex_unlock_133(& priv->mutex);
#line 695
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "leave\n");
#line 697
  return (ret);
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
__inline static bool iwl_enable_rx_ampdu(struct iwl_cfg  const  *cfg ) 
{ 


  {
#line 702
  if ((iwlwifi_mod_params.disable_11n & 4U) != 0U) {
#line 703
    return (0);
  } else {

  }
#line 704
  return (1);
}
}
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
__inline static bool iwl_enable_tx_ampdu(struct iwl_cfg  const  *cfg ) 
{ 


  {
#line 709
  if ((iwlwifi_mod_params.disable_11n & 2U) != 0U) {
#line 710
    return (0);
  } else {

  }
#line 711
  if ((iwlwifi_mod_params.disable_11n & 8U) != 0U) {
#line 712
    return (1);
  } else {

  }
#line 715
  return (0);
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_ampdu_action(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                   enum ieee80211_ampdu_mlme_action action , struct ieee80211_sta *sta ,
                                   u16 tid , u16 *ssn , u8 buf_size ) 
{ 
  struct iwl_priv *priv ;
  int ret ;
  struct iwl_station_priv *sta_priv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct iwl_rxon_context *tmp___3 ;

  {
#line 724
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 725
  ret = -22;
#line 726
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 728
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "A-MPDU action on addr %pM tid %d\n",
            (u8 *)(& sta->addr), (int )tid);
#line 731
  if (! (priv->nvm_data)->sku_cap_11n_enable) {
#line 732
    return (-13);
  } else {

  }
#line 734
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_ampdu_action", "enter\n");
#line 735
  ldv_mutex_lock_134(& priv->mutex);
#line 737
  switch ((unsigned int )action) {
  case 0U: 
#line 739
  tmp = iwl_enable_rx_ampdu(priv->cfg);
#line 739
  if (tmp) {
#line 739
    tmp___0 = 0;
  } else {
#line 739
    tmp___0 = 1;
  }
#line 739
  if (tmp___0) {
#line 740
    goto ldv_55634;
  } else {

  }
#line 741
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "start Rx\n");
#line 742
  ret = iwl_sta_rx_agg_start(priv, sta, (int )tid, (int )*ssn);
#line 743
  goto ldv_55634;
  case 1U: 
#line 745
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "stop Rx\n");
#line 746
  ret = iwl_sta_rx_agg_stop(priv, sta, (int )tid);
#line 747
  goto ldv_55634;
  case 2U: ;
#line 749
  if ((unsigned long )((priv->trans)->ops)->txq_enable == (unsigned long )((void (*/* const  */)(struct iwl_trans * ,
                                                                                                 int  ,
                                                                                                 u16  ,
                                                                                                 struct iwl_trans_txq_scd_cfg  const  * ,
                                                                                                 unsigned int  ))0)) {
#line 750
    goto ldv_55634;
  } else {

  }
#line 751
  tmp___1 = iwl_enable_tx_ampdu(priv->cfg);
#line 751
  if (tmp___1) {
#line 751
    tmp___2 = 0;
  } else {
#line 751
    tmp___2 = 1;
  }
#line 751
  if (tmp___2) {
#line 752
    goto ldv_55634;
  } else {

  }
#line 753
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "start Tx\n");
#line 754
  ret = iwlagn_tx_agg_start(priv, vif, sta, (int )tid, ssn);
#line 755
  goto ldv_55634;
  case 4U: ;
  case 5U: 
#line 758
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "Flush Tx\n");
#line 759
  ret = iwlagn_tx_agg_flush(priv, vif, sta, (int )tid);
#line 760
  goto ldv_55634;
  case 3U: 
#line 762
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "stop Tx\n");
#line 763
  ret = iwlagn_tx_agg_stop(priv, vif, sta, (int )tid);
#line 764
  if (ret == 0 && (unsigned int )priv->agg_tids_count != 0U) {
#line 765
    priv->agg_tids_count = (u8 )((int )priv->agg_tids_count - 1);
#line 766
    __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "priv->agg_tids_count = %u\n",
              (int )priv->agg_tids_count);
  } else {

  }
#line 769
  if ((unsigned int )priv->agg_tids_count == 0U && (int )priv->hw_params.use_rts_for_aggregation) {
#line 774
    sta_priv->lq_sta.lq.general_params.flags = (unsigned int )sta_priv->lq_sta.lq.general_params.flags & 254U;
#line 776
    tmp___3 = iwl_rxon_ctx_from_vif(vif);
#line 776
    iwl_send_lq_cmd(priv, tmp___3, & sta_priv->lq_sta.lq, 1, 0);
  } else {

  }
#line 779
  goto ldv_55634;
  case 6U: 
#line 781
  ret = iwlagn_tx_agg_oper(priv, vif, sta, (int )tid, (int )buf_size);
#line 782
  goto ldv_55634;
  }
  ldv_55634: 
#line 784
  ldv_mutex_unlock_135(& priv->mutex);
#line 785
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_ampdu_action", "leave\n");
#line 786
  return (ret);
}
}
#line 789 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_sta_add(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                              struct ieee80211_sta *sta ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_vif_priv *vif_priv ;
  bool is_ap ;
  int ret ;
  u8 sta_id ;

  {
#line 793
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 794
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 795
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
#line 796
  is_ap = (unsigned int )vif->type == 2U;
#line 800
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_sta_add", "proceeding to add station %pM\n",
            (u8 *)(& sta->addr));
#line 802
  sta_priv->sta_id = 255U;
#line 804
  atomic_set(& sta_priv->pending_frames, 0);
#line 805
  if ((unsigned int )vif->type == 3U) {
#line 806
    sta_priv->client = 1;
  } else {

  }
#line 808
  ret = iwl_add_station_common(priv, vif_priv->ctx, (u8 const   *)(& sta->addr), (int )is_ap,
                               sta, & sta_id);
#line 810
  if (ret != 0) {
#line 811
    __iwl_err(priv->dev, 0, 0, "Unable to add station %pM (%d)\n", (u8 *)(& sta->addr),
              ret);
#line 814
    return (ret);
  } else {

  }
#line 817
  sta_priv->sta_id = sta_id;
#line 819
  return (0);
}
}
#line 822 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_sta_remove(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                 struct ieee80211_sta *sta ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_station_priv *sta_priv ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 826
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 827
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 830
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_sta_remove", "proceeding to remove station %pM\n",
            (u8 *)(& sta->addr));
#line 832
  if ((unsigned int )vif->type == 2U) {
#line 838
    ret = 0;
#line 839
    iwl_deactivate_station(priv, (int )sta_priv->sta_id, (u8 const   *)(& sta->addr));
  } else {
#line 841
    ret = iwl_remove_station(priv, (int )sta_priv->sta_id, (u8 const   *)(& sta->addr));
#line 842
    if (ret != 0) {
#line 843
      tmp___1 = iwl_is_rfkill(priv);
#line 843
      if (tmp___1 == 0) {
#line 843
        __iwl_err(priv->dev, 0, 0, "Error removing station %pM\n", (u8 *)(& sta->addr));
      } else {
#line 843
        tmp = iwl_have_debug_level(128U);
#line 843
        if ((int )tmp != 0) {
#line 843
          tmp___0 = 0;
        } else {
#line 843
          tmp___0 = 1;
        }
#line 843
        __iwl_err(priv->dev, 1, (int )((bool )tmp___0), "Error removing station %pM\n",
                  (u8 *)(& sta->addr));
      }
    } else {

    }
  }
#line 846
  return (ret);
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_sta_state(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                struct ieee80211_sta *sta , enum ieee80211_sta_state old_state ,
                                enum ieee80211_sta_state new_state ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_vif_priv *vif_priv ;
  enum ldv_36117 op ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 855
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 856
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
#line 859
  op = 0;
#line 862
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_sta_state", "station %pM state change %d->%d\n",
            (u8 *)(& sta->addr), (unsigned int )old_state, (unsigned int )new_state);
#line 865
  ldv_mutex_lock_136(& priv->mutex);
#line 866
  if ((unsigned int )vif->type == 2U) {
#line 867
    if ((unsigned int )old_state == 0U && (unsigned int )new_state == 1U) {
#line 869
      op = 1;
    } else
#line 870
    if ((unsigned int )old_state == 1U && (unsigned int )new_state == 0U) {
#line 872
      op = 2;
    } else
#line 873
    if ((unsigned int )old_state == 2U && (unsigned int )new_state == 3U) {
#line 875
      op = 3;
    } else {

    }
  } else
#line 877
  if ((unsigned int )old_state == 2U && (unsigned int )new_state == 3U) {
#line 879
    op = 4;
  } else
#line 880
  if ((unsigned int )old_state == 3U && (unsigned int )new_state == 2U) {
#line 882
    op = 2;
  } else {

  }
#line 885
  switch ((unsigned int )op) {
  case 1U: 
#line 887
  ret = iwlagn_mac_sta_add(hw, vif, sta);
#line 888
  if (ret != 0) {
#line 889
    goto ldv_55681;
  } else {

  }
#line 896
  spin_lock_bh(& priv->sta_lock);
#line 897
  tmp = iwl_sta_id(sta);
#line 897
  priv->stations[tmp].used = (unsigned int )priv->stations[tmp].used & 251U;
#line 899
  spin_unlock_bh(& priv->sta_lock);
#line 900
  goto ldv_55681;
  case 2U: 
#line 902
  ret = iwlagn_mac_sta_remove(hw, vif, sta);
#line 903
  goto ldv_55681;
  case 4U: 
#line 905
  ret = iwlagn_mac_sta_add(hw, vif, sta);
#line 906
  if (ret != 0) {
#line 907
    goto ldv_55681;
  } else {

  }
#line 909
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_sta_state", "Initializing rate scaling for station %pM\n",
            (u8 *)(& sta->addr));
#line 912
  tmp___0 = iwl_sta_id(sta);
#line 912
  iwl_rs_rate_init(priv, sta, (int )((u8 )tmp___0));
#line 913
  ret = 0;
#line 914
  goto ldv_55681;
  case 3U: 
#line 917
  ret = iwl_sta_update_ht(priv, vif_priv->ctx, sta);
#line 918
  if (ret != 0) {
#line 919
    goto ldv_55681;
  } else {

  }
#line 920
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_sta_state", "Initializing rate scaling for station %pM\n",
            (u8 *)(& sta->addr));
#line 923
  tmp___1 = iwl_sta_id(sta);
#line 923
  iwl_rs_rate_init(priv, sta, (int )((u8 )tmp___1));
#line 924
  ret = 0;
#line 925
  goto ldv_55681;
  default: 
#line 927
  ret = 0;
#line 928
  goto ldv_55681;
  }
  ldv_55681: 
#line 935
  tmp___2 = iwl_is_rfkill(priv);
#line 935
  if (tmp___2 != 0) {
#line 936
    ret = 0;
  } else {

  }
#line 938
  ldv_mutex_unlock_137(& priv->mutex);
#line 939
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_sta_state", "leave\n");
#line 941
  return (ret);
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_channel_switch(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                      struct ieee80211_channel_switch *ch_switch ) 
{ 
  struct iwl_priv *priv ;
  struct ieee80211_conf *conf ;
  struct ieee80211_channel *channel ;
  struct iwl_ht_config *ht_conf ;
  struct iwl_rxon_context *ctx ;
  u16 ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  enum nl80211_channel_type tmp___4 ;
  int tmp___5 ;

  {
#line 948
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 949
  conf = & hw->conf;
#line 950
  channel = ch_switch->chandef.chan;
#line 951
  ht_conf = & priv->current_ht_config;
#line 960
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 963
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_channel_switch", "enter\n");
#line 965
  ldv_mutex_lock_138(& priv->mutex);
#line 967
  tmp = iwl_is_rfkill(priv);
#line 967
  if (tmp != 0) {
#line 968
    goto out;
  } else {

  }
#line 970
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 970
  if (tmp___0 != 0) {
#line 973
    goto out;
  } else {
#line 970
    tmp___1 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 970
    if (tmp___1 != 0) {
#line 973
      goto out;
    } else {
#line 970
      tmp___2 = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->status));
#line 970
      if (tmp___2 != 0) {
#line 973
        goto out;
      } else {

      }
    }
  }
#line 975
  tmp___3 = iwl_is_associated_ctx(ctx);
#line 975
  if (tmp___3 == 0) {
#line 976
    goto out;
  } else {

  }
#line 978
  if ((unsigned long )(priv->lib)->set_channel_switch == (unsigned long )((int (*/* const  */)(struct iwl_priv * ,
                                                                                               struct ieee80211_channel_switch * ))0)) {
#line 979
    goto out;
  } else {

  }
#line 981
  ch = channel->hw_value;
#line 982
  if ((int )((unsigned short )ctx->active.channel) == (int )ch) {
#line 983
    goto out;
  } else {

  }
#line 985
  priv->current_ht_config.smps = conf->smps_mode;
#line 988
  tmp___4 = cfg80211_get_chandef_type((struct cfg80211_chan_def  const  *)(& ch_switch->chandef));
#line 988
  switch ((unsigned int )tmp___4) {
  case 0U: ;
  case 1U: 
#line 991
  ctx->ht.is_40mhz = 0;
#line 992
  ctx->ht.extension_chan_offset = 0U;
#line 993
  goto ldv_55701;
  case 2U: 
#line 995
  ctx->ht.extension_chan_offset = 3U;
#line 996
  ctx->ht.is_40mhz = 1;
#line 997
  goto ldv_55701;
  case 3U: 
#line 999
  ctx->ht.extension_chan_offset = 1U;
#line 1000
  ctx->ht.is_40mhz = 1;
#line 1001
  goto ldv_55701;
  }
  ldv_55701: ;
#line 1004
  if ((int )ctx->staging.channel != (int )ch) {
#line 1005
    ctx->staging.flags = 0U;
  } else {

  }
#line 1007
  iwl_set_rxon_channel(priv, channel, ctx);
#line 1008
  iwl_set_rxon_ht(priv, ht_conf);
#line 1009
  iwl_set_flags_for_band(priv, ctx, channel->band, ctx->vif);
#line 1015
  set_bit(11L, (unsigned long volatile   *)(& priv->status));
#line 1016
  priv->switch_channel = ch;
#line 1017
  tmp___5 = (*((priv->lib)->set_channel_switch))(priv, ch_switch);
#line 1017
  if (tmp___5 != 0) {
#line 1018
    clear_bit(11L, (unsigned long volatile   *)(& priv->status));
#line 1019
    priv->switch_channel = 0U;
#line 1020
    ieee80211_chswitch_done(ctx->vif, 0);
  } else {

  }
  out: 
#line 1024
  ldv_mutex_unlock_139(& priv->mutex);
#line 1025
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_channel_switch", "leave\n");
#line 1026
  return;
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
void iwl_chswitch_done(struct iwl_priv *priv , bool is_success ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;
  int tmp___0 ;

  {
#line 1034
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 1036
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 1036
  if (tmp != 0) {
#line 1037
    return;
  } else {

  }
#line 1039
  tmp___0 = test_and_clear_bit(11L, (unsigned long volatile   *)(& priv->status));
#line 1039
  if (tmp___0 == 0) {
#line 1040
    return;
  } else {

  }
#line 1042
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 1043
    ieee80211_chswitch_done(ctx->vif, (int )is_success);
  } else {

  }
#line 1044
  return;
}
}
#line 1046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_configure_filter(struct ieee80211_hw *hw , unsigned int changed_flags ,
                                    unsigned int *total_flags , u64 multicast ) 
{ 
  struct iwl_priv *priv ;
  __le32 filter_or ;
  __le32 filter_nand ;
  struct iwl_rxon_context *ctx ;

  {
#line 1051
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1052
  filter_or = 0U;
#line 1052
  filter_nand = 0U;
#line 1062
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_configure_filter", "Enter: changed: 0x%x, total: 0x%x\n",
            changed_flags, *total_flags);
#line 1065
  if ((*total_flags & 64U) != 0U) {
#line 1065
    filter_or = filter_or | 1U;
  } else {
#line 1065
    filter_nand = filter_nand | 1U;
  }
#line 1067
  if ((*total_flags & 32U) != 0U) {
#line 1067
    filter_or = filter_or | 3U;
  } else {
#line 1067
    filter_nand = filter_nand | 3U;
  }
#line 1068
  if ((*total_flags & 16U) != 0U) {
#line 1068
    filter_or = filter_or | 64U;
  } else {
#line 1068
    filter_nand = filter_nand | 64U;
  }
#line 1072
  ldv_mutex_lock_140(& priv->mutex);
#line 1074
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 1074
  goto ldv_55721;
  ldv_55720: ;
#line 1074
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 1075
    ctx->staging.filter_flags = ctx->staging.filter_flags & ~ filter_nand;
#line 1076
    ctx->staging.filter_flags = ctx->staging.filter_flags | filter_or;
  } else {

  }
#line 1074
  ctx = ctx + 1;
  ldv_55721: ;
#line 1074
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 1076
    goto ldv_55720;
  } else {

  }
#line 1084
  ldv_mutex_unlock_141(& priv->mutex);
#line 1092
  *total_flags = *total_flags & 114U;
#line 1093
  return;
}
}
#line 1096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_flush(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                             u32 queues , bool drop ) 
{ 
  struct iwl_priv *priv ;
  u32 scd_queues ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1099
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1102
  ldv_mutex_lock_142(& priv->mutex);
#line 1103
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_flush", "enter\n");
#line 1105
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 1105
  if (tmp != 0) {
#line 1106
    __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_mac_flush", "Aborting flush due to device shutdown\n");
#line 1107
    goto done;
  } else {

  }
#line 1109
  tmp___0 = iwl_is_rfkill(priv);
#line 1109
  if (tmp___0 != 0) {
#line 1110
    __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_mac_flush", "Aborting flush due to RF Kill\n");
#line 1111
    goto done;
  } else {

  }
#line 1114
  scd_queues = (u32 )(1UL << ((priv->cfg)->base_params)->num_of_queues) - 1U;
#line 1115
  scd_queues = scd_queues & 4294966767U;
#line 1118
  if ((int )drop) {
#line 1119
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_mac_flush", "Flushing SCD queues: 0x%x\n",
              scd_queues);
#line 1121
    tmp___1 = iwlagn_txfifo_flush(priv, scd_queues);
#line 1121
    if (tmp___1 != 0) {
#line 1122
      __iwl_err(priv->dev, 0, 0, "flush request fail\n");
#line 1123
      goto done;
    } else {

    }
  } else {

  }
#line 1127
  __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_mac_flush", "wait transmit/flush all frames\n");
#line 1128
  iwl_trans_wait_tx_queue_empty(priv->trans, scd_queues);
  done: 
#line 1130
  ldv_mutex_unlock_143(& priv->mutex);
#line 1131
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_flush", "leave\n");
#line 1132
  return;
}
}
#line 1134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_event_callback(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                      struct ieee80211_event  const  *event ) 
{ 
  struct iwl_priv *priv ;

  {
#line 1138
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1140
  if ((unsigned int )event->type != 0U) {
#line 1141
    return;
  } else {

  }
#line 1143
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_event_callback", "enter\n");
#line 1145
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 1147
    if ((unsigned int )event->u.rssi.data == 1U) {
#line 1148
      priv->bt_enable_pspoll = 1;
    } else
#line 1149
    if ((unsigned int )event->u.rssi.data == 0U) {
#line 1150
      priv->bt_enable_pspoll = 0;
    } else {

    }
#line 1152
    queue_work___1(priv->workqueue, & priv->bt_runtime_config);
  } else {
#line 1154
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_event_callback", "Advanced BT coex disabled,ignoring RSSI callback\n");
  }
#line 1158
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_event_callback", "leave\n");
#line 1159
  return;
}
}
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_set_tim(struct ieee80211_hw *hw , struct ieee80211_sta *sta ,
                              bool set ) 
{ 
  struct iwl_priv *priv ;

  {
#line 1164
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1166
  queue_work___1(priv->workqueue, & priv->beacon_update);
#line 1168
  return (0);
}
}
#line 1171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_conf_tx(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                              u16 queue , struct ieee80211_tx_queue_params  const  *params ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_vif_priv *vif_priv ;
  struct iwl_rxon_context *ctx ;
  int q ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1175
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1176
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
#line 1177
  ctx = vif_priv->ctx;
#line 1180
  __ret_warn_on = (unsigned long )ctx == (unsigned long )((struct iwl_rxon_context *)0);
#line 1180
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1180
  if (tmp != 0L) {
#line 1180
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1180);
  } else {

  }
#line 1180
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1180
  if (tmp___0 != 0L) {
#line 1181
    return (-22);
  } else {

  }
#line 1183
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_conf_tx", "enter\n");
#line 1185
  tmp___1 = iwl_is_ready_rf(priv);
#line 1185
  if (tmp___1 == 0) {
#line 1186
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_conf_tx", "leave - RF not ready\n");
#line 1187
    return (-5);
  } else {

  }
#line 1190
  if ((unsigned int )queue > 3U) {
#line 1191
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_conf_tx", "leave - queue >= AC_NUM %d\n",
              (int )queue);
#line 1192
    return (0);
  } else {

  }
#line 1195
  q = 3 - (int )queue;
#line 1197
  ldv_mutex_lock_144(& priv->mutex);
#line 1199
  ctx->qos_data.def_qos_parm.ac[q].cw_min = params->cw_min;
#line 1201
  ctx->qos_data.def_qos_parm.ac[q].cw_max = params->cw_max;
#line 1203
  ctx->qos_data.def_qos_parm.ac[q].aifsn = params->aifs;
#line 1204
  ctx->qos_data.def_qos_parm.ac[q].edca_txop = (unsigned int )((unsigned short )params->txop) * 32U;
#line 1207
  ctx->qos_data.def_qos_parm.ac[q].reserved1 = 0U;
#line 1209
  ldv_mutex_unlock_145(& priv->mutex);
#line 1211
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_conf_tx", "leave\n");
#line 1212
  return (0);
}
}
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_tx_last_beacon(struct ieee80211_hw *hw ) 
{ 
  struct iwl_priv *priv ;

  {
#line 1217
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1219
  return (priv->ibss_manager == 1U);
}
}
#line 1222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwl_set_mode(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int tmp ;

  {
#line 1224
  iwl_connection_init_rx_config(priv, ctx);
#line 1226
  iwlagn_set_rxon_chain(priv, ctx);
#line 1228
  tmp = iwlagn_commit_rxon(priv, ctx);
#line 1228
  return (tmp);
}
}
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwl_setup_interface(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct ieee80211_vif *vif ;
  int err ;
  int ac ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1234
  vif = ctx->vif;
#line 1237
  if (debug_locks != 0) {
#line 1237
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 1237
    if (tmp == 0) {
#line 1237
      tmp___0 = 1;
    } else {
#line 1237
      tmp___0 = 0;
    }
  } else {
#line 1237
    tmp___0 = 0;
  }
#line 1237
  __ret_warn_on = tmp___0;
#line 1237
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1237
  if (tmp___1 != 0L) {
#line 1237
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1237);
  } else {

  }
#line 1237
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1244
  priv->iw_mode = vif->type;
#line 1246
  ctx->is_active = 1;
#line 1248
  err = iwl_set_mode(priv, ctx);
#line 1249
  if (err != 0) {
#line 1250
    if (! ctx->always_active) {
#line 1251
      ctx->is_active = 0;
    } else {

    }
#line 1252
    return (err);
  } else {

  }
#line 1255
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && (unsigned int )vif->type == 1U) {
#line 1262
    priv->bt_traffic_load = 2U;
  } else {

  }
#line 1266
  ac = 0;
#line 1266
  goto ldv_55777;
  ldv_55776: 
#line 1267
  vif->hw_queue[ac] = ctx->ac_to_queue[ac];
#line 1266
  ac = ac + 1;
  ldv_55777: ;
#line 1266
  if (ac <= 3) {
#line 1268
    goto ldv_55776;
  } else {

  }

#line 1269
  if ((unsigned int )vif->type == 3U) {
#line 1270
    vif->cab_queue = ctx->mcast_queue;
  } else {
#line 1272
    vif->cab_queue = 255U;
  }
#line 1274
  return (0);
}
}
#line 1277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_add_interface(struct ieee80211_hw *hw , struct ieee80211_vif *vif ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_vif_priv *vif_priv ;
  struct iwl_rxon_context *tmp ;
  struct iwl_rxon_context *ctx ;
  int err ;
  enum nl80211_iftype viftype ;
  enum nl80211_iftype tmp___0 ;
  bool reset ;
  int tmp___1 ;
  u32 possible_modes ;

  {
#line 1280
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1281
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
#line 1282
  ctx = (struct iwl_rxon_context *)0;
#line 1284
  tmp___0 = ieee80211_vif_type_p2p(vif);
#line 1284
  viftype = tmp___0;
#line 1285
  reset = 0;
#line 1287
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_add_interface", "enter: type %d, addr %pM\n",
            (unsigned int )viftype, (u8 *)(& vif->addr));
#line 1290
  ldv_mutex_lock_146(& priv->mutex);
#line 1292
  tmp___1 = iwl_is_ready_rf(priv);
#line 1292
  if (tmp___1 == 0) {
#line 1293
    __iwl_warn(priv->dev, "Try to add interface when device not ready\n");
#line 1294
    err = -22;
#line 1295
    goto out;
  } else {

  }
#line 1298
  tmp = (struct iwl_rxon_context *)(& priv->contexts);
#line 1298
  goto ldv_55796;
  ldv_55795: ;
#line 1298
  if ((int )((unsigned long )priv->valid_contexts >> (int )tmp->ctxid) & 1) {
#line 1299
    possible_modes = tmp->interface_modes | tmp->exclusive_interface_modes;
#line 1302
    if ((unsigned long )tmp->vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 1304
      if ((unsigned long )tmp->vif == (unsigned long )vif) {
#line 1305
        reset = 1;
#line 1306
        ctx = tmp;
#line 1307
        goto ldv_55793;
      } else {

      }
#line 1311
      if ((int )((unsigned long )tmp->exclusive_interface_modes >> (int )(tmp->vif)->type) & 1) {
#line 1313
        err = -22;
#line 1314
        goto out;
      } else {

      }
#line 1316
      goto ldv_55794;
    } else {

    }
#line 1319
    if ((((unsigned long )possible_modes >> (int )viftype) & 1UL) == 0UL) {
#line 1320
      goto ldv_55794;
    } else {

    }
#line 1323
    ctx = tmp;
#line 1324
    goto ldv_55793;
  } else {

  }
  ldv_55794: 
#line 1298
  tmp = tmp + 1;
  ldv_55796: ;
#line 1298
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp) {
#line 1300
    goto ldv_55795;
  } else {

  }
  ldv_55793: ;
#line 1327
  if ((unsigned long )ctx == (unsigned long )((struct iwl_rxon_context *)0)) {
#line 1328
    err = -95;
#line 1329
    goto out;
  } else {

  }
#line 1332
  vif_priv->ctx = ctx;
#line 1333
  ctx->vif = vif;
#line 1344
  if ((unsigned int )vif->type == 6U) {
#line 1345
    _ieee80211_hw_set(priv->hw, 1);
  } else {
#line 1347
    __clear_bit(1L, (unsigned long volatile   *)(& (priv->hw)->flags));
  }
#line 1349
  err = iwl_setup_interface(priv, ctx);
#line 1350
  if (err == 0 || (int )reset) {
#line 1351
    goto out;
  } else {

  }
#line 1353
  ctx->vif = (struct ieee80211_vif *)0;
#line 1354
  priv->iw_mode = 2;
  out: 
#line 1356
  ldv_mutex_unlock_147(& priv->mutex);
#line 1358
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_add_interface", "leave\n");
#line 1359
  return (err);
}
}
#line 1362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwl_teardown_interface(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                                   bool mode_change ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 1366
  tmp = iwl_rxon_ctx_from_vif(vif);
#line 1366
  ctx = tmp;
#line 1368
  if (debug_locks != 0) {
#line 1368
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
#line 1368
    if (tmp___0 == 0) {
#line 1368
      tmp___1 = 1;
    } else {
#line 1368
      tmp___1 = 0;
    }
  } else {
#line 1368
    tmp___1 = 0;
  }
#line 1368
  __ret_warn_on = tmp___1;
#line 1368
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1368
  if (tmp___2 != 0L) {
#line 1368
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1368);
  } else {

  }
#line 1368
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1370
  if ((unsigned long )priv->scan_vif == (unsigned long )vif) {
#line 1371
    iwl_scan_cancel_timeout(priv, 200UL);
#line 1372
    iwl_force_scan_end(priv);
  } else {

  }
#line 1375
  if (! mode_change) {
#line 1376
    iwl_set_mode(priv, ctx);
#line 1377
    if (! ctx->always_active) {
#line 1378
      ctx->is_active = 0;
    } else {

    }
  } else {

  }
#line 1388
  if ((unsigned int )vif->type == 1U) {
#line 1389
    priv->bt_traffic_load = priv->last_bt_traffic_load;
  } else {

  }
#line 1390
  return;
}
}
#line 1392 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_remove_interface(struct ieee80211_hw *hw , struct ieee80211_vif *vif ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  struct iwl_rxon_context *tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1395
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1396
  tmp = iwl_rxon_ctx_from_vif(vif);
#line 1396
  ctx = tmp;
#line 1398
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_remove_interface", "enter\n");
#line 1400
  ldv_mutex_lock_148(& priv->mutex);
#line 1402
  __ret_warn_on = (unsigned long )ctx->vif != (unsigned long )vif;
#line 1402
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1402
  if (tmp___1 != 0L) {
#line 1402
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1402);
  } else {

  }
#line 1402
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1402
  if (tmp___2 != 0L) {
#line 1404
    __iwl_err(priv->dev, 0, 0, "ctx->vif = %p, vif = %p\n", ctx->vif, vif);
#line 1405
    tmp___0 = (struct iwl_rxon_context *)(& priv->contexts);
#line 1405
    goto ldv_55816;
    ldv_55815: ;
#line 1405
    if ((int )((unsigned long )priv->valid_contexts >> (int )tmp___0->ctxid) & 1) {
#line 1406
      __iwl_err(priv->dev, 0, 0, "\tID = %d:\tctx = %p\tctx->vif = %p\n", (unsigned int )tmp___0->ctxid,
                tmp___0, tmp___0->vif);
    } else {

    }
#line 1405
    tmp___0 = tmp___0 + 1;
    ldv_55816: ;
#line 1405
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp___0) {
#line 1407
      goto ldv_55815;
    } else {

    }

  } else {

  }
#line 1409
  ctx->vif = (struct ieee80211_vif *)0;
#line 1411
  iwl_teardown_interface(priv, vif, 0);
#line 1413
  ldv_mutex_unlock_149(& priv->mutex);
#line 1415
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_remove_interface", "leave\n");
#line 1416
  return;
}
}
#line 1419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_change_interface(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                       enum nl80211_iftype newtype , bool newp2p ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  enum nl80211_iftype newviftype ;
  u32 interface_modes ;
  int err ;
  int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
#line 1423
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1425
  newviftype = newtype;
#line 1429
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_change_interface", "enter\n");
#line 1431
  newtype = ieee80211_iftype_p2p(newtype, (int )newp2p);
#line 1433
  ldv_mutex_lock_150(& priv->mutex);
#line 1435
  ctx = iwl_rxon_ctx_from_vif(vif);
#line 1442
  if ((unsigned int )ctx->ctxid != 0U) {
#line 1443
    err = -16;
#line 1444
    goto out;
  } else {

  }
#line 1447
  if ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0)) {
#line 1452
    err = -16;
#line 1453
    goto out;
  } else {
#line 1447
    tmp___0 = iwl_is_ready_rf(priv);
#line 1447
    if (tmp___0 == 0) {
#line 1452
      err = -16;
#line 1453
      goto out;
    } else {

    }
  }
#line 1457
  interface_modes = ctx->interface_modes | ctx->exclusive_interface_modes;
#line 1458
  if ((((unsigned long )interface_modes >> (int )newtype) & 1UL) == 0UL) {
#line 1459
    err = -16;
#line 1460
    goto out;
  } else {

  }
#line 1463
  if ((int )((unsigned long )ctx->exclusive_interface_modes >> (int )newtype) & 1) {
#line 1464
    tmp = (struct iwl_rxon_context *)(& priv->contexts);
#line 1464
    goto ldv_55834;
    ldv_55833: ;
#line 1464
    if ((int )((unsigned long )priv->valid_contexts >> (int )tmp->ctxid) & 1) {
#line 1465
      if ((unsigned long )ctx == (unsigned long )tmp) {
#line 1466
        goto ldv_55832;
      } else {

      }
#line 1468
      if (! tmp->is_active) {
#line 1469
        goto ldv_55832;
      } else {

      }
#line 1475
      err = -16;
#line 1476
      goto out;
    } else {

    }
    ldv_55832: 
#line 1464
    tmp = tmp + 1;
    ldv_55834: ;
#line 1464
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp) {
#line 1466
      goto ldv_55833;
    } else {

    }

  } else {

  }
#line 1481
  iwl_teardown_interface(priv, vif, 1);
#line 1482
  vif->type = newviftype;
#line 1483
  vif->p2p = newp2p;
#line 1484
  err = iwl_setup_interface(priv, ctx);
#line 1485
  __ret_warn_on = err != 0;
#line 1485
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1485
  if (tmp___1 != 0L) {
#line 1485
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1485);
  } else {

  }
#line 1485
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1493
  err = 0;
  out: 
#line 1496
  ldv_mutex_unlock_151(& priv->mutex);
#line 1497
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_change_interface", "leave\n");
#line 1499
  return (err);
}
}
#line 1502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static int iwlagn_mac_hw_scan(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                              struct ieee80211_scan_request *hw_req ) 
{ 
  struct iwl_priv *priv ;
  struct cfg80211_scan_request *req ;
  int ret ;

  {
#line 1506
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1507
  req = & hw_req->req;
#line 1510
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_hw_scan", "enter\n");
#line 1512
  if (req->n_channels == 0U) {
#line 1513
    return (-22);
  } else {

  }
#line 1515
  ldv_mutex_lock_152(& priv->mutex);
#line 1521
  if ((unsigned int )priv->scan_type != 0U) {
#line 1522
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_mac_hw_scan", "SCAN request during internal scan - defer\n");
#line 1524
    priv->scan_request = req;
#line 1525
    priv->scan_vif = vif;
#line 1526
    ret = 0;
  } else {
#line 1528
    priv->scan_request = req;
#line 1529
    priv->scan_vif = vif;
#line 1534
    ret = iwl_scan_initiate(priv, vif, 0, (req->channels[0])->band);
#line 1536
    if (ret != 0) {
#line 1537
      priv->scan_request = (struct cfg80211_scan_request *)0;
#line 1538
      priv->scan_vif = (struct ieee80211_vif *)0;
    } else {

    }
  }
#line 1542
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_hw_scan", "leave\n");
#line 1544
  ldv_mutex_unlock_153(& priv->mutex);
#line 1546
  return (ret);
}
}
#line 1549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwl_sta_modify_ps_wake(struct iwl_priv *priv , int sta_id ) 
{ 
  struct iwl_addsta_cmd cmd ;

  {
#line 1551
  cmd.mode = 1U;
#line 1551
  cmd.reserved[0] = (unsigned char)0;
#line 1551
  cmd.reserved[1] = (unsigned char)0;
#line 1551
  cmd.reserved[2] = (unsigned char)0;
#line 1551
  cmd.sta.addr[0] = (unsigned char)0;
#line 1551
  cmd.sta.addr[1] = (unsigned char)0;
#line 1551
  cmd.sta.addr[2] = (unsigned char)0;
#line 1551
  cmd.sta.addr[3] = (unsigned char)0;
#line 1551
  cmd.sta.addr[4] = (unsigned char)0;
#line 1551
  cmd.sta.addr[5] = (unsigned char)0;
#line 1551
  cmd.sta.reserved1 = (unsigned short)0;
#line 1551
  cmd.sta.sta_id = (unsigned char )sta_id;
#line 1551
  cmd.sta.modify_mask = (unsigned char)0;
#line 1551
  cmd.sta.reserved2 = (unsigned short)0;
#line 1551
  cmd.key.key_flags = (unsigned short)0;
#line 1551
  cmd.key.tkip_rx_tsc_byte2 = (unsigned char)0;
#line 1551
  cmd.key.reserved1 = (unsigned char)0;
#line 1551
  cmd.key.tkip_rx_ttak[0] = (unsigned short)0;
#line 1551
  cmd.key.tkip_rx_ttak[1] = (unsigned short)0;
#line 1551
  cmd.key.tkip_rx_ttak[2] = (unsigned short)0;
#line 1551
  cmd.key.tkip_rx_ttak[3] = (unsigned short)0;
#line 1551
  cmd.key.tkip_rx_ttak[4] = (unsigned short)0;
#line 1551
  cmd.key.key_offset = (unsigned char)0;
#line 1551
  cmd.key.reserved2 = (unsigned char)0;
#line 1551
  cmd.key.key[0] = (unsigned char)0;
#line 1551
  cmd.key.key[1] = (unsigned char)0;
#line 1551
  cmd.key.key[2] = (unsigned char)0;
#line 1551
  cmd.key.key[3] = (unsigned char)0;
#line 1551
  cmd.key.key[4] = (unsigned char)0;
#line 1551
  cmd.key.key[5] = (unsigned char)0;
#line 1551
  cmd.key.key[6] = (unsigned char)0;
#line 1551
  cmd.key.key[7] = (unsigned char)0;
#line 1551
  cmd.key.key[8] = (unsigned char)0;
#line 1551
  cmd.key.key[9] = (unsigned char)0;
#line 1551
  cmd.key.key[10] = (unsigned char)0;
#line 1551
  cmd.key.key[11] = (unsigned char)0;
#line 1551
  cmd.key.key[12] = (unsigned char)0;
#line 1551
  cmd.key.key[13] = (unsigned char)0;
#line 1551
  cmd.key.key[14] = (unsigned char)0;
#line 1551
  cmd.key.key[15] = (unsigned char)0;
#line 1551
  cmd.key.tx_secur_seq_cnt = 0ULL;
#line 1551
  cmd.key.hw_tkip_mic_rx_key = 0ULL;
#line 1551
  cmd.key.hw_tkip_mic_tx_key = 0ULL;
#line 1551
  cmd.station_flags = 0U;
#line 1551
  cmd.station_flags_msk = 256U;
#line 1551
  cmd.tid_disable_tx = (unsigned short)0;
#line 1551
  cmd.legacy_reserved = (unsigned short)0;
#line 1551
  cmd.add_immediate_ba_tid = (unsigned char)0;
#line 1551
  cmd.remove_immediate_ba_tid = (unsigned char)0;
#line 1551
  cmd.add_immediate_ba_ssn = (unsigned short)0;
#line 1551
  cmd.sleep_tx_count = (unsigned short)0;
#line 1551
  cmd.reserved2 = (unsigned short)0;
#line 1557
  iwl_send_add_sta(priv, & cmd, 1);
#line 1558
  return;
}
}
#line 1560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
static void iwlagn_mac_sta_notify(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                  enum sta_notify_cmd cmd , struct ieee80211_sta *sta ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_station_priv *sta_priv ;
  int sta_id ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;

  {
#line 1565
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1566
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 1569
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_sta_notify", "enter\n");
#line 1571
  switch ((unsigned int )cmd) {
  case 0U: 
#line 1573
  __ret_warn_on = ! sta_priv->client;
#line 1573
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1573
  if (tmp != 0L) {
#line 1573
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1573);
  } else {

  }
#line 1573
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1574
  sta_priv->asleep = 1;
#line 1575
  tmp___0 = atomic_read((atomic_t const   *)(& sta_priv->pending_frames));
#line 1575
  if (tmp___0 > 0) {
#line 1576
    ieee80211_sta_block_awake(hw, sta, 1);
  } else {

  }
#line 1577
  goto ldv_55865;
  case 1U: 
#line 1579
  __ret_warn_on___0 = ! sta_priv->client;
#line 1579
  tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1579
  if (tmp___1 != 0L) {
#line 1579
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1579);
  } else {

  }
#line 1579
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1580
  if (! sta_priv->asleep) {
#line 1581
    goto ldv_55865;
  } else {

  }
#line 1582
  sta_priv->asleep = 0;
#line 1583
  sta_id = iwl_sta_id(sta);
#line 1584
  if (sta_id != 255) {
#line 1585
    iwl_sta_modify_ps_wake(priv, sta_id);
  } else {

  }
#line 1586
  goto ldv_55865;
  default: ;
#line 1588
  goto ldv_55865;
  }
  ldv_55865: 
#line 1590
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_sta_notify", "leave\n");
#line 1591
  return;
}
}
#line 1593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
struct ieee80211_ops  const  iwlagn_hw_ops  = 
#line 1593
     {& iwlagn_mac_tx, & iwlagn_mac_start, & iwlagn_mac_stop, & iwlagn_mac_suspend,
    & iwlagn_mac_resume, & iwlagn_mac_set_wakeup, & iwlagn_mac_add_interface, & iwlagn_mac_change_interface,
    & iwlagn_mac_remove_interface, & iwlagn_mac_config, & iwlagn_bss_info_changed,
    0, 0, 0, & iwlagn_configure_filter, & iwlagn_mac_set_tim, & iwlagn_mac_set_key,
    & iwlagn_mac_update_tkip_key, & iwlagn_mac_set_rekey_data, 0, & iwlagn_mac_hw_scan,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & iwlagn_mac_sta_notify, & iwlagn_mac_sta_state,
    0, 0, 0, 0, & iwlagn_mac_conf_tx, 0, 0, 0, & iwlagn_mac_tx_last_beacon, & iwlagn_mac_ampdu_action,
    0, 0, 0, 0, 0, & iwlagn_mac_flush, & iwlagn_mac_channel_switch, 0, 0, 0, 0, 0,
    0, 0, 0, & iwlagn_mac_event_callback, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.c"
struct ieee80211_hw *iwl_alloc_all(void) 
{ 
  struct iwl_priv *priv ;
  struct iwl_op_mode *op_mode ;
  struct ieee80211_hw *hw ;

  {
#line 1632
  hw = ldv_ieee80211_alloc_hw_154(14456UL, & iwlagn_hw_ops);
#line 1634
  if ((unsigned long )hw == (unsigned long )((struct ieee80211_hw *)0)) {
#line 1635
    goto out;
  } else {

  }
#line 1637
  op_mode = (struct iwl_op_mode *)hw->priv;
#line 1638
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1639
  priv->hw = hw;
  out: ;
#line 1642
  return (hw);
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
int ldv_retval_13  ;
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_initialize_ieee80211_ops_64(void) 
{ 
  void *tmp ;

  {
#line 553
  tmp = ldv_init_zalloc(160UL);
#line 553
  iwlagn_hw_ops_group0 = (struct ieee80211_hw *)tmp;
#line 554
  return;
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_main_exported_64(void) 
{ 
  struct ieee80211_vif *ldvarg148 ;
  void *tmp ;
  struct ieee80211_sta *ldvarg139 ;
  void *tmp___0 ;
  u8 ldvarg130 ;
  u32 ldvarg117 ;
  u32 ldvarg143 ;
  struct ieee80211_vif *ldvarg108 ;
  void *tmp___1 ;
  struct ieee80211_key_conf *ldvarg150 ;
  void *tmp___2 ;
  struct sk_buff *ldvarg133 ;
  void *tmp___3 ;
  unsigned int ldvarg124 ;
  u16 *ldvarg127 ;
  void *tmp___4 ;
  struct ieee80211_vif *ldvarg116 ;
  void *tmp___5 ;
  struct ieee80211_sta *ldvarg147 ;
  void *tmp___6 ;
  struct ieee80211_vif *ldvarg119 ;
  void *tmp___7 ;
  struct ieee80211_event *ldvarg120 ;
  void *tmp___8 ;
  u16 *ldvarg113 ;
  void *tmp___9 ;
  struct ieee80211_tx_queue_params *ldvarg135 ;
  void *tmp___10 ;
  bool ldvarg112 ;
  enum ieee80211_sta_state ldvarg102 ;
  struct ieee80211_vif *ldvarg153 ;
  void *tmp___11 ;
  struct ieee80211_vif *ldvarg111 ;
  void *tmp___12 ;
  unsigned int *ldvarg123 ;
  void *tmp___13 ;
  struct ieee80211_vif *ldvarg126 ;
  void *tmp___14 ;
  struct ieee80211_sta *ldvarg128 ;
  void *tmp___15 ;
  struct ieee80211_bss_conf *ldvarg144 ;
  void *tmp___16 ;
  u64 ldvarg122 ;
  struct ieee80211_vif *ldvarg137 ;
  void *tmp___17 ;
  bool ldvarg151 ;
  u32 ldvarg154 ;
  struct ieee80211_vif *ldvarg104 ;
  void *tmp___18 ;
  struct ieee80211_vif *ldvarg121 ;
  void *tmp___19 ;
  struct ieee80211_vif *ldvarg142 ;
  void *tmp___20 ;
  enum nl80211_iftype ldvarg107 ;
  enum set_key_cmd ldvarg149 ;
  enum ieee80211_ampdu_mlme_action ldvarg129 ;
  struct ieee80211_vif *ldvarg110 ;
  void *tmp___21 ;
  bool ldvarg138 ;
  u16 ldvarg132 ;
  u32 ldvarg152 ;
  enum ieee80211_sta_state ldvarg105 ;
  struct ieee80211_sta *ldvarg140 ;
  void *tmp___22 ;
  struct ieee80211_vif *ldvarg145 ;
  void *tmp___23 ;
  struct ieee80211_sta *ldvarg103 ;
  void *tmp___24 ;
  struct ieee80211_sta *ldvarg114 ;
  void *tmp___25 ;
  struct ieee80211_channel_switch *ldvarg125 ;
  void *tmp___26 ;
  u16 ldvarg136 ;
  struct ieee80211_scan_request *ldvarg109 ;
  void *tmp___27 ;
  struct ieee80211_key_conf *ldvarg115 ;
  void *tmp___28 ;
  struct cfg80211_gtk_rekey_data *ldvarg118 ;
  void *tmp___29 ;
  enum sta_notify_cmd ldvarg141 ;
  struct cfg80211_wowlan *ldvarg146 ;
  void *tmp___30 ;
  struct ieee80211_vif *ldvarg101 ;
  void *tmp___31 ;
  bool ldvarg106 ;
  struct ieee80211_tx_control *ldvarg134 ;
  void *tmp___32 ;
  struct ieee80211_vif *ldvarg131 ;
  void *tmp___33 ;
  int tmp___34 ;

  {
#line 557
  tmp = ldv_init_zalloc(296UL);
#line 557
  ldvarg148 = (struct ieee80211_vif *)tmp;
#line 558
  tmp___0 = ldv_init_zalloc(216UL);
#line 558
  ldvarg139 = (struct ieee80211_sta *)tmp___0;
#line 562
  tmp___1 = ldv_init_zalloc(296UL);
#line 562
  ldvarg108 = (struct ieee80211_vif *)tmp___1;
#line 563
  tmp___2 = ldv_init_zalloc(24UL);
#line 563
  ldvarg150 = (struct ieee80211_key_conf *)tmp___2;
#line 564
  tmp___3 = ldv_init_zalloc(232UL);
#line 564
  ldvarg133 = (struct sk_buff *)tmp___3;
#line 566
  tmp___4 = ldv_init_zalloc(2UL);
#line 566
  ldvarg127 = (u16 *)tmp___4;
#line 567
  tmp___5 = ldv_init_zalloc(296UL);
#line 567
  ldvarg116 = (struct ieee80211_vif *)tmp___5;
#line 568
  tmp___6 = ldv_init_zalloc(216UL);
#line 568
  ldvarg147 = (struct ieee80211_sta *)tmp___6;
#line 569
  tmp___7 = ldv_init_zalloc(296UL);
#line 569
  ldvarg119 = (struct ieee80211_vif *)tmp___7;
#line 570
  tmp___8 = ldv_init_zalloc(24UL);
#line 570
  ldvarg120 = (struct ieee80211_event *)tmp___8;
#line 571
  tmp___9 = ldv_init_zalloc(2UL);
#line 571
  ldvarg113 = (u16 *)tmp___9;
#line 572
  tmp___10 = ldv_init_zalloc(10UL);
#line 572
  ldvarg135 = (struct ieee80211_tx_queue_params *)tmp___10;
#line 575
  tmp___11 = ldv_init_zalloc(296UL);
#line 575
  ldvarg153 = (struct ieee80211_vif *)tmp___11;
#line 576
  tmp___12 = ldv_init_zalloc(296UL);
#line 576
  ldvarg111 = (struct ieee80211_vif *)tmp___12;
#line 577
  tmp___13 = ldv_init_zalloc(4UL);
#line 577
  ldvarg123 = (unsigned int *)tmp___13;
#line 578
  tmp___14 = ldv_init_zalloc(296UL);
#line 578
  ldvarg126 = (struct ieee80211_vif *)tmp___14;
#line 579
  tmp___15 = ldv_init_zalloc(216UL);
#line 579
  ldvarg128 = (struct ieee80211_sta *)tmp___15;
#line 580
  tmp___16 = ldv_init_zalloc(240UL);
#line 580
  ldvarg144 = (struct ieee80211_bss_conf *)tmp___16;
#line 582
  tmp___17 = ldv_init_zalloc(296UL);
#line 582
  ldvarg137 = (struct ieee80211_vif *)tmp___17;
#line 585
  tmp___18 = ldv_init_zalloc(296UL);
#line 585
  ldvarg104 = (struct ieee80211_vif *)tmp___18;
#line 586
  tmp___19 = ldv_init_zalloc(296UL);
#line 586
  ldvarg121 = (struct ieee80211_vif *)tmp___19;
#line 587
  tmp___20 = ldv_init_zalloc(296UL);
#line 587
  ldvarg142 = (struct ieee80211_vif *)tmp___20;
#line 591
  tmp___21 = ldv_init_zalloc(296UL);
#line 591
  ldvarg110 = (struct ieee80211_vif *)tmp___21;
#line 596
  tmp___22 = ldv_init_zalloc(216UL);
#line 596
  ldvarg140 = (struct ieee80211_sta *)tmp___22;
#line 597
  tmp___23 = ldv_init_zalloc(296UL);
#line 597
  ldvarg145 = (struct ieee80211_vif *)tmp___23;
#line 598
  tmp___24 = ldv_init_zalloc(216UL);
#line 598
  ldvarg103 = (struct ieee80211_sta *)tmp___24;
#line 599
  tmp___25 = ldv_init_zalloc(216UL);
#line 599
  ldvarg114 = (struct ieee80211_sta *)tmp___25;
#line 600
  tmp___26 = ldv_init_zalloc(48UL);
#line 600
  ldvarg125 = (struct ieee80211_channel_switch *)tmp___26;
#line 602
  tmp___27 = ldv_init_zalloc(168UL);
#line 602
  ldvarg109 = (struct ieee80211_scan_request *)tmp___27;
#line 603
  tmp___28 = ldv_init_zalloc(24UL);
#line 603
  ldvarg115 = (struct ieee80211_key_conf *)tmp___28;
#line 604
  tmp___29 = ldv_init_zalloc(24UL);
#line 604
  ldvarg118 = (struct cfg80211_gtk_rekey_data *)tmp___29;
#line 606
  tmp___30 = ldv_init_zalloc(40UL);
#line 606
  ldvarg146 = (struct cfg80211_wowlan *)tmp___30;
#line 607
  tmp___31 = ldv_init_zalloc(296UL);
#line 607
  ldvarg101 = (struct ieee80211_vif *)tmp___31;
#line 609
  tmp___32 = ldv_init_zalloc(8UL);
#line 609
  ldvarg134 = (struct ieee80211_tx_control *)tmp___32;
#line 610
  tmp___33 = ldv_init_zalloc(296UL);
#line 610
  ldvarg131 = (struct ieee80211_vif *)tmp___33;
#line 559
  ldv_memset((void *)(& ldvarg130), 0, 1UL);
#line 560
  ldv_memset((void *)(& ldvarg117), 0, 4UL);
#line 561
  ldv_memset((void *)(& ldvarg143), 0, 4UL);
#line 565
  ldv_memset((void *)(& ldvarg124), 0, 4UL);
#line 573
  ldv_memset((void *)(& ldvarg112), 0, 1UL);
#line 574
  ldv_memset((void *)(& ldvarg102), 0, 4UL);
#line 581
  ldv_memset((void *)(& ldvarg122), 0, 8UL);
#line 583
  ldv_memset((void *)(& ldvarg151), 0, 1UL);
#line 584
  ldv_memset((void *)(& ldvarg154), 0, 4UL);
#line 588
  ldv_memset((void *)(& ldvarg107), 0, 4UL);
#line 589
  ldv_memset((void *)(& ldvarg149), 0, 4UL);
#line 590
  ldv_memset((void *)(& ldvarg129), 0, 4UL);
#line 592
  ldv_memset((void *)(& ldvarg138), 0, 1UL);
#line 593
  ldv_memset((void *)(& ldvarg132), 0, 2UL);
#line 594
  ldv_memset((void *)(& ldvarg152), 0, 4UL);
#line 595
  ldv_memset((void *)(& ldvarg105), 0, 4UL);
#line 601
  ldv_memset((void *)(& ldvarg136), 0, 2UL);
#line 605
  ldv_memset((void *)(& ldvarg141), 0, 4UL);
#line 608
  ldv_memset((void *)(& ldvarg106), 0, 1UL);
#line 612
  tmp___34 = __VERIFIER_nondet_int();
#line 612
  switch (tmp___34) {
  case 0: ;
#line 615
  if (ldv_state_variable_64 == 1) {
#line 617
    ldv_retval_13 = iwlagn_mac_start(iwlagn_hw_ops_group0);
#line 619
    if (ldv_retval_13 == 0) {
#line 620
      ldv_state_variable_64 = 2;
#line 621
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 625
  goto ldv_55940;
  case 1: ;
#line 628
  if (ldv_state_variable_64 == 1) {
#line 630
    iwlagn_mac_config(iwlagn_hw_ops_group0, ldvarg154);
#line 632
    ldv_state_variable_64 = 1;
  } else {

  }
#line 635
  if (ldv_state_variable_64 == 2) {
#line 637
    iwlagn_mac_config(iwlagn_hw_ops_group0, ldvarg154);
#line 639
    ldv_state_variable_64 = 2;
  } else {

  }
#line 642
  goto ldv_55940;
  case 2: ;
#line 645
  if (ldv_state_variable_64 == 1) {
#line 647
    iwlagn_mac_flush(iwlagn_hw_ops_group0, ldvarg153, ldvarg152, (int )ldvarg151);
#line 649
    ldv_state_variable_64 = 1;
  } else {

  }
#line 652
  if (ldv_state_variable_64 == 2) {
#line 654
    iwlagn_mac_flush(iwlagn_hw_ops_group0, ldvarg153, ldvarg152, (int )ldvarg151);
#line 656
    ldv_state_variable_64 = 2;
  } else {

  }
#line 659
  goto ldv_55940;
  case 3: ;
#line 662
  if (ldv_state_variable_64 == 1) {
#line 664
    iwlagn_mac_set_key(iwlagn_hw_ops_group0, ldvarg149, ldvarg148, ldvarg147, ldvarg150);
#line 666
    ldv_state_variable_64 = 1;
  } else {

  }
#line 669
  if (ldv_state_variable_64 == 2) {
#line 671
    iwlagn_mac_set_key(iwlagn_hw_ops_group0, ldvarg149, ldvarg148, ldvarg147, ldvarg150);
#line 673
    ldv_state_variable_64 = 2;
  } else {

  }
#line 676
  goto ldv_55940;
  case 4: ;
#line 679
  if (ldv_state_variable_64 == 1) {
#line 681
    iwlagn_mac_suspend(iwlagn_hw_ops_group0, ldvarg146);
#line 683
    ldv_state_variable_64 = 1;
  } else {

  }
#line 686
  if (ldv_state_variable_64 == 2) {
#line 688
    iwlagn_mac_suspend(iwlagn_hw_ops_group0, ldvarg146);
#line 690
    ldv_state_variable_64 = 2;
  } else {

  }
#line 693
  goto ldv_55940;
  case 5: ;
#line 696
  if (ldv_state_variable_64 == 1) {
#line 698
    iwlagn_bss_info_changed(iwlagn_hw_ops_group0, ldvarg145, ldvarg144, ldvarg143);
#line 700
    ldv_state_variable_64 = 1;
  } else {

  }
#line 703
  if (ldv_state_variable_64 == 2) {
#line 705
    iwlagn_bss_info_changed(iwlagn_hw_ops_group0, ldvarg145, ldvarg144, ldvarg143);
#line 707
    ldv_state_variable_64 = 2;
  } else {

  }
#line 710
  goto ldv_55940;
  case 6: ;
#line 713
  if (ldv_state_variable_64 == 1) {
#line 715
    iwlagn_mac_sta_notify(iwlagn_hw_ops_group0, ldvarg142, ldvarg141, ldvarg140);
#line 717
    ldv_state_variable_64 = 1;
  } else {

  }
#line 720
  if (ldv_state_variable_64 == 2) {
#line 722
    iwlagn_mac_sta_notify(iwlagn_hw_ops_group0, ldvarg142, ldvarg141, ldvarg140);
#line 724
    ldv_state_variable_64 = 2;
  } else {

  }
#line 727
  goto ldv_55940;
  case 7: ;
#line 730
  if (ldv_state_variable_64 == 1) {
#line 732
    iwlagn_mac_set_tim(iwlagn_hw_ops_group0, ldvarg139, (int )ldvarg138);
#line 734
    ldv_state_variable_64 = 1;
  } else {

  }
#line 737
  if (ldv_state_variable_64 == 2) {
#line 739
    iwlagn_mac_set_tim(iwlagn_hw_ops_group0, ldvarg139, (int )ldvarg138);
#line 741
    ldv_state_variable_64 = 2;
  } else {

  }
#line 744
  goto ldv_55940;
  case 8: ;
#line 747
  if (ldv_state_variable_64 == 1) {
#line 749
    iwlagn_mac_conf_tx(iwlagn_hw_ops_group0, ldvarg137, (int )ldvarg136, (struct ieee80211_tx_queue_params  const  *)ldvarg135);
#line 751
    ldv_state_variable_64 = 1;
  } else {

  }
#line 754
  if (ldv_state_variable_64 == 2) {
#line 756
    iwlagn_mac_conf_tx(iwlagn_hw_ops_group0, ldvarg137, (int )ldvarg136, (struct ieee80211_tx_queue_params  const  *)ldvarg135);
#line 758
    ldv_state_variable_64 = 2;
  } else {

  }
#line 761
  goto ldv_55940;
  case 9: ;
#line 764
  if (ldv_state_variable_64 == 2) {
#line 766
    iwlagn_mac_stop(iwlagn_hw_ops_group0);
#line 768
    ldv_state_variable_64 = 1;
#line 769
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 772
  goto ldv_55940;
  case 10: ;
#line 775
  if (ldv_state_variable_64 == 1) {
#line 777
    iwlagn_mac_tx(iwlagn_hw_ops_group0, ldvarg134, ldvarg133);
#line 779
    ldv_state_variable_64 = 1;
  } else {

  }
#line 782
  if (ldv_state_variable_64 == 2) {
#line 784
    iwlagn_mac_tx(iwlagn_hw_ops_group0, ldvarg134, ldvarg133);
#line 786
    ldv_state_variable_64 = 2;
  } else {

  }
#line 789
  goto ldv_55940;
  case 11: ;
#line 792
  if (ldv_state_variable_64 == 1) {
#line 794
    iwlagn_mac_resume(iwlagn_hw_ops_group0);
#line 796
    ldv_state_variable_64 = 1;
  } else {

  }
#line 799
  if (ldv_state_variable_64 == 2) {
#line 801
    iwlagn_mac_resume(iwlagn_hw_ops_group0);
#line 803
    ldv_state_variable_64 = 2;
  } else {

  }
#line 806
  goto ldv_55940;
  case 12: ;
#line 809
  if (ldv_state_variable_64 == 1) {
#line 811
    iwlagn_mac_ampdu_action(iwlagn_hw_ops_group0, ldvarg131, ldvarg129, ldvarg128,
                            (int )ldvarg132, ldvarg127, (int )ldvarg130);
#line 813
    ldv_state_variable_64 = 1;
  } else {

  }
#line 816
  if (ldv_state_variable_64 == 2) {
#line 818
    iwlagn_mac_ampdu_action(iwlagn_hw_ops_group0, ldvarg131, ldvarg129, ldvarg128,
                            (int )ldvarg132, ldvarg127, (int )ldvarg130);
#line 820
    ldv_state_variable_64 = 2;
  } else {

  }
#line 823
  goto ldv_55940;
  case 13: ;
#line 826
  if (ldv_state_variable_64 == 1) {
#line 828
    iwlagn_mac_channel_switch(iwlagn_hw_ops_group0, ldvarg126, ldvarg125);
#line 830
    ldv_state_variable_64 = 1;
  } else {

  }
#line 833
  if (ldv_state_variable_64 == 2) {
#line 835
    iwlagn_mac_channel_switch(iwlagn_hw_ops_group0, ldvarg126, ldvarg125);
#line 837
    ldv_state_variable_64 = 2;
  } else {

  }
#line 840
  goto ldv_55940;
  case 14: ;
#line 843
  if (ldv_state_variable_64 == 1) {
#line 845
    iwlagn_configure_filter(iwlagn_hw_ops_group0, ldvarg124, ldvarg123, ldvarg122);
#line 847
    ldv_state_variable_64 = 1;
  } else {

  }
#line 850
  if (ldv_state_variable_64 == 2) {
#line 852
    iwlagn_configure_filter(iwlagn_hw_ops_group0, ldvarg124, ldvarg123, ldvarg122);
#line 854
    ldv_state_variable_64 = 2;
  } else {

  }
#line 857
  goto ldv_55940;
  case 15: ;
#line 860
  if (ldv_state_variable_64 == 1) {
#line 862
    iwlagn_mac_tx_last_beacon(iwlagn_hw_ops_group0);
#line 864
    ldv_state_variable_64 = 1;
  } else {

  }
#line 867
  if (ldv_state_variable_64 == 2) {
#line 869
    iwlagn_mac_tx_last_beacon(iwlagn_hw_ops_group0);
#line 871
    ldv_state_variable_64 = 2;
  } else {

  }
#line 874
  goto ldv_55940;
  case 16: ;
#line 877
  if (ldv_state_variable_64 == 1) {
#line 879
    iwlagn_mac_event_callback(iwlagn_hw_ops_group0, ldvarg121, (struct ieee80211_event  const  *)ldvarg120);
#line 881
    ldv_state_variable_64 = 1;
  } else {

  }
#line 884
  if (ldv_state_variable_64 == 2) {
#line 886
    iwlagn_mac_event_callback(iwlagn_hw_ops_group0, ldvarg121, (struct ieee80211_event  const  *)ldvarg120);
#line 888
    ldv_state_variable_64 = 2;
  } else {

  }
#line 891
  goto ldv_55940;
  case 17: ;
#line 894
  if (ldv_state_variable_64 == 1) {
#line 896
    iwlagn_mac_set_rekey_data(iwlagn_hw_ops_group0, ldvarg119, ldvarg118);
#line 898
    ldv_state_variable_64 = 1;
  } else {

  }
#line 901
  if (ldv_state_variable_64 == 2) {
#line 903
    iwlagn_mac_set_rekey_data(iwlagn_hw_ops_group0, ldvarg119, ldvarg118);
#line 905
    ldv_state_variable_64 = 2;
  } else {

  }
#line 908
  goto ldv_55940;
  case 18: ;
#line 911
  if (ldv_state_variable_64 == 1) {
#line 913
    iwlagn_mac_update_tkip_key(iwlagn_hw_ops_group0, ldvarg116, ldvarg115, ldvarg114,
                               ldvarg117, ldvarg113);
#line 915
    ldv_state_variable_64 = 1;
  } else {

  }
#line 918
  if (ldv_state_variable_64 == 2) {
#line 920
    iwlagn_mac_update_tkip_key(iwlagn_hw_ops_group0, ldvarg116, ldvarg115, ldvarg114,
                               ldvarg117, ldvarg113);
#line 922
    ldv_state_variable_64 = 2;
  } else {

  }
#line 925
  goto ldv_55940;
  case 19: ;
#line 928
  if (ldv_state_variable_64 == 1) {
#line 930
    iwlagn_mac_set_wakeup(iwlagn_hw_ops_group0, (int )ldvarg112);
#line 932
    ldv_state_variable_64 = 1;
  } else {

  }
#line 935
  if (ldv_state_variable_64 == 2) {
#line 937
    iwlagn_mac_set_wakeup(iwlagn_hw_ops_group0, (int )ldvarg112);
#line 939
    ldv_state_variable_64 = 2;
  } else {

  }
#line 942
  goto ldv_55940;
  case 20: ;
#line 945
  if (ldv_state_variable_64 == 1) {
#line 947
    iwlagn_mac_add_interface(iwlagn_hw_ops_group0, ldvarg111);
#line 949
    ldv_state_variable_64 = 1;
  } else {

  }
#line 952
  if (ldv_state_variable_64 == 2) {
#line 954
    iwlagn_mac_add_interface(iwlagn_hw_ops_group0, ldvarg111);
#line 956
    ldv_state_variable_64 = 2;
  } else {

  }
#line 959
  goto ldv_55940;
  case 21: ;
#line 962
  if (ldv_state_variable_64 == 1) {
#line 964
    iwlagn_mac_hw_scan(iwlagn_hw_ops_group0, ldvarg110, ldvarg109);
#line 966
    ldv_state_variable_64 = 1;
  } else {

  }
#line 969
  if (ldv_state_variable_64 == 2) {
#line 971
    iwlagn_mac_hw_scan(iwlagn_hw_ops_group0, ldvarg110, ldvarg109);
#line 973
    ldv_state_variable_64 = 2;
  } else {

  }
#line 976
  goto ldv_55940;
  case 22: ;
#line 979
  if (ldv_state_variable_64 == 1) {
#line 981
    iwlagn_mac_change_interface(iwlagn_hw_ops_group0, ldvarg108, ldvarg107, (int )ldvarg106);
#line 983
    ldv_state_variable_64 = 1;
  } else {

  }
#line 986
  if (ldv_state_variable_64 == 2) {
#line 988
    iwlagn_mac_change_interface(iwlagn_hw_ops_group0, ldvarg108, ldvarg107, (int )ldvarg106);
#line 990
    ldv_state_variable_64 = 2;
  } else {

  }
#line 993
  goto ldv_55940;
  case 23: ;
#line 996
  if (ldv_state_variable_64 == 1) {
#line 998
    iwlagn_mac_sta_state(iwlagn_hw_ops_group0, ldvarg104, ldvarg103, ldvarg102, ldvarg105);
#line 1000
    ldv_state_variable_64 = 1;
  } else {

  }
#line 1003
  if (ldv_state_variable_64 == 2) {
#line 1005
    iwlagn_mac_sta_state(iwlagn_hw_ops_group0, ldvarg104, ldvarg103, ldvarg102, ldvarg105);
#line 1007
    ldv_state_variable_64 = 2;
  } else {

  }
#line 1010
  goto ldv_55940;
  case 24: ;
#line 1013
  if (ldv_state_variable_64 == 1) {
#line 1015
    iwlagn_mac_remove_interface(iwlagn_hw_ops_group0, ldvarg101);
#line 1017
    ldv_state_variable_64 = 1;
  } else {

  }
#line 1020
  if (ldv_state_variable_64 == 2) {
#line 1022
    iwlagn_mac_remove_interface(iwlagn_hw_ops_group0, ldvarg101);
#line 1024
    ldv_state_variable_64 = 2;
  } else {

  }
#line 1027
  goto ldv_55940;
  default: 
#line 1028
  ldv_stop();
  }
  ldv_55940: ;
#line 1032
  return;
}
}
#line 1057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
bool ldv_queue_work_on_109(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1061
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1061
  ldv_func_res = tmp;
#line 1063
  activate_work_7(ldv_func_arg3, 2);
#line 1065
  return (ldv_func_res);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
bool ldv_queue_delayed_work_on_110(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1072
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1072
  ldv_func_res = tmp;
#line 1074
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1076
  return (ldv_func_res);
}
}
#line 1079 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
bool ldv_queue_work_on_111(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1083
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1083
  ldv_func_res = tmp;
#line 1085
  activate_work_7(ldv_func_arg3, 2);
#line 1087
  return (ldv_func_res);
}
}
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_flush_workqueue_112(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1093
  flush_workqueue(ldv_func_arg1);
#line 1095
  call_and_disable_all_7(2);
#line 1096
  return;
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
bool ldv_queue_delayed_work_on_113(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1102
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1102
  ldv_func_res = tmp;
#line 1104
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1106
  return (ldv_func_res);
}
}
#line 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_114(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1112
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1114
  mutex_lock(ldv_func_arg1);
#line 1115
  return;
}
}
#line 1117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_115(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1120
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1122
  mutex_unlock(ldv_func_arg1);
#line 1123
  return;
}
}
#line 1125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_116(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1128
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1130
  mutex_lock(ldv_func_arg1);
#line 1131
  return;
}
}
#line 1133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
int ldv_mutex_trylock_117(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1137
  tmp = mutex_trylock(ldv_func_arg1);
#line 1137
  ldv_func_res = tmp;
#line 1139
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1139
  return (tmp___0);
#line 1141
  return (ldv_func_res);
}
}
#line 1144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1147
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1149
  mutex_unlock(ldv_func_arg1);
#line 1150
  return;
}
}
#line 1152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1155
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1157
  mutex_unlock(ldv_func_arg1);
#line 1158
  return;
}
}
#line 1160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_120(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1163
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1165
  mutex_lock(ldv_func_arg1);
#line 1166
  return;
}
}
#line 1168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_121(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1171
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1173
  mutex_lock(ldv_func_arg1);
#line 1174
  return;
}
}
#line 1176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1179
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1181
  mutex_unlock(ldv_func_arg1);
#line 1182
  return;
}
}
#line 1184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_123(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1187
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1189
  mutex_lock(ldv_func_arg1);
#line 1190
  return;
}
}
#line 1192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1195
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1197
  mutex_unlock(ldv_func_arg1);
#line 1198
  return;
}
}
#line 1200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_flush_workqueue_125(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1203
  flush_workqueue(ldv_func_arg1);
#line 1205
  call_and_disable_all_7(2);
#line 1206
  return;
}
}
#line 1208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_126(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1211
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1213
  mutex_lock(ldv_func_arg1);
#line 1214
  return;
}
}
#line 1216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_127(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1219
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1221
  mutex_unlock(ldv_func_arg1);
#line 1222
  return;
}
}
#line 1224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_128(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1227
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1229
  mutex_lock(ldv_func_arg1);
#line 1230
  return;
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_129(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1235
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1237
  mutex_unlock(ldv_func_arg1);
#line 1238
  return;
}
}
#line 1240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_130(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1243
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1245
  mutex_lock(ldv_func_arg1);
#line 1246
  return;
}
}
#line 1248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_131(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1251
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1253
  mutex_unlock(ldv_func_arg1);
#line 1254
  return;
}
}
#line 1256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_132(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1259
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1261
  mutex_lock(ldv_func_arg1);
#line 1262
  return;
}
}
#line 1264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1267
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1269
  mutex_unlock(ldv_func_arg1);
#line 1270
  return;
}
}
#line 1272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_134(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1275
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1277
  mutex_lock(ldv_func_arg1);
#line 1278
  return;
}
}
#line 1280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_135(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1283
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1285
  mutex_unlock(ldv_func_arg1);
#line 1286
  return;
}
}
#line 1288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_136(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1291
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1293
  mutex_lock(ldv_func_arg1);
#line 1294
  return;
}
}
#line 1296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1299
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1301
  mutex_unlock(ldv_func_arg1);
#line 1302
  return;
}
}
#line 1304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1307
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1309
  mutex_lock(ldv_func_arg1);
#line 1310
  return;
}
}
#line 1312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_139(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1315
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1317
  mutex_unlock(ldv_func_arg1);
#line 1318
  return;
}
}
#line 1320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1323
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1325
  mutex_lock(ldv_func_arg1);
#line 1326
  return;
}
}
#line 1328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1331
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1333
  mutex_unlock(ldv_func_arg1);
#line 1334
  return;
}
}
#line 1336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1339
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1341
  mutex_lock(ldv_func_arg1);
#line 1342
  return;
}
}
#line 1344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_143(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1347
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1349
  mutex_unlock(ldv_func_arg1);
#line 1350
  return;
}
}
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1355
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1357
  mutex_lock(ldv_func_arg1);
#line 1358
  return;
}
}
#line 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1363
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1365
  mutex_unlock(ldv_func_arg1);
#line 1366
  return;
}
}
#line 1368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1371
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1373
  mutex_lock(ldv_func_arg1);
#line 1374
  return;
}
}
#line 1376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_147(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1379
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1381
  mutex_unlock(ldv_func_arg1);
#line 1382
  return;
}
}
#line 1384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_148(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1387
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1389
  mutex_lock(ldv_func_arg1);
#line 1390
  return;
}
}
#line 1392 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1395
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1397
  mutex_unlock(ldv_func_arg1);
#line 1398
  return;
}
}
#line 1400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_150(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1403
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1405
  mutex_lock(ldv_func_arg1);
#line 1406
  return;
}
}
#line 1408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1411
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1413
  mutex_unlock(ldv_func_arg1);
#line 1414
  return;
}
}
#line 1416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1419
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1421
  mutex_lock(ldv_func_arg1);
#line 1422
  return;
}
}
#line 1424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1427
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1429
  mutex_unlock(ldv_func_arg1);
#line 1430
  return;
}
}
#line 1432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/mac80211.o.c.prepared"
__inline static struct ieee80211_hw *ldv_ieee80211_alloc_hw_154(size_t priv_data_len ,
                                                                struct ieee80211_ops  const  *ops ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  struct ieee80211_hw *tmp ;

  {
#line 1436
  tmp = ieee80211_alloc_hw(priv_data_len, ops);
#line 1436
  ldv_func_res = tmp;
#line 1438
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___12 )0)) {
#line 1439
    ldv_state_variable_64 = 1;
#line 1440
    ldv_initialize_ieee80211_ops_64();
#line 1442
    iwlagn_hw_ops_group0 = ldv_func_res;
  } else {

  }
#line 1445
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_213(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_211(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_214(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_215(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
void ldv_mutex_lock_210(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_212(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_216(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_205(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_206(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_208(struct workqueue_struct *ldv_func_arg1 ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 683 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_fw_alive(struct iwl_trans *trans , u32 scd_addr ) 
{ 


  {
#line 685
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 685, 0);
#line 687
  trans->state = 1;
#line 689
  (*((trans->ops)->fw_alive))(trans, scd_addr);
#line 690
  return;
}
}
#line 692 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static int iwl_trans_start_fw(struct iwl_trans *trans , struct fw_img  const  *fw ,
                                       bool run_in_rfkill ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 696
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 696, 0);
#line 698
  __ret_warn_once = (unsigned int )trans->rx_mpdu_cmd == 0U;
#line 698
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 698
  if (tmp___1 != 0L) {
#line 698
    __ret_warn_on = ! __warned;
#line 698
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 698
    if (tmp != 0L) {
#line 698
      warn_slowpath_null("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 698);
    } else {

    }
#line 698
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 698
    if (tmp___0 != 0L) {
#line 698
      __warned = 1;
    } else {

    }
  } else {

  }
#line 698
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 700
  clear_bit(5L, (unsigned long volatile   *)(& trans->status));
#line 701
  tmp___2 = (*((trans->ops)->start_fw))(trans, fw, (int )run_in_rfkill);
#line 701
  return (tmp___2);
}
}
#line 852 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_txq_enable_cfg(struct iwl_trans *trans , int queue ,
                                              u16 ssn , struct iwl_trans_txq_scd_cfg  const  *cfg ,
                                              unsigned int queue_wdg_timeout ) 
{ 
  long tmp ;

  {
#line 856
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 856, 0);
#line 858
  tmp = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
#line 858
  if (tmp != 0L) {
#line 859
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_txq_enable_cfg",
              (unsigned int )trans->state);
  } else {

  }
#line 861
  (*((trans->ops)->txq_enable))(trans, queue, (int )ssn, cfg, queue_wdg_timeout);
#line 862
  return;
}
}
#line 881 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_ac_txq_enable(struct iwl_trans *trans , int queue ,
                                             int fifo , unsigned int queue_wdg_timeout ) 
{ 
  struct iwl_trans_txq_scd_cfg cfg ;

  {
#line 884
  cfg.fifo = (unsigned char )fifo;
#line 884
  cfg.sta_id = -1;
#line 884
  cfg.tid = 8U;
#line 884
  cfg.aggregate = 0;
#line 884
  cfg.frame_limit = 64;
#line 892
  iwl_trans_txq_enable_cfg(trans, queue, 0, (struct iwl_trans_txq_scd_cfg  const  *)(& cfg),
                           queue_wdg_timeout);
#line 893
  return;
}
}
#line 135 "drivers/net/wireless/iwlwifi/dvm/../iwl-notif-wait.h"
extern void iwl_remove_notification(struct iwl_notif_wait_data * , struct iwl_notification_wait * ) ;
#line 114 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static void iwl_set_calib_hdr(struct iwl_calib_hdr *hdr , u8 cmd ) 
{ 


  {
#line 116
  hdr->op_code = cmd;
#line 117
  hdr->first_group = 0U;
#line 118
  hdr->groups_num = 1U;
#line 119
  hdr->data_valid = 1U;
#line 120
  return;
}
}
#line 168
int iwl_init_alive_start(struct iwl_priv *priv ) ;
#line 172
int iwl_send_calib_results(struct iwl_priv *priv ) ;
#line 173
int iwl_calib_set(struct iwl_priv *priv , struct iwl_calib_hdr  const  *cmd , int len ) ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
__inline static struct fw_img  const  *iwl_get_ucode_image(struct iwl_priv *priv ,
                                                           enum iwl_ucode_type ucode_type ) 
{ 


  {
#line 51
  if ((unsigned int )ucode_type > 3U) {
#line 52
    return ((struct fw_img  const  *)0);
  } else {

  }
#line 54
  return ((struct fw_img  const  *)(& (priv->fw)->img) + (unsigned long )ucode_type);
}
}
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static int iwl_set_Xtal_calib(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_xtal_freq_cmd cmd ;
  __le16 *xtal_calib ;
  int tmp ;

  {
#line 63
  xtal_calib = (__le16 *)(& (priv->nvm_data)->xtal_calib);
#line 65
  iwl_set_calib_hdr(& cmd.hdr, 15);
#line 66
  cmd.cap_pin1 = (u8 )*xtal_calib;
#line 67
  cmd.cap_pin2 = (u8 )*(xtal_calib + 1UL);
#line 68
  tmp = iwl_calib_set(priv, (struct iwl_calib_hdr  const  *)(& cmd), 8);
#line 68
  return (tmp);
}
}
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static int iwl_set_temperature_offset_calib(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_temperature_offset_cmd cmd ;
  int tmp ;

  {
#line 75
  memset((void *)(& cmd), 0, 8UL);
#line 76
  iwl_set_calib_hdr(& cmd.hdr, 18);
#line 77
  cmd.radio_sensor_offset = (priv->nvm_data)->raw_temperature;
#line 78
  if ((unsigned int )cmd.radio_sensor_offset == 0U) {
#line 79
    cmd.radio_sensor_offset = 2700U;
  } else {

  }
#line 81
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib", "Radio sensor offset: %d\n",
            (int )cmd.radio_sensor_offset);
#line 83
  tmp = iwl_calib_set(priv, (struct iwl_calib_hdr  const  *)(& cmd), 8);
#line 83
  return (tmp);
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static int iwl_set_temperature_offset_calib_v2(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_temperature_offset_v2_cmd cmd ;
  int tmp ;

  {
#line 90
  memset((void *)(& cmd), 0, 12UL);
#line 91
  iwl_set_calib_hdr(& cmd.hdr, 18);
#line 92
  cmd.radio_sensor_offset_high = (priv->nvm_data)->kelvin_temperature;
#line 93
  cmd.radio_sensor_offset_low = (priv->nvm_data)->raw_temperature;
#line 94
  if ((unsigned int )cmd.radio_sensor_offset_low == 0U) {
#line 95
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib_v2", "no info in EEPROM, use default\n");
#line 96
    cmd.radio_sensor_offset_low = 2700U;
#line 97
    cmd.radio_sensor_offset_high = 2700U;
  } else {

  }
#line 99
  cmd.burntVoltageRef = (priv->nvm_data)->calib_voltage;
#line 101
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib_v2", "Radio sensor offset high: %d\n",
            (int )cmd.radio_sensor_offset_high);
#line 103
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib_v2", "Radio sensor offset low: %d\n",
            (int )cmd.radio_sensor_offset_low);
#line 105
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib_v2", "Voltage Ref: %d\n",
            (int )cmd.burntVoltageRef);
#line 108
  tmp = iwl_calib_set(priv, (struct iwl_calib_hdr  const  *)(& cmd), 12);
#line 108
  return (tmp);
}
}
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static int iwl_send_calib_cfg(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_cfg_cmd calib_cfg_cmd ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 114
  cmd.data[0] = (void const   *)(& calib_cfg_cmd);
#line 114
  tmp = 1U;
#line 114
  while (1) {
#line 114
    if (tmp >= 2U) {
#line 114
      break;
    } else {

    }
#line 114
    cmd.data[tmp] = 0;
#line 114
    tmp = tmp + 1U;
  }
#line 114
  cmd.resp_pkt = 0;
#line 114
  cmd._rx_page_addr = 0UL;
#line 114
  cmd._rx_page_order = 0U;
#line 114
  cmd.handler_status = 0;
#line 114
  cmd.flags = 0U;
#line 114
  cmd.len[0] = 92U;
#line 114
  tmp___0 = 1U;
#line 114
  while (1) {
#line 114
    if (tmp___0 >= 2U) {
#line 114
      break;
    } else {

    }
#line 114
    cmd.len[tmp___0] = (unsigned short)0;
#line 114
    tmp___0 = tmp___0 + 1U;
  }
#line 114
  cmd.dataflags[0] = (unsigned char)0;
#line 114
  cmd.dataflags[1] = (unsigned char)0;
#line 114
  cmd.id = 101U;
#line 120
  memset((void *)(& calib_cfg_cmd), 0, 92UL);
#line 121
  calib_cfg_cmd.ucd_calib_cfg.once.is_enable = 95U;
#line 122
  calib_cfg_cmd.ucd_calib_cfg.once.start = 95U;
#line 123
  calib_cfg_cmd.ucd_calib_cfg.once.send_res = 95U;
#line 124
  calib_cfg_cmd.ucd_calib_cfg.flags = 1U;
#line 127
  tmp___1 = iwl_dvm_send_cmd(priv, & cmd);
#line 127
  return (tmp___1);
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
int iwl_init_alive_start(struct iwl_priv *priv ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 134
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 142
    ret = iwl_send_bt_env(priv, 1, 1);
#line 144
    if (ret != 0) {
#line 145
      return (ret);
    } else {

    }
  } else {

  }
#line 149
  ret = iwl_send_calib_cfg(priv);
#line 150
  if (ret != 0) {
#line 151
    return (ret);
  } else {

  }
#line 157
  if ((int )(priv->lib)->need_temp_offset_calib) {
#line 158
    if ((int )(priv->lib)->temp_offset_v2) {
#line 159
      tmp = iwl_set_temperature_offset_calib_v2(priv);
#line 159
      return (tmp);
    } else {
#line 161
      tmp___0 = iwl_set_temperature_offset_calib(priv);
#line 161
      return (tmp___0);
    }
  } else {

  }
#line 164
  return (0);
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static int iwl_send_wimax_coex(struct iwl_priv *priv ) 
{ 
  struct iwl_wimax_coex_cmd coex_cmd ;
  int tmp ;

  {
#line 172
  memset((void *)(& coex_cmd), 0, 68UL);
#line 174
  tmp = iwl_dvm_send_cmd_pdu(priv, 90, 0U, 68, (void const   *)(& coex_cmd));
#line 174
  return (tmp);
}
}
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static u8 const   iwl_bt_prio_tbl[16U]  = 
#line 179
  {      6U,      7U,      2U,      3U, 
        4U,      5U,      6U,      8U, 
        10U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
void iwl_send_prio_tbl(struct iwl_priv *priv ) 
{ 
  struct iwl_bt_coex_prio_table_cmd prio_tbl_cmd ;
  int tmp ;

  {
#line 205
  memcpy((void *)(& prio_tbl_cmd.prio_tbl), (void const   *)(& iwl_bt_prio_tbl),
           16UL);
#line 207
  tmp = iwl_dvm_send_cmd_pdu(priv, 204, 0U, 16, (void const   *)(& prio_tbl_cmd));
#line 207
  if (tmp != 0) {
#line 210
    __iwl_err(priv->dev, 0, 0, "failed to send BT prio tbl command\n");
  } else {

  }
#line 211
  return;
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
int iwl_send_bt_env(struct iwl_priv *priv , u8 action , u8 type ) 
{ 
  struct iwl_bt_coex_prot_env_cmd env_cmd ;
  int ret ;

  {
#line 218
  env_cmd.action = action;
#line 219
  env_cmd.type = type;
#line 220
  ret = iwl_dvm_send_cmd_pdu(priv, 205, 0U, 4, (void const   *)(& env_cmd));
#line 223
  if (ret != 0) {
#line 224
    __iwl_err(priv->dev, 0, 0, "failed to send BT env command\n");
  } else {

  }
#line 225
  return (ret);
}
}
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static u8 const   iwlagn_default_queue_to_tx_fifo[4U]  = {      3U,      2U,      1U,      0U};
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static u8 const   iwlagn_ipan_queue_to_tx_fifo[11U]  = 
#line 235
  {      3U,      2U,      1U,      0U, 
        0U,      4U,      2U,      5U, 
        4U,      255U,      5U};
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static int iwl_alive_notify(struct iwl_priv *priv ) 
{ 
  u8 const   *queue_to_txf ;
  u8 n_queues ;
  int ret ;
  int i ;
  int tmp ;

  {
#line 256
  iwl_trans_fw_alive(priv->trans, 0U);
#line 258
  if ((int )(priv->fw)->ucode_capa.flags & 1 && (int )(priv->nvm_data)->sku_cap_ipan_enable) {
#line 260
    n_queues = 11U;
#line 261
    queue_to_txf = (u8 const   *)(& iwlagn_ipan_queue_to_tx_fifo);
  } else {
#line 263
    n_queues = 4U;
#line 264
    queue_to_txf = (u8 const   *)(& iwlagn_default_queue_to_tx_fifo);
  }
#line 267
  i = 0;
#line 267
  goto ldv_54305;
  ldv_54304: ;
#line 268
  if ((unsigned int )((unsigned char )*(queue_to_txf + (unsigned long )i)) != 255U) {
#line 269
    iwl_trans_ac_txq_enable(priv->trans, i, (int )*(queue_to_txf + (unsigned long )i),
                            0U);
  } else {

  }
#line 267
  i = i + 1;
  ldv_54305: ;
#line 267
  if ((int )n_queues > i) {
#line 269
    goto ldv_54304;
  } else {

  }
#line 272
  priv->passive_no_rx = 0;
#line 273
  priv->transport_queue_stop = 0UL;
#line 275
  ret = iwl_send_wimax_coex(priv);
#line 276
  if (ret != 0) {
#line 277
    return (ret);
  } else {

  }
#line 279
  if (! ((_Bool )(priv->lib)->no_xtal_calib)) {
#line 280
    ret = iwl_set_Xtal_calib(priv);
#line 281
    if (ret != 0) {
#line 282
      return (ret);
    } else {

    }
  } else {

  }
#line 285
  tmp = iwl_send_calib_results(priv);
#line 285
  return (tmp);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static bool iwl_alive_fn(struct iwl_notif_wait_data *notif_wait , struct iwl_rx_packet *pkt ,
                         void *data ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_notif_wait_data  const  *__mptr ;
  struct iwl_alive_data *alive_data ;
  struct iwl_alive_resp *palive ;

  {
#line 297
  __mptr = (struct iwl_notif_wait_data  const  *)notif_wait;
#line 297
  priv = (struct iwl_priv *)__mptr + 0xfffffffffffff5f8UL;
#line 298
  alive_data = (struct iwl_alive_data *)data;
#line 301
  palive = (struct iwl_alive_resp *)(& pkt->data);
#line 303
  __iwl_dbg(priv->dev, 65536U, 0, "iwl_alive_fn", "Alive ucode status 0x%08X revision 0x%01X 0x%01X\n",
            palive->is_valid, (int )palive->ver_type, (int )palive->ver_subtype);
#line 308
  priv->device_pointers.error_event_table = palive->error_event_table_ptr;
#line 310
  priv->device_pointers.log_event_table = palive->log_event_table_ptr;
#line 313
  alive_data->subtype = palive->ver_subtype;
#line 314
  alive_data->valid = palive->is_valid == 1U;
#line 316
  return (1);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
int iwl_load_ucode_wait_alive(struct iwl_priv *priv , enum iwl_ucode_type ucode_type ) 
{ 
  struct iwl_notification_wait alive_wait ;
  struct iwl_alive_data alive_data ;
  struct fw_img  const  *fw ;
  int ret ;
  enum iwl_ucode_type old_type ;
  u8 alive_cmd[1U] ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
#line 330
  alive_cmd[0] = 1U;
#line 332
  fw = iwl_get_ucode_image(priv, ucode_type);
#line 333
  __ret_warn_on = (unsigned long )fw == (unsigned long )((struct fw_img  const  *)0);
#line 333
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 333
  if (tmp != 0L) {
#line 333
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c",
                       333);
  } else {

  }
#line 333
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 333
  if (tmp___0 != 0L) {
#line 334
    return (-22);
  } else {

  }
#line 336
  old_type = priv->cur_ucode;
#line 337
  priv->cur_ucode = ucode_type;
#line 338
  priv->ucode_loaded = 0;
#line 340
  iwl_init_notification_wait(& priv->notif_wait, & alive_wait, (u8 const   *)(& alive_cmd),
                             1, & iwl_alive_fn, (void *)(& alive_data));
#line 344
  ret = iwl_trans_start_fw(priv->trans, fw, 0);
#line 345
  if (ret != 0) {
#line 346
    priv->cur_ucode = old_type;
#line 347
    iwl_remove_notification(& priv->notif_wait, & alive_wait);
#line 348
    return (ret);
  } else {

  }
#line 355
  ret = iwl_wait_notification(& priv->notif_wait, & alive_wait, 250UL);
#line 357
  if (ret != 0) {
#line 358
    priv->cur_ucode = old_type;
#line 359
    return (ret);
  } else {

  }
#line 362
  if (! alive_data.valid) {
#line 363
    __iwl_err(priv->dev, 0, 0, "Loaded ucode is not valid!\n");
#line 364
    priv->cur_ucode = old_type;
#line 365
    return (-5);
  } else {

  }
#line 368
  priv->ucode_loaded = 1;
#line 370
  if ((unsigned int )ucode_type != 2U) {
#line 372
    msleep(5U);
  } else {

  }
#line 375
  ret = iwl_alive_notify(priv);
#line 376
  if (ret != 0) {
#line 377
    __iwl_warn(priv->dev, "Could not complete ALIVE transition: %d\n", ret);
#line 379
    priv->cur_ucode = old_type;
#line 380
    return (ret);
  } else {

  }
#line 383
  return (0);
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
static bool iwlagn_wait_calib(struct iwl_notif_wait_data *notif_wait , struct iwl_rx_packet *pkt ,
                              void *data ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_calib_hdr *hdr ;
  int __ret_warn_on ;
  long tmp ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
#line 389
  priv = (struct iwl_priv *)data;
#line 392
  if ((unsigned int )pkt->hdr.cmd != 102U) {
#line 393
    __ret_warn_on = (unsigned int )pkt->hdr.cmd != 103U;
#line 393
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 393
    if (tmp != 0L) {
#line 393
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c",
                         393);
    } else {

    }
#line 393
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 394
    return (1);
  } else {

  }
#line 397
  hdr = (struct iwl_calib_hdr *)(& pkt->data);
#line 399
  tmp___0 = iwl_rx_packet_payload_len((struct iwl_rx_packet  const  *)pkt);
#line 399
  tmp___1 = iwl_calib_set(priv, (struct iwl_calib_hdr  const  *)hdr, (int )tmp___0);
#line 399
  if (tmp___1 != 0) {
#line 400
    __iwl_err(priv->dev, 0, 0, "Failed to record calibration data %d\n", (int )hdr->op_code);
  } else {

  }
#line 403
  return (0);
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c"
int iwl_run_init_ucode(struct iwl_priv *priv ) 
{ 
  struct iwl_notification_wait calib_wait ;
  u8 calib_complete[2U] ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 409
  calib_complete[0] = 102U;
#line 409
  calib_complete[1] = 103U;
#line 415
  if (debug_locks != 0) {
#line 415
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 415
    if (tmp == 0) {
#line 415
      tmp___0 = 1;
    } else {
#line 415
      tmp___0 = 0;
    }
  } else {
#line 415
    tmp___0 = 0;
  }
#line 415
  __ret_warn_on = tmp___0;
#line 415
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 415
  if (tmp___1 != 0L) {
#line 415
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.c",
                       415);
  } else {

  }
#line 415
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 418
  if ((unsigned int )(priv->fw)->img[1].sec[0].len == 0U) {
#line 419
    return (0);
  } else {

  }
#line 421
  iwl_init_notification_wait(& priv->notif_wait, & calib_wait, (u8 const   *)(& calib_complete),
                             2, & iwlagn_wait_calib, (void *)priv);
#line 426
  ret = iwl_load_ucode_wait_alive(priv, 1);
#line 427
  if (ret != 0) {
#line 428
    goto error;
  } else {

  }
#line 430
  ret = iwl_init_alive_start(priv);
#line 431
  if (ret != 0) {
#line 432
    goto error;
  } else {

  }
#line 438
  ret = iwl_wait_notification(& priv->notif_wait, & calib_wait, 500UL);
#line 441
  goto out;
  error: 
#line 444
  iwl_remove_notification(& priv->notif_wait, & calib_wait);
  out: 
#line 447
  iwl_trans_stop_device(priv->trans);
#line 448
  priv->ucode_loaded = 0;
#line 450
  return (ret);
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
bool ldv_queue_work_on_205(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 577
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_work_7(ldv_func_arg3, 2);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
bool ldv_queue_delayed_work_on_206(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_work_7(& ldv_func_arg3->work, 2);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
bool ldv_queue_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_7(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
void ldv_flush_workqueue_208(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 609
  flush_workqueue(ldv_func_arg1);
#line 611
  call_and_disable_all_7(2);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
bool ldv_queue_delayed_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 618
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 618
  ldv_func_res = tmp;
#line 620
  activate_work_7(& ldv_func_arg3->work, 2);
#line 622
  return (ldv_func_res);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
void ldv_mutex_lock_210(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
void ldv_mutex_unlock_211(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 638
  mutex_unlock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
void ldv_mutex_lock_212(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 646
  mutex_lock(ldv_func_arg1);
#line 647
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
int ldv_mutex_trylock_213(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
void ldv_mutex_unlock_214(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 665
  mutex_unlock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
void ldv_mutex_unlock_215(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 673
  mutex_unlock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/ucode.o.c.prepared"
void ldv_mutex_lock_216(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 681
  mutex_lock(ldv_func_arg1);
#line 682
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 55 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 


  {
#line 57
  return ((__u32 )*p);
}
}
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 333 "include/linux/lockdep.h"
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
#line 337
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_241(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_239(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_242(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_243(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
void ldv_mutex_lock_238(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_240(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_244(struct mutex *ldv_func_arg1 ) ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add___1(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6557;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6557;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6557;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6557;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6557: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub___1(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6569;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6569;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6569;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6569;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6569: ;
#line 79
  return;
}
}
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField17.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField17.rlock);
#line 358
  return;
}
}
#line 268 "include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void) 
{ 


  {
#line 270
  __preempt_count_add___1(1);
#line 270
  __asm__  volatile   ("": : : "memory");
#line 271
  return;
}
}
#line 273 "include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void) 
{ 


  {
#line 275
  __asm__  volatile   ("": : : "memory");
#line 275
  __preempt_count_sub___1(1);
#line 276
  return;
}
}
#line 447 "include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map ) 
{ 


  {
#line 449
  lock_acquire(map, 0U, 0, 2, 0, (struct lockdep_map *)0, 0UL);
#line 450
  return;
}
}
#line 452 "include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map ) 
{ 


  {
#line 454
  lock_release(map, 1, 0UL);
#line 455
  return;
}
}
#line 457
extern struct lockdep_map rcu_lock_map ;
#line 463
extern int rcu_read_lock_held(void) ;
#line 843 "include/linux/rcupdate.h"
__inline static void rcu_read_lock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 845
  __rcu_read_lock();
#line 847
  rcu_lock_acquire(& rcu_lock_map);
#line 848
  tmp = debug_lockdep_rcu_enabled();
#line 848
  if (tmp != 0 && ! __warned) {
#line 848
    tmp___0 = rcu_is_watching();
#line 848
    if (tmp___0) {
#line 848
      tmp___1 = 0;
    } else {
#line 848
      tmp___1 = 1;
    }
#line 848
    if (tmp___1) {
#line 848
      __warned = 1;
#line 848
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 849, "rcu_read_lock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 851
  return;
}
}
#line 897 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 899
  tmp = debug_lockdep_rcu_enabled();
#line 899
  if (tmp != 0 && ! __warned) {
#line 899
    tmp___0 = rcu_is_watching();
#line 899
    if (tmp___0) {
#line 899
      tmp___1 = 0;
    } else {
#line 899
      tmp___1 = 1;
    }
#line 899
    if (tmp___1) {
#line 899
      __warned = 1;
#line 899
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 900, "rcu_read_unlock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 902
  __rcu_read_unlock();
#line 903
  rcu_lock_release(& rcu_lock_map);
#line 904
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_233(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_235(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_234(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_237(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_236(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___2(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_233(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 290 "include/linux/slab.h"
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 852 "include/linux/skbuff.h"
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 1011 "include/linux/skbuff.h"
__inline static int skb_queue_empty(struct sk_buff_head  const  *list ) 
{ 


  {
#line 1013
  return ((unsigned long )((struct sk_buff  const  *)list->next) == (unsigned long )((struct sk_buff  const  *)list));
}
}
#line 1259 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_peek(struct sk_buff_head  const  *list_ ) 
{ 
  struct sk_buff *skb ;

  {
#line 1261
  skb = list_->next;
#line 1263
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)list_)) {
#line 1264
    skb = (struct sk_buff *)0;
  } else {

  }
#line 1265
  return (skb);
}
}
#line 1331 "include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1333
  tmp = (struct sk_buff *)list;
#line 1333
  list->next = tmp;
#line 1333
  list->prev = tmp;
#line 1334
  list->qlen = 0U;
#line 1335
  return;
}
}
#line 1520 "include/linux/skbuff.h"
__inline static void __skb_unlink(struct sk_buff *skb , struct sk_buff_head *list ) 
{ 
  struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *tmp ;

  {
#line 1524
  list->qlen = list->qlen - 1U;
#line 1525
  next = skb->__annonCompField68.__annonCompField67.next;
#line 1526
  prev = skb->__annonCompField68.__annonCompField67.prev;
#line 1527
  tmp = (struct sk_buff *)0;
#line 1527
  skb->__annonCompField68.__annonCompField67.prev = tmp;
#line 1527
  skb->__annonCompField68.__annonCompField67.next = tmp;
#line 1528
  next->__annonCompField68.__annonCompField67.prev = prev;
#line 1529
  prev->__annonCompField68.__annonCompField67.next = next;
#line 1530
  return;
}
}
#line 1541 "include/linux/skbuff.h"
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
#line 1543
  tmp = skb_peek((struct sk_buff_head  const  *)list);
#line 1543
  skb = tmp;
#line 1544
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1545
    __skb_unlink(skb, list);
  } else {

  }
#line 1546
  return (skb);
}
}
#line 1692
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 281 "include/linux/ieee80211.h"
__inline static int ieee80211_has_morefrags(__le16 fc ) 
{ 


  {
#line 283
  return (((int )fc & 1024) != 0);
}
}
#line 335 "include/linux/ieee80211.h"
__inline static int ieee80211_is_mgmt(__le16 fc ) 
{ 


  {
#line 337
  return (((int )fc & 12) == 0);
}
}
#line 393 "include/linux/ieee80211.h"
__inline static int ieee80211_is_assoc_req(__le16 fc ) 
{ 


  {
#line 395
  return (((int )fc & 252) == 0);
}
}
#line 413 "include/linux/ieee80211.h"
__inline static int ieee80211_is_reassoc_req(__le16 fc ) 
{ 


  {
#line 415
  return (((int )fc & 252) == 32);
}
}
#line 443 "include/linux/ieee80211.h"
__inline static int ieee80211_is_probe_resp(__le16 fc ) 
{ 


  {
#line 445
  return (((int )fc & 252) == 80);
}
}
#line 483 "include/linux/ieee80211.h"
__inline static int ieee80211_is_auth(__le16 fc ) 
{ 


  {
#line 485
  return (((int )fc & 252) == 176);
}
}
#line 513 "include/linux/ieee80211.h"
__inline static int ieee80211_is_back_req(__le16 fc ) 
{ 


  {
#line 515
  return (((int )fc & 252) == 132);
}
}
#line 603 "include/linux/ieee80211.h"
__inline static int ieee80211_is_qos_nullfunc(__le16 fc ) 
{ 


  {
#line 605
  return (((int )fc & 252) == 200);
}
}
#line 3689 "include/net/cfg80211.h"
extern unsigned int ieee80211_hdrlen(__le16  ) ;
#line 3888 "include/net/mac80211.h"
extern void ieee80211_tx_status(struct ieee80211_hw * , struct sk_buff * ) ;
#line 4314
extern void ieee80211_get_tkip_p2k(struct ieee80211_key_conf * , struct sk_buff * ,
                                   u8 * ) ;
#line 4707
extern void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif * , u8 const   * ,
                                             u16  ) ;
#line 4733
extern void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif * , u8 const   * ,
                                            u16  ) ;
#line 4747
extern struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif * , u8 const   * ) ;
#line 5179 "include/net/mac80211.h"
__inline static s8 rate_lowest_index___0(struct ieee80211_supported_band *sband ,
                                         struct ieee80211_sta *sta ) 
{ 
  int i ;
  int tmp ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 5184
  i = 0;
#line 5184
  goto ldv_49800;
  ldv_49799: 
#line 5185
  tmp = rate_supported(sta, sband->band, i);
#line 5185
  if (tmp != 0) {
#line 5186
    return ((s8 )i);
  } else {

  }
#line 5184
  i = i + 1;
  ldv_49800: ;
#line 5184
  if (sband->n_bitrates > i) {
#line 5186
    goto ldv_49799;
  } else {

  }
#line 5189
  __ret_warn_once = 1;
#line 5189
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 5189
  if (tmp___2 != 0L) {
#line 5189
    __ret_warn_on = ! __warned;
#line 5189
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 5189
    if (tmp___0 != 0L) {
#line 5189
      warn_slowpath_null("include/net/mac80211.h", 5189);
    } else {

    }
#line 5189
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 5189
    if (tmp___1 != 0L) {
#line 5189
      __warned = 1;
    } else {

    }
  } else {

  }
#line 5189
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 5192
  return (0);
}
}
#line 297 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void *rxb_addr(struct iwl_rx_cmd_buffer *r ) 
{ 
  void *tmp ;

  {
#line 299
  tmp = lowmem_page_address((struct page  const  *)r->_page);
#line 299
  return ((void *)((unsigned long )tmp + (unsigned long )r->_offset));
}
}
#line 805 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static struct iwl_device_cmd *iwl_trans_alloc_tx_cmd(struct iwl_trans *trans ) 
{ 
  u8 *dev_cmd_ptr ;
  void *tmp ;
  long tmp___0 ;

  {
#line 807
  tmp = kmem_cache_alloc(trans->dev_cmd_pool, 32U);
#line 807
  dev_cmd_ptr = (u8 *)tmp;
#line 809
  tmp___0 = ldv__builtin_expect((unsigned long )dev_cmd_ptr == (unsigned long )((u8 *)0U),
                             0L);
#line 809
  if (tmp___0 != 0L) {
#line 810
    return ((struct iwl_device_cmd *)0);
  } else {

  }
#line 812
  return ((struct iwl_device_cmd *)(dev_cmd_ptr + trans->dev_cmd_headroom));
}
}
#line 824 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static int iwl_trans_tx(struct iwl_trans *trans , struct sk_buff *skb , struct iwl_device_cmd *dev_cmd ,
                                 int queue ) 
{ 
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 827
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& trans->status));
#line 827
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 827
  if (tmp___0 != 0L) {
#line 828
    return (-5);
  } else {

  }
#line 830
  tmp___1 = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
#line 830
  if (tmp___1 != 0L) {
#line 831
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_tx", (unsigned int )trans->state);
  } else {

  }
#line 833
  tmp___2 = (*((trans->ops)->tx))(trans, skb, dev_cmd, queue);
#line 833
  return (tmp___2);
}
}
#line 836 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_reclaim(struct iwl_trans *trans , int queue , int ssn ,
                                       struct sk_buff_head *skbs ) 
{ 
  long tmp ;

  {
#line 839
  tmp = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
#line 839
  if (tmp != 0L) {
#line 840
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_reclaim", (unsigned int )trans->state);
  } else {

  }
#line 842
  (*((trans->ops)->reclaim))(trans, queue, ssn, skbs);
#line 843
  return;
}
}
#line 845 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_txq_disable(struct iwl_trans *trans , int queue , bool configure_scd ) 
{ 


  {
#line 848
  (*((trans->ops)->txq_disable))(trans, queue, (int )configure_scd);
#line 849
  return;
}
}
#line 864 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_txq_enable(struct iwl_trans *trans , int queue , int fifo ,
                                          int sta_id , int tid , int frame_limit ,
                                          u16 ssn , unsigned int queue_wdg_timeout ) 
{ 
  struct iwl_trans_txq_scd_cfg cfg ;

  {
#line 869
  cfg.fifo = (unsigned char )fifo;
#line 869
  cfg.sta_id = (signed char )sta_id;
#line 869
  cfg.tid = (unsigned char )tid;
#line 869
  cfg.aggregate = sta_id >= 0;
#line 869
  cfg.frame_limit = frame_limit;
#line 877
  iwl_trans_txq_enable_cfg(trans, queue, (int )ssn, (struct iwl_trans_txq_scd_cfg  const  *)(& cfg),
                           queue_wdg_timeout);
#line 878
  return;
}
}
#line 202 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
int iwlagn_hwrate_to_mac80211_idx(u32 rate_n_flags , enum ieee80211_band band ) ;
#line 219
int iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                  struct iwl_device_cmd *cmd ) ;
#line 222
int iwlagn_rx_reply_tx(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) ;
#line 225 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static u32 iwl_tx_status_to_mac80211(u32 status ) 
{ 


  {
#line 227
  status = status & 255U;
#line 229
  switch (status) {
  case 1U: ;
  case 2U: ;
#line 232
  return (512U);
  case 136U: ;
  case 144U: ;
#line 235
  return (256U);
  default: ;
#line 237
  return (0U);
  }
}
}
#line 241 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static bool iwl_is_tx_success(u32 status ) 
{ 


  {
#line 243
  status = status & 255U;
#line 244
  return ((bool )(status == 1U || status == 2U));
}
}
#line 296
char const   *iwl_get_tx_fail_reason(u32 status ) ;
#line 297
char const   *iwl_get_agg_tx_fail_reason(u16 status ) ;
#line 374
int iwl_sta_tx_modify_enable_tid(struct iwl_priv *priv , int sta_id , int tid ) ;
#line 379
void iwl_sta_modify_sleep_tx_count(struct iwl_priv *priv , int sta_id , int cnt ) ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static u8 const   tid_to_ac[8U]  = 
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
  {      2U,      3U,      3U,      2U, 
        1U,      1U,      0U,      0U};
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_tx_cmd_protection(struct iwl_priv *priv , struct ieee80211_tx_info *info ,
                                     __le16 fc , __le32 *tx_flags ) 
{ 


  {
#line 55
  if (((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags & 1 || ((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags & 2) != 0) || (info->flags & 64U) != 0U) {
#line 58
    *tx_flags = *tx_flags | 1U;
  } else {

  }
#line 59
  return;
}
}
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_tx_cmd_build_basic(struct iwl_priv *priv , struct sk_buff *skb ,
                                      struct iwl_tx_cmd *tx_cmd , struct ieee80211_tx_info *info ,
                                      struct ieee80211_hdr *hdr , u8 sta_id ) 
{ 
  __le16 fc ;
  __le32 tx_flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u8 *qc ;
  u8 *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 70
  fc = hdr->frame_control;
#line 71
  tx_flags = tx_cmd->tx_flags;
#line 73
  tx_cmd->stop_time.life_time = 4294967295U;
#line 75
  if ((info->flags & 4U) == 0U) {
#line 76
    tx_flags = tx_flags | 8U;
  } else {
#line 78
    tx_flags = tx_flags & 4294967287U;
  }
#line 80
  tmp___3 = ieee80211_is_probe_resp((int )fc);
#line 80
  if (tmp___3 != 0) {
#line 81
    tx_flags = tx_flags | 65536U;
  } else {
#line 82
    tmp___2 = ieee80211_is_back_req((int )fc);
#line 82
    if (tmp___2 != 0) {
#line 83
      tx_flags = tx_flags | 72U;
    } else
#line 84
    if (((unsigned int )info->band == 0U && (unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 84
      tmp = ieee80211_is_auth((int )fc);
#line 84
      if (tmp != 0) {
#line 90
        tx_flags = tx_flags | 4096U;
      } else {
#line 84
        tmp___0 = ieee80211_is_assoc_req((int )fc);
#line 84
        if (tmp___0 != 0) {
#line 90
          tx_flags = tx_flags | 4096U;
        } else {
#line 84
          tmp___1 = ieee80211_is_reassoc_req((int )fc);
#line 84
          if (tmp___1 != 0) {
#line 90
            tx_flags = tx_flags | 4096U;
          } else
#line 84
          if ((int )info->__annonCompField99.control.flags & 1) {
#line 90
            tx_flags = tx_flags | 4096U;
          } else {

          }
        }
      }
    } else {

    }
  }
#line 93
  tx_cmd->sta_id = sta_id;
#line 94
  tmp___4 = ieee80211_has_morefrags((int )fc);
#line 94
  if (tmp___4 != 0) {
#line 95
    tx_flags = tx_flags | 16384U;
  } else {

  }
#line 97
  tmp___6 = ieee80211_is_data_qos((int )fc);
#line 97
  if (tmp___6 != 0) {
#line 98
    tmp___5 = ieee80211_get_qos_ctl(hdr);
#line 98
    qc = tmp___5;
#line 99
    tx_cmd->tid_tspec = (unsigned int )*qc & 15U;
#line 100
    tx_flags = tx_flags & 4294959103U;
  } else {
#line 102
    tx_cmd->tid_tspec = 8U;
#line 103
    if ((info->flags & 2U) != 0U) {
#line 104
      tx_flags = tx_flags | 8192U;
    } else {
#line 106
      tx_flags = tx_flags & 4294959103U;
    }
  }
#line 109
  iwlagn_tx_cmd_protection(priv, info, (int )fc, & tx_flags);
#line 111
  tx_flags = tx_flags & 4294963455U;
#line 112
  tmp___9 = ieee80211_is_mgmt((int )fc);
#line 112
  if (tmp___9 != 0) {
#line 113
    tmp___7 = ieee80211_is_assoc_req((int )fc);
#line 113
    if (tmp___7 != 0) {
#line 114
      tx_cmd->timeout.pm_frame_timeout = 3U;
    } else {
#line 113
      tmp___8 = ieee80211_is_reassoc_req((int )fc);
#line 113
      if (tmp___8 != 0) {
#line 114
        tx_cmd->timeout.pm_frame_timeout = 3U;
      } else {
#line 116
        tx_cmd->timeout.pm_frame_timeout = 2U;
      }
    }
  } else {
#line 118
    tx_cmd->timeout.pm_frame_timeout = 0U;
  }
#line 121
  tx_cmd->driver_txop = 0U;
#line 122
  tx_cmd->tx_flags = tx_flags;
#line 123
  tx_cmd->next_frame_len = 0U;
#line 124
  return;
}
}
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_tx_cmd_build_rate(struct iwl_priv *priv , struct iwl_tx_cmd *tx_cmd ,
                                     struct ieee80211_tx_info *info , struct ieee80211_sta *sta ,
                                     __le16 fc ) 
{ 
  u32 rate_flags ;
  int rate_idx ;
  u8 rts_retry_limit ;
  u8 data_retry_limit ;
  u8 rate_plcp ;
  u8 _min1 ;
  u8 _min2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  s8 tmp___3 ;
  u8 tmp___4 ;
  u32 tmp___5 ;

  {
#line 138
  if ((int )priv->wowlan) {
#line 139
    rts_retry_limit = 7U;
#line 140
    data_retry_limit = 7U;
  } else {
#line 143
    rts_retry_limit = 60U;
#line 146
    tmp___0 = ieee80211_is_probe_resp((int )fc);
#line 146
    if (tmp___0 != 0) {
#line 147
      data_retry_limit = 3U;
#line 149
      _min1 = data_retry_limit;
#line 149
      _min2 = rts_retry_limit;
#line 149
      rts_retry_limit = (u8 )((int )_min1 < (int )_min2 ? _min1 : _min2);
    } else {
#line 150
      tmp = ieee80211_is_back_req((int )fc);
#line 150
      if (tmp != 0) {
#line 151
        data_retry_limit = 60U;
      } else {
#line 153
        data_retry_limit = 15U;
      }
    }
  }
#line 156
  tx_cmd->data_retry_limit = data_retry_limit;
#line 157
  tx_cmd->rts_retry_limit = rts_retry_limit;
#line 161
  tmp___2 = ieee80211_is_data((int )fc);
#line 161
  if (tmp___2 != 0) {
#line 162
    tx_cmd->initial_rate_index = 0U;
#line 163
    tx_cmd->tx_flags = tx_cmd->tx_flags | 16U;
#line 164
    return;
  } else {
#line 165
    tmp___1 = ieee80211_is_back_req((int )fc);
#line 165
    if (tmp___1 != 0) {
#line 166
      tx_cmd->tx_flags = tx_cmd->tx_flags | 16U;
    } else {

    }
  }
#line 174
  rate_idx = (int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].idx;
#line 175
  if ((((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags & 8) != 0 || rate_idx < 0) || rate_idx > 12) {
#line 177
    tmp___3 = rate_lowest_index___0((struct ieee80211_supported_band *)(& (priv->nvm_data)->bands) + (unsigned long )info->band,
                                    sta);
#line 177
    rate_idx = (int )tmp___3;
  } else {

  }
#line 180
  if ((unsigned int )info->band == 1U) {
#line 181
    rate_idx = rate_idx + 4;
  } else {

  }
#line 183
  rate_plcp = iwl_rates[rate_idx].plcp;
#line 185
  rate_flags = 0U;
#line 188
  if (rate_idx >= 0 && rate_idx <= 3) {
#line 189
    rate_flags = rate_flags | 512U;
  } else {

  }
#line 192
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && (int )priv->bt_full_concurrent) {
#line 196
    tmp___4 = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 196
    priv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, (int )priv->mgmt_tx_ant, (int )tmp___4);
  } else {
#line 199
    priv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, (int )priv->mgmt_tx_ant, (int )(priv->nvm_data)->valid_tx_ant);
  }
#line 202
  tmp___5 = iwl_ant_idx_to_flags((int )priv->mgmt_tx_ant);
#line 202
  rate_flags = tmp___5 | rate_flags;
#line 205
  tx_cmd->rate_n_flags = iwl_hw_set_rate_n_flags((int )rate_plcp, rate_flags);
#line 206
  return;
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_tx_cmd_build_hwcrypto(struct iwl_priv *priv , struct ieee80211_tx_info *info ,
                                         struct iwl_tx_cmd *tx_cmd , struct sk_buff *skb_frag ) 
{ 
  struct ieee80211_key_conf *keyconf ;

  {
#line 213
  keyconf = info->__annonCompField99.control.hw_key;
#line 215
  switch (keyconf->cipher) {
  case 1027076U: 
#line 217
  tx_cmd->sec_ctl = 2U;
#line 218
  memcpy((void *)(& tx_cmd->key), (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
#line 219
  if ((info->flags & 64U) != 0U) {
#line 220
    tx_cmd->tx_flags = tx_cmd->tx_flags | 4194304U;
  } else {

  }
#line 221
  goto ldv_55146;
  case 1027074U: 
#line 224
  tx_cmd->sec_ctl = 3U;
#line 225
  ieee80211_get_tkip_p2k(keyconf, skb_frag, (u8 *)(& tx_cmd->key));
#line 226
  goto ldv_55146;
  case 1027077U: 
#line 229
  tx_cmd->sec_ctl = (u8 )((unsigned int )tx_cmd->sec_ctl | 8U);
  case 1027073U: 
#line 232
  tx_cmd->sec_ctl = (u8 )((int )((signed char )tx_cmd->sec_ctl) | ((int )((signed char )((int )keyconf->keyidx << 6)) | 1));
#line 235
  memcpy((void *)(& tx_cmd->key) + 3U, (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
#line 237
  __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_cmd_build_hwcrypto", "Configuring packet for WEP encryption with key %d\n",
            (int )keyconf->keyidx);
#line 239
  goto ldv_55146;
  default: 
#line 242
  __iwl_err(priv->dev, 0, 0, "Unknown encode cipher %x\n", keyconf->cipher);
#line 243
  goto ldv_55146;
  }
  ldv_55146: ;
#line 246
  return;
}
}
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static int iwl_sta_id_or_broadcast(struct iwl_rxon_context *context , struct ieee80211_sta *sta ) 
{ 
  int sta_id ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 262
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) {
#line 263
    return ((int )context->bcast_sta_id);
  } else {

  }
#line 265
  sta_id = iwl_sta_id(sta);
#line 271
  __ret_warn_on = sta_id == 255;
#line 271
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 271
  if (tmp != 0L) {
#line 271
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                       271);
  } else {

  }
#line 271
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 273
  return (sta_id);
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
int iwlagn_tx_skb(struct iwl_priv *priv , struct ieee80211_sta *sta , struct sk_buff *skb ) 
{ 
  struct ieee80211_hdr *hdr ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_device_cmd *dev_cmd ;
  struct iwl_tx_cmd *tx_cmd ;
  __le16 fc ;
  u8 hdr_len ;
  u16 len ;
  u16 seq_number ;
  u8 sta_id ;
  u8 tid ;
  bool is_agg ;
  bool is_data_qos ;
  int txq_id ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct iwl_wipan_noa_data *noa_data ;
  struct iwl_wipan_noa_data *________p1 ;
  struct iwl_wipan_noa_data *_________p1 ;
  union __anonunion___u_482 __u ;
  bool __warned ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  u8 *qc ;
  struct iwl_tid_data *tid_data ;
  bool __warned___0 ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  bool __warned___1 ;
  int __ret_warn_once___0 ;
  int __ret_warn_on___0 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  bool __warned___2 ;
  int __ret_warn_once___1 ;
  int __ret_warn_on___1 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 283
  hdr = (struct ieee80211_hdr *)skb->data;
#line 284
  tmp = IEEE80211_SKB_CB(skb);
#line 284
  info = tmp;
#line 285
  sta_priv = (struct iwl_station_priv *)0;
#line 286
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 291
  seq_number = 0U;
#line 292
  tid = 8U;
#line 293
  is_agg = 0;
#line 293
  is_data_qos = 0;
#line 296
  if ((unsigned long )info->__annonCompField99.control.vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 297
    ctx = iwl_rxon_ctx_from_vif(info->__annonCompField99.control.vif);
  } else {

  }
#line 299
  tmp___0 = iwl_is_rfkill(priv);
#line 299
  if (tmp___0 != 0) {
#line 300
    __iwl_dbg(priv->dev, 8192U, 0, "iwlagn_tx_skb", "Dropping - RF KILL\n");
#line 301
    goto drop_unlock_priv;
  } else {

  }
#line 304
  fc = hdr->frame_control;
#line 307
  tmp___3 = ieee80211_is_auth((int )fc);
#line 307
  if (tmp___3 != 0) {
#line 308
    __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_skb", "Sending AUTH frame\n");
  } else {
#line 309
    tmp___2 = ieee80211_is_assoc_req((int )fc);
#line 309
    if (tmp___2 != 0) {
#line 310
      __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_skb", "Sending ASSOC frame\n");
    } else {
#line 311
      tmp___1 = ieee80211_is_reassoc_req((int )fc);
#line 311
      if (tmp___1 != 0) {
#line 312
        __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_skb", "Sending REASSOC frame\n");
      } else {

      }
    }
  }
#line 315
  tmp___8 = ieee80211_is_probe_resp((int )fc);
#line 315
  tmp___9 = ldv__builtin_expect(tmp___8 != 0, 0L);
#line 315
  if (tmp___9 != 0L) {
#line 317
    __read_once_size((void const volatile   *)(& priv->noa_data), (void *)(& __u.__c),
                     8);
#line 317
    _________p1 = __u.__val;
#line 317
    ________p1 = _________p1;
#line 317
    tmp___4 = debug_lockdep_rcu_enabled();
#line 317
    if (tmp___4 != 0 && ! __warned) {
#line 317
      tmp___5 = rcu_read_lock_held();
#line 317
      if (tmp___5 == 0) {
#line 317
        __warned = 1;
#line 317
        lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                               317, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 317
    noa_data = ________p1;
#line 319
    if ((unsigned long )noa_data != (unsigned long )((struct iwl_wipan_noa_data *)0)) {
#line 319
      tmp___7 = pskb_expand_head(skb, 0, (int )noa_data->length, 32U);
#line 319
      if (tmp___7 == 0) {
#line 322
        tmp___6 = skb_put(skb, noa_data->length);
#line 322
        memcpy((void *)tmp___6, (void const   *)(& noa_data->data), (size_t )noa_data->length);
#line 324
        hdr = (struct ieee80211_hdr *)skb->data;
      } else {

      }
    } else {

    }
  } else {

  }
#line 328
  tmp___10 = ieee80211_hdrlen((int )fc);
#line 328
  hdr_len = (u8 )tmp___10;
#line 331
  tmp___12 = ieee80211_is_data((int )fc);
#line 331
  if (tmp___12 == 0) {
#line 332
    sta_id = ctx->bcast_sta_id;
  } else {
#line 335
    tmp___11 = iwl_sta_id_or_broadcast(ctx, sta);
#line 335
    sta_id = (u8 )tmp___11;
#line 336
    if ((unsigned int )sta_id == 255U) {
#line 337
      __iwl_dbg(priv->dev, 8192U, 0, "iwlagn_tx_skb", "Dropping - INVALID STATION: %pM\n",
                (u8 *)(& hdr->addr1));
#line 339
      goto drop_unlock_priv;
    } else {

    }
  }
#line 343
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
#line 344
    sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  } else {

  }
#line 346
  if (((unsigned long )sta_priv != (unsigned long )((struct iwl_station_priv *)0) && (int )sta_priv->asleep) && (info->flags & 131072U) != 0U) {
#line 361
    iwl_sta_modify_sleep_tx_count(priv, (int )sta_id, 1);
  } else {

  }
#line 364
  dev_cmd = iwl_trans_alloc_tx_cmd(priv->trans);
#line 366
  tmp___13 = ldv__builtin_expect((unsigned long )dev_cmd == (unsigned long )((struct iwl_device_cmd *)0),
                              0L);
#line 366
  if (tmp___13 != 0L) {
#line 367
    goto drop_unlock_priv;
  } else {

  }
#line 369
  memset((void *)dev_cmd, 0, 324UL);
#line 370
  dev_cmd->hdr.cmd = 28U;
#line 371
  tx_cmd = (struct iwl_tx_cmd *)(& dev_cmd->payload);
#line 374
  len = (unsigned short )skb->len;
#line 375
  tx_cmd->len = len;
#line 377
  if ((unsigned long )info->__annonCompField99.control.hw_key != (unsigned long )((struct ieee80211_key_conf *)0)) {
#line 378
    iwlagn_tx_cmd_build_hwcrypto(priv, info, tx_cmd, skb);
  } else {

  }
#line 381
  iwlagn_tx_cmd_build_basic(priv, skb, tx_cmd, info, hdr, (int )sta_id);
#line 383
  iwlagn_tx_cmd_build_rate(priv, tx_cmd, info, sta, (int )fc);
#line 385
  memset((void *)(& info->__annonCompField99.status), 0, 40UL);
#line 387
  info->__annonCompField99.driver_data[0] = (void *)ctx;
#line 388
  info->__annonCompField99.driver_data[1] = (void *)dev_cmd;
#line 391
  spin_lock(& priv->sta_lock);
#line 393
  tmp___22 = ieee80211_is_data_qos((int )fc);
#line 393
  if (tmp___22 != 0) {
#line 393
    tmp___23 = ieee80211_is_qos_nullfunc((int )fc);
#line 393
    if (tmp___23 == 0) {
#line 394
      qc = (u8 *)0U;
#line 396
      qc = ieee80211_get_qos_ctl(hdr);
#line 397
      tid = (unsigned int )*qc & 15U;
#line 398
      __ret_warn_once = (unsigned int )tid > 7U;
#line 398
      tmp___16 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 398
      if (tmp___16 != 0L) {
#line 398
        __ret_warn_on = ! __warned___0;
#line 398
        tmp___14 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 398
        if (tmp___14 != 0L) {
#line 398
          warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                             398);
        } else {

        }
#line 398
        tmp___15 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 398
        if (tmp___15 != 0L) {
#line 398
          __warned___0 = 1;
        } else {

        }
      } else {

      }
#line 398
      tmp___17 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 398
      if (tmp___17 != 0L) {
#line 399
        goto drop_unlock_sta;
      } else {

      }
#line 400
      tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
#line 403
      if ((info->flags & 64U) != 0U && (unsigned int )tid_data->agg.state != 2U) {
#line 405
        __iwl_err(priv->dev, 0, 0, "TX_CTL_AMPDU while not in AGG: Tx flags = 0x%08x, agg.state = %d\n",
                  info->flags, (unsigned int )tid_data->agg.state);
#line 408
        __iwl_err(priv->dev, 0, 0, "sta_id = %d, tid = %d seq_num = %d\n", (int )sta_id,
                  (int )tid, (int )tid_data->seq_number >> 4);
#line 411
        goto drop_unlock_sta;
      } else {

      }
#line 417
      __ret_warn_once___0 = (unsigned int )tid_data->agg.state != 2U && (unsigned int )tid_data->agg.state != 0U;
#line 417
      tmp___20 = ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
#line 417
      if (tmp___20 != 0L) {
#line 417
        __ret_warn_on___0 = ! __warned___1;
#line 417
        tmp___18 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 417
        if (tmp___18 != 0L) {
#line 417
          warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                            419, "Tx while agg.state = %d\n", (unsigned int )tid_data->agg.state);
        } else {

        }
#line 417
        tmp___19 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 417
        if (tmp___19 != 0L) {
#line 417
          __warned___1 = 1;
        } else {

        }
      } else {

      }
#line 417
      tmp___21 = ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
#line 417
      if (tmp___21 != 0L) {
#line 420
        goto drop_unlock_sta;
      } else {

      }
#line 422
      seq_number = tid_data->seq_number;
#line 423
      seq_number = (unsigned int )seq_number & 65520U;
#line 424
      hdr->seq_ctrl = (unsigned int )hdr->seq_ctrl & 15U;
#line 425
      hdr->seq_ctrl = (__le16 )((int )hdr->seq_ctrl | (int )seq_number);
#line 426
      seq_number = (unsigned int )seq_number + 16U;
#line 428
      if ((info->flags & 64U) != 0U) {
#line 429
        is_agg = 1;
      } else {

      }
#line 430
      is_data_qos = 1;
    } else {

    }
  } else {

  }
#line 434
  memcpy((void *)(& tx_cmd->hdr), (void const   *)hdr, (size_t )hdr_len);
#line 436
  txq_id = (int )info->hw_queue;
#line 438
  if ((int )is_agg) {
#line 439
    txq_id = (int )priv->tid_data[(int )sta_id][(int )tid].agg.txq_id;
  } else
#line 440
  if ((info->flags & 32U) != 0U) {
#line 445
    hdr->frame_control = (__le16 )((unsigned int )hdr->frame_control | 8192U);
  } else {

  }
#line 449
  __ret_warn_once___1 = (int )is_agg && (int )priv->queue_to_mac80211[txq_id] != (int )info->hw_queue;
#line 449
  tmp___26 = ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
#line 449
  if (tmp___26 != 0L) {
#line 449
    __ret_warn_on___1 = ! __warned___2;
#line 449
    tmp___24 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 449
    if (tmp___24 != 0L) {
#line 449
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                         450);
    } else {

    }
#line 449
    tmp___25 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 449
    if (tmp___25 != 0L) {
#line 449
      __warned___2 = 1;
    } else {

    }
  } else {

  }
#line 449
  ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
#line 452
  __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_skb", "TX to [%d|%d] Q:%d - seq: 0x%x\n",
            (int )sta_id, (int )tid, txq_id, (int )seq_number);
#line 455
  tmp___27 = iwl_trans_tx(priv->trans, skb, dev_cmd, txq_id);
#line 455
  if (tmp___27 != 0) {
#line 456
    goto drop_unlock_sta;
  } else {

  }
#line 458
  if ((int )is_data_qos) {
#line 458
    tmp___28 = ieee80211_has_morefrags((int )fc);
#line 458
    if (tmp___28 == 0) {
#line 459
      priv->tid_data[(int )sta_id][(int )tid].seq_number = seq_number;
    } else {

    }
  } else {

  }
#line 461
  spin_unlock(& priv->sta_lock);
#line 470
  if (((unsigned long )sta_priv != (unsigned long )((struct iwl_station_priv *)0) && (int )sta_priv->client) && ! is_agg) {
#line 471
    atomic_inc(& sta_priv->pending_frames);
  } else {

  }
#line 473
  return (0);
  drop_unlock_sta: ;
#line 476
  if ((unsigned long )dev_cmd != (unsigned long )((struct iwl_device_cmd *)0)) {
#line 477
    iwl_trans_free_tx_cmd(priv->trans, dev_cmd);
  } else {

  }
#line 478
  spin_unlock(& priv->sta_lock);
  drop_unlock_priv: ;
#line 480
  return (-1);
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static int iwlagn_alloc_agg_txq(struct iwl_priv *priv , int mq ) 
{ 
  int q ;
  int tmp ;

  {
#line 487
  q = 11;
#line 487
  goto ldv_55216;
  ldv_55215: 
#line 489
  tmp = test_and_set_bit((long )q, (unsigned long volatile   *)(& priv->agg_q_alloc));
#line 489
  if (tmp == 0) {
#line 490
    priv->queue_to_mac80211[q] = (u8 )mq;
#line 491
    return (q);
  } else {

  }
#line 488
  q = q + 1;
  ldv_55216: ;
#line 487
  if ((int )((priv->cfg)->base_params)->num_of_queues > q) {
#line 490
    goto ldv_55215;
  } else {

  }

#line 495
  return (-28);
}
}
#line 498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_dealloc_agg_txq(struct iwl_priv *priv , int q ) 
{ 


  {
#line 500
  clear_bit((long )q, (unsigned long volatile   *)(& priv->agg_q_alloc));
#line 501
  priv->queue_to_mac80211[q] = 255U;
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
int iwlagn_tx_agg_stop(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                       u16 tid ) 
{ 
  struct iwl_tid_data *tid_data ;
  int sta_id ;
  int txq_id ;
  enum iwl_agg_state agg_state ;
  int tmp ;
  int tmp___0 ;

  {
#line 511
  sta_id = iwl_sta_id(sta);
#line 513
  if (sta_id == 255) {
#line 514
    __iwl_err(priv->dev, 0, 0, "Invalid station for AGG tid %d\n", (int )tid);
#line 515
    return (-6);
  } else {

  }
#line 518
  spin_lock_bh(& priv->sta_lock);
#line 520
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
#line 521
  txq_id = (int )tid_data->agg.txq_id;
#line 523
  switch ((unsigned int )tid_data->agg.state) {
  case 3U: 
#line 531
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_stop", "AGG stop before setup done\n");
#line 532
  goto turn_off;
  case 1U: 
#line 538
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_stop", "AGG stop before AGG became operational\n");
#line 539
  goto turn_off;
  case 2U: ;
#line 541
  goto ldv_55237;
  default: 
#line 543
  __iwl_warn(priv->dev, "Stopping AGG while state not ON or starting for %d on %d (%d)\n",
             sta_id, (int )tid, (unsigned int )tid_data->agg.state);
#line 546
  spin_unlock_bh(& priv->sta_lock);
#line 547
  return (0);
  }
  ldv_55237: 
#line 550
  tid_data->agg.ssn = (int )tid_data->seq_number >> 4;
#line 553
  tmp = variable_test_bit((long )txq_id, (unsigned long const volatile   *)(& priv->agg_q_alloc));
#line 553
  if (tmp == 0) {
#line 554
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_stop", "stopping AGG on STA/TID %d/%d but hwq %d not used\n",
              sta_id, (int )tid, txq_id);
  } else
#line 557
  if ((int )tid_data->agg.ssn != (int )tid_data->next_reclaimed) {
#line 558
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_stop", "Can\'t proceed: ssn %d, next_recl = %d\n",
              (int )tid_data->agg.ssn, (int )tid_data->next_reclaimed);
#line 562
    tid_data->agg.state = 4;
#line 563
    spin_unlock_bh(& priv->sta_lock);
#line 564
    return (0);
  } else {

  }
#line 567
  __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_stop", "Can proceed: ssn = next_recl = %d\n",
            (int )tid_data->agg.ssn);
  turn_off: 
#line 570
  agg_state = tid_data->agg.state;
#line 571
  tid_data->agg.state = 0;
#line 573
  spin_unlock_bh(& priv->sta_lock);
#line 575
  tmp___0 = variable_test_bit((long )txq_id, (unsigned long const volatile   *)(& priv->agg_q_alloc));
#line 575
  if (tmp___0 != 0) {
#line 582
    if ((unsigned int )agg_state == 2U) {
#line 583
      iwl_trans_txq_disable(priv->trans, txq_id, 1);
    } else {
#line 585
      __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_stop", "Don\'t disable tx agg: %d\n",
                (unsigned int )agg_state);
    }
#line 587
    iwlagn_dealloc_agg_txq(priv, txq_id);
  } else {

  }
#line 590
  ieee80211_stop_tx_ba_cb_irqsafe(vif, (u8 const   *)(& sta->addr), (int )tid);
#line 592
  return (0);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
int iwlagn_tx_agg_start(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                        u16 tid , u16 *ssn ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  struct iwl_tid_data *tid_data ;
  int sta_id ;
  int txq_id ;
  int ret ;
  long tmp___0 ;

  {
#line 598
  tmp = iwl_rxon_ctx_from_vif(vif);
#line 598
  ctx = tmp;
#line 602
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_start", "TX AGG request on ra = %pM tid = %d\n",
            (u8 *)(& sta->addr), (int )tid);
#line 605
  sta_id = iwl_sta_id(sta);
#line 606
  if (sta_id == 255) {
#line 607
    __iwl_err(priv->dev, 0, 0, "Start AGG on invalid station\n");
#line 608
    return (-6);
  } else {

  }
#line 610
  tmp___0 = ldv__builtin_expect((unsigned int )tid > 7U, 0L);
#line 610
  if (tmp___0 != 0L) {
#line 611
    return (-22);
  } else {

  }
#line 613
  if ((unsigned int )priv->tid_data[sta_id][(int )tid].agg.state != 0U) {
#line 614
    __iwl_err(priv->dev, 0, 0, "Start AGG when state is not IWL_AGG_OFF !\n");
#line 615
    return (-6);
  } else {

  }
#line 618
  txq_id = iwlagn_alloc_agg_txq(priv, (int )ctx->ac_to_queue[(int )tid_to_ac[(int )tid]]);
#line 619
  if (txq_id < 0) {
#line 620
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_start", "No free aggregation queue for %pM/%d\n",
              (u8 *)(& sta->addr), (int )tid);
#line 623
    return (txq_id);
  } else {

  }
#line 626
  ret = iwl_sta_tx_modify_enable_tid(priv, sta_id, (int )tid);
#line 627
  if (ret != 0) {
#line 628
    return (ret);
  } else {

  }
#line 630
  spin_lock_bh(& priv->sta_lock);
#line 631
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
#line 632
  tid_data->agg.ssn = (int )tid_data->seq_number >> 4;
#line 633
  tid_data->agg.txq_id = (u16 )txq_id;
#line 635
  *ssn = tid_data->agg.ssn;
#line 637
  if ((int )*ssn == (int )tid_data->next_reclaimed) {
#line 638
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_start", "Can proceed: ssn = next_recl = %d\n",
              (int )tid_data->agg.ssn);
#line 640
    tid_data->agg.state = 1;
#line 641
    ieee80211_start_tx_ba_cb_irqsafe(vif, (u8 const   *)(& sta->addr), (int )tid);
  } else {
#line 643
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_start", "Can\'t proceed: ssn %d, next_reclaimed = %d\n",
              (int )tid_data->agg.ssn, (int )tid_data->next_reclaimed);
#line 647
    tid_data->agg.state = 3;
  }
#line 649
  spin_unlock_bh(& priv->sta_lock);
#line 651
  return (ret);
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
int iwlagn_tx_agg_flush(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                        u16 tid ) 
{ 
  struct iwl_tid_data *tid_data ;
  enum iwl_agg_state agg_state ;
  int sta_id ;
  int txq_id ;
  int tmp ;
  int tmp___0 ;

  {
#line 660
  sta_id = iwl_sta_id(sta);
#line 666
  spin_lock_bh(& priv->sta_lock);
#line 668
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
#line 669
  txq_id = (int )tid_data->agg.txq_id;
#line 670
  agg_state = tid_data->agg.state;
#line 671
  __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_flush", "Flush AGG: sta %d tid %d q %d state %d\n",
            sta_id, (int )tid, txq_id, (unsigned int )tid_data->agg.state);
#line 674
  tid_data->agg.state = 0;
#line 676
  spin_unlock_bh(& priv->sta_lock);
#line 678
  tmp = iwlagn_txfifo_flush(priv, (u32 )(1UL << txq_id));
#line 678
  if (tmp != 0) {
#line 679
    __iwl_err(priv->dev, 0, 0, "Couldn\'t flush the AGG queue\n");
  } else {

  }
#line 681
  tmp___0 = variable_test_bit((long )txq_id, (unsigned long const volatile   *)(& priv->agg_q_alloc));
#line 681
  if (tmp___0 != 0) {
#line 688
    if ((unsigned int )agg_state == 2U) {
#line 689
      iwl_trans_txq_disable(priv->trans, txq_id, 1);
    } else {
#line 691
      __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_flush", "Don\'t disable tx agg: %d\n",
                (unsigned int )agg_state);
    }
#line 693
    iwlagn_dealloc_agg_txq(priv, txq_id);
  } else {

  }
#line 696
  return (0);
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
int iwlagn_tx_agg_oper(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                       u16 tid , u8 buf_size ) 
{ 
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  int q ;
  int fifo ;
  u16 ssn ;
  int __min1 ;
  int __min2 ;
  u8 _min1 ;
  u8 _min2 ;
  int tmp___0 ;

  {
#line 702
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 703
  tmp = iwl_rxon_ctx_from_vif(vif);
#line 703
  ctx = tmp;
#line 707
  __min1 = (int )buf_size;
#line 707
  __min2 = 63;
#line 707
  buf_size = (u8 )(__min1 < __min2 ? __min1 : __min2);
#line 709
  spin_lock_bh(& priv->sta_lock);
#line 710
  ssn = priv->tid_data[(int )sta_priv->sta_id][(int )tid].agg.ssn;
#line 711
  q = (int )priv->tid_data[(int )sta_priv->sta_id][(int )tid].agg.txq_id;
#line 712
  priv->tid_data[(int )sta_priv->sta_id][(int )tid].agg.state = 2;
#line 713
  spin_unlock_bh(& priv->sta_lock);
#line 715
  fifo = (int )ctx->ac_to_fifo[(int )tid_to_ac[(int )tid]];
#line 717
  iwl_trans_txq_enable(priv->trans, q, fifo, (int )sta_priv->sta_id, (int )tid, (int )buf_size,
                       (int )ssn, 0U);
#line 726
  if ((unsigned int )sta_priv->max_agg_bufsize == 0U) {
#line 727
    sta_priv->max_agg_bufsize = 63U;
  } else {

  }
#line 738
  _min1 = sta_priv->max_agg_bufsize;
#line 738
  _min2 = buf_size;
#line 738
  sta_priv->max_agg_bufsize = (u8 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 740
  if ((int )priv->hw_params.use_rts_for_aggregation) {
#line 746
    sta_priv->lq_sta.lq.general_params.flags = (u8 )((unsigned int )sta_priv->lq_sta.lq.general_params.flags | 1U);
  } else {

  }
#line 749
  priv->agg_tids_count = (u8 )((int )priv->agg_tids_count + 1);
#line 750
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_oper", "priv->agg_tids_count = %u\n",
            (int )priv->agg_tids_count);
#line 753
  sta_priv->lq_sta.lq.agg_params.agg_frame_cnt_limit = sta_priv->max_agg_bufsize;
#line 756
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_oper", "Tx aggregation enabled on ra = %pM tid = %d\n",
            (u8 *)(& sta->addr), (int )tid);
#line 759
  tmp___0 = iwl_send_lq_cmd(priv, ctx, & sta_priv->lq_sta.lq, 1, 0);
#line 759
  return (tmp___0);
}
}
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_check_ratid_empty(struct iwl_priv *priv , int sta_id , u8 tid ) 
{ 
  struct iwl_tid_data *tid_data ;
  enum iwl_rxon_context_id ctx ;
  struct ieee80211_vif *vif ;
  u8 *addr ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 765
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
#line 770
  if (debug_locks != 0) {
#line 770
    tmp = lock_is_held(& priv->sta_lock.__annonCompField17.__annonCompField16.dep_map);
#line 770
    if (tmp == 0) {
#line 770
      tmp___0 = 1;
    } else {
#line 770
      tmp___0 = 0;
    }
  } else {
#line 770
    tmp___0 = 0;
  }
#line 770
  __ret_warn_on = tmp___0;
#line 770
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 770
  if (tmp___1 != 0L) {
#line 770
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                       770);
  } else {

  }
#line 770
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 772
  addr = (u8 *)(& priv->stations[sta_id].sta.sta.addr);
#line 773
  ctx = (enum iwl_rxon_context_id )priv->stations[sta_id].ctxid;
#line 774
  vif = priv->contexts[(unsigned int )ctx].vif;
#line 776
  switch ((unsigned int )priv->tid_data[sta_id][(int )tid].agg.state) {
  case 4U: ;
#line 779
  if ((int )tid_data->agg.ssn == (int )tid_data->next_reclaimed) {
#line 780
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_check_ratid_empty", "Can continue DELBA flow ssn = next_recl = %d\n",
              (int )tid_data->next_reclaimed);
#line 783
    iwl_trans_txq_disable(priv->trans, (int )tid_data->agg.txq_id, 1);
#line 785
    iwlagn_dealloc_agg_txq(priv, (int )tid_data->agg.txq_id);
#line 786
    tid_data->agg.state = 0;
#line 787
    ieee80211_stop_tx_ba_cb_irqsafe(vif, (u8 const   *)addr, (int )tid);
  } else {

  }
#line 789
  goto ldv_55295;
  case 3U: ;
#line 792
  if ((int )tid_data->agg.ssn == (int )tid_data->next_reclaimed) {
#line 793
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_check_ratid_empty", "Can continue ADDBA flow ssn = next_recl = %d\n",
              (int )tid_data->next_reclaimed);
#line 796
    tid_data->agg.state = 1;
#line 797
    ieee80211_start_tx_ba_cb_irqsafe(vif, (u8 const   *)addr, (int )tid);
  } else {

  }
#line 799
  goto ldv_55295;
  default: ;
#line 801
  goto ldv_55295;
  }
  ldv_55295: ;
#line 804
  return;
}
}
#line 805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_non_agg_tx_status(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                     u8 const   *addr1 ) 
{ 
  struct ieee80211_sta *sta ;
  struct iwl_station_priv *sta_priv ;
  int tmp ;

  {
#line 812
  rcu_read_lock();
#line 813
  sta = ieee80211_find_sta(ctx->vif, addr1);
#line 814
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
#line 815
    sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 817
    if ((int )sta_priv->client) {
#line 817
      tmp = atomic_sub_return(1, & sta_priv->pending_frames);
#line 817
      if (tmp == 0) {
#line 819
        ieee80211_sta_block_awake(priv->hw, sta, 0);
      } else {

      }
    } else {

    }
  } else {

  }
#line 821
  rcu_read_unlock();
#line 822
  return;
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_hwrate_to_tx_control(struct iwl_priv *priv , u32 rate_n_flags ,
                                        struct ieee80211_tx_info *info ) 
{ 
  struct ieee80211_tx_rate *r ;
  int tmp ;

  {
#line 830
  r = (struct ieee80211_tx_rate *)(& info->__annonCompField99.status.rates);
#line 832
  info->__annonCompField99.status.antenna = (u8 )((rate_n_flags & 114688U) >> 14);
#line 834
  if ((rate_n_flags & 256U) != 0U) {
#line 835
    r->flags = (unsigned short )((unsigned int )r->flags | 8U);
  } else {

  }
#line 836
  if ((rate_n_flags & 1024U) != 0U) {
#line 837
    r->flags = (unsigned short )((unsigned int )r->flags | 16U);
  } else {

  }
#line 838
  if ((rate_n_flags & 2048U) != 0U) {
#line 839
    r->flags = (unsigned short )((unsigned int )r->flags | 32U);
  } else {

  }
#line 840
  if ((rate_n_flags & 4096U) != 0U) {
#line 841
    r->flags = (unsigned short )((unsigned int )r->flags | 64U);
  } else {

  }
#line 842
  if ((rate_n_flags & 8192U) != 0U) {
#line 843
    r->flags = (unsigned short )((unsigned int )r->flags | 128U);
  } else {

  }
#line 844
  tmp = iwlagn_hwrate_to_mac80211_idx(rate_n_flags, (enum ieee80211_band )info->band);
#line 844
  r->idx = (s8 )tmp;
#line 845
  return;
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
char const   *iwl_get_tx_fail_reason(u32 status ) 
{ 


  {
#line 853
  switch (status & 255U) {
  case 1U: ;
#line 855
  return ("SUCCESS");
  case 64U: ;
#line 856
  return ("DELAY");
  case 65U: ;
#line 857
  return ("FEW_BYTES");
  case 66U: ;
#line 858
  return ("BT_PRIO");
  case 67U: ;
#line 859
  return ("QUIET_PERIOD");
  case 68U: ;
#line 860
  return ("CALC_TTAK");
  case 129U: ;
#line 861
  return ("INTERNAL_CROSSED_RETRY");
  case 130U: ;
#line 862
  return ("SHORT_LIMIT");
  case 131U: ;
#line 863
  return ("LONG_LIMIT");
  case 132U: ;
#line 864
  return ("FIFO_UNDERRUN");
  case 133U: ;
#line 865
  return ("DRAIN_FLOW");
  case 134U: ;
#line 866
  return ("RFKILL_FLUSH");
  case 135U: ;
#line 867
  return ("LIFE_EXPIRE");
  case 136U: ;
#line 868
  return ("DEST_PS");
  case 137U: ;
#line 869
  return ("HOST_ABORTED");
  case 138U: ;
#line 870
  return ("BT_RETRY");
  case 139U: ;
#line 871
  return ("STA_INVALID");
  case 140U: ;
#line 872
  return ("FRAG_DROPPED");
  case 141U: ;
#line 873
  return ("TID_DISABLE");
  case 142U: ;
#line 874
  return ("FIFO_FLUSHED");
  case 143U: ;
#line 875
  return ("INSUFFICIENT_CF_POLL");
  case 144U: ;
#line 876
  return ("PASSIVE_NO_RX");
  case 145U: ;
#line 877
  return ("NO_BEACON_ON_RADAR");
  }
#line 880
  return ("UNKNOWN");
}
}
#line 887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_count_agg_tx_err_status(struct iwl_priv *priv , u16 status ) 
{ 


  {
#line 889
  status = (unsigned int )status & 4095U;
#line 891
  switch ((int )status) {
  case 1: 
#line 893
  priv->reply_agg_tx_stats.underrun = priv->reply_agg_tx_stats.underrun + 1U;
#line 894
  goto ldv_55342;
  case 2: 
#line 896
  priv->reply_agg_tx_stats.bt_prio = priv->reply_agg_tx_stats.bt_prio + 1U;
#line 897
  goto ldv_55342;
  case 4: 
#line 899
  priv->reply_agg_tx_stats.few_bytes = priv->reply_agg_tx_stats.few_bytes + 1U;
#line 900
  goto ldv_55342;
  case 8: 
#line 902
  priv->reply_agg_tx_stats.abort = priv->reply_agg_tx_stats.abort + 1U;
#line 903
  goto ldv_55342;
  case 16: 
#line 905
  priv->reply_agg_tx_stats.last_sent_ttl = priv->reply_agg_tx_stats.last_sent_ttl + 1U;
#line 906
  goto ldv_55342;
  case 32: 
#line 908
  priv->reply_agg_tx_stats.last_sent_try = priv->reply_agg_tx_stats.last_sent_try + 1U;
#line 909
  goto ldv_55342;
  case 64: 
#line 911
  priv->reply_agg_tx_stats.last_sent_bt_kill = priv->reply_agg_tx_stats.last_sent_bt_kill + 1U;
#line 912
  goto ldv_55342;
  case 128: 
#line 914
  priv->reply_agg_tx_stats.scd_query = priv->reply_agg_tx_stats.scd_query + 1U;
#line 915
  goto ldv_55342;
  case 256: 
#line 917
  priv->reply_agg_tx_stats.bad_crc32 = priv->reply_agg_tx_stats.bad_crc32 + 1U;
#line 918
  goto ldv_55342;
  case 511: 
#line 920
  priv->reply_agg_tx_stats.response = priv->reply_agg_tx_stats.response + 1U;
#line 921
  goto ldv_55342;
  case 512: 
#line 923
  priv->reply_agg_tx_stats.dump_tx = priv->reply_agg_tx_stats.dump_tx + 1U;
#line 924
  goto ldv_55342;
  case 1024: 
#line 926
  priv->reply_agg_tx_stats.delay_tx = priv->reply_agg_tx_stats.delay_tx + 1U;
#line 927
  goto ldv_55342;
  default: 
#line 929
  priv->reply_agg_tx_stats.unknown = priv->reply_agg_tx_stats.unknown + 1U;
#line 930
  goto ldv_55342;
  }
  ldv_55342: ;
#line 933
  return;
}
}
#line 934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
__inline static u32 iwlagn_get_scd_ssn(struct iwlagn_tx_resp *tx_resp ) 
{ 
  __u32 tmp ;

  {
#line 936
  tmp = __le32_to_cpup((__le32 const   *)(& tx_resp->status) + (unsigned long )tx_resp->frame_count);
#line 936
  return (tmp & 4095U);
}
}
#line 940 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwl_rx_reply_tx_agg(struct iwl_priv *priv , struct iwlagn_tx_resp *tx_resp ) 
{ 
  struct agg_tx_status *frame_status ;
  int tid ;
  int sta_id ;
  struct iwl_ht_agg *agg ;
  u32 status ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u32 tmp___0 ;
  u16 fstatus ;
  u8 retry_cnt ;
  char const   *tmp___1 ;

  {
#line 943
  frame_status = & tx_resp->status;
#line 944
  tid = (int )tx_resp->ra_tid & 15;
#line 946
  sta_id = (int )tx_resp->ra_tid >> 4;
#line 948
  agg = & priv->tid_data[sta_id][tid].agg;
#line 949
  status = (u32 )tx_resp->status.status;
#line 952
  __ret_warn_on = tid == 8;
#line 952
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 952
  if (tmp != 0L) {
#line 952
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                       952);
  } else {

  }
#line 952
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 954
  if ((int )agg->wait_for_ba) {
#line 955
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwl_rx_reply_tx_agg", "got tx response w/o block-ack\n");
  } else {

  }
#line 958
  agg->rate_n_flags = tx_resp->rate_n_flags;
#line 959
  agg->wait_for_ba = (unsigned int )tx_resp->frame_count > 1U;
#line 965
  if ((((unsigned int )tx_resp->bt_kill_count != 0U && (unsigned int )tx_resp->frame_count == 1U) && (unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 968
    __iwl_dbg(priv->dev, 32768U, 0, "iwl_rx_reply_tx_agg", "receive reply tx w/ bt_kill\n");
  } else {

  }
#line 971
  if ((unsigned int )tx_resp->frame_count == 1U) {
#line 972
    return;
  } else {

  }
#line 974
  tmp___0 = iwlagn_get_scd_ssn(tx_resp);
#line 974
  __iwl_dbg(priv->dev, 1073741824U, 0, "iwl_rx_reply_tx_agg", "TXQ %d initial_rate 0x%x ssn %d frm_cnt %d\n",
            (int )agg->txq_id, tx_resp->rate_n_flags, tmp___0, (int )tx_resp->frame_count);
#line 980
  i = 0;
#line 980
  goto ldv_55375;
  ldv_55374: 
#line 981
  fstatus = (frame_status + (unsigned long )i)->status;
#line 982
  retry_cnt = (u8 )((int )fstatus >> 12);
#line 984
  if ((status & 4095U) != 0U) {
#line 985
    iwlagn_count_agg_tx_err_status(priv, (int )fstatus);
  } else {

  }
#line 987
  if ((status & 12U) != 0U) {
#line 989
    goto ldv_55373;
  } else {

  }
#line 991
  if ((status & 4095U) != 0U || (unsigned int )retry_cnt > 1U) {
#line 992
    tmp___1 = iwl_get_agg_tx_fail_reason((int )fstatus);
#line 992
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwl_rx_reply_tx_agg", "%d: status %s (0x%04x), try-count (0x%01x)\n",
              i, tmp___1, (int )fstatus & 4095, (int )retry_cnt);
  } else {

  }
  ldv_55373: 
#line 980
  i = i + 1;
  ldv_55375: ;
#line 980
  if ((int )tx_resp->frame_count > i) {
#line 982
    goto ldv_55374;
  } else {

  }

#line 987
  return;
}
}
#line 1004 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
char const   *iwl_get_agg_tx_fail_reason(u16 status ) 
{ 


  {
#line 1006
  status = (unsigned int )status & 4095U;
#line 1007
  switch ((int )status) {
  case 0: ;
#line 1009
  return ("SUCCESS");
  case 1: ;
#line 1010
  return ("UNDERRUN_MSK");
  case 2: ;
#line 1011
  return ("BT_PRIO_MSK");
  case 4: ;
#line 1012
  return ("FEW_BYTES_MSK");
  case 8: ;
#line 1013
  return ("ABORT_MSK");
  case 16: ;
#line 1014
  return ("LAST_SENT_TTL_MSK");
  case 32: ;
#line 1015
  return ("LAST_SENT_TRY_CNT_MSK");
  case 64: ;
#line 1016
  return ("LAST_SENT_BT_KILL_MSK");
  case 128: ;
#line 1017
  return ("SCD_QUERY_MSK");
  case 256: ;
#line 1018
  return ("TEST_BAD_CRC32_MSK");
  case 511: ;
#line 1019
  return ("RESPONSE_MSK");
  case 512: ;
#line 1020
  return ("DUMP_TX_MSK");
  case 1024: ;
#line 1021
  return ("DELAY_TX_MSK");
  }
#line 1024
  return ("UNKNOWN");
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_count_tx_err_status(struct iwl_priv *priv , u16 status ) 
{ 


  {
#line 1030
  status = (unsigned int )status & 255U;
#line 1032
  switch ((int )status) {
  case 64: 
#line 1034
  priv->reply_tx_stats.pp_delay = priv->reply_tx_stats.pp_delay + 1U;
#line 1035
  goto ldv_55398;
  case 65: 
#line 1037
  priv->reply_tx_stats.pp_few_bytes = priv->reply_tx_stats.pp_few_bytes + 1U;
#line 1038
  goto ldv_55398;
  case 66: 
#line 1040
  priv->reply_tx_stats.pp_bt_prio = priv->reply_tx_stats.pp_bt_prio + 1U;
#line 1041
  goto ldv_55398;
  case 67: 
#line 1043
  priv->reply_tx_stats.pp_quiet_period = priv->reply_tx_stats.pp_quiet_period + 1U;
#line 1044
  goto ldv_55398;
  case 68: 
#line 1046
  priv->reply_tx_stats.pp_calc_ttak = priv->reply_tx_stats.pp_calc_ttak + 1U;
#line 1047
  goto ldv_55398;
  case 129: 
#line 1049
  priv->reply_tx_stats.int_crossed_retry = priv->reply_tx_stats.int_crossed_retry + 1U;
#line 1050
  goto ldv_55398;
  case 130: 
#line 1052
  priv->reply_tx_stats.short_limit = priv->reply_tx_stats.short_limit + 1U;
#line 1053
  goto ldv_55398;
  case 131: 
#line 1055
  priv->reply_tx_stats.long_limit = priv->reply_tx_stats.long_limit + 1U;
#line 1056
  goto ldv_55398;
  case 132: 
#line 1058
  priv->reply_tx_stats.fifo_underrun = priv->reply_tx_stats.fifo_underrun + 1U;
#line 1059
  goto ldv_55398;
  case 133: 
#line 1061
  priv->reply_tx_stats.drain_flow = priv->reply_tx_stats.drain_flow + 1U;
#line 1062
  goto ldv_55398;
  case 134: 
#line 1064
  priv->reply_tx_stats.rfkill_flush = priv->reply_tx_stats.rfkill_flush + 1U;
#line 1065
  goto ldv_55398;
  case 135: 
#line 1067
  priv->reply_tx_stats.life_expire = priv->reply_tx_stats.life_expire + 1U;
#line 1068
  goto ldv_55398;
  case 136: 
#line 1070
  priv->reply_tx_stats.dest_ps = priv->reply_tx_stats.dest_ps + 1U;
#line 1071
  goto ldv_55398;
  case 137: 
#line 1073
  priv->reply_tx_stats.host_abort = priv->reply_tx_stats.host_abort + 1U;
#line 1074
  goto ldv_55398;
  case 138: 
#line 1076
  priv->reply_tx_stats.bt_retry = priv->reply_tx_stats.bt_retry + 1U;
#line 1077
  goto ldv_55398;
  case 139: 
#line 1079
  priv->reply_tx_stats.sta_invalid = priv->reply_tx_stats.sta_invalid + 1U;
#line 1080
  goto ldv_55398;
  case 140: 
#line 1082
  priv->reply_tx_stats.frag_drop = priv->reply_tx_stats.frag_drop + 1U;
#line 1083
  goto ldv_55398;
  case 141: 
#line 1085
  priv->reply_tx_stats.tid_disable = priv->reply_tx_stats.tid_disable + 1U;
#line 1086
  goto ldv_55398;
  case 142: 
#line 1088
  priv->reply_tx_stats.fifo_flush = priv->reply_tx_stats.fifo_flush + 1U;
#line 1089
  goto ldv_55398;
  case 143: 
#line 1091
  priv->reply_tx_stats.insuff_cf_poll = priv->reply_tx_stats.insuff_cf_poll + 1U;
#line 1092
  goto ldv_55398;
  case 144: 
#line 1094
  priv->reply_tx_stats.fail_hw_drop = priv->reply_tx_stats.fail_hw_drop + 1U;
#line 1095
  goto ldv_55398;
  case 145: 
#line 1097
  priv->reply_tx_stats.sta_color_mismatch = priv->reply_tx_stats.sta_color_mismatch + 1U;
#line 1098
  goto ldv_55398;
  default: 
#line 1100
  priv->reply_tx_stats.unknown = priv->reply_tx_stats.unknown + 1U;
#line 1101
  goto ldv_55398;
  }
  ldv_55398: ;
#line 1104
  return;
}
}
#line 1105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwlagn_set_tx_status(struct iwl_priv *priv , struct ieee80211_tx_info *info ,
                                 struct iwlagn_tx_resp *tx_resp ) 
{ 
  u16 status ;
  u32 tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1109
  status = tx_resp->status.status;
#line 1111
  info->flags = info->flags & 4294967231U;
#line 1113
  info->__annonCompField99.status.rates[0].count = (unsigned char )((unsigned int )tx_resp->failure_frame + 1U);
#line 1114
  tmp = iwl_tx_status_to_mac80211((u32 )status);
#line 1114
  info->flags = info->flags | tmp;
#line 1115
  iwlagn_hwrate_to_tx_control(priv, tx_resp->rate_n_flags, info);
#line 1117
  tmp___0 = iwl_is_tx_success((u32 )status);
#line 1117
  if (tmp___0) {
#line 1117
    tmp___1 = 0;
  } else {
#line 1117
    tmp___1 = 1;
  }
#line 1117
  if (tmp___1) {
#line 1118
    iwlagn_count_tx_err_status(priv, (int )status);
  } else {

  }
#line 1119
  return;
}
}
#line 1121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
static void iwl_check_abort_status(struct iwl_priv *priv , u8 frame_count , u32 status ) 
{ 
  int tmp ;

  {
#line 1124
  if ((unsigned int )frame_count == 1U && status == 134U) {
#line 1125
    __iwl_err(priv->dev, 0, 0, "Tx flush command to flush out all frames\n");
#line 1126
    tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 1126
    if (tmp == 0) {
#line 1127
      queue_work___2(priv->workqueue, & priv->tx_flush);
    } else {

    }
  } else {

  }
#line 1129
  return;
}
}
#line 1131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
int iwlagn_rx_reply_tx(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  u16 sequence ;
  int txq_id ;
  int cmd_index ;
  struct iwlagn_tx_resp *tx_resp ;
  struct ieee80211_hdr *hdr ;
  u32 status ;
  u16 ssn ;
  u32 tmp___0 ;
  int tid ;
  int sta_id ;
  int freed ;
  struct ieee80211_tx_info *info ;
  struct sk_buff_head skbs ;
  struct sk_buff *skb ;
  struct iwl_rxon_context *ctx ;
  bool is_agg ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  u16 next_reclaimed ;
  int tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  struct ieee80211_tx_info *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;

  {
#line 1134
  tmp = rxb_addr(rxb);
#line 1134
  pkt = (struct iwl_rx_packet *)tmp;
#line 1135
  sequence = pkt->hdr.sequence;
#line 1136
  txq_id = ((int )sequence >> 8) & 31;
#line 1137
  cmd_index = (int )sequence & 255;
#line 1138
  tx_resp = (struct iwlagn_tx_resp *)(& pkt->data);
#line 1140
  status = (u32 )tx_resp->status.status;
#line 1141
  tmp___0 = iwlagn_get_scd_ssn(tx_resp);
#line 1141
  ssn = (u16 )tmp___0;
#line 1149
  is_agg = txq_id > 10;
#line 1151
  tid = (int )tx_resp->ra_tid & 15;
#line 1153
  sta_id = (int )tx_resp->ra_tid >> 4;
#line 1156
  spin_lock_bh(& priv->sta_lock);
#line 1158
  if ((int )is_agg) {
#line 1159
    __ret_warn_once = sta_id > 15 || tid > 7;
#line 1159
    tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1159
    if (tmp___3 != 0L) {
#line 1159
      __ret_warn_on = ! __warned;
#line 1159
      tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1159
      if (tmp___1 != 0L) {
#line 1159
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                           1160);
      } else {

      }
#line 1159
      tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1159
      if (tmp___2 != 0L) {
#line 1159
        __warned = 1;
      } else {

      }
    } else {

    }
#line 1159
    ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1161
    if ((int )priv->tid_data[sta_id][tid].agg.txq_id != txq_id) {
#line 1162
      __iwl_err(priv->dev, 0, 0, "txq_id mismatch: %d %d\n", txq_id, (int )priv->tid_data[sta_id][tid].agg.txq_id);
    } else {

    }
#line 1164
    iwl_rx_reply_tx_agg(priv, tx_resp);
  } else {

  }
#line 1167
  __skb_queue_head_init(& skbs);
#line 1169
  if ((unsigned int )tx_resp->frame_count == 1U) {
#line 1170
    next_reclaimed = tx_resp->seq_ctl;
#line 1171
    next_reclaimed = (u16 )((((int )next_reclaimed + 16) & 65520) >> 4);
#line 1173
    if ((int )is_agg) {
#line 1185
      next_reclaimed = ssn;
    } else {

    }
#line 1188
    if (tid != 8) {
#line 1189
      priv->tid_data[sta_id][tid].next_reclaimed = next_reclaimed;
#line 1191
      __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "Next reclaimed packet:%d\n",
                (int )next_reclaimed);
    } else {

    }
#line 1195
    iwl_trans_reclaim(priv->trans, txq_id, (int )ssn, & skbs);
#line 1197
    iwlagn_check_ratid_empty(priv, sta_id, (int )((u8 )tid));
#line 1198
    freed = 0;
#line 1201
    skb = skbs.next;
#line 1201
    goto ldv_55461;
    ldv_55460: 
#line 1202
    hdr = (struct ieee80211_hdr *)skb->data;
#line 1204
    tmp___4 = ieee80211_is_data_qos((int )hdr->frame_control);
#line 1204
    if (tmp___4 == 0) {
#line 1205
      priv->last_seq_ctl = tx_resp->seq_ctl;
    } else {

    }
#line 1207
    info = IEEE80211_SKB_CB(skb);
#line 1208
    ctx = (struct iwl_rxon_context *)info->__annonCompField99.driver_data[0];
#line 1209
    iwl_trans_free_tx_cmd(priv->trans, (struct iwl_device_cmd *)info->__annonCompField99.driver_data[1]);
#line 1212
    memset((void *)(& info->__annonCompField99.status), 0, 40UL);
#line 1214
    if ((status == 144U && (unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) && (unsigned int )(ctx->vif)->type == 2U) {
#line 1218
      priv->passive_no_rx = 1;
#line 1219
      __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_rx_reply_tx", "stop all queues: passive channel\n");
#line 1221
      ieee80211_stop_queues(priv->hw);
#line 1223
      tmp___5 = iwl_get_tx_fail_reason(status);
#line 1223
      __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "TXQ %d status %s (0x%08x) rate_n_flags 0x%x retries %d\n",
                txq_id, tmp___5, status, tx_resp->rate_n_flags, (int )tx_resp->failure_frame);
#line 1232
      __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "FrameCnt = %d, idx=%d\n",
                (int )tx_resp->frame_count, cmd_index);
    } else {

    }
#line 1238
    if ((int )is_agg) {
#line 1238
      tmp___6 = iwl_is_tx_success(status);
#line 1238
      if (tmp___6) {
#line 1238
        tmp___7 = 0;
      } else {
#line 1238
        tmp___7 = 1;
      }
#line 1238
      if (tmp___7) {
#line 1239
        info->flags = info->flags | 2048U;
      } else {

      }
    } else {

    }
#line 1240
    tmp___8 = IEEE80211_SKB_CB(skb);
#line 1240
    iwlagn_set_tx_status(priv, tmp___8, tx_resp);
#line 1242
    if (! is_agg) {
#line 1243
      iwlagn_non_agg_tx_status(priv, ctx, (u8 const   *)(& hdr->addr1));
    } else {

    }
#line 1245
    freed = freed + 1;
#line 1201
    skb = skb->__annonCompField68.__annonCompField67.next;
    ldv_55461: ;
#line 1201
    if ((unsigned long )((struct sk_buff *)(& skbs)) != (unsigned long )skb) {
#line 1203
      goto ldv_55460;
    } else {

    }

#line 1248
    if (tid != 8) {
#line 1249
      priv->tid_data[sta_id][tid].next_reclaimed = next_reclaimed;
#line 1251
      __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "Next reclaimed packet:%d\n",
                (int )next_reclaimed);
    } else {

    }
#line 1255
    if (! is_agg && freed != 1) {
#line 1256
      __iwl_err(priv->dev, 0, 0, "Q: %d, freed %d\n", txq_id, freed);
    } else {

    }
#line 1258
    tmp___9 = iwl_get_tx_fail_reason(status);
#line 1258
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "TXQ %d status %s (0x%08x)\n",
              txq_id, tmp___9, status);
#line 1261
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "\t\t\t\tinitial_rate 0x%x retries %d, idx=%d ssn=%d seq_ctl=0x%x\n",
              tx_resp->rate_n_flags, (int )tx_resp->failure_frame, (int )sequence & 255,
              (int )ssn, (int )tx_resp->seq_ctl);
  } else {

  }
#line 1269
  iwl_check_abort_status(priv, (int )tx_resp->frame_count, status);
#line 1270
  spin_unlock_bh(& priv->sta_lock);
#line 1272
  goto ldv_55464;
  ldv_55463: 
#line 1273
  skb = __skb_dequeue(& skbs);
#line 1274
  ieee80211_tx_status(priv->hw, skb);
  ldv_55464: 
#line 1272
  tmp___10 = skb_queue_empty((struct sk_buff_head  const  *)(& skbs));
#line 1272
  if (tmp___10 == 0) {
#line 1274
    goto ldv_55463;
  } else {

  }

#line 1277
  return (0);
}
}
#line 1286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c"
int iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                  struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_compressed_ba_resp *ba_resp ;
  struct iwl_ht_agg *agg ;
  struct sk_buff_head reclaimed_skbs ;
  struct sk_buff *skb ;
  int sta_id ;
  int tid ;
  int freed ;
  u16 scd_flow ;
  u16 ba_resp_scd_ssn ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct ieee80211_hdr *hdr ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp___3 ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1290
  tmp = rxb_addr(rxb);
#line 1290
  pkt = (struct iwl_rx_packet *)tmp;
#line 1291
  ba_resp = (struct iwl_compressed_ba_resp *)(& pkt->data);
#line 1300
  scd_flow = ba_resp->scd_flow;
#line 1304
  ba_resp_scd_ssn = ba_resp->scd_ssn;
#line 1306
  if ((int )scd_flow >= (int )((priv->cfg)->base_params)->num_of_queues) {
#line 1307
    __iwl_err(priv->dev, 0, 0, "BUG_ON scd_flow is bigger than number of queues\n");
#line 1309
    return (0);
  } else {

  }
#line 1312
  sta_id = (int )ba_resp->sta_id;
#line 1313
  tid = (int )ba_resp->tid;
#line 1314
  agg = & priv->tid_data[sta_id][tid].agg;
#line 1316
  spin_lock_bh(& priv->sta_lock);
#line 1318
  tmp___1 = ldv__builtin_expect((long )(! agg->wait_for_ba), 0L);
#line 1318
  if (tmp___1 != 0L) {
#line 1319
    tmp___0 = ldv__builtin_expect(ba_resp->bitmap != 0ULL, 0L);
#line 1319
    if (tmp___0 != 0L) {
#line 1320
      __iwl_err(priv->dev, 0, 0, "Received BA when not expected\n");
    } else {

    }
#line 1321
    spin_unlock_bh(& priv->sta_lock);
#line 1322
    return (0);
  } else {

  }
#line 1325
  tmp___2 = ldv__builtin_expect((int )agg->txq_id != (int )scd_flow, 0L);
#line 1325
  if (tmp___2 != 0L) {
#line 1332
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_rx_reply_compressed_ba", "Bad queue mapping txq_id=%d, agg_txq[sta:%d,tid:%d]=%d\n",
              (int )scd_flow, sta_id, tid, (int )agg->txq_id);
#line 1335
    spin_unlock_bh(& priv->sta_lock);
#line 1336
    return (0);
  } else {

  }
#line 1339
  __skb_queue_head_init(& reclaimed_skbs);
#line 1344
  iwl_trans_reclaim(priv->trans, (int )scd_flow, (int )ba_resp_scd_ssn, & reclaimed_skbs);
#line 1347
  __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_compressed_ba", "REPLY_COMPRESSED_BA [%d] Received from %pM, sta_id = %d\n",
            (int )agg->wait_for_ba, (u8 *)(& ba_resp->sta_addr_lo32), (int )ba_resp->sta_id);
#line 1352
  __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_compressed_ba", "TID = %d, SeqCtl = %d, bitmap = 0x%llx, scd_flow = %d, scd_ssn = %d sent:%d, acked:%d\n",
            (int )ba_resp->tid, (int )ba_resp->seq_ctl, ba_resp->bitmap, (int )scd_flow,
            (int )ba_resp_scd_ssn, (int )ba_resp->txed, (int )ba_resp->txed_2_done);
#line 1360
  agg->wait_for_ba = 0;
#line 1363
  if ((int )ba_resp->txed_2_done > (int )ba_resp->txed) {
#line 1364
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_compressed_ba", "bogus sent(%d) and ack(%d) count\n",
              (int )ba_resp->txed, (int )ba_resp->txed_2_done);
#line 1371
    ba_resp->txed = ba_resp->txed_2_done;
  } else {

  }
#line 1374
  priv->tid_data[sta_id][tid].next_reclaimed = ba_resp_scd_ssn;
#line 1376
  iwlagn_check_ratid_empty(priv, sta_id, (int )((u8 )tid));
#line 1377
  freed = 0;
#line 1379
  skb = reclaimed_skbs.next;
#line 1379
  goto ldv_55490;
  ldv_55489: 
#line 1380
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1381
  tmp___3 = IEEE80211_SKB_CB(skb);
#line 1381
  info = tmp___3;
#line 1383
  tmp___7 = ieee80211_is_data_qos((int )hdr->frame_control);
#line 1383
  if (tmp___7 != 0) {
#line 1384
    freed = freed + 1;
  } else {
#line 1386
    __ret_warn_once = 1;
#line 1386
    tmp___6 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 1386
    if (tmp___6 != 0L) {
#line 1386
      __ret_warn_on = ! __warned;
#line 1386
      tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1386
      if (tmp___4 != 0L) {
#line 1386
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                           1386);
      } else {

      }
#line 1386
      tmp___5 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1386
      if (tmp___5 != 0L) {
#line 1386
        __warned = 1;
      } else {

      }
    } else {

    }
#line 1386
    ldv__builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 1388
  iwl_trans_free_tx_cmd(priv->trans, (struct iwl_device_cmd *)info->__annonCompField99.driver_data[1]);
#line 1390
  memset((void *)(& info->__annonCompField99.status), 0, 40UL);
#line 1395
  info->flags = info->flags | 512U;
#line 1397
  if (freed == 1) {
#line 1400
    info = IEEE80211_SKB_CB(skb);
#line 1401
    memset((void *)(& info->__annonCompField99.status), 0, 40UL);
#line 1402
    info->flags = info->flags | 1024U;
#line 1403
    info->__annonCompField99.status.ampdu_ack_len = ba_resp->txed_2_done;
#line 1404
    info->__annonCompField99.status.ampdu_len = ba_resp->txed;
#line 1405
    iwlagn_hwrate_to_tx_control(priv, agg->rate_n_flags, info);
  } else {

  }
#line 1379
  skb = skb->__annonCompField68.__annonCompField67.next;
  ldv_55490: ;
#line 1379
  if ((unsigned long )((struct sk_buff *)(& reclaimed_skbs)) != (unsigned long )skb) {
#line 1381
    goto ldv_55489;
  } else {

  }
#line 1410
  spin_unlock_bh(& priv->sta_lock);
#line 1412
  goto ldv_55493;
  ldv_55492: 
#line 1413
  skb = __skb_dequeue(& reclaimed_skbs);
#line 1414
  ieee80211_tx_status(priv->hw, skb);
  ldv_55493: 
#line 1412
  tmp___8 = skb_queue_empty((struct sk_buff_head  const  *)(& reclaimed_skbs));
#line 1412
  if (tmp___8 == 0) {
#line 1414
    goto ldv_55492;
  } else {

  }

#line 1417
  return (0);
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
bool ldv_queue_work_on_233(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 577
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_work_7(ldv_func_arg3, 2);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
bool ldv_queue_delayed_work_on_234(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_work_7(& ldv_func_arg3->work, 2);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
bool ldv_queue_work_on_235(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_7(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
void ldv_flush_workqueue_236(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 609
  flush_workqueue(ldv_func_arg1);
#line 611
  call_and_disable_all_7(2);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
bool ldv_queue_delayed_work_on_237(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 618
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 618
  ldv_func_res = tmp;
#line 620
  activate_work_7(& ldv_func_arg3->work, 2);
#line 622
  return (ldv_func_res);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
void ldv_mutex_lock_238(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
void ldv_mutex_unlock_239(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 638
  mutex_unlock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
void ldv_mutex_lock_240(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 646
  mutex_lock(ldv_func_arg1);
#line 647
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
int ldv_mutex_trylock_241(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
void ldv_mutex_unlock_242(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 665
  mutex_unlock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
void ldv_mutex_unlock_243(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 673
  mutex_unlock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tx.o.c.prepared"
void ldv_mutex_lock_244(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 681
  mutex_lock(ldv_func_arg1);
#line 682
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_269(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_271(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_276(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_279(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_280(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_268(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_272(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_275(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_278(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_281(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_263(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_262(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_265(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_264(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
bool ldv_cancel_work_sync_277(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___3(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_261(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void call_and_disable_work_7(struct work_struct *work ) ;
#line 491
void invoke_work_7(void) ;
#line 4265 "include/net/mac80211.h"
extern void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf * , u32  , u16 * ) ;
#line 4300
extern void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf * , u8 const   * ,
                                      u32  , u16 * ) ;
#line 4344
extern void ieee80211_get_key_tx_seq(struct ieee80211_key_conf * , struct ieee80211_key_seq * ) ;
#line 4363
extern void ieee80211_get_key_rx_seq(struct ieee80211_key_conf * , int  , struct ieee80211_key_seq * ) ;
#line 4847
extern void ieee80211_iter_keys(struct ieee80211_hw * , struct ieee80211_vif * , void (*)(struct ieee80211_hw * ,
                                                                                          struct ieee80211_vif * ,
                                                                                          struct ieee80211_sta * ,
                                                                                          struct ieee80211_key_conf * ,
                                                                                          void * ) ,
                                void * ) ;
#line 4999
extern void ieee80211_request_smps(struct ieee80211_vif * , enum ieee80211_smps_mode  ) ;
#line 5282
extern void ieee80211_enable_rssi_reports(struct ieee80211_vif * , int  , int  ) ;
#line 5286
extern void ieee80211_disable_rssi_reports(struct ieee80211_vif * ) ;
#line 5298
extern int ieee80211_ave_rssi(struct ieee80211_vif * ) ;
#line 776 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static int iwl_trans_send_cmd(struct iwl_trans *trans , struct iwl_host_cmd *cmd ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 781
  if ((cmd->flags & 4U) == 0U) {
#line 781
    tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& trans->status));
#line 781
    if (tmp != 0) {
#line 781
      tmp___0 = 1;
    } else {
#line 781
      tmp___0 = 0;
    }
  } else {
#line 781
    tmp___0 = 0;
  }
#line 781
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 781
  if (tmp___1 != 0L) {
#line 783
    return (-132);
  } else {

  }
#line 785
  tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& trans->status));
#line 785
  tmp___3 = ldv__builtin_expect(tmp___2 != 0, 0L);
#line 785
  if (tmp___3 != 0L) {
#line 786
    return (-5);
  } else {

  }
#line 788
  tmp___4 = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
#line 788
  if (tmp___4 != 0L) {
#line 789
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_send_cmd", (unsigned int )trans->state);
#line 790
    return (-5);
  } else {

  }
#line 793
  if ((cmd->flags & 1U) == 0U) {
#line 794
    lock_acquire(& trans->sync_cmd_lockdep_map, 0U, 0, 2, 1, (struct lockdep_map *)0,
                 0UL);
  } else {

  }
#line 796
  ret = (*((trans->ops)->send_cmd))(trans, cmd);
#line 798
  if ((cmd->flags & 1U) == 0U) {
#line 799
    lock_release(& trans->sync_cmd_lockdep_map, 1, 0UL);
  } else {

  }
#line 801
  return (ret);
}
}
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/tt.h"
void iwl_tt_handler(struct iwl_priv *priv ) ;
#line 933 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
__inline static int iwl_is_associated(struct iwl_priv *priv , enum iwl_rxon_context_id ctxid ) 
{ 
  int tmp ;

  {
#line 936
  tmp = iwl_is_associated_ctx((struct iwl_rxon_context *)(& priv->contexts) + (unsigned long )ctxid);
#line 936
  return (tmp);
}
}
#line 181 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
int iwlagn_send_tx_power(struct iwl_priv *priv ) ;
#line 182
void iwlagn_temperature(struct iwl_priv *priv ) ;
#line 196
int iwlagn_send_patterns(struct iwl_priv *priv , struct cfg80211_wowlan *wowlan ) ;
#line 280
int iwlagn_bt_coex_profile_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                 struct iwl_device_cmd *cmd ) ;
#line 283
void iwlagn_bt_rx_handler_setup(struct iwl_priv *priv ) ;
#line 286
void iwlagn_bt_coex_rssi_monitor(struct iwl_priv *priv ) ;
#line 287
void iwlagn_bt_adjust_rssi_monitor(struct iwl_priv *priv , bool rssi_ena ) ;
#line 305
int iwlagn_manage_ibss_station(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                               bool add ) ;
#line 354
int iwlagn_add_bssid_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                             u8 const   *addr , u8 *sta_id_r ) ;
#line 431 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static int iwl_is_ctkill(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
#line 433
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& priv->status));
#line 433
  return (tmp);
}
}
#line 485 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static char const   *iwl_dvm_get_cmd_string(u8 cmd ) 
{ 
  char const   *s ;

  {
#line 487
  s = iwl_dvm_cmd_strings[(int )cmd];
#line 488
  if ((unsigned long )s != (unsigned long )((char const   *)0)) {
#line 489
    return (s);
  } else {

  }
#line 490
  return ("UNKNOWN");
}
}
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwlagn_hw_valid_rtc_data_addr(u32 addr ) 
{ 


  {
#line 45
  return (addr > 8388607U && addr <= 8437759U);
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwlagn_send_tx_power(struct iwl_priv *priv ) 
{ 
  struct iwlagn_tx_power_dbm_cmd tx_power_cmd ;
  u8 tx_ant_cfg_cmd ;
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 54
  tmp = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
#line 54
  __ret_warn_once = tmp != 0;
#line 54
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 54
  if (tmp___2 != 0L) {
#line 54
    __ret_warn_on = ! __warned;
#line 54
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 54
    if (tmp___0 != 0L) {
#line 54
      warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                        55, "TX Power requested while scanning!\n");
    } else {

    }
#line 54
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 54
    if (tmp___1 != 0L) {
#line 54
      __warned = 1;
    } else {

    }
  } else {

  }
#line 54
  tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 54
  if (tmp___3 != 0L) {
#line 56
    return (-11);
  } else {

  }
#line 59
  tx_power_cmd.global_lmt = (signed char )((unsigned int )((unsigned char )priv->tx_power_user_lmt) * 2U);
#line 61
  if ((int )tx_power_cmd.global_lmt > (int )(priv->nvm_data)->max_tx_pwr_half_dbm) {
#line 73
    tx_power_cmd.global_lmt = (priv->nvm_data)->max_tx_pwr_half_dbm;
  } else {

  }
#line 76
  tx_power_cmd.flags = 64U;
#line 77
  tx_power_cmd.srv_chan_lmt = 127;
#line 79
  if (((unsigned int )(priv->fw)->ucode_ver & 65280U) >> 8 == 1U) {
#line 80
    tx_ant_cfg_cmd = 152U;
  } else {
#line 82
    tx_ant_cfg_cmd = 149U;
  }
#line 84
  tmp___4 = iwl_dvm_send_cmd_pdu(priv, (int )tx_ant_cfg_cmd, 0U, 4, (void const   *)(& tx_power_cmd));
#line 84
  return (tmp___4);
}
}
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_temperature(struct iwl_priv *priv ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 90
  if (debug_locks != 0) {
#line 90
    tmp = lock_is_held(& priv->statistics.lock.__annonCompField17.__annonCompField16.dep_map);
#line 90
    if (tmp == 0) {
#line 90
      tmp___0 = 1;
    } else {
#line 90
      tmp___0 = 0;
    }
  } else {
#line 90
    tmp___0 = 0;
  }
#line 90
  __ret_warn_on = tmp___0;
#line 90
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 90
  if (tmp___1 != 0L) {
#line 90
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                       90);
  } else {

  }
#line 90
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 93
  priv->temperature = (s32 )priv->statistics.common.temperature;
#line 94
  iwl_tt_handler(priv);
#line 95
  return;
}
}
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwlagn_hwrate_to_mac80211_idx(u32 rate_n_flags , enum ieee80211_band band ) 
{ 
  int idx ;
  int band_offset ;

  {
#line 99
  idx = 0;
#line 100
  band_offset = 0;
#line 103
  if ((rate_n_flags & 256U) != 0U) {
#line 104
    idx = (int )rate_n_flags & 255;
#line 105
    return (idx);
  } else {
#line 108
    if ((unsigned int )band == 1U) {
#line 109
      band_offset = 4;
    } else {

    }
#line 110
    idx = band_offset;
#line 110
    goto ldv_55326;
    ldv_55325: ;
#line 111
    if ((u32 )iwl_rates[idx].plcp == (rate_n_flags & 255U)) {
#line 112
      return (idx - band_offset);
    } else {

    }
#line 110
    idx = idx + 1;
    ldv_55326: ;
#line 110
    if (idx <= 11) {
#line 112
      goto ldv_55325;
    } else {

    }

  }
#line 115
  return (-1);
}
}
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwlagn_manage_ibss_station(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                               bool add ) 
{ 
  struct iwl_vif_priv *vif_priv ;
  int tmp ;
  int tmp___0 ;

  {
#line 121
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
#line 123
  if ((int )add) {
#line 124
    tmp = iwlagn_add_bssid_station(priv, vif_priv->ctx, vif->bss_conf.bssid, & vif_priv->ibss_bssid_sta_id);
#line 124
    return (tmp);
  } else {

  }
#line 127
  tmp___0 = iwl_remove_station(priv, (int )vif_priv->ibss_bssid_sta_id, vif->bss_conf.bssid);
#line 127
  return (tmp___0);
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwlagn_txfifo_flush(struct iwl_priv *priv , u32 scd_q_msk ) 
{ 
  struct iwl_txfifo_flush_cmd_v3 flush_cmd_v3 ;
  struct iwl_txfifo_flush_cmd_v2 flush_cmd_v2 ;
  u32 queue_control ;
  int tmp ;
  int tmp___0 ;

  {
#line 140
  flush_cmd_v3.queue_control = 0U;
#line 140
  flush_cmd_v3.flush_control = 2U;
#line 140
  flush_cmd_v3.reserved = (unsigned short)0;
#line 143
  flush_cmd_v2.queue_control = (unsigned short)0;
#line 143
  flush_cmd_v2.flush_control = 2U;
#line 147
  queue_control = 15U;
#line 150
  if ((unsigned int )priv->valid_contexts != 1U) {
#line 151
    queue_control = queue_control | 496U;
  } else {

  }
#line 156
  if ((int )(priv->nvm_data)->sku_cap_11n_enable) {
#line 157
    queue_control = queue_control | 1047552U;
  } else {

  }
#line 159
  if (scd_q_msk != 0U) {
#line 160
    queue_control = scd_q_msk;
  } else {

  }
#line 162
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_txfifo_flush", "queue control: 0x%x\n", queue_control);
#line 163
  flush_cmd_v3.queue_control = queue_control;
#line 164
  flush_cmd_v2.queue_control = (unsigned short )queue_control;
#line 166
  if (((unsigned int )(priv->fw)->ucode_ver & 65280U) >> 8 > 2U) {
#line 167
    tmp = iwl_dvm_send_cmd_pdu(priv, 30, 0U, 8, (void const   *)(& flush_cmd_v3));
#line 167
    return (tmp);
  } else {

  }
#line 170
  tmp___0 = iwl_dvm_send_cmd_pdu(priv, 30, 0U, 4, (void const   *)(& flush_cmd_v2));
#line 170
  return (tmp___0);
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_dev_txfifo_flush(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
#line 176
  ldv_mutex_lock_273(& priv->mutex);
#line 177
  ieee80211_stop_queues(priv->hw);
#line 178
  tmp = iwlagn_txfifo_flush(priv, 0U);
#line 178
  if (tmp != 0) {
#line 179
    __iwl_err(priv->dev, 0, 0, "flush request fail\n");
#line 180
    goto done;
  } else {

  }
#line 182
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_dev_txfifo_flush", "wait transmit/flush all frames\n");
#line 183
  iwl_trans_wait_tx_queue_empty(priv->trans, 4294967295U);
  done: 
#line 185
  ieee80211_wake_queues(priv->hw);
#line 186
  ldv_mutex_unlock_274(& priv->mutex);
#line 187
  return;
}
}
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static __le32 const   iwlagn_def_3w_lookup[12U]  = 
#line 193
  {      2863311530U,      2863311530U,      2930420394U,      2863311530U, 
        3422617384U,      43690U,      3422595754U,      43690U, 
        3221241856U,      16384U,      4026552320U,      4026552320U};
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static __le32 const   iwlagn_concurrent_lookup[12U]  = 
#line 226
  {      2863311530U,      2863311530U,      2863311530U,      2863311530U, 
        2863311530U,      2863311530U,      2863311530U,      2863311530U, 
        0U,      0U,      0U,      0U};
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_send_advance_bt_config(struct iwl_priv *priv ) 
{ 
  struct iwl_basic_bt_cmd basic ;
  struct iwl_bt_cmd_v1 bt_cmd_v1 ;
  struct iwl_bt_cmd_v2 bt_cmd_v2 ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 243
  basic.flags = (unsigned char)0;
#line 243
  basic.ledtime = (unsigned char)0;
#line 243
  basic.max_kill = 5U;
#line 243
  basic.bt3_timer_t7_value = 1U;
#line 243
  basic.kill_ack_mask = 0U;
#line 243
  basic.kill_cts_mask = 0U;
#line 243
  basic.bt3_prio_sample_time = 2U;
#line 243
  basic.bt3_timer_t2_value = 12U;
#line 243
  basic.bt4_reaction_time = (unsigned short)0;
#line 243
  basic.bt3_lookup_table[0] = 0U;
#line 243
  basic.bt3_lookup_table[1] = 0U;
#line 243
  basic.bt3_lookup_table[2] = 0U;
#line 243
  basic.bt3_lookup_table[3] = 0U;
#line 243
  basic.bt3_lookup_table[4] = 0U;
#line 243
  basic.bt3_lookup_table[5] = 0U;
#line 243
  basic.bt3_lookup_table[6] = 0U;
#line 243
  basic.bt3_lookup_table[7] = 0U;
#line 243
  basic.bt3_lookup_table[8] = 0U;
#line 243
  basic.bt3_lookup_table[9] = 0U;
#line 243
  basic.bt3_lookup_table[10] = 0U;
#line 243
  basic.bt3_lookup_table[11] = 0U;
#line 243
  basic.reduce_txpower = (unsigned char)0;
#line 243
  basic.reserved = (unsigned char)0;
#line 243
  basic.valid = (unsigned short)0;
#line 256
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
#line 263
    if ((int )((priv->lib)->bt_params)->bt_session_2) {
#line 264
      bt_cmd_v2.prio_boost = ((priv->lib)->bt_params)->bt_prio_boost;
#line 266
      bt_cmd_v2.tx_prio_boost = 0U;
#line 267
      bt_cmd_v2.rx_prio_boost = 0U;
    } else {
#line 270
      __ret_warn_on = ((unsigned int )((priv->lib)->bt_params)->bt_prio_boost & 4294967040U) != 0U;
#line 270
      tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 270
      if (tmp != 0L) {
#line 270
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                           270);
      } else {

      }
#line 270
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 271
      bt_cmd_v1.prio_boost = (u8 )((priv->lib)->bt_params)->bt_prio_boost;
#line 273
      bt_cmd_v1.tx_prio_boost = 0U;
#line 274
      bt_cmd_v1.rx_prio_boost = 0U;
    }
  } else {
#line 277
    __iwl_err(priv->dev, 0, 0, "failed to construct BT Coex Config\n");
#line 278
    return;
  }
#line 291
  basic.kill_ack_mask = priv->kill_ack_mask;
#line 292
  basic.kill_cts_mask = priv->kill_cts_mask;
#line 293
  if ((int )priv->reduced_txpower) {
#line 294
    basic.reduce_txpower = 1U;
  } else {

  }
#line 295
  basic.valid = priv->bt_valid;
#line 303
  if (! iwlwifi_mod_params.bt_coex_active || (unsigned int )priv->iw_mode == 1U) {
#line 305
    basic.flags = 0U;
  } else {
#line 307
    basic.flags = 16U;
#line 310
    if (! priv->bt_enable_pspoll) {
#line 311
      basic.flags = (u8 )((unsigned int )basic.flags | 128U);
    } else {
#line 313
      basic.flags = (unsigned int )basic.flags & 127U;
    }
#line 315
    if ((int )priv->bt_ch_announce) {
#line 316
      basic.flags = (u8 )((unsigned int )basic.flags | 1U);
    } else {

    }
#line 317
    __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_send_advance_bt_config", "BT coex flag: 0X%x\n",
              (int )basic.flags);
  }
#line 319
  priv->bt_enable_flag = basic.flags;
#line 320
  if ((int )priv->bt_full_concurrent) {
#line 321
    memcpy((void *)(& basic.bt3_lookup_table), (void const   *)(& iwlagn_concurrent_lookup),
             48UL);
  } else {
#line 324
    memcpy((void *)(& basic.bt3_lookup_table), (void const   *)(& iwlagn_def_3w_lookup),
             48UL);
  }
#line 327
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_send_advance_bt_config", "BT coex %s in %s mode\n",
            (unsigned int )basic.flags != 0U ? (char *)"active" : (char *)"disabled",
            (int )priv->bt_full_concurrent ? (char *)"full concurrency" : (char *)"3-wire");
#line 332
  if ((int )((priv->lib)->bt_params)->bt_session_2) {
#line 333
    memcpy((void *)(& bt_cmd_v2.basic), (void const   *)(& basic), 68UL);
#line 335
    ret = iwl_dvm_send_cmd_pdu(priv, 155, 0U, 76, (void const   *)(& bt_cmd_v2));
  } else {
#line 338
    memcpy((void *)(& bt_cmd_v1.basic), (void const   *)(& basic), 68UL);
#line 340
    ret = iwl_dvm_send_cmd_pdu(priv, 155, 0U, 72, (void const   *)(& bt_cmd_v1));
  }
#line 343
  if (ret != 0) {
#line 344
    __iwl_err(priv->dev, 0, 0, "failed to send BT Coex Config\n");
  } else {

  }
#line 345
  return;
}
}
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_bt_adjust_rssi_monitor(struct iwl_priv *priv , bool rssi_ena ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *found_ctx ;
  bool found_ap ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 350
  found_ctx = (struct iwl_rxon_context *)0;
#line 351
  found_ap = 0;
#line 353
  if (debug_locks != 0) {
#line 353
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 353
    if (tmp == 0) {
#line 353
      tmp___0 = 1;
    } else {
#line 353
      tmp___0 = 0;
    }
  } else {
#line 353
    tmp___0 = 0;
  }
#line 353
  __ret_warn_on = tmp___0;
#line 353
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 353
  if (tmp___1 != 0L) {
#line 353
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                       353);
  } else {

  }
#line 353
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 356
  if ((int )rssi_ena) {
#line 357
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 357
    goto ldv_55371;
    ldv_55370: ;
#line 357
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 358
      if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 3U) {
#line 358
        tmp___2 = iwl_is_associated_ctx(ctx);
#line 358
        if (tmp___2 != 0) {
#line 360
          found_ap = 1;
#line 361
          goto ldv_55369;
        } else {

        }
      } else {

      }
    } else {

    }
#line 357
    ctx = ctx + 1;
    ldv_55371: ;
#line 357
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 359
      goto ldv_55370;
    } else {

    }
    ldv_55369: ;
  } else {

  }
#line 370
  if (! rssi_ena || (int )found_ap) {
#line 371
    if ((unsigned long )priv->cur_rssi_ctx != (unsigned long )((struct iwl_rxon_context *)0)) {
#line 372
      ctx = priv->cur_rssi_ctx;
#line 373
      ieee80211_disable_rssi_reports(ctx->vif);
#line 374
      priv->cur_rssi_ctx = (struct iwl_rxon_context *)0;
    } else {

    }
#line 376
    return;
  } else {

  }
#line 383
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 383
  goto ldv_55374;
  ldv_55373: ;
#line 383
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 384
    if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 2U) {
#line 384
      tmp___3 = iwl_is_associated_ctx(ctx);
#line 384
      if (tmp___3 != 0) {
#line 386
        found_ctx = ctx;
#line 387
        goto ldv_55372;
      } else {

      }
    } else {

    }
  } else {

  }
#line 383
  ctx = ctx + 1;
  ldv_55374: ;
#line 383
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 385
    goto ldv_55373;
  } else {

  }
  ldv_55372: ;
#line 395
  if ((unsigned long )priv->cur_rssi_ctx == (unsigned long )found_ctx) {
#line 396
    return;
  } else {

  }
#line 404
  if ((unsigned long )priv->cur_rssi_ctx != (unsigned long )((struct iwl_rxon_context *)0)) {
#line 405
    ctx = priv->cur_rssi_ctx;
#line 406
    if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 407
      ieee80211_disable_rssi_reports(ctx->vif);
    } else {

    }
  } else {

  }
#line 410
  priv->cur_rssi_ctx = found_ctx;
#line 412
  if ((unsigned long )found_ctx == (unsigned long )((struct iwl_rxon_context *)0)) {
#line 413
    return;
  } else {

  }
#line 415
  ieee80211_enable_rssi_reports(found_ctx->vif, -75, -65);
#line 416
  return;
}
}
#line 420 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static bool iwlagn_bt_traffic_is_sco(struct iwl_bt_uart_msg *uart_msg ) 
{ 


  {
#line 422
  return (((int )uart_msg->frame3 & 1) != 0);
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static void iwlagn_bt_traffic_change_work(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct iwl_rxon_context *ctx ;
  int smps_request ;
  int tmp ;

  {
#line 429
  __mptr = (struct work_struct  const  *)work;
#line 429
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd198UL;
#line 431
  smps_request = -1;
#line 433
  if ((unsigned int )priv->bt_enable_flag == 0U) {
#line 435
    return;
  } else {

  }
#line 443
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_traffic_change_work", "BT traffic load changes: %d\n",
            (int )priv->bt_traffic_load);
#line 446
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
#line 448
  if ((unsigned int )priv->bt_status != 0U) {
#line 449
    smps_request = 3;
  } else {
#line 451
    smps_request = 0;
  }
#line 452
  goto ldv_55388;
  case 1: 
#line 454
  smps_request = 3;
#line 455
  goto ldv_55388;
  case 2: ;
  case 3: 
#line 458
  smps_request = 2;
#line 459
  goto ldv_55388;
  default: 
#line 461
  __iwl_err(priv->dev, 0, 0, "Invalid BT traffic load: %d\n", (int )priv->bt_traffic_load);
#line 463
  goto ldv_55388;
  }
  ldv_55388: 
#line 466
  ldv_mutex_lock_275(& priv->mutex);
#line 475
  tmp = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
#line 475
  if (tmp != 0) {
#line 476
    goto out;
  } else {

  }
#line 478
  iwl_update_chain_flags(priv);
#line 480
  if (smps_request != -1) {
#line 481
    priv->current_ht_config.smps = (enum ieee80211_smps_mode )smps_request;
#line 482
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 482
    goto ldv_55395;
    ldv_55394: ;
#line 482
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 483
      if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 2U) {
#line 484
        ieee80211_request_smps(ctx->vif, (enum ieee80211_smps_mode )smps_request);
      } else {

      }
    } else {

    }
#line 482
    ctx = ctx + 1;
    ldv_55395: ;
#line 482
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 484
      goto ldv_55394;
    } else {

    }

  } else {

  }
#line 492
  iwlagn_bt_coex_rssi_monitor(priv);
  out: 
#line 494
  ldv_mutex_unlock_276(& priv->mutex);
#line 495
  return;
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_bt_coex_rssi_monitor(struct iwl_priv *priv ) 
{ 


  {
#line 504
  if ((int )priv->bt_is_sco && (unsigned int )priv->bt_traffic_load == 3U) {
#line 506
    iwlagn_bt_adjust_rssi_monitor(priv, 1);
  } else {
#line 508
    iwlagn_bt_adjust_rssi_monitor(priv, 0);
  }
#line 509
  return;
}
}
#line 511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static void iwlagn_print_uartmsg(struct iwl_priv *priv , struct iwl_bt_uart_msg *uart_msg ) 
{ 


  {
#line 514
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Message Type = 0x%X, SSN = 0x%X, Update Req = 0x%X\n",
            (int )uart_msg->frame1 & 7, (int )(((unsigned int )uart_msg->frame1 & 24U) >> 3),
            (int )(((unsigned int )uart_msg->frame1 & 32U) >> 5));
#line 523
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Open connections = 0x%X, Traffic load = 0x%X, Chl_SeqN = 0x%X, In band = 0x%X\n",
            (int )uart_msg->frame2 & 3, (int )(((unsigned int )uart_msg->frame2 & 12U) >> 2),
            (int )(((unsigned int )uart_msg->frame2 & 16U) >> 4), (int )(((unsigned int )uart_msg->frame2 & 32U) >> 5));
#line 534
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "SCO/eSCO = 0x%X, Sniff = 0x%X, A2DP = 0x%X, ACL = 0x%X, Master = 0x%X, OBEX = 0x%X\n",
            (int )uart_msg->frame3 & 1, (int )(((unsigned int )uart_msg->frame3 & 2U) >> 1),
            (int )(((unsigned int )uart_msg->frame3 & 4U) >> 2), (int )(((unsigned int )uart_msg->frame3 & 8U) >> 3),
            (int )(((unsigned int )uart_msg->frame3 & 16U) >> 4), (int )(((unsigned int )uart_msg->frame3 & 32U) >> 5));
#line 549
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Idle duration = 0x%X\n",
            (int )uart_msg->frame4 & 63);
#line 553
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Tx Activity = 0x%X, Rx Activity = 0x%X, eSCO Retransmissions = 0x%X\n",
            (int )uart_msg->frame5 & 3, (int )(((unsigned int )uart_msg->frame5 & 12U) >> 2),
            (int )(((unsigned int )uart_msg->frame5 & 48U) >> 4));
#line 562
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Sniff Interval = 0x%X, Discoverable = 0x%X\n",
            (int )uart_msg->frame6 & 31, (int )(((unsigned int )uart_msg->frame6 & 32U) >> 5));
#line 568
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Sniff Activity = 0x%X, Page = 0x%X, Inquiry = 0x%X, Connectable = 0x%X\n",
            (int )uart_msg->frame7 & 7, (int )(((unsigned int )uart_msg->frame7 & 8U) >> 3),
            (int )(((unsigned int )uart_msg->frame7 & 16U) >> 4), (int )(((unsigned int )uart_msg->frame7 & 32U) >> 5));
#line 569
  return;
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static bool iwlagn_set_kill_msk(struct iwl_priv *priv , struct iwl_bt_uart_msg *uart_msg ) 
{ 
  bool need_update ;
  u8 kill_msk ;
  __le32 bt_kill_ack_msg[3U] ;
  __le32 bt_kill_cts_msg[3U] ;

  {
#line 583
  need_update = 0;
#line 584
  kill_msk = 2U;
#line 585
  bt_kill_ack_msg[0] = 4294901760U;
#line 585
  bt_kill_ack_msg[1] = 4294967295U;
#line 585
  bt_kill_ack_msg[2] = 0U;
#line 589
  bt_kill_cts_msg[0] = 4294901760U;
#line 589
  bt_kill_cts_msg[1] = 4294967295U;
#line 589
  bt_kill_cts_msg[2] = 0U;
#line 594
  if (! priv->reduced_txpower) {
#line 595
    kill_msk = (unsigned int )uart_msg->frame3 & 1U;
  } else {

  }
#line 597
  if (priv->kill_ack_mask != bt_kill_ack_msg[(int )kill_msk] || priv->kill_cts_mask != bt_kill_cts_msg[(int )kill_msk]) {
#line 599
    priv->bt_valid = (__le16 )((unsigned int )priv->bt_valid | 16U);
#line 600
    priv->kill_ack_mask = bt_kill_ack_msg[(int )kill_msk];
#line 601
    priv->bt_valid = (__le16 )((unsigned int )priv->bt_valid | 32U);
#line 602
    priv->kill_cts_mask = bt_kill_cts_msg[(int )kill_msk];
#line 603
    need_update = 1;
  } else {

  }
#line 605
  return (need_update);
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static bool iwlagn_fill_txpower_mode(struct iwl_priv *priv , struct iwl_bt_uart_msg *uart_msg ) 
{ 
  bool need_update ;
  struct iwl_rxon_context *ctx ;
  int ave_rssi ;
  int tmp ;
  int tmp___0 ;

  {
#line 620
  need_update = 0;
#line 621
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 624
  if ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0) || (unsigned int )(ctx->vif)->type != 2U) {
#line 625
    __iwl_dbg(priv->dev, 1U, 0, "iwlagn_fill_txpower_mode", "BSS ctx not active or not in sta mode\n");
#line 626
    return (0);
  } else {

  }
#line 629
  ave_rssi = ieee80211_ave_rssi(ctx->vif);
#line 630
  if (ave_rssi == 0) {
#line 632
    __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_fill_txpower_mode", "no rssi data available\n");
#line 633
    return (need_update);
  } else {

  }
#line 635
  if (! priv->reduced_txpower) {
#line 635
    tmp___0 = iwl_is_associated(priv, 1);
#line 635
    if (tmp___0 == 0) {
#line 635
      if (ave_rssi >= -61) {
#line 635
        if (((int )uart_msg->frame3 & 40) != 0) {
#line 635
          if (((int )uart_msg->frame3 & 7) == 0) {
#line 643
            priv->reduced_txpower = 1;
#line 644
            priv->bt_valid = (__le16 )((unsigned int )priv->bt_valid | 64U);
#line 645
            need_update = 1;
          } else {
#line 635
            goto _L___2;
          }
        } else {
#line 635
          goto _L___2;
        }
      } else {
#line 635
        goto _L___2;
      }
    } else {
#line 635
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 646
  if ((int )priv->reduced_txpower) {
#line 646
    tmp = iwl_is_associated(priv, 1);
#line 646
    if (((tmp != 0 || ave_rssi < -65) || ((int )uart_msg->frame3 & 7) != 0) || ((int )uart_msg->frame3 & 40) == 0) {
#line 654
      priv->reduced_txpower = 0;
#line 655
      priv->bt_valid = (__le16 )((unsigned int )priv->bt_valid | 64U);
#line 656
      need_update = 1;
    } else {

    }
  } else {

  }
#line 659
  return (need_update);
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwlagn_bt_coex_profile_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                 struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_bt_coex_profile_notif *coex ;
  struct iwl_bt_uart_msg *uart_msg ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 666
  tmp = rxb_addr(rxb);
#line 666
  pkt = (struct iwl_rx_packet *)tmp;
#line 667
  coex = (struct iwl_bt_coex_profile_notif *)(& pkt->data);
#line 668
  uart_msg = & coex->last_bt_uart_msg;
#line 670
  if ((unsigned int )priv->bt_enable_flag == 0U) {
#line 672
    return (0);
  } else {

  }
#line 675
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_coex_profile_notif", "BT Coex notification:\n");
#line 676
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_coex_profile_notif", "    status: %d\n",
            (int )coex->bt_status);
#line 677
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_coex_profile_notif", "    traffic load: %d\n",
            (int )coex->bt_traffic_load);
#line 678
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_coex_profile_notif", "    CI compliance: %d\n",
            (int )coex->bt_ci_compliance);
#line 680
  iwlagn_print_uartmsg(priv, uart_msg);
#line 682
  priv->last_bt_traffic_load = priv->bt_traffic_load;
#line 683
  priv->bt_is_sco = iwlagn_bt_traffic_is_sco(uart_msg);
#line 685
  if ((unsigned int )priv->iw_mode != 1U) {
#line 686
    if ((int )priv->bt_status != (int )coex->bt_status || (int )priv->last_bt_traffic_load != (int )coex->bt_traffic_load) {
#line 688
      if ((unsigned int )coex->bt_status != 0U) {
#line 690
        if (! priv->bt_ch_announce) {
#line 691
          priv->bt_traffic_load = 2U;
        } else {
#line 694
          priv->bt_traffic_load = coex->bt_traffic_load;
        }
      } else {
#line 698
        priv->bt_traffic_load = 0U;
      }
#line 701
      priv->bt_status = coex->bt_status;
#line 702
      queue_work___3(priv->workqueue, & priv->bt_traffic_change_work);
    } else {

    }
  } else {

  }
#line 709
  tmp___0 = iwlagn_fill_txpower_mode(priv, uart_msg);
#line 709
  if ((int )tmp___0) {
#line 711
    queue_work___3(priv->workqueue, & priv->bt_runtime_config);
  } else {
#line 709
    tmp___1 = iwlagn_set_kill_msk(priv, uart_msg);
#line 709
    if ((int )tmp___1) {
#line 711
      queue_work___3(priv->workqueue, & priv->bt_runtime_config);
    } else {

    }
  }
#line 716
  priv->bt_ci_compliance = coex->bt_ci_compliance;
#line 717
  return (0);
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_bt_rx_handler_setup(struct iwl_priv *priv ) 
{ 


  {
#line 722
  priv->rx_handlers[206] = & iwlagn_bt_coex_profile_notif;
#line 724
  return;
}
}
#line 726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_bt_setup_deferred_work(struct iwl_priv *priv ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 728
  __init_work(& priv->bt_traffic_change_work, 0);
#line 728
  __constr_expr_0.counter = 137438953408L;
#line 728
  priv->bt_traffic_change_work.data = __constr_expr_0;
#line 728
  lockdep_init_map(& priv->bt_traffic_change_work.lockdep_map, "(&priv->bt_traffic_change_work)",
                   & __key, 0);
#line 728
  INIT_LIST_HEAD(& priv->bt_traffic_change_work.entry);
#line 728
  priv->bt_traffic_change_work.func = & iwlagn_bt_traffic_change_work;
#line 730
  return;
}
}
#line 732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_bt_cancel_deferred_work(struct iwl_priv *priv ) 
{ 


  {
#line 734
  ldv_cancel_work_sync_277(& priv->bt_traffic_change_work);
#line 735
  return;
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static bool is_single_rx_stream(struct iwl_priv *priv ) 
{ 


  {
#line 739
  return ((bool )((unsigned int )priv->current_ht_config.smps == 2U || (int )priv->current_ht_config.single_chain_sufficient));
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static int iwl_get_active_rx_chain_count(struct iwl_priv *priv ) 
{ 
  bool tmp ;

  {
#line 760
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && ((int )priv->bt_full_concurrent || (unsigned int )priv->bt_traffic_load > 1U)) {
#line 768
    return (2);
  } else {

  }
#line 771
  tmp = is_single_rx_stream(priv);
#line 771
  if ((int )tmp) {
#line 772
    return (2);
  } else {
#line 774
    return (3);
  }
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static int iwl_get_idle_rx_chain_count(struct iwl_priv *priv , int active_cnt ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 784
  switch ((unsigned int )priv->current_ht_config.smps) {
  case 2U: ;
  case 3U: ;
#line 787
  return (1);
  case 0U: ;
  case 1U: ;
#line 790
  return (active_cnt);
  default: 
#line 792
  __ret_warn_on = 1;
#line 792
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 792
  if (tmp != 0L) {
#line 792
    warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                      793, "invalid SMPS mode %d", (unsigned int )priv->current_ht_config.smps);
  } else {

  }
#line 792
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 794
  return (active_cnt);
  }
}
}
#line 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static u8 iwl_count_chain_bitmap(u32 chain_bitmap ) 
{ 
  u8 res ;

  {
#line 802
  res = (unsigned int )((u8 )chain_bitmap) & 1U;
#line 803
  res = (int )((u8 )(((unsigned long )chain_bitmap & 2UL) >> 1)) + (int )res;
#line 804
  res = (int )((u8 )(((unsigned long )chain_bitmap & 4UL) >> 2)) + (int )res;
#line 805
  res = (int )((u8 )(((unsigned long )chain_bitmap & 8UL) >> 3)) + (int )res;
#line 806
  return (res);
}
}
#line 815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
void iwlagn_set_rxon_chain(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  bool is_single ;
  bool tmp ;
  bool is_cam ;
  int tmp___0 ;
  u8 idle_rx_cnt ;
  u8 active_rx_cnt ;
  u8 valid_rx_cnt ;
  u32 active_chains ;
  u16 rx_chain ;
  u8 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __ret_warn_on ;
  long tmp___4 ;

  {
#line 817
  tmp = is_single_rx_stream(priv);
#line 817
  is_single = tmp;
#line 818
  tmp___0 = constant_test_bit(13L, (unsigned long const volatile   *)(& priv->status));
#line 818
  is_cam = tmp___0 == 0;
#line 827
  if (priv->chain_noise_data.active_chains != 0U) {
#line 828
    active_chains = priv->chain_noise_data.active_chains;
  } else {
#line 830
    active_chains = (u32 )(priv->nvm_data)->valid_rx_ant;
  }
#line 832
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && ((int )priv->bt_full_concurrent || (unsigned int )priv->bt_traffic_load > 1U)) {
#line 840
    tmp___1 = first_antenna((int )((u8 )active_chains));
#line 840
    active_chains = (u32 )tmp___1;
  } else {

  }
#line 843
  rx_chain = (int )((u16 )active_chains) << 1U;
#line 846
  tmp___2 = iwl_get_active_rx_chain_count(priv);
#line 846
  active_rx_cnt = (u8 )tmp___2;
#line 847
  tmp___3 = iwl_get_idle_rx_chain_count(priv, (int )active_rx_cnt);
#line 847
  idle_rx_cnt = (u8 )tmp___3;
#line 853
  valid_rx_cnt = iwl_count_chain_bitmap(active_chains);
#line 854
  if ((int )valid_rx_cnt < (int )active_rx_cnt) {
#line 855
    active_rx_cnt = valid_rx_cnt;
  } else {

  }
#line 857
  if ((int )valid_rx_cnt < (int )idle_rx_cnt) {
#line 858
    idle_rx_cnt = valid_rx_cnt;
  } else {

  }
#line 860
  rx_chain = (u16 )((int )((short )((int )active_rx_cnt << 12)) | (int )((short )rx_chain));
#line 861
  rx_chain = (u16 )((int )((short )((int )idle_rx_cnt << 10)) | (int )((short )rx_chain));
#line 863
  ctx->staging.rx_chain = rx_chain;
#line 865
  if ((! is_single && (unsigned int )active_rx_cnt > 1U) && (int )is_cam) {
#line 866
    ctx->staging.rx_chain = (__le16 )((unsigned int )ctx->staging.rx_chain | 16384U);
  } else {
#line 868
    ctx->staging.rx_chain = (unsigned int )ctx->staging.rx_chain & 49151U;
  }
#line 870
  __iwl_dbg(priv->dev, 4097U, 0, "iwlagn_set_rxon_chain", "rx_chain=0x%X active=%d idle=%d\n",
            (int )ctx->staging.rx_chain, (int )active_rx_cnt, (int )idle_rx_cnt);
#line 874
  __ret_warn_on = ((unsigned int )active_rx_cnt == 0U || (unsigned int )idle_rx_cnt == 0U) || (int )active_rx_cnt < (int )idle_rx_cnt;
#line 874
  tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 874
  if (tmp___4 != 0L) {
#line 874
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                       875);
  } else {

  }
#line 874
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 876
  return;
}
}
#line 878 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
u8 iwl_toggle_tx_ant(struct iwl_priv *priv , u8 ant , u8 valid ) 
{ 
  int i ;
  u8 ind ;

  {
#line 881
  ind = ant;
#line 883
  if ((unsigned int )priv->band == 0U && (unsigned int )priv->bt_traffic_load > 1U) {
#line 885
    return (0U);
  } else {

  }
#line 887
  i = 0;
#line 887
  goto ldv_55484;
  ldv_55483: 
#line 888
  ind = (int )ind + 1 <= 2 ? (unsigned int )ind + 1U : 0U;
#line 889
  if ((int )((unsigned long )valid >> (int )ind) & 1) {
#line 890
    return (ind);
  } else {

  }
#line 887
  i = i + 1;
  ldv_55484: ;
#line 887
  if (i <= 1) {
#line 889
    goto ldv_55483;
  } else {

  }

#line 892
  return (ant);
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static void iwlagn_convert_p1k(u16 *p1k , __le16 *out ) 
{ 
  int i ;

  {
#line 900
  i = 0;
#line 900
  goto ldv_55492;
  ldv_55491: 
#line 901
  *(out + (unsigned long )i) = *(p1k + (unsigned long )i);
#line 900
  i = i + 1;
  ldv_55492: ;
#line 900
  if (i <= 4) {
#line 902
    goto ldv_55491;
  } else {

  }

#line 907
  return;
}
}
#line 913 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
static void iwlagn_wowlan_program_keys(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                       struct ieee80211_sta *sta , struct ieee80211_key_conf *key ,
                                       void *_data___0 ) 
{ 
  struct iwl_priv *priv ;
  struct wowlan_key_data *data ;
  struct iwl_rxon_context *ctx ;
  struct aes_sc *aes_sc ;
  struct aes_sc *aes_tx_sc ;
  struct tkip_sc *tkip_sc ;
  struct tkip_sc *tkip_tx_sc ;
  struct iwlagn_p1k_cache *rx_p1ks ;
  u8 *rx_mic_key ;
  struct ieee80211_key_seq seq ;
  u32 cur_rx_iv32 ;
  u16 p1k[5U] ;
  int ret ;
  int i ;
  u8 *pn ;
  u8 *pn___0 ;

  {
#line 919
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 920
  data = (struct wowlan_key_data *)_data___0;
#line 921
  ctx = data->ctx;
#line 922
  aes_tx_sc = (struct aes_sc *)0;
#line 923
  tkip_tx_sc = (struct tkip_sc *)0;
#line 927
  cur_rx_iv32 = 0U;
#line 931
  ldv_mutex_lock_278(& priv->mutex);
#line 933
  if (((key->cipher == 1027073U || key->cipher == 1027077U) && (unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) && (unsigned int )ctx->key_mapping_keys == 0U) {
#line 936
    ret = iwl_set_default_wep_key(priv, ctx, key);
  } else {
#line 938
    ret = iwl_set_dynamic_key(priv, ctx, key, sta);
  }
#line 940
  if (ret != 0) {
#line 941
    __iwl_err(priv->dev, 0, 0, "Error setting key during suspend!\n");
#line 942
    data->error = 1;
  } else {

  }
#line 945
  switch (key->cipher) {
  case 1027074U: ;
#line 947
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
#line 948
    tkip_sc = (struct tkip_sc *)(& (data->rsc_tsc)->all_tsc_rsc.tkip.unicast_rsc);
#line 949
    tkip_tx_sc = & (data->rsc_tsc)->all_tsc_rsc.tkip.tsc;
#line 951
    rx_p1ks = (struct iwlagn_p1k_cache *)(& (data->tkip)->rx_uni);
#line 953
    ieee80211_get_key_tx_seq(key, & seq);
#line 954
    tkip_tx_sc->iv16 = seq.__annonCompField100.tkip.iv16;
#line 955
    tkip_tx_sc->iv32 = seq.__annonCompField100.tkip.iv32;
#line 957
    ieee80211_get_tkip_p1k_iv(key, seq.__annonCompField100.tkip.iv32, (u16 *)(& p1k));
#line 958
    iwlagn_convert_p1k((u16 *)(& p1k), (__le16 *)(& (data->tkip)->tx.p1k));
#line 960
    memcpy((void *)(& (data->tkip)->mic_keys.tx), (void const   *)(& key->key) + 16U,
             8UL);
#line 964
    rx_mic_key = (u8 *)(& (data->tkip)->mic_keys.rx_unicast);
  } else {
#line 966
    tkip_sc = (struct tkip_sc *)(& (data->rsc_tsc)->all_tsc_rsc.tkip.multicast_rsc);
#line 968
    rx_p1ks = (struct iwlagn_p1k_cache *)(& (data->tkip)->rx_multi);
#line 969
    rx_mic_key = (u8 *)(& (data->tkip)->mic_keys.rx_mcast);
  }
#line 977
  i = 0;
#line 977
  goto ldv_55525;
  ldv_55524: 
#line 978
  ieee80211_get_key_rx_seq(key, i, & seq);
#line 979
  (tkip_sc + (unsigned long )i)->iv16 = seq.__annonCompField100.tkip.iv16;
#line 980
  (tkip_sc + (unsigned long )i)->iv32 = seq.__annonCompField100.tkip.iv32;
#line 982
  if (seq.__annonCompField100.tkip.iv32 > cur_rx_iv32) {
#line 983
    cur_rx_iv32 = seq.__annonCompField100.tkip.iv32;
  } else {

  }
#line 977
  i = i + 1;
  ldv_55525: ;
#line 977
  if (i <= 15) {
#line 979
    goto ldv_55524;
  } else {

  }
#line 986
  ieee80211_get_tkip_rx_p1k(key, data->bssid, cur_rx_iv32, (u16 *)(& p1k));
#line 987
  iwlagn_convert_p1k((u16 *)(& p1k), (__le16 *)(& rx_p1ks->p1k));
#line 988
  ieee80211_get_tkip_rx_p1k(key, data->bssid, cur_rx_iv32 + 1U, (u16 *)(& p1k));
#line 990
  iwlagn_convert_p1k((u16 *)(& p1k), (__le16 *)(& (rx_p1ks + 1UL)->p1k));
#line 992
  memcpy((void *)rx_mic_key, (void const   *)(& key->key) + 24U, 8UL);
#line 996
  data->use_tkip = 1;
#line 997
  data->use_rsc_tsc = 1;
#line 998
  goto ldv_55527;
  case 1027076U: ;
#line 1000
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
#line 1001
    pn = (u8 *)(& seq.__annonCompField100.ccmp.pn);
#line 1003
    aes_sc = (struct aes_sc *)(& (data->rsc_tsc)->all_tsc_rsc.aes.unicast_rsc);
#line 1004
    aes_tx_sc = & (data->rsc_tsc)->all_tsc_rsc.aes.tsc;
#line 1006
    ieee80211_get_key_tx_seq(key, & seq);
#line 1007
    aes_tx_sc->pn = (((((unsigned long long )*(pn + 5UL) | ((unsigned long long )*(pn + 4UL) << 8)) | ((unsigned long long )*(pn + 3UL) << 16)) | ((unsigned long long )*(pn + 2UL) << 24)) | ((unsigned long long )*(pn + 1UL) << 32)) | ((unsigned long long )*pn << 40);
  } else {
#line 1015
    aes_sc = (struct aes_sc *)(& (data->rsc_tsc)->all_tsc_rsc.aes.multicast_rsc);
  }
#line 1021
  i = 0;
#line 1021
  goto ldv_55532;
  ldv_55531: 
#line 1022
  pn___0 = (u8 *)(& seq.__annonCompField100.ccmp.pn);
#line 1024
  ieee80211_get_key_rx_seq(key, i, & seq);
#line 1025
  aes_sc->pn = (((((unsigned long long )*(pn___0 + 5UL) | ((unsigned long long )*(pn___0 + 4UL) << 8)) | ((unsigned long long )*(pn___0 + 3UL) << 16)) | ((unsigned long long )*(pn___0 + 2UL) << 24)) | ((unsigned long long )*(pn___0 + 1UL) << 32)) | ((unsigned long long )*pn___0 << 40);
#line 1021
  i = i + 1;
  ldv_55532: ;
#line 1021
  if (i <= 15) {
#line 1023
    goto ldv_55531;
  } else {

  }
#line 1033
  data->use_rsc_tsc = 1;
#line 1034
  goto ldv_55527;
  }
  ldv_55527: 
#line 1037
  ldv_mutex_unlock_279(& priv->mutex);
#line 1038
  return;
}
}
#line 1040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwlagn_send_patterns(struct iwl_priv *priv , struct cfg80211_wowlan *wowlan ) 
{ 
  struct iwlagn_wowlan_patterns_cmd *pattern_cmd ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  int i ;
  int err ;
  void *tmp___0 ;
  int mask_len ;

  {
#line 1044
  cmd.data[0] = 0;
#line 1044
  cmd.data[1] = 0;
#line 1044
  cmd.resp_pkt = 0;
#line 1044
  cmd._rx_page_addr = 0UL;
#line 1044
  cmd._rx_page_order = 0U;
#line 1044
  cmd.handler_status = 0;
#line 1044
  cmd.flags = 0U;
#line 1044
  cmd.len[0] = (unsigned short)0;
#line 1044
  cmd.len[1] = (unsigned short)0;
#line 1044
  cmd.dataflags[0] = 1U;
#line 1044
  tmp = 1U;
#line 1044
  while (1) {
#line 1044
    if (tmp >= 2U) {
#line 1044
      break;
    } else {

    }
#line 1044
    cmd.dataflags[tmp] = (unsigned char)0;
#line 1044
    tmp = tmp + 1U;
  }
#line 1044
  cmd.id = 224U;
#line 1050
  if (wowlan->n_patterns == 0) {
#line 1051
    return (0);
  } else {

  }
#line 1053
  cmd.len[0] = (unsigned int )((u16 )((unsigned long )wowlan->n_patterns)) * 148U + 4U;
#line 1056
  tmp___0 = kmalloc((size_t )cmd.len[0], 208U);
#line 1056
  pattern_cmd = (struct iwlagn_wowlan_patterns_cmd *)tmp___0;
#line 1057
  if ((unsigned long )pattern_cmd == (unsigned long )((struct iwlagn_wowlan_patterns_cmd *)0)) {
#line 1058
    return (-12);
  } else {

  }
#line 1060
  pattern_cmd->n_patterns = (unsigned int )wowlan->n_patterns;
#line 1062
  i = 0;
#line 1062
  goto ldv_55544;
  ldv_55543: 
#line 1063
  mask_len = ((wowlan->patterns + (unsigned long )i)->pattern_len + 7) / 8;
#line 1065
  memcpy((void *)(& pattern_cmd->patterns[i].mask), (void const   *)(wowlan->patterns + (unsigned long )i)->mask,
           (size_t )mask_len);
#line 1067
  memcpy((void *)(& pattern_cmd->patterns[i].pattern), (void const   *)(wowlan->patterns + (unsigned long )i)->pattern,
           (size_t )(wowlan->patterns + (unsigned long )i)->pattern_len);
#line 1070
  pattern_cmd->patterns[i].mask_size = (u8 )mask_len;
#line 1071
  pattern_cmd->patterns[i].pattern_size = (u8 )(wowlan->patterns + (unsigned long )i)->pattern_len;
#line 1062
  i = i + 1;
  ldv_55544: ;
#line 1062
  if (wowlan->n_patterns > i) {
#line 1064
    goto ldv_55543;
  } else {

  }
#line 1075
  cmd.data[0] = (void const   *)pattern_cmd;
#line 1076
  err = iwl_dvm_send_cmd(priv, & cmd);
#line 1077
  kfree((void const   *)pattern_cmd);
#line 1078
  return (err);
}
}
#line 1081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwlagn_suspend(struct iwl_priv *priv , struct cfg80211_wowlan *wowlan ) 
{ 
  struct iwlagn_wowlan_wakeup_filter_cmd wakeup_filter_cmd ;
  struct iwl_rxon_cmd rxon ;
  struct iwl_rxon_context *ctx ;
  struct iwlagn_wowlan_kek_kck_material_cmd kek_kck_cmd ;
  struct iwlagn_wowlan_tkip_params_cmd tkip_cmd ;
  struct iwlagn_d3_config_cmd d3_cfg_cmd ;
  struct wowlan_key_data key_data ;
  int ret ;
  int i ;
  u16 seq ;
  void *tmp ;
  struct iwl_host_cmd rsc_tsc_cmd ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1085
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 1087
  tkip_cmd.mic_keys.tx[0] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.tx[1] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.tx[2] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.tx[3] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.tx[4] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.tx[5] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.tx[6] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.tx[7] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_unicast[0] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_unicast[1] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_unicast[2] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_unicast[3] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_unicast[4] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_unicast[5] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_unicast[6] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_unicast[7] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_mcast[0] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_mcast[1] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_mcast[2] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_mcast[3] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_mcast[4] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_mcast[5] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_mcast[6] = (unsigned char)0;
#line 1087
  tkip_cmd.mic_keys.rx_mcast[7] = (unsigned char)0;
#line 1087
  tkip_cmd.tx.p1k[0] = (unsigned short)0;
#line 1087
  tkip_cmd.tx.p1k[1] = (unsigned short)0;
#line 1087
  tkip_cmd.tx.p1k[2] = (unsigned short)0;
#line 1087
  tkip_cmd.tx.p1k[3] = (unsigned short)0;
#line 1087
  tkip_cmd.tx.p1k[4] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[0].p1k[0] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[0].p1k[1] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[0].p1k[2] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[0].p1k[3] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[0].p1k[4] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[1].p1k[0] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[1].p1k[1] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[1].p1k[2] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[1].p1k[3] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_uni[1].p1k[4] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[0].p1k[0] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[0].p1k[1] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[0].p1k[2] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[0].p1k[3] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[0].p1k[4] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[1].p1k[0] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[1].p1k[1] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[1].p1k[2] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[1].p1k[3] = (unsigned short)0;
#line 1087
  tkip_cmd.rx_multi[1].p1k[4] = (unsigned short)0;
#line 1088
  d3_cfg_cmd.min_sleep_time = 10000000U;
#line 1088
  d3_cfg_cmd.wakeup_flags = 0U;
#line 1096
  key_data.ctx = ctx;
#line 1096
  key_data.rsc_tsc = 0;
#line 1096
  key_data.tkip = & tkip_cmd;
#line 1096
  key_data.bssid = (u8 const   *)(& ctx->active.bssid_addr);
#line 1096
  key_data.error = (_Bool)0;
#line 1096
  key_data.use_rsc_tsc = 0;
#line 1096
  key_data.use_tkip = 0;
#line 1106
  tmp = kzalloc(264UL, 208U);
#line 1106
  key_data.rsc_tsc = (struct iwlagn_wowlan_rsc_tsc_params_cmd *)tmp;
#line 1107
  if ((unsigned long )key_data.rsc_tsc == (unsigned long )((struct iwlagn_wowlan_rsc_tsc_params_cmd *)0)) {
#line 1108
    return (-12);
  } else {

  }
#line 1110
  memset((void *)(& wakeup_filter_cmd), 0, 24UL);
#line 1116
  seq = (unsigned int )priv->last_seq_ctl & 65520U;
#line 1117
  wakeup_filter_cmd.non_qos_seq = seq;
#line 1123
  i = 0;
#line 1123
  goto ldv_55561;
  ldv_55560: 
#line 1124
  seq = priv->tid_data[0][i].seq_number;
#line 1125
  seq = (unsigned int )seq + 65520U;
#line 1126
  wakeup_filter_cmd.qos_seq[i] = seq;
#line 1123
  i = i + 1;
  ldv_55561: ;
#line 1123
  if (i <= 7) {
#line 1125
    goto ldv_55560;
  } else {

  }

#line 1129
  if ((int )wowlan->disconnect) {
#line 1130
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 12U;
  } else {

  }
#line 1133
  if ((int )wowlan->magic_pkt) {
#line 1134
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 1U;
  } else {

  }
#line 1136
  if ((int )wowlan->gtk_rekey_failure) {
#line 1137
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 16U;
  } else {

  }
#line 1139
  if ((int )wowlan->eap_identity_req) {
#line 1140
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 32U;
  } else {

  }
#line 1142
  if ((int )wowlan->four_way_handshake) {
#line 1143
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 64U;
  } else {

  }
#line 1145
  if (wowlan->n_patterns != 0) {
#line 1146
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 2U;
  } else {

  }
#line 1149
  if ((int )wowlan->rfkill_release) {
#line 1150
    d3_cfg_cmd.wakeup_flags = d3_cfg_cmd.wakeup_flags | 1U;
  } else {

  }
#line 1153
  iwl_scan_cancel_timeout(priv, 200UL);
#line 1155
  memcpy((void *)(& rxon), (void const   *)(& ctx->active), 50UL);
#line 1157
  priv->ucode_loaded = 0;
#line 1158
  iwl_trans_stop_device(priv->trans);
#line 1160
  priv->wowlan = 1;
#line 1162
  ret = iwl_load_ucode_wait_alive(priv, 2);
#line 1163
  if (ret != 0) {
#line 1164
    goto out;
  } else {

  }
#line 1167
  ret = iwl_alive_start(priv);
#line 1168
  if (ret != 0) {
#line 1169
    goto out;
  } else {

  }
#line 1171
  memcpy((void *)(& ctx->staging), (void const   *)(& rxon), 50UL);
#line 1172
  ret = iwlagn_commit_rxon(priv, ctx);
#line 1173
  if (ret != 0) {
#line 1174
    goto out;
  } else {

  }
#line 1176
  ret = iwl_power_update_mode(priv, 1);
#line 1177
  if (ret != 0) {
#line 1178
    goto out;
  } else {

  }
#line 1180
  if (iwlwifi_mod_params.sw_crypto == 0) {
#line 1182
    priv->ucode_key_table = 0UL;
#line 1183
    ctx->key_mapping_keys = 0U;
#line 1190
    ldv_mutex_unlock_280(& priv->mutex);
#line 1191
    ieee80211_iter_keys(priv->hw, ctx->vif, & iwlagn_wowlan_program_keys, (void *)(& key_data));
#line 1194
    ldv_mutex_lock_281(& priv->mutex);
#line 1195
    if ((int )key_data.error) {
#line 1196
      ret = -5;
#line 1197
      goto out;
    } else {

    }
#line 1200
    if ((int )key_data.use_rsc_tsc) {
#line 1201
      rsc_tsc_cmd.data[0] = (void const   *)key_data.rsc_tsc;
#line 1201
      tmp___0 = 1U;
#line 1201
      while (1) {
#line 1201
        if (tmp___0 >= 2U) {
#line 1201
          break;
        } else {

        }
#line 1201
        rsc_tsc_cmd.data[tmp___0] = 0;
#line 1201
        tmp___0 = tmp___0 + 1U;
      }
#line 1201
      rsc_tsc_cmd.resp_pkt = 0;
#line 1201
      rsc_tsc_cmd._rx_page_addr = 0UL;
#line 1201
      rsc_tsc_cmd._rx_page_order = 0U;
#line 1201
      rsc_tsc_cmd.handler_status = 0;
#line 1201
      rsc_tsc_cmd.flags = 0U;
#line 1201
      rsc_tsc_cmd.len[0] = 264U;
#line 1201
      tmp___1 = 1U;
#line 1201
      while (1) {
#line 1201
        if (tmp___1 >= 2U) {
#line 1201
          break;
        } else {

        }
#line 1201
        rsc_tsc_cmd.len[tmp___1] = (unsigned short)0;
#line 1201
        tmp___1 = tmp___1 + 1U;
      }
#line 1201
      rsc_tsc_cmd.dataflags[0] = 1U;
#line 1201
      tmp___2 = 1U;
#line 1201
      while (1) {
#line 1201
        if (tmp___2 >= 2U) {
#line 1201
          break;
        } else {

        }
#line 1201
        rsc_tsc_cmd.dataflags[tmp___2] = (unsigned char)0;
#line 1201
        tmp___2 = tmp___2 + 1U;
      }
#line 1201
      rsc_tsc_cmd.id = 226U;
#line 1208
      ret = iwl_dvm_send_cmd(priv, & rsc_tsc_cmd);
#line 1209
      if (ret != 0) {
#line 1210
        goto out;
      } else {

      }
    } else {

    }
#line 1213
    if ((int )key_data.use_tkip) {
#line 1214
      ret = iwl_dvm_send_cmd_pdu(priv, 227, 0U, 74, (void const   *)(& tkip_cmd));
#line 1218
      if (ret != 0) {
#line 1219
        goto out;
      } else {

      }
    } else {

    }
#line 1222
    if ((int )priv->have_rekey_data) {
#line 1223
      memset((void *)(& kek_kck_cmd), 0, 76UL);
#line 1224
      memcpy((void *)(& kek_kck_cmd.kck), (void const   *)(& priv->kck), 16UL);
#line 1225
      kek_kck_cmd.kck_len = 16U;
#line 1226
      memcpy((void *)(& kek_kck_cmd.kek), (void const   *)(& priv->kek), 16UL);
#line 1227
      kek_kck_cmd.kek_len = 16U;
#line 1228
      kek_kck_cmd.replay_ctr = priv->replay_ctr;
#line 1230
      ret = iwl_dvm_send_cmd_pdu(priv, 228, 0U, 76, (void const   *)(& kek_kck_cmd));
#line 1234
      if (ret != 0) {
#line 1235
        goto out;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1239
  ret = iwl_dvm_send_cmd_pdu(priv, 211, 0U, 8, (void const   *)(& d3_cfg_cmd));
#line 1241
  if (ret != 0) {
#line 1242
    goto out;
  } else {

  }
#line 1244
  ret = iwl_dvm_send_cmd_pdu(priv, 225, 0U, 24, (void const   *)(& wakeup_filter_cmd));
#line 1247
  if (ret != 0) {
#line 1248
    goto out;
  } else {

  }
#line 1250
  ret = iwlagn_send_patterns(priv, wowlan);
  out: 
#line 1252
  kfree((void const   *)key_data.rsc_tsc);
#line 1253
  return (ret);
}
}
#line 1257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwl_dvm_send_cmd(struct iwl_priv *priv , struct iwl_host_cmd *cmd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int __ret_warn_on ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
#line 1259
  tmp___0 = iwl_is_rfkill(priv);
#line 1259
  if (tmp___0 != 0) {
#line 1260
    tmp = iwl_is_rfkill(priv);
#line 1260
    __iwl_warn(priv->dev, "Not sending command - %s KILL\n", tmp != 0 ? (char *)"RF" : (char *)"CT");
#line 1262
    return (-5);
  } else {
#line 1259
    tmp___1 = iwl_is_ctkill(priv);
#line 1259
    if (tmp___1 != 0) {
#line 1260
      tmp = iwl_is_rfkill(priv);
#line 1260
      __iwl_warn(priv->dev, "Not sending command - %s KILL\n", tmp != 0 ? (char *)"RF" : (char *)"CT");
#line 1262
      return (-5);
    } else {

    }
  }
#line 1265
  tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->status));
#line 1265
  if (tmp___3 != 0) {
#line 1266
    tmp___2 = iwl_dvm_get_cmd_string((int )cmd->id);
#line 1266
    __iwl_err(priv->dev, 0, 0, "Command %s failed: FW Error\n", tmp___2);
#line 1268
    return (-5);
  } else {

  }
#line 1275
  if (! priv->ucode_loaded) {
#line 1276
    __iwl_err(priv->dev, 0, 0, "Fw not loaded - dropping CMD: %x\n", (int )cmd->id);
#line 1277
    return (-5);
  } else {

  }
#line 1285
  if ((cmd->flags & 1U) == 0U) {
#line 1286
    if (debug_locks != 0) {
#line 1286
      tmp___4 = lock_is_held(& priv->mutex.dep_map);
#line 1286
      if (tmp___4 == 0) {
#line 1286
        tmp___5 = 1;
      } else {
#line 1286
        tmp___5 = 0;
      }
    } else {
#line 1286
      tmp___5 = 0;
    }
#line 1286
    __ret_warn_on = tmp___5;
#line 1286
    tmp___6 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1286
    if (tmp___6 != 0L) {
#line 1286
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                         1286);
    } else {

    }
#line 1286
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  } else {

  }
#line 1288
  tmp___7 = iwl_trans_send_cmd(priv->trans, cmd);
#line 1288
  return (tmp___7);
}
}
#line 1291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.c"
int iwl_dvm_send_cmd_pdu(struct iwl_priv *priv , u8 id , u32 flags , u16 len , void const   *data ) 
{ 
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 1294
  cmd.data[0] = data;
#line 1294
  tmp = 1U;
#line 1294
  while (1) {
#line 1294
    if (tmp >= 2U) {
#line 1294
      break;
    } else {

    }
#line 1294
    cmd.data[tmp] = 0;
#line 1294
    tmp = tmp + 1U;
  }
#line 1294
  cmd.resp_pkt = 0;
#line 1294
  cmd._rx_page_addr = 0UL;
#line 1294
  cmd._rx_page_order = 0U;
#line 1294
  cmd.handler_status = 0;
#line 1294
  cmd.flags = flags;
#line 1294
  cmd.len[0] = len;
#line 1294
  tmp___0 = 1U;
#line 1294
  while (1) {
#line 1294
    if (tmp___0 >= 2U) {
#line 1294
      break;
    } else {

    }
#line 1294
    cmd.len[tmp___0] = (unsigned short)0;
#line 1294
    tmp___0 = tmp___0 + 1U;
  }
#line 1294
  cmd.dataflags[0] = (unsigned char)0;
#line 1294
  cmd.dataflags[1] = (unsigned char)0;
#line 1294
  cmd.id = id;
#line 1301
  tmp___1 = iwl_dvm_send_cmd(priv, & cmd);
#line 1301
  return (tmp___1);
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void disable_work_7(struct work_struct *work ) 
{ 


  {
#line 552
  if ((ldv_work_7_0 == 3 || ldv_work_7_0 == 2) && (unsigned long )ldv_work_struct_7_0 == (unsigned long )work) {
#line 554
    ldv_work_7_0 = 1;
  } else {

  }
#line 556
  if ((ldv_work_7_1 == 3 || ldv_work_7_1 == 2) && (unsigned long )ldv_work_struct_7_1 == (unsigned long )work) {
#line 558
    ldv_work_7_1 = 1;
  } else {

  }
#line 560
  if ((ldv_work_7_2 == 3 || ldv_work_7_2 == 2) && (unsigned long )ldv_work_struct_7_2 == (unsigned long )work) {
#line 562
    ldv_work_7_2 = 1;
  } else {

  }
#line 564
  if ((ldv_work_7_3 == 3 || ldv_work_7_3 == 2) && (unsigned long )ldv_work_struct_7_3 == (unsigned long )work) {
#line 566
    ldv_work_7_3 = 1;
  } else {

  }
#line 567
  return;
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void call_and_disable_work_7(struct work_struct *work ) 
{ 


  {
#line 574
  if ((ldv_work_7_0 == 2 || ldv_work_7_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_0) {
#line 576
    iwlagn_bt_traffic_change_work(work);
#line 577
    ldv_work_7_0 = 1;
#line 578
    return;
  } else {

  }
#line 580
  if ((ldv_work_7_1 == 2 || ldv_work_7_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_1) {
#line 582
    iwlagn_bt_traffic_change_work(work);
#line 583
    ldv_work_7_1 = 1;
#line 584
    return;
  } else {

  }
#line 586
  if ((ldv_work_7_2 == 2 || ldv_work_7_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_2) {
#line 588
    iwlagn_bt_traffic_change_work(work);
#line 589
    ldv_work_7_2 = 1;
#line 590
    return;
  } else {

  }
#line 592
  if ((ldv_work_7_3 == 2 || ldv_work_7_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_3) {
#line 594
    iwlagn_bt_traffic_change_work(work);
#line 595
    ldv_work_7_3 = 1;
#line 596
    return;
  } else {

  }
#line 598
  return;
}
}
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void call_and_disable_all_7(int state ) 
{ 


  {
#line 603
  if (ldv_work_7_0 == state) {
#line 604
    call_and_disable_work_7(ldv_work_struct_7_0);
  } else {

  }
#line 605
  if (ldv_work_7_1 == state) {
#line 606
    call_and_disable_work_7(ldv_work_struct_7_1);
  } else {

  }
#line 607
  if (ldv_work_7_2 == state) {
#line 608
    call_and_disable_work_7(ldv_work_struct_7_2);
  } else {

  }
#line 609
  if (ldv_work_7_3 == state) {
#line 610
    call_and_disable_work_7(ldv_work_struct_7_3);
  } else {

  }
#line 611
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void work_init_7(void) 
{ 


  {
#line 615
  ldv_work_7_0 = 0;
#line 616
  ldv_work_7_1 = 0;
#line 617
  ldv_work_7_2 = 0;
#line 618
  ldv_work_7_3 = 0;
#line 619
  return;
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void invoke_work_7(void) 
{ 
  int tmp ;

  {
#line 624
  tmp = __VERIFIER_nondet_int();
#line 624
  switch (tmp) {
  case 0: ;
#line 626
  if (ldv_work_7_0 == 2 || ldv_work_7_0 == 3) {
#line 627
    ldv_work_7_0 = 4;
#line 628
    iwlagn_bt_traffic_change_work(ldv_work_struct_7_0);
#line 629
    ldv_work_7_0 = 1;
  } else {

  }
#line 632
  goto ldv_55599;
  case 1: ;
#line 634
  if (ldv_work_7_1 == 2 || ldv_work_7_1 == 3) {
#line 635
    ldv_work_7_1 = 4;
#line 636
    iwlagn_bt_traffic_change_work(ldv_work_struct_7_0);
#line 637
    ldv_work_7_1 = 1;
  } else {

  }
#line 640
  goto ldv_55599;
  case 2: ;
#line 642
  if (ldv_work_7_2 == 2 || ldv_work_7_2 == 3) {
#line 643
    ldv_work_7_2 = 4;
#line 644
    iwlagn_bt_traffic_change_work(ldv_work_struct_7_0);
#line 645
    ldv_work_7_2 = 1;
  } else {

  }
#line 648
  goto ldv_55599;
  case 3: ;
#line 650
  if (ldv_work_7_3 == 2 || ldv_work_7_3 == 3) {
#line 651
    ldv_work_7_3 = 4;
#line 652
    iwlagn_bt_traffic_change_work(ldv_work_struct_7_0);
#line 653
    ldv_work_7_3 = 1;
  } else {

  }
#line 656
  goto ldv_55599;
  default: 
#line 657
  ldv_stop();
  }
  ldv_55599: ;
#line 659
  return;
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void activate_work_7(struct work_struct *work , int state ) 
{ 


  {
#line 664
  if (ldv_work_7_0 == 0) {
#line 665
    ldv_work_struct_7_0 = work;
#line 666
    ldv_work_7_0 = state;
#line 667
    return;
  } else {

  }
#line 670
  if (ldv_work_7_1 == 0) {
#line 671
    ldv_work_struct_7_1 = work;
#line 672
    ldv_work_7_1 = state;
#line 673
    return;
  } else {

  }
#line 676
  if (ldv_work_7_2 == 0) {
#line 677
    ldv_work_struct_7_2 = work;
#line 678
    ldv_work_7_2 = state;
#line 679
    return;
  } else {

  }
#line 682
  if (ldv_work_7_3 == 0) {
#line 683
    ldv_work_struct_7_3 = work;
#line 684
    ldv_work_7_3 = state;
#line 685
    return;
  } else {

  }
#line 687
  return;
}
}
#line 713 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
bool ldv_queue_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 717
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 717
  ldv_func_res = tmp;
#line 719
  activate_work_7(ldv_func_arg3, 2);
#line 721
  return (ldv_func_res);
}
}
#line 724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
bool ldv_queue_delayed_work_on_262(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 728
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 728
  ldv_func_res = tmp;
#line 730
  activate_work_7(& ldv_func_arg3->work, 2);
#line 732
  return (ldv_func_res);
}
}
#line 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
bool ldv_queue_work_on_263(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 739
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 739
  ldv_func_res = tmp;
#line 741
  activate_work_7(ldv_func_arg3, 2);
#line 743
  return (ldv_func_res);
}
}
#line 746 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_flush_workqueue_264(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 749
  flush_workqueue(ldv_func_arg1);
#line 751
  call_and_disable_all_7(2);
#line 752
  return;
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
bool ldv_queue_delayed_work_on_265(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 758
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 758
  ldv_func_res = tmp;
#line 760
  activate_work_7(& ldv_func_arg3->work, 2);
#line 762
  return (ldv_func_res);
}
}
#line 765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 768
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 770
  mutex_lock(ldv_func_arg1);
#line 771
  return;
}
}
#line 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 776
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 778
  mutex_unlock(ldv_func_arg1);
#line 779
  return;
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_lock_268(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 784
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 786
  mutex_lock(ldv_func_arg1);
#line 787
  return;
}
}
#line 789 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
int ldv_mutex_trylock_269(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 793
  tmp = mutex_trylock(ldv_func_arg1);
#line 793
  ldv_func_res = tmp;
#line 795
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 795
  return (tmp___0);
#line 797
  return (ldv_func_res);
}
}
#line 800 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 803
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 805
  mutex_unlock(ldv_func_arg1);
#line 806
  return;
}
}
#line 808 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_unlock_271(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 811
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 813
  mutex_unlock(ldv_func_arg1);
#line 814
  return;
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_lock_272(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 819
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 821
  mutex_lock(ldv_func_arg1);
#line 822
  return;
}
}
#line 824 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 827
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 829
  mutex_lock(ldv_func_arg1);
#line 830
  return;
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 835
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 837
  mutex_unlock(ldv_func_arg1);
#line 838
  return;
}
}
#line 840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_lock_275(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 843
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 845
  mutex_lock(ldv_func_arg1);
#line 846
  return;
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_unlock_276(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 851
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 853
  mutex_unlock(ldv_func_arg1);
#line 854
  return;
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
bool ldv_cancel_work_sync_277(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  bool tmp ;

  {
#line 860
  tmp = cancel_work_sync(ldv_func_arg1);
#line 860
  ldv_func_res = tmp;
#line 862
  disable_work_7(ldv_func_arg1);
#line 864
  return (ldv_func_res);
}
}
#line 867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_lock_278(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 870
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 872
  mutex_lock(ldv_func_arg1);
#line 873
  return;
}
}
#line 875 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_unlock_279(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 878
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 880
  mutex_unlock(ldv_func_arg1);
#line 881
  return;
}
}
#line 883 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_unlock_280(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 886
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 888
  mutex_unlock(ldv_func_arg1);
#line 889
  return;
}
}
#line 891 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/lib.o.c.prepared"
void ldv_mutex_lock_281(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 894
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 896
  mutex_lock(ldv_func_arg1);
#line 897
  return;
}
}
#line 48 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 113
extern void list_del(struct list_head * ) ;
#line 123 "include/linux/list.h"
__inline static void list_replace(struct list_head *old , struct list_head *new ) 
{ 


  {
#line 126
  new->next = old->next;
#line 127
  (new->next)->prev = new;
#line 128
  new->prev = old->prev;
#line 129
  (new->prev)->next = new;
#line 130
  return;
}
}
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_315(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_313(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_316(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_317(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_314(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_318(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_307(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_309(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_308(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_311(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_310(struct workqueue_struct *ldv_func_arg1 ) ;
#line 939 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
__inline static int iwl_is_any_associated(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
#line 942
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 942
  goto ldv_52301;
  ldv_52300: ;
#line 942
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 943
    tmp = iwl_is_associated_ctx(ctx);
#line 943
    if (tmp != 0) {
#line 944
      return (1);
    } else {

    }
  } else {

  }
#line 942
  ctx = ctx + 1;
  ldv_52301: ;
#line 942
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 944
    goto ldv_52300;
  } else {

  }

#line 945
  return (0);
}
}
#line 71 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/calib.h"
void iwl_init_sensitivity(struct iwl_priv *priv ) ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
int iwl_send_calib_results(struct iwl_priv *priv ) 
{ 
  struct iwl_host_cmd hcmd ;
  struct iwl_calib_result *res ;
  struct list_head  const  *__mptr ;
  int ret ;
  struct list_head  const  *__mptr___0 ;

  {
#line 95
  hcmd.data[0] = 0;
#line 95
  hcmd.data[1] = 0;
#line 95
  hcmd.resp_pkt = 0;
#line 95
  hcmd._rx_page_addr = 0UL;
#line 95
  hcmd._rx_page_order = 0U;
#line 95
  hcmd.handler_status = 0;
#line 95
  hcmd.flags = 0U;
#line 95
  hcmd.len[0] = (unsigned short)0;
#line 95
  hcmd.len[1] = (unsigned short)0;
#line 95
  hcmd.dataflags[0] = (unsigned char)0;
#line 95
  hcmd.dataflags[1] = (unsigned char)0;
#line 95
  hcmd.id = 176U;
#line 100
  __mptr = (struct list_head  const  *)priv->calib_results.next;
#line 100
  res = (struct iwl_calib_result *)__mptr;
#line 100
  goto ldv_52734;
  ldv_52733: 
#line 103
  hcmd.len[0] = (u16 )res->cmd_len;
#line 104
  hcmd.data[0] = (void const   *)(& res->hdr);
#line 105
  hcmd.dataflags[0] = 1U;
#line 106
  ret = iwl_dvm_send_cmd(priv, & hcmd);
#line 107
  if (ret != 0) {
#line 108
    __iwl_err(priv->dev, 0, 0, "Error %d on calib cmd %d\n", ret, (int )res->hdr.op_code);
#line 110
    return (ret);
  } else {

  }
#line 100
  __mptr___0 = (struct list_head  const  *)res->list.next;
#line 100
  res = (struct iwl_calib_result *)__mptr___0;
  ldv_52734: ;
#line 100
  if ((unsigned long )(& res->list) != (unsigned long )(& priv->calib_results)) {
#line 102
    goto ldv_52733;
  } else {

  }

#line 114
  return (0);
}
}
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
int iwl_calib_set(struct iwl_priv *priv , struct iwl_calib_hdr  const  *cmd , int len ) 
{ 
  struct iwl_calib_result *res ;
  struct iwl_calib_result *tmp ;
  void *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 122
  tmp___0 = kmalloc((unsigned long )len + 28UL, 32U);
#line 122
  res = (struct iwl_calib_result *)tmp___0;
#line 124
  if ((unsigned long )res == (unsigned long )((struct iwl_calib_result *)0)) {
#line 125
    return (-12);
  } else {

  }
#line 126
  memcpy((void *)(& res->hdr), (void const   *)cmd, (size_t )len);
#line 127
  res->cmd_len = (size_t )len;
#line 129
  __mptr = (struct list_head  const  *)priv->calib_results.next;
#line 129
  tmp = (struct iwl_calib_result *)__mptr;
#line 129
  goto ldv_52748;
  ldv_52747: ;
#line 130
  if ((int )tmp->hdr.op_code == (int )res->hdr.op_code) {
#line 131
    list_replace(& tmp->list, & res->list);
#line 132
    kfree((void const   *)tmp);
#line 133
    return (0);
  } else {

  }
#line 129
  __mptr___0 = (struct list_head  const  *)tmp->list.next;
#line 129
  tmp = (struct iwl_calib_result *)__mptr___0;
  ldv_52748: ;
#line 129
  if ((unsigned long )(& tmp->list) != (unsigned long )(& priv->calib_results)) {
#line 131
    goto ldv_52747;
  } else {

  }
#line 138
  list_add_tail(& res->list, & priv->calib_results);
#line 140
  return (0);
}
}
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
void iwl_calib_free_results(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_result *res ;
  struct iwl_calib_result *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 147
  __mptr = (struct list_head  const  *)priv->calib_results.next;
#line 147
  res = (struct iwl_calib_result *)__mptr;
#line 147
  __mptr___0 = (struct list_head  const  *)res->list.next;
#line 147
  tmp = (struct iwl_calib_result *)__mptr___0;
#line 147
  goto ldv_52762;
  ldv_52761: 
#line 148
  list_del(& res->list);
#line 149
  kfree((void const   *)res);
#line 147
  res = tmp;
#line 147
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 147
  tmp = (struct iwl_calib_result *)__mptr___1;
  ldv_52762: ;
#line 147
  if ((unsigned long )(& res->list) != (unsigned long )(& priv->calib_results)) {
#line 149
    goto ldv_52761;
  } else {

  }

#line 154
  return;
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
static int iwl_sens_energy_cck(struct iwl_priv *priv , u32 norm_fa , u32 rx_enable_time ,
                               struct statistics_general_data *rx_info ) 
{ 
  u32 max_nrg_cck ;
  int i ;
  u8 max_silence_rssi ;
  u32 silence_ref ;
  u8 silence_rssi_a ;
  u8 silence_rssi_b ;
  u8 silence_rssi_c ;
  u32 val ;
  u32 false_alarms ;
  u32 max_false_alarms ;
  u32 min_false_alarms ;
  struct iwl_sensitivity_data *data ;
  struct iwl_sensitivity_ranges  const  *ranges ;
  u8 _max1 ;
  u8 _max2 ;
  u8 _max1___0 ;
  unsigned char _max2___0 ;
  u32 _max1___1 ;
  u32 _max2___1 ;
  u32 _min1 ;
  u32 _min2 ;
  u32 _min1___0 ;
  u32 _min2___0 ;
  u32 _max1___2 ;
  u32 _max2___2 ;
  unsigned int _min1___1 ;
  u32 _min2___1 ;
  u32 _max1___3 ;
  u32 _max2___3 ;
  unsigned int _min1___2 ;
  u32 _min2___2 ;
  unsigned int _min1___3 ;
  u32 _min2___3 ;
  unsigned int _max1___4 ;
  u32 _max2___4 ;
  unsigned int _max1___5 ;
  u32 _max2___5 ;

  {
#line 170
  max_nrg_cck = 0U;
#line 171
  i = 0;
#line 172
  max_silence_rssi = 0U;
#line 173
  silence_ref = 0U;
#line 174
  silence_rssi_a = 0U;
#line 175
  silence_rssi_b = 0U;
#line 176
  silence_rssi_c = 0U;
#line 188
  false_alarms = norm_fa * 204800U;
#line 189
  max_false_alarms = rx_enable_time * 50U;
#line 190
  min_false_alarms = rx_enable_time * 5U;
#line 191
  data = (struct iwl_sensitivity_data *)0;
#line 192
  ranges = priv->hw_params.sens;
#line 194
  data = & priv->sensitivity_data;
#line 196
  data->nrg_auto_corr_silence_diff = 0;
#line 201
  silence_rssi_a = (unsigned char )((rx_info->beacon_silence_rssi_a & 65280U) >> 8);
#line 203
  silence_rssi_b = (unsigned char )((rx_info->beacon_silence_rssi_b & 65280U) >> 8);
#line 205
  silence_rssi_c = (unsigned char )((rx_info->beacon_silence_rssi_c & 65280U) >> 8);
#line 208
  _max1 = silence_rssi_b;
#line 208
  _max2 = silence_rssi_c;
#line 208
  val = (u32 )((int )_max1 > (int )_max2 ? _max1 : _max2);
#line 209
  _max1___0 = silence_rssi_a;
#line 209
  _max2___0 = (unsigned char )val;
#line 209
  max_silence_rssi = (u8 )((int )_max1___0 > (int )_max2___0 ? (int )_max1___0 : (int )_max2___0);
#line 212
  data->nrg_silence_rssi[data->nrg_silence_idx] = max_silence_rssi;
#line 213
  data->nrg_silence_idx = data->nrg_silence_idx + 1U;
#line 214
  if (data->nrg_silence_idx > 19U) {
#line 215
    data->nrg_silence_idx = 0U;
  } else {

  }
#line 218
  i = 0;
#line 218
  goto ldv_52793;
  ldv_52792: 
#line 219
  val = (u32 )data->nrg_silence_rssi[i];
#line 220
  _max1___1 = silence_ref;
#line 220
  _max2___1 = val;
#line 220
  silence_ref = _max1___1 > _max2___1 ? _max1___1 : _max2___1;
#line 218
  i = i + 1;
  ldv_52793: ;
#line 218
  if (i <= 19) {
#line 220
    goto ldv_52792;
  } else {

  }
#line 222
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "silence a %u, b %u, c %u, 20-bcn max %u\n",
            (int )silence_rssi_a, (int )silence_rssi_b, (int )silence_rssi_c, silence_ref);
#line 229
  i = (int )data->nrg_energy_idx;
#line 230
  _min1 = rx_info->beacon_energy_b;
#line 230
  _min2 = rx_info->beacon_energy_c;
#line 230
  val = _min1 < _min2 ? _min1 : _min2;
#line 231
  _min1___0 = rx_info->beacon_energy_a;
#line 231
  _min2___0 = val;
#line 231
  data->nrg_value[i] = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 233
  data->nrg_energy_idx = data->nrg_energy_idx + 1U;
#line 234
  if (data->nrg_energy_idx > 9U) {
#line 235
    data->nrg_energy_idx = 0U;
  } else {

  }
#line 241
  max_nrg_cck = data->nrg_value[0];
#line 242
  i = 1;
#line 242
  goto ldv_52806;
  ldv_52805: 
#line 243
  _max1___2 = max_nrg_cck;
#line 243
  _max2___2 = data->nrg_value[i];
#line 243
  max_nrg_cck = _max1___2 > _max2___2 ? _max1___2 : _max2___2;
#line 242
  i = i + 1;
  ldv_52806: ;
#line 242
  if (i <= 9) {
#line 244
    goto ldv_52805;
  } else {

  }
#line 244
  max_nrg_cck = max_nrg_cck + 6U;
#line 246
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "rx energy a %u, b %u, c %u, 10-bcn max/min %u\n",
            rx_info->beacon_energy_a, rx_info->beacon_energy_b, rx_info->beacon_energy_c,
            max_nrg_cck - 6U);
#line 252
  if (false_alarms < min_false_alarms) {
#line 253
    data->num_in_cck_no_fa = data->num_in_cck_no_fa + 1U;
  } else {
#line 255
    data->num_in_cck_no_fa = 0U;
  }
#line 256
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "consecutive bcns with few false alarms = %u\n",
            data->num_in_cck_no_fa);
#line 260
  if (false_alarms > max_false_alarms && data->auto_corr_cck > 160U) {
#line 262
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "norm FA %u > max FA %u\n",
              false_alarms, max_false_alarms);
#line 264
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "... reducing sensitivity\n");
#line 265
    data->nrg_curr_state = 0U;
#line 267
    data->nrg_silence_ref = silence_ref;
#line 271
    data->nrg_th_cck = data->nrg_th_cck - 2U;
  } else
#line 273
  if (false_alarms < min_false_alarms) {
#line 274
    data->nrg_curr_state = 1U;
#line 278
    data->nrg_auto_corr_silence_diff = (int )data->nrg_silence_ref - (int )silence_ref;
#line 281
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "norm FA %u < min FA %u, silence diff %d\n",
              false_alarms, min_false_alarms, data->nrg_auto_corr_silence_diff);
#line 291
    if (data->nrg_prev_state != 0U && (data->nrg_auto_corr_silence_diff > 2 || data->num_in_cck_no_fa > 100U)) {
#line 295
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "... increasing sensitivity\n");
#line 297
      val = data->nrg_th_cck + 2U;
#line 298
      _min1___1 = (unsigned int )ranges->min_nrg_cck;
#line 298
      _min2___1 = val;
#line 298
      data->nrg_th_cck = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
    } else {
#line 300
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "... but not changing sensitivity\n");
    }
  } else {
#line 305
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", " FA in safe zone\n");
#line 306
    data->nrg_curr_state = 2U;
#line 309
    data->nrg_silence_ref = silence_ref;
#line 314
    if (data->nrg_prev_state == 0U) {
#line 315
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "... increasing margin\n");
#line 316
      if (data->nrg_th_cck > max_nrg_cck + 8U) {
#line 317
        data->nrg_th_cck = data->nrg_th_cck - 8U;
      } else {
#line 319
        data->nrg_th_cck = max_nrg_cck;
      }
    } else {

    }
  }
#line 328
  _max1___3 = max_nrg_cck;
#line 328
  _max2___3 = data->nrg_th_cck;
#line 328
  data->nrg_th_cck = _max1___3 > _max2___3 ? _max1___3 : _max2___3;
#line 329
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "new nrg_th_cck %u\n",
            data->nrg_th_cck);
#line 331
  data->nrg_prev_state = data->nrg_curr_state;
#line 334
  if (false_alarms > min_false_alarms) {
#line 339
    if (data->auto_corr_cck <= 159U) {
#line 340
      data->auto_corr_cck = 161U;
    } else {
#line 342
      val = data->auto_corr_cck + 3U;
#line 344
      _min1___2 = (unsigned int )ranges->auto_corr_max_cck;
#line 344
      _min2___2 = val;
#line 344
      data->auto_corr_cck = _min1___2 < _min2___2 ? _min1___2 : _min2___2;
    }
#line 346
    val = data->auto_corr_cck_mrc + 3U;
#line 348
    _min1___3 = (unsigned int )ranges->auto_corr_max_cck_mrc;
#line 348
    _min2___3 = val;
#line 348
    data->auto_corr_cck_mrc = _min1___3 < _min2___3 ? _min1___3 : _min2___3;
  } else
#line 349
  if (false_alarms < min_false_alarms && (data->nrg_auto_corr_silence_diff > 2 || data->num_in_cck_no_fa > 100U)) {
#line 354
    val = data->auto_corr_cck - 3U;
#line 356
    _max1___4 = (unsigned int )ranges->auto_corr_min_cck;
#line 356
    _max2___4 = val;
#line 356
    data->auto_corr_cck = _max1___4 > _max2___4 ? _max1___4 : _max2___4;
#line 357
    val = data->auto_corr_cck_mrc - 3U;
#line 359
    _max1___5 = (unsigned int )ranges->auto_corr_min_cck_mrc;
#line 359
    _max2___5 = val;
#line 359
    data->auto_corr_cck_mrc = _max1___5 > _max2___5 ? _max1___5 : _max2___5;
  } else {

  }
#line 362
  return (0);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
static int iwl_sens_auto_corr_ofdm(struct iwl_priv *priv , u32 norm_fa , u32 rx_enable_time ) 
{ 
  u32 val ;
  u32 false_alarms ;
  u32 max_false_alarms ;
  u32 min_false_alarms ;
  struct iwl_sensitivity_data *data ;
  struct iwl_sensitivity_ranges  const  *ranges ;
  unsigned int _min1 ;
  u32 _min2 ;
  unsigned int _min1___0 ;
  u32 _min2___0 ;
  unsigned int _min1___1 ;
  u32 _min2___1 ;
  unsigned int _min1___2 ;
  u32 _min2___2 ;
  unsigned int _max1 ;
  u32 _max2 ;
  unsigned int _max1___0 ;
  u32 _max2___0 ;
  unsigned int _max1___1 ;
  u32 _max2___1 ;
  unsigned int _max1___2 ;
  u32 _max2___2 ;

  {
#line 371
  false_alarms = norm_fa * 204800U;
#line 372
  max_false_alarms = rx_enable_time * 50U;
#line 373
  min_false_alarms = rx_enable_time * 5U;
#line 374
  data = (struct iwl_sensitivity_data *)0;
#line 375
  ranges = priv->hw_params.sens;
#line 377
  data = & priv->sensitivity_data;
#line 380
  if (false_alarms > max_false_alarms) {
#line 382
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_auto_corr_ofdm", "norm FA %u > max FA %u)\n",
              false_alarms, max_false_alarms);
#line 385
    val = data->auto_corr_ofdm + 1U;
#line 387
    _min1 = (unsigned int )ranges->auto_corr_max_ofdm;
#line 387
    _min2 = val;
#line 387
    data->auto_corr_ofdm = _min1 < _min2 ? _min1 : _min2;
#line 389
    val = data->auto_corr_ofdm_mrc + 1U;
#line 391
    _min1___0 = (unsigned int )ranges->auto_corr_max_ofdm_mrc;
#line 391
    _min2___0 = val;
#line 391
    data->auto_corr_ofdm_mrc = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 393
    val = data->auto_corr_ofdm_x1 + 1U;
#line 395
    _min1___1 = (unsigned int )ranges->auto_corr_max_ofdm_x1;
#line 395
    _min2___1 = val;
#line 395
    data->auto_corr_ofdm_x1 = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
#line 397
    val = data->auto_corr_ofdm_mrc_x1 + 1U;
#line 399
    _min1___2 = (unsigned int )ranges->auto_corr_max_ofdm_mrc_x1;
#line 399
    _min2___2 = val;
#line 399
    data->auto_corr_ofdm_mrc_x1 = _min1___2 < _min2___2 ? _min1___2 : _min2___2;
  } else
#line 403
  if (false_alarms < min_false_alarms) {
#line 405
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_auto_corr_ofdm", "norm FA %u < min FA %u\n",
              false_alarms, min_false_alarms);
#line 408
    val = data->auto_corr_ofdm - 1U;
#line 410
    _max1 = (unsigned int )ranges->auto_corr_min_ofdm;
#line 410
    _max2 = val;
#line 410
    data->auto_corr_ofdm = _max1 > _max2 ? _max1 : _max2;
#line 412
    val = data->auto_corr_ofdm_mrc - 1U;
#line 414
    _max1___0 = (unsigned int )ranges->auto_corr_min_ofdm_mrc;
#line 414
    _max2___0 = val;
#line 414
    data->auto_corr_ofdm_mrc = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 416
    val = data->auto_corr_ofdm_x1 - 1U;
#line 418
    _max1___1 = (unsigned int )ranges->auto_corr_min_ofdm_x1;
#line 418
    _max2___1 = val;
#line 418
    data->auto_corr_ofdm_x1 = _max1___1 > _max2___1 ? _max1___1 : _max2___1;
#line 420
    val = data->auto_corr_ofdm_mrc_x1 - 1U;
#line 422
    _max1___2 = (unsigned int )ranges->auto_corr_min_ofdm_mrc_x1;
#line 422
    _max2___2 = val;
#line 422
    data->auto_corr_ofdm_mrc_x1 = _max1___2 > _max2___2 ? _max1___2 : _max2___2;
  } else {
#line 424
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_auto_corr_ofdm", "min FA %u < norm FA %u < max FA %u OK\n",
              min_false_alarms, false_alarms, max_false_alarms);
  }
#line 427
  return (0);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
static void iwl_prepare_legacy_sensitivity_tbl(struct iwl_priv *priv , struct iwl_sensitivity_data *data ,
                                               __le16 *tbl ) 
{ 


  {
#line 434
  *(tbl + 5UL) = (unsigned short )data->auto_corr_ofdm;
#line 436
  *(tbl + 6UL) = (unsigned short )data->auto_corr_ofdm_mrc;
#line 438
  *(tbl + 2UL) = (unsigned short )data->auto_corr_ofdm_x1;
#line 440
  *(tbl + 3UL) = (unsigned short )data->auto_corr_ofdm_mrc_x1;
#line 443
  *(tbl + 9UL) = (unsigned short )data->auto_corr_cck;
#line 445
  *(tbl + 4UL) = (unsigned short )data->auto_corr_cck_mrc;
#line 448
  *tbl = (unsigned short )data->nrg_th_cck;
#line 450
  *(tbl + 1UL) = (unsigned short )data->nrg_th_ofdm;
#line 453
  *(tbl + 7UL) = data->barker_corr_th_min;
#line 455
  *(tbl + 8UL) = data->barker_corr_th_min_mrc;
#line 457
  *(tbl + 10UL) = data->nrg_th_cca;
#line 460
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_prepare_legacy_sensitivity_tbl", "ofdm: ac %u mrc %u x1 %u mrc_x1 %u thresh %u\n",
            data->auto_corr_ofdm, data->auto_corr_ofdm_mrc, data->auto_corr_ofdm_x1,
            data->auto_corr_ofdm_mrc_x1, data->nrg_th_ofdm);
#line 465
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_prepare_legacy_sensitivity_tbl", "cck: ac %u mrc %u thresh %u\n",
            data->auto_corr_cck, data->auto_corr_cck_mrc, data->nrg_th_cck);
#line 466
  return;
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
static int iwl_sensitivity_write(struct iwl_priv *priv ) 
{ 
  struct iwl_sensitivity_cmd cmd ;
  struct iwl_sensitivity_data *data ;
  struct iwl_host_cmd cmd_out ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 474
  data = (struct iwl_sensitivity_data *)0;
#line 475
  cmd_out.data[0] = (void const   *)(& cmd);
#line 475
  tmp = 1U;
#line 475
  while (1) {
#line 475
    if (tmp >= 2U) {
#line 475
      break;
    } else {

    }
#line 475
    cmd_out.data[tmp] = 0;
#line 475
    tmp = tmp + 1U;
  }
#line 475
  cmd_out.resp_pkt = 0;
#line 475
  cmd_out._rx_page_addr = 0UL;
#line 475
  cmd_out._rx_page_order = 0U;
#line 475
  cmd_out.handler_status = 0;
#line 475
  cmd_out.flags = 1U;
#line 475
  cmd_out.len[0] = 24U;
#line 475
  tmp___0 = 1U;
#line 475
  while (1) {
#line 475
    if (tmp___0 >= 2U) {
#line 475
      break;
    } else {

    }
#line 475
    cmd_out.len[tmp___0] = (unsigned short)0;
#line 475
    tmp___0 = tmp___0 + 1U;
  }
#line 475
  cmd_out.dataflags[0] = (unsigned char)0;
#line 475
  cmd_out.dataflags[1] = (unsigned char)0;
#line 475
  cmd_out.id = 168U;
#line 482
  data = & priv->sensitivity_data;
#line 484
  memset((void *)(& cmd), 0, 24UL);
#line 486
  iwl_prepare_legacy_sensitivity_tbl(priv, data, (__le16 *)(& cmd.table));
#line 489
  cmd.control = 1U;
#line 492
  tmp___1 = memcmp((void const   *)(& cmd.table), (void const   *)(& priv->sensitivity_tbl),
                   22UL);
#line 492
  if (tmp___1 == 0) {
#line 494
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_write", "No change in SENSITIVITY_CMD\n");
#line 495
    return (0);
  } else {

  }
#line 499
  memcpy((void *)(& priv->sensitivity_tbl), (void const   *)(& cmd.table), 22UL);
#line 502
  tmp___2 = iwl_dvm_send_cmd(priv, & cmd_out);
#line 502
  return (tmp___2);
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
static int iwl_enhance_sensitivity_write(struct iwl_priv *priv ) 
{ 
  struct iwl_enhance_sensitivity_cmd cmd ;
  struct iwl_sensitivity_data *data ;
  struct iwl_host_cmd cmd_out ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 509
  data = (struct iwl_sensitivity_data *)0;
#line 510
  cmd_out.data[0] = (void const   *)(& cmd);
#line 510
  tmp = 1U;
#line 510
  while (1) {
#line 510
    if (tmp >= 2U) {
#line 510
      break;
    } else {

    }
#line 510
    cmd_out.data[tmp] = 0;
#line 510
    tmp = tmp + 1U;
  }
#line 510
  cmd_out.resp_pkt = 0;
#line 510
  cmd_out._rx_page_addr = 0UL;
#line 510
  cmd_out._rx_page_order = 0U;
#line 510
  cmd_out.handler_status = 0;
#line 510
  cmd_out.flags = 1U;
#line 510
  cmd_out.len[0] = 48U;
#line 510
  tmp___0 = 1U;
#line 510
  while (1) {
#line 510
    if (tmp___0 >= 2U) {
#line 510
      break;
    } else {

    }
#line 510
    cmd_out.len[tmp___0] = (unsigned short)0;
#line 510
    tmp___0 = tmp___0 + 1U;
  }
#line 510
  cmd_out.dataflags[0] = (unsigned char)0;
#line 510
  cmd_out.dataflags[1] = (unsigned char)0;
#line 510
  cmd_out.id = 168U;
#line 517
  data = & priv->sensitivity_data;
#line 519
  memset((void *)(& cmd), 0, 48UL);
#line 521
  iwl_prepare_legacy_sensitivity_tbl(priv, data, (__le16 *)(& cmd.enhance_table));
#line 523
  if ((int )(priv->lib)->hd_v2) {
#line 524
    cmd.enhance_table[11] = 1U;
#line 526
    cmd.enhance_table[12] = 1U;
#line 528
    cmd.enhance_table[13] = 1U;
#line 530
    cmd.enhance_table[14] = 600U;
#line 532
    cmd.enhance_table[15] = 40U;
#line 534
    cmd.enhance_table[16] = 486U;
#line 536
    cmd.enhance_table[17] = 45U;
#line 538
    cmd.enhance_table[18] = 853U;
#line 540
    cmd.enhance_table[19] = 60U;
#line 542
    cmd.enhance_table[20] = 476U;
#line 544
    cmd.enhance_table[21] = 99U;
  } else {
#line 547
    cmd.enhance_table[11] = 0U;
#line 549
    cmd.enhance_table[12] = 0U;
#line 551
    cmd.enhance_table[13] = 0U;
#line 553
    cmd.enhance_table[14] = 668U;
#line 555
    cmd.enhance_table[15] = 4U;
#line 557
    cmd.enhance_table[16] = 486U;
#line 559
    cmd.enhance_table[17] = 37U;
#line 561
    cmd.enhance_table[18] = 853U;
#line 563
    cmd.enhance_table[19] = 4U;
#line 565
    cmd.enhance_table[20] = 476U;
#line 567
    cmd.enhance_table[21] = 99U;
  }
#line 572
  cmd.control = 1U;
#line 575
  tmp___1 = memcmp((void const   *)(& cmd.enhance_table), (void const   *)(& priv->sensitivity_tbl),
                   22UL);
#line 575
  if (tmp___1 == 0) {
#line 575
    tmp___2 = memcmp((void const   *)(& cmd.enhance_table) + 11U, (void const   *)(& priv->enhance_sensitivity_tbl),
                     24UL);
#line 575
    if (tmp___2 == 0) {
#line 580
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_enhance_sensitivity_write", "No change in SENSITIVITY_CMD\n");
#line 581
      return (0);
    } else {

    }
  } else {

  }
#line 585
  memcpy((void *)(& priv->sensitivity_tbl), (void const   *)(& cmd.enhance_table),
           22UL);
#line 587
  memcpy((void *)(& priv->enhance_sensitivity_tbl), (void const   *)(& cmd.enhance_table) + 11U,
           24UL);
#line 591
  tmp___3 = iwl_dvm_send_cmd(priv, & cmd_out);
#line 591
  return (tmp___3);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
void iwl_init_sensitivity(struct iwl_priv *priv ) 
{ 
  int ret ;
  int i ;
  struct iwl_sensitivity_data *data ;
  struct iwl_sensitivity_ranges  const  *ranges ;
  int tmp ;
  int tmp___0 ;

  {
#line 596
  ret = 0;
#line 598
  data = (struct iwl_sensitivity_data *)0;
#line 599
  ranges = priv->hw_params.sens;
#line 601
  if ((int )priv->calib_disabled & 1) {
#line 602
    return;
  } else {

  }
#line 604
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_init_sensitivity", "Start iwl_init_sensitivity\n");
#line 607
  data = & priv->sensitivity_data;
#line 609
  if ((unsigned long )ranges == (unsigned long )((struct iwl_sensitivity_ranges  const  *)0)) {
#line 610
    return;
  } else {

  }
#line 612
  memset((void *)data, 0, 144UL);
#line 614
  data->num_in_cck_no_fa = 0U;
#line 615
  data->nrg_curr_state = 0U;
#line 616
  data->nrg_prev_state = 0U;
#line 617
  data->nrg_silence_ref = 0U;
#line 618
  data->nrg_silence_idx = 0U;
#line 619
  data->nrg_energy_idx = 0U;
#line 621
  i = 0;
#line 621
  goto ldv_52891;
  ldv_52890: 
#line 622
  data->nrg_value[i] = 0U;
#line 621
  i = i + 1;
  ldv_52891: ;
#line 621
  if (i <= 9) {
#line 623
    goto ldv_52890;
  } else {

  }
#line 624
  i = 0;
#line 624
  goto ldv_52894;
  ldv_52893: 
#line 625
  data->nrg_silence_rssi[i] = 0U;
#line 624
  i = i + 1;
  ldv_52894: ;
#line 624
  if (i <= 19) {
#line 626
    goto ldv_52893;
  } else {

  }
#line 627
  data->auto_corr_ofdm = (u32 )ranges->auto_corr_min_ofdm;
#line 628
  data->auto_corr_ofdm_mrc = (u32 )ranges->auto_corr_min_ofdm_mrc;
#line 629
  data->auto_corr_ofdm_x1 = (u32 )ranges->auto_corr_min_ofdm_x1;
#line 630
  data->auto_corr_ofdm_mrc_x1 = (u32 )ranges->auto_corr_min_ofdm_mrc_x1;
#line 631
  data->auto_corr_cck = 125U;
#line 632
  data->auto_corr_cck_mrc = (u32 )ranges->auto_corr_min_cck_mrc;
#line 633
  data->nrg_th_cck = (u32 )ranges->nrg_th_cck;
#line 634
  data->nrg_th_ofdm = (u32 )ranges->nrg_th_ofdm;
#line 635
  data->barker_corr_th_min = ranges->barker_corr_th_min;
#line 636
  data->barker_corr_th_min_mrc = ranges->barker_corr_th_min_mrc;
#line 637
  data->nrg_th_cca = ranges->nrg_th_cca;
#line 639
  data->last_bad_plcp_cnt_ofdm = 0U;
#line 640
  data->last_fa_cnt_ofdm = 0U;
#line 641
  data->last_bad_plcp_cnt_cck = 0U;
#line 642
  data->last_fa_cnt_cck = 0U;
#line 644
  if ((int )(priv->fw)->enhance_sensitivity_table) {
#line 645
    tmp = iwl_enhance_sensitivity_write(priv);
#line 645
    ret = tmp | ret;
  } else {
#line 647
    tmp___0 = iwl_sensitivity_write(priv);
#line 647
    ret = tmp___0 | ret;
  }
#line 648
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_init_sensitivity", "<<return 0x%X\n", ret);
#line 649
  return;
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
void iwl_sensitivity_calibration(struct iwl_priv *priv ) 
{ 
  u32 rx_enable_time ;
  u32 fa_cck ;
  u32 fa_ofdm ;
  u32 bad_plcp_cck ;
  u32 bad_plcp_ofdm ;
  u32 norm_fa_ofdm ;
  u32 norm_fa_cck ;
  struct iwl_sensitivity_data *data ;
  struct statistics_rx_non_phy *rx_info ;
  struct statistics_rx_phy *ofdm ;
  struct statistics_rx_phy *cck ;
  struct statistics_general_data statis ;
  int tmp ;

  {
#line 660
  data = (struct iwl_sensitivity_data *)0;
#line 665
  if ((int )priv->calib_disabled & 1) {
#line 666
    return;
  } else {

  }
#line 668
  data = & priv->sensitivity_data;
#line 670
  tmp = iwl_is_any_associated(priv);
#line 670
  if (tmp == 0) {
#line 671
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "<< - not associated\n");
#line 672
    return;
  } else {

  }
#line 675
  spin_lock_bh(& priv->statistics.lock);
#line 676
  rx_info = & priv->statistics.rx_non_phy;
#line 677
  ofdm = & priv->statistics.rx_ofdm;
#line 678
  cck = & priv->statistics.rx_cck;
#line 679
  if (rx_info->interference_data_flag != 1U) {
#line 680
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "<< invalid data.\n");
#line 681
    spin_unlock_bh(& priv->statistics.lock);
#line 682
    return;
  } else {

  }
#line 686
  rx_enable_time = rx_info->channel_load;
#line 687
  fa_cck = cck->false_alarm_cnt;
#line 688
  fa_ofdm = ofdm->false_alarm_cnt;
#line 689
  bad_plcp_cck = cck->plcp_err;
#line 690
  bad_plcp_ofdm = ofdm->plcp_err;
#line 692
  statis.beacon_silence_rssi_a = rx_info->beacon_silence_rssi_a;
#line 694
  statis.beacon_silence_rssi_b = rx_info->beacon_silence_rssi_b;
#line 696
  statis.beacon_silence_rssi_c = rx_info->beacon_silence_rssi_c;
#line 698
  statis.beacon_energy_a = rx_info->beacon_energy_a;
#line 700
  statis.beacon_energy_b = rx_info->beacon_energy_b;
#line 702
  statis.beacon_energy_c = rx_info->beacon_energy_c;
#line 705
  spin_unlock_bh(& priv->statistics.lock);
#line 707
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "rx_enable_time = %u usecs\n",
            rx_enable_time);
#line 709
  if (rx_enable_time == 0U) {
#line 710
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "<< RX Enable Time == 0!\n");
#line 711
    return;
  } else {

  }
#line 717
  if (data->last_bad_plcp_cnt_cck > bad_plcp_cck) {
#line 718
    data->last_bad_plcp_cnt_cck = bad_plcp_cck;
  } else {
#line 720
    bad_plcp_cck = bad_plcp_cck - data->last_bad_plcp_cnt_cck;
#line 721
    data->last_bad_plcp_cnt_cck = data->last_bad_plcp_cnt_cck + bad_plcp_cck;
  }
#line 724
  if (data->last_bad_plcp_cnt_ofdm > bad_plcp_ofdm) {
#line 725
    data->last_bad_plcp_cnt_ofdm = bad_plcp_ofdm;
  } else {
#line 727
    bad_plcp_ofdm = bad_plcp_ofdm - data->last_bad_plcp_cnt_ofdm;
#line 728
    data->last_bad_plcp_cnt_ofdm = data->last_bad_plcp_cnt_ofdm + bad_plcp_ofdm;
  }
#line 731
  if (data->last_fa_cnt_ofdm > fa_ofdm) {
#line 732
    data->last_fa_cnt_ofdm = fa_ofdm;
  } else {
#line 734
    fa_ofdm = fa_ofdm - data->last_fa_cnt_ofdm;
#line 735
    data->last_fa_cnt_ofdm = data->last_fa_cnt_ofdm + fa_ofdm;
  }
#line 738
  if (data->last_fa_cnt_cck > fa_cck) {
#line 739
    data->last_fa_cnt_cck = fa_cck;
  } else {
#line 741
    fa_cck = fa_cck - data->last_fa_cnt_cck;
#line 742
    data->last_fa_cnt_cck = data->last_fa_cnt_cck + fa_cck;
  }
#line 746
  norm_fa_ofdm = fa_ofdm + bad_plcp_ofdm;
#line 747
  norm_fa_cck = fa_cck + bad_plcp_cck;
#line 749
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "cck: fa %u badp %u  ofdm: fa %u badp %u\n",
            fa_cck, bad_plcp_cck, fa_ofdm, bad_plcp_ofdm);
#line 752
  iwl_sens_auto_corr_ofdm(priv, norm_fa_ofdm, rx_enable_time);
#line 753
  iwl_sens_energy_cck(priv, norm_fa_cck, rx_enable_time, & statis);
#line 754
  if ((int )(priv->fw)->enhance_sensitivity_table) {
#line 755
    iwl_enhance_sensitivity_write(priv);
  } else {
#line 757
    iwl_sensitivity_write(priv);
  }
#line 758
  return;
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
__inline static u8 find_first_chain(u8 mask ) 
{ 


  {
#line 762
  if ((int )mask & 1) {
#line 763
    return (0U);
  } else {

  }
#line 764
  if (((unsigned long )mask & 2UL) != 0UL) {
#line 765
    return (1U);
  } else {

  }
#line 766
  return (2U);
}
}
#line 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
static void iwl_find_disconn_antenna(struct iwl_priv *priv , u32 *average_sig , struct iwl_chain_noise_data *data ) 
{ 
  u32 active_chains ;
  u32 max_average_sig ;
  u16 max_average_sig_antenna_i ;
  u8 num_tx_chains ;
  u8 first_chain ;
  u16 i ;
  s32 rssi_delta ;
  u8 ant_msk ;

  {
#line 776
  active_chains = 0U;
#line 781
  i = 0U;
#line 783
  *average_sig = data->chain_signal_a / 16U;
#line 784
  *(average_sig + 1UL) = data->chain_signal_b / 16U;
#line 785
  *(average_sig + 2UL) = data->chain_signal_c / 16U;
#line 787
  if (*average_sig >= *(average_sig + 1UL)) {
#line 788
    max_average_sig = *average_sig;
#line 789
    max_average_sig_antenna_i = 0U;
#line 790
    active_chains = (u32 )(1 << (int )max_average_sig_antenna_i);
  } else {
#line 792
    max_average_sig = *(average_sig + 1UL);
#line 793
    max_average_sig_antenna_i = 1U;
#line 794
    active_chains = (u32 )(1 << (int )max_average_sig_antenna_i);
  }
#line 797
  if (*(average_sig + 2UL) >= max_average_sig) {
#line 798
    max_average_sig = *(average_sig + 2UL);
#line 799
    max_average_sig_antenna_i = 2U;
#line 800
    active_chains = (u32 )(1 << (int )max_average_sig_antenna_i);
  } else {

  }
#line 803
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "average_sig: a %d b %d c %d\n",
            *average_sig, *(average_sig + 1UL), *(average_sig + 2UL));
#line 805
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "max_average_sig = %d, antenna %d\n",
            max_average_sig, (int )max_average_sig_antenna_i);
#line 809
  i = 0U;
#line 809
  goto ldv_52929;
  ldv_52928: ;
#line 810
  if ((int )i != (int )max_average_sig_antenna_i) {
#line 811
    rssi_delta = (s32 )(max_average_sig - *(average_sig + (unsigned long )i));
#line 815
    if (rssi_delta > 15) {
#line 816
      data->disconn_array[(int )i] = 1U;
    } else {
#line 818
      active_chains = (u32 )(1 << (int )i) | active_chains;
    }
#line 819
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "i = %d  rssiDelta = %d  disconn_array[i] = %d\n",
              (int )i, rssi_delta, (int )data->disconn_array[(int )i]);
  } else {

  }
#line 809
  i = (u16 )((int )i + 1);
  ldv_52929: ;
#line 809
  if ((unsigned int )i <= 2U) {
#line 811
    goto ldv_52928;
  } else {

  }
#line 835
  active_chains = (u32 )(priv->nvm_data)->valid_rx_ant & active_chains;
#line 837
  num_tx_chains = 0U;
#line 838
  i = 0U;
#line 838
  goto ldv_52935;
  ldv_52934: 
#line 841
  ant_msk = (u8 )(1 << (int )i);
#line 842
  if ((unsigned int )((int )(priv->nvm_data)->valid_tx_ant & (int )ant_msk) == 0U) {
#line 843
    goto ldv_52932;
  } else {

  }
#line 845
  num_tx_chains = (u8 )((int )num_tx_chains + 1);
#line 846
  if ((unsigned int )data->disconn_array[(int )i] == 0U) {
#line 848
    goto ldv_52933;
  } else {

  }
#line 849
  if ((int )priv->hw_params.tx_chains_num == (int )num_tx_chains && (unsigned int )data->disconn_array[(int )i] != 0U) {
#line 855
    first_chain = find_first_chain((int )(priv->nvm_data)->valid_tx_ant);
#line 857
    data->disconn_array[(int )first_chain] = 0U;
#line 858
    active_chains = (u32 )(1UL << (int )first_chain) | active_chains;
#line 859
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "All Tx chains are disconnected W/A - declare %d as connected\n",
              (int )first_chain);
#line 862
    goto ldv_52933;
  } else {

  }
  ldv_52932: 
#line 838
  i = (u16 )((int )i + 1);
  ldv_52935: ;
#line 838
  if ((unsigned int )i <= 2U) {
#line 840
    goto ldv_52934;
  } else {

  }
  ldv_52933: ;
#line 866
  if ((u32 )(priv->nvm_data)->valid_rx_ant != active_chains && priv->chain_noise_data.active_chains != active_chains) {
#line 868
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "Detected that not all antennas are connected! Connected: %#x, valid: %#x.\n",
              active_chains, (int )(priv->nvm_data)->valid_rx_ant);
  } else {

  }
#line 875
  data->active_chains = active_chains;
#line 876
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "active_chains (bitwise) = 0x%x\n",
            active_chains);
#line 877
  return;
}
}
#line 880 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
static void iwlagn_gain_computation(struct iwl_priv *priv , u32 *average_noise , u8 default_chain ) 
{ 
  int i ;
  s32 delta_g ;
  struct iwl_chain_noise_data *data ;
  long _min1 ;
  long ret ;
  int __x___0 ;
  long _min2 ;
  struct iwl_calib_chain_noise_gain_cmd cmd ;

  {
#line 886
  data = & priv->chain_noise_data;
#line 891
  i = (int )default_chain + 1;
#line 891
  goto ldv_52957;
  ldv_52956: ;
#line 892
  if ((unsigned int )data->disconn_array[i] != 0U) {
#line 893
    data->delta_gain_code[i] = 0U;
#line 894
    goto ldv_52944;
  } else {

  }
#line 897
  delta_g = ((int )(priv->lib)->chain_noise_scale * ((int )*(average_noise + (unsigned long )default_chain) - (int )*(average_noise + (unsigned long )i))) / 1500;
#line 903
  __x___0 = delta_g;
#line 903
  ret = (long )(__x___0 < 0 ? - __x___0 : __x___0);
#line 903
  _min1 = ret;
#line 903
  _min2 = 3L;
#line 903
  data->delta_gain_code[i] = (u8 )(_min1 < _min2 ? _min1 : _min2);
#line 906
  if (delta_g < 0) {
#line 915
    data->delta_gain_code[i] = (u8 )((unsigned int )data->delta_gain_code[i] | 4U);
  } else {

  }
  ldv_52944: 
#line 891
  i = i + 1;
  ldv_52957: ;
#line 891
  if (i <= 2) {
#line 893
    goto ldv_52956;
  } else {

  }
#line 918
  __iwl_dbg(priv->dev, 2097152U, 0, "iwlagn_gain_computation", "Delta gains: ANT_B = %d  ANT_C = %d\n",
            (int )data->delta_gain_code[1], (int )data->delta_gain_code[2]);
#line 921
  if ((unsigned int )data->radio_write == 0U) {
#line 924
    memset((void *)(& cmd), 0, 8UL);
#line 926
    iwl_set_calib_hdr(& cmd.hdr, (int )priv->phy_calib_chain_noise_gain_cmd);
#line 928
    cmd.delta_gain_1 = data->delta_gain_code[1];
#line 929
    cmd.delta_gain_2 = data->delta_gain_code[2];
#line 930
    iwl_dvm_send_cmd_pdu(priv, 176, 1U, 8, (void const   *)(& cmd));
#line 933
    data->radio_write = 1U;
#line 934
    data->state = 2U;
  } else {

  }
#line 936
  return;
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
void iwl_chain_noise_calibration(struct iwl_priv *priv ) 
{ 
  struct iwl_chain_noise_data *data ;
  u32 chain_noise_a ;
  u32 chain_noise_b ;
  u32 chain_noise_c ;
  u32 chain_sig_a ;
  u32 chain_sig_b ;
  u32 chain_sig_c ;
  u32 average_sig[3U] ;
  unsigned int tmp ;
  u32 average_noise[3U] ;
  unsigned int tmp___0 ;
  u32 min_average_noise ;
  u16 min_average_noise_antenna_i ;
  u16 i ;
  u16 rxon_chnum ;
  u16 stat_chnum ;
  u8 rxon_band24 ;
  u8 stat_band24 ;
  struct statistics_rx_non_phy *rx_info ;
  struct iwl_rxon_context *ctx ;
  u8 tmp___1 ;

  {
#line 946
  data = (struct iwl_chain_noise_data *)0;
#line 954
  average_sig[0] = 65535U;
#line 954
  tmp = 1U;
#line 954
  while (1) {
#line 954
    if (tmp >= 3U) {
#line 954
      break;
    } else {

    }
#line 954
    average_sig[tmp] = 0U;
#line 954
    tmp = tmp + 1U;
  }
#line 955
  average_noise[0] = 65535U;
#line 955
  tmp___0 = 1U;
#line 955
  while (1) {
#line 955
    if (tmp___0 >= 3U) {
#line 955
      break;
    } else {

    }
#line 955
    average_noise[tmp___0] = 0U;
#line 955
    tmp___0 = tmp___0 + 1U;
  }
#line 956
  min_average_noise = 4294967295U;
#line 957
  min_average_noise_antenna_i = 65535U;
#line 958
  i = 0U;
#line 959
  rxon_chnum = 65535U;
#line 960
  stat_chnum = 65535U;
#line 970
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 972
  if ((priv->calib_disabled & 2U) != 0U) {
#line 973
    return;
  } else {

  }
#line 975
  data = & priv->chain_noise_data;
#line 981
  if ((unsigned int )data->state != 1U) {
#line 982
    if ((unsigned int )data->state == 0U) {
#line 983
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "Wait for noise calib reset\n");
    } else {

    }
#line 984
    return;
  } else {

  }
#line 987
  spin_lock_bh(& priv->statistics.lock);
#line 989
  rx_info = & priv->statistics.rx_non_phy;
#line 991
  if (rx_info->interference_data_flag != 1U) {
#line 992
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", " << Interference data unavailable\n");
#line 993
    spin_unlock_bh(& priv->statistics.lock);
#line 994
    return;
  } else {

  }
#line 997
  rxon_band24 = (unsigned int )((u8 )ctx->staging.flags) & 1U;
#line 998
  rxon_chnum = ctx->staging.channel;
#line 999
  stat_band24 = (priv->statistics.flag & 2U) != 0U;
#line 1001
  stat_chnum = (u16 )(priv->statistics.flag >> 16);
#line 1005
  if ((int )rxon_chnum != (int )stat_chnum || (int )rxon_band24 != (int )stat_band24) {
#line 1006
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "Stats not from chan=%d, band24=%d\n",
              (int )rxon_chnum, (int )rxon_band24);
#line 1008
    spin_unlock_bh(& priv->statistics.lock);
#line 1009
    return;
  } else {

  }
#line 1016
  chain_noise_a = rx_info->beacon_silence_rssi_a & 255U;
#line 1018
  chain_noise_b = rx_info->beacon_silence_rssi_b & 255U;
#line 1020
  chain_noise_c = rx_info->beacon_silence_rssi_c & 255U;
#line 1023
  chain_sig_a = rx_info->beacon_rssi_a & 255U;
#line 1024
  chain_sig_b = rx_info->beacon_rssi_b & 255U;
#line 1025
  chain_sig_c = rx_info->beacon_rssi_c & 255U;
#line 1027
  spin_unlock_bh(& priv->statistics.lock);
#line 1029
  data->beacon_count = (u16 )((int )data->beacon_count + 1);
#line 1031
  data->chain_noise_a = data->chain_noise_a + chain_noise_a;
#line 1032
  data->chain_noise_b = data->chain_noise_b + chain_noise_b;
#line 1033
  data->chain_noise_c = data->chain_noise_c + chain_noise_c;
#line 1035
  data->chain_signal_a = data->chain_signal_a + chain_sig_a;
#line 1036
  data->chain_signal_b = data->chain_signal_b + chain_sig_b;
#line 1037
  data->chain_signal_c = data->chain_signal_c + chain_sig_c;
#line 1039
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "chan=%d, band24=%d, beacon=%d\n",
            (int )rxon_chnum, (int )rxon_band24, (int )data->beacon_count);
#line 1041
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "chain_sig: a %d b %d c %d\n",
            chain_sig_a, chain_sig_b, chain_sig_c);
#line 1043
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "chain_noise: a %d b %d c %d\n",
            chain_noise_a, chain_noise_b, chain_noise_c);
#line 1049
  if ((unsigned int )data->beacon_count != 16U) {
#line 1050
    return;
  } else {

  }
#line 1053
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 1057
    data->active_chains = (u32 )(priv->nvm_data)->valid_rx_ant;
#line 1058
    i = 0U;
#line 1058
    goto ldv_52984;
    ldv_52983: ;
#line 1059
    if ((data->active_chains & (u32 )(1 << (int )i)) == 0U) {
#line 1060
      data->disconn_array[(int )i] = 1U;
    } else {

    }
#line 1058
    i = (u16 )((int )i + 1);
    ldv_52984: ;
#line 1058
    if ((unsigned int )i <= 2U) {
#line 1060
      goto ldv_52983;
    } else {

    }

  } else {
#line 1062
    iwl_find_disconn_antenna(priv, (u32 *)(& average_sig), data);
  }
#line 1065
  average_noise[0] = data->chain_noise_a / 16U;
#line 1066
  average_noise[1] = data->chain_noise_b / 16U;
#line 1067
  average_noise[2] = data->chain_noise_c / 16U;
#line 1069
  i = 0U;
#line 1069
  goto ldv_52987;
  ldv_52986: ;
#line 1070
  if ((unsigned int )data->disconn_array[(int )i] == 0U && average_noise[(int )i] <= min_average_noise) {
#line 1074
    min_average_noise = average_noise[(int )i];
#line 1075
    min_average_noise_antenna_i = i;
  } else {

  }
#line 1069
  i = (u16 )((int )i + 1);
  ldv_52987: ;
#line 1069
  if ((unsigned int )i <= 2U) {
#line 1071
    goto ldv_52986;
  } else {

  }
#line 1079
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "average_noise: a %d b %d c %d\n",
            average_noise[0], average_noise[1], average_noise[2]);
#line 1083
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "min_average_noise = %d, antenna %d\n",
            min_average_noise, (int )min_average_noise_antenna_i);
#line 1086
  tmp___1 = find_first_chain((int )(priv->nvm_data)->valid_rx_ant);
#line 1086
  iwlagn_gain_computation(priv, (u32 *)(& average_noise), (int )tmp___1);
#line 1093
  iwl_update_chain_flags(priv);
#line 1095
  data->state = 3U;
#line 1096
  iwl_power_update_mode(priv, 0);
#line 1097
  return;
}
}
#line 1099 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.c"
void iwl_reset_run_time_calib(struct iwl_priv *priv ) 
{ 
  int i ;

  {
#line 1102
  memset((void *)(& priv->sensitivity_data), 0, 144UL);
#line 1104
  memset((void *)(& priv->chain_noise_data), 0, 40UL);
#line 1106
  i = 0;
#line 1106
  goto ldv_52994;
  ldv_52993: 
#line 1107
  priv->chain_noise_data.delta_gain_code[i] = 4U;
#line 1106
  i = i + 1;
  ldv_52994: ;
#line 1106
  if (i <= 2) {
#line 1108
    goto ldv_52993;
  } else {

  }
#line 1112
  iwl_send_statistics_request(priv, 1, 1);
#line 1113
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
bool ldv_queue_work_on_307(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 577
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_work_7(ldv_func_arg3, 2);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
bool ldv_queue_delayed_work_on_308(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_work_7(& ldv_func_arg3->work, 2);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
bool ldv_queue_work_on_309(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_7(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
void ldv_flush_workqueue_310(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 609
  flush_workqueue(ldv_func_arg1);
#line 611
  call_and_disable_all_7(2);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
bool ldv_queue_delayed_work_on_311(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 618
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 618
  ldv_func_res = tmp;
#line 620
  activate_work_7(& ldv_func_arg3->work, 2);
#line 622
  return (ldv_func_res);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
void ldv_mutex_unlock_313(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 638
  mutex_unlock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
void ldv_mutex_lock_314(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 646
  mutex_lock(ldv_func_arg1);
#line 647
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
int ldv_mutex_trylock_315(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
void ldv_mutex_unlock_316(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 665
  mutex_unlock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
void ldv_mutex_unlock_317(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 673
  mutex_unlock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/calib.o.c.prepared"
void ldv_mutex_lock_318(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 681
  mutex_lock(ldv_func_arg1);
#line 682
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags___1(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4801: ;
#line 831
    goto ldv_4801;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_343(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_341(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_344(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_345(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_352(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_355(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_lock_340(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_342(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_346(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_351(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_354(struct mutex *ldv_func_arg1 ) ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count___1(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6516;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6516;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6516;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6516;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6516: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add___2(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6573;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6573;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6573;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6573;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6573: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub___2(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6585;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6585;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6585;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6585;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6585: ;
#line 79
  return;
}
}
#line 173 "include/linux/timer.h"
int ldv_mod_timer_347(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_348(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 181
int ldv_mod_timer_349(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 232
int ldv_del_timer_sync_350(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_353(struct timer_list *ldv_func_arg1 ) ;
#line 240
int ldv_del_timer_sync_356(struct timer_list *ldv_func_arg1 ) ;
#line 244
int ldv_del_timer_sync_357(struct timer_list *ldv_func_arg1 ) ;
#line 248
int ldv_del_timer_sync_358(struct timer_list *ldv_func_arg1 ) ;
#line 498 "include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held___1(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 500
  lockdep_opinion = 0;
#line 502
  tmp = debug_lockdep_rcu_enabled();
#line 502
  if (tmp == 0) {
#line 503
    return (1);
  } else {

  }
#line 504
  tmp___0 = rcu_is_watching();
#line 504
  if (tmp___0) {
#line 504
    tmp___1 = 0;
  } else {
#line 504
    tmp___1 = 1;
  }
#line 504
  if (tmp___1) {
#line 505
    return (0);
  } else {

  }
#line 506
  tmp___2 = rcu_lockdep_current_cpu_online();
#line 506
  if (tmp___2) {
#line 506
    tmp___3 = 0;
  } else {
#line 506
    tmp___3 = 1;
  }
#line 506
  if (tmp___3) {
#line 507
    return (0);
  } else {

  }
#line 508
  if (debug_locks != 0) {
#line 509
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
#line 510
  if (lockdep_opinion != 0) {
#line 510
    tmp___6 = 1;
  } else {
#line 510
    tmp___4 = preempt_count___1();
#line 510
    if (tmp___4 != 0) {
#line 510
      tmp___6 = 1;
    } else {
#line 510
      _flags = arch_local_save_flags___1();
#line 510
      tmp___5 = arch_irqs_disabled_flags(_flags);
#line 510
      if (tmp___5 != 0) {
#line 510
        tmp___6 = 1;
      } else {
#line 510
        tmp___6 = 0;
      }
    }
  }
#line 510
  return (tmp___6);
}
}
#line 969 "include/linux/rcupdate.h"
__inline static void rcu_read_lock_sched_notrace___1(void) 
{ 


  {
#line 971
  __preempt_count_add___2(1);
#line 971
  __asm__  volatile   ("": : : "memory");
#line 973
  return;
}
}
#line 990 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock_sched_notrace___1(void) 
{ 


  {
#line 993
  __asm__  volatile   ("": : : "memory");
#line 993
  __preempt_count_sub___2(1);
#line 994
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_335(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_337(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_336(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_339(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_338(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
bool ldv_cancel_work_sync_359(struct work_struct *ldv_func_arg1 ) ;
#line 471
bool ldv_cancel_work_sync_360(struct work_struct *ldv_func_arg1 ) ;
#line 475
bool ldv_cancel_work_sync_361(struct work_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___4(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_335(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 525 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 527
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 528
    return ((void *)0);
  } else {

  }
#line 529
  tmp = __kmalloc(n * size, flags);
#line 529
  return (tmp);
}
}
#line 538 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 540
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 540
  return (tmp);
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void activate_suitable_timer_18(struct timer_list *timer , unsigned long data ) ;
#line 393
void call_and_disable_work_10(struct work_struct *work ) ;
#line 396
void invoke_work_8(void) ;
#line 400
void disable_suitable_timer_17(struct timer_list *timer ) ;
#line 417
void invoke_work_10(void) ;
#line 419
void ldv_timer_17(int state , struct timer_list *timer ) ;
#line 422
void choose_timer_18(void) ;
#line 437
void call_and_disable_all_9(int state ) ;
#line 445
void call_and_disable_work_8(struct work_struct *work ) ;
#line 452
void invoke_work_9(void) ;
#line 459
void disable_work_8(struct work_struct *work ) ;
#line 460
void activate_work_9(struct work_struct *work , int state ) ;
#line 466
void ldv_timer_18(int state , struct timer_list *timer ) ;
#line 478
void choose_timer_17(void) ;
#line 496
void call_and_disable_all_8(int state ) ;
#line 498
void call_and_disable_work_9(struct work_struct *work ) ;
#line 507
void activate_work_8(struct work_struct *work , int state ) ;
#line 512
void activate_suitable_timer_17(struct timer_list *timer , unsigned long data ) ;
#line 517
void disable_work_9(struct work_struct *work ) ;
#line 522
void disable_work_10(struct work_struct *work ) ;
#line 523
int reg_timer_17(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 530
void activate_work_10(struct work_struct *work , int state ) ;
#line 535
void activate_pending_timer_17(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 540
void call_and_disable_all_10(int state ) ;
#line 50 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32___0(struct device  const  *dev , u32 offs ,
                                                    u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_386 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_388 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 35
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ioread32.key);
#line 35
  if ((int )tmp___1) {
#line 35
    rcu_read_lock_sched_notrace___1();
#line 35
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                     (void *)(& __u.__c), 8);
#line 35
    _________p1 = __u.__val;
#line 35
    ________p1 = _________p1;
#line 35
    tmp = debug_lockdep_rcu_enabled();
#line 35
    if (tmp != 0 && ! __warned) {
#line 35
      tmp___0 = rcu_read_lock_sched_held___1();
#line 35
      if (tmp___0 == 0) {
#line 35
        __warned = 1;
#line 35
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               50, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 35
    it_func_ptr = ________p1;
#line 35
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51270: 
#line 35
      it_func = it_func_ptr->func;
#line 35
      __data = it_func_ptr->data;
#line 35
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 35
      it_func_ptr = it_func_ptr + 1;
#line 35
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 37
        goto ldv_51270;
      } else {

      }

    } else {

    }
#line 35
    rcu_read_unlock_sched_notrace___1();
  } else {

  }
#line 35
  rcu_read_lock_sched_notrace___1();
#line 35
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 35
  _________p1___0 = __u___0.__val;
#line 35
  ________p1___0 = _________p1___0;
#line 35
  tmp___2 = debug_lockdep_rcu_enabled();
#line 35
  if (tmp___2 != 0 && ! __warned___0) {
#line 35
    tmp___3 = rcu_read_lock_sched_held___1();
#line 35
    if (tmp___3 == 0) {
#line 35
      __warned___0 = 1;
#line 35
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             50, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 35
  rcu_read_unlock_sched_notrace___1();
#line 37
  return;
}
}
#line 84 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32___1(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_394 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_396 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 69
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite32.key);
#line 69
  if ((int )tmp___1) {
#line 69
    rcu_read_lock_sched_notrace___1();
#line 69
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
#line 69
    _________p1 = __u.__val;
#line 69
    ________p1 = _________p1;
#line 69
    tmp = debug_lockdep_rcu_enabled();
#line 69
    if (tmp != 0 && ! __warned) {
#line 69
      tmp___0 = rcu_read_lock_sched_held___1();
#line 69
      if (tmp___0 == 0) {
#line 69
        __warned = 1;
#line 69
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 69
    it_func_ptr = ________p1;
#line 69
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51392: 
#line 69
      it_func = it_func_ptr->func;
#line 69
      __data = it_func_ptr->data;
#line 69
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 69
      it_func_ptr = it_func_ptr + 1;
#line 69
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 71
        goto ldv_51392;
      } else {

      }

    } else {

    }
#line 69
    rcu_read_unlock_sched_notrace___1();
  } else {

  }
#line 69
  rcu_read_lock_sched_notrace___1();
#line 69
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 69
  _________p1___0 = __u___0.__val;
#line 69
  ________p1___0 = _________p1___0;
#line 69
  tmp___2 = debug_lockdep_rcu_enabled();
#line 69
  if (tmp___2 != 0 && ! __warned___0) {
#line 69
    tmp___3 = rcu_read_lock_sched_held___1();
#line 69
    if (tmp___3 == 0) {
#line 69
      __warned___0 = 1;
#line 69
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 69
  rcu_read_unlock_sched_notrace___1();
#line 71
  return;
}
}
#line 41 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static void iwl_write32___1(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
#line 43
  trace_iwlwifi_dev_iowrite32___1((struct device  const  *)trans->dev, ofs, val);
#line 44
  iwl_trans_write32(trans, ofs, val);
#line 45
  return;
}
}
#line 47 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static u32 iwl_read32___0(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 val ;
  u32 tmp ;

  {
#line 49
  tmp = iwl_trans_read32(trans, ofs);
#line 49
  val = tmp;
#line 50
  trace_iwlwifi_dev_ioread32___0((struct device  const  *)trans->dev, ofs, val);
#line 51
  return (val);
}
}
#line 117 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/tt.h"
u8 iwl_tt_current_power_mode(struct iwl_priv *priv ) ;
#line 118
bool iwl_tt_is_low_power_state(struct iwl_priv *priv ) ;
#line 121
enum iwl_antenna_ok iwl_rx_ant_restriction(struct iwl_priv *priv ) ;
#line 122
void iwl_tt_enter_ct_kill(struct iwl_priv *priv ) ;
#line 123
void iwl_tt_exit_ct_kill(struct iwl_priv *priv ) ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static struct iwl_tt_trans  const  tt_range_0[3U]  = {      {0, 0U, 104U}, 
        {1, 105U, 113U}, 
        {3, 114U, 4294967295U}};
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static struct iwl_tt_trans  const  tt_range_1[3U]  = {      {0, 0U, 95U}, 
        {2, 110U, 113U}, 
        {3, 114U, 4294967295U}};
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static struct iwl_tt_trans  const  tt_range_2[3U]  = {      {1, 0U, 100U}, 
        {3, 114U, 4294967295U}, 
        {3, 114U, 4294967295U}};
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static struct iwl_tt_trans  const  tt_range_3[3U]  = {      {0, 0U, 95U}, 
        {3, 96U, 4294967295U}, 
        {3, 96U, 4294967295U}};
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static struct iwl_tt_restriction  const  restriction_range[4U]  = {      {2, 2, 1}, 
        {1, 2, 1}, 
        {1, 1, 0}, 
        {0, 0, 0}};
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
bool iwl_tt_is_low_power_state(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;

  {
#line 84
  tt = & priv->thermal_throttle;
#line 86
  if ((unsigned int )tt->state != 0U) {
#line 87
    return (1);
  } else {

  }
#line 88
  return (0);
}
}
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
u8 iwl_tt_current_power_mode(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;

  {
#line 93
  tt = & priv->thermal_throttle;
#line 95
  return (tt->tt_power_mode);
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
bool iwl_ht_enabled(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;
  struct iwl_tt_restriction *restriction ;

  {
#line 100
  tt = & priv->thermal_throttle;
#line 103
  if (! priv->thermal_throttle.advanced_tt) {
#line 104
    return (1);
  } else {

  }
#line 105
  restriction = tt->restriction + (unsigned long )tt->state;
#line 106
  return (restriction->is_ht);
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static bool iwl_within_ct_kill_margin(struct iwl_priv *priv ) 
{ 
  s32 temp ;
  bool within_margin ;

  {
#line 111
  temp = priv->temperature;
#line 112
  within_margin = 0;
#line 114
  if (! priv->thermal_throttle.advanced_tt) {
#line 115
    within_margin = temp + 3 > 109;
  } else {
#line 118
    within_margin = temp + 3 > 113;
  }
#line 120
  return (within_margin);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
bool iwl_check_for_ct_kill(struct iwl_priv *priv ) 
{ 
  bool is_ct_kill ;
  bool tmp ;

  {
#line 125
  is_ct_kill = 0;
#line 127
  tmp = iwl_within_ct_kill_margin(priv);
#line 127
  if ((int )tmp) {
#line 128
    iwl_tt_enter_ct_kill(priv);
#line 129
    is_ct_kill = 1;
  } else {

  }
#line 131
  return (is_ct_kill);
}
}
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
enum iwl_antenna_ok iwl_tx_ant_restriction(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;
  struct iwl_tt_restriction *restriction ;

  {
#line 136
  tt = & priv->thermal_throttle;
#line 139
  if (! priv->thermal_throttle.advanced_tt) {
#line 140
    return (2);
  } else {

  }
#line 141
  restriction = tt->restriction + (unsigned long )tt->state;
#line 142
  return (restriction->tx_stream);
}
}
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
enum iwl_antenna_ok iwl_rx_ant_restriction(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;
  struct iwl_tt_restriction *restriction ;

  {
#line 147
  tt = & priv->thermal_throttle;
#line 150
  if (! priv->thermal_throttle.advanced_tt) {
#line 151
    return (2);
  } else {

  }
#line 152
  restriction = tt->restriction + (unsigned long )tt->state;
#line 153
  return (restriction->rx_stream);
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_tt_check_exit_ct_kill(unsigned long data ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_tt_mgmt *tt ;
  unsigned long flags ;
  int tmp ;
  bool tmp___0 ;
  long tmp___1 ;

  {
#line 169
  priv = (struct iwl_priv *)data;
#line 170
  tt = & priv->thermal_throttle;
#line 173
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 173
  if (tmp != 0) {
#line 174
    return;
  } else {

  }
#line 176
  if ((unsigned int )tt->state == 3U) {
#line 177
    if ((int )priv->thermal_throttle.ct_kill_toggle) {
#line 178
      iwl_write32___1(priv->trans, 92U, 8U);
#line 180
      priv->thermal_throttle.ct_kill_toggle = 0;
    } else {
#line 182
      iwl_write32___1(priv->trans, 88U, 8U);
#line 184
      priv->thermal_throttle.ct_kill_toggle = 1;
    }
#line 186
    iwl_read32___0(priv->trans, 84U);
#line 187
    tmp___0 = (*(((priv->trans)->ops)->grab_nic_access))(priv->trans, 0, & flags);
#line 187
    tmp___1 = ldv__builtin_expect((long )tmp___0, 1L);
#line 187
    if (tmp___1 != 0L) {
#line 188
      iwl_trans_release_nic_access(priv->trans, & flags);
    } else {

    }
#line 193
    __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_check_exit_ct_kill", "schedule ct_kill exit timer\n");
#line 194
    ldv_mod_timer_347(& priv->thermal_throttle.ct_kill_exit_tm, (unsigned long )jiffies + 1250UL);
  } else {

  }
#line 197
  return;
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_perform_ct_kill_task(struct iwl_priv *priv , bool stop ) 
{ 


  {
#line 202
  if ((int )stop) {
#line 203
    __iwl_dbg(priv->dev, 512U, 0, "iwl_perform_ct_kill_task", "Stop all queues\n");
#line 204
    if ((unsigned int )priv->mac80211_registered != 0U) {
#line 205
      ieee80211_stop_queues(priv->hw);
    } else {

    }
#line 206
    __iwl_dbg(priv->dev, 512U, 0, "iwl_perform_ct_kill_task", "Schedule 5 seconds CT_KILL Timer\n");
#line 208
    ldv_mod_timer_348(& priv->thermal_throttle.ct_kill_exit_tm, (unsigned long )jiffies + 1250UL);
  } else {
#line 211
    __iwl_dbg(priv->dev, 512U, 0, "iwl_perform_ct_kill_task", "Wake all queues\n");
#line 212
    if ((unsigned int )priv->mac80211_registered != 0U) {
#line 213
      ieee80211_wake_queues(priv->hw);
    } else {

    }
  }
#line 215
  return;
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_tt_ready_for_ct_kill(unsigned long data ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_tt_mgmt *tt ;
  int tmp ;

  {
#line 219
  priv = (struct iwl_priv *)data;
#line 220
  tt = & priv->thermal_throttle;
#line 222
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 222
  if (tmp != 0) {
#line 223
    return;
  } else {

  }
#line 226
  if ((unsigned int )tt->state != 3U) {
#line 227
    __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_ready_for_ct_kill", "entering CT_KILL state when temperature timer expired\n");
#line 229
    tt->state = 3;
#line 230
    set_bit(1L, (unsigned long volatile   *)(& priv->status));
#line 231
    iwl_perform_ct_kill_task(priv, 1);
  } else {

  }
#line 233
  return;
}
}
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_prepare_ct_kill_task(struct iwl_priv *priv ) 
{ 
  unsigned long tmp ;

  {
#line 237
  __iwl_dbg(priv->dev, 512U, 0, "iwl_prepare_ct_kill_task", "Prepare to enter IWL_TI_CT_KILL\n");
#line 239
  iwl_send_statistics_request(priv, 0, 0);
#line 241
  tmp = msecs_to_jiffies(300U);
#line 241
  ldv_mod_timer_349(& priv->thermal_throttle.ct_kill_waiting_tm, tmp + (unsigned long )jiffies);
#line 243
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_legacy_tt_handler(struct iwl_priv *priv , s32 temp , bool force ) 
{ 
  struct iwl_tt_mgmt *tt ;
  enum iwl_tt_state old_state ;
  int tmp ;

  {
#line 260
  tt = & priv->thermal_throttle;
#line 264
  if ((tt->tt_previous_temp != 0 && tt->tt_previous_temp < temp) && temp - tt->tt_previous_temp > 5) {
#line 268
    __iwl_dbg(priv->dev, 512U, 0, "iwl_legacy_tt_handler", "Temperature increase %d degree Celsius\n",
              temp - tt->tt_previous_temp);
  } else {

  }
#line 273
  old_state = tt->state;
#line 275
  if (temp > 109) {
#line 276
    tt->state = 3;
  } else
#line 277
  if (temp > 99) {
#line 278
    tt->state = 2;
  } else
#line 279
  if (temp > 89) {
#line 280
    tt->state = 1;
  } else {
#line 282
    tt->state = 0;
  }
#line 285
  tt->tt_previous_temp = temp;
#line 288
  ldv_del_timer_sync_350(& priv->thermal_throttle.ct_kill_waiting_tm);
#line 289
  if ((unsigned int )tt->state != (unsigned int )old_state) {
#line 290
    switch ((unsigned int )tt->state) {
    case 0U: ;
#line 297
    goto ldv_55239;
    case 1U: 
#line 299
    tt->tt_power_mode = 2U;
#line 300
    goto ldv_55239;
    case 2U: 
#line 302
    tt->tt_power_mode = 3U;
#line 303
    goto ldv_55239;
    default: 
#line 305
    tt->tt_power_mode = 4U;
#line 306
    goto ldv_55239;
    }
    ldv_55239: 
#line 308
    ldv_mutex_lock_351(& priv->mutex);
#line 309
    if ((unsigned int )old_state == 3U) {
#line 310
      clear_bit(1L, (unsigned long volatile   *)(& priv->status));
    } else {

    }
#line 311
    if ((unsigned int )tt->state != 3U) {
#line 311
      tmp = iwl_power_update_mode(priv, 1);
#line 311
      if (tmp != 0) {
#line 316
        if ((unsigned int )old_state == 3U) {
#line 317
          set_bit(1L, (unsigned long volatile   *)(& priv->status));
        } else {

        }
#line 318
        tt->state = old_state;
#line 319
        __iwl_err(priv->dev, 0, 0, "Cannot update power mode, TT state not updated\n");
      } else {
#line 311
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 322
      if ((unsigned int )tt->state == 3U) {
#line 323
        if ((int )force) {
#line 324
          set_bit(1L, (unsigned long volatile   *)(& priv->status));
#line 325
          iwl_perform_ct_kill_task(priv, 1);
        } else {
#line 327
          iwl_prepare_ct_kill_task(priv);
#line 328
          tt->state = old_state;
        }
      } else
#line 330
      if ((unsigned int )old_state == 3U && (unsigned int )tt->state != 3U) {
#line 332
        iwl_perform_ct_kill_task(priv, 0);
      } else {

      }
#line 333
      __iwl_dbg(priv->dev, 512U, 0, "iwl_legacy_tt_handler", "Temperature state changed %u\n",
                (unsigned int )tt->state);
#line 335
      __iwl_dbg(priv->dev, 512U, 0, "iwl_legacy_tt_handler", "Power Index change to %u\n",
                (int )tt->tt_power_mode);
    }
#line 338
    ldv_mutex_unlock_352(& priv->mutex);
  } else {

  }
#line 340
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_advance_tt_handler(struct iwl_priv *priv , s32 temp , bool force ) 
{ 
  struct iwl_tt_mgmt *tt ;
  int i ;
  bool changed ;
  enum iwl_tt_state old_state ;
  struct iwl_tt_trans *transaction ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_cmd *rxon ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 365
  tt = & priv->thermal_throttle;
#line 367
  changed = 0;
#line 371
  old_state = tt->state;
#line 372
  i = 0;
#line 372
  goto ldv_55256;
  ldv_55255: 
#line 383
  transaction = tt->transaction + (unsigned long )((unsigned int )old_state * 3U + (unsigned int )i);
#line 385
  if ((u32 )temp >= transaction->tt_low && (u32 )temp <= transaction->tt_high) {
#line 388
    if ((tt->tt_previous_temp != 0 && tt->tt_previous_temp < temp) && temp - tt->tt_previous_temp > 5) {
#line 392
      __iwl_dbg(priv->dev, 512U, 0, "iwl_advance_tt_handler", "Temperature increase %d degree Celsius\n",
                temp - tt->tt_previous_temp);
    } else {

    }
#line 397
    tt->tt_previous_temp = temp;
#line 399
    if ((unsigned int )transaction->next_state != (unsigned int )old_state) {
#line 401
      changed = 1;
#line 402
      tt->state = transaction->next_state;
    } else {

    }
#line 405
    goto ldv_55254;
  } else {

  }
#line 372
  i = i + 1;
  ldv_55256: ;
#line 372
  if (i <= 2) {
#line 374
    goto ldv_55255;
  } else {

  }
  ldv_55254: 
#line 409
  ldv_del_timer_sync_353(& priv->thermal_throttle.ct_kill_waiting_tm);
#line 410
  if ((int )changed) {
#line 411
    if ((unsigned int )tt->state != 0U) {
#line 413
      tt->tt_power_mode = 4U;
#line 415
      tmp = iwl_ht_enabled(priv);
#line 415
      if (tmp) {
#line 415
        tmp___0 = 0;
      } else {
#line 415
        tmp___0 = 1;
      }
#line 415
      if (tmp___0) {
#line 418
        ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 418
        goto ldv_55260;
        ldv_55259: ;
#line 418
        if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 421
          rxon = & ctx->staging;
#line 424
          rxon->flags = rxon->flags & 4164943871U;
        } else {

        }
#line 418
        ctx = ctx + 1;
        ldv_55260: ;
#line 418
        if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 420
          goto ldv_55259;
        } else {

        }

      } else {
#line 434
        iwl_set_rxon_ht(priv, & priv->current_ht_config);
      }
    } else {
#line 446
      iwl_set_rxon_ht(priv, & priv->current_ht_config);
    }
#line 448
    ldv_mutex_lock_354(& priv->mutex);
#line 449
    if ((unsigned int )old_state == 3U) {
#line 450
      clear_bit(1L, (unsigned long volatile   *)(& priv->status));
    } else {

    }
#line 451
    if ((unsigned int )tt->state != 3U) {
#line 451
      tmp___1 = iwl_power_update_mode(priv, 1);
#line 451
      if (tmp___1 != 0) {
#line 456
        __iwl_err(priv->dev, 0, 0, "Cannot update power mode, TT state not updated\n");
#line 458
        if ((unsigned int )old_state == 3U) {
#line 459
          set_bit(1L, (unsigned long volatile   *)(& priv->status));
        } else {

        }
#line 460
        tt->state = old_state;
      } else {
#line 451
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 462
      __iwl_dbg(priv->dev, 512U, 0, "iwl_advance_tt_handler", "Thermal Throttling to new state: %u\n",
                (unsigned int )tt->state);
#line 465
      if ((unsigned int )old_state != 3U && (unsigned int )tt->state == 3U) {
#line 467
        if ((int )force) {
#line 468
          __iwl_dbg(priv->dev, 512U, 0, "iwl_advance_tt_handler", "Enter IWL_TI_CT_KILL\n");
#line 470
          set_bit(1L, (unsigned long volatile   *)(& priv->status));
#line 471
          iwl_perform_ct_kill_task(priv, 1);
        } else {
#line 473
          tt->state = old_state;
#line 474
          iwl_prepare_ct_kill_task(priv);
        }
      } else
#line 476
      if ((unsigned int )old_state == 3U && (unsigned int )tt->state != 3U) {
#line 478
        __iwl_dbg(priv->dev, 512U, 0, "iwl_advance_tt_handler", "Exit IWL_TI_CT_KILL\n");
#line 479
        iwl_perform_ct_kill_task(priv, 0);
      } else {

      }
    }
#line 482
    ldv_mutex_unlock_355(& priv->mutex);
  } else {

  }
#line 484
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_bg_ct_enter(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct iwl_tt_mgmt *tt ;
  int tmp ;
  int tmp___0 ;

  {
#line 498
  __mptr = (struct work_struct  const  *)work;
#line 498
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcf88UL;
#line 499
  tt = & priv->thermal_throttle;
#line 501
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 501
  if (tmp != 0) {
#line 502
    return;
  } else {

  }
#line 504
  tmp___0 = iwl_is_ready(priv);
#line 504
  if (tmp___0 == 0) {
#line 505
    return;
  } else {

  }
#line 507
  if ((unsigned int )tt->state != 3U) {
#line 508
    __iwl_err(priv->dev, 0, 0, "Device reached critical temperature - ucode going to sleep!\n");
#line 510
    if (! priv->thermal_throttle.advanced_tt) {
#line 511
      iwl_legacy_tt_handler(priv, 110, 1);
    } else {
#line 515
      iwl_advance_tt_handler(priv, 115, 1);
    }
  } else {

  }
#line 517
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_bg_ct_exit(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct iwl_tt_mgmt *tt ;
  int tmp ;
  int tmp___0 ;

  {
#line 527
  __mptr = (struct work_struct  const  *)work;
#line 527
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcf38UL;
#line 528
  tt = & priv->thermal_throttle;
#line 530
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 530
  if (tmp != 0) {
#line 531
    return;
  } else {

  }
#line 533
  tmp___0 = iwl_is_ready(priv);
#line 533
  if (tmp___0 == 0) {
#line 534
    return;
  } else {

  }
#line 537
  ldv_del_timer_sync_356(& priv->thermal_throttle.ct_kill_exit_tm);
#line 539
  if ((unsigned int )tt->state == 3U) {
#line 540
    __iwl_err(priv->dev, 0, 0, "Device temperature below critical- ucode awake!\n");
#line 547
    priv->temperature = 0;
#line 548
    if (! priv->thermal_throttle.advanced_tt) {
#line 549
      iwl_legacy_tt_handler(priv, 100, 1);
    } else {
#line 553
      iwl_advance_tt_handler(priv, 95, 1);
    }
  } else {

  }
#line 555
  return;
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
void iwl_tt_enter_ct_kill(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
#line 560
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 560
  if (tmp != 0) {
#line 561
    return;
  } else {

  }
#line 563
  __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_enter_ct_kill", "Queueing critical temperature enter.\n");
#line 564
  queue_work___4(priv->workqueue, & priv->ct_enter);
#line 565
  return;
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
void iwl_tt_exit_ct_kill(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
#line 569
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 569
  if (tmp != 0) {
#line 570
    return;
  } else {

  }
#line 572
  __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_exit_ct_kill", "Queueing critical temperature exit.\n");
#line 573
  queue_work___4(priv->workqueue, & priv->ct_exit);
#line 574
  return;
}
}
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
static void iwl_bg_tt_work(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  s32 temp ;
  int tmp ;

  {
#line 578
  __mptr = (struct work_struct  const  *)work;
#line 578
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcfd8UL;
#line 579
  temp = priv->temperature;
#line 581
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 581
  if (tmp != 0) {
#line 582
    return;
  } else {

  }
#line 584
  if (! priv->thermal_throttle.advanced_tt) {
#line 585
    iwl_legacy_tt_handler(priv, temp, 0);
  } else {
#line 587
    iwl_advance_tt_handler(priv, temp, 0);
  }
#line 588
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
void iwl_tt_handler(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
#line 592
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 592
  if (tmp != 0) {
#line 593
    return;
  } else {

  }
#line 595
  __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_handler", "Queueing thermal throttling work.\n");
#line 596
  queue_work___4(priv->workqueue, & priv->tt_work);
#line 597
  return;
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
void iwl_tt_initialize(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;
  int size ;
  struct iwl_tt_trans *transaction ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_2 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 606
  tt = & priv->thermal_throttle;
#line 607
  size = 36;
#line 610
  __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_initialize", "Initialize Thermal Throttling\n");
#line 612
  memset((void *)tt, 0, 288UL);
#line 614
  tt->state = 0;
#line 615
  reg_timer_18(& priv->thermal_throttle.ct_kill_exit_tm, & iwl_tt_check_exit_ct_kill,
               (unsigned long )priv);
#line 617
  reg_timer_18(& priv->thermal_throttle.ct_kill_waiting_tm, & iwl_tt_ready_for_ct_kill,
               (unsigned long )priv);
#line 620
  __init_work(& priv->tt_work, 0);
#line 620
  __constr_expr_0.counter = 137438953408L;
#line 620
  priv->tt_work.data = __constr_expr_0;
#line 620
  lockdep_init_map(& priv->tt_work.lockdep_map, "(&priv->tt_work)", & __key, 0);
#line 620
  INIT_LIST_HEAD(& priv->tt_work.entry);
#line 620
  priv->tt_work.func = & iwl_bg_tt_work;
#line 621
  __init_work(& priv->ct_enter, 0);
#line 621
  __constr_expr_1.counter = 137438953408L;
#line 621
  priv->ct_enter.data = __constr_expr_1;
#line 621
  lockdep_init_map(& priv->ct_enter.lockdep_map, "(&priv->ct_enter)", & __key___0,
                   0);
#line 621
  INIT_LIST_HEAD(& priv->ct_enter.entry);
#line 621
  priv->ct_enter.func = & iwl_bg_ct_enter;
#line 622
  __init_work(& priv->ct_exit, 0);
#line 622
  __constr_expr_2.counter = 137438953408L;
#line 622
  priv->ct_exit.data = __constr_expr_2;
#line 622
  lockdep_init_map(& priv->ct_exit.lockdep_map, "(&priv->ct_exit)", & __key___1, 0);
#line 622
  INIT_LIST_HEAD(& priv->ct_exit.entry);
#line 622
  priv->ct_exit.func = & iwl_bg_ct_exit;
#line 624
  if ((int )(priv->lib)->adv_thermal_throttle) {
#line 625
    __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_initialize", "Advanced Thermal Throttling\n");
#line 626
    tmp = kcalloc(4UL, 12UL, 208U);
#line 626
    tt->restriction = (struct iwl_tt_restriction *)tmp;
#line 629
    tmp___0 = kcalloc(12UL, 12UL, 208U);
#line 629
    tt->transaction = (struct iwl_tt_trans *)tmp___0;
#line 633
    if ((unsigned long )tt->restriction == (unsigned long )((struct iwl_tt_restriction *)0) || (unsigned long )tt->transaction == (unsigned long )((struct iwl_tt_trans *)0)) {
#line 634
      __iwl_err(priv->dev, 0, 0, "Fallback to Legacy Throttling\n");
#line 635
      priv->thermal_throttle.advanced_tt = 0;
#line 636
      kfree((void const   *)tt->restriction);
#line 637
      tt->restriction = (struct iwl_tt_restriction *)0;
#line 638
      kfree((void const   *)tt->transaction);
#line 639
      tt->transaction = (struct iwl_tt_trans *)0;
    } else {
#line 641
      transaction = tt->transaction;
#line 643
      memcpy((void *)transaction, (void const   *)(& tt_range_0), (size_t )size);
#line 644
      transaction = tt->transaction + 3UL;
#line 646
      memcpy((void *)transaction, (void const   *)(& tt_range_1), (size_t )size);
#line 647
      transaction = tt->transaction + 6UL;
#line 649
      memcpy((void *)transaction, (void const   *)(& tt_range_2), (size_t )size);
#line 650
      transaction = tt->transaction + 9UL;
#line 652
      memcpy((void *)transaction, (void const   *)(& tt_range_3), (size_t )size);
#line 653
      size = 48;
#line 655
      memcpy((void *)tt->restriction, (void const   *)(& restriction_range), (size_t )size);
#line 657
      priv->thermal_throttle.advanced_tt = 1;
    }
  } else {
#line 660
    __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_initialize", "Legacy Thermal Throttling\n");
#line 661
    priv->thermal_throttle.advanced_tt = 0;
  }
#line 663
  return;
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.c"
void iwl_tt_exit(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;

  {
#line 668
  tt = & priv->thermal_throttle;
#line 671
  ldv_del_timer_sync_357(& priv->thermal_throttle.ct_kill_exit_tm);
#line 673
  ldv_del_timer_sync_358(& priv->thermal_throttle.ct_kill_waiting_tm);
#line 674
  ldv_cancel_work_sync_359(& priv->tt_work);
#line 675
  ldv_cancel_work_sync_360(& priv->ct_enter);
#line 676
  ldv_cancel_work_sync_361(& priv->ct_exit);
#line 678
  if ((int )priv->thermal_throttle.advanced_tt) {
#line 680
    kfree((void const   *)tt->restriction);
#line 681
    tt->restriction = (struct iwl_tt_restriction *)0;
#line 682
    kfree((void const   *)tt->transaction);
#line 683
    tt->transaction = (struct iwl_tt_trans *)0;
  } else {

  }
#line 685
  return;
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void activate_suitable_timer_18(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 551
  if (ldv_timer_18_0 == 0 || ldv_timer_18_0 == 2) {
#line 552
    ldv_timer_list_18_0 = timer;
#line 553
    ldv_timer_list_18_0->data = data;
#line 554
    ldv_timer_18_0 = 1;
#line 555
    return;
  } else {

  }
#line 557
  if (ldv_timer_18_1 == 0 || ldv_timer_18_1 == 2) {
#line 558
    ldv_timer_list_18_1 = timer;
#line 559
    ldv_timer_list_18_1->data = data;
#line 560
    ldv_timer_18_1 = 1;
#line 561
    return;
  } else {

  }
#line 563
  if (ldv_timer_18_2 == 0 || ldv_timer_18_2 == 2) {
#line 564
    ldv_timer_list_18_2 = timer;
#line 565
    ldv_timer_list_18_2->data = data;
#line 566
    ldv_timer_18_2 = 1;
#line 567
    return;
  } else {

  }
#line 569
  if (ldv_timer_18_3 == 0 || ldv_timer_18_3 == 2) {
#line 570
    ldv_timer_list_18_3 = timer;
#line 571
    ldv_timer_list_18_3->data = data;
#line 572
    ldv_timer_18_3 = 1;
#line 573
    return;
  } else {

  }
#line 575
  return;
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void timer_init_17(void) 
{ 


  {
#line 580
  ldv_timer_17_0 = 0;
#line 581
  ldv_timer_17_1 = 0;
#line 582
  ldv_timer_17_2 = 0;
#line 583
  ldv_timer_17_3 = 0;
#line 584
  return;
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void call_and_disable_work_10(struct work_struct *work ) 
{ 


  {
#line 590
  if ((ldv_work_10_0 == 2 || ldv_work_10_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_0) {
#line 592
    iwl_bg_ct_exit(work);
#line 593
    ldv_work_10_0 = 1;
#line 594
    return;
  } else {

  }
#line 596
  if ((ldv_work_10_1 == 2 || ldv_work_10_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_1) {
#line 598
    iwl_bg_ct_exit(work);
#line 599
    ldv_work_10_1 = 1;
#line 600
    return;
  } else {

  }
#line 602
  if ((ldv_work_10_2 == 2 || ldv_work_10_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_2) {
#line 604
    iwl_bg_ct_exit(work);
#line 605
    ldv_work_10_2 = 1;
#line 606
    return;
  } else {

  }
#line 608
  if ((ldv_work_10_3 == 2 || ldv_work_10_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_3) {
#line 610
    iwl_bg_ct_exit(work);
#line 611
    ldv_work_10_3 = 1;
#line 612
    return;
  } else {

  }
#line 614
  return;
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void work_init_9(void) 
{ 


  {
#line 618
  ldv_work_9_0 = 0;
#line 619
  ldv_work_9_1 = 0;
#line 620
  ldv_work_9_2 = 0;
#line 621
  ldv_work_9_3 = 0;
#line 622
  return;
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void invoke_work_8(void) 
{ 
  int tmp ;

  {
#line 627
  tmp = __VERIFIER_nondet_int();
#line 627
  switch (tmp) {
  case 0: ;
#line 629
  if (ldv_work_8_0 == 2 || ldv_work_8_0 == 3) {
#line 630
    ldv_work_8_0 = 4;
#line 631
    iwl_bg_tt_work(ldv_work_struct_8_0);
#line 632
    ldv_work_8_0 = 1;
  } else {

  }
#line 635
  goto ldv_55333;
  case 1: ;
#line 637
  if (ldv_work_8_1 == 2 || ldv_work_8_1 == 3) {
#line 638
    ldv_work_8_1 = 4;
#line 639
    iwl_bg_tt_work(ldv_work_struct_8_0);
#line 640
    ldv_work_8_1 = 1;
  } else {

  }
#line 643
  goto ldv_55333;
  case 2: ;
#line 645
  if (ldv_work_8_2 == 2 || ldv_work_8_2 == 3) {
#line 646
    ldv_work_8_2 = 4;
#line 647
    iwl_bg_tt_work(ldv_work_struct_8_0);
#line 648
    ldv_work_8_2 = 1;
  } else {

  }
#line 651
  goto ldv_55333;
  case 3: ;
#line 653
  if (ldv_work_8_3 == 2 || ldv_work_8_3 == 3) {
#line 654
    ldv_work_8_3 = 4;
#line 655
    iwl_bg_tt_work(ldv_work_struct_8_0);
#line 656
    ldv_work_8_3 = 1;
  } else {

  }
#line 659
  goto ldv_55333;
  default: 
#line 660
  ldv_stop();
  }
  ldv_55333: ;
#line 662
  return;
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void disable_suitable_timer_17(struct timer_list *timer ) 
{ 


  {
#line 667
  if (ldv_timer_17_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_17_0) {
#line 668
    ldv_timer_17_0 = 0;
#line 669
    return;
  } else {

  }
#line 671
  if (ldv_timer_17_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_17_1) {
#line 672
    ldv_timer_17_1 = 0;
#line 673
    return;
  } else {

  }
#line 675
  if (ldv_timer_17_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_17_2) {
#line 676
    ldv_timer_17_2 = 0;
#line 677
    return;
  } else {

  }
#line 679
  if (ldv_timer_17_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_17_3) {
#line 680
    ldv_timer_17_3 = 0;
#line 681
    return;
  } else {

  }
#line 683
  return;
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int reg_timer_18(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 688
  if ((unsigned long )function == (unsigned long )(& iwl_tt_ready_for_ct_kill)) {
#line 689
    activate_suitable_timer_18(timer, data);
  } else {

  }
#line 690
  return (0);
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void activate_pending_timer_18(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 695
  if ((unsigned long )ldv_timer_list_18_0 == (unsigned long )timer) {
#line 696
    if (ldv_timer_18_0 == 2 || pending_flag != 0) {
#line 697
      ldv_timer_list_18_0 = timer;
#line 698
      ldv_timer_list_18_0->data = data;
#line 699
      ldv_timer_18_0 = 1;
    } else {

    }
#line 701
    return;
  } else {

  }
#line 704
  if ((unsigned long )ldv_timer_list_18_1 == (unsigned long )timer) {
#line 705
    if (ldv_timer_18_1 == 2 || pending_flag != 0) {
#line 706
      ldv_timer_list_18_1 = timer;
#line 707
      ldv_timer_list_18_1->data = data;
#line 708
      ldv_timer_18_1 = 1;
    } else {

    }
#line 710
    return;
  } else {

  }
#line 713
  if ((unsigned long )ldv_timer_list_18_2 == (unsigned long )timer) {
#line 714
    if (ldv_timer_18_2 == 2 || pending_flag != 0) {
#line 715
      ldv_timer_list_18_2 = timer;
#line 716
      ldv_timer_list_18_2->data = data;
#line 717
      ldv_timer_18_2 = 1;
    } else {

    }
#line 719
    return;
  } else {

  }
#line 722
  if ((unsigned long )ldv_timer_list_18_3 == (unsigned long )timer) {
#line 723
    if (ldv_timer_18_3 == 2 || pending_flag != 0) {
#line 724
      ldv_timer_list_18_3 = timer;
#line 725
      ldv_timer_list_18_3->data = data;
#line 726
      ldv_timer_18_3 = 1;
    } else {

    }
#line 728
    return;
  } else {

  }
#line 730
  activate_suitable_timer_18(timer, data);
#line 731
  return;
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void invoke_work_10(void) 
{ 
  int tmp ;

  {
#line 736
  tmp = __VERIFIER_nondet_int();
#line 736
  switch (tmp) {
  case 0: ;
#line 738
  if (ldv_work_10_0 == 2 || ldv_work_10_0 == 3) {
#line 739
    ldv_work_10_0 = 4;
#line 740
    iwl_bg_ct_exit(ldv_work_struct_10_0);
#line 741
    ldv_work_10_0 = 1;
  } else {

  }
#line 744
  goto ldv_55358;
  case 1: ;
#line 746
  if (ldv_work_10_1 == 2 || ldv_work_10_1 == 3) {
#line 747
    ldv_work_10_1 = 4;
#line 748
    iwl_bg_ct_exit(ldv_work_struct_10_0);
#line 749
    ldv_work_10_1 = 1;
  } else {

  }
#line 752
  goto ldv_55358;
  case 2: ;
#line 754
  if (ldv_work_10_2 == 2 || ldv_work_10_2 == 3) {
#line 755
    ldv_work_10_2 = 4;
#line 756
    iwl_bg_ct_exit(ldv_work_struct_10_0);
#line 757
    ldv_work_10_2 = 1;
  } else {

  }
#line 760
  goto ldv_55358;
  case 3: ;
#line 762
  if (ldv_work_10_3 == 2 || ldv_work_10_3 == 3) {
#line 763
    ldv_work_10_3 = 4;
#line 764
    iwl_bg_ct_exit(ldv_work_struct_10_0);
#line 765
    ldv_work_10_3 = 1;
  } else {

  }
#line 768
  goto ldv_55358;
  default: 
#line 769
  ldv_stop();
  }
  ldv_55358: ;
#line 771
  return;
}
}
#line 775 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_timer_17(int state , struct timer_list *timer ) 
{ 


  {
#line 776
  LDV_IN_INTERRUPT = 2;
#line 777
  iwl_tt_check_exit_ct_kill(timer->data);
#line 778
  LDV_IN_INTERRUPT = 1;
#line 779
  return;
}
}
#line 782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void choose_timer_18(void) 
{ 
  int tmp ;

  {
#line 783
  tmp = __VERIFIER_nondet_int();
#line 783
  switch (tmp) {
  case 0: ;
#line 785
  if (ldv_timer_18_0 == 1) {
#line 786
    ldv_timer_18_0 = 2;
#line 787
    ldv_timer_18(ldv_timer_18_0, ldv_timer_list_18_0);
  } else {

  }
#line 790
  goto ldv_55371;
  case 1: ;
#line 792
  if (ldv_timer_18_1 == 1) {
#line 793
    ldv_timer_18_1 = 2;
#line 794
    ldv_timer_18(ldv_timer_18_1, ldv_timer_list_18_1);
  } else {

  }
#line 797
  goto ldv_55371;
  case 2: ;
#line 799
  if (ldv_timer_18_2 == 1) {
#line 800
    ldv_timer_18_2 = 2;
#line 801
    ldv_timer_18(ldv_timer_18_2, ldv_timer_list_18_2);
  } else {

  }
#line 804
  goto ldv_55371;
  case 3: ;
#line 806
  if (ldv_timer_18_3 == 1) {
#line 807
    ldv_timer_18_3 = 2;
#line 808
    ldv_timer_18(ldv_timer_18_3, ldv_timer_list_18_3);
  } else {

  }
#line 811
  goto ldv_55371;
  default: 
#line 812
  ldv_stop();
  }
  ldv_55371: ;
#line 814
  return;
}
}
#line 818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void disable_suitable_timer_18(struct timer_list *timer ) 
{ 


  {
#line 819
  if (ldv_timer_18_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_18_0) {
#line 820
    ldv_timer_18_0 = 0;
#line 821
    return;
  } else {

  }
#line 823
  if (ldv_timer_18_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_18_1) {
#line 824
    ldv_timer_18_1 = 0;
#line 825
    return;
  } else {

  }
#line 827
  if (ldv_timer_18_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_18_2) {
#line 828
    ldv_timer_18_2 = 0;
#line 829
    return;
  } else {

  }
#line 831
  if (ldv_timer_18_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_18_3) {
#line 832
    ldv_timer_18_3 = 0;
#line 833
    return;
  } else {

  }
#line 835
  return;
}
}
#line 839 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void work_init_8(void) 
{ 


  {
#line 840
  ldv_work_8_0 = 0;
#line 841
  ldv_work_8_1 = 0;
#line 842
  ldv_work_8_2 = 0;
#line 843
  ldv_work_8_3 = 0;
#line 844
  return;
}
}
#line 847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void call_and_disable_all_9(int state ) 
{ 


  {
#line 849
  if (ldv_work_9_0 == state) {
#line 850
    call_and_disable_work_9(ldv_work_struct_9_0);
  } else {

  }
#line 851
  if (ldv_work_9_1 == state) {
#line 852
    call_and_disable_work_9(ldv_work_struct_9_1);
  } else {

  }
#line 853
  if (ldv_work_9_2 == state) {
#line 854
    call_and_disable_work_9(ldv_work_struct_9_2);
  } else {

  }
#line 855
  if (ldv_work_9_3 == state) {
#line 856
    call_and_disable_work_9(ldv_work_struct_9_3);
  } else {

  }
#line 857
  return;
}
}
#line 860 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void work_init_10(void) 
{ 


  {
#line 861
  ldv_work_10_0 = 0;
#line 862
  ldv_work_10_1 = 0;
#line 863
  ldv_work_10_2 = 0;
#line 864
  ldv_work_10_3 = 0;
#line 865
  return;
}
}
#line 868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void timer_init_18(void) 
{ 


  {
#line 869
  ldv_timer_18_0 = 0;
#line 870
  ldv_timer_18_1 = 0;
#line 871
  ldv_timer_18_2 = 0;
#line 872
  ldv_timer_18_3 = 0;
#line 873
  return;
}
}
#line 876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void call_and_disable_work_8(struct work_struct *work ) 
{ 


  {
#line 879
  if ((ldv_work_8_0 == 2 || ldv_work_8_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_0) {
#line 881
    iwl_bg_tt_work(work);
#line 882
    ldv_work_8_0 = 1;
#line 883
    return;
  } else {

  }
#line 885
  if ((ldv_work_8_1 == 2 || ldv_work_8_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_1) {
#line 887
    iwl_bg_tt_work(work);
#line 888
    ldv_work_8_1 = 1;
#line 889
    return;
  } else {

  }
#line 891
  if ((ldv_work_8_2 == 2 || ldv_work_8_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_2) {
#line 893
    iwl_bg_tt_work(work);
#line 894
    ldv_work_8_2 = 1;
#line 895
    return;
  } else {

  }
#line 897
  if ((ldv_work_8_3 == 2 || ldv_work_8_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_3) {
#line 899
    iwl_bg_tt_work(work);
#line 900
    ldv_work_8_3 = 1;
#line 901
    return;
  } else {

  }
#line 903
  return;
}
}
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void invoke_work_9(void) 
{ 
  int tmp ;

  {
#line 908
  tmp = __VERIFIER_nondet_int();
#line 908
  switch (tmp) {
  case 0: ;
#line 910
  if (ldv_work_9_0 == 2 || ldv_work_9_0 == 3) {
#line 911
    ldv_work_9_0 = 4;
#line 912
    iwl_bg_ct_enter(ldv_work_struct_9_0);
#line 913
    ldv_work_9_0 = 1;
  } else {

  }
#line 916
  goto ldv_55402;
  case 1: ;
#line 918
  if (ldv_work_9_1 == 2 || ldv_work_9_1 == 3) {
#line 919
    ldv_work_9_1 = 4;
#line 920
    iwl_bg_ct_enter(ldv_work_struct_9_0);
#line 921
    ldv_work_9_1 = 1;
  } else {

  }
#line 924
  goto ldv_55402;
  case 2: ;
#line 926
  if (ldv_work_9_2 == 2 || ldv_work_9_2 == 3) {
#line 927
    ldv_work_9_2 = 4;
#line 928
    iwl_bg_ct_enter(ldv_work_struct_9_0);
#line 929
    ldv_work_9_2 = 1;
  } else {

  }
#line 932
  goto ldv_55402;
  case 3: ;
#line 934
  if (ldv_work_9_3 == 2 || ldv_work_9_3 == 3) {
#line 935
    ldv_work_9_3 = 4;
#line 936
    iwl_bg_ct_enter(ldv_work_struct_9_0);
#line 937
    ldv_work_9_3 = 1;
  } else {

  }
#line 940
  goto ldv_55402;
  default: 
#line 941
  ldv_stop();
  }
  ldv_55402: ;
#line 943
  return;
}
}
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void disable_work_8(struct work_struct *work ) 
{ 


  {
#line 949
  if ((ldv_work_8_0 == 3 || ldv_work_8_0 == 2) && (unsigned long )ldv_work_struct_8_0 == (unsigned long )work) {
#line 951
    ldv_work_8_0 = 1;
  } else {

  }
#line 953
  if ((ldv_work_8_1 == 3 || ldv_work_8_1 == 2) && (unsigned long )ldv_work_struct_8_1 == (unsigned long )work) {
#line 955
    ldv_work_8_1 = 1;
  } else {

  }
#line 957
  if ((ldv_work_8_2 == 3 || ldv_work_8_2 == 2) && (unsigned long )ldv_work_struct_8_2 == (unsigned long )work) {
#line 959
    ldv_work_8_2 = 1;
  } else {

  }
#line 961
  if ((ldv_work_8_3 == 3 || ldv_work_8_3 == 2) && (unsigned long )ldv_work_struct_8_3 == (unsigned long )work) {
#line 963
    ldv_work_8_3 = 1;
  } else {

  }
#line 964
  return;
}
}
#line 968 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void activate_work_9(struct work_struct *work , int state ) 
{ 


  {
#line 969
  if (ldv_work_9_0 == 0) {
#line 970
    ldv_work_struct_9_0 = work;
#line 971
    ldv_work_9_0 = state;
#line 972
    return;
  } else {

  }
#line 975
  if (ldv_work_9_1 == 0) {
#line 976
    ldv_work_struct_9_1 = work;
#line 977
    ldv_work_9_1 = state;
#line 978
    return;
  } else {

  }
#line 981
  if (ldv_work_9_2 == 0) {
#line 982
    ldv_work_struct_9_2 = work;
#line 983
    ldv_work_9_2 = state;
#line 984
    return;
  } else {

  }
#line 987
  if (ldv_work_9_3 == 0) {
#line 988
    ldv_work_struct_9_3 = work;
#line 989
    ldv_work_9_3 = state;
#line 990
    return;
  } else {

  }
#line 992
  return;
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_timer_18(int state , struct timer_list *timer ) 
{ 


  {
#line 996
  LDV_IN_INTERRUPT = 2;
#line 997
  iwl_tt_ready_for_ct_kill(timer->data);
#line 998
  LDV_IN_INTERRUPT = 1;
#line 999
  return;
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void choose_timer_17(void) 
{ 
  int tmp ;

  {
#line 1003
  tmp = __VERIFIER_nondet_int();
#line 1003
  switch (tmp) {
  case 0: ;
#line 1005
  if (ldv_timer_17_0 == 1) {
#line 1006
    ldv_timer_17_0 = 2;
#line 1007
    ldv_timer_17(ldv_timer_17_0, ldv_timer_list_17_0);
  } else {

  }
#line 1010
  goto ldv_55422;
  case 1: ;
#line 1012
  if (ldv_timer_17_1 == 1) {
#line 1013
    ldv_timer_17_1 = 2;
#line 1014
    ldv_timer_17(ldv_timer_17_1, ldv_timer_list_17_1);
  } else {

  }
#line 1017
  goto ldv_55422;
  case 2: ;
#line 1019
  if (ldv_timer_17_2 == 1) {
#line 1020
    ldv_timer_17_2 = 2;
#line 1021
    ldv_timer_17(ldv_timer_17_2, ldv_timer_list_17_2);
  } else {

  }
#line 1024
  goto ldv_55422;
  case 3: ;
#line 1026
  if (ldv_timer_17_3 == 1) {
#line 1027
    ldv_timer_17_3 = 2;
#line 1028
    ldv_timer_17(ldv_timer_17_3, ldv_timer_list_17_3);
  } else {

  }
#line 1031
  goto ldv_55422;
  default: 
#line 1032
  ldv_stop();
  }
  ldv_55422: ;
#line 1034
  return;
}
}
#line 1038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void call_and_disable_all_8(int state ) 
{ 


  {
#line 1040
  if (ldv_work_8_0 == state) {
#line 1041
    call_and_disable_work_8(ldv_work_struct_8_0);
  } else {

  }
#line 1042
  if (ldv_work_8_1 == state) {
#line 1043
    call_and_disable_work_8(ldv_work_struct_8_1);
  } else {

  }
#line 1044
  if (ldv_work_8_2 == state) {
#line 1045
    call_and_disable_work_8(ldv_work_struct_8_2);
  } else {

  }
#line 1046
  if (ldv_work_8_3 == state) {
#line 1047
    call_and_disable_work_8(ldv_work_struct_8_3);
  } else {

  }
#line 1048
  return;
}
}
#line 1051 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void call_and_disable_work_9(struct work_struct *work ) 
{ 


  {
#line 1054
  if ((ldv_work_9_0 == 2 || ldv_work_9_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_0) {
#line 1056
    iwl_bg_ct_enter(work);
#line 1057
    ldv_work_9_0 = 1;
#line 1058
    return;
  } else {

  }
#line 1060
  if ((ldv_work_9_1 == 2 || ldv_work_9_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_1) {
#line 1062
    iwl_bg_ct_enter(work);
#line 1063
    ldv_work_9_1 = 1;
#line 1064
    return;
  } else {

  }
#line 1066
  if ((ldv_work_9_2 == 2 || ldv_work_9_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_2) {
#line 1068
    iwl_bg_ct_enter(work);
#line 1069
    ldv_work_9_2 = 1;
#line 1070
    return;
  } else {

  }
#line 1072
  if ((ldv_work_9_3 == 2 || ldv_work_9_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_3) {
#line 1074
    iwl_bg_ct_enter(work);
#line 1075
    ldv_work_9_3 = 1;
#line 1076
    return;
  } else {

  }
#line 1078
  return;
}
}
#line 1081 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void activate_work_8(struct work_struct *work , int state ) 
{ 


  {
#line 1082
  if (ldv_work_8_0 == 0) {
#line 1083
    ldv_work_struct_8_0 = work;
#line 1084
    ldv_work_8_0 = state;
#line 1085
    return;
  } else {

  }
#line 1088
  if (ldv_work_8_1 == 0) {
#line 1089
    ldv_work_struct_8_1 = work;
#line 1090
    ldv_work_8_1 = state;
#line 1091
    return;
  } else {

  }
#line 1094
  if (ldv_work_8_2 == 0) {
#line 1095
    ldv_work_struct_8_2 = work;
#line 1096
    ldv_work_8_2 = state;
#line 1097
    return;
  } else {

  }
#line 1100
  if (ldv_work_8_3 == 0) {
#line 1101
    ldv_work_struct_8_3 = work;
#line 1102
    ldv_work_8_3 = state;
#line 1103
    return;
  } else {

  }
#line 1105
  return;
}
}
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void activate_suitable_timer_17(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 1109
  if (ldv_timer_17_0 == 0 || ldv_timer_17_0 == 2) {
#line 1110
    ldv_timer_list_17_0 = timer;
#line 1111
    ldv_timer_list_17_0->data = data;
#line 1112
    ldv_timer_17_0 = 1;
#line 1113
    return;
  } else {

  }
#line 1115
  if (ldv_timer_17_1 == 0 || ldv_timer_17_1 == 2) {
#line 1116
    ldv_timer_list_17_1 = timer;
#line 1117
    ldv_timer_list_17_1->data = data;
#line 1118
    ldv_timer_17_1 = 1;
#line 1119
    return;
  } else {

  }
#line 1121
  if (ldv_timer_17_2 == 0 || ldv_timer_17_2 == 2) {
#line 1122
    ldv_timer_list_17_2 = timer;
#line 1123
    ldv_timer_list_17_2->data = data;
#line 1124
    ldv_timer_17_2 = 1;
#line 1125
    return;
  } else {

  }
#line 1127
  if (ldv_timer_17_3 == 0 || ldv_timer_17_3 == 2) {
#line 1128
    ldv_timer_list_17_3 = timer;
#line 1129
    ldv_timer_list_17_3->data = data;
#line 1130
    ldv_timer_17_3 = 1;
#line 1131
    return;
  } else {

  }
#line 1133
  return;
}
}
#line 1137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void disable_work_9(struct work_struct *work ) 
{ 


  {
#line 1139
  if ((ldv_work_9_0 == 3 || ldv_work_9_0 == 2) && (unsigned long )ldv_work_struct_9_0 == (unsigned long )work) {
#line 1141
    ldv_work_9_0 = 1;
  } else {

  }
#line 1143
  if ((ldv_work_9_1 == 3 || ldv_work_9_1 == 2) && (unsigned long )ldv_work_struct_9_1 == (unsigned long )work) {
#line 1145
    ldv_work_9_1 = 1;
  } else {

  }
#line 1147
  if ((ldv_work_9_2 == 3 || ldv_work_9_2 == 2) && (unsigned long )ldv_work_struct_9_2 == (unsigned long )work) {
#line 1149
    ldv_work_9_2 = 1;
  } else {

  }
#line 1151
  if ((ldv_work_9_3 == 3 || ldv_work_9_3 == 2) && (unsigned long )ldv_work_struct_9_3 == (unsigned long )work) {
#line 1153
    ldv_work_9_3 = 1;
  } else {

  }
#line 1154
  return;
}
}
#line 1158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void disable_work_10(struct work_struct *work ) 
{ 


  {
#line 1160
  if ((ldv_work_10_0 == 3 || ldv_work_10_0 == 2) && (unsigned long )ldv_work_struct_10_0 == (unsigned long )work) {
#line 1162
    ldv_work_10_0 = 1;
  } else {

  }
#line 1164
  if ((ldv_work_10_1 == 3 || ldv_work_10_1 == 2) && (unsigned long )ldv_work_struct_10_1 == (unsigned long )work) {
#line 1166
    ldv_work_10_1 = 1;
  } else {

  }
#line 1168
  if ((ldv_work_10_2 == 3 || ldv_work_10_2 == 2) && (unsigned long )ldv_work_struct_10_2 == (unsigned long )work) {
#line 1170
    ldv_work_10_2 = 1;
  } else {

  }
#line 1172
  if ((ldv_work_10_3 == 3 || ldv_work_10_3 == 2) && (unsigned long )ldv_work_struct_10_3 == (unsigned long )work) {
#line 1174
    ldv_work_10_3 = 1;
  } else {

  }
#line 1175
  return;
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int reg_timer_17(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 1180
  if ((unsigned long )function == (unsigned long )(& iwl_tt_check_exit_ct_kill)) {
#line 1181
    activate_suitable_timer_17(timer, data);
  } else {

  }
#line 1182
  return (0);
}
}
#line 1186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void activate_work_10(struct work_struct *work , int state ) 
{ 


  {
#line 1187
  if (ldv_work_10_0 == 0) {
#line 1188
    ldv_work_struct_10_0 = work;
#line 1189
    ldv_work_10_0 = state;
#line 1190
    return;
  } else {

  }
#line 1193
  if (ldv_work_10_1 == 0) {
#line 1194
    ldv_work_struct_10_1 = work;
#line 1195
    ldv_work_10_1 = state;
#line 1196
    return;
  } else {

  }
#line 1199
  if (ldv_work_10_2 == 0) {
#line 1200
    ldv_work_struct_10_2 = work;
#line 1201
    ldv_work_10_2 = state;
#line 1202
    return;
  } else {

  }
#line 1205
  if (ldv_work_10_3 == 0) {
#line 1206
    ldv_work_struct_10_3 = work;
#line 1207
    ldv_work_10_3 = state;
#line 1208
    return;
  } else {

  }
#line 1210
  return;
}
}
#line 1213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void activate_pending_timer_17(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 1214
  if ((unsigned long )ldv_timer_list_17_0 == (unsigned long )timer) {
#line 1215
    if (ldv_timer_17_0 == 2 || pending_flag != 0) {
#line 1216
      ldv_timer_list_17_0 = timer;
#line 1217
      ldv_timer_list_17_0->data = data;
#line 1218
      ldv_timer_17_0 = 1;
    } else {

    }
#line 1220
    return;
  } else {

  }
#line 1223
  if ((unsigned long )ldv_timer_list_17_1 == (unsigned long )timer) {
#line 1224
    if (ldv_timer_17_1 == 2 || pending_flag != 0) {
#line 1225
      ldv_timer_list_17_1 = timer;
#line 1226
      ldv_timer_list_17_1->data = data;
#line 1227
      ldv_timer_17_1 = 1;
    } else {

    }
#line 1229
    return;
  } else {

  }
#line 1232
  if ((unsigned long )ldv_timer_list_17_2 == (unsigned long )timer) {
#line 1233
    if (ldv_timer_17_2 == 2 || pending_flag != 0) {
#line 1234
      ldv_timer_list_17_2 = timer;
#line 1235
      ldv_timer_list_17_2->data = data;
#line 1236
      ldv_timer_17_2 = 1;
    } else {

    }
#line 1238
    return;
  } else {

  }
#line 1241
  if ((unsigned long )ldv_timer_list_17_3 == (unsigned long )timer) {
#line 1242
    if (ldv_timer_17_3 == 2 || pending_flag != 0) {
#line 1243
      ldv_timer_list_17_3 = timer;
#line 1244
      ldv_timer_list_17_3->data = data;
#line 1245
      ldv_timer_17_3 = 1;
    } else {

    }
#line 1247
    return;
  } else {

  }
#line 1249
  activate_suitable_timer_17(timer, data);
#line 1250
  return;
}
}
#line 1253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void call_and_disable_all_10(int state ) 
{ 


  {
#line 1255
  if (ldv_work_10_0 == state) {
#line 1256
    call_and_disable_work_10(ldv_work_struct_10_0);
  } else {

  }
#line 1257
  if (ldv_work_10_1 == state) {
#line 1258
    call_and_disable_work_10(ldv_work_struct_10_1);
  } else {

  }
#line 1259
  if (ldv_work_10_2 == state) {
#line 1260
    call_and_disable_work_10(ldv_work_struct_10_2);
  } else {

  }
#line 1261
  if (ldv_work_10_3 == state) {
#line 1262
    call_and_disable_work_10(ldv_work_struct_10_3);
  } else {

  }
#line 1263
  return;
}
}
#line 1289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
bool ldv_queue_work_on_335(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1293
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1293
  ldv_func_res = tmp;
#line 1295
  activate_work_7(ldv_func_arg3, 2);
#line 1297
  return (ldv_func_res);
}
}
#line 1300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
bool ldv_queue_delayed_work_on_336(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1304
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1304
  ldv_func_res = tmp;
#line 1306
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1308
  return (ldv_func_res);
}
}
#line 1311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
bool ldv_queue_work_on_337(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1315
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1315
  ldv_func_res = tmp;
#line 1317
  activate_work_7(ldv_func_arg3, 2);
#line 1319
  return (ldv_func_res);
}
}
#line 1322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_flush_workqueue_338(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1325
  flush_workqueue(ldv_func_arg1);
#line 1327
  call_and_disable_all_7(2);
#line 1328
  return;
}
}
#line 1330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
bool ldv_queue_delayed_work_on_339(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1334
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1334
  ldv_func_res = tmp;
#line 1336
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1338
  return (ldv_func_res);
}
}
#line 1341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_lock_340(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1344
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1346
  mutex_lock(ldv_func_arg1);
#line 1347
  return;
}
}
#line 1349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_unlock_341(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1352
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1354
  mutex_unlock(ldv_func_arg1);
#line 1355
  return;
}
}
#line 1357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_lock_342(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1360
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1362
  mutex_lock(ldv_func_arg1);
#line 1363
  return;
}
}
#line 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_mutex_trylock_343(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1369
  tmp = mutex_trylock(ldv_func_arg1);
#line 1369
  ldv_func_res = tmp;
#line 1371
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1371
  return (tmp___0);
#line 1373
  return (ldv_func_res);
}
}
#line 1376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_unlock_344(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1379
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1381
  mutex_unlock(ldv_func_arg1);
#line 1382
  return;
}
}
#line 1384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_unlock_345(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1387
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1389
  mutex_unlock(ldv_func_arg1);
#line 1390
  return;
}
}
#line 1392 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_lock_346(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1395
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1397
  mutex_lock(ldv_func_arg1);
#line 1398
  return;
}
}
#line 1400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_mod_timer_347(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 1404
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1404
  ldv_func_res = tmp;
#line 1406
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
#line 1408
  return (ldv_func_res);
}
}
#line 1411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_mod_timer_348(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 1415
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1415
  ldv_func_res = tmp;
#line 1417
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
#line 1419
  return (ldv_func_res);
}
}
#line 1422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_mod_timer_349(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 1426
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1426
  ldv_func_res = tmp;
#line 1428
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
#line 1430
  return (ldv_func_res);
}
}
#line 1433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_del_timer_sync_350(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 1437
  tmp = del_timer_sync(ldv_func_arg1);
#line 1437
  ldv_func_res = tmp;
#line 1439
  disable_suitable_timer_18(ldv_func_arg1);
#line 1441
  return (ldv_func_res);
}
}
#line 1444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_lock_351(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1447
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1449
  mutex_lock(ldv_func_arg1);
#line 1450
  return;
}
}
#line 1452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_unlock_352(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1455
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1457
  mutex_unlock(ldv_func_arg1);
#line 1458
  return;
}
}
#line 1460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_del_timer_sync_353(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
#line 1464
  tmp = del_timer_sync(ldv_func_arg1);
#line 1464
  ldv_func_res = tmp;
#line 1466
  disable_suitable_timer_18(ldv_func_arg1);
#line 1468
  return (ldv_func_res);
}
}
#line 1471 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_lock_354(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1474
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1476
  mutex_lock(ldv_func_arg1);
#line 1477
  return;
}
}
#line 1479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
void ldv_mutex_unlock_355(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1482
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1484
  mutex_unlock(ldv_func_arg1);
#line 1485
  return;
}
}
#line 1487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_del_timer_sync_356(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
#line 1491
  tmp = del_timer_sync(ldv_func_arg1);
#line 1491
  ldv_func_res = tmp;
#line 1493
  disable_suitable_timer_18(ldv_func_arg1);
#line 1495
  return (ldv_func_res);
}
}
#line 1498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_del_timer_sync_357(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 1502
  tmp = del_timer_sync(ldv_func_arg1);
#line 1502
  ldv_func_res = tmp;
#line 1504
  disable_suitable_timer_18(ldv_func_arg1);
#line 1506
  return (ldv_func_res);
}
}
#line 1509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
int ldv_del_timer_sync_358(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 1513
  tmp = del_timer_sync(ldv_func_arg1);
#line 1513
  ldv_func_res = tmp;
#line 1515
  disable_suitable_timer_18(ldv_func_arg1);
#line 1517
  return (ldv_func_res);
}
}
#line 1520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
bool ldv_cancel_work_sync_359(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  bool tmp ;

  {
#line 1524
  tmp = cancel_work_sync(ldv_func_arg1);
#line 1524
  ldv_func_res = tmp;
#line 1526
  disable_work_7(ldv_func_arg1);
#line 1528
  return (ldv_func_res);
}
}
#line 1531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
bool ldv_cancel_work_sync_360(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  bool tmp ;

  {
#line 1535
  tmp = cancel_work_sync(ldv_func_arg1);
#line 1535
  ldv_func_res = tmp;
#line 1537
  disable_work_7(ldv_func_arg1);
#line 1539
  return (ldv_func_res);
}
}
#line 1542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/tt.o.c.prepared"
bool ldv_cancel_work_sync_361(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  bool tmp ;

  {
#line 1546
  tmp = cancel_work_sync(ldv_func_arg1);
#line 1546
  ldv_func_res = tmp;
#line 1548
  disable_work_7(ldv_func_arg1);
#line 1550
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_401(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_399(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_402(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_403(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
void ldv_mutex_lock_398(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_400(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_404(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_393(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_395(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_394(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_396(struct workqueue_struct *ldv_func_arg1 ) ;
#line 367 "include/linux/gfp.h"
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 157 "include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 159
  return ((unsigned int )(((int )((unsigned short )*((u16 const   *)addr)) & (int )((unsigned short )*((u16 const   *)addr + 2U))) & (int )((unsigned short )*((u16 const   *)addr + 4U))) == 65535U);
}
}
#line 310 "include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 313
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 316
  return (fold == 0U);
}
}
#line 284 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_free_resp(struct iwl_host_cmd *cmd ) 
{ 


  {
#line 286
  free_pages(cmd->_rx_page_addr, cmd->_rx_page_order);
#line 287
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
u8 const   iwl_bcast_addr[6U] ;
#line 254 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
int iwl_scan_cancel(struct iwl_priv *priv ) ;
#line 316
void iwl_restore_stations(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
#line 320
int iwl_get_free_ucode_key_offset(struct iwl_priv *priv ) ;
#line 330
u8 iwl_prep_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx , u8 const   *addr ,
                    bool is_ap , struct ieee80211_sta *sta ) ;
#line 335
int iwl_add_sta_callback(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) ;
#line 362
int iwl_restore_default_wep_keys(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
#line 380
int iwl_update_bcast_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
#line 382
int iwl_update_bcast_stations(struct iwl_priv *priv ) ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
u8 const   iwl_bcast_addr[6U]  = {      255U,      255U,      255U,      255U, 
        255U,      255U};
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static int iwl_sta_ucode_activate(struct iwl_priv *priv , u8 sta_id ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 39
  if (debug_locks != 0) {
#line 39
    tmp = lock_is_held(& priv->sta_lock.__annonCompField17.__annonCompField16.dep_map);
#line 39
    if (tmp == 0) {
#line 39
      tmp___0 = 1;
    } else {
#line 39
      tmp___0 = 0;
    }
  } else {
#line 39
    tmp___0 = 0;
  }
#line 39
  __ret_warn_on = tmp___0;
#line 39
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 39
  if (tmp___1 != 0L) {
#line 39
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       39);
  } else {

  }
#line 39
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 41
  if ((unsigned int )sta_id > 15U) {
#line 42
    __iwl_err(priv->dev, 0, 0, "invalid sta_id %u\n", (int )sta_id);
#line 43
    return (-22);
  } else {

  }
#line 45
  if (((unsigned long )priv->stations[(int )sta_id].used & 1UL) == 0UL) {
#line 46
    __iwl_err(priv->dev, 0, 0, "ACTIVATE a non DRIVER active station id %u addr %pM\n",
              (int )sta_id, (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
  } else {

  }
#line 50
  if (((unsigned long )priv->stations[(int )sta_id].used & 2UL) != 0UL) {
#line 51
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_sta_ucode_activate", "STA id %u addr %pM already present in uCode (according to driver)\n",
              (int )sta_id, (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
  } else {
#line 56
    priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 2U);
#line 57
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_sta_ucode_activate", "Added STA id %u addr %pM to uCode\n",
              (int )sta_id, (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
  }
#line 60
  return (0);
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static int iwl_process_add_sta_resp(struct iwl_priv *priv , struct iwl_addsta_cmd *addsta ,
                                    struct iwl_rx_packet *pkt ) 
{ 
  struct iwl_add_sta_resp *add_sta_resp ;
  u8 sta_id ;
  int ret ;

  {
#line 67
  add_sta_resp = (struct iwl_add_sta_resp *)(& pkt->data);
#line 68
  sta_id = addsta->sta.sta_id;
#line 69
  ret = -5;
#line 71
  if (((int )pkt->hdr.flags & 64) != 0) {
#line 72
    __iwl_err(priv->dev, 0, 0, "Bad return from REPLY_ADD_STA (0x%08X)\n", (int )pkt->hdr.flags);
#line 74
    return (ret);
  } else {

  }
#line 77
  __iwl_dbg(priv->dev, 1U, 0, "iwl_process_add_sta_resp", "Processing response for adding station %u\n",
            (int )sta_id);
#line 80
  spin_lock_bh(& priv->sta_lock);
#line 82
  switch ((int )add_sta_resp->status) {
  case 1: 
#line 84
  __iwl_dbg(priv->dev, 1U, 0, "iwl_process_add_sta_resp", "REPLY_ADD_STA PASSED\n");
#line 85
  ret = iwl_sta_ucode_activate(priv, (int )sta_id);
#line 86
  goto ldv_52882;
  case 2: 
#line 88
  __iwl_err(priv->dev, 0, 0, "Adding station %d failed, no room in table.\n", (int )sta_id);
#line 90
  goto ldv_52882;
  case 4: 
#line 92
  __iwl_err(priv->dev, 0, 0, "Adding station %d failed, no block ack resource.\n",
            (int )sta_id);
#line 94
  goto ldv_52882;
  case 8: 
#line 96
  __iwl_err(priv->dev, 0, 0, "Attempting to modify non-existing station %d\n", (int )sta_id);
#line 98
  goto ldv_52882;
  default: 
#line 100
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_process_add_sta_resp", "Received REPLY_ADD_STA:(0x%08X)\n",
            (int )add_sta_resp->status);
#line 102
  goto ldv_52882;
  }
  ldv_52882: 
#line 105
  __iwl_dbg(priv->dev, 1U, 0, "iwl_process_add_sta_resp", "%s station id %u addr %pM\n",
            (unsigned int )priv->stations[(int )sta_id].sta.mode == 1U ? (char *)"Modified" : (char *)"Added",
            (int )sta_id, (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
#line 118
  __iwl_dbg(priv->dev, 1U, 0, "iwl_process_add_sta_resp", "%s station according to cmd buffer %pM\n",
            (unsigned int )priv->stations[(int )sta_id].sta.mode == 1U ? (char *)"Modified" : (char *)"Added",
            (u8 *)(& addsta->sta.addr));
#line 122
  spin_unlock_bh(& priv->sta_lock);
#line 124
  return (ret);
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_add_sta_callback(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  int tmp___0 ;

  {
#line 130
  tmp = rxb_addr(rxb);
#line 130
  pkt = (struct iwl_rx_packet *)tmp;
#line 132
  if ((unsigned long )cmd == (unsigned long )((struct iwl_device_cmd *)0)) {
#line 133
    return (0);
  } else {

  }
#line 135
  tmp___0 = iwl_process_add_sta_resp(priv, (struct iwl_addsta_cmd *)(& cmd->payload),
                                     pkt);
#line 135
  return (tmp___0);
}
}
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_send_add_sta(struct iwl_priv *priv , struct iwl_addsta_cmd *sta , u8 flags ) 
{ 
  int ret ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  u8 sta_id ;

  {
#line 141
  ret = 0;
#line 142
  cmd.data[0] = (void const   *)sta;
#line 142
  tmp = 1U;
#line 142
  while (1) {
#line 142
    if (tmp >= 2U) {
#line 142
      break;
    } else {

    }
#line 142
    cmd.data[tmp] = 0;
#line 142
    tmp = tmp + 1U;
  }
#line 142
  cmd.resp_pkt = 0;
#line 142
  cmd._rx_page_addr = 0UL;
#line 142
  cmd._rx_page_order = 0U;
#line 142
  cmd.handler_status = 0;
#line 142
  cmd.flags = (unsigned int )flags;
#line 142
  cmd.len[0] = 92U;
#line 142
  tmp___0 = 1U;
#line 142
  while (1) {
#line 142
    if (tmp___0 >= 2U) {
#line 142
      break;
    } else {

    }
#line 142
    cmd.len[tmp___0] = (unsigned short)0;
#line 142
    tmp___0 = tmp___0 + 1U;
  }
#line 142
  cmd.dataflags[0] = (unsigned char)0;
#line 142
  cmd.dataflags[1] = (unsigned char)0;
#line 142
  cmd.id = 24U;
#line 148
  sta_id = sta->sta.sta_id;
#line 150
  __iwl_dbg(priv->dev, 1U, 0, "iwl_send_add_sta", "Adding sta %u (%pM) %ssynchronously\n",
            (int )sta_id, (u8 *)(& sta->sta.addr), (int )flags & 1 ? (char *)"a" : (char *)"");
#line 153
  if (((int )flags & 1) == 0) {
#line 154
    cmd.flags = cmd.flags | 2U;
#line 155
    __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                  155, 0);
  } else {

  }
#line 158
  ret = iwl_dvm_send_cmd(priv, & cmd);
#line 160
  if (ret != 0 || (int )flags & 1) {
#line 161
    return (ret);
  } else {

  }
#line 165
  iwl_free_resp(& cmd);
#line 167
  if (cmd.handler_status != 0) {
#line 168
    __iwl_err(priv->dev, 0, 0, "%s - error in the CMD response %d\n", "iwl_send_add_sta",
              cmd.handler_status);
  } else {

  }
#line 171
  return (cmd.handler_status);
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
bool iwl_is_ht40_tx_allowed(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct ieee80211_sta *sta ) 
{ 


  {
#line 178
  if (! ctx->ht.enabled || ! ctx->ht.is_40mhz) {
#line 179
    return (0);
  } else {

  }
#line 182
  if ((int )priv->disable_ht40) {
#line 183
    return (0);
  } else {

  }
#line 187
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) {
#line 188
    return (1);
  } else {

  }
#line 190
  return ((unsigned int )sta->bandwidth != 0U);
}
}
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static void iwl_sta_calc_ht_flags(struct iwl_priv *priv , struct ieee80211_sta *sta ,
                                  struct iwl_rxon_context *ctx , __le32 *flags , __le32 *mask ) 
{ 
  struct ieee80211_sta_ht_cap *sta_ht_inf ;
  bool tmp ;

  {
#line 198
  sta_ht_inf = & sta->ht_cap;
#line 200
  *mask = 66715648U;
#line 205
  *flags = 0U;
#line 207
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0) || ! sta_ht_inf->ht_supported) {
#line 208
    return;
  } else {

  }
#line 210
  __iwl_dbg(priv->dev, 1U, 0, "iwl_sta_calc_ht_flags", "STA %pM SM PS mode: %s\n",
            (u8 *)(& sta->addr), (unsigned int )sta->smps_mode != 2U ? ((unsigned int )sta->smps_mode == 3U ? (char *)"dynamic" : (char *)"disabled") : (char *)"static");
#line 217
  switch ((unsigned int )sta->smps_mode) {
  case 2U: 
#line 219
  *flags = *flags | 4194304U;
#line 220
  goto ldv_52917;
  case 3U: 
#line 222
  *flags = *flags | 131072U;
#line 223
  goto ldv_52917;
  case 1U: ;
#line 225
  goto ldv_52917;
  default: 
#line 227
  __iwl_warn(priv->dev, "Invalid MIMO PS mode %d\n", (unsigned int )sta->smps_mode);
#line 228
  goto ldv_52917;
  }
  ldv_52917: 
#line 231
  *flags = *flags | ((unsigned int )sta_ht_inf->ampdu_factor << 19);
#line 234
  *flags = *flags | ((unsigned int )sta_ht_inf->ampdu_density << 23);
#line 237
  tmp = iwl_is_ht40_tx_allowed(priv, ctx, sta);
#line 237
  if ((int )tmp) {
#line 238
    *flags = *flags | 2097152U;
  } else {

  }
#line 239
  return;
}
}
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_sta_update_ht(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct ieee80211_sta *sta ) 
{ 
  u8 sta_id ;
  int tmp ;
  __le32 flags ;
  __le32 mask ;
  struct iwl_addsta_cmd cmd ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 244
  tmp = iwl_sta_id(sta);
#line 244
  sta_id = (u8 )tmp;
#line 248
  __ret_warn_once = (unsigned int )sta_id == 255U;
#line 248
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 248
  if (tmp___2 != 0L) {
#line 248
    __ret_warn_on = ! __warned;
#line 248
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 248
    if (tmp___0 != 0L) {
#line 248
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                         248);
    } else {

    }
#line 248
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 248
    if (tmp___1 != 0L) {
#line 248
      __warned = 1;
    } else {

    }
  } else {

  }
#line 248
  tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 248
  if (tmp___3 != 0L) {
#line 249
    return (-22);
  } else {

  }
#line 251
  iwl_sta_calc_ht_flags(priv, sta, ctx, & flags, & mask);
#line 253
  spin_lock_bh(& priv->sta_lock);
#line 254
  priv->stations[(int )sta_id].sta.station_flags = priv->stations[(int )sta_id].sta.station_flags & ~ mask;
#line 255
  priv->stations[(int )sta_id].sta.station_flags = priv->stations[(int )sta_id].sta.station_flags | flags;
#line 256
  spin_unlock_bh(& priv->sta_lock);
#line 258
  memset((void *)(& cmd), 0, 92UL);
#line 259
  cmd.mode = 1U;
#line 260
  cmd.station_flags_msk = mask;
#line 261
  cmd.station_flags = flags;
#line 262
  cmd.sta.sta_id = sta_id;
#line 264
  tmp___4 = iwl_send_add_sta(priv, & cmd, 0);
#line 264
  return (tmp___4);
}
}
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static void iwl_set_ht_add_station(struct iwl_priv *priv , u8 index , struct ieee80211_sta *sta ,
                                   struct iwl_rxon_context *ctx ) 
{ 
  __le32 flags ;
  __le32 mask ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 273
  iwl_sta_calc_ht_flags(priv, sta, ctx, & flags, & mask);
#line 275
  if (debug_locks != 0) {
#line 275
    tmp = lock_is_held(& priv->sta_lock.__annonCompField17.__annonCompField16.dep_map);
#line 275
    if (tmp == 0) {
#line 275
      tmp___0 = 1;
    } else {
#line 275
      tmp___0 = 0;
    }
  } else {
#line 275
    tmp___0 = 0;
  }
#line 275
  __ret_warn_on = tmp___0;
#line 275
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 275
  if (tmp___1 != 0L) {
#line 275
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       275);
  } else {

  }
#line 275
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 276
  priv->stations[(int )index].sta.station_flags = priv->stations[(int )index].sta.station_flags & ~ mask;
#line 277
  priv->stations[(int )index].sta.station_flags = priv->stations[(int )index].sta.station_flags | flags;
#line 278
  return;
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
u8 iwl_prep_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx , u8 const   *addr ,
                    bool is_ap , struct ieee80211_sta *sta ) 
{ 
  struct iwl_station_entry *station ;
  int i ;
  u8 sta_id ;
  bool tmp ;
  bool tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct iwl_station_priv *sta_priv ;

  {
#line 290
  sta_id = 255U;
#line 292
  if ((int )is_ap) {
#line 293
    sta_id = ctx->ap_sta_id;
  } else {
#line 294
    tmp___0 = is_broadcast_ether_addr(addr);
#line 294
    if ((int )tmp___0) {
#line 295
      sta_id = ctx->bcast_sta_id;
    } else {
#line 297
      i = 2;
#line 297
      goto ldv_52957;
      ldv_52956: 
#line 298
      tmp = ether_addr_equal((u8 const   *)(& priv->stations[i].sta.sta.addr), addr);
#line 298
      if ((int )tmp) {
#line 300
        sta_id = (u8 )i;
#line 301
        goto ldv_52955;
      } else {

      }
#line 304
      if ((unsigned int )priv->stations[i].used == 0U && (unsigned int )sta_id == 255U) {
#line 306
        sta_id = (u8 )i;
      } else {

      }
#line 297
      i = i + 1;
      ldv_52957: ;
#line 297
      if (i <= 15) {
#line 299
        goto ldv_52956;
      } else {

      }
      ldv_52955: ;
    }
  }
#line 313
  tmp___1 = ldv__builtin_expect((unsigned int )sta_id == 255U, 0L);
#line 313
  if (tmp___1 != 0L) {
#line 314
    return (sta_id);
  } else {

  }
#line 321
  if (((unsigned long )priv->stations[(int )sta_id].used & 4UL) != 0UL) {
#line 322
    __iwl_dbg(priv->dev, 1U, 0, "iwl_prep_station", "STA %d already in process of being added.\n",
              (int )sta_id);
#line 324
    return (sta_id);
  } else {

  }
#line 327
  if ((int )priv->stations[(int )sta_id].used & 1 && ((unsigned long )priv->stations[(int )sta_id].used & 2UL) != 0UL) {
#line 327
    tmp___2 = ether_addr_equal((u8 const   *)(& priv->stations[(int )sta_id].sta.sta.addr),
                               addr);
#line 327
    if ((int )tmp___2) {
#line 330
      __iwl_dbg(priv->dev, 4097U, 0, "iwl_prep_station", "STA %d (%pM) already added, not adding again.\n",
                (int )sta_id, addr);
#line 332
      return (sta_id);
    } else {

    }
  } else {

  }
#line 335
  station = (struct iwl_station_entry *)(& priv->stations) + (unsigned long )sta_id;
#line 336
  station->used = 1U;
#line 337
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_prep_station", "Add STA to driver ID %d: %pM\n",
            (int )sta_id, addr);
#line 339
  priv->num_stations = priv->num_stations + 1;
#line 342
  memset((void *)(& station->sta), 0, 92UL);
#line 343
  memcpy((void *)(& station->sta.sta.addr), (void const   *)addr, 6UL);
#line 344
  station->sta.mode = 0U;
#line 345
  station->sta.sta.sta_id = sta_id;
#line 346
  station->sta.station_flags = ctx->station_flags;
#line 347
  station->ctxid = (u8 )ctx->ctxid;
#line 349
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
#line 352
    sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
#line 353
    sta_priv->ctx = ctx;
  } else {

  }
#line 361
  iwl_set_ht_add_station(priv, (int )sta_id, sta, ctx);
#line 363
  return (sta_id);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_add_station_common(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                           u8 const   *addr , bool is_ap , struct ieee80211_sta *sta ,
                           u8 *sta_id_r ) 
{ 
  int ret ;
  u8 sta_id ;
  struct iwl_addsta_cmd sta_cmd ;

  {
#line 376
  ret = 0;
#line 380
  *sta_id_r = 0U;
#line 381
  spin_lock_bh(& priv->sta_lock);
#line 382
  sta_id = iwl_prep_station(priv, ctx, addr, (int )is_ap, sta);
#line 383
  if ((unsigned int )sta_id == 255U) {
#line 384
    __iwl_err(priv->dev, 0, 0, "Unable to prepare station %pM for addition\n", addr);
#line 386
    spin_unlock_bh(& priv->sta_lock);
#line 387
    return (-22);
  } else {

  }
#line 395
  if (((unsigned long )priv->stations[(int )sta_id].used & 4UL) != 0UL) {
#line 396
    __iwl_dbg(priv->dev, 1U, 0, "iwl_add_station_common", "STA %d already in process of being added.\n",
              (int )sta_id);
#line 398
    spin_unlock_bh(& priv->sta_lock);
#line 399
    return (-17);
  } else {

  }
#line 402
  if ((int )priv->stations[(int )sta_id].used & 1 && ((unsigned long )priv->stations[(int )sta_id].used & 2UL) != 0UL) {
#line 404
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_add_station_common", "STA %d (%pM) already added, not adding again.\n",
              (int )sta_id, addr);
#line 406
    spin_unlock_bh(& priv->sta_lock);
#line 407
    return (-17);
  } else {

  }
#line 410
  priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 4U);
#line 411
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[(int )sta_id].sta),
           92UL);
#line 413
  spin_unlock_bh(& priv->sta_lock);
#line 416
  ret = iwl_send_add_sta(priv, & sta_cmd, 0);
#line 417
  if (ret != 0) {
#line 418
    spin_lock_bh(& priv->sta_lock);
#line 419
    __iwl_err(priv->dev, 0, 0, "Adding station %pM failed.\n", (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
#line 421
    priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 254U;
#line 422
    priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 251U;
#line 423
    spin_unlock_bh(& priv->sta_lock);
  } else {

  }
#line 425
  *sta_id_r = sta_id;
#line 426
  return (ret);
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static void iwl_sta_ucode_deactivate(struct iwl_priv *priv , u8 sta_id ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 434
  if (debug_locks != 0) {
#line 434
    tmp = lock_is_held(& priv->sta_lock.__annonCompField17.__annonCompField16.dep_map);
#line 434
    if (tmp == 0) {
#line 434
      tmp___0 = 1;
    } else {
#line 434
      tmp___0 = 0;
    }
  } else {
#line 434
    tmp___0 = 0;
  }
#line 434
  __ret_warn_on = tmp___0;
#line 434
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 434
  if (tmp___1 != 0L) {
#line 434
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       434);
  } else {

  }
#line 434
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 437
  if (((unsigned long )priv->stations[(int )sta_id].used & 3UL) != 2UL) {
#line 440
    __iwl_err(priv->dev, 0, 0, "removed non active STA %u\n", (int )sta_id);
  } else {

  }
#line 442
  priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 253U;
#line 444
  memset((void *)(& priv->stations) + (unsigned long )sta_id, 0, 104UL);
#line 445
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_sta_ucode_deactivate", "Removed STA %u\n", (int )sta_id);
#line 446
  return;
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static int iwl_send_remove_station(struct iwl_priv *priv , u8 const   *addr , int sta_id ,
                                   bool temporary ) 
{ 
  struct iwl_rx_packet *pkt ;
  int ret ;
  struct iwl_rem_sta_cmd rm_sta_cmd ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  struct iwl_rem_sta_resp *rem_sta_resp ;

  {
#line 456
  cmd.data[0] = (void const   *)(& rm_sta_cmd);
#line 456
  tmp = 1U;
#line 456
  while (1) {
#line 456
    if (tmp >= 2U) {
#line 456
      break;
    } else {

    }
#line 456
    cmd.data[tmp] = 0;
#line 456
    tmp = tmp + 1U;
  }
#line 456
  cmd.resp_pkt = 0;
#line 456
  cmd._rx_page_addr = 0UL;
#line 456
  cmd._rx_page_order = 0U;
#line 456
  cmd.handler_status = 0;
#line 456
  cmd.flags = 0U;
#line 456
  cmd.len[0] = 12U;
#line 456
  tmp___0 = 1U;
#line 456
  while (1) {
#line 456
    if (tmp___0 >= 2U) {
#line 456
      break;
    } else {

    }
#line 456
    cmd.len[tmp___0] = (unsigned short)0;
#line 456
    tmp___0 = tmp___0 + 1U;
  }
#line 456
  cmd.dataflags[0] = (unsigned char)0;
#line 456
  cmd.dataflags[1] = (unsigned char)0;
#line 456
  cmd.id = 25U;
#line 462
  memset((void *)(& rm_sta_cmd), 0, 12UL);
#line 463
  rm_sta_cmd.num_sta = 1U;
#line 464
  memcpy((void *)(& rm_sta_cmd.addr), (void const   *)addr, 6UL);
#line 466
  cmd.flags = cmd.flags | 2U;
#line 468
  ret = iwl_dvm_send_cmd(priv, & cmd);
#line 470
  if (ret != 0) {
#line 471
    return (ret);
  } else {

  }
#line 473
  pkt = cmd.resp_pkt;
#line 474
  if (((int )pkt->hdr.flags & 64) != 0) {
#line 475
    __iwl_err(priv->dev, 0, 0, "Bad return from REPLY_REMOVE_STA (0x%08X)\n", (int )pkt->hdr.flags);
#line 477
    ret = -5;
  } else {

  }
#line 480
  if (ret == 0) {
#line 481
    rem_sta_resp = (struct iwl_rem_sta_resp *)(& pkt->data);
#line 482
    switch ((int )rem_sta_resp->status) {
    case 1: ;
#line 484
    if (! temporary) {
#line 485
      spin_lock_bh(& priv->sta_lock);
#line 486
      iwl_sta_ucode_deactivate(priv, (int )((u8 )sta_id));
#line 487
      spin_unlock_bh(& priv->sta_lock);
    } else {

    }
#line 489
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_send_remove_station", "REPLY_REMOVE_STA PASSED\n");
#line 490
    goto ldv_52992;
    default: 
#line 492
    ret = -5;
#line 493
    __iwl_err(priv->dev, 0, 0, "REPLY_REMOVE_STA failed\n");
#line 494
    goto ldv_52992;
    }
    ldv_52992: ;
  } else {

  }
#line 497
  iwl_free_resp(& cmd);
#line 499
  return (ret);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_remove_station(struct iwl_priv *priv , u8 const   sta_id , u8 const   *addr ) 
{ 
  u8 tid ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 510
  tmp = iwl_is_ready(priv);
#line 510
  if (tmp == 0) {
#line 511
    __iwl_dbg(priv->dev, 1U, 0, "iwl_remove_station", "Unable to remove station %pM, device not ready.\n",
              addr);
#line 519
    return (0);
  } else {

  }
#line 522
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_remove_station", "Removing STA from driver:%d  %pM\n",
            (int )sta_id, addr);
#line 525
  __ret_warn_on = (unsigned int )((unsigned char )sta_id) == 255U;
#line 525
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 525
  if (tmp___0 != 0L) {
#line 525
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       525);
  } else {

  }
#line 525
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 525
  if (tmp___1 != 0L) {
#line 526
    return (-22);
  } else {

  }
#line 528
  spin_lock_bh(& priv->sta_lock);
#line 530
  if (((unsigned long )priv->stations[(int )sta_id].used & 1UL) == 0UL) {
#line 531
    __iwl_dbg(priv->dev, 1U, 0, "iwl_remove_station", "Removing %pM but non DRIVER active\n",
              addr);
#line 533
    goto out_err;
  } else {

  }
#line 536
  if (((unsigned long )priv->stations[(int )sta_id].used & 2UL) == 0UL) {
#line 537
    __iwl_dbg(priv->dev, 1U, 0, "iwl_remove_station", "Removing %pM but non UCODE active\n",
              addr);
#line 539
    goto out_err;
  } else {

  }
#line 542
  if (((unsigned long )priv->stations[(int )sta_id].used & 8UL) != 0UL) {
#line 543
    kfree((void const   *)priv->stations[(int )sta_id].lq);
#line 544
    priv->stations[(int )sta_id].lq = (struct iwl_link_quality_cmd *)0;
  } else {

  }
#line 547
  tid = 0U;
#line 547
  goto ldv_53005;
  ldv_53004: 
#line 548
  memset((void *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid),
           0, 20UL);
#line 547
  tid = (u8 )((int )tid + 1);
  ldv_53005: ;
#line 547
  if ((unsigned int )tid <= 7U) {
#line 549
    goto ldv_53004;
  } else {

  }
#line 551
  priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 254U;
#line 553
  priv->num_stations = priv->num_stations - 1;
#line 555
  __ret_warn_on___0 = priv->num_stations < 0;
#line 555
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 555
  if (tmp___2 != 0L) {
#line 555
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       555);
  } else {

  }
#line 555
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 555
  if (tmp___3 != 0L) {
#line 556
    priv->num_stations = 0;
  } else {

  }
#line 558
  spin_unlock_bh(& priv->sta_lock);
#line 560
  tmp___4 = iwl_send_remove_station(priv, addr, (int )sta_id, 0);
#line 560
  return (tmp___4);
  out_err: 
#line 562
  spin_unlock_bh(& priv->sta_lock);
#line 563
  return (-22);
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
void iwl_deactivate_station(struct iwl_priv *priv , u8 const   sta_id , u8 const   *addr ) 
{ 
  u8 tid ;
  int tmp ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  bool __warned___0 ;
  int __ret_warn_once___0 ;
  int __ret_warn_on___0 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bool __warned___1 ;
  int __ret_warn_once___1 ;
  int __ret_warn_on___1 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
#line 571
  tmp = iwl_is_ready(priv);
#line 571
  if (tmp == 0) {
#line 572
    __iwl_dbg(priv->dev, 1U, 0, "iwl_deactivate_station", "Unable to remove station %pM, device not ready.\n",
              addr);
#line 575
    return;
  } else {

  }
#line 578
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_deactivate_station", "Deactivating STA: %pM (%d)\n",
            addr, (int )sta_id);
#line 580
  __ret_warn_once = (unsigned int )((unsigned char )sta_id) == 255U;
#line 580
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 580
  if (tmp___2 != 0L) {
#line 580
    __ret_warn_on = ! __warned;
#line 580
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 580
    if (tmp___0 != 0L) {
#line 580
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                         580);
    } else {

    }
#line 580
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 580
    if (tmp___1 != 0L) {
#line 580
      __warned = 1;
    } else {

    }
  } else {

  }
#line 580
  tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 580
  if (tmp___3 != 0L) {
#line 581
    return;
  } else {

  }
#line 583
  spin_lock_bh(& priv->sta_lock);
#line 585
  __ret_warn_once___0 = ((unsigned long )priv->stations[(int )sta_id].used & 1UL) == 0UL;
#line 585
  tmp___6 = ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
#line 585
  if (tmp___6 != 0L) {
#line 585
    __ret_warn_on___0 = ! __warned___0;
#line 585
    tmp___4 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 585
    if (tmp___4 != 0L) {
#line 585
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                         585);
    } else {

    }
#line 585
    tmp___5 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 585
    if (tmp___5 != 0L) {
#line 585
      __warned___0 = 1;
    } else {

    }
  } else {

  }
#line 585
  ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
#line 587
  tid = 0U;
#line 587
  goto ldv_53027;
  ldv_53026: 
#line 588
  memset((void *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid),
           0, 20UL);
#line 587
  tid = (u8 )((int )tid + 1);
  ldv_53027: ;
#line 587
  if ((unsigned int )tid <= 7U) {
#line 589
    goto ldv_53026;
  } else {

  }
#line 591
  priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 254U;
#line 592
  priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 251U;
#line 594
  priv->num_stations = priv->num_stations - 1;
#line 596
  __ret_warn_once___1 = priv->num_stations < 0;
#line 596
  tmp___9 = ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
#line 596
  if (tmp___9 != 0L) {
#line 596
    __ret_warn_on___1 = ! __warned___1;
#line 596
    tmp___7 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 596
    if (tmp___7 != 0L) {
#line 596
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                         596);
    } else {

    }
#line 596
    tmp___8 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 596
    if (tmp___8 != 0L) {
#line 596
      __warned___1 = 1;
    } else {

    }
  } else {

  }
#line 596
  tmp___10 = ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
#line 596
  if (tmp___10 != 0L) {
#line 597
    priv->num_stations = 0;
  } else {

  }
#line 599
  spin_unlock_bh(& priv->sta_lock);
#line 600
  return;
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static void iwl_sta_fill_lq(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            u8 sta_id , struct iwl_link_quality_cmd *link_cmd ) 
{ 
  int i ;
  int r ;
  u32 rate_flags ;
  __le32 rate_n_flags ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;

  {
#line 606
  rate_flags = 0U;
#line 609
  if (debug_locks != 0) {
#line 609
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 609
    if (tmp == 0) {
#line 609
      tmp___0 = 1;
    } else {
#line 609
      tmp___0 = 0;
    }
  } else {
#line 609
    tmp___0 = 0;
  }
#line 609
  __ret_warn_on = tmp___0;
#line 609
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 609
  if (tmp___1 != 0L) {
#line 609
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       609);
  } else {

  }
#line 609
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 611
  memset((void *)link_cmd, 0, 88UL);
#line 615
  if ((unsigned int )priv->band == 1U) {
#line 616
    r = 4;
  } else
#line 617
  if (((unsigned long )ctx != (unsigned long )((struct iwl_rxon_context *)0) && (unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) && (int )(ctx->vif)->p2p) {
#line 618
    r = 4;
  } else {
#line 620
    r = 0;
  }
#line 622
  if (r >= 0 && r <= 3) {
#line 623
    rate_flags = rate_flags | 512U;
  } else {

  }
#line 625
  tmp___2 = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 625
  rate_flags = (u32 )((int )tmp___2 << 14) | rate_flags;
#line 627
  rate_n_flags = iwl_hw_set_rate_n_flags((int )iwl_rates[r].plcp, rate_flags);
#line 628
  i = 0;
#line 628
  goto ldv_53047;
  ldv_53046: 
#line 629
  link_cmd->rs_table[i].rate_n_flags = rate_n_flags;
#line 628
  i = i + 1;
  ldv_53047: ;
#line 628
  if (i <= 15) {
#line 630
    goto ldv_53046;
  } else {

  }
#line 631
  link_cmd->general_params.single_stream_ant_msk = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 634
  tmp___3 = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
#line 634
  link_cmd->general_params.dual_stream_ant_msk = (u8 )((int )((signed char )(priv->nvm_data)->valid_tx_ant) & ~ ((int )((signed char )tmp___3)));
#line 637
  if ((unsigned int )link_cmd->general_params.dual_stream_ant_msk == 0U) {
#line 638
    link_cmd->general_params.dual_stream_ant_msk = 3U;
  } else {
#line 639
    tmp___4 = num_of_ant((int )(priv->nvm_data)->valid_tx_ant);
#line 639
    if ((unsigned int )tmp___4 == 2U) {
#line 640
      link_cmd->general_params.dual_stream_ant_msk = (priv->nvm_data)->valid_tx_ant;
    } else {

    }
  }
#line 644
  link_cmd->agg_params.agg_dis_start_th = 3U;
#line 646
  link_cmd->agg_params.agg_time_limit = 4000U;
#line 649
  link_cmd->sta_id = sta_id;
#line 650
  return;
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
void iwl_clear_ucode_stations(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int i ;
  bool cleared ;

  {
#line 664
  cleared = 0;
#line 666
  __iwl_dbg(priv->dev, 1U, 0, "iwl_clear_ucode_stations", "Clearing ucode stations in driver\n");
#line 668
  spin_lock_bh(& priv->sta_lock);
#line 669
  i = 0;
#line 669
  goto ldv_53058;
  ldv_53057: ;
#line 670
  if ((unsigned long )ctx != (unsigned long )((struct iwl_rxon_context *)0) && (unsigned int )ctx->ctxid != (unsigned int )priv->stations[i].ctxid) {
#line 671
    goto ldv_53056;
  } else {

  }
#line 673
  if (((unsigned long )priv->stations[i].used & 2UL) != 0UL) {
#line 674
    __iwl_dbg(priv->dev, 1U, 0, "iwl_clear_ucode_stations", "Clearing ucode active for station %d\n",
              i);
#line 676
    priv->stations[i].used = (unsigned int )priv->stations[i].used & 253U;
#line 677
    cleared = 1;
  } else {

  }
  ldv_53056: 
#line 669
  i = i + 1;
  ldv_53058: ;
#line 669
  if (i <= 15) {
#line 671
    goto ldv_53057;
  } else {

  }
#line 680
  spin_unlock_bh(& priv->sta_lock);
#line 682
  if (! cleared) {
#line 683
    __iwl_dbg(priv->dev, 1U, 0, "iwl_clear_ucode_stations", "No active stations found to be cleared\n");
  } else {

  }
#line 684
  return;
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
void iwl_restore_stations(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_addsta_cmd sta_cmd ;
  struct iwl_link_quality_cmd zero_lq ;
  struct iwl_link_quality_cmd lq ;
  int i ;
  bool found ;
  int ret ;
  bool send_lq ;
  int tmp ;
  int tmp___0 ;

  {
#line 698
  zero_lq.sta_id = (unsigned char)0;
#line 698
  zero_lq.reserved1 = (unsigned char)0;
#line 698
  zero_lq.control = (unsigned short)0;
#line 698
  zero_lq.general_params.flags = (unsigned char)0;
#line 698
  zero_lq.general_params.mimo_delimiter = (unsigned char)0;
#line 698
  zero_lq.general_params.single_stream_ant_msk = (unsigned char)0;
#line 698
  zero_lq.general_params.dual_stream_ant_msk = (unsigned char)0;
#line 698
  zero_lq.general_params.start_rate_index[0] = (unsigned char)0;
#line 698
  zero_lq.general_params.start_rate_index[1] = (unsigned char)0;
#line 698
  zero_lq.general_params.start_rate_index[2] = (unsigned char)0;
#line 698
  zero_lq.general_params.start_rate_index[3] = (unsigned char)0;
#line 698
  zero_lq.agg_params.agg_time_limit = (unsigned short)0;
#line 698
  zero_lq.agg_params.agg_dis_start_th = (unsigned char)0;
#line 698
  zero_lq.agg_params.agg_frame_cnt_limit = (unsigned char)0;
#line 698
  zero_lq.agg_params.reserved = 0U;
#line 698
  zero_lq.rs_table[0].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[1].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[2].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[3].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[4].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[5].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[6].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[7].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[8].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[9].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[10].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[11].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[12].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[13].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[14].rate_n_flags = 0U;
#line 698
  zero_lq.rs_table[15].rate_n_flags = 0U;
#line 698
  zero_lq.reserved2 = 0U;
#line 701
  found = 0;
#line 705
  tmp = iwl_is_ready(priv);
#line 705
  if (tmp == 0) {
#line 706
    __iwl_dbg(priv->dev, 1U, 0, "iwl_restore_stations", "Not ready yet, not restoring any stations.\n");
#line 708
    return;
  } else {

  }
#line 711
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_restore_stations", "Restoring all known stations ... start.\n");
#line 712
  spin_lock_bh(& priv->sta_lock);
#line 713
  i = 0;
#line 713
  goto ldv_53074;
  ldv_53073: ;
#line 714
  if ((unsigned int )ctx->ctxid != (unsigned int )priv->stations[i].ctxid) {
#line 715
    goto ldv_53072;
  } else {

  }
#line 716
  if ((int )priv->stations[i].used & 1 && ((unsigned long )priv->stations[i].used & 2UL) == 0UL) {
#line 718
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_restore_stations", "Restoring sta %pM\n",
              (u8 *)(& priv->stations[i].sta.sta.addr));
#line 720
    priv->stations[i].sta.mode = 0U;
#line 721
    priv->stations[i].used = (u8 )((unsigned int )priv->stations[i].used | 4U);
#line 722
    found = 1;
  } else {

  }
  ldv_53072: 
#line 713
  i = i + 1;
  ldv_53074: ;
#line 713
  if (i <= 15) {
#line 715
    goto ldv_53073;
  } else {

  }
#line 726
  i = 0;
#line 726
  goto ldv_53078;
  ldv_53077: ;
#line 727
  if (((unsigned long )priv->stations[i].used & 4UL) != 0UL) {
#line 728
    memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[i].sta), 92UL);
#line 730
    send_lq = 0;
#line 731
    if ((unsigned long )priv->stations[i].lq != (unsigned long )((struct iwl_link_quality_cmd *)0)) {
#line 732
      if ((int )priv->wowlan) {
#line 733
        iwl_sta_fill_lq(priv, ctx, (int )((u8 )i), & lq);
      } else {
#line 735
        memcpy((void *)(& lq), (void const   *)priv->stations[i].lq, 88UL);
      }
#line 738
      tmp___0 = memcmp((void const   *)(& lq), (void const   *)(& zero_lq), 88UL);
#line 738
      if (tmp___0 != 0) {
#line 739
        send_lq = 1;
      } else {

      }
    } else {

    }
#line 741
    spin_unlock_bh(& priv->sta_lock);
#line 742
    ret = iwl_send_add_sta(priv, & sta_cmd, 0);
#line 743
    if (ret != 0) {
#line 744
      spin_lock_bh(& priv->sta_lock);
#line 745
      __iwl_err(priv->dev, 0, 0, "Adding station %pM failed.\n", (u8 *)(& priv->stations[i].sta.sta.addr));
#line 747
      priv->stations[i].used = (unsigned int )priv->stations[i].used & 254U;
#line 749
      priv->stations[i].used = (unsigned int )priv->stations[i].used & 251U;
#line 751
      goto ldv_53076;
    } else {

    }
#line 757
    if ((int )send_lq) {
#line 758
      iwl_send_lq_cmd(priv, ctx, & lq, 0, 1);
    } else {

    }
#line 759
    spin_lock_bh(& priv->sta_lock);
#line 760
    priv->stations[i].used = (unsigned int )priv->stations[i].used & 251U;
  } else {

  }
  ldv_53076: 
#line 726
  i = i + 1;
  ldv_53078: ;
#line 726
  if (i <= 15) {
#line 728
    goto ldv_53077;
  } else {

  }
#line 764
  spin_unlock_bh(& priv->sta_lock);
#line 765
  if (! found) {
#line 766
    __iwl_dbg(priv->dev, 1U, 0, "iwl_restore_stations", "Restoring all known stations .... no stations to be restored.\n");
  } else {
#line 769
    __iwl_dbg(priv->dev, 1U, 0, "iwl_restore_stations", "Restoring all known stations .... complete.\n");
  }
#line 770
  return;
}
}
#line 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_get_free_ucode_key_offset(struct iwl_priv *priv ) 
{ 
  int i ;
  int tmp ;

  {
#line 777
  i = 0;
#line 777
  goto ldv_53085;
  ldv_53084: 
#line 778
  tmp = test_and_set_bit((long )i, (unsigned long volatile   *)(& priv->ucode_key_table));
#line 778
  if (tmp == 0) {
#line 779
    return (i);
  } else {

  }
#line 777
  i = i + 1;
  ldv_53085: ;
#line 777
  if ((int )priv->sta_key_max_num > i) {
#line 779
    goto ldv_53084;
  } else {

  }

#line 781
  return (255);
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
void iwl_dealloc_bcast_stations(struct iwl_priv *priv ) 
{ 
  int i ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
#line 788
  spin_lock_bh(& priv->sta_lock);
#line 789
  i = 0;
#line 789
  goto ldv_53095;
  ldv_53094: ;
#line 790
  if (((unsigned long )priv->stations[i].used & 16UL) == 0UL) {
#line 791
    goto ldv_53091;
  } else {

  }
#line 793
  priv->stations[i].used = (unsigned int )priv->stations[i].used & 253U;
#line 794
  priv->num_stations = priv->num_stations - 1;
#line 795
  __ret_warn_on = priv->num_stations < 0;
#line 795
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 795
  if (tmp != 0L) {
#line 795
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       795);
  } else {

  }
#line 795
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 795
  if (tmp___0 != 0L) {
#line 796
    priv->num_stations = 0;
  } else {

  }
#line 797
  kfree((void const   *)priv->stations[i].lq);
#line 798
  priv->stations[i].lq = (struct iwl_link_quality_cmd *)0;
  ldv_53091: 
#line 789
  i = i + 1;
  ldv_53095: ;
#line 789
  if (i <= 15) {
#line 791
    goto ldv_53094;
  } else {

  }
#line 800
  spin_unlock_bh(& priv->sta_lock);
#line 801
  return;
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static void iwl_dump_lq_cmd(struct iwl_priv *priv , struct iwl_link_quality_cmd *lq ) 
{ 
  int i ;

  {
#line 808
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_dump_lq_cmd", "lq station id 0x%x\n", (int )lq->sta_id);
#line 809
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_dump_lq_cmd", "lq ant 0x%X 0x%X\n", (int )lq->general_params.single_stream_ant_msk,
            (int )lq->general_params.dual_stream_ant_msk);
#line 813
  i = 0;
#line 813
  goto ldv_53104;
  ldv_53103: 
#line 814
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_dump_lq_cmd", "lq index %d 0x%X\n", i, lq->rs_table[i].rate_n_flags);
#line 813
  i = i + 1;
  ldv_53104: ;
#line 813
  if (i <= 15) {
#line 815
    goto ldv_53103;
  } else {

  }

#line 820
  return;
}
}
#line 835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static bool is_lq_table_valid(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                              struct iwl_link_quality_cmd *lq ) 
{ 
  int i ;

  {
#line 841
  if ((int )ctx->ht.enabled) {
#line 842
    return (1);
  } else {

  }
#line 844
  __iwl_dbg(priv->dev, 1U, 0, "is_lq_table_valid", "Channel %u is not an HT channel\n",
            (int )ctx->active.channel);
#line 846
  i = 0;
#line 846
  goto ldv_53114;
  ldv_53113: ;
#line 847
  if ((lq->rs_table[i].rate_n_flags & 256U) != 0U) {
#line 849
    __iwl_dbg(priv->dev, 1U, 0, "is_lq_table_valid", "index %d of LQ expects HT channel\n",
              i);
#line 852
    return (0);
  } else {

  }
#line 846
  i = i + 1;
  ldv_53114: ;
#line 846
  if (i <= 15) {
#line 848
    goto ldv_53113;
  } else {

  }

#line 855
  return (1);
}
}
#line 868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_send_lq_cmd(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct iwl_link_quality_cmd *lq ,
                    u8 flags , bool init ) 
{ 
  int ret ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on___0 ;
  long tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;

  {
#line 871
  ret = 0;
#line 872
  cmd.data[0] = (void const   *)lq;
#line 872
  tmp = 1U;
#line 872
  while (1) {
#line 872
    if (tmp >= 2U) {
#line 872
      break;
    } else {

    }
#line 872
    cmd.data[tmp] = 0;
#line 872
    tmp = tmp + 1U;
  }
#line 872
  cmd.resp_pkt = 0;
#line 872
  cmd._rx_page_addr = 0UL;
#line 872
  cmd._rx_page_order = 0U;
#line 872
  cmd.handler_status = 0;
#line 872
  cmd.flags = (unsigned int )flags;
#line 872
  cmd.len[0] = 88U;
#line 872
  tmp___0 = 1U;
#line 872
  while (1) {
#line 872
    if (tmp___0 >= 2U) {
#line 872
      break;
    } else {

    }
#line 872
    cmd.len[tmp___0] = (unsigned short)0;
#line 872
    tmp___0 = tmp___0 + 1U;
  }
#line 872
  cmd.dataflags[0] = (unsigned char)0;
#line 872
  cmd.dataflags[1] = (unsigned char)0;
#line 872
  cmd.id = 78U;
#line 879
  __ret_warn_on = (unsigned int )lq->sta_id == 255U;
#line 879
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 879
  if (tmp___1 != 0L) {
#line 879
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       879);
  } else {

  }
#line 879
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 879
  if (tmp___2 != 0L) {
#line 880
    return (-22);
  } else {

  }
#line 883
  spin_lock_bh(& priv->sta_lock);
#line 884
  if (((unsigned long )priv->stations[(int )lq->sta_id].used & 1UL) == 0UL) {
#line 885
    spin_unlock_bh(& priv->sta_lock);
#line 886
    return (-22);
  } else {

  }
#line 888
  spin_unlock_bh(& priv->sta_lock);
#line 890
  iwl_dump_lq_cmd(priv, lq);
#line 891
  __ret_warn_on___0 = (int )init && (int )cmd.flags & 1;
#line 891
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 891
  if (tmp___3 != 0L) {
#line 891
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       891);
  } else {

  }
#line 891
  tmp___4 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 891
  if (tmp___4 != 0L) {
#line 892
    return (-22);
  } else {

  }
#line 894
  tmp___5 = is_lq_table_valid(priv, ctx, lq);
#line 894
  if ((int )tmp___5) {
#line 895
    ret = iwl_dvm_send_cmd(priv, & cmd);
  } else {
#line 897
    ret = -22;
  }
#line 899
  if ((int )cmd.flags & 1) {
#line 900
    return (ret);
  } else {

  }
#line 902
  if ((int )init) {
#line 903
    __iwl_dbg(priv->dev, 1U, 0, "iwl_send_lq_cmd", "init LQ command complete, clearing sta addition status for sta %d\n",
              (int )lq->sta_id);
#line 906
    spin_lock_bh(& priv->sta_lock);
#line 907
    priv->stations[(int )lq->sta_id].used = (unsigned int )priv->stations[(int )lq->sta_id].used & 251U;
#line 908
    spin_unlock_bh(& priv->sta_lock);
  } else {

  }
#line 910
  return (ret);
}
}
#line 915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static struct iwl_link_quality_cmd *iwl_sta_alloc_lq(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                                     u8 sta_id ) 
{ 
  struct iwl_link_quality_cmd *link_cmd ;
  void *tmp ;

  {
#line 920
  tmp = kzalloc(88UL, 208U);
#line 920
  link_cmd = (struct iwl_link_quality_cmd *)tmp;
#line 921
  if ((unsigned long )link_cmd == (unsigned long )((struct iwl_link_quality_cmd *)0)) {
#line 922
    __iwl_err(priv->dev, 0, 0, "Unable to allocate memory for LQ cmd.\n");
#line 923
    return ((struct iwl_link_quality_cmd *)0);
  } else {

  }
#line 926
  iwl_sta_fill_lq(priv, ctx, (int )sta_id, link_cmd);
#line 928
  return (link_cmd);
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwlagn_add_bssid_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                             u8 const   *addr , u8 *sta_id_r ) 
{ 
  int ret ;
  u8 sta_id ;
  struct iwl_link_quality_cmd *link_cmd ;

  {
#line 944
  if ((unsigned long )sta_id_r != (unsigned long )((u8 *)0U)) {
#line 945
    *sta_id_r = 255U;
  } else {

  }
#line 947
  ret = iwl_add_station_common(priv, ctx, addr, 0, (struct ieee80211_sta *)0, & sta_id);
#line 948
  if (ret != 0) {
#line 949
    __iwl_err(priv->dev, 0, 0, "Unable to add station %pM\n", addr);
#line 950
    return (ret);
  } else {

  }
#line 953
  if ((unsigned long )sta_id_r != (unsigned long )((u8 *)0U)) {
#line 954
    *sta_id_r = sta_id;
  } else {

  }
#line 956
  spin_lock_bh(& priv->sta_lock);
#line 957
  priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 8U);
#line 958
  spin_unlock_bh(& priv->sta_lock);
#line 961
  link_cmd = iwl_sta_alloc_lq(priv, ctx, (int )sta_id);
#line 962
  if ((unsigned long )link_cmd == (unsigned long )((struct iwl_link_quality_cmd *)0)) {
#line 963
    __iwl_err(priv->dev, 0, 0, "Unable to initialize rate scaling for station %pM.\n",
              addr);
#line 966
    return (-12);
  } else {

  }
#line 969
  ret = iwl_send_lq_cmd(priv, ctx, link_cmd, 0, 1);
#line 970
  if (ret != 0) {
#line 971
    __iwl_err(priv->dev, 0, 0, "Link quality command failed (%d)\n", ret);
  } else {

  }
#line 973
  spin_lock_bh(& priv->sta_lock);
#line 974
  priv->stations[(int )sta_id].lq = link_cmd;
#line 975
  spin_unlock_bh(& priv->sta_lock);
#line 977
  return (0);
}
}
#line 988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static int iwl_send_static_wepkey_cmd(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                      bool send_if_empty ) 
{ 
  int i ;
  int not_empty ;
  u8 buff[100U] ;
  struct iwl_wep_cmd *wep_cmd ;
  size_t cmd_size ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 992
  not_empty = 0;
#line 995
  wep_cmd = (struct iwl_wep_cmd *)(& buff);
#line 996
  cmd_size = 4UL;
#line 997
  cmd.data[0] = (void const   *)wep_cmd;
#line 997
  tmp = 1U;
#line 997
  while (1) {
#line 997
    if (tmp >= 2U) {
#line 997
      break;
    } else {

    }
#line 997
    cmd.data[tmp] = 0;
#line 997
    tmp = tmp + 1U;
  }
#line 997
  cmd.resp_pkt = 0;
#line 997
  cmd._rx_page_addr = 0UL;
#line 997
  cmd._rx_page_order = 0U;
#line 997
  cmd.handler_status = 0;
#line 997
  cmd.flags = 0U;
#line 997
  cmd.len[0] = (unsigned short)0;
#line 997
  cmd.len[1] = (unsigned short)0;
#line 997
  cmd.dataflags[0] = (unsigned char)0;
#line 997
  cmd.dataflags[1] = (unsigned char)0;
#line 997
  cmd.id = ctx->wep_key_cmd;
#line 1002
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                1002, 0);
#line 1004
  memset((void *)wep_cmd, 0, cmd_size + 96UL);
#line 1007
  i = 0;
#line 1007
  goto ldv_53157;
  ldv_53156: 
#line 1008
  wep_cmd->key[i].key_index = (u8 )i;
#line 1009
  if ((unsigned int )ctx->wep_keys[i].key_size != 0U) {
#line 1010
    wep_cmd->key[i].key_offset = (u8 )i;
#line 1011
    not_empty = 1;
  } else {
#line 1013
    wep_cmd->key[i].key_offset = 255U;
  }
#line 1016
  wep_cmd->key[i].key_size = ctx->wep_keys[i].key_size;
#line 1017
  memcpy((void *)(& wep_cmd->key[i].key) + 3U, (void const   *)(& ctx->wep_keys[i].key),
           (size_t )ctx->wep_keys[i].key_size);
#line 1007
  i = i + 1;
  ldv_53157: ;
#line 1007
  if (i <= 3) {
#line 1009
    goto ldv_53156;
  } else {

  }
#line 1021
  wep_cmd->global_key_type = 1U;
#line 1022
  wep_cmd->num_keys = 4U;
#line 1024
  cmd_size = cmd_size + 96UL;
#line 1026
  cmd.len[0] = (u16 )cmd_size;
#line 1028
  if (not_empty != 0 || (int )send_if_empty) {
#line 1029
    tmp___0 = iwl_dvm_send_cmd(priv, & cmd);
#line 1029
    return (tmp___0);
  } else {
#line 1031
    return (0);
  }
}
}
#line 1034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_restore_default_wep_keys(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1037
  if (debug_locks != 0) {
#line 1037
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 1037
    if (tmp == 0) {
#line 1037
      tmp___0 = 1;
    } else {
#line 1037
      tmp___0 = 0;
    }
  } else {
#line 1037
    tmp___0 = 0;
  }
#line 1037
  __ret_warn_on = tmp___0;
#line 1037
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1037
  if (tmp___1 != 0L) {
#line 1037
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1037);
  } else {

  }
#line 1037
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1039
  tmp___2 = iwl_send_static_wepkey_cmd(priv, ctx, 0);
#line 1039
  return (tmp___2);
}
}
#line 1042 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_remove_default_wep_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                               struct ieee80211_key_conf *keyconf ) 
{ 
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1048
  if (debug_locks != 0) {
#line 1048
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 1048
    if (tmp == 0) {
#line 1048
      tmp___0 = 1;
    } else {
#line 1048
      tmp___0 = 0;
    }
  } else {
#line 1048
    tmp___0 = 0;
  }
#line 1048
  __ret_warn_on = tmp___0;
#line 1048
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1048
  if (tmp___1 != 0L) {
#line 1048
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1048);
  } else {

  }
#line 1048
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1050
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_remove_default_wep_key", "Removing default WEP key: idx=%d\n",
            (int )keyconf->keyidx);
#line 1053
  memset((void *)(& ctx->wep_keys) + (unsigned long )keyconf->keyidx, 0, 24UL);
#line 1054
  tmp___2 = iwl_is_rfkill(priv);
#line 1054
  if (tmp___2 != 0) {
#line 1055
    __iwl_dbg(priv->dev, 4194304U, 0, "iwl_remove_default_wep_key", "Not sending REPLY_WEPKEY command due to RFKILL.\n");
#line 1058
    return (0);
  } else {

  }
#line 1060
  ret = iwl_send_static_wepkey_cmd(priv, ctx, 1);
#line 1061
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_remove_default_wep_key", "Remove default WEP key: idx=%d ret=%d\n",
            (int )keyconf->keyidx, ret);
#line 1064
  return (ret);
}
}
#line 1067 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_set_default_wep_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct ieee80211_key_conf *keyconf ) 
{ 
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1073
  if (debug_locks != 0) {
#line 1073
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 1073
    if (tmp == 0) {
#line 1073
      tmp___0 = 1;
    } else {
#line 1073
      tmp___0 = 0;
    }
  } else {
#line 1073
    tmp___0 = 0;
  }
#line 1073
  __ret_warn_on = tmp___0;
#line 1073
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1073
  if (tmp___1 != 0L) {
#line 1073
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1073);
  } else {

  }
#line 1073
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1075
  if ((unsigned int )keyconf->keylen != 13U && (unsigned int )keyconf->keylen != 5U) {
#line 1077
    __iwl_dbg(priv->dev, 4194304U, 0, "iwl_set_default_wep_key", "Bad WEP key length %d\n",
              (int )keyconf->keylen);
#line 1079
    return (-22);
  } else {

  }
#line 1082
  keyconf->hw_key_idx = 254U;
#line 1084
  ctx->wep_keys[(int )keyconf->keyidx].key_size = keyconf->keylen;
#line 1085
  memcpy((void *)(& ctx->wep_keys[(int )keyconf->keyidx].key), (void const   *)(& keyconf->key),
           (size_t )keyconf->keylen);
#line 1088
  ret = iwl_send_static_wepkey_cmd(priv, ctx, 0);
#line 1089
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_set_default_wep_key", "Set default WEP key: len=%d idx=%d ret=%d\n",
            (int )keyconf->keylen, (int )keyconf->keyidx, ret);
#line 1092
  return (ret);
}
}
#line 1110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static u8 iwlagn_key_sta_id(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ) 
{ 
  struct iwl_vif_priv *vif_priv ;
  int tmp ;

  {
#line 1114
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
#line 1116
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
#line 1117
    tmp = iwl_sta_id(sta);
#line 1117
    return ((u8 )tmp);
  } else {

  }
#line 1124
  if ((unsigned int )vif->type == 2U && (unsigned long )vif_priv->ctx != (unsigned long )((struct iwl_rxon_context *)0)) {
#line 1125
    return ((vif_priv->ctx)->ap_sta_id);
  } else {

  }
#line 1127
  return (255U);
}
}
#line 1130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
static int iwlagn_send_sta_key(struct iwl_priv *priv , struct ieee80211_key_conf *keyconf ,
                               u8 sta_id , u32 tkip_iv32 , u16 *tkip_p1k , u32 cmd_flags ) 
{ 
  __le16 key_flags ;
  struct iwl_addsta_cmd sta_cmd ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 1139
  spin_lock_bh(& priv->sta_lock);
#line 1140
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[(int )sta_id].sta),
           92UL);
#line 1141
  spin_unlock_bh(& priv->sta_lock);
#line 1143
  key_flags = (int )((unsigned short )keyconf->keyidx) << 8U;
#line 1144
  key_flags = (__le16 )((unsigned int )key_flags | 8U);
#line 1146
  switch (keyconf->cipher) {
  case 1027076U: 
#line 1148
  key_flags = (__le16 )((unsigned int )key_flags | 2U);
#line 1149
  memcpy((void *)(& sta_cmd.key.key), (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
#line 1150
  goto ldv_53201;
  case 1027074U: 
#line 1152
  key_flags = (__le16 )((unsigned int )key_flags | 3U);
#line 1153
  sta_cmd.key.tkip_rx_tsc_byte2 = (u8 )tkip_iv32;
#line 1154
  i = 0;
#line 1154
  goto ldv_53204;
  ldv_53203: 
#line 1155
  sta_cmd.key.tkip_rx_ttak[i] = *(tkip_p1k + (unsigned long )i);
#line 1154
  i = i + 1;
  ldv_53204: ;
#line 1154
  if (i <= 4) {
#line 1156
    goto ldv_53203;
  } else {

  }
#line 1156
  memcpy((void *)(& sta_cmd.key.key), (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
#line 1157
  goto ldv_53201;
  case 1027077U: 
#line 1159
  key_flags = (__le16 )((unsigned int )key_flags | 4096U);
  case 1027073U: 
#line 1162
  key_flags = (__le16 )((unsigned int )key_flags | 1U);
#line 1163
  memcpy((void *)(& sta_cmd.key.key) + 3U, (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
#line 1164
  goto ldv_53201;
  default: 
#line 1166
  __ret_warn_on = 1;
#line 1166
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1166
  if (tmp != 0L) {
#line 1166
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1166);
  } else {

  }
#line 1166
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1167
  return (-22);
  }
  ldv_53201: ;
#line 1170
  if (((int )keyconf->flags & 8) == 0) {
#line 1171
    key_flags = (__le16 )((unsigned int )key_flags | 16384U);
  } else {

  }
#line 1174
  sta_cmd.key.key_offset = keyconf->hw_key_idx;
#line 1176
  sta_cmd.key.key_flags = key_flags;
#line 1177
  sta_cmd.mode = 1U;
#line 1178
  sta_cmd.sta.modify_mask = 1U;
#line 1180
  tmp___0 = iwl_send_add_sta(priv, & sta_cmd, (int )((u8 )cmd_flags));
#line 1180
  return (tmp___0);
}
}
#line 1183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
void iwl_update_tkip_key(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_key_conf *keyconf ,
                         struct ieee80211_sta *sta , u32 iv32 , u16 *phase1key ) 
{ 
  u8 sta_id ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 1188
  tmp = iwlagn_key_sta_id(priv, vif, sta);
#line 1188
  sta_id = tmp;
#line 1190
  if ((unsigned int )sta_id == 255U) {
#line 1191
    return;
  } else {

  }
#line 1193
  tmp___0 = iwl_scan_cancel(priv);
#line 1193
  if (tmp___0 != 0) {
#line 1196
    return;
  } else {

  }
#line 1199
  iwlagn_send_sta_key(priv, keyconf, (int )sta_id, iv32, phase1key, 1U);
#line 1200
  return;
}
}
#line 1203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_remove_dynamic_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                           struct ieee80211_key_conf *keyconf , struct ieee80211_sta *sta ) 
{ 
  struct iwl_addsta_cmd sta_cmd ;
  u8 sta_id ;
  u8 tmp ;
  __le16 key_flags ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1209
  tmp = iwlagn_key_sta_id(priv, ctx->vif, sta);
#line 1209
  sta_id = tmp;
#line 1213
  if ((unsigned int )sta_id == 255U) {
#line 1214
    return (-2);
  } else {

  }
#line 1216
  spin_lock_bh(& priv->sta_lock);
#line 1217
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[(int )sta_id].sta),
           92UL);
#line 1218
  if (((unsigned long )priv->stations[(int )sta_id].used & 2UL) == 0UL) {
#line 1219
    sta_id = 255U;
  } else {

  }
#line 1220
  spin_unlock_bh(& priv->sta_lock);
#line 1222
  if ((unsigned int )sta_id == 255U) {
#line 1223
    return (0);
  } else {

  }
#line 1225
  if (debug_locks != 0) {
#line 1225
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
#line 1225
    if (tmp___0 == 0) {
#line 1225
      tmp___1 = 1;
    } else {
#line 1225
      tmp___1 = 0;
    }
  } else {
#line 1225
    tmp___1 = 0;
  }
#line 1225
  __ret_warn_on = tmp___1;
#line 1225
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1225
  if (tmp___2 != 0L) {
#line 1225
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1225);
  } else {

  }
#line 1225
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1227
  ctx->key_mapping_keys = (u8 )((int )ctx->key_mapping_keys - 1);
#line 1229
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_remove_dynamic_key", "Remove dynamic key: idx=%d sta=%d\n",
            (int )keyconf->keyidx, (int )sta_id);
#line 1232
  tmp___3 = test_and_clear_bit((long )keyconf->hw_key_idx, (unsigned long volatile   *)(& priv->ucode_key_table));
#line 1232
  if (tmp___3 == 0) {
#line 1233
    __iwl_err(priv->dev, 0, 0, "offset %d not used in uCode key table.\n", (int )keyconf->hw_key_idx);
  } else {

  }
#line 1236
  key_flags = (int )((unsigned short )keyconf->keyidx) << 8U;
#line 1237
  key_flags = (__le16 )((unsigned int )key_flags | 2056U);
#line 1240
  if (((int )keyconf->flags & 8) == 0) {
#line 1241
    key_flags = (__le16 )((unsigned int )key_flags | 16384U);
  } else {

  }
#line 1243
  sta_cmd.key.key_flags = key_flags;
#line 1244
  sta_cmd.key.key_offset = keyconf->hw_key_idx;
#line 1245
  sta_cmd.sta.modify_mask = 1U;
#line 1246
  sta_cmd.mode = 1U;
#line 1248
  tmp___4 = iwl_send_add_sta(priv, & sta_cmd, 0);
#line 1248
  return (tmp___4);
}
}
#line 1251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_set_dynamic_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct ieee80211_key_conf *keyconf ,
                        struct ieee80211_sta *sta ) 
{ 
  struct ieee80211_key_seq seq ;
  u16 p1k[5U] ;
  int ret ;
  u8 sta_id ;
  u8 tmp ;
  u8 const   *addr ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 1259
  tmp = iwlagn_key_sta_id(priv, ctx->vif, sta);
#line 1259
  sta_id = tmp;
#line 1262
  if ((unsigned int )sta_id == 255U) {
#line 1263
    return (-22);
  } else {

  }
#line 1265
  if (debug_locks != 0) {
#line 1265
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
#line 1265
    if (tmp___0 == 0) {
#line 1265
      tmp___1 = 1;
    } else {
#line 1265
      tmp___1 = 0;
    }
  } else {
#line 1265
    tmp___1 = 0;
  }
#line 1265
  __ret_warn_on = tmp___1;
#line 1265
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1265
  if (tmp___2 != 0L) {
#line 1265
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1265);
  } else {

  }
#line 1265
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1267
  tmp___3 = iwl_get_free_ucode_key_offset(priv);
#line 1267
  keyconf->hw_key_idx = (u8 )tmp___3;
#line 1268
  if ((unsigned int )keyconf->hw_key_idx == 255U) {
#line 1269
    return (-28);
  } else {

  }
#line 1271
  ctx->key_mapping_keys = (u8 )((int )ctx->key_mapping_keys + 1);
#line 1273
  switch (keyconf->cipher) {
  case 1027074U: ;
#line 1275
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
#line 1276
    addr = (u8 const   *)(& sta->addr);
  } else {
#line 1278
    addr = (u8 const   *)(& ctx->active.bssid_addr);
  }
#line 1281
  ieee80211_get_key_rx_seq(keyconf, 0, & seq);
#line 1282
  ieee80211_get_tkip_rx_p1k(keyconf, addr, seq.__annonCompField100.tkip.iv32, (u16 *)(& p1k));
#line 1283
  ret = iwlagn_send_sta_key(priv, keyconf, (int )sta_id, seq.__annonCompField100.tkip.iv32,
                            (u16 *)(& p1k), 0U);
#line 1285
  goto ldv_53246;
  case 1027076U: ;
  case 1027073U: ;
  case 1027077U: 
#line 1289
  ret = iwlagn_send_sta_key(priv, keyconf, (int )sta_id, 0U, (u16 *)0U, 0U);
#line 1291
  goto ldv_53246;
  default: 
#line 1293
  __iwl_err(priv->dev, 0, 0, "Unknown cipher %x\n", keyconf->cipher);
#line 1294
  ret = -22;
  }
  ldv_53246: ;
#line 1297
  if (ret != 0) {
#line 1298
    ctx->key_mapping_keys = (u8 )((int )ctx->key_mapping_keys - 1);
#line 1299
    clear_bit((long )keyconf->hw_key_idx, (unsigned long volatile   *)(& priv->ucode_key_table));
  } else {

  }
#line 1302
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_set_dynamic_key", "Set dynamic key: cipher=%x len=%d idx=%d sta=%pM ret=%d\n",
            keyconf->cipher, (int )keyconf->keylen, (int )keyconf->keyidx, (unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0) ? (u8 *)(& sta->addr) : (u8 *)0U,
            ret);
#line 1306
  return (ret);
}
}
#line 1316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwlagn_alloc_bcast_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_link_quality_cmd *link_cmd ;
  u8 sta_id ;

  {
#line 1322
  spin_lock_bh(& priv->sta_lock);
#line 1323
  sta_id = iwl_prep_station(priv, ctx, (u8 const   *)(& iwl_bcast_addr), 0, (struct ieee80211_sta *)0);
#line 1324
  if ((unsigned int )sta_id == 255U) {
#line 1325
    __iwl_err(priv->dev, 0, 0, "Unable to prepare broadcast station\n");
#line 1326
    spin_unlock_bh(& priv->sta_lock);
#line 1328
    return (-22);
  } else {

  }
#line 1331
  priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 1U);
#line 1332
  priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 16U);
#line 1333
  spin_unlock_bh(& priv->sta_lock);
#line 1335
  link_cmd = iwl_sta_alloc_lq(priv, ctx, (int )sta_id);
#line 1336
  if ((unsigned long )link_cmd == (unsigned long )((struct iwl_link_quality_cmd *)0)) {
#line 1337
    __iwl_err(priv->dev, 0, 0, "Unable to initialize rate scaling for bcast station.\n");
#line 1339
    return (-12);
  } else {

  }
#line 1342
  spin_lock_bh(& priv->sta_lock);
#line 1343
  priv->stations[(int )sta_id].lq = link_cmd;
#line 1344
  spin_unlock_bh(& priv->sta_lock);
#line 1346
  return (0);
}
}
#line 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_update_bcast_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_link_quality_cmd *link_cmd ;
  u8 sta_id ;

  {
#line 1359
  sta_id = ctx->bcast_sta_id;
#line 1361
  link_cmd = iwl_sta_alloc_lq(priv, ctx, (int )sta_id);
#line 1362
  if ((unsigned long )link_cmd == (unsigned long )((struct iwl_link_quality_cmd *)0)) {
#line 1363
    __iwl_err(priv->dev, 0, 0, "Unable to initialize rate scaling for bcast station.\n");
#line 1364
    return (-12);
  } else {

  }
#line 1367
  spin_lock_bh(& priv->sta_lock);
#line 1368
  if ((unsigned long )priv->stations[(int )sta_id].lq != (unsigned long )((struct iwl_link_quality_cmd *)0)) {
#line 1369
    kfree((void const   *)priv->stations[(int )sta_id].lq);
  } else {
#line 1371
    __iwl_dbg(priv->dev, 1U, 0, "iwl_update_bcast_station", "Bcast station rate scaling has not been initialized yet.\n");
  }
#line 1372
  priv->stations[(int )sta_id].lq = link_cmd;
#line 1373
  spin_unlock_bh(& priv->sta_lock);
#line 1375
  return (0);
}
}
#line 1378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_update_bcast_stations(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int ret ;

  {
#line 1381
  ret = 0;
#line 1383
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 1383
  goto ldv_53272;
  ldv_53271: ;
#line 1383
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 1384
    ret = iwl_update_bcast_station(priv, ctx);
#line 1385
    if (ret != 0) {
#line 1386
      goto ldv_53270;
    } else {

    }
  } else {

  }
#line 1383
  ctx = ctx + 1;
  ldv_53272: ;
#line 1383
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 1385
    goto ldv_53271;
  } else {

  }
  ldv_53270: ;
#line 1389
  return (ret);
}
}
#line 1395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_sta_tx_modify_enable_tid(struct iwl_priv *priv , int sta_id , int tid ) 
{ 
  struct iwl_addsta_cmd sta_cmd ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1399
  if (debug_locks != 0) {
#line 1399
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 1399
    if (tmp == 0) {
#line 1399
      tmp___0 = 1;
    } else {
#line 1399
      tmp___0 = 0;
    }
  } else {
#line 1399
    tmp___0 = 0;
  }
#line 1399
  __ret_warn_on = tmp___0;
#line 1399
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1399
  if (tmp___1 != 0L) {
#line 1399
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1399);
  } else {

  }
#line 1399
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1402
  spin_lock_bh(& priv->sta_lock);
#line 1403
  priv->stations[sta_id].sta.sta.modify_mask = 2U;
#line 1404
  priv->stations[sta_id].sta.tid_disable_tx = (__le16 )((int )priv->stations[sta_id].sta.tid_disable_tx & ~ ((int )((unsigned short )(1 << tid))));
#line 1405
  priv->stations[sta_id].sta.mode = 1U;
#line 1406
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[sta_id].sta), 92UL);
#line 1407
  spin_unlock_bh(& priv->sta_lock);
#line 1409
  tmp___2 = iwl_send_add_sta(priv, & sta_cmd, 0);
#line 1409
  return (tmp___2);
}
}
#line 1412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_sta_rx_agg_start(struct iwl_priv *priv , struct ieee80211_sta *sta , int tid ,
                         u16 ssn ) 
{ 
  int sta_id ;
  struct iwl_addsta_cmd sta_cmd ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1418
  if (debug_locks != 0) {
#line 1418
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 1418
    if (tmp == 0) {
#line 1418
      tmp___0 = 1;
    } else {
#line 1418
      tmp___0 = 0;
    }
  } else {
#line 1418
    tmp___0 = 0;
  }
#line 1418
  __ret_warn_on = tmp___0;
#line 1418
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1418
  if (tmp___1 != 0L) {
#line 1418
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1418);
  } else {

  }
#line 1418
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1420
  sta_id = iwl_sta_id(sta);
#line 1421
  if (sta_id == 255) {
#line 1422
    return (-6);
  } else {

  }
#line 1424
  spin_lock_bh(& priv->sta_lock);
#line 1425
  priv->stations[sta_id].sta.station_flags_msk = 0U;
#line 1426
  priv->stations[sta_id].sta.sta.modify_mask = 8U;
#line 1427
  priv->stations[sta_id].sta.add_immediate_ba_tid = (unsigned char )tid;
#line 1428
  priv->stations[sta_id].sta.add_immediate_ba_ssn = ssn;
#line 1429
  priv->stations[sta_id].sta.mode = 1U;
#line 1430
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[sta_id].sta), 92UL);
#line 1431
  spin_unlock_bh(& priv->sta_lock);
#line 1433
  tmp___2 = iwl_send_add_sta(priv, & sta_cmd, 0);
#line 1433
  return (tmp___2);
}
}
#line 1436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
int iwl_sta_rx_agg_stop(struct iwl_priv *priv , struct ieee80211_sta *sta , int tid ) 
{ 
  int sta_id ;
  struct iwl_addsta_cmd sta_cmd ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1442
  if (debug_locks != 0) {
#line 1442
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 1442
    if (tmp == 0) {
#line 1442
      tmp___0 = 1;
    } else {
#line 1442
      tmp___0 = 0;
    }
  } else {
#line 1442
    tmp___0 = 0;
  }
#line 1442
  __ret_warn_on = tmp___0;
#line 1442
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1442
  if (tmp___1 != 0L) {
#line 1442
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1442);
  } else {

  }
#line 1442
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1444
  sta_id = iwl_sta_id(sta);
#line 1445
  if (sta_id == 255) {
#line 1446
    __iwl_err(priv->dev, 0, 0, "Invalid station for AGG tid %d\n", tid);
#line 1447
    return (-6);
  } else {

  }
#line 1450
  spin_lock_bh(& priv->sta_lock);
#line 1451
  priv->stations[sta_id].sta.station_flags_msk = 0U;
#line 1452
  priv->stations[sta_id].sta.sta.modify_mask = 16U;
#line 1453
  priv->stations[sta_id].sta.remove_immediate_ba_tid = (unsigned char )tid;
#line 1454
  priv->stations[sta_id].sta.mode = 1U;
#line 1455
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[sta_id].sta), 92UL);
#line 1456
  spin_unlock_bh(& priv->sta_lock);
#line 1458
  tmp___2 = iwl_send_add_sta(priv, & sta_cmd, 0);
#line 1458
  return (tmp___2);
}
}
#line 1463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.c"
void iwl_sta_modify_sleep_tx_count(struct iwl_priv *priv , int sta_id , int cnt ) 
{ 
  struct iwl_addsta_cmd cmd ;

  {
#line 1465
  cmd.mode = 1U;
#line 1465
  cmd.reserved[0] = (unsigned char)0;
#line 1465
  cmd.reserved[1] = (unsigned char)0;
#line 1465
  cmd.reserved[2] = (unsigned char)0;
#line 1465
  cmd.sta.addr[0] = (unsigned char)0;
#line 1465
  cmd.sta.addr[1] = (unsigned char)0;
#line 1465
  cmd.sta.addr[2] = (unsigned char)0;
#line 1465
  cmd.sta.addr[3] = (unsigned char)0;
#line 1465
  cmd.sta.addr[4] = (unsigned char)0;
#line 1465
  cmd.sta.addr[5] = (unsigned char)0;
#line 1465
  cmd.sta.reserved1 = (unsigned short)0;
#line 1465
  cmd.sta.sta_id = (unsigned char )sta_id;
#line 1465
  cmd.sta.modify_mask = 32U;
#line 1465
  cmd.sta.reserved2 = (unsigned short)0;
#line 1465
  cmd.key.key_flags = (unsigned short)0;
#line 1465
  cmd.key.tkip_rx_tsc_byte2 = (unsigned char)0;
#line 1465
  cmd.key.reserved1 = (unsigned char)0;
#line 1465
  cmd.key.tkip_rx_ttak[0] = (unsigned short)0;
#line 1465
  cmd.key.tkip_rx_ttak[1] = (unsigned short)0;
#line 1465
  cmd.key.tkip_rx_ttak[2] = (unsigned short)0;
#line 1465
  cmd.key.tkip_rx_ttak[3] = (unsigned short)0;
#line 1465
  cmd.key.tkip_rx_ttak[4] = (unsigned short)0;
#line 1465
  cmd.key.key_offset = (unsigned char)0;
#line 1465
  cmd.key.reserved2 = (unsigned char)0;
#line 1465
  cmd.key.key[0] = (unsigned char)0;
#line 1465
  cmd.key.key[1] = (unsigned char)0;
#line 1465
  cmd.key.key[2] = (unsigned char)0;
#line 1465
  cmd.key.key[3] = (unsigned char)0;
#line 1465
  cmd.key.key[4] = (unsigned char)0;
#line 1465
  cmd.key.key[5] = (unsigned char)0;
#line 1465
  cmd.key.key[6] = (unsigned char)0;
#line 1465
  cmd.key.key[7] = (unsigned char)0;
#line 1465
  cmd.key.key[8] = (unsigned char)0;
#line 1465
  cmd.key.key[9] = (unsigned char)0;
#line 1465
  cmd.key.key[10] = (unsigned char)0;
#line 1465
  cmd.key.key[11] = (unsigned char)0;
#line 1465
  cmd.key.key[12] = (unsigned char)0;
#line 1465
  cmd.key.key[13] = (unsigned char)0;
#line 1465
  cmd.key.key[14] = (unsigned char)0;
#line 1465
  cmd.key.key[15] = (unsigned char)0;
#line 1465
  cmd.key.tx_secur_seq_cnt = 0ULL;
#line 1465
  cmd.key.hw_tkip_mic_rx_key = 0ULL;
#line 1465
  cmd.key.hw_tkip_mic_tx_key = 0ULL;
#line 1465
  cmd.station_flags = 256U;
#line 1465
  cmd.station_flags_msk = 256U;
#line 1465
  cmd.tid_disable_tx = (unsigned short)0;
#line 1465
  cmd.legacy_reserved = (unsigned short)0;
#line 1465
  cmd.add_immediate_ba_tid = (unsigned char)0;
#line 1465
  cmd.remove_immediate_ba_tid = (unsigned char)0;
#line 1465
  cmd.add_immediate_ba_ssn = (unsigned short)0;
#line 1465
  cmd.sleep_tx_count = (unsigned short )cnt;
#line 1465
  cmd.reserved2 = (unsigned short)0;
#line 1474
  iwl_send_add_sta(priv, & cmd, 1);
#line 1475
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
bool ldv_queue_work_on_393(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 577
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_work_7(ldv_func_arg3, 2);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
bool ldv_queue_delayed_work_on_394(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_work_7(& ldv_func_arg3->work, 2);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
bool ldv_queue_work_on_395(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_7(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
void ldv_flush_workqueue_396(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 609
  flush_workqueue(ldv_func_arg1);
#line 611
  call_and_disable_all_7(2);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
bool ldv_queue_delayed_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 618
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 618
  ldv_func_res = tmp;
#line 620
  activate_work_7(& ldv_func_arg3->work, 2);
#line 622
  return (ldv_func_res);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
void ldv_mutex_lock_398(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
void ldv_mutex_unlock_399(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 638
  mutex_unlock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
void ldv_mutex_lock_400(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 646
  mutex_lock(ldv_func_arg1);
#line 647
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
int ldv_mutex_trylock_401(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
void ldv_mutex_unlock_402(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 665
  mutex_unlock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
void ldv_mutex_unlock_403(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 673
  mutex_unlock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/sta.o.c.prepared"
void ldv_mutex_lock_404(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 681
  mutex_lock(ldv_func_arg1);
#line 682
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 148 "include/linux/byteorder/generic.h"
__inline static void le32_add_cpu(__le32 *var , u32 val ) 
{ 


  {
#line 150
  *var = *var + val;
#line 151
  return;
}
}
#line 431 "include/linux/printk.h"
extern void print_hex_dump(char const   * , char const   * , int  , int  , int  ,
                           void const   * , size_t  , bool  ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags___2(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4801: ;
#line 831
    goto ldv_4801;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_429(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_427(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_430(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
void ldv_mutex_lock_426(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_428(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count___2(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6500;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6500;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6500;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6500;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6500: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 173 "include/linux/timer.h"
int ldv_mod_timer_433(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 51 "include/linux/rcutree.h"
extern void kfree_call_rcu(struct callback_head * , void (*)(struct callback_head * ) ) ;
#line 498 "include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held___2(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 500
  lockdep_opinion = 0;
#line 502
  tmp = debug_lockdep_rcu_enabled();
#line 502
  if (tmp == 0) {
#line 503
    return (1);
  } else {

  }
#line 504
  tmp___0 = rcu_is_watching();
#line 504
  if (tmp___0) {
#line 504
    tmp___1 = 0;
  } else {
#line 504
    tmp___1 = 1;
  }
#line 504
  if (tmp___1) {
#line 505
    return (0);
  } else {

  }
#line 506
  tmp___2 = rcu_lockdep_current_cpu_online();
#line 506
  if (tmp___2) {
#line 506
    tmp___3 = 0;
  } else {
#line 506
    tmp___3 = 1;
  }
#line 506
  if (tmp___3) {
#line 507
    return (0);
  } else {

  }
#line 508
  if (debug_locks != 0) {
#line 509
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
#line 510
  if (lockdep_opinion != 0) {
#line 510
    tmp___6 = 1;
  } else {
#line 510
    tmp___4 = preempt_count___2();
#line 510
    if (tmp___4 != 0) {
#line 510
      tmp___6 = 1;
    } else {
#line 510
      _flags = arch_local_save_flags___2();
#line 510
      tmp___5 = arch_irqs_disabled_flags(_flags);
#line 510
      if (tmp___5 != 0) {
#line 510
        tmp___6 = 1;
      } else {
#line 510
        tmp___6 = 0;
      }
    }
  }
#line 510
  return (tmp___6);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_421(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_423(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_422(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_425(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_424(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___5(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_421(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 10 "include/linux/mmdebug.h"
extern void dump_page(struct page * , char const   * ) ;
#line 400 "include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
#line 400
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
#line 400
  return (tmp);
}
}
#line 532 "include/linux/mm.h"
extern bool __get_page_tail(struct page * ) ;
#line 534 "include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 536
  tmp___1 = PageTail((struct page  const  *)page);
#line 536
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 536
  if (tmp___2 != 0L) {
#line 537
    tmp = __get_page_tail(page);
#line 537
    tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 537
    if (tmp___0 != 0L) {
#line 538
      return;
    } else {

    }
  } else {

  }
#line 543
  tmp___3 = atomic_read((atomic_t const   *)(& page->__annonCompField42.__annonCompField41.__annonCompField40._count));
#line 543
  tmp___4 = ldv__builtin_expect(tmp___3 <= 0, 0L);
#line 543
  if (tmp___4 != 0L) {
#line 543
    dump_page(page, "VM_BUG_ON_PAGE(atomic_read(&page->_count) <= 0)");
#line 543
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/mm.h"),
                         "i" (543), "i" (12UL));
    ldv_23557: ;
#line 543
    goto ldv_23557;
  } else {

  }
#line 544
  atomic_inc(& page->__annonCompField42.__annonCompField41.__annonCompField40._count);
#line 545
  return;
}
}
#line 783 "include/linux/skbuff.h"
extern struct sk_buff *__alloc_skb(unsigned int  , gfp_t  , int  , int  ) ;
#line 787 "include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb(unsigned int size , gfp_t priority ) 
{ 
  struct sk_buff *tmp ;

  {
#line 790
  tmp = __alloc_skb(size, priority, 0, -1);
#line 790
  return (tmp);
}
}
#line 1567 "include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1569
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 1643
extern void skb_add_rx_frag(struct sk_buff * , int  , struct page * , int  , int  ,
                            unsigned int  ) ;
#line 1765 "include/linux/skbuff.h"
__inline static int skb_tailroom(struct sk_buff  const  *skb ) 
{ 
  bool tmp ;

  {
#line 1767
  tmp = skb_is_nonlinear(skb);
#line 1767
  return ((int )tmp ? 0 : (int )((unsigned int )skb->end - (unsigned int )skb->tail));
}
}
#line 453 "include/linux/ieee80211.h"
__inline static int ieee80211_is_beacon(__le16 fc ) 
{ 


  {
#line 455
  return (((int )fc & 252) == 128);
}
}
#line 3528 "include/net/cfg80211.h"
extern int ieee80211_channel_to_frequency(int  , enum ieee80211_band  ) ;
#line 923 "include/net/mac80211.h"
__inline static struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb ) 
{ 


  {
#line 925
  return ((struct ieee80211_rx_status *)(& skb->cb));
}
}
#line 3734
extern void ieee80211_rx(struct ieee80211_hw * , struct sk_buff * ) ;
#line 302 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static int rxb_offset(struct iwl_rx_cmd_buffer *r ) 
{ 


  {
#line 304
  return (r->_offset);
}
}
#line 307 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static struct page *rxb_steal_page(struct iwl_rx_cmd_buffer *r ) 
{ 


  {
#line 309
  r->_page_stolen = 1;
#line 310
  get_page(r->_page);
#line 311
  return (r->_page);
}
}
#line 84 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32___2(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_387 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_389 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 69
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite32.key);
#line 69
  if ((int )tmp___1) {
#line 69
    __rcu_read_lock();
#line 69
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
#line 69
    _________p1 = __u.__val;
#line 69
    ________p1 = _________p1;
#line 69
    tmp = debug_lockdep_rcu_enabled();
#line 69
    if (tmp != 0 && ! __warned) {
#line 69
      tmp___0 = rcu_read_lock_sched_held___2();
#line 69
      if (tmp___0 == 0) {
#line 69
        __warned = 1;
#line 69
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 69
    it_func_ptr = ________p1;
#line 69
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_50599: 
#line 69
      it_func = it_func_ptr->func;
#line 69
      __data = it_func_ptr->data;
#line 69
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 69
      it_func_ptr = it_func_ptr + 1;
#line 69
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 71
        goto ldv_50599;
      } else {

      }

    } else {

    }
#line 69
    __rcu_read_unlock();
  } else {

  }
#line 69
  __rcu_read_lock();
#line 69
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 69
  _________p1___0 = __u___0.__val;
#line 69
  ________p1___0 = _________p1___0;
#line 69
  tmp___2 = debug_lockdep_rcu_enabled();
#line 69
  if (tmp___2 != 0 && ! __warned___0) {
#line 69
    tmp___3 = rcu_read_lock_sched_held___2();
#line 69
    if (tmp___3 == 0) {
#line 69
      __warned___0 = 1;
#line 69
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 69
  __rcu_read_unlock();
#line 71
  return;
}
}
#line 41 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static void iwl_write32___2(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
#line 43
  trace_iwlwifi_dev_iowrite32___2((struct device  const  *)trans->dev, ofs, val);
#line 44
  iwl_trans_write32(trans, ofs, val);
#line 45
  return;
}
}
#line 70
extern void iwl_write_direct32(struct iwl_trans * , u32  , u32  ) ;
#line 115 "drivers/net/wireless/iwlwifi/dvm/../iwl-notif-wait.h"
extern void iwl_notification_wait_init(struct iwl_notif_wait_data * ) ;
#line 116
extern void iwl_notification_wait_notify(struct iwl_notif_wait_data * , struct iwl_rx_packet * ) ;
#line 939 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
__inline static int iwl_is_any_associated___0(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
#line 942
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 942
  goto ldv_53975;
  ldv_53974: ;
#line 942
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 943
    tmp = iwl_is_associated_ctx(ctx);
#line 943
    if (tmp != 0) {
#line 944
      return (1);
    } else {

    }
  } else {

  }
#line 942
  ctx = ctx + 1;
  ldv_53975: ;
#line 942
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 944
    goto ldv_53974;
  } else {

  }

#line 945
  return (0);
}
}
#line 252 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
int iwl_force_rf_reset(struct iwl_priv *priv , bool external ) ;
#line 257
void iwl_internal_short_hw_scan(struct iwl_priv *priv ) ;
#line 258
void iwl_setup_rx_scan_handlers(struct iwl_priv *priv ) ;
#line 390 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static u8 iwl_hw_get_rate(__le32 rate_n_flags ) 
{ 


  {
#line 392
  return ((u8 )rate_n_flags);
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
char const   * const  iwl_dvm_cmd_strings[255U]  = 
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
  {      0,      "REPLY_ALIVE",      "REPLY_ERROR",      "REPLY_ECHO", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        "REPLY_RXON",      "REPLY_RXON_ASSOC",      0,      "REPLY_QOS_PARAM", 
        "REPLY_RXON_TIMING",      0,      0,      0, 
        "REPLY_ADD_STA",      "REPLY_REMOVE_STA",      "REPLY_REMOVE_ALL_STA",      0, 
        "REPLY_TX",      0,      "REPLY_TXFIFO_FLUSH",      0, 
        "REPLY_WEPKEY",      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        "REPLY_LEDS_CMD",      0,      0,      0, 
        0,      0,      "REPLY_TX_LINK_QUALITY_CMD",      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      "COEX_PRIORITY_TABLE_CMD",      "COEX_MEDIUM_NOTIFICATION", 
        "COEX_EVENT_CMD",      0,      0,      0, 
        0,      0,      "TEMPERATURE_NOTIFICATION",      0, 
        0,      "CALIBRATION_CFG_CMD",      "CALIBRATION_RES_NOTIFICATION",      "CALIBRATION_COMPLETE_NOTIFICATION", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      "REPLY_QUIET_CMD",      "REPLY_CHANNEL_SWITCH",      "CHANNEL_SWITCH_NOTIFICATION", 
        "REPLY_SPECTRUM_MEASUREMENT_CMD",      "SPECTRUM_MEASURE_NOTIFICATION",      0,      "POWER_TABLE_CMD", 
        0,      0,      "PM_SLEEP_NOTIFICATION",      "PM_DEBUG_STATISTIC_NOTIFIC", 
        0,      0,      0,      0, 
        "REPLY_SCAN_CMD",      "REPLY_SCAN_ABORT_CMD",      "SCAN_START_NOTIFICATION",      "SCAN_RESULTS_NOTIFICATION", 
        "SCAN_COMPLETE_NOTIFICATION",      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        "BEACON_NOTIFICATION",      "REPLY_TX_BEACON",      0,      0, 
        "WHO_IS_AWAKE_NOTIFICATION",      "REPLY_TX_POWER_DBM_CMD",      "QUIET_NOTIFICATION",      "REPLY_TX_PWR_TABLE_CMD", 
        "TX_ANT_CONFIGURATION_CMD",      "MEASURE_ABORT_NOTIFICATION",      0,      "REPLY_BT_CONFIG", 
        "REPLY_STATISTICS_CMD",      "STATISTICS_NOTIFICATION",      0,      0, 
        "REPLY_CARD_STATE_CMD",      "CARD_STATE_NOTIFICATION",      "MISSED_BEACONS_NOTIFICATION",      0, 
        "REPLY_CT_KILL_CONFIG_CMD",      0,      0,      0, 
        "SENSITIVITY_CMD",      0,      0,      0, 
        0,      0,      0,      0, 
        "REPLY_PHY_CALIBRATION_CMD",      0,      "REPLY_WIPAN_PARAMS",      "REPLY_WIPAN_RXON", 
        "REPLY_WIPAN_RXON_TIMING",      0,      "REPLY_WIPAN_RXON_ASSOC",      "REPLY_WIPAN_QOS_PARAM", 
        "REPLY_WIPAN_WEPKEY",      "REPLY_WIPAN_P2P_CHANNEL_SWITCH",      0,      0, 
        "REPLY_WIPAN_NOA_NOTIFICATION",      "REPLY_WIPAN_DEACTIVATION_COMPLETE",      0,      0, 
        "REPLY_RX_PHY_CMD",      "REPLY_RX_MPDU_CMD",      0,      0, 
        0,      "REPLY_COMPRESSED_BA",      0,      0, 
        0,      0,      0,      0, 
        "REPLY_BT_COEX_PRIO_TABLE",      "REPLY_BT_COEX_PROT_ENV",      "REPLY_BT_COEX_PROFILE_NOTIF",      0, 
        0,      0,      0,      "REPLY_D3_CONFIG", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        "REPLY_WOWLAN_PATTERNS",      "REPLY_WOWLAN_WAKEUP_FILTER",      "REPLY_WOWLAN_TSC_RSC_PARAMS",      "REPLY_WOWLAN_TKIP_PARAMS", 
        "REPLY_WOWLAN_KEK_KCK_MATERIAL",      "REPLY_WOWLAN_GET_STATUS"};
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_reply_error(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                 struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_error_resp *err_resp ;

  {
#line 130
  tmp = rxb_addr(rxb);
#line 130
  pkt = (struct iwl_rx_packet *)tmp;
#line 131
  err_resp = (struct iwl_error_resp *)(& pkt->data);
#line 133
  __iwl_err(priv->dev, 0, 0, "Error Reply type 0x%08X cmd REPLY_ERROR (0x%02X) seq 0x%04X ser 0x%08X\n",
            err_resp->error_type, (int )err_resp->cmd_id, (int )err_resp->bad_cmd_seq_num,
            err_resp->error_info);
#line 139
  return (0);
}
}
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_csa(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_csa_notification *csa ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_cmd *rxon ;
  int tmp___0 ;

  {
#line 145
  tmp = rxb_addr(rxb);
#line 145
  pkt = (struct iwl_rx_packet *)tmp;
#line 146
  csa = (struct iwl_csa_notification *)(& pkt->data);
#line 151
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 152
  rxon = (struct iwl_rxon_cmd *)(& ctx->active);
#line 154
  tmp___0 = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->status));
#line 154
  if (tmp___0 == 0) {
#line 155
    return (0);
  } else {

  }
#line 157
  if (csa->status == 0U && (int )csa->channel == (int )priv->switch_channel) {
#line 158
    rxon->channel = csa->channel;
#line 159
    ctx->staging.channel = csa->channel;
#line 160
    __iwl_dbg(priv->dev, 268435456U, 0, "iwlagn_rx_csa", "CSA notif: channel %d\n",
              (int )csa->channel);
#line 162
    iwl_chswitch_done(priv, 1);
  } else {
#line 164
    __iwl_err(priv->dev, 0, 0, "CSA notif (fail) : channel %d\n", (int )csa->channel);
#line 166
    iwl_chswitch_done(priv, 0);
  }
#line 168
  return (0);
}
}
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_spectrum_measure_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                            struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_spectrum_notification *report ;

  {
#line 176
  tmp = rxb_addr(rxb);
#line 176
  pkt = (struct iwl_rx_packet *)tmp;
#line 177
  report = (struct iwl_spectrum_notification *)(& pkt->data);
#line 179
  if ((unsigned int )report->state == 0U) {
#line 180
    __iwl_dbg(priv->dev, 268435456U, 0, "iwlagn_rx_spectrum_measure_notif", "Spectrum Measure Notification: Start\n");
#line 182
    return (0);
  } else {

  }
#line 185
  memcpy((void *)(& priv->measure_report), (void const   *)report, 100UL);
#line 186
  priv->measurement_status = (u8 )((unsigned int )priv->measurement_status | 1U);
#line 187
  return (0);
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_pm_sleep_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                    struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_sleep_notification *sleep ;

  {
#line 195
  tmp = rxb_addr(rxb);
#line 195
  pkt = (struct iwl_rx_packet *)tmp;
#line 196
  sleep = (struct iwl_sleep_notification *)(& pkt->data);
#line 197
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_pm_sleep_notif", "sleep mode: %d, src: %d\n",
            (int )sleep->pm_sleep_mode, (int )sleep->pm_wakeup_src);
#line 200
  return (0);
}
}
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_pm_debug_statistics_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                               struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  u32 len ;
  u32 tmp___0 ;
  bool tmp___1 ;

  {
#line 207
  tmp = rxb_addr(rxb);
#line 207
  pkt = (struct iwl_rx_packet *)tmp;
#line 208
  tmp___0 = iwl_rx_packet_len((struct iwl_rx_packet  const  *)pkt);
#line 208
  len = tmp___0;
#line 209
  __iwl_dbg(priv->dev, 128U, 0, "iwlagn_rx_pm_debug_statistics_notif", "Dumping %d bytes of unhandled notification for PM_DEBUG_STATISTIC_NOTIFIC:\n",
            len);
#line 211
  tmp___1 = iwl_have_debug_level(128U);
#line 211
  if ((int )tmp___1) {
#line 211
    print_hex_dump("\017", "iwl data: ", 2, 16, 1, (void const   *)(& pkt->data),
                   (size_t )len, 1);
  } else {

  }
#line 212
  return (0);
}
}
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_beacon_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                  struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwlagn_beacon_notif *beacon ;
  u16 status ;
  u8 rate ;
  u8 tmp___0 ;

  {
#line 219
  tmp = rxb_addr(rxb);
#line 219
  pkt = (struct iwl_rx_packet *)tmp;
#line 220
  beacon = (struct iwlagn_beacon_notif *)(& pkt->data);
#line 222
  status = beacon->beacon_notify_hdr.status.status;
#line 223
  tmp___0 = iwl_hw_get_rate(beacon->beacon_notify_hdr.rate_n_flags);
#line 223
  rate = tmp___0;
#line 225
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_beacon_notif", "beacon status %#x, retries:%d ibssmgr:%d tsf:0x%.8x%.8x rate:%d\n",
            (int )status & 255, (int )beacon->beacon_notify_hdr.failure_frame, beacon->ibss_mgr_status,
            beacon->high_tsf, beacon->low_tsf, (int )rate);
#line 234
  priv->ibss_manager = beacon->ibss_mgr_status;
#line 236
  return (0);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static bool iwlagn_good_plcp_health(struct iwl_priv *priv , struct statistics_rx_phy *cur_ofdm ,
                                    struct statistics_rx_ht_phy *cur_ofdm_ht , unsigned int msecs ) 
{ 
  int delta ;
  int threshold ;

  {
#line 251
  threshold = (int )priv->plcp_delta_threshold;
#line 253
  if (threshold == 0) {
#line 254
    __iwl_dbg(priv->dev, 128U, 0, "iwlagn_good_plcp_health", "plcp_err check disabled\n");
#line 255
    return (1);
  } else {

  }
#line 258
  delta = (int )(((cur_ofdm->plcp_err - priv->statistics.rx_ofdm.plcp_err) + cur_ofdm_ht->plcp_err) - priv->statistics.rx_ofdm_ht.plcp_err);
#line 264
  if (delta <= 0) {
#line 265
    return (1);
  } else {

  }
#line 267
  if ((unsigned int )(delta * 100) / msecs > (unsigned int )threshold) {
#line 268
    __iwl_dbg(priv->dev, 128U, 0, "iwlagn_good_plcp_health", "plcp health threshold %u delta %d msecs %u\n",
              threshold, delta, msecs);
#line 271
    return (0);
  } else {

  }
#line 274
  return (1);
}
}
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
int iwl_force_rf_reset(struct iwl_priv *priv , bool external ) 
{ 
  struct iwl_rf_reset *rf_reset ;
  int tmp ;
  int tmp___0 ;

  {
#line 281
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 281
  if (tmp != 0) {
#line 282
    return (-11);
  } else {

  }
#line 284
  tmp___0 = iwl_is_any_associated___0(priv);
#line 284
  if (tmp___0 == 0) {
#line 285
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_force_rf_reset", "force reset rejected: not associated\n");
#line 286
    return (-67);
  } else {

  }
#line 289
  rf_reset = & priv->rf_reset;
#line 290
  rf_reset->reset_request_count = rf_reset->reset_request_count + 1;
#line 292
  if ((! external && rf_reset->last_reset_jiffies != 0UL) && (long )(((unsigned long )jiffies - rf_reset->last_reset_jiffies) - 750UL) < 0L) {
#line 294
    __iwl_dbg(priv->dev, 1U, 0, "iwl_force_rf_reset", "RF reset rejected\n");
#line 295
    rf_reset->reset_reject_count = rf_reset->reset_reject_count + 1;
#line 296
    return (-11);
  } else {

  }
#line 298
  rf_reset->reset_success_count = rf_reset->reset_success_count + 1;
#line 299
  rf_reset->last_reset_jiffies = jiffies;
#line 310
  __iwl_dbg(priv->dev, 1U, 0, "iwl_force_rf_reset", "perform radio reset.\n");
#line 311
  iwl_internal_short_hw_scan(priv);
#line 312
  return (0);
}
}
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static void iwlagn_recover_from_statistics(struct iwl_priv *priv , struct statistics_rx_phy *cur_ofdm ,
                                           struct statistics_rx_ht_phy *cur_ofdm_ht ,
                                           struct statistics_tx *tx , unsigned long stamp ) 
{ 
  unsigned int msecs ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 324
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 324
  if (tmp != 0) {
#line 325
    return;
  } else {

  }
#line 327
  msecs = jiffies_to_msecs(stamp - priv->rx_statistics_jiffies);
#line 330
  tmp___0 = iwl_is_any_associated___0(priv);
#line 330
  if (tmp___0 == 0) {
#line 331
    return;
  } else {

  }
#line 334
  if (msecs <= 98U) {
#line 335
    return;
  } else {

  }
#line 337
  tmp___1 = iwlagn_good_plcp_health(priv, cur_ofdm, cur_ofdm_ht, msecs);
#line 337
  if (tmp___1) {
#line 337
    tmp___2 = 0;
  } else {
#line 337
    tmp___2 = 1;
  }
#line 337
  if (tmp___2) {
#line 338
    iwl_force_rf_reset(priv, 0);
  } else {

  }
#line 339
  return;
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static void iwlagn_rx_calc_noise(struct iwl_priv *priv ) 
{ 
  struct statistics_rx_non_phy *rx_info ;
  int num_active_rx ;
  int total_silence ;
  int bcn_silence_a ;
  int bcn_silence_b ;
  int bcn_silence_c ;
  int last_rx_noise ;

  {
#line 347
  num_active_rx = 0;
#line 348
  total_silence = 0;
#line 352
  rx_info = & priv->statistics.rx_non_phy;
#line 354
  bcn_silence_a = (int )rx_info->beacon_silence_rssi_a & 255;
#line 356
  bcn_silence_b = (int )rx_info->beacon_silence_rssi_b & 255;
#line 358
  bcn_silence_c = (int )rx_info->beacon_silence_rssi_c & 255;
#line 361
  if (bcn_silence_a != 0) {
#line 362
    total_silence = total_silence + bcn_silence_a;
#line 363
    num_active_rx = num_active_rx + 1;
  } else {

  }
#line 365
  if (bcn_silence_b != 0) {
#line 366
    total_silence = total_silence + bcn_silence_b;
#line 367
    num_active_rx = num_active_rx + 1;
  } else {

  }
#line 369
  if (bcn_silence_c != 0) {
#line 370
    total_silence = total_silence + bcn_silence_c;
#line 371
    num_active_rx = num_active_rx + 1;
  } else {

  }
#line 375
  if (num_active_rx != 0) {
#line 376
    last_rx_noise = total_silence / num_active_rx + -107;
  } else {
#line 378
    last_rx_noise = -127;
  }
#line 380
  __iwl_dbg(priv->dev, 2097152U, 0, "iwlagn_rx_calc_noise", "inband silence a %u, b %u, c %u, dBm %d\n",
            bcn_silence_a, bcn_silence_b, bcn_silence_c, last_rx_noise);
#line 381
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static void accum_stats(__le32 *prev , __le32 *cur , __le32 *delta , __le32 *max_delta ,
                        __le32 *accum , int size ) 
{ 
  int i ;

  {
#line 396
  i = 0;
#line 396
  goto ldv_54488;
  ldv_54487: ;
#line 399
  if (*cur > *prev) {
#line 400
    *delta = *cur - *prev;
#line 402
    le32_add_cpu(accum, *delta);
#line 403
    if (*delta > *max_delta) {
#line 404
      *max_delta = *delta;
    } else {

    }
  } else {

  }
#line 398
  i = i + 1;
#line 398
  prev = prev + 1;
#line 398
  cur = cur + 1;
#line 398
  delta = delta + 1;
#line 398
  max_delta = max_delta + 1;
#line 398
  accum = accum + 1;
  ldv_54488: ;
#line 396
  if ((unsigned long )i < (unsigned long )size / 4UL) {
#line 399
    goto ldv_54487;
  } else {

  }

#line 404
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static void iwlagn_accumulative_statistics(struct iwl_priv *priv , struct statistics_general_common *common ,
                                           struct statistics_rx_non_phy *rx_non_phy ,
                                           struct statistics_rx_phy *rx_ofdm , struct statistics_rx_ht_phy *rx_ofdm_ht ,
                                           struct statistics_rx_phy *rx_cck , struct statistics_tx *tx ,
                                           struct statistics_bt_activity *bt_activity ) 
{ 


  {
#line 427
  accum_stats((__le32 *)(& priv->statistics.common), (__le32 *)common, (__le32 *)(& priv->delta_stats.common),
              (__le32 *)(& priv->max_delta_stats.common), (__le32 *)(& priv->accum_stats.common),
              80);
#line 428
  accum_stats((__le32 *)(& priv->statistics.rx_non_phy), (__le32 *)rx_non_phy, (__le32 *)(& priv->delta_stats.rx_non_phy),
              (__le32 *)(& priv->max_delta_stats.rx_non_phy), (__le32 *)(& priv->accum_stats.rx_non_phy),
              84);
#line 429
  accum_stats((__le32 *)(& priv->statistics.rx_ofdm), (__le32 *)rx_ofdm, (__le32 *)(& priv->delta_stats.rx_ofdm),
              (__le32 *)(& priv->max_delta_stats.rx_ofdm), (__le32 *)(& priv->accum_stats.rx_ofdm),
              80);
#line 430
  accum_stats((__le32 *)(& priv->statistics.rx_ofdm_ht), (__le32 *)rx_ofdm_ht, (__le32 *)(& priv->delta_stats.rx_ofdm_ht),
              (__le32 *)(& priv->max_delta_stats.rx_ofdm_ht), (__le32 *)(& priv->accum_stats.rx_ofdm_ht),
              40);
#line 431
  accum_stats((__le32 *)(& priv->statistics.rx_cck), (__le32 *)rx_cck, (__le32 *)(& priv->delta_stats.rx_cck),
              (__le32 *)(& priv->max_delta_stats.rx_cck), (__le32 *)(& priv->accum_stats.rx_cck),
              80);
#line 432
  accum_stats((__le32 *)(& priv->statistics.tx), (__le32 *)tx, (__le32 *)(& priv->delta_stats.tx),
              (__le32 *)(& priv->max_delta_stats.tx), (__le32 *)(& priv->accum_stats.tx),
              104);
#line 433
  if ((unsigned long )bt_activity != (unsigned long )((struct statistics_bt_activity *)0)) {
#line 434
    accum_stats((__le32 *)(& priv->statistics.bt_activity), (__le32 *)bt_activity,
                (__le32 *)(& priv->delta_stats.bt_activity), (__le32 *)(& priv->max_delta_stats.bt_activity),
                (__le32 *)(& priv->accum_stats.bt_activity), 32);
  } else {

  }
#line 435
  return;
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_statistics(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                struct iwl_device_cmd *cmd ) 
{ 
  unsigned long stamp ;
  int reg_recalib_period ;
  int change ;
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  u32 len ;
  u32 tmp___0 ;
  __le32 *flag ;
  struct statistics_general_common *common ;
  struct statistics_rx_non_phy *rx_non_phy ;
  struct statistics_rx_phy *rx_ofdm ;
  struct statistics_rx_ht_phy *rx_ofdm_ht ;
  struct statistics_rx_phy *rx_cck ;
  struct statistics_tx *tx ;
  struct statistics_bt_activity *bt_activity ;
  struct iwl_bt_notif_statistics *stats ;
  struct iwl_notif_statistics *stats___0 ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
#line 455
  stamp = jiffies;
#line 456
  reg_recalib_period = 60;
#line 458
  tmp = rxb_addr(rxb);
#line 458
  pkt = (struct iwl_rx_packet *)tmp;
#line 459
  tmp___0 = iwl_rx_packet_payload_len((struct iwl_rx_packet  const  *)pkt);
#line 459
  len = tmp___0;
#line 469
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_statistics", "Statistics notification received (%d bytes).\n",
            len);
#line 472
  spin_lock(& priv->statistics.lock);
#line 474
  if (len == 524U) {
#line 476
    stats = (struct iwl_bt_notif_statistics *)(& pkt->data);
#line 477
    flag = & stats->flag;
#line 478
    common = & stats->general.common;
#line 479
    rx_non_phy = & stats->rx.general.common;
#line 480
    rx_ofdm = & stats->rx.ofdm;
#line 481
    rx_ofdm_ht = & stats->rx.ofdm_ht;
#line 482
    rx_cck = & stats->rx.cck;
#line 483
    tx = & stats->tx;
#line 484
    bt_activity = & stats->general.activity;
#line 488
    priv->statistics.num_bt_kills = stats->rx.general.num_bt_kills;
#line 489
    le32_add_cpu(& priv->statistics.accum_num_bt_kills, stats->rx.general.num_bt_kills);
  } else
#line 492
  if (len == 480U) {
#line 494
    stats___0 = (struct iwl_notif_statistics *)(& pkt->data);
#line 495
    flag = & stats___0->flag;
#line 496
    common = & stats___0->general.common;
#line 497
    rx_non_phy = & stats___0->rx.general;
#line 498
    rx_ofdm = & stats___0->rx.ofdm;
#line 499
    rx_ofdm_ht = & stats___0->rx.ofdm_ht;
#line 500
    rx_cck = & stats___0->rx.cck;
#line 501
    tx = & stats___0->tx;
#line 502
    bt_activity = (struct statistics_bt_activity *)0;
  } else {
#line 504
    __ret_warn_once = 1;
#line 504
    tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 504
    if (tmp___3 != 0L) {
#line 504
      __ret_warn_on = ! __warned;
#line 504
      tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 504
      if (tmp___1 != 0L) {
#line 504
        warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c",
                          506, "len %d doesn\'t match BT (%zu) or normal (%zu)\n",
                          len, 524UL, 480UL);
      } else {

      }
#line 504
      tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 504
      if (tmp___2 != 0L) {
#line 504
        __warned = 1;
      } else {

      }
    } else {

    }
#line 504
    ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 507
    spin_unlock(& priv->statistics.lock);
#line 508
    return (0);
  }
#line 511
  change = common->temperature != priv->statistics.common.temperature || ((*flag ^ priv->statistics.flag) & 8U) != 0U;
#line 515
  iwlagn_accumulative_statistics(priv, common, rx_non_phy, rx_ofdm, rx_ofdm_ht, rx_cck,
                                 tx, bt_activity);
#line 518
  iwlagn_recover_from_statistics(priv, rx_ofdm, rx_ofdm_ht, tx, stamp);
#line 520
  priv->statistics.flag = *flag;
#line 521
  memcpy((void *)(& priv->statistics.common), (void const   *)common, 80UL);
#line 522
  memcpy((void *)(& priv->statistics.rx_non_phy), (void const   *)rx_non_phy, 84UL);
#line 523
  memcpy((void *)(& priv->statistics.rx_ofdm), (void const   *)rx_ofdm, 80UL);
#line 524
  memcpy((void *)(& priv->statistics.rx_ofdm_ht), (void const   *)rx_ofdm_ht, 40UL);
#line 525
  memcpy((void *)(& priv->statistics.rx_cck), (void const   *)rx_cck, 80UL);
#line 526
  memcpy((void *)(& priv->statistics.tx), (void const   *)tx, 104UL);
#line 528
  if ((unsigned long )bt_activity != (unsigned long )((struct statistics_bt_activity *)0)) {
#line 529
    memcpy((void *)(& priv->statistics.bt_activity), (void const   *)bt_activity,
             32UL);
  } else {

  }
#line 533
  priv->rx_statistics_jiffies = stamp;
#line 535
  set_bit(6L, (unsigned long volatile   *)(& priv->status));
#line 541
  tmp___4 = msecs_to_jiffies((unsigned int const   )(reg_recalib_period * 1000));
#line 541
  ldv_mod_timer_433(& priv->statistics_periodic, tmp___4 + (unsigned long )jiffies);
#line 544
  tmp___5 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 544
  tmp___6 = ldv__builtin_expect(tmp___5 == 0, 0L);
#line 544
  if (tmp___6 != 0L && (unsigned int )pkt->hdr.cmd == 157U) {
#line 546
    iwlagn_rx_calc_noise(priv);
#line 547
    queue_work___5(priv->workqueue, & priv->run_time_calib_work);
  } else {

  }
#line 549
  if ((unsigned long )(priv->lib)->temperature != (unsigned long )((void (*/* const  */)(struct iwl_priv * ))0) && change != 0) {
#line 550
    (*((priv->lib)->temperature))(priv);
  } else {

  }
#line 552
  spin_unlock(& priv->statistics.lock);
#line 554
  return (0);
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_reply_statistics(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                      struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_notif_statistics *stats ;

  {
#line 561
  tmp = rxb_addr(rxb);
#line 561
  pkt = (struct iwl_rx_packet *)tmp;
#line 562
  stats = (struct iwl_notif_statistics *)(& pkt->data);
#line 564
  if ((int )stats->flag & 1) {
#line 566
    memset((void *)(& priv->accum_stats), 0, 500UL);
#line 568
    memset((void *)(& priv->delta_stats), 0, 500UL);
#line 570
    memset((void *)(& priv->max_delta_stats), 0, 500UL);
#line 573
    __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_reply_statistics", "Statistics have been cleared\n");
  } else {

  }
#line 575
  iwlagn_rx_statistics(priv, rxb, cmd);
#line 576
  return (0);
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_card_state_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                      struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_card_state_notif *card_state_notif ;
  u32 flags ;
  unsigned long status ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 585
  tmp = rxb_addr(rxb);
#line 585
  pkt = (struct iwl_rx_packet *)tmp;
#line 586
  card_state_notif = (struct iwl_card_state_notif *)(& pkt->data);
#line 587
  flags = card_state_notif->flags;
#line 588
  status = priv->status;
#line 590
  __iwl_dbg(priv->dev, 131072U, 0, "iwlagn_rx_card_state_notif", "Card state received: HW:%s SW:%s CT:%s\n",
            (int )flags & 1 ? (char *)"Kill" : (char *)"On", (flags & 2U) != 0U ? (char *)"Kill" : (char *)"On",
            (flags & 4U) != 0U ? (char *)"Reached" : (char *)"Not reached");
#line 596
  if ((flags & 7U) != 0U) {
#line 599
    iwl_write32___2(priv->trans, 88U, 4U);
#line 602
    iwl_write_direct32(priv->trans, 1072U, 4U);
#line 605
    if ((flags & 16U) == 0U) {
#line 606
      iwl_write32___2(priv->trans, 92U, 4U);
#line 608
      iwl_write_direct32(priv->trans, 1072U, 4U);
    } else {

    }
#line 611
    if ((flags & 4U) != 0U) {
#line 612
      iwl_tt_enter_ct_kill(priv);
    } else {

    }
  } else {

  }
#line 614
  if ((flags & 4U) == 0U) {
#line 615
    iwl_tt_exit_ct_kill(priv);
  } else {

  }
#line 617
  if ((int )flags & 1) {
#line 618
    set_bit(0L, (unsigned long volatile   *)(& priv->status));
  } else {
#line 620
    clear_bit(0L, (unsigned long volatile   *)(& priv->status));
  }
#line 623
  if ((flags & 16U) == 0U) {
#line 624
    iwl_scan_cancel(priv);
  } else {

  }
#line 626
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& status));
#line 626
  tmp___2 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
#line 626
  if (tmp___1 != tmp___2) {
#line 628
    tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
#line 628
    wiphy_rfkill_set_hw_state((priv->hw)->wiphy, tmp___0 != 0);
  } else {

  }
#line 630
  return (0);
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_missed_beacon_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                         struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_missed_beacon_notif *missed_beacon ;
  int tmp___0 ;

  {
#line 638
  tmp = rxb_addr(rxb);
#line 638
  pkt = (struct iwl_rx_packet *)tmp;
#line 639
  missed_beacon = (struct iwl_missed_beacon_notif *)(& pkt->data);
#line 641
  if (missed_beacon->consecutive_missed_beacons > (__le32 )priv->missed_beacon_threshold) {
#line 643
    __iwl_dbg(priv->dev, 2097152U, 0, "iwlagn_rx_missed_beacon_notif", "missed bcn cnsq %d totl %d rcd %d expctd %d\n",
              missed_beacon->consecutive_missed_beacons, missed_beacon->total_missed_becons,
              missed_beacon->num_recvd_beacons, missed_beacon->num_expected_beacons);
#line 649
    tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 649
    if (tmp___0 == 0) {
#line 650
      iwl_init_sensitivity(priv);
    } else {

    }
  } else {

  }
#line 652
  return (0);
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_reply_rx_phy(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                  struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;

  {
#line 661
  tmp = rxb_addr(rxb);
#line 661
  pkt = (struct iwl_rx_packet *)tmp;
#line 663
  priv->last_phy_res_valid = 1;
#line 664
  priv->ampdu_ref = priv->ampdu_ref + 1U;
#line 665
  memcpy((void *)(& priv->last_phy_res), (void const   *)(& pkt->data), 60UL);
#line 667
  return (0);
}
}
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_set_decrypted_flag(struct iwl_priv *priv , struct ieee80211_hdr *hdr ,
                                     u32 decrypt_res , struct ieee80211_rx_status *stats ) 
{ 
  u16 fc ;

  {
#line 678
  fc = hdr->frame_control;
#line 684
  if (((unsigned int )priv->contexts[0].active.filter_flags & 8U) != 0U) {
#line 686
    return (0);
  } else {

  }
#line 688
  if (((int )fc & 16384) == 0) {
#line 689
    return (0);
  } else {

  }
#line 691
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_set_decrypted_flag", "decrypt_res:0x%x\n",
            decrypt_res);
#line 692
  switch (decrypt_res & 1792U) {
  case 768U: ;
#line 696
  if ((decrypt_res & 6144U) == 4096U) {
#line 698
    goto ldv_54567;
  } else {

  }
  case 256U: ;
#line 701
  if ((decrypt_res & 6144U) == 2048U) {
#line 705
    __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_set_decrypted_flag", "Packet destroyed\n");
#line 706
    return (-1);
  } else {

  }
  case 512U: ;
#line 709
  if ((decrypt_res & 6144U) == 6144U) {
#line 711
    __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_set_decrypted_flag", "hw decrypt successfully!!!\n");
#line 712
    stats->flag = stats->flag | 2U;
  } else {

  }
#line 714
  goto ldv_54567;
  default: ;
#line 717
  goto ldv_54567;
  }
  ldv_54567: ;
#line 719
  return (0);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static void iwlagn_pass_packet_to_mac80211(struct iwl_priv *priv , struct ieee80211_hdr *hdr ,
                                           u16 len , u32 ampdu_status , struct iwl_rx_cmd_buffer *rxb ,
                                           struct ieee80211_rx_status *stats ) 
{ 
  struct sk_buff *skb ;
  __le16 fc ;
  struct iwl_rxon_context *ctx ;
  unsigned int hdrlen ;
  unsigned int fraglen ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int offset ;
  void *tmp___3 ;
  int tmp___4 ;
  struct page *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  struct ieee80211_rx_status *tmp___10 ;

  {
#line 730
  fc = hdr->frame_control;
#line 735
  tmp = ldv__builtin_expect((unsigned int )priv->is_open == 0U, 0L);
#line 735
  if (tmp != 0L) {
#line 736
    __iwl_dbg(priv->dev, 8192U, 1, "iwlagn_pass_packet_to_mac80211", "Dropping packet while interface is not open.\n");
#line 738
    return;
  } else {

  }
#line 742
  if (iwlwifi_mod_params.sw_crypto == 0) {
#line 742
    tmp___0 = iwlagn_set_decrypted_flag(priv, hdr, ampdu_status, stats);
#line 742
    if (tmp___0 != 0) {
#line 744
      return;
    } else {

    }
  } else {

  }
#line 749
  skb = alloc_skb(128U, 32U);
#line 750
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 751
    __iwl_err(priv->dev, 0, 0, "alloc_skb failed\n");
#line 752
    return;
  } else {

  }
#line 758
  tmp___1 = skb_tailroom((struct sk_buff  const  *)skb);
#line 758
  hdrlen = (int )len <= tmp___1 ? (unsigned int )len : 30U;
#line 760
  tmp___2 = skb_put(skb, hdrlen);
#line 760
  memcpy((void *)tmp___2, (void const   *)hdr, (size_t )hdrlen);
#line 761
  fraglen = (unsigned int )len - hdrlen;
#line 763
  if (fraglen != 0U) {
#line 764
    tmp___3 = rxb_addr(rxb);
#line 764
    tmp___4 = rxb_offset(rxb);
#line 764
    offset = (int )(((unsigned int )((long )((void *)hdr + (unsigned long )hdrlen)) - (unsigned int )((long )tmp___3)) + (unsigned int )tmp___4);
#line 767
    tmp___5 = rxb_steal_page(rxb);
#line 767
    skb_add_rx_frag(skb, 0, tmp___5, offset, (int )fraglen, rxb->truesize);
  } else {

  }
#line 778
  tmp___8 = ieee80211_is_beacon((int )fc);
#line 778
  tmp___9 = ldv__builtin_expect((long )(tmp___8 != 0 && (int )priv->passive_no_rx), 0L);
#line 778
  if (tmp___9 != 0L) {
#line 779
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 779
    goto ldv_54588;
    ldv_54587: ;
#line 779
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 780
      tmp___6 = ether_addr_equal((u8 const   *)(& hdr->addr3), (u8 const   *)(& ctx->active.bssid_addr));
#line 780
      if (tmp___6) {
#line 780
        tmp___7 = 0;
      } else {
#line 780
        tmp___7 = 1;
      }
#line 780
      if (tmp___7) {
#line 782
        goto ldv_54586;
      } else {

      }
#line 783
      iwlagn_lift_passive_no_rx(priv);
    } else {

    }
    ldv_54586: 
#line 779
    ctx = ctx + 1;
    ldv_54588: ;
#line 779
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 781
      goto ldv_54587;
    } else {

    }

  } else {

  }
#line 787
  tmp___10 = IEEE80211_SKB_RXCB(skb);
#line 787
  memcpy((void *)tmp___10, (void const   *)stats, 40UL);
#line 789
  ieee80211_rx(priv->hw, skb);
#line 790
  return;
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static u32 iwlagn_translate_rx_status(struct iwl_priv *priv , u32 decrypt_in ) 
{ 
  u32 decrypt_out ;

  {
#line 794
  decrypt_out = 0U;
#line 796
  if ((decrypt_in & 64U) != 0U) {
#line 798
    decrypt_out = decrypt_out | 192U;
  } else {

  }
#line 801
  decrypt_out = (decrypt_in & 1792U) | decrypt_out;
#line 804
  if ((decrypt_in & 1792U) == 0U) {
#line 806
    return (decrypt_out);
  } else {

  }
#line 809
  if ((decrypt_in & 1792U) == 1792U) {
#line 811
    return (decrypt_out);
  } else {

  }
#line 814
  if ((decrypt_in & 2048U) == 0U) {
#line 816
    return (decrypt_out);
  } else {

  }
#line 818
  switch (decrypt_in & 1792U) {
  case 512U: ;
#line 822
  if ((decrypt_in & 64U) == 0U) {
#line 824
    decrypt_out = decrypt_out | 2048U;
  } else {
#line 826
    decrypt_out = decrypt_out | 6144U;
  }
#line 828
  goto ldv_54596;
  case 768U: ;
#line 831
  if ((decrypt_in & 128U) == 0U) {
#line 833
    decrypt_out = decrypt_out | 4096U;
#line 834
    goto ldv_54596;
  } else {

  }
  default: ;
#line 838
  if ((decrypt_in & 32U) == 0U) {
#line 839
    decrypt_out = decrypt_out | 2048U;
  } else {
#line 841
    decrypt_out = decrypt_out | 6144U;
  }
#line 842
  goto ldv_54596;
  }
  ldv_54596: 
#line 845
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_translate_rx_status", "decrypt_in:0x%x  decrypt_out = 0x%x\n",
            decrypt_in, decrypt_out);
#line 848
  return (decrypt_out);
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_calc_rssi(struct iwl_priv *priv , struct iwl_rx_phy_res *rx_resp ) 
{ 
  struct iwlagn_non_cfg_phy *ncphy ;
  u32 val ;
  u32 rssi_a ;
  u32 rssi_b ;
  u32 rssi_c ;
  u32 max_rssi ;
  u8 agc ;
  u32 __max1 ;
  u32 __max2 ;
  u32 __max1___0 ;
  u32 __max2___0 ;

  {
#line 858
  ncphy = (struct iwlagn_non_cfg_phy *)(& rx_resp->non_cfg_phy_buf);
#line 863
  val = ncphy->non_cfg_phy[1];
#line 864
  agc = (u8 )((val & 65024U) >> 9);
#line 872
  val = ncphy->non_cfg_phy[2];
#line 873
  rssi_a = val & 255U;
#line 875
  rssi_b = (val & 16711680U) >> 16;
#line 877
  val = ncphy->non_cfg_phy[3];
#line 878
  rssi_c = val & 255U;
#line 881
  __max1 = rssi_a;
#line 881
  __max2 = rssi_b;
#line 881
  max_rssi = __max1 > __max2 ? __max1 : __max2;
#line 882
  __max1___0 = max_rssi;
#line 882
  __max2___0 = rssi_c;
#line 882
  max_rssi = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
#line 884
  __iwl_dbg(priv->dev, 536870912U, 0, "iwlagn_calc_rssi", "Rssi In A %d B %d C %d Max %d AGC dB %d\n",
            rssi_a, rssi_b, rssi_c, max_rssi, (int )agc);
#line 889
  return ((int )((max_rssi - (u32 )agc) - 44U));
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_reply_rx(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                              struct iwl_device_cmd *cmd ) 
{ 
  struct ieee80211_hdr *header ;
  struct ieee80211_rx_status rx_status ;
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_rx_phy_res *phy_res ;
  __le32 rx_pkt_status ;
  struct iwl_rx_mpdu_res_start *amsdu ;
  u32 len ;
  u32 ampdu_status ;
  u32 rate_n_flags ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 898
  rx_status.mactime = 0ULL;
#line 898
  rx_status.device_timestamp = 0U;
#line 898
  rx_status.ampdu_reference = 0U;
#line 898
  rx_status.flag = 0U;
#line 898
  rx_status.freq = (unsigned short)0;
#line 898
  rx_status.vht_flag = (unsigned char)0;
#line 898
  rx_status.rate_idx = (unsigned char)0;
#line 898
  rx_status.vht_nss = (unsigned char)0;
#line 898
  rx_status.rx_flags = (unsigned char)0;
#line 898
  rx_status.band = (unsigned char)0;
#line 898
  rx_status.antenna = (unsigned char)0;
#line 898
  rx_status.signal = (signed char)0;
#line 898
  rx_status.chains = (unsigned char)0;
#line 898
  rx_status.chain_signal[0] = (signed char)0;
#line 898
  rx_status.chain_signal[1] = (signed char)0;
#line 898
  rx_status.chain_signal[2] = (signed char)0;
#line 898
  rx_status.chain_signal[3] = (signed char)0;
#line 898
  rx_status.ampdu_delimiter_crc = (unsigned char)0;
#line 899
  tmp = rxb_addr(rxb);
#line 899
  pkt = (struct iwl_rx_packet *)tmp;
#line 907
  if (! priv->last_phy_res_valid) {
#line 908
    __iwl_err(priv->dev, 0, 0, "MPDU frame without cached PHY data\n");
#line 909
    return (0);
  } else {

  }
#line 911
  phy_res = & priv->last_phy_res;
#line 912
  amsdu = (struct iwl_rx_mpdu_res_start *)(& pkt->data);
#line 913
  header = (struct ieee80211_hdr *)(& pkt->data) + 4U;
#line 914
  len = (u32 )amsdu->byte_count;
#line 915
  rx_pkt_status = *((__le32 *)(& pkt->data) + ((unsigned long )len + 4UL));
#line 916
  ampdu_status = iwlagn_translate_rx_status(priv, rx_pkt_status);
#line 919
  tmp___0 = ldv__builtin_expect((unsigned int )phy_res->cfg_phy_cnt > 20U, 0L);
#line 919
  if (tmp___0 != 0L) {
#line 920
    __iwl_dbg(priv->dev, 8192U, 0, "iwlagn_rx_reply_rx", "dsp size out of range [0,20]: %d\n",
              (int )phy_res->cfg_phy_cnt);
#line 922
    return (0);
  } else {

  }
#line 925
  if ((rx_pkt_status & 1U) == 0U || (rx_pkt_status & 2U) == 0U) {
#line 927
    __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_reply_rx", "Bad CRC or FIFO: 0x%08X.\n",
              rx_pkt_status);
#line 929
    return (0);
  } else {

  }
#line 933
  rate_n_flags = phy_res->rate_n_flags;
#line 936
  rx_status.mactime = phy_res->timestamp;
#line 937
  rx_status.band = (int )phy_res->phy_flags & 1 ? 0U : 1U;
#line 939
  tmp___1 = ieee80211_channel_to_frequency((int )phy_res->channel, (enum ieee80211_band )rx_status.band);
#line 939
  rx_status.freq = (u16 )tmp___1;
#line 942
  tmp___2 = iwlagn_hwrate_to_mac80211_idx(rate_n_flags, (enum ieee80211_band )rx_status.band);
#line 942
  rx_status.rate_idx = (u8 )tmp___2;
#line 944
  rx_status.flag = 0U;
#line 950
  priv->ucode_beacon_time = phy_res->beacon_time_stamp;
#line 953
  tmp___3 = iwlagn_calc_rssi(priv, phy_res);
#line 953
  rx_status.signal = (s8 )tmp___3;
#line 955
  __iwl_dbg(priv->dev, 536870912U, 1, "iwlagn_rx_reply_rx", "Rssi %d, TSF %llu\n",
            (int )rx_status.signal, rx_status.mactime);
#line 971
  rx_status.antenna = (u8 )(((int )phy_res->phy_flags & 112) >> 4);
#line 976
  if (((int )phy_res->phy_flags & 4) != 0) {
#line 977
    rx_status.flag = rx_status.flag | 256U;
  } else {

  }
#line 979
  if (((int )phy_res->phy_flags & 128) != 0) {
#line 985
    rx_status.flag = rx_status.flag | 16384U;
#line 986
    rx_status.ampdu_reference = priv->ampdu_ref;
  } else {

  }
#line 990
  if ((rate_n_flags & 256U) != 0U) {
#line 991
    rx_status.flag = rx_status.flag | 512U;
  } else {

  }
#line 992
  if ((rate_n_flags & 2048U) != 0U) {
#line 993
    rx_status.flag = rx_status.flag | 1024U;
  } else {

  }
#line 994
  if ((rate_n_flags & 8192U) != 0U) {
#line 995
    rx_status.flag = rx_status.flag | 2048U;
  } else {

  }
#line 996
  if ((rate_n_flags & 1024U) != 0U) {
#line 997
    rx_status.flag = rx_status.flag | 8192U;
  } else {

  }
#line 999
  iwlagn_pass_packet_to_mac80211(priv, header, (int )((u16 )len), ampdu_status, rxb,
                                 & rx_status);
#line 1001
  return (0);
}
}
#line 1040
extern void __compiletime_assert_1040(void) ;
#line 1004 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
static int iwlagn_rx_noa_notification(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                      struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_wipan_noa_data *new_data ;
  struct iwl_wipan_noa_data *old_data ;
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_wipan_noa_notification *noa_notif ;
  int tmp___0 ;
  u32 len ;
  u32 copylen ;
  void *tmp___1 ;
  bool __cond ;
  struct iwl_wipan_noa_data *__var ;

  {
#line 1009
  tmp = rxb_addr(rxb);
#line 1009
  pkt = (struct iwl_rx_packet *)tmp;
#line 1010
  noa_notif = (struct iwl_wipan_noa_notification *)(& pkt->data);
#line 1013
  tmp___0 = debug_lockdep_rcu_enabled();
#line 1013
  old_data = priv->noa_data;
#line 1015
  if (noa_notif->noa_active != 0U) {
#line 1016
    len = (u32 )noa_notif->noa_attribute.length;
#line 1017
    copylen = len;
#line 1020
    len = len + 6U;
#line 1022
    len = len + 3U;
#line 1023
    copylen = copylen + 3U;
#line 1025
    tmp___1 = kmalloc((unsigned long )len + 24UL, 32U);
#line 1025
    new_data = (struct iwl_wipan_noa_data *)tmp___1;
#line 1026
    if ((unsigned long )new_data != (unsigned long )((struct iwl_wipan_noa_data *)0)) {
#line 1027
      new_data->length = len;
#line 1028
      new_data->data[0] = 221U;
#line 1029
      new_data->data[1] = (unsigned int )((u8 )len) - 2U;
#line 1030
      new_data->data[2] = 80U;
#line 1031
      new_data->data[3] = 111U;
#line 1032
      new_data->data[4] = 154U;
#line 1033
      new_data->data[5] = 9U;
#line 1034
      memcpy((void *)(& new_data->data) + 6U, (void const   *)(& noa_notif->noa_attribute),
               (size_t )copylen);
    } else {

    }
  } else {
#line 1038
    new_data = (struct iwl_wipan_noa_data *)0;
  }
#line 1040
  __cond = 0;
#line 1040
  if ((int )__cond) {
#line 1040
    __compiletime_assert_1040();
  } else {

  }
#line 1040
  __asm__  volatile   ("": : : "memory");
#line 1040
  __var = (struct iwl_wipan_noa_data *)0;
#line 1040
  *((struct iwl_wipan_noa_data * volatile  *)(& priv->noa_data)) = new_data;
#line 1042
  if ((unsigned long )old_data != (unsigned long )((struct iwl_wipan_noa_data *)0)) {
#line 1043
    kfree_call_rcu(& old_data->callback_head, (void (*)(struct callback_head * ))0);
  } else {

  }
#line 1045
  return (0);
}
}
#line 1054 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
void iwl_setup_rx_handlers(struct iwl_priv *priv ) 
{ 
  int (**handlers)(struct iwl_priv * , struct iwl_rx_cmd_buffer * , struct iwl_device_cmd * ) ;

  {
#line 1059
  handlers = (int (**)(struct iwl_priv * , struct iwl_rx_cmd_buffer * , struct iwl_device_cmd * ))(& priv->rx_handlers);
#line 1061
  *(handlers + 2UL) = & iwlagn_rx_reply_error;
#line 1062
  *(handlers + 115UL) = & iwlagn_rx_csa;
#line 1063
  *(handlers + 117UL) = & iwlagn_rx_spectrum_measure_notif;
#line 1065
  *(handlers + 122UL) = & iwlagn_rx_pm_sleep_notif;
#line 1066
  *(handlers + 123UL) = & iwlagn_rx_pm_debug_statistics_notif;
#line 1068
  *(handlers + 144UL) = & iwlagn_rx_beacon_notif;
#line 1069
  *(handlers + 24UL) = & iwl_add_sta_callback;
#line 1071
  *(handlers + 188UL) = & iwlagn_rx_noa_notification;
#line 1078
  *(handlers + 156UL) = & iwlagn_rx_reply_statistics;
#line 1079
  *(handlers + 157UL) = & iwlagn_rx_statistics;
#line 1081
  iwl_setup_rx_scan_handlers(priv);
#line 1083
  *(handlers + 161UL) = & iwlagn_rx_card_state_notif;
#line 1084
  *(handlers + 162UL) = & iwlagn_rx_missed_beacon_notif;
#line 1088
  *(handlers + 192UL) = & iwlagn_rx_reply_rx_phy;
#line 1089
  *(handlers + 193UL) = & iwlagn_rx_reply_rx;
#line 1092
  *(handlers + 197UL) = & iwlagn_rx_reply_compressed_ba;
#line 1095
  priv->rx_handlers[28] = & iwlagn_rx_reply_tx;
#line 1098
  iwl_notification_wait_init(& priv->notif_wait);
#line 1101
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
#line 1102
    iwlagn_bt_rx_handler_setup(priv);
  } else {

  }
#line 1103
  return;
}
}
#line 1105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.c"
int iwl_rx_dispatch(struct iwl_op_mode *op_mode , struct iwl_rx_cmd_buffer *rxb ,
                    struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_priv *priv ;
  int err ;
  char const   *tmp___0 ;

  {
#line 1108
  tmp = rxb_addr(rxb);
#line 1108
  pkt = (struct iwl_rx_packet *)tmp;
#line 1109
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
#line 1110
  err = 0;
#line 1117
  iwl_notification_wait_notify(& priv->notif_wait, pkt);
#line 1122
  if ((unsigned long )priv->rx_handlers[(int )pkt->hdr.cmd] != (unsigned long )((int (*)(struct iwl_priv * ,
                                                                                         struct iwl_rx_cmd_buffer * ,
                                                                                         struct iwl_device_cmd * ))0)) {
#line 1123
    priv->rx_handlers_stats[(int )pkt->hdr.cmd] = priv->rx_handlers_stats[(int )pkt->hdr.cmd] + 1U;
#line 1124
    err = (*(priv->rx_handlers[(int )pkt->hdr.cmd]))(priv, rxb, cmd);
  } else {
#line 1127
    tmp___0 = iwl_dvm_get_cmd_string((int )pkt->hdr.cmd);
#line 1127
    __iwl_dbg(priv->dev, 16777216U, 0, "iwl_rx_dispatch", "No handler needed for %s, 0x%02x\n",
              tmp___0, (int )pkt->hdr.cmd);
  }
#line 1131
  return (err);
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
bool ldv_queue_work_on_421(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 577
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_work_7(ldv_func_arg3, 2);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
bool ldv_queue_delayed_work_on_422(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_work_7(& ldv_func_arg3->work, 2);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
bool ldv_queue_work_on_423(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_7(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
void ldv_flush_workqueue_424(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 609
  flush_workqueue(ldv_func_arg1);
#line 611
  call_and_disable_all_7(2);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
bool ldv_queue_delayed_work_on_425(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 618
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 618
  ldv_func_res = tmp;
#line 620
  activate_work_7(& ldv_func_arg3->work, 2);
#line 622
  return (ldv_func_res);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
void ldv_mutex_lock_426(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
void ldv_mutex_unlock_427(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 638
  mutex_unlock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
void ldv_mutex_lock_428(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 646
  mutex_lock(ldv_func_arg1);
#line 647
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
int ldv_mutex_trylock_429(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
void ldv_mutex_unlock_430(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 665
  mutex_unlock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 673
  mutex_unlock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 681
  mutex_lock(ldv_func_arg1);
#line 682
  return;
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rx.o.c.prepared"
int ldv_mod_timer_433(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 688
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 688
  ldv_func_res = tmp;
#line 690
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
#line 692
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_459(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_460(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_461(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
void ldv_mutex_lock_456(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_458(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_462(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_451(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_453(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_452(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_455(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_454(struct workqueue_struct *ldv_func_arg1 ) ;
#line 982 "drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h"
__inline static void iwl_trans_set_pmi(struct iwl_trans *trans , bool state ) 
{ 


  {
#line 984
  if ((unsigned long )(trans->ops)->set_pmi != (unsigned long )((void (*/* const  */)(struct iwl_trans * ,
                                                                                      bool  ))0)) {
#line 985
    (*((trans->ops)->set_pmi))(trans, (int )state);
  } else {

  }
#line 986
  return;
}
}
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/power.h"
int iwl_power_set_mode(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd , bool force ) ;
#line 289 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static bool iwl_advanced_bt_coexist(struct iwl_priv *priv ) 
{ 


  {
#line 291
  return ((bool )((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist));
}
}
#line 444 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static void iwl_dvm_set_pmi(struct iwl_priv *priv , bool state ) 
{ 


  {
#line 446
  if ((int )state) {
#line 447
    set_bit(13L, (unsigned long volatile   *)(& priv->status));
  } else {
#line 449
    clear_bit(13L, (unsigned long volatile   *)(& priv->status));
  }
#line 450
  iwl_trans_set_pmi(priv->trans, (int )state);
#line 451
  return;
}
}
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static bool force_cam  =    1;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static struct iwl_power_vec_entry  const  range_0[5U]  = {      {{1U, 0U, 0U, 204800U, 512000U, {1U, 1U, 2U, 2U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 204800U, 307200U, {1U, 2U, 2U, 2U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 102400U, {2U, 2U, 2U, 2U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 25600U, {2U, 2U, 4U, 4U, 255U}, 0U}, 1U}, 
        {{1U, 0U, 0U, 25600U, 25600U, {2U, 2U, 4U, 6U, 255U}, 0U}, 2U}};
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static struct iwl_power_vec_entry  const  range_1[5U]  = {      {{1U, 0U, 0U, 204800U, 512000U, {1U, 2U, 3U, 4U, 4U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 204800U, 307200U, {1U, 2U, 3U, 4U, 7U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 102400U, {2U, 4U, 6U, 7U, 9U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 25600U, {2U, 4U, 6U, 9U, 10U}, 0U}, 1U}, 
        {{1U, 0U, 0U, 25600U, 25600U, {2U, 4U, 6U, 10U, 10U}, 0U}, 2U}};
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static struct iwl_power_vec_entry  const  range_2[5U]  = {      {{1U, 0U, 0U, 204800U, 512000U, {1U, 2U, 3U, 4U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 204800U, 307200U, {2U, 4U, 6U, 7U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 102400U, {2U, 7U, 9U, 9U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 25600U, {2U, 7U, 9U, 9U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 25600U, 25600U, {4U, 7U, 10U, 10U, 255U}, 0U}, 0U}};
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static struct iwl_power_vec_entry  const  apm_range_0[5U]  = {      {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 6U, 8U, 255U}, 2U}, 2U}};
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static struct iwl_power_vec_entry  const  apm_range_1[5U]  = {      {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 6U, 8U, 255U}, 0U}, 2U}};
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static struct iwl_power_vec_entry  const  apm_range_2[5U]  = {      {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 6U, 8U, 255U}, 2U}, 2U}};
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static void iwl_static_sleep_cmd(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd ,
                                 enum iwl_power_level lvl , int period ) 
{ 
  struct iwl_power_vec_entry  const  *table ;
  int max_sleep[5U] ;
  unsigned int tmp ;
  int i ;
  u8 skip ;
  u32 slp_itrvl ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;

  {
#line 164
  max_sleep[0] = 0;
#line 164
  tmp = 1U;
#line 164
  while (1) {
#line 164
    if (tmp >= 5U) {
#line 164
      break;
    } else {

    }
#line 164
    max_sleep[tmp] = 0;
#line 164
    tmp = tmp + 1U;
  }
#line 169
  if ((int )(priv->lib)->adv_pm) {
#line 170
    table = (struct iwl_power_vec_entry  const  *)(& apm_range_2);
#line 171
    if (period <= 10) {
#line 172
      table = (struct iwl_power_vec_entry  const  *)(& apm_range_1);
    } else {

    }
#line 173
    if (period <= 2) {
#line 174
      table = (struct iwl_power_vec_entry  const  *)(& apm_range_0);
    } else {

    }
  } else {
#line 176
    table = (struct iwl_power_vec_entry  const  *)(& range_2);
#line 177
    if (period <= 10) {
#line 178
      table = (struct iwl_power_vec_entry  const  *)(& range_1);
    } else {

    }
#line 179
    if (period <= 2) {
#line 180
      table = (struct iwl_power_vec_entry  const  *)(& range_0);
    } else {

    }
  }
#line 183
  __ret_warn_on = (unsigned int )lvl > 4U;
#line 183
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 183
  if (tmp___0 != 0L) {
#line 183
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c",
                       183);
  } else {

  }
#line 183
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 183
  if (tmp___1 != 0L) {
#line 184
    memset((void *)cmd, 0, 36UL);
  } else {
#line 186
    *cmd = (table + (unsigned long )lvl)->cmd;
  }
#line 188
  if (period == 0) {
#line 189
    skip = 0U;
#line 190
    period = 1;
#line 191
    i = 0;
#line 191
    goto ldv_55148;
    ldv_55147: 
#line 192
    max_sleep[i] = 1;
#line 191
    i = i + 1;
    ldv_55148: ;
#line 191
    if (i <= 4) {
#line 193
      goto ldv_55147;
    } else {

    }

  } else {
#line 195
    skip = (table + (unsigned long )lvl)->no_dtim;
#line 196
    i = 0;
#line 196
    goto ldv_55151;
    ldv_55150: 
#line 197
    max_sleep[i] = (int )cmd->sleep_interval[i];
#line 196
    i = i + 1;
    ldv_55151: ;
#line 196
    if (i <= 4) {
#line 198
      goto ldv_55150;
    } else {

    }
#line 198
    max_sleep[4] = (int )skip + 1;
  }
#line 201
  slp_itrvl = cmd->sleep_interval[4];
#line 203
  if (slp_itrvl == 255U) {
#line 204
    cmd->sleep_interval[4] = (unsigned int )(((int )skip + 1) * period);
  } else {

  }
#line 207
  slp_itrvl = cmd->sleep_interval[4];
#line 208
  if ((u32 )period < slp_itrvl) {
#line 209
    cmd->sleep_interval[4] = (slp_itrvl / (u32 )period) * (u32 )period;
  } else {

  }
#line 212
  if ((unsigned int )skip != 0U) {
#line 213
    cmd->flags = (__le16 )((unsigned int )cmd->flags | 4U);
  } else {
#line 215
    cmd->flags = (unsigned int )cmd->flags & 65531U;
  }
#line 217
  if ((int )((priv->cfg)->base_params)->shadow_reg_enable) {
#line 218
    cmd->flags = (__le16 )((unsigned int )cmd->flags | 64U);
  } else {
#line 220
    cmd->flags = (unsigned int )cmd->flags & 65471U;
  }
#line 222
  tmp___2 = iwl_advanced_bt_coexist(priv);
#line 222
  if ((int )tmp___2) {
#line 223
    if (! ((_Bool )((priv->lib)->bt_params)->bt_sco_disable)) {
#line 224
      cmd->flags = (__le16 )((unsigned int )cmd->flags | 256U);
    } else {
#line 226
      cmd->flags = (unsigned int )cmd->flags & 65279U;
    }
  } else {

  }
#line 230
  slp_itrvl = cmd->sleep_interval[4];
#line 231
  if (slp_itrvl > 10U) {
#line 232
    cmd->sleep_interval[4] = 10U;
  } else {

  }
#line 236
  i = 4;
#line 236
  goto ldv_55154;
  ldv_55153: ;
#line 237
  if (cmd->sleep_interval[i] > (__le32 )(max_sleep[i] * period)) {
#line 239
    cmd->sleep_interval[i] = (unsigned int )(max_sleep[i] * period);
  } else {

  }
#line 241
  if (i != 4) {
#line 242
    if (cmd->sleep_interval[i] > cmd->sleep_interval[i + 1]) {
#line 244
      cmd->sleep_interval[i] = cmd->sleep_interval[i + 1];
    } else {

    }
  } else {

  }
#line 236
  i = i - 1;
  ldv_55154: ;
#line 236
  if (i >= 0) {
#line 238
    goto ldv_55153;
  } else {

  }

#line 249
  if ((int )priv->power_data.bus_pm) {
#line 250
    cmd->flags = (__le16 )((unsigned int )cmd->flags | 8U);
  } else {
#line 252
    cmd->flags = (unsigned int )cmd->flags & 65527U;
  }
#line 254
  __iwl_dbg(priv->dev, 256U, 0, "iwl_static_sleep_cmd", "numSkipDtim = %u, dtimPeriod = %d\n",
            (int )skip, period);
#line 258
  __iwl_dbg(priv->dev, 256U, 0, "iwl_static_sleep_cmd", "Sleep command for index %d\n",
            (unsigned int )lvl + 1U);
#line 259
  return;
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static void iwl_power_sleep_cam_cmd(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd ) 
{ 


  {
#line 264
  memset((void *)cmd, 0, 36UL);
#line 266
  if ((int )priv->power_data.bus_pm) {
#line 267
    cmd->flags = (__le16 )((unsigned int )cmd->flags | 8U);
  } else {

  }
#line 269
  __iwl_dbg(priv->dev, 256U, 0, "iwl_power_sleep_cam_cmd", "Sleep command for CAM\n");
#line 270
  return;
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static int iwl_set_power(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd ) 
{ 
  int tmp ;

  {
#line 274
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Sending power/sleep command\n");
#line 275
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Flags value = 0x%08X\n", (int )cmd->flags);
#line 276
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Tx timeout = %u\n", cmd->tx_data_timeout);
#line 277
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Rx timeout = %u\n", cmd->rx_data_timeout);
#line 278
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Sleep interval vector = { %d , %d , %d , %d , %d }\n",
            cmd->sleep_interval[0], cmd->sleep_interval[1], cmd->sleep_interval[2],
            cmd->sleep_interval[3], cmd->sleep_interval[4]);
#line 285
  tmp = iwl_dvm_send_cmd_pdu(priv, 119, 0U, 36, (void const   *)cmd);
#line 285
  return (tmp);
}
}
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
static void iwl_power_build_cmd(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd ) 
{ 
  bool enabled ;
  int dtimper ;
  u8 tmp ;
  bool tmp___0 ;

  {
#line 292
  enabled = ((priv->hw)->conf.flags & 2U) != 0U;
#line 295
  if ((int )force_cam) {
#line 296
    iwl_power_sleep_cam_cmd(priv, cmd);
#line 297
    return;
  } else {

  }
#line 300
  dtimper = (int )(priv->hw)->conf.ps_dtim_period != 0 ? (int )(priv->hw)->conf.ps_dtim_period != 0 : 1;
#line 302
  if ((int )priv->wowlan) {
#line 303
    iwl_static_sleep_cmd(priv, cmd, 4, dtimper);
  } else
#line 304
  if (! ((_Bool )(priv->lib)->no_idle_support) && ((priv->hw)->conf.flags & 4U) != 0U) {
#line 306
    iwl_static_sleep_cmd(priv, cmd, 4, 20);
  } else {
#line 307
    tmp___0 = iwl_tt_is_low_power_state(priv);
#line 307
    if ((int )tmp___0) {
#line 309
      tmp = iwl_tt_current_power_mode(priv);
#line 309
      iwl_static_sleep_cmd(priv, cmd, (enum iwl_power_level )tmp, dtimper);
    } else
#line 311
    if (! enabled) {
#line 312
      iwl_power_sleep_cam_cmd(priv, cmd);
    } else
#line 313
    if (priv->power_data.debug_sleep_level_override >= 0) {
#line 314
      iwl_static_sleep_cmd(priv, cmd, (enum iwl_power_level )priv->power_data.debug_sleep_level_override,
                           dtimper);
    } else
#line 320
    if (iwlwifi_mod_params.power_level > 0 && iwlwifi_mod_params.power_level <= 5) {
#line 322
      iwl_static_sleep_cmd(priv, cmd, (enum iwl_power_level )(iwlwifi_mod_params.power_level + -1),
                           dtimper);
    } else {
#line 325
      iwl_static_sleep_cmd(priv, cmd, 0, dtimper);
    }
  }
#line 326
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
int iwl_power_set_mode(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd , bool force ) 
{ 
  int ret ;
  bool update_chains ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 336
  if (debug_locks != 0) {
#line 336
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 336
    if (tmp == 0) {
#line 336
      tmp___0 = 1;
    } else {
#line 336
      tmp___0 = 0;
    }
  } else {
#line 336
    tmp___0 = 0;
  }
#line 336
  __ret_warn_on = tmp___0;
#line 336
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 336
  if (tmp___1 != 0L) {
#line 336
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c",
                       336);
  } else {

  }
#line 336
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 339
  update_chains = (bool )((unsigned int )priv->chain_noise_data.state == 3U || (unsigned int )priv->chain_noise_data.state == 0U);
#line 342
  tmp___2 = memcmp((void const   *)(& priv->power_data.sleep_cmd), (void const   *)cmd,
                   36UL);
#line 342
  if (tmp___2 == 0 && ! force) {
#line 343
    return (0);
  } else {

  }
#line 345
  tmp___3 = iwl_is_ready_rf(priv);
#line 345
  if (tmp___3 == 0) {
#line 346
    return (-5);
  } else {

  }
#line 349
  memcpy((void *)(& priv->power_data.sleep_cmd_next), (void const   *)cmd, 36UL);
#line 350
  tmp___4 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 350
  if (tmp___4 != 0 && ! force) {
#line 351
    __iwl_dbg(priv->dev, 1U, 0, "iwl_power_set_mode", "Defer power set mode while scanning\n");
#line 352
    return (0);
  } else {

  }
#line 355
  if ((int )cmd->flags & 1) {
#line 356
    iwl_dvm_set_pmi(priv, 1);
  } else {

  }
#line 358
  ret = iwl_set_power(priv, cmd);
#line 359
  if (ret == 0) {
#line 360
    if (((int )cmd->flags & 1) == 0) {
#line 361
      iwl_dvm_set_pmi(priv, 0);
    } else {

    }
#line 363
    if ((int )update_chains) {
#line 364
      iwl_update_chain_flags(priv);
    } else {
#line 366
      __iwl_dbg(priv->dev, 256U, 0, "iwl_power_set_mode", "Cannot update the power, chain noise calibration running: %d\n",
                (int )priv->chain_noise_data.state);
    }
#line 371
    memcpy((void *)(& priv->power_data.sleep_cmd), (void const   *)cmd, 36UL);
  } else {
#line 373
    __iwl_err(priv->dev, 0, 0, "set power fail, ret = %d\n", ret);
  }
#line 375
  return (ret);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
int iwl_power_update_mode(struct iwl_priv *priv , bool force ) 
{ 
  struct iwl_powertable_cmd cmd ;
  int tmp ;

  {
#line 382
  iwl_power_build_cmd(priv, & cmd);
#line 383
  tmp = iwl_power_set_mode(priv, & cmd, (int )force);
#line 383
  return (tmp);
}
}
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.c"
void iwl_power_initialize(struct iwl_priv *priv ) 
{ 


  {
#line 389
  priv->power_data.bus_pm = (priv->trans)->pm_support;
#line 391
  priv->power_data.debug_sleep_level_override = -1;
#line 393
  memset((void *)(& priv->power_data.sleep_cmd), 0, 36UL);
#line 394
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
bool ldv_queue_work_on_451(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 577
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_work_7(ldv_func_arg3, 2);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
bool ldv_queue_delayed_work_on_452(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_work_7(& ldv_func_arg3->work, 2);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
bool ldv_queue_work_on_453(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_7(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
void ldv_flush_workqueue_454(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 609
  flush_workqueue(ldv_func_arg1);
#line 611
  call_and_disable_all_7(2);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
bool ldv_queue_delayed_work_on_455(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 618
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 618
  ldv_func_res = tmp;
#line 620
  activate_work_7(& ldv_func_arg3->work, 2);
#line 622
  return (ldv_func_res);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
void ldv_mutex_lock_456(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 638
  mutex_unlock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
void ldv_mutex_lock_458(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 646
  mutex_lock(ldv_func_arg1);
#line 647
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
int ldv_mutex_trylock_459(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
void ldv_mutex_unlock_460(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 665
  mutex_unlock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
void ldv_mutex_unlock_461(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 673
  mutex_unlock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/power.o.c.prepared"
void ldv_mutex_lock_462(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 681
  mutex_lock(ldv_func_arg1);
#line 682
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 437 "./arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_487(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_485(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_488(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_496(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_498(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_500(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_484(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_486(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_490(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_493(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_495(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_497(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_499(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) ;
#line 88 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 433
bool ldv_queue_work_on_479(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_481(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_480(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_483(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_482(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
bool ldv_cancel_work_sync_501(struct work_struct *ldv_func_arg1 ) ;
#line 471
bool ldv_cancel_work_sync_502(struct work_struct *ldv_func_arg1 ) ;
#line 475
bool ldv_cancel_work_sync_503(struct work_struct *ldv_func_arg1 ) ;
#line 479
extern bool cancel_delayed_work(struct delayed_work * ) ;
#line 482
bool ldv_cancel_delayed_work_491(struct delayed_work *ldv_func_arg1 ) ;
#line 486
bool ldv_cancel_delayed_work_492(struct delayed_work *ldv_func_arg1 ) ;
#line 488
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 491
bool ldv_cancel_delayed_work_sync_504(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___6(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_479(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_480(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_all_14(int state ) ;
#line 411
void call_and_disable_work_13(struct work_struct *work ) ;
#line 414
void activate_work_13(struct work_struct *work , int state ) ;
#line 421
void disable_work_14(struct work_struct *work ) ;
#line 424
void call_and_disable_all_11(int state ) ;
#line 438
void call_and_disable_all_12(int state ) ;
#line 441
void invoke_work_14(void) ;
#line 446
void invoke_work_11(void) ;
#line 453
void call_and_disable_work_14(struct work_struct *work ) ;
#line 457
void disable_work_13(struct work_struct *work ) ;
#line 471
void invoke_work_12(void) ;
#line 474
void call_and_disable_work_12(struct work_struct *work ) ;
#line 477
void activate_work_11(struct work_struct *work , int state ) ;
#line 481
void disable_work_11(struct work_struct *work ) ;
#line 482
void disable_work_12(struct work_struct *work ) ;
#line 502
void activate_work_12(struct work_struct *work , int state ) ;
#line 513
void invoke_work_13(void) ;
#line 533
void call_and_disable_work_11(struct work_struct *work ) ;
#line 537
void activate_work_14(struct work_struct *work , int state ) ;
#line 543
void call_and_disable_all_13(int state ) ;
#line 233 "include/linux/etherdevice.h"
__inline static void eth_broadcast_addr(u8 *addr ) 
{ 


  {
#line 235
  memset((void *)addr, 255, 6UL);
#line 236
  return;
}
}
#line 4516 "include/net/mac80211.h"
extern void ieee80211_scan_completed(struct ieee80211_hw * , bool  ) ;
#line 939 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
__inline static int iwl_is_any_associated___1(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
#line 942
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 942
  goto ldv_52525;
  ldv_52524: ;
#line 942
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 943
    tmp = iwl_is_associated_ctx(ctx);
#line 943
    if (tmp != 0) {
#line 944
      return (1);
    } else {

    }
  } else {

  }
#line 942
  ctx = ctx + 1;
  ldv_52525: ;
#line 942
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 944
    goto ldv_52524;
  } else {

  }

#line 945
  return (0);
}
}
#line 147 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
int iwlagn_set_pan_params(struct iwl_priv *priv ) ;
#line 189 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static struct ieee80211_supported_band  const  *iwl_get_hw_mode(struct iwl_priv *priv ,
                                                                         enum ieee80211_band band ) 
{ 


  {
#line 192
  return ((struct ieee80211_supported_band  const  *)((priv->hw)->wiphy)->bands[(unsigned int )band]);
}
}
#line 251
void iwlagn_post_scan(struct iwl_priv *priv ) ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static int iwl_send_scan_abort(struct iwl_priv *priv ) 
{ 
  int ret ;
  struct iwl_host_cmd cmd ;
  __le32 *status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 60
  cmd.data[0] = 0;
#line 60
  cmd.data[1] = 0;
#line 60
  cmd.resp_pkt = 0;
#line 60
  cmd._rx_page_addr = 0UL;
#line 60
  cmd._rx_page_order = 0U;
#line 60
  cmd.handler_status = 0;
#line 60
  cmd.flags = 2U;
#line 60
  cmd.len[0] = (unsigned short)0;
#line 60
  cmd.len[1] = (unsigned short)0;
#line 60
  cmd.dataflags[0] = (unsigned char)0;
#line 60
  cmd.dataflags[1] = (unsigned char)0;
#line 60
  cmd.id = 129U;
#line 69
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
#line 69
  if (tmp == 0) {
#line 72
    return (-5);
  } else {
#line 69
    tmp___0 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
#line 69
    if (tmp___0 == 0) {
#line 72
      return (-5);
    } else {
#line 69
      tmp___1 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->status));
#line 69
      if (tmp___1 != 0) {
#line 72
        return (-5);
      } else {

      }
    }
  }
#line 74
  ret = iwl_dvm_send_cmd(priv, & cmd);
#line 75
  if (ret != 0) {
#line 76
    return (ret);
  } else {

  }
#line 78
  status = (__le32 *)(& (cmd.resp_pkt)->data);
#line 79
  if (*status != 1U) {
#line 86
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_send_scan_abort", "SCAN_ABORT ret %d.\n",
              *status);
#line 88
    ret = -5;
  } else {

  }
#line 91
  iwl_free_resp(& cmd);
#line 92
  return (ret);
}
}
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static void iwl_complete_scan(struct iwl_priv *priv , bool aborted ) 
{ 


  {
#line 98
  if ((unsigned long )priv->scan_request != (unsigned long )((struct cfg80211_scan_request *)0)) {
#line 99
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_complete_scan", "Complete scan in mac80211\n");
#line 100
    ieee80211_scan_completed(priv->hw, (int )aborted);
  } else {

  }
#line 103
  priv->scan_type = 0;
#line 104
  priv->scan_vif = (struct ieee80211_vif *)0;
#line 105
  priv->scan_request = (struct cfg80211_scan_request *)0;
#line 106
  return;
}
}
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static void iwl_process_scan_complete(struct iwl_priv *priv ) 
{ 
  bool aborted ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int err ;
  int tmp___5 ;

  {
#line 112
  if (debug_locks != 0) {
#line 112
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 112
    if (tmp == 0) {
#line 112
      tmp___0 = 1;
    } else {
#line 112
      tmp___0 = 0;
    }
  } else {
#line 112
    tmp___0 = 0;
  }
#line 112
  __ret_warn_on = tmp___0;
#line 112
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 112
  if (tmp___1 != 0L) {
#line 112
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       112);
  } else {

  }
#line 112
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 114
  tmp___2 = test_and_clear_bit(12L, (unsigned long volatile   *)(& priv->status));
#line 114
  if (tmp___2 == 0) {
#line 115
    return;
  } else {

  }
#line 117
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_process_scan_complete", "Completed scan.\n");
#line 119
  ldv_cancel_delayed_work_491(& priv->scan_check);
#line 121
  tmp___3 = test_and_clear_bit(8L, (unsigned long volatile   *)(& priv->status));
#line 121
  aborted = tmp___3 != 0;
#line 122
  if ((int )aborted) {
#line 123
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_process_scan_complete", "Aborted scan completed.\n");
  } else {

  }
#line 125
  tmp___4 = test_and_clear_bit(7L, (unsigned long volatile   *)(& priv->status));
#line 125
  if (tmp___4 == 0) {
#line 126
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_process_scan_complete", "Scan already completed.\n");
#line 127
    goto out_settings;
  } else {

  }
#line 130
  if ((unsigned int )priv->scan_type != 0U && ! aborted) {
#line 134
    if ((unsigned long )priv->scan_request == (unsigned long )((struct cfg80211_scan_request *)0)) {
#line 135
      goto out_complete;
    } else {

    }
#line 138
    err = iwl_scan_initiate(priv, priv->scan_vif, 0, ((priv->scan_request)->channels[0])->band);
#line 140
    if (err != 0) {
#line 141
      __iwl_dbg(priv->dev, 2048U, 0, "iwl_process_scan_complete", "failed to initiate pending scan: %d\n",
                err);
#line 143
      aborted = 1;
#line 144
      goto out_complete;
    } else {

    }
#line 147
    return;
  } else {

  }
  out_complete: 
#line 151
  iwl_complete_scan(priv, (int )aborted);
  out_settings: 
#line 155
  tmp___5 = iwl_is_ready_rf(priv);
#line 155
  if (tmp___5 == 0) {
#line 156
    return;
  } else {

  }
#line 158
  iwlagn_post_scan(priv);
#line 159
  return;
}
}
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
void iwl_force_scan_end(struct iwl_priv *priv ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 163
  if (debug_locks != 0) {
#line 163
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 163
    if (tmp == 0) {
#line 163
      tmp___0 = 1;
    } else {
#line 163
      tmp___0 = 0;
    }
  } else {
#line 163
    tmp___0 = 0;
  }
#line 163
  __ret_warn_on = tmp___0;
#line 163
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 163
  if (tmp___1 != 0L) {
#line 163
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       163);
  } else {

  }
#line 163
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 165
  tmp___2 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 165
  if (tmp___2 == 0) {
#line 166
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_force_scan_end", "Forcing scan end while not scanning\n");
#line 167
    return;
  } else {

  }
#line 170
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_force_scan_end", "Forcing scan end\n");
#line 171
  clear_bit(7L, (unsigned long volatile   *)(& priv->status));
#line 172
  clear_bit(9L, (unsigned long volatile   *)(& priv->status));
#line 173
  clear_bit(8L, (unsigned long volatile   *)(& priv->status));
#line 174
  clear_bit(12L, (unsigned long volatile   *)(& priv->status));
#line 175
  iwl_complete_scan(priv, 1);
#line 176
  return;
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static void iwl_do_scan_abort(struct iwl_priv *priv ) 
{ 
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 182
  if (debug_locks != 0) {
#line 182
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 182
    if (tmp == 0) {
#line 182
      tmp___0 = 1;
    } else {
#line 182
      tmp___0 = 0;
    }
  } else {
#line 182
    tmp___0 = 0;
  }
#line 182
  __ret_warn_on = tmp___0;
#line 182
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 182
  if (tmp___1 != 0L) {
#line 182
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       182);
  } else {

  }
#line 182
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 184
  tmp___2 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 184
  if (tmp___2 == 0) {
#line 185
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_do_scan_abort", "Not performing scan to abort\n");
#line 186
    return;
  } else {

  }
#line 189
  tmp___3 = test_and_set_bit(8L, (unsigned long volatile   *)(& priv->status));
#line 189
  if (tmp___3 != 0) {
#line 190
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_do_scan_abort", "Scan abort in progress\n");
#line 191
    return;
  } else {

  }
#line 194
  ret = iwl_send_scan_abort(priv);
#line 195
  if (ret != 0) {
#line 196
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_do_scan_abort", "Send scan abort failed %d\n",
              ret);
#line 197
    iwl_force_scan_end(priv);
  } else {
#line 199
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_do_scan_abort", "Successfully send scan abort\n");
  }
#line 200
  return;
}
}
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
int iwl_scan_cancel(struct iwl_priv *priv ) 
{ 


  {
#line 207
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_cancel", "Queuing abort scan\n");
#line 208
  queue_work___6(priv->workqueue, & priv->abort_scan);
#line 209
  return (0);
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
void iwl_scan_cancel_timeout(struct iwl_priv *priv , unsigned long ms ) 
{ 
  unsigned long timeout ;
  unsigned long tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 219
  tmp = msecs_to_jiffies((unsigned int const   )ms);
#line 219
  timeout = tmp + (unsigned long )jiffies;
#line 221
  if (debug_locks != 0) {
#line 221
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
#line 221
    if (tmp___0 == 0) {
#line 221
      tmp___1 = 1;
    } else {
#line 221
      tmp___1 = 0;
    }
  } else {
#line 221
    tmp___1 = 0;
  }
#line 221
  __ret_warn_on = tmp___1;
#line 221
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 221
  if (tmp___2 != 0L) {
#line 221
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       221);
  } else {

  }
#line 221
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 223
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_cancel_timeout", "Scan cancel timeout\n");
#line 225
  iwl_do_scan_abort(priv);
#line 227
  goto ldv_52983;
  ldv_52982: 
#line 228
  tmp___3 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
#line 228
  if (tmp___3 == 0) {
#line 229
    goto finished;
  } else {

  }
#line 230
  msleep(20U);
  ldv_52983: ;
#line 227
  if ((long )(timeout - (unsigned long )jiffies) >= 0L) {
#line 229
    goto ldv_52982;
  } else {

  }

#line 233
  return;
  finished: 
#line 246
  iwl_process_scan_complete(priv);
#line 247
  return;
}
}
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static int iwl_rx_reply_scan(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                             struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_scanreq_notification *notif ;

  {
#line 255
  tmp = rxb_addr(rxb);
#line 255
  pkt = (struct iwl_rx_packet *)tmp;
#line 256
  notif = (struct iwl_scanreq_notification *)(& pkt->data);
#line 258
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_reply_scan", "Scan request status = 0x%x\n",
            notif->status);
#line 260
  return (0);
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static int iwl_rx_scan_start_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                   struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_scanstart_notification *notif ;

  {
#line 268
  tmp = rxb_addr(rxb);
#line 268
  pkt = (struct iwl_rx_packet *)tmp;
#line 269
  notif = (struct iwl_scanstart_notification *)(& pkt->data);
#line 271
  priv->scan_start_tsf = (unsigned long )notif->tsf_low;
#line 272
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_scan_start_notif", "Scan start: %d [802.11%s] (TSF: 0x%08X:%08X) - %d (beacon timer %u)\n",
            (int )notif->channel, (unsigned int )notif->band != 0U ? (char *)"bg" : (char *)"a",
            notif->tsf_high, notif->tsf_low, notif->status, notif->beacon_timer);
#line 281
  return (0);
}
}
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static int iwl_rx_scan_results_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                     struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_scanresults_notification *notif ;

  {
#line 290
  tmp = rxb_addr(rxb);
#line 290
  pkt = (struct iwl_rx_packet *)tmp;
#line 291
  notif = (struct iwl_scanresults_notification *)(& pkt->data);
#line 293
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_scan_results_notif", "Scan ch.res: %d [802.11%s] probe status: %u:%u (TSF: 0x%08X:%08X) - %d elapsed=%lu usec\n",
            (int )notif->channel, (unsigned int )notif->band != 0U ? (char *)"bg" : (char *)"a",
            (int )notif->probe_status, (int )notif->num_probe_not_sent, notif->tsf_high,
            notif->tsf_low, notif->statistics[0], (unsigned long )notif->tsf_low - priv->scan_start_tsf);
#line 306
  return (0);
}
}
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static int iwl_rx_scan_complete_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                      struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_scancomplete_notification *scan_notif ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
#line 314
  tmp = rxb_addr(rxb);
#line 314
  pkt = (struct iwl_rx_packet *)tmp;
#line 315
  scan_notif = (struct iwl_scancomplete_notification *)(& pkt->data);
#line 317
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_scan_complete_notif", "Scan complete: %d channels (TSF 0x%08X:%08X) - %d\n",
            (int )scan_notif->scanned_channels, scan_notif->tsf_low, scan_notif->tsf_high,
            (int )scan_notif->status);
#line 322
  tmp___0 = jiffies_to_msecs((unsigned long )jiffies - priv->scan_start);
#line 322
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_scan_complete_notif", "Scan on %sGHz took %dms\n",
            (unsigned int )priv->scan_band == 0U ? (char *)"2.4" : (char *)"5.2",
            tmp___0);
#line 334
  set_bit(12L, (unsigned long volatile   *)(& priv->status));
#line 335
  clear_bit(9L, (unsigned long volatile   *)(& priv->status));
#line 336
  queue_work___6(priv->workqueue, & priv->scan_completed);
#line 338
  if ((unsigned int )priv->iw_mode != 1U) {
#line 338
    tmp___1 = iwl_advanced_bt_coexist(priv);
#line 338
    if ((int )tmp___1) {
#line 338
      if ((int )priv->bt_status != (int )scan_notif->bt_status) {
#line 341
        if ((unsigned int )scan_notif->bt_status != 0U) {
#line 343
          if (! priv->bt_ch_announce) {
#line 344
            priv->bt_traffic_load = 2U;
          } else {

          }
        } else {
#line 352
          priv->bt_traffic_load = 0U;
        }
#line 355
        priv->bt_status = scan_notif->bt_status;
#line 356
        queue_work___6(priv->workqueue, & priv->bt_traffic_change_work);
      } else {

      }
    } else {

    }
  } else {

  }
#line 359
  return (0);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
void iwl_setup_rx_scan_handlers(struct iwl_priv *priv ) 
{ 


  {
#line 365
  priv->rx_handlers[128] = & iwl_rx_reply_scan;
#line 366
  priv->rx_handlers[130] = & iwl_rx_scan_start_notif;
#line 367
  priv->rx_handlers[131] = & iwl_rx_scan_results_notif;
#line 369
  priv->rx_handlers[132] = & iwl_rx_scan_complete_notif;
#line 371
  return;
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static u16 iwl_get_active_dwell_time(struct iwl_priv *priv , enum ieee80211_band band ,
                                     u8 n_probes ) 
{ 


  {
#line 376
  if ((unsigned int )band == 1U) {
#line 377
    return ((unsigned int )((u16 )((int )n_probes + 11)) * 2U);
  } else {
#line 380
    return ((unsigned int )((u16 )((int )n_probes + 1)) * 3U + 30U);
  }
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static u16 iwl_limit_dwell(struct iwl_priv *priv , u16 dwell_time ) 
{ 
  struct iwl_rxon_context *ctx ;
  int limits[2U] ;
  int n_active ;
  u16 limit ;
  int tmp ;
  int tmp___0 ;
  u16 _min1 ;
  u16 _min2 ;
  u16 _min1___0 ;
  u16 _min2___0 ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 387
  limits[0] = 0;
#line 387
  limits[1] = 0;
#line 388
  n_active = 0;
#line 401
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 401
  goto ldv_53041;
  ldv_53040: ;
#line 401
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 402
    switch ((int )ctx->staging.dev_type) {
    case 9: ;
#line 405
    goto ldv_53034;
    case 3: ;
    default: 
#line 409
    tmp = iwl_is_associated_ctx(ctx);
#line 409
    if (tmp == 0) {
#line 410
      goto ldv_53034;
    } else {

    }
#line 411
    goto ldv_53037;
    case 7: ;
    case 8: ;
#line 418
    goto ldv_53037;
    }
    ldv_53037: 
#line 421
    tmp___0 = n_active;
#line 421
    n_active = n_active + 1;
#line 421
    limits[tmp___0] = ctx->beacon_int != 0 ? ctx->beacon_int != 0 : 100;
  } else {

  }
  ldv_53034: 
#line 401
  ctx = ctx + 1;
  ldv_53041: ;
#line 401
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 403
    goto ldv_53040;
  } else {

  }

#line 424
  switch (n_active) {
  case 0: ;
#line 426
  return (dwell_time);
  case 2: 
#line 428
  limit = (unsigned int )((u16 )((limits[1] * 98) / 100)) + 65526U;
#line 429
  limit = (u16 )((unsigned int )limit / 2U);
#line 430
  _min1 = limit;
#line 430
  _min2 = dwell_time;
#line 430
  dwell_time = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
  case 1: 
#line 433
  limit = (unsigned int )((u16 )((limits[0] * 98) / 100)) + 65526U;
#line 434
  limit = (u16 )((int )limit / n_active);
#line 435
  _min1___0 = limit;
#line 435
  _min2___0 = dwell_time;
#line 435
  return ((u16 )((int )_min1___0 < (int )_min2___0 ? _min1___0 : _min2___0));
  default: 
#line 437
  __ret_warn_once = 1;
#line 437
  tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 437
  if (tmp___3 != 0L) {
#line 437
    __ret_warn_on = ! __warned;
#line 437
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 437
    if (tmp___1 != 0L) {
#line 437
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                         437);
    } else {

    }
#line 437
    tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 437
    if (tmp___2 != 0L) {
#line 437
      __warned = 1;
    } else {

    }
  } else {

  }
#line 437
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 438
  return (dwell_time);
  }
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static u16 iwl_get_passive_dwell_time(struct iwl_priv *priv , enum ieee80211_band band ) 
{ 
  u16 passive ;
  u16 tmp ;

  {
#line 445
  passive = (unsigned int )band == 0U ? 120U : 110U;
#line 449
  tmp = iwl_limit_dwell(priv, (int )passive);
#line 449
  return (tmp);
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static u8 iwl_get_single_channel_number(struct iwl_priv *priv , enum ieee80211_band band ) 
{ 
  struct ieee80211_supported_band *sband ;
  struct iwl_rxon_context *ctx ;
  int i ;
  bool busy ;

  {
#line 456
  sband = ((priv->hw)->wiphy)->bands[(unsigned int )band];
#line 460
  i = 0;
#line 460
  goto ldv_53076;
  ldv_53075: 
#line 461
  busy = 0;
#line 463
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 463
  goto ldv_53073;
  ldv_53072: ;
#line 463
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 464
    busy = (int )(sband->channels + (unsigned long )i)->hw_value == (int )ctx->staging.channel;
#line 466
    if ((int )busy) {
#line 467
      goto ldv_53071;
    } else {

    }
  } else {

  }
#line 463
  ctx = ctx + 1;
  ldv_53073: ;
#line 463
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 465
    goto ldv_53072;
  } else {

  }
  ldv_53071: ;
#line 470
  if ((int )busy) {
#line 471
    goto ldv_53074;
  } else {

  }
#line 473
  if (((sband->channels + (unsigned long )i)->flags & 1U) == 0U) {
#line 474
    return ((u8 )(sband->channels + (unsigned long )i)->hw_value);
  } else {

  }
  ldv_53074: 
#line 460
  i = i + 1;
  ldv_53076: ;
#line 460
  if (sband->n_channels > i) {
#line 462
    goto ldv_53075;
  } else {

  }

#line 477
  return (0U);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static int iwl_get_channel_for_reset_scan(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                                          enum ieee80211_band band , struct iwl_scan_channel *scan_ch ) 
{ 
  struct ieee80211_supported_band  const  *sband ;
  u16 channel ;
  u8 tmp ;

  {
#line 488
  sband = iwl_get_hw_mode(priv, band);
#line 489
  if ((unsigned long )sband == (unsigned long )((struct ieee80211_supported_band  const  *)0)) {
#line 490
    __iwl_err(priv->dev, 0, 0, "invalid band\n");
#line 491
    return (0);
  } else {

  }
#line 494
  tmp = iwl_get_single_channel_number(priv, band);
#line 494
  channel = (u16 )tmp;
#line 495
  if ((unsigned int )channel != 0U) {
#line 496
    scan_ch->channel = channel;
#line 497
    scan_ch->type = 0U;
#line 498
    scan_ch->active_dwell = 5U;
#line 500
    scan_ch->passive_dwell = 5U;
#line 503
    scan_ch->dsp_atten = 110U;
#line 504
    if ((unsigned int )band == 1U) {
#line 505
      scan_ch->tx_gain = 59U;
    } else {
#line 507
      scan_ch->tx_gain = 40U;
    }
#line 508
    return (1);
  } else {

  }
#line 511
  __iwl_err(priv->dev, 0, 0, "no valid channel found\n");
#line 512
  return (0);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static int iwl_get_channels_for_scan(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                                     enum ieee80211_band band , u8 is_active , u8 n_probes ,
                                     struct iwl_scan_channel *scan_ch ) 
{ 
  struct ieee80211_channel *chan ;
  struct ieee80211_supported_band  const  *sband ;
  u16 passive_dwell ;
  u16 active_dwell ;
  int added ;
  int i ;
  u16 channel ;

  {
#line 523
  passive_dwell = 0U;
#line 524
  active_dwell = 0U;
#line 528
  sband = iwl_get_hw_mode(priv, band);
#line 529
  if ((unsigned long )sband == (unsigned long )((struct ieee80211_supported_band  const  *)0)) {
#line 530
    return (0);
  } else {

  }
#line 532
  active_dwell = iwl_get_active_dwell_time(priv, band, (int )n_probes);
#line 533
  passive_dwell = iwl_get_passive_dwell_time(priv, band);
#line 535
  if ((int )passive_dwell <= (int )active_dwell) {
#line 536
    passive_dwell = (unsigned int )active_dwell + 1U;
  } else {

  }
#line 538
  i = 0;
#line 538
  added = 0;
#line 538
  goto ldv_53104;
  ldv_53103: 
#line 539
  chan = (priv->scan_request)->channels[i];
#line 541
  if ((unsigned int )chan->band != (unsigned int )band) {
#line 542
    goto ldv_53101;
  } else {

  }
#line 544
  channel = chan->hw_value;
#line 545
  scan_ch->channel = channel;
#line 547
  if ((unsigned int )is_active == 0U || (chan->flags & 2U) != 0U) {
#line 548
    scan_ch->type = 0U;
  } else {
#line 550
    scan_ch->type = 1U;
  }
#line 552
  if ((unsigned int )n_probes != 0U) {
#line 553
    scan_ch->type = scan_ch->type | ((unsigned int )(1UL << (int )n_probes) | ((unsigned int )(1UL << (int )n_probes) - 2U));
  } else {

  }
#line 555
  scan_ch->active_dwell = active_dwell;
#line 556
  scan_ch->passive_dwell = passive_dwell;
#line 559
  scan_ch->dsp_atten = 110U;
#line 565
  if ((unsigned int )band == 1U) {
#line 566
    scan_ch->tx_gain = 59U;
  } else {
#line 568
    scan_ch->tx_gain = 40U;
  }
#line 570
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_get_channels_for_scan", "Scanning ch=%d prob=0x%X [%s %d]\n",
            (int )channel, scan_ch->type, (int )scan_ch->type & 1 ? (char *)"ACTIVE" : (char *)"PASSIVE",
            (int )scan_ch->type & 1 ? (int )active_dwell : (int )passive_dwell);
#line 577
  scan_ch = scan_ch + 1;
#line 578
  added = added + 1;
  ldv_53101: 
#line 538
  i = i + 1;
  ldv_53104: ;
#line 538
  if ((u32 )i < (priv->scan_request)->n_channels) {
#line 540
    goto ldv_53103;
  } else {

  }
#line 581
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_get_channels_for_scan", "total channels to scan %d\n",
            added);
#line 582
  return (added);
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static u16 iwl_fill_probe_req(struct ieee80211_mgmt *frame , u8 const   *ta , u8 const   *ies ,
                              int ie_len , u8 const   *ssid , u8 ssid_len , int left ) 
{ 
  int len ;
  u8 *pos ;
  u8 *tmp ;
  u8 *tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 593
  len = 0;
#line 594
  pos = (u8 *)0U;
#line 598
  left = left + -24;
#line 599
  if (left < 0) {
#line 600
    return (0U);
  } else {

  }
#line 602
  frame->frame_control = 64U;
#line 603
  eth_broadcast_addr((u8 *)(& frame->da));
#line 604
  memcpy((void *)(& frame->sa), (void const   *)ta, 6UL);
#line 605
  eth_broadcast_addr((u8 *)(& frame->bssid));
#line 606
  frame->seq_ctrl = 0U;
#line 608
  len = len + 24;
#line 611
  pos = (u8 *)(& frame->u.probe_req.variable);
#line 614
  left = (-2 - (int )ssid_len) + left;
#line 615
  if (left < 0) {
#line 616
    return (0U);
  } else {

  }
#line 617
  tmp = pos;
#line 617
  pos = pos + 1;
#line 617
  *tmp = 0U;
#line 618
  tmp___0 = pos;
#line 618
  pos = pos + 1;
#line 618
  *tmp___0 = ssid_len;
#line 619
  if ((unsigned long )ssid != (unsigned long )((u8 const   *)0U) && (unsigned int )ssid_len != 0U) {
#line 620
    memcpy((void *)pos, (void const   *)ssid, (size_t )ssid_len);
#line 621
    pos = pos + (unsigned long )ssid_len;
  } else {

  }
#line 624
  len = ((int )ssid_len + 2) + len;
#line 626
  __ret_warn_on = left < ie_len;
#line 626
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 626
  if (tmp___1 != 0L) {
#line 626
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       626);
  } else {

  }
#line 626
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 626
  if (tmp___2 != 0L) {
#line 627
    return ((u16 )len);
  } else {

  }
#line 629
  if ((unsigned long )ies != (unsigned long )((u8 const   *)0U) && ie_len != 0) {
#line 630
    memcpy((void *)pos, (void const   *)ies, (size_t )ie_len);
#line 631
    len = len + ie_len;
  } else {

  }
#line 634
  return ((u16 )len);
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static int iwlagn_request_scan(struct iwl_priv *priv , struct ieee80211_vif *vif ) 
{ 
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  struct iwl_scan_cmd *scan ;
  struct iwl_rxon_context *ctx ;
  u32 rate_flags ;
  u16 cmd_len ;
  u16 rx_chain ;
  enum ieee80211_band band ;
  u8 n_probes ;
  u8 rx_ant ;
  u8 rate ;
  bool is_active ;
  int chan_mod ;
  u8 active_chains ;
  u8 scan_tx_antennas ;
  int ret ;
  int scan_cmd_size ;
  u8 const   *ssid ;
  u8 ssid_len ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  u16 interval ;
  u32 extra ;
  u32 suspend_time ;
  u32 scan_suspend_time ;
  int tmp___5 ;
  int i ;
  int p ;
  u32 tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 639
  cmd.data[0] = 0;
#line 639
  cmd.data[1] = 0;
#line 639
  cmd.resp_pkt = 0;
#line 639
  cmd._rx_page_addr = 0UL;
#line 639
  cmd._rx_page_order = 0U;
#line 639
  cmd.handler_status = 0;
#line 639
  cmd.flags = 0U;
#line 639
  cmd.len[0] = 764U;
#line 639
  tmp = 1U;
#line 639
  while (1) {
#line 639
    if (tmp >= 2U) {
#line 639
      break;
    } else {

    }
#line 639
    cmd.len[tmp] = (unsigned short)0;
#line 639
    tmp = tmp + 1U;
  }
#line 639
  cmd.dataflags[0] = (unsigned char)0;
#line 639
  cmd.dataflags[1] = (unsigned char)0;
#line 639
  cmd.id = 128U;
#line 644
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 645
  rate_flags = 0U;
#line 646
  cmd_len = 0U;
#line 647
  rx_chain = 0U;
#line 649
  n_probes = 0U;
#line 650
  rx_ant = (priv->nvm_data)->valid_rx_ant;
#line 652
  is_active = 0;
#line 655
  scan_tx_antennas = (priv->nvm_data)->valid_tx_ant;
#line 657
  scan_cmd_size = (int )((unsigned int )(priv->fw)->ucode_capa.max_probe_length + 1364U);
#line 660
  ssid = (u8 const   *)0U;
#line 661
  ssid_len = 0U;
#line 663
  __ret_warn_on = (unsigned int )priv->scan_type == 0U && ((unsigned long )priv->scan_request == (unsigned long )((struct cfg80211_scan_request *)0) || (priv->scan_request)->n_channels > 50U);
#line 663
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 663
  if (tmp___0 != 0L) {
#line 663
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       665);
  } else {

  }
#line 663
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 663
  if (tmp___1 != 0L) {
#line 666
    return (-22);
  } else {

  }
#line 668
  if (debug_locks != 0) {
#line 668
    tmp___2 = lock_is_held(& priv->mutex.dep_map);
#line 668
    if (tmp___2 == 0) {
#line 668
      tmp___3 = 1;
    } else {
#line 668
      tmp___3 = 0;
    }
  } else {
#line 668
    tmp___3 = 0;
  }
#line 668
  __ret_warn_on___0 = tmp___3;
#line 668
  tmp___4 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 668
  if (tmp___4 != 0L) {
#line 668
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       668);
  } else {

  }
#line 668
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 670
  if ((unsigned long )vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 671
    ctx = iwl_rxon_ctx_from_vif(vif);
  } else {

  }
#line 673
  if ((unsigned long )priv->scan_cmd == (unsigned long )((void *)0)) {
#line 674
    priv->scan_cmd = kmalloc((size_t )scan_cmd_size, 208U);
#line 675
    if ((unsigned long )priv->scan_cmd == (unsigned long )((void *)0)) {
#line 676
      __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "fail to allocate memory for scan\n");
#line 678
      return (-12);
    } else {

    }
  } else {

  }
#line 681
  scan = (struct iwl_scan_cmd *)priv->scan_cmd;
#line 682
  memset((void *)scan, 0, (size_t )scan_cmd_size);
#line 684
  scan->quiet_plcp_th = 1U;
#line 685
  scan->quiet_time = 10U;
#line 687
  tmp___5 = iwl_is_any_associated___1(priv);
#line 687
  if (tmp___5 != 0) {
#line 688
    interval = 0U;
#line 690
    suspend_time = 100U;
#line 691
    scan_suspend_time = 100U;
#line 693
    __iwl_dbg(priv->dev, 1U, 0, "iwlagn_request_scan", "Scanning while associated...\n");
#line 694
    switch ((unsigned int )priv->scan_type) {
    case 1U: 
#line 696
    interval = 0U;
#line 697
    goto ldv_53151;
    case 0U: 
#line 699
    interval = vif->bss_conf.beacon_int;
#line 700
    goto ldv_53151;
    }
    ldv_53151: 
#line 703
    scan->suspend_time = 0U;
#line 704
    scan->max_out_time = 204800U;
#line 705
    if ((unsigned int )interval == 0U) {
#line 706
      interval = (u16 )suspend_time;
    } else {

    }
#line 708
    extra = suspend_time / (u32 )interval << 22;
#line 709
    scan_suspend_time = (suspend_time % (u32 )interval) * 1024U | extra;
#line 711
    scan->suspend_time = scan_suspend_time;
#line 712
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "suspend_time 0x%X beacon interval %d\n",
              scan_suspend_time, (int )interval);
  } else {

  }
#line 716
  switch ((unsigned int )priv->scan_type) {
  case 1U: 
#line 718
  __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "Start internal passive scan.\n");
#line 724
  scan->quiet_time = 5U;
#line 725
  goto ldv_53154;
  case 0U: ;
#line 727
  if ((priv->scan_request)->n_ssids != 0) {
#line 728
    p = 0;
#line 729
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "Kicking off active scan\n");
#line 734
    ssid_len = ((priv->scan_request)->ssids)->ssid_len;
#line 735
    ssid = (u8 const   *)(& ((priv->scan_request)->ssids)->ssid);
#line 741
    i = (priv->scan_request)->n_ssids + -1;
#line 741
    goto ldv_53159;
    ldv_53158: 
#line 742
    scan->direct_scan[p].id = 0U;
#line 743
    scan->direct_scan[p].len = ((priv->scan_request)->ssids + (unsigned long )i)->ssid_len;
#line 745
    memcpy((void *)(& scan->direct_scan[p].ssid), (void const   *)(& ((priv->scan_request)->ssids + (unsigned long )i)->ssid),
             (size_t )((priv->scan_request)->ssids + (unsigned long )i)->ssid_len);
#line 748
    n_probes = (u8 )((int )n_probes + 1);
#line 749
    p = p + 1;
#line 741
    i = i - 1;
    ldv_53159: ;
#line 741
    if (i > 0) {
#line 743
      goto ldv_53158;
    } else {

    }
#line 751
    is_active = 1;
  } else {
#line 753
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "Start passive scan.\n");
  }
#line 754
  goto ldv_53154;
  }
  ldv_53154: 
#line 757
  scan->tx_cmd.tx_flags = 8192U;
#line 758
  scan->tx_cmd.sta_id = ctx->bcast_sta_id;
#line 759
  scan->tx_cmd.stop_time.life_time = 4294967295U;
#line 761
  switch ((unsigned int )priv->scan_band) {
  case 0U: 
#line 763
  scan->flags = 5U;
#line 764
  chan_mod = (int )(((unsigned int )priv->contexts[0].active.flags & 100663296U) >> 25);
#line 768
  if (((unsigned long )priv->scan_request != (unsigned long )((struct cfg80211_scan_request *)0) && (int )(priv->scan_request)->no_cck) || chan_mod == 1) {
#line 770
    rate = 13U;
  } else {
#line 772
    rate = 10U;
#line 773
    rate_flags = 512U;
  }
#line 779
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 781
    scan->tx_cmd.tx_flags = scan->tx_cmd.tx_flags | 4096U;
  } else {

  }
#line 782
  goto ldv_53162;
  case 1U: 
#line 784
  rate = 13U;
#line 785
  goto ldv_53162;
  default: 
#line 787
  __iwl_warn(priv->dev, "Invalid scan band\n");
#line 788
  return (-5);
  }
  ldv_53162: ;
#line 812
  if ((int )priv->new_scan_threshold_behaviour) {
#line 813
    scan->good_CRC_th = (__le16 )is_active;
  } else {
#line 816
    scan->good_CRC_th = (int )is_active ? 1U : 65535U;
  }
#line 819
  band = priv->scan_band;
#line 821
  if (((unsigned int )band == 0U && (unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
#line 825
    scan_tx_antennas = first_antenna((int )scan_tx_antennas);
  } else {

  }
#line 828
  priv->scan_tx_ant[(unsigned int )band] = iwl_toggle_tx_ant(priv, (int )priv->scan_tx_ant[(unsigned int )band],
                                                             (int )scan_tx_antennas);
#line 831
  tmp___6 = iwl_ant_idx_to_flags((int )priv->scan_tx_ant[(unsigned int )band]);
#line 831
  rate_flags = tmp___6 | rate_flags;
#line 832
  scan->tx_cmd.rate_n_flags = iwl_hw_set_rate_n_flags((int )rate, rate_flags);
#line 838
  tmp___7 = constant_test_bit(13L, (unsigned long const volatile   *)(& priv->status));
#line 838
  if (tmp___7 != 0 && ((priv->hw)->conf.flags & 4U) == 0U) {
#line 841
    active_chains = (u8 )((int )((unsigned char )priv->chain_noise_data.active_chains) & (int )rx_ant);
#line 843
    if ((unsigned int )active_chains == 0U) {
#line 844
      active_chains = rx_ant;
    } else {

    }
#line 846
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "chain_noise_data.active_chains: %u\n",
              priv->chain_noise_data.active_chains);
#line 849
    rx_ant = first_antenna((int )active_chains);
  } else {

  }
#line 851
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && (int )priv->bt_full_concurrent) {
#line 855
    rx_ant = first_antenna((int )rx_ant);
  } else {

  }
#line 859
  rx_chain = (u16 )((int )((short )((int )(priv->nvm_data)->valid_rx_ant << 1)) | (int )((short )rx_chain));
#line 861
  rx_chain = (u16 )((int )((short )((int )rx_ant << 7)) | (int )((short )rx_chain));
#line 862
  rx_chain = (u16 )((int )((short )((int )rx_ant << 4)) | (int )((short )rx_chain));
#line 863
  rx_chain = (u16 )((unsigned int )rx_chain | 1U);
#line 864
  scan->rx_chain = rx_chain;
#line 865
  switch ((unsigned int )priv->scan_type) {
  case 0U: 
#line 867
  cmd_len = iwl_fill_probe_req((struct ieee80211_mgmt *)(& scan->data), (u8 const   *)(& vif->addr),
                               (priv->scan_request)->ie, (int )(priv->scan_request)->ie_len,
                               ssid, (int )ssid_len, (int )((unsigned int )scan_cmd_size - 764U));
#line 874
  goto ldv_53166;
  case 1U: 
#line 877
  cmd_len = iwl_fill_probe_req((struct ieee80211_mgmt *)(& scan->data), (u8 const   *)(& iwl_bcast_addr),
                               (u8 const   *)0U, 0, (u8 const   *)0U, 0, (int )((unsigned int )scan_cmd_size - 764U));
#line 882
  goto ldv_53166;
  default: 
#line 884
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"),
                       "i" (884), "i" (12UL));
  ldv_53169: ;
#line 884
  goto ldv_53169;
  }
  ldv_53166: 
#line 886
  scan->tx_cmd.len = cmd_len;
#line 888
  scan->filter_flags = scan->filter_flags | 68U;
#line 891
  switch ((unsigned int )priv->scan_type) {
  case 1U: 
#line 893
  tmp___8 = iwl_get_channel_for_reset_scan(priv, vif, band, (struct iwl_scan_channel *)(& scan->data) + (unsigned long )cmd_len);
#line 893
  scan->channel_count = (u8 )tmp___8;
#line 896
  goto ldv_53171;
  case 0U: 
#line 898
  tmp___9 = iwl_get_channels_for_scan(priv, vif, band, (int )is_active, (int )n_probes,
                                      (struct iwl_scan_channel *)(& scan->data) + (unsigned long )cmd_len);
#line 898
  scan->channel_count = (u8 )tmp___9;
#line 902
  goto ldv_53171;
  }
  ldv_53171: ;
#line 905
  if ((unsigned int )scan->channel_count == 0U) {
#line 906
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "channel count %d\n", (int )scan->channel_count);
#line 907
    return (-5);
  } else {

  }
#line 910
  cmd.len[0] = (unsigned int )cmd.len[0] + ((unsigned int )scan->tx_cmd.len + (unsigned int )((u16 )scan->channel_count) * 12U);
#line 912
  cmd.data[0] = (void const   *)scan;
#line 913
  cmd.dataflags[0] = 1U;
#line 914
  scan->len = cmd.len[0];
#line 917
  set_bit(9L, (unsigned long volatile   *)(& priv->status));
#line 919
  ret = iwlagn_set_pan_params(priv);
#line 920
  if (ret != 0) {
#line 921
    clear_bit(9L, (unsigned long volatile   *)(& priv->status));
#line 922
    return (ret);
  } else {

  }
#line 925
  ret = iwl_dvm_send_cmd(priv, & cmd);
#line 926
  if (ret != 0) {
#line 927
    clear_bit(9L, (unsigned long volatile   *)(& priv->status));
#line 928
    iwlagn_set_pan_params(priv);
  } else {

  }
#line 931
  return (ret);
}
}
#line 934 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
void iwl_init_scan_params(struct iwl_priv *priv ) 
{ 
  u8 ant_idx ;
  int tmp ;

  {
#line 936
  tmp = fls((int )(priv->nvm_data)->valid_tx_ant);
#line 936
  ant_idx = (unsigned int )((u8 )tmp) + 255U;
#line 937
  if ((unsigned int )priv->scan_tx_ant[1] == 0U) {
#line 938
    priv->scan_tx_ant[1] = ant_idx;
  } else {

  }
#line 939
  if ((unsigned int )priv->scan_tx_ant[0] == 0U) {
#line 940
    priv->scan_tx_ant[0] = ant_idx;
  } else {

  }
#line 941
  return;
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
int iwl_scan_initiate(struct iwl_priv *priv , struct ieee80211_vif *vif , enum iwl_scan_type scan_type ,
                      enum ieee80211_band band ) 
{ 
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 950
  if (debug_locks != 0) {
#line 950
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 950
    if (tmp == 0) {
#line 950
      tmp___0 = 1;
    } else {
#line 950
      tmp___0 = 0;
    }
  } else {
#line 950
    tmp___0 = 0;
  }
#line 950
  __ret_warn_on = tmp___0;
#line 950
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 950
  if (tmp___1 != 0L) {
#line 950
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       950);
  } else {

  }
#line 950
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 952
  ldv_cancel_delayed_work_492(& priv->scan_check);
#line 954
  tmp___2 = iwl_is_ready_rf(priv);
#line 954
  if (tmp___2 == 0) {
#line 955
    __iwl_warn(priv->dev, "Request scan called when driver not ready.\n");
#line 956
    return (-5);
  } else {

  }
#line 959
  tmp___3 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
#line 959
  if (tmp___3 != 0) {
#line 960
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_initiate", "Multiple concurrent scan requests in parallel.\n");
#line 962
    return (-16);
  } else {

  }
#line 965
  tmp___4 = constant_test_bit(8L, (unsigned long const volatile   *)(& priv->status));
#line 965
  if (tmp___4 != 0) {
#line 966
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_initiate", "Scan request while abort pending.\n");
#line 967
    return (-16);
  } else {

  }
#line 970
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_initiate", "Starting %sscan...\n", (unsigned int )scan_type == 0U ? (char *)"" : (char *)"internal short ");
#line 974
  set_bit(7L, (unsigned long volatile   *)(& priv->status));
#line 975
  priv->scan_type = scan_type;
#line 976
  priv->scan_start = jiffies;
#line 977
  priv->scan_band = band;
#line 979
  ret = iwlagn_request_scan(priv, vif);
#line 980
  if (ret != 0) {
#line 981
    clear_bit(7L, (unsigned long volatile   *)(& priv->status));
#line 982
    priv->scan_type = 0;
#line 983
    return (ret);
  } else {

  }
#line 986
  queue_delayed_work(priv->workqueue, & priv->scan_check, 3750UL);
#line 989
  return (0);
}
}
#line 997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
void iwl_internal_short_hw_scan(struct iwl_priv *priv ) 
{ 


  {
#line 999
  queue_work___6(priv->workqueue, & priv->start_internal_scan);
#line 1000
  return;
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static void iwl_bg_start_internal_scan(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 1005
  __mptr = (struct work_struct  const  *)work;
#line 1005
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcee8UL;
#line 1007
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_start_internal_scan", "Start internal scan\n");
#line 1009
  ldv_mutex_lock_493(& priv->mutex);
#line 1011
  if ((unsigned int )priv->scan_type == 1U) {
#line 1012
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_start_internal_scan", "Internal scan already in progress\n");
#line 1013
    goto unlock;
  } else {

  }
#line 1016
  tmp = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 1016
  if (tmp != 0) {
#line 1017
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_start_internal_scan", "Scan already in progress.\n");
#line 1018
    goto unlock;
  } else {

  }
#line 1021
  tmp___0 = iwl_scan_initiate(priv, (struct ieee80211_vif *)0, 1, priv->band);
#line 1021
  if (tmp___0 != 0) {
#line 1022
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_start_internal_scan", "failed to start internal short scan\n");
  } else {

  }
  unlock: 
#line 1024
  ldv_mutex_unlock_494(& priv->mutex);
#line 1025
  return;
}
}
#line 1027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static void iwl_bg_scan_check(struct work_struct *data ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
#line 1030
  __mptr = (struct work_struct  const  *)data;
#line 1030
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcda8UL;
#line 1032
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_scan_check", "Scan check work\n");
#line 1037
  ldv_mutex_lock_495(& priv->mutex);
#line 1038
  iwl_force_scan_end(priv);
#line 1039
  ldv_mutex_unlock_496(& priv->mutex);
#line 1040
  return;
}
}
#line 1042 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static void iwl_bg_abort_scan(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
#line 1044
  __mptr = (struct work_struct  const  *)work;
#line 1044
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd090UL;
#line 1046
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_abort_scan", "Abort scan work\n");
#line 1050
  ldv_mutex_lock_497(& priv->mutex);
#line 1051
  iwl_scan_cancel_timeout(priv, 200UL);
#line 1052
  ldv_mutex_unlock_498(& priv->mutex);
#line 1053
  return;
}
}
#line 1055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
static void iwl_bg_scan_completed(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
#line 1058
  __mptr = (struct work_struct  const  *)work;
#line 1058
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd0e0UL;
#line 1060
  ldv_mutex_lock_499(& priv->mutex);
#line 1061
  iwl_process_scan_complete(priv);
#line 1062
  ldv_mutex_unlock_500(& priv->mutex);
#line 1063
  return;
}
}
#line 1065 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
void iwl_setup_scan_deferred_work(struct iwl_priv *priv ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___2 ;
  atomic_long_t __constr_expr_3 ;
  struct lock_class_key __key___3 ;

  {
#line 1067
  __init_work(& priv->scan_completed, 0);
#line 1067
  __constr_expr_0.counter = 137438953408L;
#line 1067
  priv->scan_completed.data = __constr_expr_0;
#line 1067
  lockdep_init_map(& priv->scan_completed.lockdep_map, "(&priv->scan_completed)",
                   & __key, 0);
#line 1067
  INIT_LIST_HEAD(& priv->scan_completed.entry);
#line 1067
  priv->scan_completed.func = & iwl_bg_scan_completed;
#line 1068
  __init_work(& priv->abort_scan, 0);
#line 1068
  __constr_expr_1.counter = 137438953408L;
#line 1068
  priv->abort_scan.data = __constr_expr_1;
#line 1068
  lockdep_init_map(& priv->abort_scan.lockdep_map, "(&priv->abort_scan)", & __key___0,
                   0);
#line 1068
  INIT_LIST_HEAD(& priv->abort_scan.entry);
#line 1068
  priv->abort_scan.func = & iwl_bg_abort_scan;
#line 1069
  __init_work(& priv->start_internal_scan, 0);
#line 1069
  __constr_expr_2.counter = 137438953408L;
#line 1069
  priv->start_internal_scan.data = __constr_expr_2;
#line 1069
  lockdep_init_map(& priv->start_internal_scan.lockdep_map, "(&priv->start_internal_scan)",
                   & __key___1, 0);
#line 1069
  INIT_LIST_HEAD(& priv->start_internal_scan.entry);
#line 1069
  priv->start_internal_scan.func = & iwl_bg_start_internal_scan;
#line 1070
  __init_work(& priv->scan_check.work, 0);
#line 1070
  __constr_expr_3.counter = 137438953408L;
#line 1070
  priv->scan_check.work.data = __constr_expr_3;
#line 1070
  lockdep_init_map(& priv->scan_check.work.lockdep_map, "(&(&priv->scan_check)->work)",
                   & __key___2, 0);
#line 1070
  INIT_LIST_HEAD(& priv->scan_check.work.entry);
#line 1070
  priv->scan_check.work.func = & iwl_bg_scan_check;
#line 1070
  init_timer_key(& priv->scan_check.timer, 2097152U, "(&(&priv->scan_check)->timer)",
                 & __key___3);
#line 1070
  priv->scan_check.timer.function = & delayed_work_timer_fn;
#line 1070
  priv->scan_check.timer.data = (unsigned long )(& priv->scan_check);
#line 1071
  return;
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.c"
void iwl_cancel_scan_deferred_work(struct iwl_priv *priv ) 
{ 
  bool tmp ;

  {
#line 1075
  ldv_cancel_work_sync_501(& priv->start_internal_scan);
#line 1076
  ldv_cancel_work_sync_502(& priv->abort_scan);
#line 1077
  ldv_cancel_work_sync_503(& priv->scan_completed);
#line 1079
  tmp = ldv_cancel_delayed_work_sync_504(& priv->scan_check);
#line 1079
  if ((int )tmp) {
#line 1080
    ldv_mutex_lock_505(& priv->mutex);
#line 1081
    iwl_force_scan_end(priv);
#line 1082
    ldv_mutex_unlock_506(& priv->mutex);
  } else {

  }
#line 1084
  return;
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_all_14(int state ) 
{ 


  {
#line 552
  if (ldv_work_14_0 == state) {
#line 553
    call_and_disable_work_14(ldv_work_struct_14_0);
  } else {

  }
#line 554
  if (ldv_work_14_1 == state) {
#line 555
    call_and_disable_work_14(ldv_work_struct_14_1);
  } else {

  }
#line 556
  if (ldv_work_14_2 == state) {
#line 557
    call_and_disable_work_14(ldv_work_struct_14_2);
  } else {

  }
#line 558
  if (ldv_work_14_3 == state) {
#line 559
    call_and_disable_work_14(ldv_work_struct_14_3);
  } else {

  }
#line 560
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_work_13(struct work_struct *work ) 
{ 


  {
#line 566
  if ((ldv_work_13_0 == 2 || ldv_work_13_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_0) {
#line 568
    iwl_bg_start_internal_scan(work);
#line 569
    ldv_work_13_0 = 1;
#line 570
    return;
  } else {

  }
#line 572
  if ((ldv_work_13_1 == 2 || ldv_work_13_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_1) {
#line 574
    iwl_bg_start_internal_scan(work);
#line 575
    ldv_work_13_1 = 1;
#line 576
    return;
  } else {

  }
#line 578
  if ((ldv_work_13_2 == 2 || ldv_work_13_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_2) {
#line 580
    iwl_bg_start_internal_scan(work);
#line 581
    ldv_work_13_2 = 1;
#line 582
    return;
  } else {

  }
#line 584
  if ((ldv_work_13_3 == 2 || ldv_work_13_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_3) {
#line 586
    iwl_bg_start_internal_scan(work);
#line 587
    ldv_work_13_3 = 1;
#line 588
    return;
  } else {

  }
#line 590
  return;
}
}
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void activate_work_13(struct work_struct *work , int state ) 
{ 


  {
#line 594
  if (ldv_work_13_0 == 0) {
#line 595
    ldv_work_struct_13_0 = work;
#line 596
    ldv_work_13_0 = state;
#line 597
    return;
  } else {

  }
#line 600
  if (ldv_work_13_1 == 0) {
#line 601
    ldv_work_struct_13_1 = work;
#line 602
    ldv_work_13_1 = state;
#line 603
    return;
  } else {

  }
#line 606
  if (ldv_work_13_2 == 0) {
#line 607
    ldv_work_struct_13_2 = work;
#line 608
    ldv_work_13_2 = state;
#line 609
    return;
  } else {

  }
#line 612
  if (ldv_work_13_3 == 0) {
#line 613
    ldv_work_struct_13_3 = work;
#line 614
    ldv_work_13_3 = state;
#line 615
    return;
  } else {

  }
#line 617
  return;
}
}
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void disable_work_14(struct work_struct *work ) 
{ 


  {
#line 622
  if ((ldv_work_14_0 == 3 || ldv_work_14_0 == 2) && (unsigned long )ldv_work_struct_14_0 == (unsigned long )work) {
#line 624
    ldv_work_14_0 = 1;
  } else {

  }
#line 626
  if ((ldv_work_14_1 == 3 || ldv_work_14_1 == 2) && (unsigned long )ldv_work_struct_14_1 == (unsigned long )work) {
#line 628
    ldv_work_14_1 = 1;
  } else {

  }
#line 630
  if ((ldv_work_14_2 == 3 || ldv_work_14_2 == 2) && (unsigned long )ldv_work_struct_14_2 == (unsigned long )work) {
#line 632
    ldv_work_14_2 = 1;
  } else {

  }
#line 634
  if ((ldv_work_14_3 == 3 || ldv_work_14_3 == 2) && (unsigned long )ldv_work_struct_14_3 == (unsigned long )work) {
#line 636
    ldv_work_14_3 = 1;
  } else {

  }
#line 637
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_all_11(int state ) 
{ 


  {
#line 643
  if (ldv_work_11_0 == state) {
#line 644
    call_and_disable_work_11(ldv_work_struct_11_0);
  } else {

  }
#line 645
  if (ldv_work_11_1 == state) {
#line 646
    call_and_disable_work_11(ldv_work_struct_11_1);
  } else {

  }
#line 647
  if (ldv_work_11_2 == state) {
#line 648
    call_and_disable_work_11(ldv_work_struct_11_2);
  } else {

  }
#line 649
  if (ldv_work_11_3 == state) {
#line 650
    call_and_disable_work_11(ldv_work_struct_11_3);
  } else {

  }
#line 651
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void work_init_14(void) 
{ 


  {
#line 655
  ldv_work_14_0 = 0;
#line 656
  ldv_work_14_1 = 0;
#line 657
  ldv_work_14_2 = 0;
#line 658
  ldv_work_14_3 = 0;
#line 659
  return;
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_all_12(int state ) 
{ 


  {
#line 664
  if (ldv_work_12_0 == state) {
#line 665
    call_and_disable_work_12(ldv_work_struct_12_0);
  } else {

  }
#line 666
  if (ldv_work_12_1 == state) {
#line 667
    call_and_disable_work_12(ldv_work_struct_12_1);
  } else {

  }
#line 668
  if (ldv_work_12_2 == state) {
#line 669
    call_and_disable_work_12(ldv_work_struct_12_2);
  } else {

  }
#line 670
  if (ldv_work_12_3 == state) {
#line 671
    call_and_disable_work_12(ldv_work_struct_12_3);
  } else {

  }
#line 672
  return;
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void invoke_work_14(void) 
{ 
  int tmp ;

  {
#line 677
  tmp = __VERIFIER_nondet_int();
#line 677
  switch (tmp) {
  case 0: ;
#line 679
  if (ldv_work_14_0 == 2 || ldv_work_14_0 == 3) {
#line 680
    ldv_work_14_0 = 4;
#line 681
    iwl_bg_scan_check(ldv_work_struct_14_0);
#line 682
    ldv_work_14_0 = 1;
  } else {

  }
#line 685
  goto ldv_53263;
  case 1: ;
#line 687
  if (ldv_work_14_1 == 2 || ldv_work_14_1 == 3) {
#line 688
    ldv_work_14_1 = 4;
#line 689
    iwl_bg_scan_check(ldv_work_struct_14_0);
#line 690
    ldv_work_14_1 = 1;
  } else {

  }
#line 693
  goto ldv_53263;
  case 2: ;
#line 695
  if (ldv_work_14_2 == 2 || ldv_work_14_2 == 3) {
#line 696
    ldv_work_14_2 = 4;
#line 697
    iwl_bg_scan_check(ldv_work_struct_14_0);
#line 698
    ldv_work_14_2 = 1;
  } else {

  }
#line 701
  goto ldv_53263;
  case 3: ;
#line 703
  if (ldv_work_14_3 == 2 || ldv_work_14_3 == 3) {
#line 704
    ldv_work_14_3 = 4;
#line 705
    iwl_bg_scan_check(ldv_work_struct_14_0);
#line 706
    ldv_work_14_3 = 1;
  } else {

  }
#line 709
  goto ldv_53263;
  default: 
#line 710
  ldv_stop();
  }
  ldv_53263: ;
#line 712
  return;
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void invoke_work_11(void) 
{ 
  int tmp ;

  {
#line 718
  tmp = __VERIFIER_nondet_int();
#line 718
  switch (tmp) {
  case 0: ;
#line 720
  if (ldv_work_11_0 == 2 || ldv_work_11_0 == 3) {
#line 721
    ldv_work_11_0 = 4;
#line 722
    iwl_bg_scan_completed(ldv_work_struct_11_0);
#line 723
    ldv_work_11_0 = 1;
  } else {

  }
#line 726
  goto ldv_53274;
  case 1: ;
#line 728
  if (ldv_work_11_1 == 2 || ldv_work_11_1 == 3) {
#line 729
    ldv_work_11_1 = 4;
#line 730
    iwl_bg_scan_completed(ldv_work_struct_11_0);
#line 731
    ldv_work_11_1 = 1;
  } else {

  }
#line 734
  goto ldv_53274;
  case 2: ;
#line 736
  if (ldv_work_11_2 == 2 || ldv_work_11_2 == 3) {
#line 737
    ldv_work_11_2 = 4;
#line 738
    iwl_bg_scan_completed(ldv_work_struct_11_0);
#line 739
    ldv_work_11_2 = 1;
  } else {

  }
#line 742
  goto ldv_53274;
  case 3: ;
#line 744
  if (ldv_work_11_3 == 2 || ldv_work_11_3 == 3) {
#line 745
    ldv_work_11_3 = 4;
#line 746
    iwl_bg_scan_completed(ldv_work_struct_11_0);
#line 747
    ldv_work_11_3 = 1;
  } else {

  }
#line 750
  goto ldv_53274;
  default: 
#line 751
  ldv_stop();
  }
  ldv_53274: ;
#line 753
  return;
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void work_init_13(void) 
{ 


  {
#line 758
  ldv_work_13_0 = 0;
#line 759
  ldv_work_13_1 = 0;
#line 760
  ldv_work_13_2 = 0;
#line 761
  ldv_work_13_3 = 0;
#line 762
  return;
}
}
#line 765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_work_14(struct work_struct *work ) 
{ 


  {
#line 768
  if ((ldv_work_14_0 == 2 || ldv_work_14_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_0) {
#line 770
    iwl_bg_scan_check(work);
#line 771
    ldv_work_14_0 = 1;
#line 772
    return;
  } else {

  }
#line 774
  if ((ldv_work_14_1 == 2 || ldv_work_14_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_1) {
#line 776
    iwl_bg_scan_check(work);
#line 777
    ldv_work_14_1 = 1;
#line 778
    return;
  } else {

  }
#line 780
  if ((ldv_work_14_2 == 2 || ldv_work_14_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_2) {
#line 782
    iwl_bg_scan_check(work);
#line 783
    ldv_work_14_2 = 1;
#line 784
    return;
  } else {

  }
#line 786
  if ((ldv_work_14_3 == 2 || ldv_work_14_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_3) {
#line 788
    iwl_bg_scan_check(work);
#line 789
    ldv_work_14_3 = 1;
#line 790
    return;
  } else {

  }
#line 792
  return;
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void disable_work_13(struct work_struct *work ) 
{ 


  {
#line 797
  if ((ldv_work_13_0 == 3 || ldv_work_13_0 == 2) && (unsigned long )ldv_work_struct_13_0 == (unsigned long )work) {
#line 799
    ldv_work_13_0 = 1;
  } else {

  }
#line 801
  if ((ldv_work_13_1 == 3 || ldv_work_13_1 == 2) && (unsigned long )ldv_work_struct_13_1 == (unsigned long )work) {
#line 803
    ldv_work_13_1 = 1;
  } else {

  }
#line 805
  if ((ldv_work_13_2 == 3 || ldv_work_13_2 == 2) && (unsigned long )ldv_work_struct_13_2 == (unsigned long )work) {
#line 807
    ldv_work_13_2 = 1;
  } else {

  }
#line 809
  if ((ldv_work_13_3 == 3 || ldv_work_13_3 == 2) && (unsigned long )ldv_work_struct_13_3 == (unsigned long )work) {
#line 811
    ldv_work_13_3 = 1;
  } else {

  }
#line 812
  return;
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void invoke_work_12(void) 
{ 
  int tmp ;

  {
#line 818
  tmp = __VERIFIER_nondet_int();
#line 818
  switch (tmp) {
  case 0: ;
#line 820
  if (ldv_work_12_0 == 2 || ldv_work_12_0 == 3) {
#line 821
    ldv_work_12_0 = 4;
#line 822
    iwl_bg_abort_scan(ldv_work_struct_12_0);
#line 823
    ldv_work_12_0 = 1;
  } else {

  }
#line 826
  goto ldv_53296;
  case 1: ;
#line 828
  if (ldv_work_12_1 == 2 || ldv_work_12_1 == 3) {
#line 829
    ldv_work_12_1 = 4;
#line 830
    iwl_bg_abort_scan(ldv_work_struct_12_0);
#line 831
    ldv_work_12_1 = 1;
  } else {

  }
#line 834
  goto ldv_53296;
  case 2: ;
#line 836
  if (ldv_work_12_2 == 2 || ldv_work_12_2 == 3) {
#line 837
    ldv_work_12_2 = 4;
#line 838
    iwl_bg_abort_scan(ldv_work_struct_12_0);
#line 839
    ldv_work_12_2 = 1;
  } else {

  }
#line 842
  goto ldv_53296;
  case 3: ;
#line 844
  if (ldv_work_12_3 == 2 || ldv_work_12_3 == 3) {
#line 845
    ldv_work_12_3 = 4;
#line 846
    iwl_bg_abort_scan(ldv_work_struct_12_0);
#line 847
    ldv_work_12_3 = 1;
  } else {

  }
#line 850
  goto ldv_53296;
  default: 
#line 851
  ldv_stop();
  }
  ldv_53296: ;
#line 853
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_work_12(struct work_struct *work ) 
{ 


  {
#line 860
  if ((ldv_work_12_0 == 2 || ldv_work_12_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_0) {
#line 862
    iwl_bg_abort_scan(work);
#line 863
    ldv_work_12_0 = 1;
#line 864
    return;
  } else {

  }
#line 866
  if ((ldv_work_12_1 == 2 || ldv_work_12_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_1) {
#line 868
    iwl_bg_abort_scan(work);
#line 869
    ldv_work_12_1 = 1;
#line 870
    return;
  } else {

  }
#line 872
  if ((ldv_work_12_2 == 2 || ldv_work_12_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_2) {
#line 874
    iwl_bg_abort_scan(work);
#line 875
    ldv_work_12_2 = 1;
#line 876
    return;
  } else {

  }
#line 878
  if ((ldv_work_12_3 == 2 || ldv_work_12_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_3) {
#line 880
    iwl_bg_abort_scan(work);
#line 881
    ldv_work_12_3 = 1;
#line 882
    return;
  } else {

  }
#line 884
  return;
}
}
#line 887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void work_init_11(void) 
{ 


  {
#line 888
  ldv_work_11_0 = 0;
#line 889
  ldv_work_11_1 = 0;
#line 890
  ldv_work_11_2 = 0;
#line 891
  ldv_work_11_3 = 0;
#line 892
  return;
}
}
#line 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void activate_work_11(struct work_struct *work , int state ) 
{ 


  {
#line 896
  if (ldv_work_11_0 == 0) {
#line 897
    ldv_work_struct_11_0 = work;
#line 898
    ldv_work_11_0 = state;
#line 899
    return;
  } else {

  }
#line 902
  if (ldv_work_11_1 == 0) {
#line 903
    ldv_work_struct_11_1 = work;
#line 904
    ldv_work_11_1 = state;
#line 905
    return;
  } else {

  }
#line 908
  if (ldv_work_11_2 == 0) {
#line 909
    ldv_work_struct_11_2 = work;
#line 910
    ldv_work_11_2 = state;
#line 911
    return;
  } else {

  }
#line 914
  if (ldv_work_11_3 == 0) {
#line 915
    ldv_work_struct_11_3 = work;
#line 916
    ldv_work_11_3 = state;
#line 917
    return;
  } else {

  }
#line 919
  return;
}
}
#line 922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void disable_work_11(struct work_struct *work ) 
{ 


  {
#line 924
  if ((ldv_work_11_0 == 3 || ldv_work_11_0 == 2) && (unsigned long )ldv_work_struct_11_0 == (unsigned long )work) {
#line 926
    ldv_work_11_0 = 1;
  } else {

  }
#line 928
  if ((ldv_work_11_1 == 3 || ldv_work_11_1 == 2) && (unsigned long )ldv_work_struct_11_1 == (unsigned long )work) {
#line 930
    ldv_work_11_1 = 1;
  } else {

  }
#line 932
  if ((ldv_work_11_2 == 3 || ldv_work_11_2 == 2) && (unsigned long )ldv_work_struct_11_2 == (unsigned long )work) {
#line 934
    ldv_work_11_2 = 1;
  } else {

  }
#line 936
  if ((ldv_work_11_3 == 3 || ldv_work_11_3 == 2) && (unsigned long )ldv_work_struct_11_3 == (unsigned long )work) {
#line 938
    ldv_work_11_3 = 1;
  } else {

  }
#line 939
  return;
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void disable_work_12(struct work_struct *work ) 
{ 


  {
#line 945
  if ((ldv_work_12_0 == 3 || ldv_work_12_0 == 2) && (unsigned long )ldv_work_struct_12_0 == (unsigned long )work) {
#line 947
    ldv_work_12_0 = 1;
  } else {

  }
#line 949
  if ((ldv_work_12_1 == 3 || ldv_work_12_1 == 2) && (unsigned long )ldv_work_struct_12_1 == (unsigned long )work) {
#line 951
    ldv_work_12_1 = 1;
  } else {

  }
#line 953
  if ((ldv_work_12_2 == 3 || ldv_work_12_2 == 2) && (unsigned long )ldv_work_struct_12_2 == (unsigned long )work) {
#line 955
    ldv_work_12_2 = 1;
  } else {

  }
#line 957
  if ((ldv_work_12_3 == 3 || ldv_work_12_3 == 2) && (unsigned long )ldv_work_struct_12_3 == (unsigned long )work) {
#line 959
    ldv_work_12_3 = 1;
  } else {

  }
#line 960
  return;
}
}
#line 964 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void activate_work_12(struct work_struct *work , int state ) 
{ 


  {
#line 965
  if (ldv_work_12_0 == 0) {
#line 966
    ldv_work_struct_12_0 = work;
#line 967
    ldv_work_12_0 = state;
#line 968
    return;
  } else {

  }
#line 971
  if (ldv_work_12_1 == 0) {
#line 972
    ldv_work_struct_12_1 = work;
#line 973
    ldv_work_12_1 = state;
#line 974
    return;
  } else {

  }
#line 977
  if (ldv_work_12_2 == 0) {
#line 978
    ldv_work_struct_12_2 = work;
#line 979
    ldv_work_12_2 = state;
#line 980
    return;
  } else {

  }
#line 983
  if (ldv_work_12_3 == 0) {
#line 984
    ldv_work_struct_12_3 = work;
#line 985
    ldv_work_12_3 = state;
#line 986
    return;
  } else {

  }
#line 988
  return;
}
}
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void invoke_work_13(void) 
{ 
  int tmp ;

  {
#line 993
  tmp = __VERIFIER_nondet_int();
#line 993
  switch (tmp) {
  case 0: ;
#line 995
  if (ldv_work_13_0 == 2 || ldv_work_13_0 == 3) {
#line 996
    ldv_work_13_0 = 4;
#line 997
    iwl_bg_start_internal_scan(ldv_work_struct_13_0);
#line 998
    ldv_work_13_0 = 1;
  } else {

  }
#line 1001
  goto ldv_53329;
  case 1: ;
#line 1003
  if (ldv_work_13_1 == 2 || ldv_work_13_1 == 3) {
#line 1004
    ldv_work_13_1 = 4;
#line 1005
    iwl_bg_start_internal_scan(ldv_work_struct_13_0);
#line 1006
    ldv_work_13_1 = 1;
  } else {

  }
#line 1009
  goto ldv_53329;
  case 2: ;
#line 1011
  if (ldv_work_13_2 == 2 || ldv_work_13_2 == 3) {
#line 1012
    ldv_work_13_2 = 4;
#line 1013
    iwl_bg_start_internal_scan(ldv_work_struct_13_0);
#line 1014
    ldv_work_13_2 = 1;
  } else {

  }
#line 1017
  goto ldv_53329;
  case 3: ;
#line 1019
  if (ldv_work_13_3 == 2 || ldv_work_13_3 == 3) {
#line 1020
    ldv_work_13_3 = 4;
#line 1021
    iwl_bg_start_internal_scan(ldv_work_struct_13_0);
#line 1022
    ldv_work_13_3 = 1;
  } else {

  }
#line 1025
  goto ldv_53329;
  default: 
#line 1026
  ldv_stop();
  }
  ldv_53329: ;
#line 1028
  return;
}
}
#line 1032 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void work_init_12(void) 
{ 


  {
#line 1033
  ldv_work_12_0 = 0;
#line 1034
  ldv_work_12_1 = 0;
#line 1035
  ldv_work_12_2 = 0;
#line 1036
  ldv_work_12_3 = 0;
#line 1037
  return;
}
}
#line 1040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_work_11(struct work_struct *work ) 
{ 


  {
#line 1043
  if ((ldv_work_11_0 == 2 || ldv_work_11_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_0) {
#line 1045
    iwl_bg_scan_completed(work);
#line 1046
    ldv_work_11_0 = 1;
#line 1047
    return;
  } else {

  }
#line 1049
  if ((ldv_work_11_1 == 2 || ldv_work_11_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_1) {
#line 1051
    iwl_bg_scan_completed(work);
#line 1052
    ldv_work_11_1 = 1;
#line 1053
    return;
  } else {

  }
#line 1055
  if ((ldv_work_11_2 == 2 || ldv_work_11_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_2) {
#line 1057
    iwl_bg_scan_completed(work);
#line 1058
    ldv_work_11_2 = 1;
#line 1059
    return;
  } else {

  }
#line 1061
  if ((ldv_work_11_3 == 2 || ldv_work_11_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_3) {
#line 1063
    iwl_bg_scan_completed(work);
#line 1064
    ldv_work_11_3 = 1;
#line 1065
    return;
  } else {

  }
#line 1067
  return;
}
}
#line 1070 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void activate_work_14(struct work_struct *work , int state ) 
{ 


  {
#line 1071
  if (ldv_work_14_0 == 0) {
#line 1072
    ldv_work_struct_14_0 = work;
#line 1073
    ldv_work_14_0 = state;
#line 1074
    return;
  } else {

  }
#line 1077
  if (ldv_work_14_1 == 0) {
#line 1078
    ldv_work_struct_14_1 = work;
#line 1079
    ldv_work_14_1 = state;
#line 1080
    return;
  } else {

  }
#line 1083
  if (ldv_work_14_2 == 0) {
#line 1084
    ldv_work_struct_14_2 = work;
#line 1085
    ldv_work_14_2 = state;
#line 1086
    return;
  } else {

  }
#line 1089
  if (ldv_work_14_3 == 0) {
#line 1090
    ldv_work_struct_14_3 = work;
#line 1091
    ldv_work_14_3 = state;
#line 1092
    return;
  } else {

  }
#line 1094
  return;
}
}
#line 1097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void call_and_disable_all_13(int state ) 
{ 


  {
#line 1099
  if (ldv_work_13_0 == state) {
#line 1100
    call_and_disable_work_13(ldv_work_struct_13_0);
  } else {

  }
#line 1101
  if (ldv_work_13_1 == state) {
#line 1102
    call_and_disable_work_13(ldv_work_struct_13_1);
  } else {

  }
#line 1103
  if (ldv_work_13_2 == state) {
#line 1104
    call_and_disable_work_13(ldv_work_struct_13_2);
  } else {

  }
#line 1105
  if (ldv_work_13_3 == state) {
#line 1106
    call_and_disable_work_13(ldv_work_struct_13_3);
  } else {

  }
#line 1107
  return;
}
}
#line 1133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_queue_work_on_479(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1137
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1137
  ldv_func_res = tmp;
#line 1139
  activate_work_7(ldv_func_arg3, 2);
#line 1141
  return (ldv_func_res);
}
}
#line 1144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_queue_delayed_work_on_480(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1148
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1148
  ldv_func_res = tmp;
#line 1150
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1152
  return (ldv_func_res);
}
}
#line 1155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_queue_work_on_481(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1159
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1159
  ldv_func_res = tmp;
#line 1161
  activate_work_7(ldv_func_arg3, 2);
#line 1163
  return (ldv_func_res);
}
}
#line 1166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_flush_workqueue_482(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1169
  flush_workqueue(ldv_func_arg1);
#line 1171
  call_and_disable_all_7(2);
#line 1172
  return;
}
}
#line 1174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_queue_delayed_work_on_483(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1178
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1178
  ldv_func_res = tmp;
#line 1180
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1182
  return (ldv_func_res);
}
}
#line 1185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_484(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1188
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1190
  mutex_lock(ldv_func_arg1);
#line 1191
  return;
}
}
#line 1193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_unlock_485(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1196
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1198
  mutex_unlock(ldv_func_arg1);
#line 1199
  return;
}
}
#line 1201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_486(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1204
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1206
  mutex_lock(ldv_func_arg1);
#line 1207
  return;
}
}
#line 1209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
int ldv_mutex_trylock_487(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1213
  tmp = mutex_trylock(ldv_func_arg1);
#line 1213
  ldv_func_res = tmp;
#line 1215
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1215
  return (tmp___0);
#line 1217
  return (ldv_func_res);
}
}
#line 1220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_unlock_488(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1223
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1225
  mutex_unlock(ldv_func_arg1);
#line 1226
  return;
}
}
#line 1228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1231
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1233
  mutex_unlock(ldv_func_arg1);
#line 1234
  return;
}
}
#line 1236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_490(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1239
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1241
  mutex_lock(ldv_func_arg1);
#line 1242
  return;
}
}
#line 1244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_cancel_delayed_work_491(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  bool tmp ;

  {
#line 1248
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 1248
  ldv_func_res = tmp;
#line 1250
  disable_work_7(& ldv_func_arg1->work);
#line 1252
  return (ldv_func_res);
}
}
#line 1255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_cancel_delayed_work_492(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___21 ldv_func_res ;
  bool tmp ;

  {
#line 1259
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 1259
  ldv_func_res = tmp;
#line 1261
  disable_work_7(& ldv_func_arg1->work);
#line 1263
  return (ldv_func_res);
}
}
#line 1266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_493(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1269
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1271
  mutex_lock(ldv_func_arg1);
#line 1272
  return;
}
}
#line 1274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1277
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1279
  mutex_unlock(ldv_func_arg1);
#line 1280
  return;
}
}
#line 1282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_495(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1285
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1287
  mutex_lock(ldv_func_arg1);
#line 1288
  return;
}
}
#line 1290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_unlock_496(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1293
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1295
  mutex_unlock(ldv_func_arg1);
#line 1296
  return;
}
}
#line 1298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_497(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1301
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1303
  mutex_lock(ldv_func_arg1);
#line 1304
  return;
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_unlock_498(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1309
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1311
  mutex_unlock(ldv_func_arg1);
#line 1312
  return;
}
}
#line 1314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_499(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1317
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1319
  mutex_lock(ldv_func_arg1);
#line 1320
  return;
}
}
#line 1322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_unlock_500(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1325
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1327
  mutex_unlock(ldv_func_arg1);
#line 1328
  return;
}
}
#line 1330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_cancel_work_sync_501(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 1334
  tmp = cancel_work_sync(ldv_func_arg1);
#line 1334
  ldv_func_res = tmp;
#line 1336
  disable_work_7(ldv_func_arg1);
#line 1338
  return (ldv_func_res);
}
}
#line 1341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_cancel_work_sync_502(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
#line 1345
  tmp = cancel_work_sync(ldv_func_arg1);
#line 1345
  ldv_func_res = tmp;
#line 1347
  disable_work_7(ldv_func_arg1);
#line 1349
  return (ldv_func_res);
}
}
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_cancel_work_sync_503(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
#line 1356
  tmp = cancel_work_sync(ldv_func_arg1);
#line 1356
  ldv_func_res = tmp;
#line 1358
  disable_work_7(ldv_func_arg1);
#line 1360
  return (ldv_func_res);
}
}
#line 1363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
bool ldv_cancel_delayed_work_sync_504(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  bool tmp ;

  {
#line 1367
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
#line 1367
  ldv_func_res = tmp;
#line 1369
  disable_work_7(& ldv_func_arg1->work);
#line 1371
  return (ldv_func_res);
}
}
#line 1374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1377
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1379
  mutex_lock(ldv_func_arg1);
#line 1380
  return;
}
}
#line 1382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/scan.o.c.prepared"
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1385
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 1387
  mutex_unlock(ldv_func_arg1);
#line 1388
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_547(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_545(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_548(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_549(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_552(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_554(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_555(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_556(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_546(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_550(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_551(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_553(struct mutex *ldv_func_arg1 ) ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add___4(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6581;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6581;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6581;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6581;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6581: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub___4(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6593;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6593;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6593;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6593;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6593: ;
#line 79
  return;
}
}
#line 268 "include/linux/rcupdate.h"
__inline static void __rcu_read_lock___0(void) 
{ 


  {
#line 270
  __preempt_count_add___4(1);
#line 270
  __asm__  volatile   ("": : : "memory");
#line 271
  return;
}
}
#line 273 "include/linux/rcupdate.h"
__inline static void __rcu_read_unlock___0(void) 
{ 


  {
#line 275
  __asm__  volatile   ("": : : "memory");
#line 275
  __preempt_count_sub___4(1);
#line 276
  return;
}
}
#line 843 "include/linux/rcupdate.h"
__inline static void rcu_read_lock___0(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 845
  __rcu_read_lock___0();
#line 847
  rcu_lock_acquire(& rcu_lock_map);
#line 848
  tmp = debug_lockdep_rcu_enabled();
#line 848
  if (tmp != 0 && ! __warned) {
#line 848
    tmp___0 = rcu_is_watching();
#line 848
    if (tmp___0) {
#line 848
      tmp___1 = 0;
    } else {
#line 848
      tmp___1 = 1;
    }
#line 848
    if (tmp___1) {
#line 848
      __warned = 1;
#line 848
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 849, "rcu_read_lock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 851
  return;
}
}
#line 897 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock___0(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 899
  tmp = debug_lockdep_rcu_enabled();
#line 899
  if (tmp != 0 && ! __warned) {
#line 899
    tmp___0 = rcu_is_watching();
#line 899
    if (tmp___0) {
#line 899
      tmp___1 = 0;
    } else {
#line 899
      tmp___1 = 1;
    }
#line 899
    if (tmp___1) {
#line 899
      __warned = 1;
#line 899
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 900, "rcu_read_unlock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 902
  __rcu_read_unlock___0();
#line 903
  rcu_lock_release(& rcu_lock_map);
#line 904
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_539(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_540(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_543(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_542(struct workqueue_struct *ldv_func_arg1 ) ;
#line 5233 "include/net/mac80211.h"
__inline static bool conf_is_ht40_minus(struct ieee80211_conf *conf ) 
{ 


  {
#line 5235
  return ((bool )((unsigned int )conf->chandef.width == 2U && conf->chandef.center_freq1 < (u32 )(conf->chandef.chan)->center_freq));
}
}
#line 5240 "include/net/mac80211.h"
__inline static bool conf_is_ht40_plus(struct ieee80211_conf *conf ) 
{ 


  {
#line 5242
  return ((bool )((unsigned int )conf->chandef.width == 2U && conf->chandef.center_freq1 > (u32 )(conf->chandef.chan)->center_freq));
}
}
#line 939 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
__inline static int iwl_is_any_associated___2(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
#line 942
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 942
  goto ldv_52485;
  ldv_52484: ;
#line 942
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 943
    tmp = iwl_is_associated_ctx(ctx);
#line 943
    if (tmp != 0) {
#line 944
      return (1);
    } else {

    }
  } else {

  }
#line 942
  ctx = ctx + 1;
  ldv_52485: ;
#line 942
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 944
    goto ldv_52484;
  } else {

  }

#line 945
  return (0);
}
}
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
void iwlagn_config_ht40(struct ieee80211_conf *conf , struct iwl_rxon_context *ctx ) ;
#line 421 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h"
__inline static int iwl_is_alive(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
#line 423
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->status));
#line 423
  return (tmp);
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
void iwl_connection_init_rx_config(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 


  {
#line 40
  memset((void *)(& ctx->staging), 0, 50UL);
#line 42
  if ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0)) {
#line 43
    ctx->staging.dev_type = ctx->unused_devtype;
  } else {
#line 45
    switch ((unsigned int )(ctx->vif)->type) {
    case 3U: 
#line 47
    ctx->staging.dev_type = ctx->ap_devtype;
#line 48
    goto ldv_52901;
    case 2U: 
#line 51
    ctx->staging.dev_type = ctx->station_devtype;
#line 52
    ctx->staging.filter_flags = 4U;
#line 53
    goto ldv_52901;
    case 1U: 
#line 56
    ctx->staging.dev_type = ctx->ibss_devtype;
#line 57
    ctx->staging.flags = 32U;
#line 58
    ctx->staging.filter_flags = 68U;
#line 60
    goto ldv_52901;
    case 6U: 
#line 63
    ctx->staging.dev_type = 6U;
#line 64
    goto ldv_52901;
    default: 
#line 67
    __iwl_err(priv->dev, 0, 0, "Unsupported interface type %d\n", (unsigned int )(ctx->vif)->type);
#line 69
    goto ldv_52901;
    }
    ldv_52901: ;
  }
#line 81
  ctx->staging.channel = ((priv->hw)->conf.chandef.chan)->hw_value;
#line 83
  priv->band = ((priv->hw)->conf.chandef.chan)->band;
#line 85
  iwl_set_flags_for_band(priv, ctx, priv->band, ctx->vif);
#line 88
  ctx->staging.flags = ctx->staging.flags & 4194303999U;
#line 90
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 91
    memcpy((void *)(& ctx->staging.node_addr), (void const   *)(& (ctx->vif)->addr),
             6UL);
  } else {

  }
#line 93
  ctx->staging.ofdm_ht_single_stream_basic_rates = 255U;
#line 94
  ctx->staging.ofdm_ht_dual_stream_basic_rates = 255U;
#line 95
  ctx->staging.ofdm_ht_triple_stream_basic_rates = 255U;
#line 96
  return;
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwlagn_disable_bss(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                              struct iwl_rxon_cmd *send ) 
{ 
  __le32 old_filter ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 102
  old_filter = send->filter_flags;
#line 105
  send->filter_flags = send->filter_flags & 4294967263U;
#line 106
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_cmd, 0U, 50, (void const   *)send);
#line 109
  send->filter_flags = old_filter;
#line 111
  if (ret != 0) {
#line 112
    tmp___1 = iwl_is_rfkill(priv);
#line 112
    if (tmp___1 == 0) {
#line 112
      __iwl_err(priv->dev, 0, 0, "Error clearing ASSOC_MSK on BSS (%d)\n", ret);
    } else {
#line 112
      tmp = iwl_have_debug_level(128U);
#line 112
      if ((int )tmp != 0) {
#line 112
        tmp___0 = 0;
      } else {
#line 112
        tmp___0 = 1;
      }
#line 112
      __iwl_err(priv->dev, 1, (int )((bool )tmp___0), "Error clearing ASSOC_MSK on BSS (%d)\n",
                ret);
    }
  } else {

  }
#line 115
  return (ret);
}
}
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwlagn_disable_pan(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                              struct iwl_rxon_cmd *send ) 
{ 
  struct iwl_notification_wait disable_wait ;
  __le32 old_filter ;
  u8 old_dev_type ;
  int ret ;
  u8 deactivate_cmd[1U] ;

  {
#line 123
  old_filter = send->filter_flags;
#line 124
  old_dev_type = send->dev_type;
#line 126
  deactivate_cmd[0] = 189U;
#line 130
  iwl_init_notification_wait(& priv->notif_wait, & disable_wait, (u8 const   *)(& deactivate_cmd),
                             1, (bool (*)(struct iwl_notif_wait_data * , struct iwl_rx_packet * ,
                                          void * ))0, (void *)0);
#line 134
  send->filter_flags = send->filter_flags & 4294967263U;
#line 135
  send->dev_type = 9U;
#line 136
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_cmd, 0U, 50, (void const   *)send);
#line 139
  send->filter_flags = old_filter;
#line 140
  send->dev_type = old_dev_type;
#line 142
  if (ret != 0) {
#line 143
    __iwl_err(priv->dev, 0, 0, "Error disabling PAN (%d)\n", ret);
#line 144
    iwl_remove_notification(& priv->notif_wait, & disable_wait);
  } else {
#line 146
    ret = iwl_wait_notification(& priv->notif_wait, & disable_wait, 250UL);
#line 148
    if (ret != 0) {
#line 149
      __iwl_err(priv->dev, 0, 0, "Timed out waiting for PAN disable\n");
    } else {

    }
  }
#line 152
  return (ret);
}
}
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwlagn_disconn_pan(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                              struct iwl_rxon_cmd *send ) 
{ 
  __le32 old_filter ;
  int ret ;

  {
#line 159
  old_filter = send->filter_flags;
#line 162
  send->filter_flags = send->filter_flags & 4294967263U;
#line 163
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_cmd, 0U, 50, (void const   *)send);
#line 166
  send->filter_flags = old_filter;
#line 168
  return (ret);
}
}
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static void iwlagn_update_qos(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int ret ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 176
  if (! ctx->is_active) {
#line 177
    return;
  } else {

  }
#line 179
  ctx->qos_data.def_qos_parm.qos_flags = 0U;
#line 181
  if (ctx->qos_data.qos_active != 0) {
#line 182
    ctx->qos_data.def_qos_parm.qos_flags = ctx->qos_data.def_qos_parm.qos_flags | 1U;
  } else {

  }
#line 185
  if ((int )ctx->ht.enabled) {
#line 186
    ctx->qos_data.def_qos_parm.qos_flags = ctx->qos_data.def_qos_parm.qos_flags | 2U;
  } else {

  }
#line 188
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_update_qos", "send QoS cmd with Qos active=%d FLAGS=0x%X\n",
            ctx->qos_data.qos_active, ctx->qos_data.def_qos_parm.qos_flags);
#line 192
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->qos_cmd, 0U, 36, (void const   *)(& ctx->qos_data.def_qos_parm));
#line 195
  if (ret != 0) {
#line 196
    tmp___1 = iwl_is_rfkill(priv);
#line 196
    if (tmp___1 == 0) {
#line 196
      __iwl_err(priv->dev, 0, 0, "Failed to update QoS\n");
    } else {
#line 196
      tmp = iwl_have_debug_level(128U);
#line 196
      if ((int )tmp != 0) {
#line 196
        tmp___0 = 0;
      } else {
#line 196
        tmp___0 = 1;
      }
#line 196
      __iwl_err(priv->dev, 1, (int )((bool )tmp___0), "Failed to update QoS\n");
    }
  } else {

  }
#line 197
  return;
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwlagn_update_beacon(struct iwl_priv *priv , struct ieee80211_vif *vif ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 202
  if (debug_locks != 0) {
#line 202
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 202
    if (tmp == 0) {
#line 202
      tmp___0 = 1;
    } else {
#line 202
      tmp___0 = 0;
    }
  } else {
#line 202
    tmp___0 = 0;
  }
#line 202
  __ret_warn_on = tmp___0;
#line 202
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 202
  if (tmp___1 != 0L) {
#line 202
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       202);
  } else {

  }
#line 202
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 204
  consume_skb(priv->beacon_skb);
#line 205
  priv->beacon_skb = ieee80211_beacon_get(priv->hw, vif);
#line 206
  if ((unsigned long )priv->beacon_skb == (unsigned long )((struct sk_buff *)0)) {
#line 207
    return (-12);
  } else {

  }
#line 208
  tmp___2 = iwlagn_send_beacon_cmd(priv);
#line 208
  return (tmp___2);
}
}
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwlagn_send_rxon_assoc(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int ret ;
  struct iwl_rxon_assoc_cmd rxon_assoc ;
  struct iwl_rxon_cmd  const  *rxon1 ;
  struct iwl_rxon_cmd  const  *rxon2 ;

  {
#line 214
  ret = 0;
#line 216
  rxon1 = (struct iwl_rxon_cmd  const  *)(& ctx->staging);
#line 217
  rxon2 = & ctx->active;
#line 219
  if (((((((((unsigned int )rxon1->flags == (unsigned int )rxon2->flags && (unsigned int )rxon1->filter_flags == (unsigned int )rxon2->filter_flags) && (int )((unsigned char )rxon1->cck_basic_rates) == (int )((unsigned char )rxon2->cck_basic_rates)) && (int )((unsigned char )rxon1->ofdm_ht_single_stream_basic_rates) == (int )((unsigned char )rxon2->ofdm_ht_single_stream_basic_rates)) && (int )((unsigned char )rxon1->ofdm_ht_dual_stream_basic_rates) == (int )((unsigned char )rxon2->ofdm_ht_dual_stream_basic_rates)) && (int )((unsigned char )rxon1->ofdm_ht_triple_stream_basic_rates) == (int )((unsigned char )rxon2->ofdm_ht_triple_stream_basic_rates)) && (int )((unsigned short )rxon1->acquisition_data) == (int )((unsigned short )rxon2->acquisition_data)) && (int )((unsigned short )rxon1->rx_chain) == (int )((unsigned short )rxon2->rx_chain)) && (int )((unsigned char )rxon1->ofdm_basic_rates) == (int )((unsigned char )rxon2->ofdm_basic_rates)) {
#line 231
    __iwl_dbg(priv->dev, 1U, 0, "iwlagn_send_rxon_assoc", "Using current RXON_ASSOC.  Not resending.\n");
#line 232
    return (0);
  } else {

  }
#line 235
  rxon_assoc.flags = ctx->staging.flags;
#line 236
  rxon_assoc.filter_flags = ctx->staging.filter_flags;
#line 237
  rxon_assoc.ofdm_basic_rates = ctx->staging.ofdm_basic_rates;
#line 238
  rxon_assoc.cck_basic_rates = ctx->staging.cck_basic_rates;
#line 239
  rxon_assoc.reserved1 = 0U;
#line 240
  rxon_assoc.reserved2 = 0U;
#line 241
  rxon_assoc.reserved3 = 0U;
#line 242
  rxon_assoc.ofdm_ht_single_stream_basic_rates = ctx->staging.ofdm_ht_single_stream_basic_rates;
#line 244
  rxon_assoc.ofdm_ht_dual_stream_basic_rates = ctx->staging.ofdm_ht_dual_stream_basic_rates;
#line 246
  rxon_assoc.rx_chain_select_flags = ctx->staging.rx_chain;
#line 247
  rxon_assoc.ofdm_ht_triple_stream_basic_rates = ctx->staging.ofdm_ht_triple_stream_basic_rates;
#line 249
  rxon_assoc.acquisition_data = ctx->staging.acquisition_data;
#line 251
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_assoc_cmd, 1U, 24, (void const   *)(& rxon_assoc));
#line 253
  return (ret);
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static u16 iwl_adjust_beacon_interval(u16 beacon_val , u16 max_beacon_val ) 
{ 
  u16 new_val ;
  u16 beacon_factor ;

  {
#line 267
  if ((unsigned int )beacon_val == 0U) {
#line 268
    return (200U);
  } else {

  }
#line 282
  beacon_factor = (u16 )(((int )beacon_val + (int )max_beacon_val) / (int )max_beacon_val);
#line 283
  new_val = (u16 )((int )beacon_val / (int )beacon_factor);
#line 285
  if ((unsigned int )new_val == 0U) {
#line 286
    new_val = max_beacon_val;
  } else {

  }
#line 288
  return (new_val);
}
}
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwl_send_rxon_timing(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  u64 tsf ;
  s32 interval_tm ;
  s32 rem ;
  struct ieee80211_conf *conf ;
  u16 beacon_int ;
  struct ieee80211_vif *vif ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint32_t __base ;
  uint32_t __rem ;
  int tmp___5 ;

  {
#line 296
  conf = (struct ieee80211_conf *)0;
#line 298
  vif = ctx->vif;
#line 300
  conf = & (priv->hw)->conf;
#line 302
  if (debug_locks != 0) {
#line 302
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 302
    if (tmp == 0) {
#line 302
      tmp___0 = 1;
    } else {
#line 302
      tmp___0 = 0;
    }
  } else {
#line 302
    tmp___0 = 0;
  }
#line 302
  __ret_warn_on = tmp___0;
#line 302
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 302
  if (tmp___1 != 0L) {
#line 302
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       302);
  } else {

  }
#line 302
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 304
  memset((void *)(& ctx->timing), 0, 20UL);
#line 306
  ctx->timing.timestamp = priv->timestamp;
#line 307
  ctx->timing.listen_interval = conf->listen_interval;
#line 309
  beacon_int = (unsigned long )vif != (unsigned long )((struct ieee80211_vif *)0) ? vif->bss_conf.beacon_int : 0U;
#line 315
  ctx->timing.atim_window = 0U;
#line 317
  if ((unsigned int )ctx->ctxid == 1U && ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0) || (unsigned int )(ctx->vif)->type != 2U)) {
#line 317
    tmp___4 = iwl_is_associated(priv, 0);
#line 317
    if (tmp___4 != 0) {
#line 317
      if ((unsigned long )priv->contexts[0].vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 317
        if ((unsigned int )(priv->contexts[0].vif)->bss_conf.beacon_int != 0U) {
#line 322
          ctx->timing.beacon_interval = priv->contexts[0].timing.beacon_interval;
#line 324
          beacon_int = ctx->timing.beacon_interval;
        } else {
#line 317
          goto _L___1;
        }
      } else {
#line 317
        goto _L___1;
      }
    } else {
#line 317
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 325
  if ((unsigned int )ctx->ctxid == 0U) {
#line 325
    tmp___2 = iwl_is_associated(priv, 1);
#line 325
    if (tmp___2 != 0) {
#line 325
      if ((unsigned long )priv->contexts[1].vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 325
        if ((unsigned int )(priv->contexts[1].vif)->bss_conf.beacon_int != 0U) {
#line 325
          tmp___3 = iwl_is_associated_ctx(ctx);
#line 325
          if ((tmp___3 == 0 || (unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0)) || (unsigned int )(ctx->vif)->bss_conf.beacon_int == 0U) {
#line 331
            ctx->timing.beacon_interval = priv->contexts[1].timing.beacon_interval;
#line 333
            beacon_int = ctx->timing.beacon_interval;
          } else {
#line 335
            beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
#line 337
            ctx->timing.beacon_interval = beacon_int;
          }
        } else {
#line 335
          beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
#line 337
          ctx->timing.beacon_interval = beacon_int;
        }
      } else {
#line 335
        beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
#line 337
        ctx->timing.beacon_interval = beacon_int;
      }
    } else {
#line 335
      beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
#line 337
      ctx->timing.beacon_interval = beacon_int;
    }
  } else {
#line 335
    beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
#line 337
    ctx->timing.beacon_interval = beacon_int;
  }
#line 340
  ctx->beacon_int = (int )beacon_int;
#line 342
  tsf = priv->timestamp;
#line 343
  interval_tm = (int )beacon_int * 1024;
#line 344
  __base = (uint32_t )interval_tm;
#line 344
  __rem = (uint32_t )(tsf % (u64 )__base);
#line 344
  tsf = tsf / (u64 )__base;
#line 344
  rem = (s32 )__rem;
#line 345
  ctx->timing.beacon_init_val = (unsigned int )(interval_tm - rem);
#line 347
  ctx->timing.dtim_period = (unsigned long )vif != (unsigned long )((struct ieee80211_vif *)0) ? ((int )vif->bss_conf.dtim_period != 0 ? (u8 )((int )vif->bss_conf.dtim_period) : 1U) : 1U;
#line 349
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_send_rxon_timing", "beacon interval %d beacon timer %d beacon tim %d\n",
            (int )ctx->timing.beacon_interval, ctx->timing.beacon_init_val, (int )ctx->timing.atim_window);
#line 355
  tmp___5 = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_timing_cmd, 0U, 20, (void const   *)(& ctx->timing));
#line 355
  return (tmp___5);
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwlagn_rxon_disconn(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int ret ;
  struct iwl_rxon_cmd *active ;

  {
#line 363
  active = (struct iwl_rxon_cmd *)(& ctx->active);
#line 365
  if ((unsigned int )ctx->ctxid == 0U) {
#line 366
    ret = iwlagn_disable_bss(priv, ctx, & ctx->staging);
  } else {
#line 368
    ret = iwlagn_disable_pan(priv, ctx, & ctx->staging);
#line 369
    if (ret != 0) {
#line 370
      return (ret);
    } else {

    }
#line 371
    if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 372
      ret = iwl_send_rxon_timing(priv, ctx);
#line 373
      if (ret != 0) {
#line 374
        __iwl_err(priv->dev, 0, 0, "Failed to send timing (%d)!\n", ret);
#line 375
        return (ret);
      } else {

      }
#line 377
      ret = iwlagn_disconn_pan(priv, ctx, & ctx->staging);
    } else {

    }
  }
#line 380
  if (ret != 0) {
#line 381
    return (ret);
  } else {

  }
#line 387
  iwl_clear_ucode_stations(priv, ctx);
#line 389
  iwl_update_bcast_station(priv, ctx);
#line 390
  iwl_restore_stations(priv, ctx);
#line 391
  ret = iwl_restore_default_wep_keys(priv, ctx);
#line 392
  if (ret != 0) {
#line 393
    __iwl_err(priv->dev, 0, 0, "Failed to restore WEP keys (%d)\n", ret);
#line 394
    return (ret);
  } else {

  }
#line 397
  memcpy((void *)active, (void const   *)(& ctx->staging), 50UL);
#line 398
  return (0);
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwl_set_tx_power(struct iwl_priv *priv , s8 tx_power , bool force ) 
{ 
  int ret ;
  s8 prev_tx_power ;
  bool defer ;
  struct iwl_rxon_context *ctx ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 406
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 408
  if ((priv->calib_disabled & 4U) != 0U) {
#line 409
    return (0);
  } else {

  }
#line 411
  if (debug_locks != 0) {
#line 411
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 411
    if (tmp == 0) {
#line 411
      tmp___0 = 1;
    } else {
#line 411
      tmp___0 = 0;
    }
  } else {
#line 411
    tmp___0 = 0;
  }
#line 411
  __ret_warn_on = tmp___0;
#line 411
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 411
  if (tmp___1 != 0L) {
#line 411
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       411);
  } else {

  }
#line 411
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 413
  if ((int )priv->tx_power_user_lmt == (int )tx_power && ! force) {
#line 414
    return (0);
  } else {

  }
#line 416
  if ((int )tx_power < 0) {
#line 417
    __iwl_warn(priv->dev, "Requested user TXPOWER %d below lower limit %d.\n", (int )tx_power,
               0);
#line 421
    return (-22);
  } else {

  }
#line 424
  if ((int )tx_power > ((int )(priv->nvm_data)->max_tx_pwr_half_dbm + 1) / 2) {
#line 425
    __iwl_warn(priv->dev, "Requested user TXPOWER %d above upper limit %d.\n", (int )tx_power,
               (int )(priv->nvm_data)->max_tx_pwr_half_dbm);
#line 428
    return (-22);
  } else {

  }
#line 431
  tmp___2 = iwl_is_ready_rf(priv);
#line 431
  if (tmp___2 == 0) {
#line 432
    return (-5);
  } else {

  }
#line 436
  priv->tx_power_next = tx_power;
#line 439
  tmp___3 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 439
  if (tmp___3 != 0) {
#line 439
    tmp___5 = 1;
  } else {
#line 439
    tmp___4 = memcmp((void const   *)(& ctx->active), (void const   *)(& ctx->staging),
                     50UL);
#line 439
    if (tmp___4 != 0) {
#line 439
      tmp___5 = 1;
    } else {
#line 439
      tmp___5 = 0;
    }
  }
#line 439
  defer = (bool )tmp___5;
#line 441
  if ((int )defer && ! force) {
#line 442
    __iwl_dbg(priv->dev, 1U, 0, "iwl_set_tx_power", "Deferring tx power set\n");
#line 443
    return (0);
  } else {

  }
#line 446
  prev_tx_power = priv->tx_power_user_lmt;
#line 447
  priv->tx_power_user_lmt = tx_power;
#line 449
  ret = iwlagn_send_tx_power(priv);
#line 452
  if (ret != 0) {
#line 453
    priv->tx_power_user_lmt = prev_tx_power;
#line 454
    priv->tx_power_next = prev_tx_power;
  } else {

  }
#line 456
  return (ret);
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwlagn_rxon_connect(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int ret ;
  struct iwl_rxon_cmd *active ;
  int tmp ;

  {
#line 463
  active = (struct iwl_rxon_cmd *)(& ctx->active);
#line 466
  if ((unsigned int )ctx->ctxid == 0U) {
#line 467
    ret = iwl_send_rxon_timing(priv, ctx);
#line 468
    if (ret != 0) {
#line 469
      __iwl_err(priv->dev, 0, 0, "Failed to send timing (%d)!\n", ret);
#line 470
      return (ret);
    } else {

    }
  } else {

  }
#line 474
  iwlagn_update_qos(priv, ctx);
#line 481
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 3U) {
#line 482
    ret = iwlagn_update_beacon(priv, ctx->vif);
#line 483
    if (ret != 0) {
#line 484
      __iwl_err(priv->dev, 0, 0, "Error sending required beacon (%d)!\n", ret);
#line 487
      return (ret);
    } else {

    }
  } else {

  }
#line 491
  priv->start_calib = 0U;
#line 498
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_cmd, 0U, 50, (void const   *)(& ctx->staging));
#line 500
  if (ret != 0) {
#line 501
    __iwl_err(priv->dev, 0, 0, "Error setting new RXON (%d)\n", ret);
#line 502
    return (ret);
  } else {

  }
#line 504
  memcpy((void *)active, (void const   *)(& ctx->staging), 50UL);
#line 507
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 1U) {
#line 508
    tmp = iwlagn_update_beacon(priv, ctx->vif);
#line 508
    if (tmp != 0) {
#line 509
      __iwl_err(priv->dev, 0, 0, "Error sending IBSS beacon\n");
    } else {

    }
  } else {

  }
#line 510
  iwl_init_sensitivity(priv);
#line 519
  ret = iwl_set_tx_power(priv, (int )priv->tx_power_next, 1);
#line 520
  if (ret != 0) {
#line 521
    __iwl_err(priv->dev, 0, 0, "Error sending TX power (%d)\n", ret);
#line 522
    return (ret);
  } else {

  }
#line 525
  if ((((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 2U) && (unsigned long )(priv->cfg)->ht_params != (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) && (unsigned int )((priv->cfg)->ht_params)->smps_mode != 0U) {
#line 527
    ieee80211_request_smps(ctx->vif, ((priv->cfg)->ht_params)->smps_mode);
  } else {

  }
#line 530
  return (0);
}
}
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
int iwlagn_set_pan_params(struct iwl_priv *priv ) 
{ 
  struct iwl_wipan_params_cmd cmd ;
  struct iwl_rxon_context *ctx_bss ;
  struct iwl_rxon_context *ctx_pan ;
  int slot0 ;
  int slot1 ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int bcnint ;
  int dtim ;
  int __max1 ;
  int __max2 ;
  int tmp___2 ;
  int __max1___0 ;
  int __max2___0 ;
  int __max1___1 ;
  int __max2___1 ;
  int tmp___3 ;

  {
#line 537
  slot0 = 300;
#line 537
  slot1 = 0;
#line 540
  if ((unsigned int )priv->valid_contexts == 1U) {
#line 541
    return (0);
  } else {

  }
#line 545
  if (debug_locks != 0) {
#line 545
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 545
    if (tmp == 0) {
#line 545
      tmp___0 = 1;
    } else {
#line 545
      tmp___0 = 0;
    }
  } else {
#line 545
    tmp___0 = 0;
  }
#line 545
  __ret_warn_on = tmp___0;
#line 545
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 545
  if (tmp___1 != 0L) {
#line 545
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       545);
  } else {

  }
#line 545
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 547
  ctx_bss = (struct iwl_rxon_context *)(& priv->contexts);
#line 548
  ctx_pan = (struct iwl_rxon_context *)(& priv->contexts) + 1UL;
#line 556
  if (! ctx_pan->is_active) {
#line 557
    return (0);
  } else {

  }
#line 559
  memset((void *)(& cmd), 0, 44UL);
#line 562
  cmd.num_slots = 2U;
#line 564
  cmd.slots[0].type = 0U;
#line 565
  cmd.slots[1].type = 1U;
#line 567
  if ((unsigned long )ctx_bss->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned long )ctx_pan->vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 568
    bcnint = ctx_pan->beacon_int;
#line 569
    dtim = (int )(ctx_pan->vif)->bss_conf.dtim_period != 0 ? (int )(ctx_pan->vif)->bss_conf.dtim_period != 0 : 1;
#line 572
    cmd.flags = (__le16 )((unsigned int )cmd.flags | 8U);
#line 574
    if (((unsigned int )(ctx_pan->vif)->type == 3U && bcnint != 0) && ctx_bss->beacon_int != bcnint) {
#line 577
      __iwl_err(priv->dev, 0, 0, "beacon intervals don\'t match (%d, %d)\n", ctx_bss->beacon_int,
                ctx_pan->beacon_int);
    } else {
#line 581
      __max1 = bcnint;
#line 581
      __max2 = ctx_bss->beacon_int;
#line 581
      bcnint = __max1 > __max2 ? __max1 : __max2;
    }
#line 583
    if (bcnint == 0) {
#line 584
      bcnint = 200;
    } else {

    }
#line 585
    slot0 = bcnint / 2;
#line 586
    slot1 = bcnint - slot0;
#line 588
    tmp___2 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
#line 588
    if (tmp___2 != 0 || (! (ctx_bss->vif)->bss_conf.idle && ! (ctx_bss->vif)->bss_conf.assoc)) {
#line 591
      slot0 = (dtim * bcnint) * 3 + -20;
#line 592
      slot1 = 20;
    } else
#line 593
    if (! (ctx_pan->vif)->bss_conf.idle && ! (ctx_pan->vif)->bss_conf.assoc) {
#line 595
      slot1 = (dtim * bcnint) * 3 + -20;
#line 596
      slot0 = 20;
    } else {

    }
  } else
#line 598
  if ((unsigned long )ctx_pan->vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 599
    slot0 = 0;
#line 600
    __max1___0 = 1;
#line 600
    __max2___0 = (int )(ctx_pan->vif)->bss_conf.dtim_period;
#line 600
    slot1 = (__max1___0 > __max2___0 ? __max1___0 : __max2___0) * ctx_pan->beacon_int;
#line 602
    __max1___1 = 200;
#line 602
    __max2___1 = slot1;
#line 602
    slot1 = __max1___1 > __max2___1 ? __max1___1 : __max2___1;
#line 604
    tmp___3 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
#line 604
    if (tmp___3 != 0) {
#line 605
      slot0 = slot1 * 3 + -20;
#line 606
      slot1 = 20;
    } else {

    }
  } else {

  }
#line 610
  cmd.slots[0].width = (unsigned short )slot0;
#line 611
  cmd.slots[1].width = (unsigned short )slot1;
#line 613
  ret = iwl_dvm_send_cmd_pdu(priv, 178, 0U, 44, (void const   *)(& cmd));
#line 615
  if (ret != 0) {
#line 616
    __iwl_err(priv->dev, 0, 0, "Error setting PAN parameters (%d)\n", ret);
  } else {

  }
#line 618
  return (ret);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static void _iwl_set_rxon_ht(struct iwl_priv *priv , struct iwl_ht_config *ht_conf ,
                             struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_rxon_cmd *rxon ;
  bool tmp ;

  {
#line 625
  rxon = & ctx->staging;
#line 627
  if (! ctx->ht.enabled) {
#line 628
    rxon->flags = rxon->flags & 4164943871U;
#line 632
    return;
  } else {

  }
#line 638
  rxon->flags = rxon->flags | (__le32 )((int )ctx->ht.protection << 23);
#line 644
  rxon->flags = rxon->flags & 4190109695U;
#line 646
  tmp = iwl_is_ht40_tx_allowed(priv, ctx, (struct ieee80211_sta *)0);
#line 646
  if ((int )tmp) {
#line 648
    if ((unsigned int )ctx->ht.protection == 2U) {
#line 650
      rxon->flags = rxon->flags | 33554432U;
#line 655
      switch ((int )ctx->ht.extension_chan_offset) {
      case 1: 
#line 657
      rxon->flags = rxon->flags & 4290772991U;
#line 659
      goto ldv_53028;
      case 3: 
#line 661
      rxon->flags = rxon->flags | 4194304U;
#line 663
      goto ldv_53028;
      }
      ldv_53028: ;
    } else {
#line 670
      switch ((int )ctx->ht.extension_chan_offset) {
      case 1: 
#line 672
      rxon->flags = rxon->flags & 4290772991U;
#line 674
      rxon->flags = rxon->flags | 67108864U;
#line 675
      goto ldv_53031;
      case 3: 
#line 677
      rxon->flags = rxon->flags | 4194304U;
#line 678
      rxon->flags = rxon->flags | 67108864U;
#line 679
      goto ldv_53031;
      case 0: ;
      default: 
#line 686
      __iwl_err(priv->dev, 0, 0, "invalid extension channel offset\n");
#line 688
      goto ldv_53031;
      }
      ldv_53031: ;
    }
  } else {
#line 692
    rxon->flags = rxon->flags;
  }
#line 695
  iwlagn_set_rxon_chain(priv, ctx);
#line 697
  __iwl_dbg(priv->dev, 4097U, 0, "_iwl_set_rxon_ht", "rxon flags 0x%X operation mode :0x%X extension channel offset 0x%x\n",
            rxon->flags, (int )ctx->ht.protection, (int )ctx->ht.extension_chan_offset);
#line 698
  return;
}
}
#line 703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
void iwl_set_rxon_ht(struct iwl_priv *priv , struct iwl_ht_config *ht_conf ) 
{ 
  struct iwl_rxon_context *ctx ;

  {
#line 707
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 707
  goto ldv_53042;
  ldv_53041: ;
#line 707
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 708
    _iwl_set_rxon_ht(priv, ht_conf, ctx);
  } else {

  }
#line 707
  ctx = ctx + 1;
  ldv_53042: ;
#line 707
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 709
    goto ldv_53041;
  } else {

  }

#line 714
  return;
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
void iwl_set_rxon_channel(struct iwl_priv *priv , struct ieee80211_channel *ch , struct iwl_rxon_context *ctx ) 
{ 
  enum ieee80211_band band ;
  u16 channel ;

  {
#line 721
  band = ch->band;
#line 722
  channel = ch->hw_value;
#line 724
  if ((int )ctx->staging.channel == (int )channel && (unsigned int )priv->band == (unsigned int )band) {
#line 726
    return;
  } else {

  }
#line 728
  ctx->staging.channel = channel;
#line 729
  if ((unsigned int )band == 1U) {
#line 730
    ctx->staging.flags = ctx->staging.flags & 4294967294U;
  } else {
#line 732
    ctx->staging.flags = ctx->staging.flags | 1U;
  }
#line 734
  priv->band = band;
#line 736
  __iwl_dbg(priv->dev, 1U, 0, "iwl_set_rxon_channel", "Staging channel set to %d [%d]\n",
            (int )channel, (unsigned int )band);
#line 737
  return;
}
}
#line 740 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
void iwl_set_flags_for_band(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            enum ieee80211_band band , struct ieee80211_vif *vif ) 
{ 


  {
#line 745
  if ((unsigned int )band == 1U) {
#line 746
    ctx->staging.flags = ctx->staging.flags & 4294967288U;
#line 749
    ctx->staging.flags = ctx->staging.flags | 16U;
  } else {
#line 752
    if ((unsigned long )vif != (unsigned long )((struct ieee80211_vif *)0) && (int )vif->bss_conf.use_short_slot) {
#line 753
      ctx->staging.flags = ctx->staging.flags | 16U;
    } else {
#line 755
      ctx->staging.flags = ctx->staging.flags & 4294967279U;
    }
#line 757
    ctx->staging.flags = ctx->staging.flags | 1U;
#line 758
    ctx->staging.flags = ctx->staging.flags | 4U;
#line 759
    ctx->staging.flags = ctx->staging.flags & 4294967293U;
  }
#line 761
  return;
}
}
#line 763 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static void iwl_set_rxon_hwcrypto(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                  int hw_decrypt ) 
{ 
  struct iwl_rxon_cmd *rxon ;

  {
#line 766
  rxon = & ctx->staging;
#line 768
  if (hw_decrypt != 0) {
#line 769
    rxon->filter_flags = rxon->filter_flags & 4294967287U;
  } else {
#line 771
    rxon->filter_flags = rxon->filter_flags | 8U;
  }
#line 772
  return;
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwl_check_rxon_cmd(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_rxon_cmd *rxon ;
  u32 errors ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 779
  rxon = & ctx->staging;
#line 780
  errors = 0U;
#line 782
  if ((int )rxon->flags & 1) {
#line 783
    if ((rxon->flags & 8192U) != 0U) {
#line 784
      __iwl_warn(priv->dev, "check 2.4G: wrong narrow\n");
#line 785
      errors = errors | 1U;
    } else {

    }
#line 787
    if ((rxon->flags & 4096U) != 0U) {
#line 788
      __iwl_warn(priv->dev, "check 2.4G: wrong radar\n");
#line 789
      errors = errors | 2U;
    } else {

    }
  } else {
#line 792
    if ((rxon->flags & 16U) == 0U) {
#line 793
      __iwl_warn(priv->dev, "check 5.2G: not short slot!\n");
#line 794
      errors = errors | 4U;
    } else {

    }
#line 796
    if ((rxon->flags & 2U) != 0U) {
#line 797
      __iwl_warn(priv->dev, "check 5.2G: CCK!\n");
#line 798
      errors = errors | 8U;
    } else {

    }
  }
#line 801
  if (((int )rxon->node_addr[0] | (int )rxon->bssid_addr[0]) & 1) {
#line 802
    __iwl_warn(priv->dev, "mac/bssid mcast!\n");
#line 803
    errors = errors | 16U;
  } else {

  }
#line 807
  if (((int )rxon->ofdm_basic_rates & 16) == 0 && ((int )rxon->cck_basic_rates & 1) == 0) {
#line 809
    __iwl_warn(priv->dev, "neither 1 nor 6 are basic\n");
#line 810
    errors = errors | 32U;
  } else {

  }
#line 813
  if ((unsigned int )rxon->assoc_id > 2007U) {
#line 814
    __iwl_warn(priv->dev, "aid > 2007\n");
#line 815
    errors = errors | 64U;
  } else {

  }
#line 818
  if ((rxon->flags & 18U) == 18U) {
#line 820
    __iwl_warn(priv->dev, "CCK and short slot\n");
#line 821
    errors = errors | 128U;
  } else {

  }
#line 824
  if ((rxon->flags & 6U) == 6U) {
#line 826
    __iwl_warn(priv->dev, "CCK and auto detect\n");
#line 827
    errors = errors | 256U;
  } else {

  }
#line 830
  if ((rxon->flags & 12U) == 8U) {
#line 833
    __iwl_warn(priv->dev, "TGg but no auto-detect\n");
#line 834
    errors = errors | 512U;
  } else {

  }
#line 837
  if ((unsigned int )rxon->channel == 0U) {
#line 838
    __iwl_warn(priv->dev, "zero channel is invalid\n");
#line 839
    errors = errors | 1024U;
  } else {

  }
#line 842
  __ret_warn_on = errors != 0U;
#line 842
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 842
  if (tmp != 0L) {
#line 842
    warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                      843, "Invalid RXON (%#x), channel %d", errors, (int )rxon->channel);
  } else {

  }
#line 842
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 845
  return (errors != 0U ? -22 : 0);
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static int iwl_full_rxon_required(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_rxon_cmd  const  *staging ;
  struct iwl_rxon_cmd  const  *active ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;

  {
#line 859
  staging = (struct iwl_rxon_cmd  const  *)(& ctx->staging);
#line 860
  active = & ctx->active;
#line 877
  tmp = iwl_is_associated_ctx(ctx);
#line 877
  if (tmp == 0) {
#line 877
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - !iwl_is_associated_ctx(ctx)\n");
#line 877
    return (1);
  } else {

  }
#line 878
  tmp___0 = ether_addr_equal((u8 const   *)(& staging->bssid_addr), (u8 const   *)(& active->bssid_addr));
#line 878
  if (tmp___0) {
#line 878
    tmp___1 = 0;
  } else {
#line 878
    tmp___1 = 1;
  }
#line 878
  if (tmp___1) {
#line 878
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - !ether_addr_equal(staging->bssid_addr, active->bssid_addr)\n");
#line 878
    return (1);
  } else {

  }
#line 879
  tmp___2 = ether_addr_equal((u8 const   *)(& staging->node_addr), (u8 const   *)(& active->node_addr));
#line 879
  if (tmp___2) {
#line 879
    tmp___3 = 0;
  } else {
#line 879
    tmp___3 = 1;
  }
#line 879
  if (tmp___3) {
#line 879
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - !ether_addr_equal(staging->node_addr, active->node_addr)\n");
#line 879
    return (1);
  } else {

  }
#line 880
  tmp___4 = ether_addr_equal((u8 const   *)(& staging->wlap_bssid_addr), (u8 const   *)(& active->wlap_bssid_addr));
#line 880
  if (tmp___4) {
#line 880
    tmp___5 = 0;
  } else {
#line 880
    tmp___5 = 1;
  }
#line 880
  if (tmp___5) {
#line 880
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - !ether_addr_equal(staging->wlap_bssid_addr, active->wlap_bssid_addr)\n");
#line 880
    return (1);
  } else {

  }
#line 882
  if ((int )((unsigned char )staging->dev_type) != (int )((unsigned char )active->dev_type)) {
#line 882
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->dev_type != active->dev_type - %d != %d\n",
              (int )staging->dev_type, (int )active->dev_type);
#line 882
    return (1);
  } else {

  }
#line 883
  if ((int )((unsigned short )staging->channel) != (int )((unsigned short )active->channel)) {
#line 883
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->channel != active->channel - %d != %d\n",
              (int )staging->channel, (int )active->channel);
#line 883
    return (1);
  } else {

  }
#line 884
  if ((int )((unsigned char )staging->air_propagation) != (int )((unsigned char )active->air_propagation)) {
#line 884
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->air_propagation != active->air_propagation - %d != %d\n",
              (int )staging->air_propagation, (int )active->air_propagation);
#line 884
    return (1);
  } else {

  }
#line 885
  if ((int )((unsigned char )staging->ofdm_ht_single_stream_basic_rates) != (int )((unsigned char )active->ofdm_ht_single_stream_basic_rates)) {
#line 885
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->ofdm_ht_single_stream_basic_rates != active->ofdm_ht_single_stream_basic_rates - %d != %d\n",
              (int )staging->ofdm_ht_single_stream_basic_rates, (int )active->ofdm_ht_single_stream_basic_rates);
#line 885
    return (1);
  } else {

  }
#line 887
  if ((int )((unsigned char )staging->ofdm_ht_dual_stream_basic_rates) != (int )((unsigned char )active->ofdm_ht_dual_stream_basic_rates)) {
#line 887
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->ofdm_ht_dual_stream_basic_rates != active->ofdm_ht_dual_stream_basic_rates - %d != %d\n",
              (int )staging->ofdm_ht_dual_stream_basic_rates, (int )active->ofdm_ht_dual_stream_basic_rates);
#line 887
    return (1);
  } else {

  }
#line 889
  if ((int )((unsigned char )staging->ofdm_ht_triple_stream_basic_rates) != (int )((unsigned char )active->ofdm_ht_triple_stream_basic_rates)) {
#line 889
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->ofdm_ht_triple_stream_basic_rates != active->ofdm_ht_triple_stream_basic_rates - %d != %d\n",
              (int )staging->ofdm_ht_triple_stream_basic_rates, (int )active->ofdm_ht_triple_stream_basic_rates);
#line 889
    return (1);
  } else {

  }
#line 891
  if ((int )((unsigned short )staging->assoc_id) != (int )((unsigned short )active->assoc_id)) {
#line 891
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->assoc_id != active->assoc_id - %d != %d\n",
              (int )staging->assoc_id, (int )active->assoc_id);
#line 891
    return (1);
  } else {

  }
#line 898
  if ((int )((unsigned int )staging->flags ^ (unsigned int )active->flags) & 1) {
#line 898
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->flags & RXON_FLG_BAND_24G_MSK != active->flags & RXON_FLG_BAND_24G_MSK - %d != %d\n",
              (unsigned int )staging->flags & 1U, (unsigned int )active->flags & 1U);
#line 898
    return (1);
  } else {

  }
#line 902
  if ((((unsigned int )staging->filter_flags ^ (unsigned int )active->filter_flags) & 32U) != 0U) {
#line 902
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->filter_flags & RXON_FILTER_ASSOC_MSK != active->filter_flags & RXON_FILTER_ASSOC_MSK - %d != %d\n",
              (unsigned int )staging->filter_flags & 32U, (unsigned int )active->filter_flags & 32U);
#line 902
    return (1);
  } else {

  }
#line 908
  return (0);
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
void iwl_print_rx_config_cmd(struct iwl_priv *priv , enum iwl_rxon_context_id ctxid ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_cmd *rxon ;
  bool tmp ;

  {
#line 915
  ctx = (struct iwl_rxon_context *)(& priv->contexts) + (unsigned long )ctxid;
#line 916
  rxon = & ctx->staging;
#line 918
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "RX CONFIG:\n");
#line 919
  tmp = iwl_have_debug_level(128U);
#line 919
  if ((int )tmp) {
#line 919
    print_hex_dump("\017", "iwl data: ", 2, 16, 1, (void const   *)rxon, 50UL, 1);
  } else {

  }
#line 920
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u16 channel: 0x%x\n",
            (int )rxon->channel);
#line 922
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u32 flags: 0x%08X\n",
            rxon->flags);
#line 924
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u32 filter_flags: 0x%08x\n",
            rxon->filter_flags);
#line 926
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8 dev_type: 0x%x\n",
            (int )rxon->dev_type);
#line 927
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8 ofdm_basic_rates: 0x%02x\n",
            (int )rxon->ofdm_basic_rates);
#line 929
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8 cck_basic_rates: 0x%02x\n",
            (int )rxon->cck_basic_rates);
#line 931
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8[6] node_addr: %pM\n",
            (u8 *)(& rxon->node_addr));
#line 932
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8[6] bssid_addr: %pM\n",
            (u8 *)(& rxon->bssid_addr));
#line 933
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u16 assoc_id: 0x%x\n",
            (int )rxon->assoc_id);
#line 934
  return;
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static void iwl_calc_basic_rates(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int lowest_present_ofdm ;
  int lowest_present_cck ;
  u8 cck ;
  u8 ofdm ;
  struct ieee80211_supported_band *sband ;
  unsigned long basic ;
  int i ;
  unsigned long tmp ;
  int hw ;
  unsigned long tmp___0 ;

  {
#line 941
  lowest_present_ofdm = 100;
#line 942
  lowest_present_cck = 100;
#line 943
  cck = 0U;
#line 944
  ofdm = 0U;
#line 946
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
#line 948
    basic = (unsigned long )(ctx->vif)->bss_conf.basic_rates;
#line 951
    sband = ((priv->hw)->wiphy)->bands[(unsigned int )((priv->hw)->conf.chandef.chan)->band];
#line 953
    tmp = find_first_bit((unsigned long const   *)(& basic), 64UL);
#line 953
    i = (int )tmp;
#line 953
    goto ldv_53099;
    ldv_53098: 
#line 954
    hw = (int )(sband->bitrates + (unsigned long )i)->hw_value;
#line 955
    if (hw > 3) {
#line 956
      ofdm = (int )((u8 )(1UL << (hw + -4))) | (int )ofdm;
#line 957
      if (lowest_present_ofdm > hw) {
#line 958
        lowest_present_ofdm = hw;
      } else {

      }
    } else {
#line 962
      cck = (int )((u8 )(1UL << hw)) | (int )cck;
#line 963
      if (lowest_present_cck > hw) {
#line 964
        lowest_present_cck = hw;
      } else {

      }
    }
#line 953
    tmp___0 = find_next_bit((unsigned long const   *)(& basic), 64UL, (unsigned long )(i + 1));
#line 953
    i = (int )tmp___0;
    ldv_53099: ;
#line 953
    if (i <= 63) {
#line 955
      goto ldv_53098;
    } else {

    }

  } else {

  }
#line 992
  if (lowest_present_ofdm > 8) {
#line 993
    ofdm = (u8 )((unsigned int )ofdm | 16U);
  } else {

  }
#line 994
  if (lowest_present_ofdm > 6) {
#line 995
    ofdm = (u8 )((unsigned int )ofdm | 4U);
  } else {

  }
#line 997
  ofdm = (u8 )((unsigned int )ofdm | 1U);
#line 1012
  if (lowest_present_cck > 3) {
#line 1013
    cck = (u8 )((unsigned int )cck | 8U);
  } else {

  }
#line 1014
  if (lowest_present_cck > 2) {
#line 1015
    cck = (u8 )((unsigned int )cck | 4U);
  } else {

  }
#line 1016
  if (lowest_present_cck > 1) {
#line 1017
    cck = (u8 )((unsigned int )cck | 2U);
  } else {

  }
#line 1019
  cck = (u8 )((unsigned int )cck | 1U);
#line 1021
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_calc_basic_rates", "Set basic rates cck:0x%.2x ofdm:0x%.2x\n",
            (int )cck, (int )ofdm);
#line 1025
  ctx->staging.cck_basic_rates = cck;
#line 1026
  ctx->staging.ofdm_basic_rates = ofdm;
#line 1027
  return;
}
}
#line 1047 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
int iwlagn_commit_rxon(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_rxon_cmd *active ;
  bool new_assoc ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1050
  active = (struct iwl_rxon_cmd *)(& ctx->active);
#line 1051
  new_assoc = (ctx->staging.filter_flags & 32U) != 0U;
#line 1054
  if (debug_locks != 0) {
#line 1054
    tmp = lock_is_held(& priv->mutex.dep_map);
#line 1054
    if (tmp == 0) {
#line 1054
      tmp___0 = 1;
    } else {
#line 1054
      tmp___0 = 0;
    }
  } else {
#line 1054
    tmp___0 = 0;
  }
#line 1054
  __ret_warn_on = tmp___0;
#line 1054
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1054
  if (tmp___1 != 0L) {
#line 1054
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       1054);
  } else {

  }
#line 1054
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1056
  tmp___2 = iwl_is_alive(priv);
#line 1056
  if (tmp___2 == 0) {
#line 1057
    return (-16);
  } else {

  }
#line 1062
  if (! ctx->is_active) {
#line 1063
    return (0);
  } else {

  }
#line 1066
  ctx->staging.flags = ctx->staging.flags | 32768U;
#line 1069
  iwl_calc_basic_rates(priv, ctx);
#line 1075
  if (! priv->hw_params.use_rts_for_aggregation) {
#line 1076
    ctx->staging.flags = ctx->staging.flags | 1073741824U;
  } else {

  }
#line 1078
  if (((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (int )(ctx->vif)->bss_conf.use_short_slot) || (ctx->staging.flags & 1U) == 0U) {
#line 1080
    ctx->staging.flags = ctx->staging.flags | 16U;
  } else {
#line 1082
    ctx->staging.flags = ctx->staging.flags & 4294967279U;
  }
#line 1084
  iwl_print_rx_config_cmd(priv, ctx->ctxid);
#line 1085
  ret = iwl_check_rxon_cmd(priv, ctx);
#line 1086
  if (ret != 0) {
#line 1087
    __iwl_err(priv->dev, 0, 0, "Invalid RXON configuration. Not committing.\n");
#line 1088
    return (-22);
  } else {

  }
#line 1095
  tmp___3 = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->status));
#line 1095
  if (tmp___3 != 0 && (int )priv->switch_channel != (int )ctx->staging.channel) {
#line 1097
    __iwl_dbg(priv->dev, 268435456U, 0, "iwlagn_commit_rxon", "abort channel switch on %d\n",
              (int )priv->switch_channel);
#line 1099
    iwl_chswitch_done(priv, 0);
  } else {

  }
#line 1107
  tmp___4 = iwl_full_rxon_required(priv, ctx);
#line 1107
  if (tmp___4 == 0) {
#line 1108
    ret = iwlagn_send_rxon_assoc(priv, ctx);
#line 1109
    if (ret != 0) {
#line 1110
      __iwl_err(priv->dev, 0, 0, "Error setting RXON_ASSOC (%d)\n", ret);
#line 1111
      return (ret);
    } else {

    }
#line 1114
    memcpy((void *)active, (void const   *)(& ctx->staging), 50UL);
#line 1119
    iwl_set_tx_power(priv, (int )priv->tx_power_next, 0);
#line 1122
    iwl_power_update_mode(priv, 1);
#line 1124
    return (0);
  } else {

  }
#line 1127
  iwl_set_rxon_hwcrypto(priv, ctx, iwlwifi_mod_params.sw_crypto == 0);
#line 1129
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_commit_rxon", "Going to commit RXON\n  * with%s RXON_FILTER_ASSOC_MSK\n  * channel = %d\n  * bssid = %pM\n",
            (int )new_assoc ? (char *)"" : (char *)"out", (int )ctx->staging.channel,
            (u8 *)(& ctx->staging.bssid_addr));
#line 1144
  ret = iwlagn_rxon_disconn(priv, ctx);
#line 1145
  if (ret != 0) {
#line 1146
    return (ret);
  } else {

  }
#line 1148
  ret = iwlagn_set_pan_params(priv);
#line 1149
  if (ret != 0) {
#line 1150
    return (ret);
  } else {

  }
#line 1152
  if ((int )new_assoc) {
#line 1153
    tmp___5 = iwlagn_rxon_connect(priv, ctx);
#line 1153
    return (tmp___5);
  } else {

  }
#line 1155
  return (0);
}
}
#line 1158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
void iwlagn_config_ht40(struct ieee80211_conf *conf , struct iwl_rxon_context *ctx ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
#line 1161
  tmp___0 = conf_is_ht40_minus(conf);
#line 1161
  if ((int )tmp___0) {
#line 1162
    ctx->ht.extension_chan_offset = 3U;
#line 1164
    ctx->ht.is_40mhz = 1;
  } else {
#line 1165
    tmp = conf_is_ht40_plus(conf);
#line 1165
    if ((int )tmp) {
#line 1166
      ctx->ht.extension_chan_offset = 1U;
#line 1168
      ctx->ht.is_40mhz = 1;
    } else {
#line 1170
      ctx->ht.extension_chan_offset = 0U;
#line 1172
      ctx->ht.is_40mhz = 0;
    }
  }
#line 1174
  return;
}
}
#line 1176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
int iwlagn_mac_config(struct ieee80211_hw *hw , u32 changed ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct ieee80211_conf *conf ;
  struct ieee80211_channel *channel ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1178
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1180
  conf = & hw->conf;
#line 1181
  channel = conf->chandef.chan;
#line 1182
  ret = 0;
#line 1184
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "enter: changed %#x\n", changed);
#line 1186
  ldv_mutex_lock_551(& priv->mutex);
#line 1188
  tmp = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 1188
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 1188
  if (tmp___0 != 0L) {
#line 1189
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "leave - scanning\n");
#line 1190
    goto out;
  } else {

  }
#line 1193
  tmp___1 = iwl_is_ready(priv);
#line 1193
  if (tmp___1 == 0) {
#line 1194
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "leave - not ready\n");
#line 1195
    goto out;
  } else {

  }
#line 1198
  if ((changed & 66U) != 0U) {
#line 1201
    priv->current_ht_config.smps = conf->smps_mode;
#line 1210
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 1210
    goto ldv_53128;
    ldv_53127: ;
#line 1210
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 1211
      iwlagn_set_rxon_chain(priv, ctx);
    } else {

    }
#line 1210
    ctx = ctx + 1;
    ldv_53128: ;
#line 1210
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 1212
      goto ldv_53127;
    } else {

    }

  } else {

  }
#line 1214
  if ((changed & 64U) != 0U) {
#line 1215
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 1215
    goto ldv_53131;
    ldv_53130: ;
#line 1215
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 1217
      tmp___2 = conf_is_ht(conf);
#line 1217
      if ((int )ctx->ht.enabled != (int )tmp___2) {
#line 1218
        ctx->ht.enabled = conf_is_ht(conf);
      } else {

      }
#line 1220
      if ((int )ctx->ht.enabled) {
#line 1223
        if (! ctx->ht.is_40mhz) {
#line 1225
          iwlagn_config_ht40(conf, ctx);
        } else {
#line 1223
          tmp___3 = iwl_is_associated_ctx(ctx);
#line 1223
          if (tmp___3 == 0) {
#line 1225
            iwlagn_config_ht40(conf, ctx);
          } else {

          }
        }
      } else {
#line 1227
        ctx->ht.is_40mhz = 0;
      }
#line 1233
      ctx->ht.protection = 0U;
#line 1238
      if ((int )ctx->staging.channel != (int )channel->hw_value) {
#line 1240
        ctx->staging.flags = 0U;
      } else {

      }
#line 1242
      iwl_set_rxon_channel(priv, channel, ctx);
#line 1243
      iwl_set_rxon_ht(priv, & priv->current_ht_config);
#line 1245
      iwl_set_flags_for_band(priv, ctx, channel->band, ctx->vif);
    } else {

    }
#line 1215
    ctx = ctx + 1;
    ldv_53131: ;
#line 1215
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 1217
      goto ldv_53130;
    } else {

    }
#line 1249
    iwl_update_bcast_stations(priv);
  } else {

  }
#line 1252
  if ((changed & 272U) != 0U) {
#line 1254
    ret = iwl_power_update_mode(priv, 0);
#line 1255
    if (ret != 0) {
#line 1256
      __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "Error setting sleep level\n");
    } else {

    }
  } else {

  }
#line 1259
  if ((changed & 32U) != 0U) {
#line 1260
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "TX Power old=%d new=%d\n", (int )priv->tx_power_user_lmt,
              conf->power_level);
#line 1263
    iwl_set_tx_power(priv, (int )((s8 )conf->power_level), 0);
  } else {

  }
#line 1266
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 1266
  goto ldv_53135;
  ldv_53134: ;
#line 1266
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 1267
    tmp___4 = memcmp((void const   *)(& ctx->staging), (void const   *)(& ctx->active),
                     50UL);
#line 1267
    if (tmp___4 == 0) {
#line 1268
      goto ldv_53133;
    } else {

    }
#line 1269
    iwlagn_commit_rxon(priv, ctx);
  } else {

  }
  ldv_53133: 
#line 1266
  ctx = ctx + 1;
  ldv_53135: ;
#line 1266
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 1268
    goto ldv_53134;
  } else {

  }

  out: 
#line 1272
  ldv_mutex_unlock_552(& priv->mutex);
#line 1273
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "leave\n");
#line 1275
  return (ret);
}
}
#line 1278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static void iwlagn_check_needed_chains(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                       struct ieee80211_bss_conf *bss_conf ) 
{ 
  struct ieee80211_vif *vif ;
  struct iwl_rxon_context *tmp ;
  struct ieee80211_sta *sta ;
  struct iwl_ht_config *ht_conf ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  bool need_multiple ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int maxstreams ;

  {
#line 1282
  vif = ctx->vif;
#line 1285
  ht_conf = & priv->current_ht_config;
#line 1289
  if (debug_locks != 0) {
#line 1289
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
#line 1289
    if (tmp___0 == 0) {
#line 1289
      tmp___1 = 1;
    } else {
#line 1289
      tmp___1 = 0;
    }
  } else {
#line 1289
    tmp___1 = 0;
  }
#line 1289
  __ret_warn_on = tmp___1;
#line 1289
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1289
  if (tmp___2 != 0L) {
#line 1289
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       1289);
  } else {

  }
#line 1289
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1291
  switch ((unsigned int )vif->type) {
  case 2U: 
#line 1293
  rcu_read_lock___0();
#line 1294
  sta = ieee80211_find_sta(vif, bss_conf->bssid);
#line 1295
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) {
#line 1302
    need_multiple = 0;
#line 1303
    rcu_read_unlock___0();
#line 1304
    goto ldv_53151;
  } else {

  }
#line 1307
  ht_cap = & sta->ht_cap;
#line 1309
  need_multiple = 1;
#line 1315
  if ((unsigned int )ht_cap->mcs.rx_mask[1] == 0U && (unsigned int )ht_cap->mcs.rx_mask[2] == 0U) {
#line 1317
    need_multiple = 0;
  } else
#line 1318
  if (((int )ht_cap->mcs.tx_params & 1) == 0) {
#line 1321
    need_multiple = 0;
  } else
#line 1322
  if (((int )ht_cap->mcs.tx_params & 2) != 0) {
#line 1333
    maxstreams = (int )ht_cap->mcs.tx_params & 12;
#line 1335
    maxstreams = maxstreams >> 2;
#line 1337
    maxstreams = maxstreams + 1;
#line 1339
    if (maxstreams <= 1) {
#line 1340
      need_multiple = 0;
    } else {

    }
  } else {

  }
#line 1343
  rcu_read_unlock___0();
#line 1344
  goto ldv_53151;
  case 1U: 
#line 1347
  need_multiple = 0;
#line 1348
  goto ldv_53151;
  default: 
#line 1351
  need_multiple = 1;
#line 1352
  goto ldv_53151;
  }
  ldv_53151: 
#line 1355
  ctx->ht_need_multiple_chains = need_multiple;
#line 1357
  if (! need_multiple) {
#line 1359
    tmp = (struct iwl_rxon_context *)(& priv->contexts);
#line 1359
    goto ldv_53158;
    ldv_53157: ;
#line 1359
    if ((int )((unsigned long )priv->valid_contexts >> (int )tmp->ctxid) & 1) {
#line 1360
      if ((unsigned long )tmp->vif == (unsigned long )((struct ieee80211_vif *)0)) {
#line 1361
        goto ldv_53155;
      } else {

      }
#line 1362
      if ((int )tmp->ht_need_multiple_chains) {
#line 1363
        need_multiple = 1;
#line 1364
        goto ldv_53156;
      } else {

      }
    } else {

    }
    ldv_53155: 
#line 1359
    tmp = tmp + 1;
    ldv_53158: ;
#line 1359
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp) {
#line 1361
      goto ldv_53157;
    } else {

    }
    ldv_53156: ;
  } else {

  }
#line 1369
  ht_conf->single_chain_sufficient = (bool )(! ((int )need_multiple != 0));
#line 1370
  return;
}
}
#line 1372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
static void iwlagn_chain_noise_reset(struct iwl_priv *priv ) 
{ 
  struct iwl_chain_noise_data *data ;
  int ret ;
  struct iwl_calib_chain_noise_reset_cmd cmd ;
  int tmp ;

  {
#line 1374
  data = & priv->chain_noise_data;
#line 1377
  if ((priv->calib_disabled & 2U) != 0U) {
#line 1378
    return;
  } else {

  }
#line 1380
  if ((unsigned int )data->state == 0U) {
#line 1380
    tmp = iwl_is_any_associated___2(priv);
#line 1380
    if (tmp != 0) {
#line 1385
      data->chain_noise_a = 0U;
#line 1386
      data->chain_noise_b = 0U;
#line 1387
      data->chain_noise_c = 0U;
#line 1388
      data->chain_signal_a = 0U;
#line 1389
      data->chain_signal_b = 0U;
#line 1390
      data->chain_signal_c = 0U;
#line 1391
      data->beacon_count = 0U;
#line 1393
      memset((void *)(& cmd), 0, 4UL);
#line 1394
      iwl_set_calib_hdr(& cmd.hdr, (int )priv->phy_calib_chain_noise_reset_cmd);
#line 1396
      ret = iwl_dvm_send_cmd_pdu(priv, 176, 0U, 4, (void const   *)(& cmd));
#line 1399
      if (ret != 0) {
#line 1400
        __iwl_err(priv->dev, 0, 0, "Could not send REPLY_PHY_CALIBRATION_CMD\n");
      } else {

      }
#line 1402
      data->state = 1U;
#line 1403
      __iwl_dbg(priv->dev, 2097152U, 0, "iwlagn_chain_noise_reset", "Run chain_noise_calibrate\n");
    } else {

    }
  } else {

  }
#line 1405
  return;
}
}
#line 1407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
void iwlagn_bss_info_changed(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                             struct ieee80211_bss_conf *bss_conf , u32 changes ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  int ret ;
  bool force ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1412
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
#line 1413
  tmp = iwl_rxon_ctx_from_vif(vif);
#line 1413
  ctx = tmp;
#line 1415
  force = 0;
#line 1417
  ldv_mutex_lock_553(& priv->mutex);
#line 1419
  if ((changes & 16384U) != 0U && (int )bss_conf->idle) {
#line 1424
    iwlagn_lift_passive_no_rx(priv);
  } else {

  }
#line 1427
  tmp___0 = iwl_is_ready(priv);
#line 1427
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 1427
  if (tmp___1 != 0L) {
#line 1428
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_bss_info_changed", "leave - not ready\n");
#line 1429
    ldv_mutex_unlock_554(& priv->mutex);
#line 1430
    return;
  } else {

  }
#line 1433
  tmp___2 = ldv__builtin_expect((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0),
                             0L);
#line 1433
  if (tmp___2 != 0L) {
#line 1434
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_bss_info_changed", "leave - vif is NULL\n");
#line 1435
    ldv_mutex_unlock_555(& priv->mutex);
#line 1436
    return;
  } else {

  }
#line 1439
  if ((changes & 64U) != 0U) {
#line 1440
    force = 1;
  } else {

  }
#line 1442
  if ((changes & 8192U) != 0U) {
#line 1443
    ctx->qos_data.qos_active = (int )bss_conf->qos;
#line 1444
    iwlagn_update_qos(priv, ctx);
  } else {

  }
#line 1447
  ctx->staging.assoc_id = vif->bss_conf.aid;
#line 1448
  if ((int )vif->bss_conf.use_short_preamble) {
#line 1449
    ctx->staging.flags = ctx->staging.flags | 32U;
  } else {
#line 1451
    ctx->staging.flags = ctx->staging.flags & 4294967263U;
  }
#line 1453
  if ((int )changes & 1) {
#line 1454
    if ((int )bss_conf->assoc) {
#line 1455
      priv->timestamp = bss_conf->sync_tsf;
#line 1456
      ctx->staging.filter_flags = ctx->staging.filter_flags | 32U;
    } else {
#line 1458
      ctx->staging.filter_flags = ctx->staging.filter_flags & 4294967263U;
#line 1460
      if ((unsigned int )ctx->ctxid == 0U) {
#line 1461
        priv->have_rekey_data = 0;
      } else {

      }
    }
#line 1464
    iwlagn_bt_coex_rssi_monitor(priv);
  } else {

  }
#line 1467
  if ((int )ctx->ht.enabled) {
#line 1468
    ctx->ht.protection = (unsigned int )((u8 )bss_conf->ht_operation_mode) & 3U;
#line 1470
    ctx->ht.non_gf_sta_present = ((int )bss_conf->ht_operation_mode & 4) != 0;
#line 1472
    iwlagn_check_needed_chains(priv, ctx, bss_conf);
#line 1473
    iwl_set_rxon_ht(priv, & priv->current_ht_config);
  } else {

  }
#line 1476
  iwlagn_set_rxon_chain(priv, ctx);
#line 1478
  if ((int )bss_conf->use_cts_prot && (unsigned int )priv->band != 1U) {
#line 1479
    ctx->staging.flags = ctx->staging.flags | 8U;
  } else {
#line 1481
    ctx->staging.flags = ctx->staging.flags & 4294967287U;
  }
#line 1483
  if ((int )bss_conf->use_cts_prot) {
#line 1484
    ctx->staging.flags = ctx->staging.flags | 1073741824U;
  } else {
#line 1486
    ctx->staging.flags = ctx->staging.flags & 3221225471U;
  }
#line 1488
  memcpy((void *)(& ctx->staging.bssid_addr), (void const   *)bss_conf->bssid, 6UL);
#line 1490
  if ((unsigned int )vif->type == 3U || (unsigned int )vif->type == 1U) {
#line 1492
    if ((int )vif->bss_conf.enable_beacon) {
#line 1493
      ctx->staging.filter_flags = ctx->staging.filter_flags | 32U;
#line 1494
      priv->beacon_ctx = ctx;
    } else {
#line 1496
      ctx->staging.filter_flags = ctx->staging.filter_flags & 4294967263U;
#line 1497
      priv->beacon_ctx = (struct iwl_rxon_context *)0;
    }
  } else {

  }
#line 1509
  if ((unsigned int )vif->type == 2U) {
#line 1510
    if (! bss_conf->assoc) {
#line 1511
      ctx->staging.filter_flags = ctx->staging.filter_flags | 64U;
    } else {
#line 1513
      ctx->staging.filter_flags = ctx->staging.filter_flags & 4294967231U;
    }
  } else {

  }
#line 1517
  if ((int )force) {
#line 1518
    iwlagn_commit_rxon(priv, ctx);
  } else {
#line 1517
    tmp___3 = memcmp((void const   *)(& ctx->staging), (void const   *)(& ctx->active),
                     50UL);
#line 1517
    if (tmp___3 != 0) {
#line 1518
      iwlagn_commit_rxon(priv, ctx);
    } else {

    }
  }
#line 1520
  if ((int )changes & 1 && (int )bss_conf->assoc) {
#line 1526
    if ((unsigned int )priv->chain_noise_data.state == 3U) {
#line 1527
      iwl_power_update_mode(priv, 0);
    } else {

    }
#line 1530
    iwlagn_chain_noise_reset(priv);
#line 1531
    priv->start_calib = 1U;
  } else {

  }
#line 1534
  if ((changes & 2048U) != 0U) {
#line 1535
    ret = iwlagn_manage_ibss_station(priv, vif, (int )bss_conf->ibss_joined);
#line 1537
    if (ret != 0) {
#line 1538
      __iwl_err(priv->dev, 0, 0, "failed to %s IBSS station %pM\n", (int )bss_conf->ibss_joined ? (char *)"add" : (char *)"remove",
                bss_conf->bssid);
    } else {

    }
  } else {

  }
#line 1543
  if ((changes & 256U) != 0U && (unsigned long )priv->beacon_ctx == (unsigned long )ctx) {
#line 1544
    tmp___4 = iwlagn_update_beacon(priv, vif);
#line 1544
    if (tmp___4 != 0) {
#line 1545
      __iwl_err(priv->dev, 0, 0, "Error updating beacon\n");
    } else {

    }
  } else {

  }
#line 1548
  ldv_mutex_unlock_556(& priv->mutex);
#line 1549
  return;
}
}
#line 1551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.c"
void iwlagn_post_scan(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
#line 1559
  iwl_power_set_mode(priv, & priv->power_data.sleep_cmd_next, 0);
#line 1560
  iwl_set_tx_power(priv, (int )priv->tx_power_next, 0);
#line 1566
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 1566
  goto ldv_53182;
  ldv_53181: ;
#line 1566
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 1567
    tmp = memcmp((void const   *)(& ctx->staging), (void const   *)(& ctx->active),
                 50UL);
#line 1567
    if (tmp != 0) {
#line 1568
      iwlagn_commit_rxon(priv, ctx);
    } else {

    }
  } else {

  }
#line 1566
  ctx = ctx + 1;
  ldv_53182: ;
#line 1566
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 1568
    goto ldv_53181;
  } else {

  }
#line 1570
  iwlagn_set_pan_params(priv);
#line 1571
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
bool ldv_queue_work_on_539(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 577
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_work_7(ldv_func_arg3, 2);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
bool ldv_queue_delayed_work_on_540(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_work_7(& ldv_func_arg3->work, 2);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
bool ldv_queue_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_7(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_flush_workqueue_542(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 609
  flush_workqueue(ldv_func_arg1);
#line 611
  call_and_disable_all_7(2);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
bool ldv_queue_delayed_work_on_543(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 618
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 618
  ldv_func_res = tmp;
#line 620
  activate_work_7(& ldv_func_arg3->work, 2);
#line 622
  return (ldv_func_res);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_unlock_545(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 638
  mutex_unlock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_lock_546(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 646
  mutex_lock(ldv_func_arg1);
#line 647
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
int ldv_mutex_trylock_547(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_unlock_548(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 665
  mutex_unlock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_unlock_549(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 673
  mutex_unlock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_lock_550(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 681
  mutex_lock(ldv_func_arg1);
#line 682
  return;
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_lock_551(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 687
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 689
  mutex_lock(ldv_func_arg1);
#line 690
  return;
}
}
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_unlock_552(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 695
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 697
  mutex_unlock(ldv_func_arg1);
#line 698
  return;
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_lock_553(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 703
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 705
  mutex_lock(ldv_func_arg1);
#line 706
  return;
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_unlock_554(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 711
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 713
  mutex_unlock(ldv_func_arg1);
#line 714
  return;
}
}
#line 716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_unlock_555(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 719
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 721
  mutex_unlock(ldv_func_arg1);
#line 722
  return;
}
}
#line 724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/rxon.o.c.prepared"
void ldv_mutex_unlock_556(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 727
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 729
  mutex_unlock(ldv_func_arg1);
#line 730
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags___3(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4801: ;
#line 831
    goto ldv_4801;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_587(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_585(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_588(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_589(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_mutex_lock_584(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_586(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_590(struct mutex *ldv_func_arg1 ) ;
#line 498 "include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held___3(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 500
  lockdep_opinion = 0;
#line 502
  tmp = debug_lockdep_rcu_enabled();
#line 502
  if (tmp == 0) {
#line 503
    return (1);
  } else {

  }
#line 504
  tmp___0 = rcu_is_watching();
#line 504
  if (tmp___0) {
#line 504
    tmp___1 = 0;
  } else {
#line 504
    tmp___1 = 1;
  }
#line 504
  if (tmp___1) {
#line 505
    return (0);
  } else {

  }
#line 506
  tmp___2 = rcu_lockdep_current_cpu_online();
#line 506
  if (tmp___2) {
#line 506
    tmp___3 = 0;
  } else {
#line 506
    tmp___3 = 1;
  }
#line 506
  if (tmp___3) {
#line 507
    return (0);
  } else {

  }
#line 508
  if (debug_locks != 0) {
#line 509
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
#line 510
  if (lockdep_opinion != 0) {
#line 510
    tmp___6 = 1;
  } else {
#line 510
    tmp___4 = preempt_count___2();
#line 510
    if (tmp___4 != 0) {
#line 510
      tmp___6 = 1;
    } else {
#line 510
      _flags = arch_local_save_flags___3();
#line 510
      tmp___5 = arch_irqs_disabled_flags(_flags);
#line 510
      if (tmp___5 != 0) {
#line 510
        tmp___6 = 1;
      } else {
#line 510
        tmp___6 = 0;
      }
    }
  }
#line 510
  return (tmp___6);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_579(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_581(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_580(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_583(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_582(struct workqueue_struct *ldv_func_arg1 ) ;
#line 84 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32___3(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_383 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_385 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 69
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite32.key);
#line 69
  if ((int )tmp___1) {
#line 69
    __rcu_read_lock();
#line 69
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
#line 69
    _________p1 = __u.__val;
#line 69
    ________p1 = _________p1;
#line 69
    tmp = debug_lockdep_rcu_enabled();
#line 69
    if (tmp != 0 && ! __warned) {
#line 69
      tmp___0 = rcu_read_lock_sched_held___3();
#line 69
      if (tmp___0 == 0) {
#line 69
        __warned = 1;
#line 69
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 69
    it_func_ptr = ________p1;
#line 69
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_50433: 
#line 69
      it_func = it_func_ptr->func;
#line 69
      __data = it_func_ptr->data;
#line 69
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 69
      it_func_ptr = it_func_ptr + 1;
#line 69
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 71
        goto ldv_50433;
      } else {

      }

    } else {

    }
#line 69
    __rcu_read_unlock();
  } else {

  }
#line 69
  __rcu_read_lock();
#line 69
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 69
  _________p1___0 = __u___0.__val;
#line 69
  ________p1___0 = _________p1___0;
#line 69
  tmp___2 = debug_lockdep_rcu_enabled();
#line 69
  if (tmp___2 != 0 && ! __warned___0) {
#line 69
    tmp___3 = rcu_read_lock_sched_held___3();
#line 69
    if (tmp___3 == 0) {
#line 69
      __warned___0 = 1;
#line 69
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 69
  __rcu_read_unlock();
#line 71
  return;
}
}
#line 41 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static void iwl_write32___3(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
#line 43
  trace_iwlwifi_dev_iowrite32___3((struct device  const  *)trans->dev, ofs, val);
#line 44
  iwl_trans_write32(trans, ofs, val);
#line 45
  return;
}
}
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl1000_set_ct_threshold(struct iwl_priv *priv ) 
{ 


  {
#line 57
  priv->hw_params.ct_kill_threshold = 110U;
#line 58
  priv->hw_params.ct_kill_exit_threshold = 95U;
#line 59
  return;
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl1000_nic_config(struct iwl_priv *priv ) 
{ 


  {
#line 66
  iwl_set_bits_mask_prph(priv->trans, 12376U, 96U, 4294966815U);
#line 67
  return;
}
}
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
__inline static u32 iwl_beacon_time_mask_low(struct iwl_priv *priv , u16 tsf_bits ) 
{ 


  {
#line 79
  return ((u32 )((1 << (int )tsf_bits) + -1));
}
}
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
__inline static u32 iwl_beacon_time_mask_high(struct iwl_priv *priv , u16 tsf_bits ) 
{ 


  {
#line 90
  return ((u32 )(((1 << (32 - (int )tsf_bits)) + -1) << (int )tsf_bits));
}
}
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static u32 iwl_usecs_to_beacons(struct iwl_priv *priv , u32 usec , u32 beacon_interval ) 
{ 
  u32 quot ;
  u32 rem ;
  u32 interval ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 104
  interval = beacon_interval * 1024U;
#line 106
  if (interval == 0U || usec == 0U) {
#line 107
    return (0U);
  } else {

  }
#line 109
  tmp = iwl_beacon_time_mask_high(priv, 22);
#line 109
  quot = usec / interval & (tmp >> 22);
#line 112
  tmp___0 = iwl_beacon_time_mask_low(priv, 22);
#line 112
  rem = usec % interval & tmp___0;
#line 115
  return ((quot << 22) + rem);
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static __le32 iwl_add_beacon_time(struct iwl_priv *priv , u32 base , u32 addon , u32 beacon_interval ) 
{ 
  u32 base_low ;
  u32 tmp ;
  u32 addon_low ;
  u32 tmp___0 ;
  u32 interval ;
  u32 res ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 124
  tmp = iwl_beacon_time_mask_low(priv, 22);
#line 124
  base_low = tmp & base;
#line 126
  tmp___0 = iwl_beacon_time_mask_low(priv, 22);
#line 126
  addon_low = tmp___0 & addon;
#line 128
  interval = beacon_interval * 1024U;
#line 129
  tmp___1 = iwl_beacon_time_mask_high(priv, 22);
#line 129
  tmp___2 = iwl_beacon_time_mask_high(priv, 22);
#line 129
  res = (tmp___1 & base) + (tmp___2 & addon);
#line 134
  if (base_low > addon_low) {
#line 135
    res = (base_low - addon_low) + res;
  } else
#line 136
  if (base_low < addon_low) {
#line 137
    res = ((interval + base_low) - addon_low) + res;
#line 138
    res = res + 4194304U;
  } else {
#line 140
    res = res + 4194304U;
  }
#line 142
  return (res);
}
}
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static struct iwl_sensitivity_ranges  const  iwl1000_sensitivity  = 
#line 145
     {95U, 95U, 95U, 90U, 170U, 120U, 240U, 120U, 210U, 155U, 290U, 200U, 400U, 125U,
    170U, 190U, 390U, 62U};
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl1000_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
#line 171
  iwl1000_set_ct_threshold(priv);
#line 174
  priv->hw_params.sens = & iwl1000_sensitivity;
#line 175
  return;
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_1000_cfg  = 
#line 177
     {& iwl1000_hw_set_hw_params, 0, & iwl1000_nic_config, & iwlagn_temperature, 0,
    1000, 200U, (_Bool)0, 1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0};
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl2000_set_ct_threshold(struct iwl_priv *priv ) 
{ 


  {
#line 195
  priv->hw_params.ct_kill_threshold = 114U;
#line 196
  priv->hw_params.ct_kill_exit_threshold = 95U;
#line 197
  return;
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl2000_nic_config(struct iwl_priv *priv ) 
{ 


  {
#line 202
  iwl_set_bit(priv->trans, 80U, 128U);
#line 203
  return;
}
}
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static struct iwl_sensitivity_ranges  const  iwl2000_sensitivity  = 
#line 206
     {97U, 97U, 100U, 80U, 128U, 105U, 192U, 145U, 232U, 110U, 232U, 175U, 310U, 125U,
    160U, 190U, 390U, 62U};
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl2000_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
#line 232
  iwl2000_set_ct_threshold(priv);
#line 235
  priv->hw_params.sens = & iwl2000_sensitivity;
#line 236
  return;
}
}
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_2000_cfg  = 
#line 238
     {& iwl2000_hw_set_hw_params, 0, & iwl2000_nic_config, & iwlagn_temperature, 0,
    1000, 50U, 1, 1, 1, (_Bool)0, 1, (_Bool)0, 1, (_Bool)0};
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_105_cfg  = 
#line 251
     {& iwl2000_hw_set_hw_params, 0, & iwl2000_nic_config, & iwlagn_temperature, 0,
    1000, 50U, 1, 1, 1, (_Bool)0, 1, (_Bool)0, 1, 1};
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static struct iwl_dvm_bt_params  const  iwl2030_bt_params  =    {1, 0U, 4042322160U, 1200U, 1, 1};
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_2030_cfg  = 
#line 275
     {& iwl2000_hw_set_hw_params, 0, & iwl2000_nic_config, & iwlagn_temperature, & iwl2030_bt_params,
    1000, 50U, 1, 1, 1, (_Bool)0, 1, (_Bool)0, 1, 1};
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static struct iwl_sensitivity_ranges  const  iwl5000_sensitivity  = 
#line 296
     {100U, 100U, 100U, 90U, 170U, 105U, 220U, 120U, 210U, 120U, 240U, 200U, 400U, 125U,
    200U, 190U, 390U, 62U};
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static struct iwl_sensitivity_ranges  const  iwl5150_sensitivity  = 
#line 320
     {95U, 95U, 95U, 90U, 170U, 105U, 220U, 120U, 210U, 105U, 220U, 200U, 400U, 125U,
    170U, 190U, 390U, 62U};
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static s32 iwl_temp_calib_to_offset(struct iwl_priv *priv ) 
{ 
  u16 temperature ;
  u16 voltage ;

  {
#line 351
  temperature = (priv->nvm_data)->kelvin_temperature;
#line 352
  voltage = (priv->nvm_data)->kelvin_voltage;
#line 355
  return ((int )temperature - (int )voltage / -5);
}
}
#line 359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl5150_set_ct_threshold(struct iwl_priv *priv ) 
{ 
  s32 volt2temp_coef ;
  s32 threshold ;
  s32 tmp ;

  {
#line 361
  volt2temp_coef = -5;
#line 362
  tmp = iwl_temp_calib_to_offset(priv);
#line 362
  threshold = 383 - tmp;
#line 365
  priv->hw_params.ct_kill_threshold = (u32 )(threshold * volt2temp_coef);
#line 366
  return;
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl5000_set_ct_threshold(struct iwl_priv *priv ) 
{ 


  {
#line 371
  priv->hw_params.ct_kill_threshold = 110U;
#line 372
  return;
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl5000_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
#line 376
  iwl5000_set_ct_threshold(priv);
#line 379
  priv->hw_params.sens = & iwl5000_sensitivity;
#line 380
  return;
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl5150_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
#line 384
  iwl5150_set_ct_threshold(priv);
#line 387
  priv->hw_params.sens = & iwl5150_sensitivity;
#line 388
  return;
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl5150_temperature(struct iwl_priv *priv ) 
{ 
  u32 vt ;
  s32 offset ;
  s32 tmp ;

  {
#line 392
  vt = 0U;
#line 393
  tmp = iwl_temp_calib_to_offset(priv);
#line 393
  offset = tmp;
#line 395
  vt = priv->statistics.common.temperature;
#line 396
  vt = vt / 4294967291U + (u32 )offset;
#line 398
  priv->temperature = (s32 )(vt - 273U);
#line 399
  iwl_tt_handler(priv);
#line 400
  return;
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static int iwl5000_hw_channel_switch(struct iwl_priv *priv , struct ieee80211_channel_switch *ch_switch ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl5000_channel_switch_cmd cmd ;
  u32 switch_time_in_usec ;
  u32 ucode_switch_time ;
  u16 ch ;
  u32 tsf_low ;
  u8 switch_count ;
  u16 beacon_interval ;
  struct ieee80211_vif *vif ;
  struct iwl_host_cmd hcmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 409
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 415
  beacon_interval = ctx->timing.beacon_interval;
#line 416
  vif = ctx->vif;
#line 417
  hcmd.data[0] = (void const   *)(& cmd);
#line 417
  tmp = 1U;
#line 417
  while (1) {
#line 417
    if (tmp >= 2U) {
#line 417
      break;
    } else {

    }
#line 417
    hcmd.data[tmp] = 0;
#line 417
    tmp = tmp + 1U;
  }
#line 417
  hcmd.resp_pkt = 0;
#line 417
  hcmd._rx_page_addr = 0UL;
#line 417
  hcmd._rx_page_order = 0U;
#line 417
  hcmd.handler_status = 0;
#line 417
  hcmd.flags = 0U;
#line 417
  hcmd.len[0] = 224U;
#line 417
  tmp___0 = 1U;
#line 417
  while (1) {
#line 417
    if (tmp___0 >= 2U) {
#line 417
      break;
    } else {

    }
#line 417
    hcmd.len[tmp___0] = (unsigned short)0;
#line 417
    tmp___0 = tmp___0 + 1U;
  }
#line 417
  hcmd.dataflags[0] = (unsigned char)0;
#line 417
  hcmd.dataflags[1] = (unsigned char)0;
#line 417
  hcmd.id = 114U;
#line 423
  cmd.band = (unsigned int )priv->band == 0U;
#line 424
  ch = (ch_switch->chandef.chan)->hw_value;
#line 425
  __iwl_dbg(priv->dev, 268435456U, 0, "iwl5000_hw_channel_switch", "channel switch from %d to %d\n",
            (int )ctx->active.channel, (int )ch);
#line 427
  cmd.channel = ch;
#line 428
  cmd.rxon_flags = ctx->staging.flags;
#line 429
  cmd.rxon_filter_flags = ctx->staging.filter_flags;
#line 430
  switch_count = ch_switch->count;
#line 431
  tsf_low = (u32 )ch_switch->timestamp;
#line 436
  if (priv->ucode_beacon_time > tsf_low && (unsigned int )beacon_interval != 0U) {
#line 437
    if ((u32 )switch_count > (priv->ucode_beacon_time - tsf_low) / (u32 )beacon_interval) {
#line 439
      switch_count = (int )switch_count - (int )((u8 )((priv->ucode_beacon_time - tsf_low) / (u32 )beacon_interval));
    } else {
#line 442
      switch_count = 0U;
    }
  } else {

  }
#line 444
  if ((unsigned int )switch_count <= 1U) {
#line 445
    cmd.switch_time = priv->ucode_beacon_time;
  } else {
#line 447
    switch_time_in_usec = (u32 )(((int )vif->bss_conf.beacon_int * (int )switch_count) * 1024);
#line 449
    ucode_switch_time = iwl_usecs_to_beacons(priv, switch_time_in_usec, (u32 )beacon_interval);
#line 452
    cmd.switch_time = iwl_add_beacon_time(priv, priv->ucode_beacon_time, ucode_switch_time,
                                          (u32 )beacon_interval);
  }
#line 457
  __iwl_dbg(priv->dev, 268435456U, 0, "iwl5000_hw_channel_switch", "uCode time for the switch is 0x%x\n",
            cmd.switch_time);
#line 459
  cmd.expect_beacon = (unsigned int )((u8 )(ch_switch->chandef.chan)->flags) & 8U;
#line 462
  tmp___1 = iwl_dvm_send_cmd(priv, & hcmd);
#line 462
  return (tmp___1);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_5000_cfg  = 
#line 465
     {& iwl5000_hw_set_hw_params, & iwl5000_hw_channel_switch, 0, & iwlagn_temperature,
    0, 1000, 100U, (_Bool)0, (_Bool)0, (_Bool)0, 1, (_Bool)0, (_Bool)0, (_Bool)0,
    (_Bool)0};
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_5150_cfg  = 
#line 474
     {& iwl5150_hw_set_hw_params, & iwl5000_hw_channel_switch, 0, & iwl5150_temperature,
    0, 1000, 100U, (_Bool)0, (_Bool)0, (_Bool)0, 1, (_Bool)0, 1, (_Bool)0, (_Bool)0};
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl6000_set_ct_threshold(struct iwl_priv *priv ) 
{ 


  {
#line 494
  priv->hw_params.ct_kill_threshold = 114U;
#line 495
  priv->hw_params.ct_kill_exit_threshold = 95U;
#line 496
  return;
}
}
#line 499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl6000_nic_config(struct iwl_priv *priv ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 501
  switch ((unsigned int )(priv->cfg)->device_family) {
  case 11U: ;
  case 12U: ;
  case 9U: ;
#line 505
  goto ldv_54330;
  case 10U: 
#line 508
  iwl_write32___3(priv->trans, 80U, 2U);
#line 510
  goto ldv_54330;
  case 13U: ;
#line 513
  if ((unsigned int )(priv->nvm_data)->calib_version > 5U) {
#line 514
    iwl_set_bit(priv->trans, 80U, 4U);
  } else {

  }
#line 516
  goto ldv_54330;
  case 14U: ;
#line 519
  if ((unsigned int )(priv->nvm_data)->calib_version > 5U) {
#line 520
    iwl_set_bit(priv->trans, 80U, 4U);
  } else {

  }
#line 522
  iwl_set_bit(priv->trans, 80U, 8U);
#line 524
  goto ldv_54330;
  default: 
#line 526
  __ret_warn_on = 1;
#line 526
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 526
  if (tmp != 0L) {
#line 526
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c",
                       526);
  } else {

  }
#line 526
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_54330: ;
#line 529
  return;
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static struct iwl_sensitivity_ranges  const  iwl6000_sensitivity  = 
#line 530
     {110U, 110U, 110U, 80U, 128U, 105U, 192U, 145U, 232U, 110U, 232U, 175U, 310U, 125U,
    160U, 190U, 336U, 62U};
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static void iwl6000_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
#line 556
  iwl6000_set_ct_threshold(priv);
#line 559
  priv->hw_params.sens = & iwl6000_sensitivity;
#line 560
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static int iwl6000_hw_channel_switch(struct iwl_priv *priv , struct ieee80211_channel_switch *ch_switch ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl6000_channel_switch_cmd *cmd ;
  u32 switch_time_in_usec ;
  u32 ucode_switch_time ;
  u16 ch ;
  u32 tsf_low ;
  u8 switch_count ;
  u16 beacon_interval ;
  struct ieee80211_vif *vif ;
  struct iwl_host_cmd hcmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int err ;
  void *tmp___1 ;

  {
#line 570
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 576
  beacon_interval = ctx->timing.beacon_interval;
#line 577
  vif = ctx->vif;
#line 578
  hcmd.data[0] = 0;
#line 578
  hcmd.data[1] = 0;
#line 578
  hcmd.resp_pkt = 0;
#line 578
  hcmd._rx_page_addr = 0UL;
#line 578
  hcmd._rx_page_order = 0U;
#line 578
  hcmd.handler_status = 0;
#line 578
  hcmd.flags = 0U;
#line 578
  hcmd.len[0] = 328U;
#line 578
  tmp = 1U;
#line 578
  while (1) {
#line 578
    if (tmp >= 2U) {
#line 578
      break;
    } else {

    }
#line 578
    hcmd.len[tmp] = (unsigned short)0;
#line 578
    tmp = tmp + 1U;
  }
#line 578
  hcmd.dataflags[0] = 1U;
#line 578
  tmp___0 = 1U;
#line 578
  while (1) {
#line 578
    if (tmp___0 >= 2U) {
#line 578
      break;
    } else {

    }
#line 578
    hcmd.dataflags[tmp___0] = (unsigned char)0;
#line 578
    tmp___0 = tmp___0 + 1U;
  }
#line 578
  hcmd.id = 114U;
#line 585
  tmp___1 = kzalloc(328UL, 208U);
#line 585
  cmd = (struct iwl6000_channel_switch_cmd *)tmp___1;
#line 586
  if ((unsigned long )cmd == (unsigned long )((struct iwl6000_channel_switch_cmd *)0)) {
#line 587
    return (-12);
  } else {

  }
#line 589
  hcmd.data[0] = (void const   *)cmd;
#line 591
  cmd->band = (unsigned int )priv->band == 0U;
#line 592
  ch = (ch_switch->chandef.chan)->hw_value;
#line 593
  __iwl_dbg(priv->dev, 268435456U, 0, "iwl6000_hw_channel_switch", "channel switch from %u to %u\n",
            (int )ctx->active.channel, (int )ch);
#line 595
  cmd->channel = ch;
#line 596
  cmd->rxon_flags = ctx->staging.flags;
#line 597
  cmd->rxon_filter_flags = ctx->staging.filter_flags;
#line 598
  switch_count = ch_switch->count;
#line 599
  tsf_low = (u32 )ch_switch->timestamp;
#line 604
  if (priv->ucode_beacon_time > tsf_low && (unsigned int )beacon_interval != 0U) {
#line 605
    if ((u32 )switch_count > (priv->ucode_beacon_time - tsf_low) / (u32 )beacon_interval) {
#line 607
      switch_count = (int )switch_count - (int )((u8 )((priv->ucode_beacon_time - tsf_low) / (u32 )beacon_interval));
    } else {
#line 610
      switch_count = 0U;
    }
  } else {

  }
#line 612
  if ((unsigned int )switch_count <= 1U) {
#line 613
    cmd->switch_time = priv->ucode_beacon_time;
  } else {
#line 615
    switch_time_in_usec = (u32 )(((int )vif->bss_conf.beacon_int * (int )switch_count) * 1024);
#line 617
    ucode_switch_time = iwl_usecs_to_beacons(priv, switch_time_in_usec, (u32 )beacon_interval);
#line 620
    cmd->switch_time = iwl_add_beacon_time(priv, priv->ucode_beacon_time, ucode_switch_time,
                                           (u32 )beacon_interval);
  }
#line 625
  __iwl_dbg(priv->dev, 268435456U, 0, "iwl6000_hw_channel_switch", "uCode time for the switch is 0x%x\n",
            cmd->switch_time);
#line 627
  cmd->expect_beacon = (unsigned int )((u8 )(ch_switch->chandef.chan)->flags) & 8U;
#line 630
  err = iwl_dvm_send_cmd(priv, & hcmd);
#line 631
  kfree((void const   *)cmd);
#line 632
  return (err);
}
}
#line 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_6000_cfg  = 
#line 635
     {& iwl6000_hw_set_hw_params, & iwl6000_hw_channel_switch, & iwl6000_nic_config,
    & iwlagn_temperature, 0, 1000, 50U, 1, 1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
    (_Bool)0, (_Bool)0};
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_6005_cfg  = 
#line 646
     {& iwl6000_hw_set_hw_params, & iwl6000_hw_channel_switch, & iwl6000_nic_config,
    & iwlagn_temperature, 0, 1000, 50U, 1, 1, (_Bool)0, (_Bool)0, 1, (_Bool)0, (_Bool)0,
    (_Bool)0};
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_6050_cfg  = 
#line 658
     {& iwl6000_hw_set_hw_params, & iwl6000_hw_channel_switch, & iwl6000_nic_config,
    & iwlagn_temperature, 0, 1500, 50U, 1, 1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
    (_Bool)0, (_Bool)0};
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
static struct iwl_dvm_bt_params  const  iwl6000_bt_params  =    {1, 0U, 240U, 1200U, 1, (_Bool)0};
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.c"
struct iwl_dvm_cfg  const  iwl_dvm_6030_cfg  = 
#line 678
     {& iwl6000_hw_set_hw_params, & iwl6000_hw_channel_switch, & iwl6000_nic_config,
    & iwlagn_temperature, & iwl6000_bt_params, 1000, 50U, 1, 1, (_Bool)0, (_Bool)0,
    1, (_Bool)0, (_Bool)0, 1};
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_62(void) 
{ 
  void *tmp ;

  {
#line 551
  tmp = ldv_init_zalloc(14448UL);
#line 551
  iwl_dvm_2000_cfg_group0 = (struct iwl_priv *)tmp;
#line 552
  return;
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_63(void) 
{ 
  void *tmp ;

  {
#line 555
  tmp = ldv_init_zalloc(14448UL);
#line 555
  iwl_dvm_1000_cfg_group0 = (struct iwl_priv *)tmp;
#line 556
  return;
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_56(void) 
{ 
  void *tmp ;

  {
#line 559
  tmp = ldv_init_zalloc(14448UL);
#line 559
  iwl_dvm_6005_cfg_group0 = (struct iwl_priv *)tmp;
#line 560
  return;
}
}
#line 562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_54(void) 
{ 
  void *tmp ;

  {
#line 563
  tmp = ldv_init_zalloc(14448UL);
#line 563
  iwl_dvm_6030_cfg_group0 = (struct iwl_priv *)tmp;
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_59(void) 
{ 
  void *tmp ;

  {
#line 567
  tmp = ldv_init_zalloc(14448UL);
#line 567
  iwl_dvm_5000_cfg_group0 = (struct iwl_priv *)tmp;
#line 568
  return;
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_57(void) 
{ 
  void *tmp ;

  {
#line 571
  tmp = ldv_init_zalloc(14448UL);
#line 571
  iwl_dvm_6000_cfg_group0 = (struct iwl_priv *)tmp;
#line 572
  return;
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_61(void) 
{ 
  void *tmp ;

  {
#line 575
  tmp = ldv_init_zalloc(14448UL);
#line 575
  iwl_dvm_105_cfg_group0 = (struct iwl_priv *)tmp;
#line 576
  return;
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_55(void) 
{ 
  void *tmp ;

  {
#line 579
  tmp = ldv_init_zalloc(14448UL);
#line 579
  iwl_dvm_6050_cfg_group0 = (struct iwl_priv *)tmp;
#line 580
  return;
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_60(void) 
{ 
  void *tmp ;

  {
#line 583
  tmp = ldv_init_zalloc(14448UL);
#line 583
  iwl_dvm_2030_cfg_group0 = (struct iwl_priv *)tmp;
#line 584
  return;
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_initialize_iwl_dvm_cfg_58(void) 
{ 
  void *tmp ;

  {
#line 587
  tmp = ldv_init_zalloc(14448UL);
#line 587
  iwl_dvm_5150_cfg_group0 = (struct iwl_priv *)tmp;
#line 588
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_63(void) 
{ 
  int tmp ;

  {
#line 592
  tmp = __VERIFIER_nondet_int();
#line 592
  switch (tmp) {
  case 0: ;
#line 595
  if (ldv_state_variable_63 == 1) {
#line 597
    iwl1000_nic_config(iwl_dvm_1000_cfg_group0);
#line 599
    ldv_state_variable_63 = 1;
  } else {

  }
#line 602
  goto ldv_54396;
  case 1: ;
#line 605
  if (ldv_state_variable_63 == 1) {
#line 607
    iwlagn_temperature(iwl_dvm_1000_cfg_group0);
#line 609
    ldv_state_variable_63 = 1;
  } else {

  }
#line 612
  goto ldv_54396;
  case 2: ;
#line 615
  if (ldv_state_variable_63 == 1) {
#line 617
    iwl1000_hw_set_hw_params(iwl_dvm_1000_cfg_group0);
#line 619
    ldv_state_variable_63 = 1;
  } else {

  }
#line 622
  goto ldv_54396;
  default: 
#line 623
  ldv_stop();
  }
  ldv_54396: ;
#line 627
  return;
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_57(void) 
{ 
  struct ieee80211_channel_switch *ldvarg40 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 630
  tmp = ldv_init_zalloc(48UL);
#line 630
  ldvarg40 = (struct ieee80211_channel_switch *)tmp;
#line 632
  tmp___0 = __VERIFIER_nondet_int();
#line 632
  switch (tmp___0) {
  case 0: ;
#line 635
  if (ldv_state_variable_57 == 1) {
#line 637
    iwl6000_nic_config(iwl_dvm_6000_cfg_group0);
#line 639
    ldv_state_variable_57 = 1;
  } else {

  }
#line 642
  goto ldv_54405;
  case 1: ;
#line 645
  if (ldv_state_variable_57 == 1) {
#line 647
    iwlagn_temperature(iwl_dvm_6000_cfg_group0);
#line 649
    ldv_state_variable_57 = 1;
  } else {

  }
#line 652
  goto ldv_54405;
  case 2: ;
#line 655
  if (ldv_state_variable_57 == 1) {
#line 657
    iwl6000_hw_set_hw_params(iwl_dvm_6000_cfg_group0);
#line 659
    ldv_state_variable_57 = 1;
  } else {

  }
#line 662
  goto ldv_54405;
  case 3: ;
#line 665
  if (ldv_state_variable_57 == 1) {
#line 667
    iwl6000_hw_channel_switch(iwl_dvm_6000_cfg_group0, ldvarg40);
#line 669
    ldv_state_variable_57 = 1;
  } else {

  }
#line 672
  goto ldv_54405;
  default: 
#line 673
  ldv_stop();
  }
  ldv_54405: ;
#line 677
  return;
}
}
#line 679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_61(void) 
{ 
  int tmp ;

  {
#line 681
  tmp = __VERIFIER_nondet_int();
#line 681
  switch (tmp) {
  case 0: ;
#line 684
  if (ldv_state_variable_61 == 1) {
#line 686
    iwl2000_nic_config(iwl_dvm_105_cfg_group0);
#line 688
    ldv_state_variable_61 = 1;
  } else {

  }
#line 691
  goto ldv_54414;
  case 1: ;
#line 694
  if (ldv_state_variable_61 == 1) {
#line 696
    iwlagn_temperature(iwl_dvm_105_cfg_group0);
#line 698
    ldv_state_variable_61 = 1;
  } else {

  }
#line 701
  goto ldv_54414;
  case 2: ;
#line 704
  if (ldv_state_variable_61 == 1) {
#line 706
    iwl2000_hw_set_hw_params(iwl_dvm_105_cfg_group0);
#line 708
    ldv_state_variable_61 = 1;
  } else {

  }
#line 711
  goto ldv_54414;
  default: 
#line 712
  ldv_stop();
  }
  ldv_54414: ;
#line 716
  return;
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_58(void) 
{ 
  struct ieee80211_channel_switch *ldvarg155 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 719
  tmp = ldv_init_zalloc(48UL);
#line 719
  ldvarg155 = (struct ieee80211_channel_switch *)tmp;
#line 721
  tmp___0 = __VERIFIER_nondet_int();
#line 721
  switch (tmp___0) {
  case 0: ;
#line 724
  if (ldv_state_variable_58 == 1) {
#line 726
    iwl5150_temperature(iwl_dvm_5150_cfg_group0);
#line 728
    ldv_state_variable_58 = 1;
  } else {

  }
#line 731
  goto ldv_54423;
  case 1: ;
#line 734
  if (ldv_state_variable_58 == 1) {
#line 736
    iwl5150_hw_set_hw_params(iwl_dvm_5150_cfg_group0);
#line 738
    ldv_state_variable_58 = 1;
  } else {

  }
#line 741
  goto ldv_54423;
  case 2: ;
#line 744
  if (ldv_state_variable_58 == 1) {
#line 746
    iwl5000_hw_channel_switch(iwl_dvm_5150_cfg_group0, ldvarg155);
#line 748
    ldv_state_variable_58 = 1;
  } else {

  }
#line 751
  goto ldv_54423;
  default: 
#line 752
  ldv_stop();
  }
  ldv_54423: ;
#line 756
  return;
}
}
#line 758 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_59(void) 
{ 
  struct ieee80211_channel_switch *ldvarg236 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 759
  tmp = ldv_init_zalloc(48UL);
#line 759
  ldvarg236 = (struct ieee80211_channel_switch *)tmp;
#line 761
  tmp___0 = __VERIFIER_nondet_int();
#line 761
  switch (tmp___0) {
  case 0: ;
#line 764
  if (ldv_state_variable_59 == 1) {
#line 766
    iwlagn_temperature(iwl_dvm_5000_cfg_group0);
#line 768
    ldv_state_variable_59 = 1;
  } else {

  }
#line 771
  goto ldv_54432;
  case 1: ;
#line 774
  if (ldv_state_variable_59 == 1) {
#line 776
    iwl5000_hw_set_hw_params(iwl_dvm_5000_cfg_group0);
#line 778
    ldv_state_variable_59 = 1;
  } else {

  }
#line 781
  goto ldv_54432;
  case 2: ;
#line 784
  if (ldv_state_variable_59 == 1) {
#line 786
    iwl5000_hw_channel_switch(iwl_dvm_5000_cfg_group0, ldvarg236);
#line 788
    ldv_state_variable_59 = 1;
  } else {

  }
#line 791
  goto ldv_54432;
  default: 
#line 792
  ldv_stop();
  }
  ldv_54432: ;
#line 796
  return;
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_60(void) 
{ 
  int tmp ;

  {
#line 800
  tmp = __VERIFIER_nondet_int();
#line 800
  switch (tmp) {
  case 0: ;
#line 803
  if (ldv_state_variable_60 == 1) {
#line 805
    iwl2000_nic_config(iwl_dvm_2030_cfg_group0);
#line 807
    ldv_state_variable_60 = 1;
  } else {

  }
#line 810
  goto ldv_54440;
  case 1: ;
#line 813
  if (ldv_state_variable_60 == 1) {
#line 815
    iwlagn_temperature(iwl_dvm_2030_cfg_group0);
#line 817
    ldv_state_variable_60 = 1;
  } else {

  }
#line 820
  goto ldv_54440;
  case 2: ;
#line 823
  if (ldv_state_variable_60 == 1) {
#line 825
    iwl2000_hw_set_hw_params(iwl_dvm_2030_cfg_group0);
#line 827
    ldv_state_variable_60 = 1;
  } else {

  }
#line 830
  goto ldv_54440;
  default: 
#line 831
  ldv_stop();
  }
  ldv_54440: ;
#line 835
  return;
}
}
#line 837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_56(void) 
{ 
  struct ieee80211_channel_switch *ldvarg166 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 838
  tmp = ldv_init_zalloc(48UL);
#line 838
  ldvarg166 = (struct ieee80211_channel_switch *)tmp;
#line 840
  tmp___0 = __VERIFIER_nondet_int();
#line 840
  switch (tmp___0) {
  case 0: ;
#line 843
  if (ldv_state_variable_56 == 1) {
#line 845
    iwl6000_nic_config(iwl_dvm_6005_cfg_group0);
#line 847
    ldv_state_variable_56 = 1;
  } else {

  }
#line 850
  goto ldv_54449;
  case 1: ;
#line 853
  if (ldv_state_variable_56 == 1) {
#line 855
    iwlagn_temperature(iwl_dvm_6005_cfg_group0);
#line 857
    ldv_state_variable_56 = 1;
  } else {

  }
#line 860
  goto ldv_54449;
  case 2: ;
#line 863
  if (ldv_state_variable_56 == 1) {
#line 865
    iwl6000_hw_set_hw_params(iwl_dvm_6005_cfg_group0);
#line 867
    ldv_state_variable_56 = 1;
  } else {

  }
#line 870
  goto ldv_54449;
  case 3: ;
#line 873
  if (ldv_state_variable_56 == 1) {
#line 875
    iwl6000_hw_channel_switch(iwl_dvm_6005_cfg_group0, ldvarg166);
#line 877
    ldv_state_variable_56 = 1;
  } else {

  }
#line 880
  goto ldv_54449;
  default: 
#line 881
  ldv_stop();
  }
  ldv_54449: ;
#line 885
  return;
}
}
#line 887 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_62(void) 
{ 
  int tmp ;

  {
#line 889
  tmp = __VERIFIER_nondet_int();
#line 889
  switch (tmp) {
  case 0: ;
#line 892
  if (ldv_state_variable_62 == 1) {
#line 894
    iwl2000_nic_config(iwl_dvm_2000_cfg_group0);
#line 896
    ldv_state_variable_62 = 1;
  } else {

  }
#line 899
  goto ldv_54458;
  case 1: ;
#line 902
  if (ldv_state_variable_62 == 1) {
#line 904
    iwlagn_temperature(iwl_dvm_2000_cfg_group0);
#line 906
    ldv_state_variable_62 = 1;
  } else {

  }
#line 909
  goto ldv_54458;
  case 2: ;
#line 912
  if (ldv_state_variable_62 == 1) {
#line 914
    iwl2000_hw_set_hw_params(iwl_dvm_2000_cfg_group0);
#line 916
    ldv_state_variable_62 = 1;
  } else {

  }
#line 919
  goto ldv_54458;
  default: 
#line 920
  ldv_stop();
  }
  ldv_54458: ;
#line 924
  return;
}
}
#line 926 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_54(void) 
{ 
  struct ieee80211_channel_switch *ldvarg185 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 927
  tmp = ldv_init_zalloc(48UL);
#line 927
  ldvarg185 = (struct ieee80211_channel_switch *)tmp;
#line 929
  tmp___0 = __VERIFIER_nondet_int();
#line 929
  switch (tmp___0) {
  case 0: ;
#line 932
  if (ldv_state_variable_54 == 1) {
#line 934
    iwl6000_nic_config(iwl_dvm_6030_cfg_group0);
#line 936
    ldv_state_variable_54 = 1;
  } else {

  }
#line 939
  goto ldv_54467;
  case 1: ;
#line 942
  if (ldv_state_variable_54 == 1) {
#line 944
    iwlagn_temperature(iwl_dvm_6030_cfg_group0);
#line 946
    ldv_state_variable_54 = 1;
  } else {

  }
#line 949
  goto ldv_54467;
  case 2: ;
#line 952
  if (ldv_state_variable_54 == 1) {
#line 954
    iwl6000_hw_set_hw_params(iwl_dvm_6030_cfg_group0);
#line 956
    ldv_state_variable_54 = 1;
  } else {

  }
#line 959
  goto ldv_54467;
  case 3: ;
#line 962
  if (ldv_state_variable_54 == 1) {
#line 964
    iwl6000_hw_channel_switch(iwl_dvm_6030_cfg_group0, ldvarg185);
#line 966
    ldv_state_variable_54 = 1;
  } else {

  }
#line 969
  goto ldv_54467;
  default: 
#line 970
  ldv_stop();
  }
  ldv_54467: ;
#line 974
  return;
}
}
#line 976 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_main_exported_55(void) 
{ 
  struct ieee80211_channel_switch *ldvarg34 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 977
  tmp = ldv_init_zalloc(48UL);
#line 977
  ldvarg34 = (struct ieee80211_channel_switch *)tmp;
#line 979
  tmp___0 = __VERIFIER_nondet_int();
#line 979
  switch (tmp___0) {
  case 0: ;
#line 982
  if (ldv_state_variable_55 == 1) {
#line 984
    iwl6000_nic_config(iwl_dvm_6050_cfg_group0);
#line 986
    ldv_state_variable_55 = 1;
  } else {

  }
#line 989
  goto ldv_54477;
  case 1: ;
#line 992
  if (ldv_state_variable_55 == 1) {
#line 994
    iwlagn_temperature(iwl_dvm_6050_cfg_group0);
#line 996
    ldv_state_variable_55 = 1;
  } else {

  }
#line 999
  goto ldv_54477;
  case 2: ;
#line 1002
  if (ldv_state_variable_55 == 1) {
#line 1004
    iwl6000_hw_set_hw_params(iwl_dvm_6050_cfg_group0);
#line 1006
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1009
  goto ldv_54477;
  case 3: ;
#line 1012
  if (ldv_state_variable_55 == 1) {
#line 1014
    iwl6000_hw_channel_switch(iwl_dvm_6050_cfg_group0, ldvarg34);
#line 1016
    ldv_state_variable_55 = 1;
  } else {

  }
#line 1019
  goto ldv_54477;
  default: 
#line 1020
  ldv_stop();
  }
  ldv_54477: ;
#line 1024
  return;
}
}
#line 1049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
bool ldv_queue_work_on_579(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1053
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1053
  ldv_func_res = tmp;
#line 1055
  activate_work_7(ldv_func_arg3, 2);
#line 1057
  return (ldv_func_res);
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
bool ldv_queue_delayed_work_on_580(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1064
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1064
  ldv_func_res = tmp;
#line 1066
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1068
  return (ldv_func_res);
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
bool ldv_queue_work_on_581(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1075
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1075
  ldv_func_res = tmp;
#line 1077
  activate_work_7(ldv_func_arg3, 2);
#line 1079
  return (ldv_func_res);
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_flush_workqueue_582(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1085
  flush_workqueue(ldv_func_arg1);
#line 1087
  call_and_disable_all_7(2);
#line 1088
  return;
}
}
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
bool ldv_queue_delayed_work_on_583(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1094
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1094
  ldv_func_res = tmp;
#line 1096
  activate_work_7(& ldv_func_arg3->work, 2);
#line 1098
  return (ldv_func_res);
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_mutex_lock_584(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1104
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1106
  mutex_lock(ldv_func_arg1);
#line 1107
  return;
}
}
#line 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_mutex_unlock_585(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1112
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1114
  mutex_unlock(ldv_func_arg1);
#line 1115
  return;
}
}
#line 1117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_mutex_lock_586(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1120
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1122
  mutex_lock(ldv_func_arg1);
#line 1123
  return;
}
}
#line 1125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
int ldv_mutex_trylock_587(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1129
  tmp = mutex_trylock(ldv_func_arg1);
#line 1129
  ldv_func_res = tmp;
#line 1131
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1131
  return (tmp___0);
#line 1133
  return (ldv_func_res);
}
}
#line 1136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_mutex_unlock_588(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1139
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1141
  mutex_unlock(ldv_func_arg1);
#line 1142
  return;
}
}
#line 1144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_mutex_unlock_589(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1147
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1149
  mutex_unlock(ldv_func_arg1);
#line 1150
  return;
}
}
#line 1152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/devices.o.c.prepared"
void ldv_mutex_lock_590(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1155
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1157
  mutex_lock(ldv_func_arg1);
#line 1158
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 413 "include/linux/kernel.h"
extern char *kasprintf(gfp_t  , char const   *  , ...) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags___4(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4801: ;
#line 831
    goto ldv_4801;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_615(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_613(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_616(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_617(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
void ldv_mutex_lock_612(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_614(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_618(struct mutex *ldv_func_arg1 ) ;
#line 498 "include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held___4(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 500
  lockdep_opinion = 0;
#line 502
  tmp = debug_lockdep_rcu_enabled();
#line 502
  if (tmp == 0) {
#line 503
    return (1);
  } else {

  }
#line 504
  tmp___0 = rcu_is_watching();
#line 504
  if (tmp___0) {
#line 504
    tmp___1 = 0;
  } else {
#line 504
    tmp___1 = 1;
  }
#line 504
  if (tmp___1) {
#line 505
    return (0);
  } else {

  }
#line 506
  tmp___2 = rcu_lockdep_current_cpu_online();
#line 506
  if (tmp___2) {
#line 506
    tmp___3 = 0;
  } else {
#line 506
    tmp___3 = 1;
  }
#line 506
  if (tmp___3) {
#line 507
    return (0);
  } else {

  }
#line 508
  if (debug_locks != 0) {
#line 509
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
#line 510
  if (lockdep_opinion != 0) {
#line 510
    tmp___6 = 1;
  } else {
#line 510
    tmp___4 = preempt_count___2();
#line 510
    if (tmp___4 != 0) {
#line 510
      tmp___6 = 1;
    } else {
#line 510
      _flags = arch_local_save_flags___4();
#line 510
      tmp___5 = arch_irqs_disabled_flags(_flags);
#line 510
      if (tmp___5 != 0) {
#line 510
        tmp___6 = 1;
      } else {
#line 510
        tmp___6 = 0;
      }
    }
  }
#line 510
  return (tmp___6);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_607(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_609(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_608(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_611(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_610(struct workqueue_struct *ldv_func_arg1 ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 3303 "include/net/cfg80211.h"
__inline static char const   *wiphy_name(struct wiphy  const  *wiphy ) 
{ 
  char const   *tmp ;

  {
#line 3305
  tmp = dev_name(& wiphy->dev);
#line 3305
  return (tmp);
}
}
#line 3547 "include/net/mac80211.h"
extern char const   *__ieee80211_get_radio_led_name(struct ieee80211_hw * ) ;
#line 3549
extern char const   *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw * , unsigned int  ,
                                                        struct ieee80211_tpt_blink  const  * ,
                                                        unsigned int  ) ;
#line 3629 "include/net/mac80211.h"
__inline static char const   *ieee80211_get_radio_led_name(struct ieee80211_hw *hw ) 
{ 
  char const   *tmp ;

  {
#line 3632
  tmp = __ieee80211_get_radio_led_name(hw);
#line 3632
  return (tmp);
}
}
#line 3651 "include/net/mac80211.h"
__inline static char const   *ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw ,
                                                               unsigned int flags ,
                                                               struct ieee80211_tpt_blink  const  *blink_table ,
                                                               unsigned int blink_table_len ) 
{ 
  char const   *tmp ;

  {
#line 3656
  tmp = __ieee80211_create_tpt_led_trigger(hw, flags, blink_table, blink_table_len);
#line 3656
  return (tmp);
}
}
#line 50 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32___1(struct device  const  *dev , u32 offs ,
                                                    u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_390___0 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_392___0 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 35
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ioread32.key);
#line 35
  if ((int )tmp___1) {
#line 35
    __rcu_read_lock();
#line 35
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                     (void *)(& __u.__c), 8);
#line 35
    _________p1 = __u.__val;
#line 35
    ________p1 = _________p1;
#line 35
    tmp = debug_lockdep_rcu_enabled();
#line 35
    if (tmp != 0 && ! __warned) {
#line 35
      tmp___0 = rcu_read_lock_sched_held___4();
#line 35
      if (tmp___0 == 0) {
#line 35
        __warned = 1;
#line 35
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               50, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 35
    it_func_ptr = ________p1;
#line 35
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51364: 
#line 35
      it_func = it_func_ptr->func;
#line 35
      __data = it_func_ptr->data;
#line 35
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 35
      it_func_ptr = it_func_ptr + 1;
#line 35
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 37
        goto ldv_51364;
      } else {

      }

    } else {

    }
#line 35
    __rcu_read_unlock();
  } else {

  }
#line 35
  __rcu_read_lock();
#line 35
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 35
  _________p1___0 = __u___0.__val;
#line 35
  ________p1___0 = _________p1___0;
#line 35
  tmp___2 = debug_lockdep_rcu_enabled();
#line 35
  if (tmp___2 != 0 && ! __warned___0) {
#line 35
    tmp___3 = rcu_read_lock_sched_held___4();
#line 35
    if (tmp___3 == 0) {
#line 35
      __warned___0 = 1;
#line 35
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             50, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 35
  __rcu_read_unlock();
#line 37
  return;
}
}
#line 84 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_iowrite32___4(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_398___1 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_400___1 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 69
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite32.key);
#line 69
  if ((int )tmp___1) {
#line 69
    __rcu_read_lock();
#line 69
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
#line 69
    _________p1 = __u.__val;
#line 69
    ________p1 = _________p1;
#line 69
    tmp = debug_lockdep_rcu_enabled();
#line 69
    if (tmp != 0 && ! __warned) {
#line 69
      tmp___0 = rcu_read_lock_sched_held___4();
#line 69
      if (tmp___0 == 0) {
#line 69
        __warned = 1;
#line 69
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 69
    it_func_ptr = ________p1;
#line 69
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51486: 
#line 69
      it_func = it_func_ptr->func;
#line 69
      __data = it_func_ptr->data;
#line 69
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 69
      it_func_ptr = it_func_ptr + 1;
#line 69
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 71
        goto ldv_51486;
      } else {

      }

    } else {

    }
#line 69
    __rcu_read_unlock();
  } else {

  }
#line 69
  __rcu_read_lock();
#line 69
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 69
  _________p1___0 = __u___0.__val;
#line 69
  ________p1___0 = _________p1___0;
#line 69
  tmp___2 = debug_lockdep_rcu_enabled();
#line 69
  if (tmp___2 != 0 && ! __warned___0) {
#line 69
    tmp___3 = rcu_read_lock_sched_held___4();
#line 69
    if (tmp___3 == 0) {
#line 69
      __warned___0 = 1;
#line 69
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 69
  __rcu_read_unlock();
#line 71
  return;
}
}
#line 41 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static void iwl_write32___4(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
#line 43
  trace_iwlwifi_dev_iowrite32___4((struct device  const  *)trans->dev, ofs, val);
#line 44
  iwl_trans_write32(trans, ofs, val);
#line 45
  return;
}
}
#line 47 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static u32 iwl_read32___1(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 val ;
  u32 tmp ;

  {
#line 49
  tmp = iwl_trans_read32(trans, ofs);
#line 49
  val = tmp;
#line 50
  trace_iwlwifi_dev_ioread32___1((struct device  const  *)trans->dev, ofs, val);
#line 51
  return (val);
}
}
#line 106 "include/linux/leds.h"
extern int led_classdev_register(struct device * , struct led_classdev * ) ;
#line 110
extern void led_classdev_unregister(struct led_classdev * ) ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
static struct ieee80211_tpt_blink  const  iwl_blink[10U]  = 
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
  {      {0, 334}, 
        {1023, 260}, 
        {5119, 220}, 
        {10239, 190}, 
        {20479, 170}, 
        {51199, 150}, 
        {71679, 130}, 
        {102399, 110}, 
        {204799, 80}, 
        {307199, 50}};
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
void iwlagn_led_enable(struct iwl_priv *priv ) 
{ 


  {
#line 71
  iwl_write32___4(priv->trans, 148U, 96U);
#line 72
  return;
}
}
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
__inline static u8 iwl_blink_compensation(struct iwl_priv *priv , u8 time , u16 compensation ) 
{ 


  {
#line 88
  if ((unsigned int )compensation == 0U) {
#line 89
    __iwl_err(priv->dev, 0, 0, "undefined blink compensation: use pre-defined blinking time\n");
#line 91
    return (time);
  } else {

  }
#line 94
  return ((u8 )((int )time * (int )compensation >> 6));
}
}
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
static int iwl_send_led_cmd(struct iwl_priv *priv , struct iwl_led_cmd *led_cmd ) 
{ 
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  u32 reg ;
  int tmp___1 ;

  {
#line 99
  cmd.data[0] = (void const   *)led_cmd;
#line 99
  tmp = 1U;
#line 99
  while (1) {
#line 99
    if (tmp >= 2U) {
#line 99
      break;
    } else {

    }
#line 99
    cmd.data[tmp] = 0;
#line 99
    tmp = tmp + 1U;
  }
#line 99
  cmd.resp_pkt = 0;
#line 99
  cmd._rx_page_addr = 0UL;
#line 99
  cmd._rx_page_order = 0U;
#line 99
  cmd.handler_status = 0;
#line 99
  cmd.flags = 1U;
#line 99
  cmd.len[0] = 8U;
#line 99
  tmp___0 = 1U;
#line 99
  while (1) {
#line 99
    if (tmp___0 >= 2U) {
#line 99
      break;
    } else {

    }
#line 99
    cmd.len[tmp___0] = (unsigned short)0;
#line 99
    tmp___0 = tmp___0 + 1U;
  }
#line 99
  cmd.dataflags[0] = (unsigned char)0;
#line 99
  cmd.dataflags[1] = (unsigned char)0;
#line 99
  cmd.id = 72U;
#line 107
  reg = iwl_read32___1(priv->trans, 148U);
#line 108
  if ((reg & 4294967263U) != reg) {
#line 109
    iwl_write32___4(priv->trans, 148U, reg & 4294967263U);
  } else {

  }
#line 112
  tmp___1 = iwl_dvm_send_cmd(priv, & cmd);
#line 112
  return (tmp___1);
}
}
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
static int iwl_led_cmd(struct iwl_priv *priv , unsigned long on , unsigned long off ) 
{ 
  struct iwl_led_cmd led_cmd ;
  int ret ;
  int tmp ;

  {
#line 120
  led_cmd.interval = 1000U;
#line 120
  led_cmd.id = 2U;
#line 120
  led_cmd.off = (unsigned char)0;
#line 120
  led_cmd.on = (unsigned char)0;
#line 120
  led_cmd.reserved = (unsigned char)0;
#line 126
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
#line 126
  if (tmp == 0) {
#line 127
    return (-16);
  } else {

  }
#line 129
  if (priv->blink_on == on && priv->blink_off == off) {
#line 130
    return (0);
  } else {

  }
#line 132
  if (off == 0UL) {
#line 134
    on = 11UL;
  } else {

  }
#line 137
  __iwl_dbg(priv->dev, 524288U, 0, "iwl_led_cmd", "Led blink time compensation=%u\n",
            (int )((priv->cfg)->base_params)->led_compensation);
#line 139
  led_cmd.on = iwl_blink_compensation(priv, (int )((u8 )on), (int )((priv->cfg)->base_params)->led_compensation);
#line 141
  led_cmd.off = iwl_blink_compensation(priv, (int )((u8 )off), (int )((priv->cfg)->base_params)->led_compensation);
#line 144
  ret = iwl_send_led_cmd(priv, & led_cmd);
#line 145
  if (ret == 0) {
#line 146
    priv->blink_on = on;
#line 147
    priv->blink_off = off;
  } else {

  }
#line 149
  return (ret);
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
static void iwl_led_brightness_set(struct led_classdev *led_cdev , enum led_brightness brightness ) 
{ 
  struct iwl_priv *priv ;
  struct led_classdev  const  *__mptr ;
  unsigned long on ;

  {
#line 155
  __mptr = (struct led_classdev  const  *)led_cdev;
#line 155
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcac8UL;
#line 156
  on = 0UL;
#line 158
  if ((unsigned int )brightness != 0U) {
#line 159
    on = 11UL;
  } else {

  }
#line 161
  iwl_led_cmd(priv, on, 0UL);
#line 162
  return;
}
}
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
static int iwl_led_blink_set(struct led_classdev *led_cdev , unsigned long *delay_on ,
                             unsigned long *delay_off ) 
{ 
  struct iwl_priv *priv ;
  struct led_classdev  const  *__mptr ;
  int tmp ;

  {
#line 168
  __mptr = (struct led_classdev  const  *)led_cdev;
#line 168
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcac8UL;
#line 170
  tmp = iwl_led_cmd(priv, *delay_on, *delay_off);
#line 170
  return (tmp);
}
}
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
void iwl_leds_init(struct iwl_priv *priv ) 
{ 
  int mode ;
  int ret ;
  char const   *tmp ;
  char *tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
#line 175
  mode = iwlwifi_mod_params.led_mode;
#line 178
  if (mode == 3) {
#line 179
    __iwl_info(priv->dev, "Led disabled\n");
#line 180
    return;
  } else {

  }
#line 182
  if (mode == 0) {
#line 183
    mode = (int )(priv->cfg)->led_mode;
  } else {

  }
#line 185
  tmp = wiphy_name((struct wiphy  const  *)(priv->hw)->wiphy);
#line 185
  tmp___0 = kasprintf(208U, "%s-led", tmp);
#line 185
  priv->led.name = (char const   *)tmp___0;
#line 187
  priv->led.brightness_set = & iwl_led_brightness_set;
#line 188
  priv->led.blink_set = & iwl_led_blink_set;
#line 189
  priv->led.max_brightness = 1;
#line 191
  switch (mode) {
  case 0: 
#line 193
  __ret_warn_on = 1;
#line 193
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 193
  if (tmp___1 != 0L) {
#line 193
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c",
                       193);
  } else {

  }
#line 193
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 194
  goto ldv_55312;
  case 2: 
#line 196
  priv->led.default_trigger = ieee80211_create_tpt_led_trigger(priv->hw, 4U, (struct ieee80211_tpt_blink  const  *)(& iwl_blink),
                                                               10U);
#line 200
  goto ldv_55312;
  case 1: 
#line 202
  priv->led.default_trigger = ieee80211_get_radio_led_name(priv->hw);
#line 204
  goto ldv_55312;
  }
  ldv_55312: 
#line 207
  ret = led_classdev_register((priv->trans)->dev, & priv->led);
#line 208
  if (ret != 0) {
#line 209
    kfree((void const   *)priv->led.name);
#line 210
    return;
  } else {

  }
#line 213
  priv->led_registered = 1;
#line 214
  return;
}
}
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.c"
void iwl_leds_exit(struct iwl_priv *priv ) 
{ 


  {
#line 218
  if (! priv->led_registered) {
#line 219
    return;
  } else {

  }
#line 221
  led_classdev_unregister(& priv->led);
#line 222
  kfree((void const   *)priv->led.name);
#line 223
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
bool ldv_queue_work_on_607(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 577
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 577
  ldv_func_res = tmp;
#line 579
  activate_work_7(ldv_func_arg3, 2);
#line 581
  return (ldv_func_res);
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
bool ldv_queue_delayed_work_on_608(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 588
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 588
  ldv_func_res = tmp;
#line 590
  activate_work_7(& ldv_func_arg3->work, 2);
#line 592
  return (ldv_func_res);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
bool ldv_queue_work_on_609(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 599
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 599
  ldv_func_res = tmp;
#line 601
  activate_work_7(ldv_func_arg3, 2);
#line 603
  return (ldv_func_res);
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
void ldv_flush_workqueue_610(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 609
  flush_workqueue(ldv_func_arg1);
#line 611
  call_and_disable_all_7(2);
#line 612
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
bool ldv_queue_delayed_work_on_611(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 618
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 618
  ldv_func_res = tmp;
#line 620
  activate_work_7(& ldv_func_arg3->work, 2);
#line 622
  return (ldv_func_res);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
void ldv_mutex_lock_612(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 628
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 630
  mutex_lock(ldv_func_arg1);
#line 631
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
void ldv_mutex_unlock_613(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 636
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 638
  mutex_unlock(ldv_func_arg1);
#line 639
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
void ldv_mutex_lock_614(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 644
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 646
  mutex_lock(ldv_func_arg1);
#line 647
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
int ldv_mutex_trylock_615(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  tmp = mutex_trylock(ldv_func_arg1);
#line 653
  ldv_func_res = tmp;
#line 655
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 655
  return (tmp___0);
#line 657
  return (ldv_func_res);
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
void ldv_mutex_unlock_616(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 663
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 665
  mutex_unlock(ldv_func_arg1);
#line 666
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
void ldv_mutex_unlock_617(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 671
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 673
  mutex_unlock(ldv_func_arg1);
#line 674
  return;
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/led.o.c.prepared"
void ldv_mutex_lock_618(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 679
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 681
  mutex_lock(ldv_func_arg1);
#line 682
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 427 "include/linux/printk.h"
extern int hex_dump_to_buffer(void const   * , size_t  , int  , int  , char * , size_t  ,
                              bool  ) ;
#line 64 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags___5(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4801: ;
#line 831
    goto ldv_4801;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_645(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_641(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_642(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_646(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_648(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_650(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_652(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_656(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_lock_640(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_643(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_644(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_647(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_649(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_651(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_655(struct mutex *ldv_func_arg1 ) ;
#line 20 "./arch/x86/include/asm/preempt.h"
__inline static int preempt_count___5(void) 
{ 
  int pfo_ret__ ;

  {
#line 22
  switch (4UL) {
  case 1UL: 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6532;
  case 2UL: 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6532;
  case 4UL: 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6532;
  case 8UL: 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6532;
  default: 
#line 22
  __bad_percpu_size();
  }
  ldv_6532: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add___7(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6589;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6589;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6589;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6589;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6589: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub___7(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6601;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6601;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6601;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6601;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6601: ;
#line 79
  return;
}
}
#line 173 "include/linux/timer.h"
int ldv_mod_timer_653(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 232
int ldv_del_timer_sync_654(struct timer_list *ldv_func_arg1 ) ;
#line 498 "include/linux/rcupdate.h"
__inline static int rcu_read_lock_sched_held___5(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 500
  lockdep_opinion = 0;
#line 502
  tmp = debug_lockdep_rcu_enabled();
#line 502
  if (tmp == 0) {
#line 503
    return (1);
  } else {

  }
#line 504
  tmp___0 = rcu_is_watching();
#line 504
  if (tmp___0) {
#line 504
    tmp___1 = 0;
  } else {
#line 504
    tmp___1 = 1;
  }
#line 504
  if (tmp___1) {
#line 505
    return (0);
  } else {

  }
#line 506
  tmp___2 = rcu_lockdep_current_cpu_online();
#line 506
  if (tmp___2) {
#line 506
    tmp___3 = 0;
  } else {
#line 506
    tmp___3 = 1;
  }
#line 506
  if (tmp___3) {
#line 507
    return (0);
  } else {

  }
#line 508
  if (debug_locks != 0) {
#line 509
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
#line 510
  if (lockdep_opinion != 0) {
#line 510
    tmp___6 = 1;
  } else {
#line 510
    tmp___4 = preempt_count___5();
#line 510
    if (tmp___4 != 0) {
#line 510
      tmp___6 = 1;
    } else {
#line 510
      _flags = arch_local_save_flags___5();
#line 510
      tmp___5 = arch_irqs_disabled_flags(_flags);
#line 510
      if (tmp___5 != 0) {
#line 510
        tmp___6 = 1;
      } else {
#line 510
        tmp___6 = 0;
      }
    }
  }
#line 510
  return (tmp___6);
}
}
#line 969 "include/linux/rcupdate.h"
__inline static void rcu_read_lock_sched_notrace___5(void) 
{ 


  {
#line 971
  __preempt_count_add___7(1);
#line 971
  __asm__  volatile   ("": : : "memory");
#line 973
  return;
}
}
#line 990 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock_sched_notrace___5(void) 
{ 


  {
#line 993
  __asm__  volatile   ("": : : "memory");
#line 993
  __preempt_count_sub___7(1);
#line 994
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_635(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_637(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_636(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_639(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_638(struct workqueue_struct *ldv_func_arg1 ) ;
#line 2651 "include/linux/fs.h"
extern loff_t generic_file_llseek(struct file * , loff_t  , int  ) ;
#line 58 "include/linux/debugfs.h"
extern struct dentry *debugfs_create_dir(char const   * , struct dentry * ) ;
#line 60
extern struct dentry *debugfs_create_symlink(char const   * , struct dentry * , char const   * ) ;
#line 50 "drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h"
__inline static void trace_iwlwifi_dev_ioread32___2(struct device  const  *dev , u32 offs ,
                                                    u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_386___0 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_388___0 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 35
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ioread32.key);
#line 35
  if ((int )tmp___1) {
#line 35
    rcu_read_lock_sched_notrace___5();
#line 35
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                     (void *)(& __u.__c), 8);
#line 35
    _________p1 = __u.__val;
#line 35
    ________p1 = _________p1;
#line 35
    tmp = debug_lockdep_rcu_enabled();
#line 35
    if (tmp != 0 && ! __warned) {
#line 35
      tmp___0 = rcu_read_lock_sched_held___5();
#line 35
      if (tmp___0 == 0) {
#line 35
        __warned = 1;
#line 35
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               50, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
#line 35
    it_func_ptr = ________p1;
#line 35
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51246: 
#line 35
      it_func = it_func_ptr->func;
#line 35
      __data = it_func_ptr->data;
#line 35
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
#line 35
      it_func_ptr = it_func_ptr + 1;
#line 35
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
#line 37
        goto ldv_51246;
      } else {

      }

    } else {

    }
#line 35
    rcu_read_unlock_sched_notrace___5();
  } else {

  }
#line 35
  rcu_read_lock_sched_notrace___5();
#line 35
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                   (void *)(& __u___0.__c), 8);
#line 35
  _________p1___0 = __u___0.__val;
#line 35
  ________p1___0 = _________p1___0;
#line 35
  tmp___2 = debug_lockdep_rcu_enabled();
#line 35
  if (tmp___2 != 0 && ! __warned___0) {
#line 35
    tmp___3 = rcu_read_lock_sched_held___5();
#line 35
    if (tmp___3 == 0) {
#line 35
      __warned___0 = 1;
#line 35
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             50, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 35
  rcu_read_unlock_sched_notrace___5();
#line 37
  return;
}
}
#line 47 "drivers/net/wireless/iwlwifi/dvm/../iwl-io.h"
__inline static u32 iwl_read32___2(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 val ;
  u32 tmp ;

  {
#line 49
  tmp = iwl_trans_read32(trans, ofs);
#line 49
  val = tmp;
#line 50
  trace_iwlwifi_dev_ioread32___2((struct device  const  *)trans->dev, ofs, val);
#line 51
  return (val);
}
}
#line 939 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/dev.h"
__inline static int iwl_is_any_associated___3(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
#line 942
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 942
  goto ldv_54744;
  ldv_54743: ;
#line 942
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 943
    tmp = iwl_is_associated_ctx(ctx);
#line 943
    if (tmp != 0) {
#line 944
      return (1);
    } else {

    }
  } else {

  }
#line 942
  ctx = ctx + 1;
  ldv_54744: ;
#line 942
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 944
    goto ldv_54743;
  } else {

  }

#line 945
  return (0);
}
}
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_sram_read(struct file *file , char *user_buf , size_t count ,
                                   loff_t *ppos ) 
{ 
  u32 val ;
  char *buf ;
  ssize_t ret ;
  int i ;
  bool device_format ;
  int offset ;
  int len ;
  int pos ;
  int sram ;
  struct iwl_priv *priv ;
  struct fw_img  const  *img ;
  size_t bufsz ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 99
  val = 0U;
#line 102
  i = 0;
#line 103
  device_format = 0;
#line 104
  offset = 0;
#line 105
  len = 0;
#line 106
  pos = 0;
#line 108
  priv = (struct iwl_priv *)file->private_data;
#line 112
  tmp = iwl_is_ready_rf(priv);
#line 112
  if (tmp == 0) {
#line 113
    return (-11L);
  } else {

  }
#line 116
  if (priv->dbgfs_sram_offset == 0U && priv->dbgfs_sram_len == 0U) {
#line 117
    priv->dbgfs_sram_offset = 8388608U;
#line 118
    if (! priv->ucode_loaded) {
#line 119
      return (-22L);
    } else {

    }
#line 120
    img = (struct fw_img  const  *)(& (priv->fw)->img) + (unsigned long )priv->cur_ucode;
#line 121
    priv->dbgfs_sram_len = img->sec[0].len;
  } else {

  }
#line 123
  len = (int )priv->dbgfs_sram_len;
#line 125
  if (len == -4) {
#line 126
    device_format = 1;
#line 127
    len = 4;
  } else {

  }
#line 130
  bufsz = (size_t )(len * 4 + 50);
#line 131
  tmp___0 = kmalloc(bufsz, 208U);
#line 131
  buf = (char *)tmp___0;
#line 132
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 133
    return (-12L);
  } else {

  }
#line 135
  tmp___1 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "sram_len: 0x%x\n",
                      len);
#line 135
  pos = tmp___1 + pos;
#line 137
  tmp___2 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "sram_offset: 0x%x\n",
                      priv->dbgfs_sram_offset);
#line 137
  pos = tmp___2 + pos;
#line 141
  offset = (int )priv->dbgfs_sram_offset & 3;
#line 142
  sram = (int )priv->dbgfs_sram_offset & -4;
#line 145
  val = iwl_trans_read_mem32(priv->trans, (u32 )sram);
#line 147
  goto ldv_55166;
  ldv_55165: ;
#line 149
  if (i == 0) {
#line 150
    tmp___3 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "%08X: ",
                        sram + offset);
#line 150
    pos = tmp___3 + pos;
  } else {

  }
#line 153
  if ((int )device_format) {
#line 154
    tmp___4 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "%02x", (val >> (3 - offset) * 8) & 255U);
#line 154
    pos = tmp___4 + pos;
  } else {
#line 157
    tmp___5 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "%02x ",
                        (val >> offset * 8) & 255U);
#line 157
    pos = tmp___5 + pos;
  }
#line 161
  offset = offset + 1;
#line 161
  if (offset == 4) {
#line 162
    sram = sram + 4;
#line 163
    offset = 0;
#line 164
    val = iwl_trans_read_mem32(priv->trans, (u32 )sram);
  } else {

  }
#line 168
  i = i + 1;
#line 168
  if (i == 16) {
#line 169
    i = 0;
#line 170
    tmp___6 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "\n");
#line 170
    pos = tmp___6 + pos;
  } else
#line 171
  if ((i & 7) == 0) {
#line 172
    tmp___7 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "   ");
#line 172
    pos = tmp___7 + pos;
  } else
#line 173
  if ((i & 3) == 0) {
#line 174
    tmp___8 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, " ");
#line 174
    pos = tmp___8 + pos;
  } else {

  }
#line 147
  len = len - 1;
  ldv_55166: ;
#line 147
  if (len != 0) {
#line 149
    goto ldv_55165;
  } else {

  }

#line 177
  if (i != 0) {
#line 178
    tmp___9 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "\n");
#line 178
    pos = tmp___9 + pos;
  } else {

  }
#line 180
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 181
  kfree((void const   *)buf);
#line 182
  return (ret);
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_sram_write(struct file *file , char const   *user_buf , size_t count ,
                                    loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[64U] ;
  int buf_size ;
  u32 offset ;
  u32 len ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 189
  priv = (struct iwl_priv *)file->private_data;
#line 194
  memset((void *)(& buf), 0, 64UL);
#line 195
  _min1 = count;
#line 195
  _min2 = 63UL;
#line 195
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 196
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 196
  if (tmp != 0UL) {
#line 197
    return (-14L);
  } else {

  }
#line 199
  tmp___1 = sscanf((char const   *)(& buf), "%x,%x", & offset, & len);
#line 199
  if (tmp___1 == 2) {
#line 200
    priv->dbgfs_sram_offset = offset;
#line 201
    priv->dbgfs_sram_len = len;
  } else {
#line 202
    tmp___0 = sscanf((char const   *)(& buf), "%x", & offset);
#line 202
    if (tmp___0 == 1) {
#line 203
      priv->dbgfs_sram_offset = offset;
#line 204
      priv->dbgfs_sram_len = 4294967292U;
    } else {
#line 206
      priv->dbgfs_sram_offset = 0U;
#line 207
      priv->dbgfs_sram_len = 0U;
    }
  }
#line 210
  return ((ssize_t )count);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_wowlan_sram_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct fw_img  const  *img ;
  ssize_t tmp ;

  {
#line 217
  priv = (struct iwl_priv *)file->private_data;
#line 218
  img = (struct fw_img  const  *)(& (priv->fw)->img) + 2UL;
#line 220
  if ((unsigned long )priv->wowlan_sram == (unsigned long )((void *)0)) {
#line 221
    return (-61L);
  } else {

  }
#line 223
  tmp = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)priv->wowlan_sram,
                                (size_t )img->sec[0].len);
#line 223
  return (tmp);
}
}
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_stations_read(struct file *file , char *user_buf , size_t count ,
                                       loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_station_entry *station ;
  struct iwl_tid_data *tid_data ;
  char *buf ;
  int i ;
  int j ;
  int pos ;
  ssize_t ret ;
  size_t bufsz ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 230
  priv = (struct iwl_priv *)file->private_data;
#line 234
  pos = 0;
#line 237
  bufsz = (unsigned long )priv->num_stations * 500UL + 30UL;
#line 239
  tmp = kmalloc(bufsz, 208U);
#line 239
  buf = (char *)tmp;
#line 240
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 241
    return (-12L);
  } else {

  }
#line 243
  tmp___0 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "num of stations: %d\n\n",
                      priv->num_stations);
#line 243
  pos = tmp___0 + pos;
#line 246
  i = 0;
#line 246
  goto ldv_55210;
  ldv_55209: 
#line 247
  station = (struct iwl_station_entry *)(& priv->stations) + (unsigned long )i;
#line 248
  if ((unsigned int )station->used == 0U) {
#line 249
    goto ldv_55205;
  } else {

  }
#line 250
  tmp___1 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "station %d - addr: %pM, flags: %#x\n",
                      i, (u8 *)(& station->sta.sta.addr), station->sta.station_flags_msk);
#line 250
  pos = tmp___1 + pos;
#line 254
  tmp___2 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "TID seqno  next_rclmd rate_n_flags state txq\n");
#line 254
  pos = tmp___2 + pos;
#line 258
  j = 0;
#line 258
  goto ldv_55207;
  ldv_55206: 
#line 259
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )i + (unsigned long )j);
#line 260
  tmp___3 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "%d:  0x%.4x 0x%.4x     0x%.8x   %d     %.2d",
                      j, (int )tid_data->seq_number, (int )tid_data->next_reclaimed,
                      tid_data->agg.rate_n_flags, (unsigned int )tid_data->agg.state,
                      (int )tid_data->agg.txq_id);
#line 260
  pos = tmp___3 + pos;
#line 269
  if ((int )tid_data->agg.wait_for_ba) {
#line 270
    tmp___4 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, " - waitforba");
#line 270
    pos = tmp___4 + pos;
  } else {

  }
#line 272
  tmp___5 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "\n");
#line 272
  pos = tmp___5 + pos;
#line 258
  j = j + 1;
  ldv_55207: ;
#line 258
  if (j <= 7) {
#line 260
    goto ldv_55206;
  } else {

  }
#line 275
  tmp___6 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "\n");
#line 275
  pos = tmp___6 + pos;
  ldv_55205: 
#line 246
  i = i + 1;
  ldv_55210: ;
#line 246
  if (i <= 15) {
#line 248
    goto ldv_55209;
  } else {

  }
#line 278
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 279
  kfree((void const   *)buf);
#line 280
  return (ret);
}
}
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_nvm_read(struct file *file , char *user_buf , size_t count ,
                                  loff_t *ppos ) 
{ 
  ssize_t ret ;
  struct iwl_priv *priv ;
  int pos ;
  int ofs ;
  int buf_size ;
  u8 const   *ptr ;
  char *buf ;
  u16 nvm_ver ;
  size_t eeprom_len ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 289
  priv = (struct iwl_priv *)file->private_data;
#line 290
  pos = 0;
#line 290
  ofs = 0;
#line 290
  buf_size = 0;
#line 294
  eeprom_len = priv->eeprom_blob_size;
#line 295
  buf_size = (int )((unsigned int )(eeprom_len + 64UL) * 4U);
#line 297
  if ((eeprom_len & 15UL) != 0UL) {
#line 298
    return (-61L);
  } else {

  }
#line 300
  ptr = (u8 const   *)priv->eeprom_blob;
#line 301
  if ((unsigned long )ptr == (unsigned long )((u8 const   *)0U)) {
#line 302
    return (-12L);
  } else {

  }
#line 305
  tmp = kzalloc((size_t )buf_size, 208U);
#line 305
  buf = (char *)tmp;
#line 306
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 307
    return (-12L);
  } else {

  }
#line 309
  nvm_ver = (u16 )(priv->nvm_data)->nvm_version;
#line 310
  tmp___0 = scnprintf(buf + (unsigned long )pos, (size_t )(buf_size - pos), "NVM version: 0x%x\n",
                      (int )nvm_ver);
#line 310
  pos = tmp___0 + pos;
#line 312
  ofs = 0;
#line 312
  goto ldv_55228;
  ldv_55227: 
#line 313
  tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(buf_size - pos), "0x%.4x ",
                      ofs);
#line 313
  pos = tmp___1 + pos;
#line 314
  hex_dump_to_buffer((void const   *)ptr + (unsigned long )ofs, 16UL, 16, 2, buf + (unsigned long )pos,
                     (size_t )(buf_size - pos), 0);
#line 316
  tmp___2 = strlen((char const   *)buf + (unsigned long )pos);
#line 316
  pos = (int )((unsigned int )tmp___2 + (unsigned int )pos);
#line 317
  if (buf_size - pos > 0) {
#line 318
    tmp___3 = pos;
#line 318
    pos = pos + 1;
#line 318
    *(buf + (unsigned long )tmp___3) = 10;
  } else {

  }
#line 312
  ofs = ofs + 16;
  ldv_55228: ;
#line 312
  if ((size_t )ofs < eeprom_len) {
#line 314
    goto ldv_55227;
  } else {

  }
#line 321
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 322
  kfree((void const   *)buf);
#line 323
  return (ret);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_channels_read(struct file *file , char *user_buf , size_t count ,
                                       loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct ieee80211_channel *channels ;
  struct ieee80211_supported_band  const  *supp_band ;
  int pos ;
  int i ;
  int bufsz ;
  char *buf ;
  ssize_t ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 329
  priv = (struct iwl_priv *)file->private_data;
#line 330
  channels = (struct ieee80211_channel *)0;
#line 331
  supp_band = (struct ieee80211_supported_band  const  *)0;
#line 332
  pos = 0;
#line 332
  bufsz = 4096;
#line 336
  tmp = kzalloc((size_t )bufsz, 208U);
#line 336
  buf = (char *)tmp;
#line 337
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 338
    return (-12L);
  } else {

  }
#line 340
  supp_band = iwl_get_hw_mode(priv, 0);
#line 341
  if ((unsigned long )supp_band != (unsigned long )((struct ieee80211_supported_band  const  *)0)) {
#line 342
    channels = supp_band->channels;
#line 344
    tmp___0 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "Displaying %d channels in 2.4GHz band 802.11bg):\n",
                        supp_band->n_channels);
#line 344
    pos = tmp___0 + pos;
#line 348
    i = 0;
#line 348
    goto ldv_55245;
    ldv_55244: 
#line 349
    tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%d: %ddBm: BSS%s%s, %s.\n",
                        (int )(channels + (unsigned long )i)->hw_value, (channels + (unsigned long )i)->max_power,
                        ((channels + (unsigned long )i)->flags & 8U) != 0U ? (char *)" (IEEE 802.11h required)" : (char *)"",
                        ((channels + (unsigned long )i)->flags & 2U) != 0U || ((channels + (unsigned long )i)->flags & 8U) != 0U ? (char *)"" : (char *)", IBSS",
                        ((channels + (unsigned long )i)->flags & 2U) != 0U ? (char *)"passive only" : (char *)"active/passive");
#line 349
    pos = tmp___1 + pos;
#line 348
    i = i + 1;
    ldv_55245: ;
#line 348
    if ((int )supp_band->n_channels > i) {
#line 350
      goto ldv_55244;
    } else {

    }

  } else {

  }
#line 363
  supp_band = iwl_get_hw_mode(priv, 1);
#line 364
  if ((unsigned long )supp_band != (unsigned long )((struct ieee80211_supported_band  const  *)0)) {
#line 365
    channels = supp_band->channels;
#line 367
    tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "Displaying %d channels in 5.2GHz band (802.11a)\n",
                        supp_band->n_channels);
#line 367
    pos = tmp___2 + pos;
#line 371
    i = 0;
#line 371
    goto ldv_55248;
    ldv_55247: 
#line 372
    tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%d: %ddBm: BSS%s%s, %s.\n",
                        (int )(channels + (unsigned long )i)->hw_value, (channels + (unsigned long )i)->max_power,
                        ((channels + (unsigned long )i)->flags & 8U) != 0U ? (char *)" (IEEE 802.11h required)" : (char *)"",
                        ((channels + (unsigned long )i)->flags & 2U) != 0U || ((channels + (unsigned long )i)->flags & 8U) != 0U ? (char *)"" : (char *)", IBSS",
                        ((channels + (unsigned long )i)->flags & 2U) != 0U ? (char *)"passive only" : (char *)"active/passive");
#line 372
    pos = tmp___3 + pos;
#line 371
    i = i + 1;
    ldv_55248: ;
#line 371
    if ((int )supp_band->n_channels > i) {
#line 373
      goto ldv_55247;
    } else {

    }

  } else {

  }
#line 386
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 387
  kfree((void const   *)buf);
#line 388
  return (ret);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_status_read(struct file *file , char *user_buf , size_t count ,
                                     loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[512U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  ssize_t tmp___21 ;

  {
#line 395
  priv = (struct iwl_priv *)file->private_data;
#line 397
  pos = 0;
#line 398
  bufsz = 512UL;
#line 400
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
#line 400
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_RF_KILL_HW:\t %d\n", tmp);
#line 400
  pos = tmp___0 + pos;
#line 402
  tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& priv->status));
#line 402
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_CT_KILL:\t\t %d\n", tmp___1);
#line 402
  pos = tmp___2 + pos;
#line 404
  tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->status));
#line 404
  tmp___4 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_ALIVE:\t\t %d\n", tmp___3);
#line 404
  pos = tmp___4 + pos;
#line 406
  tmp___5 = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
#line 406
  tmp___6 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_READY:\t\t %d\n", tmp___5);
#line 406
  pos = tmp___6 + pos;
#line 408
  tmp___7 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
#line 408
  tmp___8 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_EXIT_PENDING:\t %d\n", tmp___7);
#line 408
  pos = tmp___8 + pos;
#line 410
  tmp___9 = constant_test_bit(6L, (unsigned long const volatile   *)(& priv->status));
#line 410
  tmp___10 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_STATISTICS:\t %d\n", tmp___9);
#line 410
  pos = tmp___10 + pos;
#line 412
  tmp___11 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
#line 412
  tmp___12 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_SCANNING:\t %d\n", tmp___11);
#line 412
  pos = tmp___12 + pos;
#line 414
  tmp___13 = constant_test_bit(8L, (unsigned long const volatile   *)(& priv->status));
#line 414
  tmp___14 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_SCAN_ABORTING:\t %d\n", tmp___13);
#line 414
  pos = tmp___14 + pos;
#line 416
  tmp___15 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
#line 416
  tmp___16 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_SCAN_HW:\t\t %d\n", tmp___15);
#line 416
  pos = tmp___16 + pos;
#line 418
  tmp___17 = constant_test_bit(13L, (unsigned long const volatile   *)(& priv->status));
#line 418
  tmp___18 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_POWER_PMI:\t %d\n", tmp___17);
#line 418
  pos = tmp___18 + pos;
#line 420
  tmp___19 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->status));
#line 420
  tmp___20 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_FW_ERROR:\t %d\n", tmp___19);
#line 420
  pos = tmp___20 + pos;
#line 422
  tmp___21 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                     (size_t )pos);
#line 422
  return (tmp___21);
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_rx_handlers_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  int cnt ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 429
  priv = (struct iwl_priv *)file->private_data;
#line 431
  pos = 0;
#line 432
  cnt = 0;
#line 434
  bufsz = 1536;
#line 437
  tmp = kzalloc((size_t )bufsz, 208U);
#line 437
  buf = (char *)tmp;
#line 438
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 439
    return (-12L);
  } else {

  }
#line 441
  cnt = 0;
#line 441
  goto ldv_55273;
  ldv_55272: ;
#line 442
  if (priv->rx_handlers_stats[cnt] != 0U) {
#line 443
    tmp___0 = iwl_dvm_get_cmd_string((int )((u8 )cnt));
#line 443
    tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\tRx handler[%36s]:\t\t %u\n",
                        tmp___0, priv->rx_handlers_stats[cnt]);
#line 443
    pos = tmp___1 + pos;
  } else {

  }
#line 441
  cnt = cnt + 1;
  ldv_55273: ;
#line 441
  if (cnt <= 254) {
#line 443
    goto ldv_55272;
  } else {

  }
#line 449
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 450
  kfree((void const   *)buf);
#line 451
  return (ret);
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_rx_handlers_write(struct file *file , char const   *user_buf ,
                                           size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  u32 reset_flag ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 458
  priv = (struct iwl_priv *)file->private_data;
#line 464
  memset((void *)(& buf), 0, 8UL);
#line 465
  _min1 = count;
#line 465
  _min2 = 7UL;
#line 465
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 466
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 466
  if (tmp != 0UL) {
#line 467
    return (-14L);
  } else {

  }
#line 468
  tmp___0 = sscanf((char const   *)(& buf), "%x", & reset_flag);
#line 468
  if (tmp___0 != 1) {
#line 469
    return (-14L);
  } else {

  }
#line 470
  if (reset_flag == 0U) {
#line 471
    memset((void *)(& priv->rx_handlers_stats), 0, 1020UL);
  } else {

  }
#line 474
  return ((ssize_t )count);
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_qos_read(struct file *file , char *user_buf , size_t count ,
                                  loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  int pos ;
  int i ;
  char buf[512U] ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 480
  priv = (struct iwl_priv *)file->private_data;
#line 482
  pos = 0;
#line 484
  bufsz = 512UL;
#line 486
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
#line 486
  goto ldv_55304;
  ldv_55303: ;
#line 486
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
#line 487
    tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                    "context %d:\n", (unsigned int )ctx->ctxid);
#line 487
    pos = tmp + pos;
#line 489
    i = 0;
#line 489
    goto ldv_55301;
    ldv_55300: 
#line 490
    tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "\tcw_min\tcw_max\taifsn\ttxop\n");
#line 490
    pos = tmp___0 + pos;
#line 492
    tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "AC[%d]\t%u\t%u\t%u\t%u\n", i, (int )ctx->qos_data.def_qos_parm.ac[i].cw_min,
                        (int )ctx->qos_data.def_qos_parm.ac[i].cw_max, (int )ctx->qos_data.def_qos_parm.ac[i].aifsn,
                        (int )ctx->qos_data.def_qos_parm.ac[i].edca_txop);
#line 492
    pos = tmp___1 + pos;
#line 489
    i = i + 1;
    ldv_55301: ;
#line 489
    if (i <= 3) {
#line 491
      goto ldv_55300;
    } else {

    }
#line 499
    tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "\n");
#line 499
    pos = tmp___2 + pos;
  } else {

  }
#line 486
  ctx = ctx + 1;
  ldv_55304: ;
#line 486
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
#line 488
    goto ldv_55303;
  } else {

  }
#line 501
  tmp___3 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 501
  return (tmp___3);
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_thermal_throttling_read(struct file *file , char *user_buf ,
                                                 size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_tt_mgmt *tt ;
  struct iwl_tt_restriction *restriction ;
  char buf[100U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 508
  priv = (struct iwl_priv *)file->private_data;
#line 509
  tt = & priv->thermal_throttle;
#line 512
  pos = 0;
#line 513
  bufsz = 100UL;
#line 515
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "Thermal Throttling Mode: %s\n", (int )tt->advanced_tt ? (char *)"Advance" : (char *)"Legacy");
#line 515
  pos = tmp + pos;
#line 518
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Thermal Throttling State: %d\n", (unsigned int )tt->state);
#line 518
  pos = tmp___0 + pos;
#line 521
  if ((int )tt->advanced_tt) {
#line 522
    restriction = tt->restriction + (unsigned long )tt->state;
#line 523
    tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "Tx mode: %d\n", (unsigned int )restriction->tx_stream);
#line 523
    pos = tmp___1 + pos;
#line 526
    tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "Rx mode: %d\n", (unsigned int )restriction->rx_stream);
#line 526
    pos = tmp___2 + pos;
#line 529
    tmp___3 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "HT mode: %d\n", (int )restriction->is_ht);
#line 529
    pos = tmp___3 + pos;
  } else {

  }
#line 533
  tmp___4 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 533
  return (tmp___4);
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_disable_ht40_write(struct file *file , char const   *user_buf ,
                                            size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int ht40 ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 540
  priv = (struct iwl_priv *)file->private_data;
#line 545
  memset((void *)(& buf), 0, 8UL);
#line 546
  _min1 = count;
#line 546
  _min2 = 7UL;
#line 546
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 547
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 547
  if (tmp != 0UL) {
#line 548
    return (-14L);
  } else {

  }
#line 549
  tmp___0 = sscanf((char const   *)(& buf), "%d", & ht40);
#line 549
  if (tmp___0 != 1) {
#line 550
    return (-14L);
  } else {

  }
#line 551
  tmp___1 = iwl_is_any_associated___3(priv);
#line 551
  if (tmp___1 == 0) {
#line 552
    priv->disable_ht40 = ht40 != 0;
  } else {
#line 554
    return (-22L);
  }
#line 556
  return ((ssize_t )count);
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_disable_ht40_read(struct file *file , char *user_buf , size_t count ,
                                           loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[100U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 563
  priv = (struct iwl_priv *)file->private_data;
#line 565
  pos = 0;
#line 566
  bufsz = 100UL;
#line 568
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "11n 40MHz Mode: %s\n", (int )priv->disable_ht40 ? (char *)"Disabled" : (char *)"Enabled");
#line 568
  pos = tmp + pos;
#line 571
  tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 571
  return (tmp___0);
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_temperature_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 578
  priv = (struct iwl_priv *)file->private_data;
#line 580
  pos = 0;
#line 581
  bufsz = 8UL;
#line 583
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "%d\n", priv->temperature);
#line 583
  pos = tmp + pos;
#line 584
  tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 584
  return (tmp___0);
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_sleep_level_override_write(struct file *file , char const   *user_buf ,
                                                    size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int value ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 592
  priv = (struct iwl_priv *)file->private_data;
#line 597
  memset((void *)(& buf), 0, 8UL);
#line 598
  _min1 = count;
#line 598
  _min2 = 7UL;
#line 598
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 599
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 599
  if (tmp != 0UL) {
#line 600
    return (-14L);
  } else {

  }
#line 602
  tmp___0 = sscanf((char const   *)(& buf), "%d", & value);
#line 602
  if (tmp___0 != 1) {
#line 603
    return (-22L);
  } else {

  }
#line 610
  if (value == 0) {
#line 611
    return (-22L);
  } else
#line 612
  if (value > 0) {
#line 613
    value = value + -1;
  } else {

  }
#line 615
  if (value != -1 && (value < 0 || value > 4)) {
#line 616
    return (-22L);
  } else {

  }
#line 618
  tmp___1 = iwl_is_ready_rf(priv);
#line 618
  if (tmp___1 == 0) {
#line 619
    return (-11L);
  } else {

  }
#line 621
  priv->power_data.debug_sleep_level_override = value;
#line 623
  ldv_mutex_lock_647(& priv->mutex);
#line 624
  iwl_power_update_mode(priv, 1);
#line 625
  ldv_mutex_unlock_648(& priv->mutex);
#line 627
  return ((ssize_t )count);
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_sleep_level_override_read(struct file *file , char *user_buf ,
                                                   size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[10U] ;
  int pos ;
  int value ;
  size_t bufsz ;
  ssize_t tmp ;

  {
#line 634
  priv = (struct iwl_priv *)file->private_data;
#line 637
  bufsz = 10UL;
#line 640
  value = priv->power_data.debug_sleep_level_override;
#line 641
  if (value >= 0) {
#line 642
    value = value + 1;
  } else {

  }
#line 644
  pos = scnprintf((char *)(& buf), bufsz, "%d\n", value);
#line 645
  tmp = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                (size_t )pos);
#line 645
  return (tmp);
}
}
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_current_sleep_command_read(struct file *file , char *user_buf ,
                                                    size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[200U] ;
  int pos ;
  int i ;
  size_t bufsz ;
  struct iwl_powertable_cmd *cmd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 652
  priv = (struct iwl_priv *)file->private_data;
#line 654
  pos = 0;
#line 655
  bufsz = 200UL;
#line 656
  cmd = & priv->power_data.sleep_cmd;
#line 658
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "flags: %#.2x\n", (int )cmd->flags);
#line 658
  pos = tmp + pos;
#line 660
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "RX/TX timeout: %d/%d usec\n", cmd->rx_data_timeout, cmd->tx_data_timeout);
#line 660
  pos = tmp___0 + pos;
#line 664
  i = 0;
#line 664
  goto ldv_55388;
  ldv_55387: 
#line 665
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "sleep_interval[%d]: %d\n", i, cmd->sleep_interval[i]);
#line 665
  pos = tmp___1 + pos;
#line 664
  i = i + 1;
  ldv_55388: ;
#line 664
  if (i <= 4) {
#line 666
    goto ldv_55387;
  } else {

  }
#line 669
  tmp___2 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 669
  return (tmp___2);
}
}
#line 672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_sram_ops  = 
#line 672
     {0, & generic_file_llseek, & iwl_dbgfs_sram_read, & iwl_dbgfs_sram_write, 0, 0,
    0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_wowlan_sram_ops  = 
#line 673
     {0, & generic_file_llseek, & iwl_dbgfs_wowlan_sram_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_nvm_ops  = 
#line 674
     {0, & generic_file_llseek, & iwl_dbgfs_nvm_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & simple_open,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_stations_ops  = 
#line 675
     {0, & generic_file_llseek, & iwl_dbgfs_stations_read, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_channels_ops  = 
#line 676
     {0, & generic_file_llseek, & iwl_dbgfs_channels_read, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_status_ops  = 
#line 677
     {0, & generic_file_llseek, & iwl_dbgfs_status_read, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_rx_handlers_ops  = 
#line 678
     {0, & generic_file_llseek, & iwl_dbgfs_rx_handlers_read, & iwl_dbgfs_rx_handlers_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_qos_ops  = 
#line 679
     {0, & generic_file_llseek, & iwl_dbgfs_qos_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & simple_open,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_thermal_throttling_ops  = 
#line 680
     {0, & generic_file_llseek, & iwl_dbgfs_thermal_throttling_read, 0, 0, 0, 0, 0,
    0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_disable_ht40_ops  = 
#line 681
     {0, & generic_file_llseek, & iwl_dbgfs_disable_ht40_read, & iwl_dbgfs_disable_ht40_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_temperature_ops  = 
#line 682
     {0, & generic_file_llseek, & iwl_dbgfs_temperature_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_sleep_level_override_ops  = 
#line 683
     {0, & generic_file_llseek, & iwl_dbgfs_sleep_level_override_read, & iwl_dbgfs_sleep_level_override_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_current_sleep_command_ops  = 
#line 684
     {0, & generic_file_llseek, & iwl_dbgfs_current_sleep_command_read, 0, 0, 0, 0,
    0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static char const   *fmt_value  =    "  %-30s %10u\n";
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static char const   *fmt_hex  =    "  %-30s       0x%02X\n";
#line 688 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static char const   *fmt_table  =    "  %-30s %10u  %10u  %10u  %10u\n";
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static char const   *fmt_header  =    "%-32s    current  cumulative       delta         max\n";
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static int iwl_statistics_flag(struct iwl_priv *priv , char *buf , int bufsz ) 
{ 
  int p ;
  u32 flag ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 694
  p = 0;
#line 697
  if (debug_locks != 0) {
#line 697
    tmp = lock_is_held(& priv->statistics.lock.__annonCompField17.__annonCompField16.dep_map);
#line 697
    if (tmp == 0) {
#line 697
      tmp___0 = 1;
    } else {
#line 697
      tmp___0 = 0;
    }
  } else {
#line 697
    tmp___0 = 0;
  }
#line 697
  __ret_warn_on = tmp___0;
#line 697
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 697
  if (tmp___1 != 0L) {
#line 697
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c",
                       697);
  } else {

  }
#line 697
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 699
  flag = priv->statistics.flag;
#line 701
  tmp___2 = scnprintf(buf + (unsigned long )p, (size_t )(bufsz - p), "Statistics Flag(0x%X):\n",
                      flag);
#line 701
  p = tmp___2 + p;
#line 702
  if ((int )flag & 1) {
#line 703
    tmp___3 = scnprintf(buf + (unsigned long )p, (size_t )(bufsz - p), "\tStatistics have been cleared\n");
#line 703
    p = tmp___3 + p;
  } else {

  }
#line 705
  tmp___4 = scnprintf(buf + (unsigned long )p, (size_t )(bufsz - p), "\tOperational Frequency: %s\n",
                      (flag & 2U) != 0U ? (char *)"2.4 GHz" : (char *)"5.2 GHz");
#line 705
  p = tmp___4 + p;
#line 708
  tmp___5 = scnprintf(buf + (unsigned long )p, (size_t )(bufsz - p), "\tTGj Narrow Band: %s\n",
                      (flag & 4U) != 0U ? (char *)"enabled" : (char *)"disabled");
#line 708
  p = tmp___5 + p;
#line 712
  return (p);
}
}
#line 715 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_ucode_rx_stats_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct statistics_rx_phy *ofdm ;
  struct statistics_rx_phy *accum_ofdm ;
  struct statistics_rx_phy *delta_ofdm ;
  struct statistics_rx_phy *max_ofdm ;
  struct statistics_rx_phy *cck ;
  struct statistics_rx_phy *accum_cck ;
  struct statistics_rx_phy *delta_cck ;
  struct statistics_rx_phy *max_cck ;
  struct statistics_rx_non_phy *general ;
  struct statistics_rx_non_phy *accum_general ;
  struct statistics_rx_non_phy *delta_general ;
  struct statistics_rx_non_phy *max_general ;
  struct statistics_rx_ht_phy *ht ;
  struct statistics_rx_ht_phy *accum_ht ;
  struct statistics_rx_ht_phy *delta_ht ;
  struct statistics_rx_ht_phy *max_ht ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;

  {
#line 719
  priv = (struct iwl_priv *)file->private_data;
#line 720
  pos = 0;
#line 722
  bufsz = 8560;
#line 732
  tmp = iwl_is_alive(priv);
#line 732
  if (tmp == 0) {
#line 733
    return (-11L);
  } else {

  }
#line 735
  tmp___0 = kzalloc((size_t )bufsz, 208U);
#line 735
  buf = (char *)tmp___0;
#line 736
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 737
    return (-12L);
  } else {

  }
#line 744
  spin_lock_bh(& priv->statistics.lock);
#line 745
  ofdm = & priv->statistics.rx_ofdm;
#line 746
  cck = & priv->statistics.rx_cck;
#line 747
  general = & priv->statistics.rx_non_phy;
#line 748
  ht = & priv->statistics.rx_ofdm_ht;
#line 749
  accum_ofdm = & priv->accum_stats.rx_ofdm;
#line 750
  accum_cck = & priv->accum_stats.rx_cck;
#line 751
  accum_general = & priv->accum_stats.rx_non_phy;
#line 752
  accum_ht = & priv->accum_stats.rx_ofdm_ht;
#line 753
  delta_ofdm = & priv->delta_stats.rx_ofdm;
#line 754
  delta_cck = & priv->delta_stats.rx_cck;
#line 755
  delta_general = & priv->delta_stats.rx_non_phy;
#line 756
  delta_ht = & priv->delta_stats.rx_ofdm_ht;
#line 757
  max_ofdm = & priv->max_delta_stats.rx_ofdm;
#line 758
  max_cck = & priv->max_delta_stats.rx_cck;
#line 759
  max_general = & priv->max_delta_stats.rx_non_phy;
#line 760
  max_ht = & priv->max_delta_stats.rx_ofdm_ht;
#line 762
  tmp___1 = iwl_statistics_flag(priv, buf, bufsz);
#line 762
  pos = tmp___1 + pos;
#line 763
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                      (char *)"Statistics_Rx - OFDM:");
#line 763
  pos = tmp___2 + pos;
#line 765
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"ina_cnt:", ofdm->ina_cnt, accum_ofdm->ina_cnt, delta_ofdm->ina_cnt,
                      max_ofdm->ina_cnt);
#line 765
  pos = tmp___3 + pos;
#line 770
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"fina_cnt:", ofdm->fina_cnt, accum_ofdm->fina_cnt, delta_ofdm->fina_cnt,
                      max_ofdm->fina_cnt);
#line 770
  pos = tmp___4 + pos;
#line 774
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"plcp_err:", ofdm->plcp_err, accum_ofdm->plcp_err, delta_ofdm->plcp_err,
                      max_ofdm->plcp_err);
#line 774
  pos = tmp___5 + pos;
#line 778
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"crc32_err:", ofdm->crc32_err, accum_ofdm->crc32_err,
                      delta_ofdm->crc32_err, max_ofdm->crc32_err);
#line 778
  pos = tmp___6 + pos;
#line 782
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"overrun_err:", ofdm->overrun_err, accum_ofdm->overrun_err,
                      delta_ofdm->overrun_err, max_ofdm->overrun_err);
#line 782
  pos = tmp___7 + pos;
#line 787
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"early_overrun_err:", ofdm->early_overrun_err, accum_ofdm->early_overrun_err,
                      delta_ofdm->early_overrun_err, max_ofdm->early_overrun_err);
#line 787
  pos = tmp___8 + pos;
#line 793
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"crc32_good:", ofdm->crc32_good, accum_ofdm->crc32_good,
                      delta_ofdm->crc32_good, max_ofdm->crc32_good);
#line 793
  pos = tmp___9 + pos;
#line 798
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"false_alarm_cnt:", ofdm->false_alarm_cnt, accum_ofdm->false_alarm_cnt,
                       delta_ofdm->false_alarm_cnt, max_ofdm->false_alarm_cnt);
#line 798
  pos = tmp___10 + pos;
#line 804
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_sync_err_cnt:", ofdm->fina_sync_err_cnt, accum_ofdm->fina_sync_err_cnt,
                       delta_ofdm->fina_sync_err_cnt, max_ofdm->fina_sync_err_cnt);
#line 804
  pos = tmp___11 + pos;
#line 810
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sfd_timeout:", ofdm->sfd_timeout, accum_ofdm->sfd_timeout,
                       delta_ofdm->sfd_timeout, max_ofdm->sfd_timeout);
#line 810
  pos = tmp___12 + pos;
#line 815
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_timeout:", ofdm->fina_timeout, accum_ofdm->fina_timeout,
                       delta_ofdm->fina_timeout, max_ofdm->fina_timeout);
#line 815
  pos = tmp___13 + pos;
#line 820
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"unresponded_rts:", ofdm->unresponded_rts, accum_ofdm->unresponded_rts,
                       delta_ofdm->unresponded_rts, max_ofdm->unresponded_rts);
#line 820
  pos = tmp___14 + pos;
#line 826
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"rxe_frame_lmt_ovrun:", ofdm->rxe_frame_limit_overrun,
                       accum_ofdm->rxe_frame_limit_overrun, delta_ofdm->rxe_frame_limit_overrun,
                       max_ofdm->rxe_frame_limit_overrun);
#line 826
  pos = tmp___15 + pos;
#line 832
  tmp___16 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_ack_cnt:", ofdm->sent_ack_cnt, accum_ofdm->sent_ack_cnt,
                       delta_ofdm->sent_ack_cnt, max_ofdm->sent_ack_cnt);
#line 832
  pos = tmp___16 + pos;
#line 837
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_cts_cnt:", ofdm->sent_cts_cnt, accum_ofdm->sent_cts_cnt,
                       delta_ofdm->sent_cts_cnt, max_ofdm->sent_cts_cnt);
#line 837
  pos = tmp___17 + pos;
#line 842
  tmp___18 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_ba_rsp_cnt:", ofdm->sent_ba_rsp_cnt, accum_ofdm->sent_ba_rsp_cnt,
                       delta_ofdm->sent_ba_rsp_cnt, max_ofdm->sent_ba_rsp_cnt);
#line 842
  pos = tmp___18 + pos;
#line 848
  tmp___19 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"dsp_self_kill:", ofdm->dsp_self_kill, accum_ofdm->dsp_self_kill,
                       delta_ofdm->dsp_self_kill, max_ofdm->dsp_self_kill);
#line 848
  pos = tmp___19 + pos;
#line 854
  tmp___20 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"mh_format_err:", ofdm->mh_format_err, accum_ofdm->mh_format_err,
                       delta_ofdm->mh_format_err, max_ofdm->mh_format_err);
#line 854
  pos = tmp___20 + pos;
#line 860
  tmp___21 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"re_acq_main_rssi_sum:", ofdm->re_acq_main_rssi_sum,
                       accum_ofdm->re_acq_main_rssi_sum, delta_ofdm->re_acq_main_rssi_sum,
                       max_ofdm->re_acq_main_rssi_sum);
#line 860
  pos = tmp___21 + pos;
#line 867
  tmp___22 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                       (char *)"Statistics_Rx - CCK:");
#line 867
  pos = tmp___22 + pos;
#line 869
  tmp___23 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"ina_cnt:", cck->ina_cnt, accum_cck->ina_cnt, delta_cck->ina_cnt,
                       max_cck->ina_cnt);
#line 869
  pos = tmp___23 + pos;
#line 873
  tmp___24 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_cnt:", cck->fina_cnt, accum_cck->fina_cnt, delta_cck->fina_cnt,
                       max_cck->fina_cnt);
#line 873
  pos = tmp___24 + pos;
#line 877
  tmp___25 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"plcp_err:", cck->plcp_err, accum_cck->plcp_err, delta_cck->plcp_err,
                       max_cck->plcp_err);
#line 877
  pos = tmp___25 + pos;
#line 881
  tmp___26 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"crc32_err:", cck->crc32_err, accum_cck->crc32_err,
                       delta_cck->crc32_err, max_cck->crc32_err);
#line 881
  pos = tmp___26 + pos;
#line 885
  tmp___27 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"overrun_err:", cck->overrun_err, accum_cck->overrun_err,
                       delta_cck->overrun_err, max_cck->overrun_err);
#line 885
  pos = tmp___27 + pos;
#line 890
  tmp___28 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"early_overrun_err:", cck->early_overrun_err, accum_cck->early_overrun_err,
                       delta_cck->early_overrun_err, max_cck->early_overrun_err);
#line 890
  pos = tmp___28 + pos;
#line 896
  tmp___29 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"crc32_good:", cck->crc32_good, accum_cck->crc32_good,
                       delta_cck->crc32_good, max_cck->crc32_good);
#line 896
  pos = tmp___29 + pos;
#line 900
  tmp___30 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"false_alarm_cnt:", cck->false_alarm_cnt, accum_cck->false_alarm_cnt,
                       delta_cck->false_alarm_cnt, max_cck->false_alarm_cnt);
#line 900
  pos = tmp___30 + pos;
#line 905
  tmp___31 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_sync_err_cnt:", cck->fina_sync_err_cnt, accum_cck->fina_sync_err_cnt,
                       delta_cck->fina_sync_err_cnt, max_cck->fina_sync_err_cnt);
#line 905
  pos = tmp___31 + pos;
#line 911
  tmp___32 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sfd_timeout:", cck->sfd_timeout, accum_cck->sfd_timeout,
                       delta_cck->sfd_timeout, max_cck->sfd_timeout);
#line 911
  pos = tmp___32 + pos;
#line 916
  tmp___33 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_timeout:", cck->fina_timeout, accum_cck->fina_timeout,
                       delta_cck->fina_timeout, max_cck->fina_timeout);
#line 916
  pos = tmp___33 + pos;
#line 921
  tmp___34 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"unresponded_rts:", cck->unresponded_rts, accum_cck->unresponded_rts,
                       delta_cck->unresponded_rts, max_cck->unresponded_rts);
#line 921
  pos = tmp___34 + pos;
#line 926
  tmp___35 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"rxe_frame_lmt_ovrun:", cck->rxe_frame_limit_overrun,
                       accum_cck->rxe_frame_limit_overrun, delta_cck->rxe_frame_limit_overrun,
                       max_cck->rxe_frame_limit_overrun);
#line 926
  pos = tmp___35 + pos;
#line 932
  tmp___36 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_ack_cnt:", cck->sent_ack_cnt, accum_cck->sent_ack_cnt,
                       delta_cck->sent_ack_cnt, max_cck->sent_ack_cnt);
#line 932
  pos = tmp___36 + pos;
#line 937
  tmp___37 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_cts_cnt:", cck->sent_cts_cnt, accum_cck->sent_cts_cnt,
                       delta_cck->sent_cts_cnt, max_cck->sent_cts_cnt);
#line 937
  pos = tmp___37 + pos;
#line 942
  tmp___38 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_ba_rsp_cnt:", cck->sent_ba_rsp_cnt, accum_cck->sent_ba_rsp_cnt,
                       delta_cck->sent_ba_rsp_cnt, max_cck->sent_ba_rsp_cnt);
#line 942
  pos = tmp___38 + pos;
#line 948
  tmp___39 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"dsp_self_kill:", cck->dsp_self_kill, accum_cck->dsp_self_kill,
                       delta_cck->dsp_self_kill, max_cck->dsp_self_kill);
#line 948
  pos = tmp___39 + pos;
#line 953
  tmp___40 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"mh_format_err:", cck->mh_format_err, accum_cck->mh_format_err,
                       delta_cck->mh_format_err, max_cck->mh_format_err);
#line 953
  pos = tmp___40 + pos;
#line 958
  tmp___41 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"re_acq_main_rssi_sum:", cck->re_acq_main_rssi_sum,
                       accum_cck->re_acq_main_rssi_sum, delta_cck->re_acq_main_rssi_sum,
                       max_cck->re_acq_main_rssi_sum);
#line 958
  pos = tmp___41 + pos;
#line 965
  tmp___42 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                       (char *)"Statistics_Rx - GENERAL:");
#line 965
  pos = tmp___42 + pos;
#line 967
  tmp___43 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"bogus_cts:", general->bogus_cts, accum_general->bogus_cts,
                       delta_general->bogus_cts, max_general->bogus_cts);
#line 967
  pos = tmp___43 + pos;
#line 972
  tmp___44 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"bogus_ack:", general->bogus_ack, accum_general->bogus_ack,
                       delta_general->bogus_ack, max_general->bogus_ack);
#line 972
  pos = tmp___44 + pos;
#line 977
  tmp___45 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"non_bssid_frames:", general->non_bssid_frames, accum_general->non_bssid_frames,
                       delta_general->non_bssid_frames, max_general->non_bssid_frames);
#line 977
  pos = tmp___45 + pos;
#line 983
  tmp___46 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"filtered_frames:", general->filtered_frames, accum_general->filtered_frames,
                       delta_general->filtered_frames, max_general->filtered_frames);
#line 983
  pos = tmp___46 + pos;
#line 989
  tmp___47 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"non_channel_beacons:", general->non_channel_beacons,
                       accum_general->non_channel_beacons, delta_general->non_channel_beacons,
                       max_general->non_channel_beacons);
#line 989
  pos = tmp___47 + pos;
#line 995
  tmp___48 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"channel_beacons:", general->channel_beacons, accum_general->channel_beacons,
                       delta_general->channel_beacons, max_general->channel_beacons);
#line 995
  pos = tmp___48 + pos;
#line 1001
  tmp___49 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"num_missed_bcon:", general->num_missed_bcon, accum_general->num_missed_bcon,
                       delta_general->num_missed_bcon, max_general->num_missed_bcon);
#line 1001
  pos = tmp___49 + pos;
#line 1007
  tmp___50 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"adc_rx_saturation_time:", general->adc_rx_saturation_time,
                       accum_general->adc_rx_saturation_time, delta_general->adc_rx_saturation_time,
                       max_general->adc_rx_saturation_time);
#line 1007
  pos = tmp___50 + pos;
#line 1013
  tmp___51 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"ina_detect_search_tm:", general->ina_detection_search_time,
                       accum_general->ina_detection_search_time, delta_general->ina_detection_search_time,
                       max_general->ina_detection_search_time);
#line 1013
  pos = tmp___51 + pos;
#line 1019
  tmp___52 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_silence_rssi_a:", general->beacon_silence_rssi_a,
                       accum_general->beacon_silence_rssi_a, delta_general->beacon_silence_rssi_a,
                       max_general->beacon_silence_rssi_a);
#line 1019
  pos = tmp___52 + pos;
#line 1025
  tmp___53 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_silence_rssi_b:", general->beacon_silence_rssi_b,
                       accum_general->beacon_silence_rssi_b, delta_general->beacon_silence_rssi_b,
                       max_general->beacon_silence_rssi_b);
#line 1025
  pos = tmp___53 + pos;
#line 1031
  tmp___54 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_silence_rssi_c:", general->beacon_silence_rssi_c,
                       accum_general->beacon_silence_rssi_c, delta_general->beacon_silence_rssi_c,
                       max_general->beacon_silence_rssi_c);
#line 1031
  pos = tmp___54 + pos;
#line 1037
  tmp___55 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"interference_data_flag:", general->interference_data_flag,
                       accum_general->interference_data_flag, delta_general->interference_data_flag,
                       max_general->interference_data_flag);
#line 1037
  pos = tmp___55 + pos;
#line 1043
  tmp___56 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"channel_load:", general->channel_load, accum_general->channel_load,
                       delta_general->channel_load, max_general->channel_load);
#line 1043
  pos = tmp___56 + pos;
#line 1049
  tmp___57 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"dsp_false_alarms:", general->dsp_false_alarms, accum_general->dsp_false_alarms,
                       delta_general->dsp_false_alarms, max_general->dsp_false_alarms);
#line 1049
  pos = tmp___57 + pos;
#line 1055
  tmp___58 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_rssi_a:", general->beacon_rssi_a, accum_general->beacon_rssi_a,
                       delta_general->beacon_rssi_a, max_general->beacon_rssi_a);
#line 1055
  pos = tmp___58 + pos;
#line 1061
  tmp___59 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_rssi_b:", general->beacon_rssi_b, accum_general->beacon_rssi_b,
                       delta_general->beacon_rssi_b, max_general->beacon_rssi_b);
#line 1061
  pos = tmp___59 + pos;
#line 1067
  tmp___60 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_rssi_c:", general->beacon_rssi_c, accum_general->beacon_rssi_c,
                       delta_general->beacon_rssi_c, max_general->beacon_rssi_c);
#line 1067
  pos = tmp___60 + pos;
#line 1073
  tmp___61 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_energy_a:", general->beacon_energy_a, accum_general->beacon_energy_a,
                       delta_general->beacon_energy_a, max_general->beacon_energy_a);
#line 1073
  pos = tmp___61 + pos;
#line 1079
  tmp___62 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_energy_b:", general->beacon_energy_b, accum_general->beacon_energy_b,
                       delta_general->beacon_energy_b, max_general->beacon_energy_b);
#line 1079
  pos = tmp___62 + pos;
#line 1085
  tmp___63 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_energy_c:", general->beacon_energy_c, accum_general->beacon_energy_c,
                       delta_general->beacon_energy_c, max_general->beacon_energy_c);
#line 1085
  pos = tmp___63 + pos;
#line 1092
  tmp___64 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                       (char *)"Statistics_Rx - OFDM_HT:");
#line 1092
  pos = tmp___64 + pos;
#line 1094
  tmp___65 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"plcp_err:", ht->plcp_err, accum_ht->plcp_err, delta_ht->plcp_err,
                       max_ht->plcp_err);
#line 1094
  pos = tmp___65 + pos;
#line 1098
  tmp___66 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"overrun_err:", ht->overrun_err, accum_ht->overrun_err,
                       delta_ht->overrun_err, max_ht->overrun_err);
#line 1098
  pos = tmp___66 + pos;
#line 1102
  tmp___67 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"early_overrun_err:", ht->early_overrun_err, accum_ht->early_overrun_err,
                       delta_ht->early_overrun_err, max_ht->early_overrun_err);
#line 1102
  pos = tmp___67 + pos;
#line 1108
  tmp___68 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"crc32_good:", ht->crc32_good, accum_ht->crc32_good,
                       delta_ht->crc32_good, max_ht->crc32_good);
#line 1108
  pos = tmp___68 + pos;
#line 1112
  tmp___69 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"crc32_err:", ht->crc32_err, accum_ht->crc32_err, delta_ht->crc32_err,
                       max_ht->crc32_err);
#line 1112
  pos = tmp___69 + pos;
#line 1116
  tmp___70 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"mh_format_err:", ht->mh_format_err, accum_ht->mh_format_err,
                       delta_ht->mh_format_err, max_ht->mh_format_err);
#line 1116
  pos = tmp___70 + pos;
#line 1121
  tmp___71 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg_crc32_good:", ht->agg_crc32_good, accum_ht->agg_crc32_good,
                       delta_ht->agg_crc32_good, max_ht->agg_crc32_good);
#line 1121
  pos = tmp___71 + pos;
#line 1126
  tmp___72 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg_mpdu_cnt:", ht->agg_mpdu_cnt, accum_ht->agg_mpdu_cnt,
                       delta_ht->agg_mpdu_cnt, max_ht->agg_mpdu_cnt);
#line 1126
  pos = tmp___72 + pos;
#line 1131
  tmp___73 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg_cnt:", ht->agg_cnt, accum_ht->agg_cnt, delta_ht->agg_cnt,
                       max_ht->agg_cnt);
#line 1131
  pos = tmp___73 + pos;
#line 1135
  tmp___74 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"unsupport_mcs:", ht->unsupport_mcs, accum_ht->unsupport_mcs,
                       delta_ht->unsupport_mcs, max_ht->unsupport_mcs);
#line 1135
  pos = tmp___74 + pos;
#line 1141
  spin_unlock_bh(& priv->statistics.lock);
#line 1143
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 1144
  kfree((void const   *)buf);
#line 1145
  return (ret);
}
}
#line 1148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_ucode_tx_stats_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct statistics_tx *tx ;
  struct statistics_tx *accum_tx ;
  struct statistics_tx *delta_tx ;
  struct statistics_tx *max_tx ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 1152
  priv = (struct iwl_priv *)file->private_data;
#line 1153
  pos = 0;
#line 1155
  bufsz = 5242;
#line 1159
  tmp = iwl_is_alive(priv);
#line 1159
  if (tmp == 0) {
#line 1160
    return (-11L);
  } else {

  }
#line 1162
  tmp___0 = kzalloc((size_t )bufsz, 208U);
#line 1162
  buf = (char *)tmp___0;
#line 1163
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 1164
    return (-12L);
  } else {

  }
#line 1170
  spin_lock_bh(& priv->statistics.lock);
#line 1172
  tx = & priv->statistics.tx;
#line 1173
  accum_tx = & priv->accum_stats.tx;
#line 1174
  delta_tx = & priv->delta_stats.tx;
#line 1175
  max_tx = & priv->max_delta_stats.tx;
#line 1177
  tmp___1 = iwl_statistics_flag(priv, buf, bufsz);
#line 1177
  pos = tmp___1 + pos;
#line 1178
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                      (char *)"Statistics_Tx:");
#line 1178
  pos = tmp___2 + pos;
#line 1180
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"preamble:", tx->preamble_cnt, accum_tx->preamble_cnt,
                      delta_tx->preamble_cnt, max_tx->preamble_cnt);
#line 1180
  pos = tmp___3 + pos;
#line 1185
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"rx_detected_cnt:", tx->rx_detected_cnt, accum_tx->rx_detected_cnt,
                      delta_tx->rx_detected_cnt, max_tx->rx_detected_cnt);
#line 1185
  pos = tmp___4 + pos;
#line 1190
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"bt_prio_defer_cnt:", tx->bt_prio_defer_cnt, accum_tx->bt_prio_defer_cnt,
                      delta_tx->bt_prio_defer_cnt, max_tx->bt_prio_defer_cnt);
#line 1190
  pos = tmp___5 + pos;
#line 1196
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"bt_prio_kill_cnt:", tx->bt_prio_kill_cnt, accum_tx->bt_prio_kill_cnt,
                      delta_tx->bt_prio_kill_cnt, max_tx->bt_prio_kill_cnt);
#line 1196
  pos = tmp___6 + pos;
#line 1202
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"few_bytes_cnt:", tx->few_bytes_cnt, accum_tx->few_bytes_cnt,
                      delta_tx->few_bytes_cnt, max_tx->few_bytes_cnt);
#line 1202
  pos = tmp___7 + pos;
#line 1207
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"cts_timeout:", tx->cts_timeout, accum_tx->cts_timeout,
                      delta_tx->cts_timeout, max_tx->cts_timeout);
#line 1207
  pos = tmp___8 + pos;
#line 1211
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"ack_timeout:", tx->ack_timeout, accum_tx->ack_timeout,
                      delta_tx->ack_timeout, max_tx->ack_timeout);
#line 1211
  pos = tmp___9 + pos;
#line 1216
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"expected_ack_cnt:", tx->expected_ack_cnt, accum_tx->expected_ack_cnt,
                       delta_tx->expected_ack_cnt, max_tx->expected_ack_cnt);
#line 1216
  pos = tmp___10 + pos;
#line 1222
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"actual_ack_cnt:", tx->actual_ack_cnt, accum_tx->actual_ack_cnt,
                       delta_tx->actual_ack_cnt, max_tx->actual_ack_cnt);
#line 1222
  pos = tmp___11 + pos;
#line 1228
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"dump_msdu_cnt:", tx->dump_msdu_cnt, accum_tx->dump_msdu_cnt,
                       delta_tx->dump_msdu_cnt, max_tx->dump_msdu_cnt);
#line 1228
  pos = tmp___12 + pos;
#line 1234
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"abort_nxt_frame_mismatch:", tx->burst_abort_next_frame_mismatch_cnt,
                       accum_tx->burst_abort_next_frame_mismatch_cnt, delta_tx->burst_abort_next_frame_mismatch_cnt,
                       max_tx->burst_abort_next_frame_mismatch_cnt);
#line 1234
  pos = tmp___13 + pos;
#line 1240
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"abort_missing_nxt_frame:", tx->burst_abort_missing_next_frame_cnt,
                       accum_tx->burst_abort_missing_next_frame_cnt, delta_tx->burst_abort_missing_next_frame_cnt,
                       max_tx->burst_abort_missing_next_frame_cnt);
#line 1240
  pos = tmp___14 + pos;
#line 1246
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"cts_timeout_collision:", tx->cts_timeout_collision,
                       accum_tx->cts_timeout_collision, delta_tx->cts_timeout_collision,
                       max_tx->cts_timeout_collision);
#line 1246
  pos = tmp___15 + pos;
#line 1252
  tmp___16 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"ack_ba_timeout_collision:", tx->ack_or_ba_timeout_collision,
                       accum_tx->ack_or_ba_timeout_collision, delta_tx->ack_or_ba_timeout_collision,
                       max_tx->ack_or_ba_timeout_collision);
#line 1252
  pos = tmp___16 + pos;
#line 1258
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg ba_timeout:", tx->agg.ba_timeout, accum_tx->agg.ba_timeout,
                       delta_tx->agg.ba_timeout, max_tx->agg.ba_timeout);
#line 1258
  pos = tmp___17 + pos;
#line 1264
  tmp___18 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg ba_resched_frames:", tx->agg.ba_reschedule_frames,
                       accum_tx->agg.ba_reschedule_frames, delta_tx->agg.ba_reschedule_frames,
                       max_tx->agg.ba_reschedule_frames);
#line 1264
  pos = tmp___18 + pos;
#line 1270
  tmp___19 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg scd_query_agg_frame:", tx->agg.scd_query_agg_frame_cnt,
                       accum_tx->agg.scd_query_agg_frame_cnt, delta_tx->agg.scd_query_agg_frame_cnt,
                       max_tx->agg.scd_query_agg_frame_cnt);
#line 1270
  pos = tmp___19 + pos;
#line 1276
  tmp___20 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg scd_query_no_agg:", tx->agg.scd_query_no_agg,
                       accum_tx->agg.scd_query_no_agg, delta_tx->agg.scd_query_no_agg,
                       max_tx->agg.scd_query_no_agg);
#line 1276
  pos = tmp___20 + pos;
#line 1282
  tmp___21 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg scd_query_agg:", tx->agg.scd_query_agg, accum_tx->agg.scd_query_agg,
                       delta_tx->agg.scd_query_agg, max_tx->agg.scd_query_agg);
#line 1282
  pos = tmp___21 + pos;
#line 1288
  tmp___22 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg scd_query_mismatch:", tx->agg.scd_query_mismatch,
                       accum_tx->agg.scd_query_mismatch, delta_tx->agg.scd_query_mismatch,
                       max_tx->agg.scd_query_mismatch);
#line 1288
  pos = tmp___22 + pos;
#line 1294
  tmp___23 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg frame_not_ready:", tx->agg.frame_not_ready, accum_tx->agg.frame_not_ready,
                       delta_tx->agg.frame_not_ready, max_tx->agg.frame_not_ready);
#line 1294
  pos = tmp___23 + pos;
#line 1300
  tmp___24 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg underrun:", tx->agg.underrun, accum_tx->agg.underrun,
                       delta_tx->agg.underrun, max_tx->agg.underrun);
#line 1300
  pos = tmp___24 + pos;
#line 1305
  tmp___25 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg bt_prio_kill:", tx->agg.bt_prio_kill, accum_tx->agg.bt_prio_kill,
                       delta_tx->agg.bt_prio_kill, max_tx->agg.bt_prio_kill);
#line 1305
  pos = tmp___25 + pos;
#line 1311
  tmp___26 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg rx_ba_rsp_cnt:", tx->agg.rx_ba_rsp_cnt, accum_tx->agg.rx_ba_rsp_cnt,
                       delta_tx->agg.rx_ba_rsp_cnt, max_tx->agg.rx_ba_rsp_cnt);
#line 1311
  pos = tmp___26 + pos;
#line 1318
  if (((unsigned int )tx->tx_power.ant_a != 0U || (unsigned int )tx->tx_power.ant_b != 0U) || (unsigned int )tx->tx_power.ant_c != 0U) {
#line 1319
    tmp___27 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "tx power: (1/2 dB step)\n");
#line 1319
    pos = tmp___27 + pos;
#line 1321
    if ((int )(priv->nvm_data)->valid_tx_ant & 1 && (unsigned int )tx->tx_power.ant_a != 0U) {
#line 1323
      tmp___28 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_hex,
                           (char *)"antenna A:", (int )tx->tx_power.ant_a);
#line 1323
      pos = tmp___28 + pos;
    } else {

    }
#line 1326
    if (((unsigned long )(priv->nvm_data)->valid_tx_ant & 2UL) != 0UL && (unsigned int )tx->tx_power.ant_b != 0U) {
#line 1328
      tmp___29 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_hex,
                           (char *)"antenna B:", (int )tx->tx_power.ant_b);
#line 1328
      pos = tmp___29 + pos;
    } else {

    }
#line 1331
    if (((unsigned long )(priv->nvm_data)->valid_tx_ant & 4UL) != 0UL && (unsigned int )tx->tx_power.ant_c != 0U) {
#line 1333
      tmp___30 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_hex,
                           (char *)"antenna C:", (int )tx->tx_power.ant_c);
#line 1333
      pos = tmp___30 + pos;
    } else {

    }
  } else {

  }
#line 1338
  spin_unlock_bh(& priv->statistics.lock);
#line 1340
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 1341
  kfree((void const   *)buf);
#line 1342
  return (ret);
}
}
#line 1345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_ucode_general_stats_read(struct file *file , char *user_buf ,
                                                  size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct statistics_general_common *general ;
  struct statistics_general_common *accum_general ;
  struct statistics_general_common *delta_general ;
  struct statistics_general_common *max_general ;
  struct statistics_dbg *dbg ;
  struct statistics_dbg *accum_dbg ;
  struct statistics_dbg *delta_dbg ;
  struct statistics_dbg *max_dbg ;
  struct statistics_div *div ;
  struct statistics_div *accum_div ;
  struct statistics_div *delta_div ;
  struct statistics_div *max_div ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 1349
  priv = (struct iwl_priv *)file->private_data;
#line 1350
  pos = 0;
#line 1352
  bufsz = 1180;
#line 1359
  tmp = iwl_is_alive(priv);
#line 1359
  if (tmp == 0) {
#line 1360
    return (-11L);
  } else {

  }
#line 1362
  tmp___0 = kzalloc((size_t )bufsz, 208U);
#line 1362
  buf = (char *)tmp___0;
#line 1363
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 1364
    return (-12L);
  } else {

  }
#line 1371
  spin_lock_bh(& priv->statistics.lock);
#line 1373
  general = & priv->statistics.common;
#line 1374
  dbg = & priv->statistics.common.dbg;
#line 1375
  div = & priv->statistics.common.div;
#line 1376
  accum_general = & priv->accum_stats.common;
#line 1377
  accum_dbg = & priv->accum_stats.common.dbg;
#line 1378
  accum_div = & priv->accum_stats.common.div;
#line 1379
  delta_general = & priv->delta_stats.common;
#line 1380
  max_general = & priv->max_delta_stats.common;
#line 1381
  delta_dbg = & priv->delta_stats.common.dbg;
#line 1382
  max_dbg = & priv->max_delta_stats.common.dbg;
#line 1383
  delta_div = & priv->delta_stats.common.div;
#line 1384
  max_div = & priv->max_delta_stats.common.div;
#line 1386
  tmp___1 = iwl_statistics_flag(priv, buf, bufsz);
#line 1386
  pos = tmp___1 + pos;
#line 1387
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                      (char *)"Statistics_General:");
#line 1387
  pos = tmp___2 + pos;
#line 1389
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_value,
                      (char *)"temperature:", general->temperature);
#line 1389
  pos = tmp___3 + pos;
#line 1392
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_value,
                      (char *)"temperature_m:", general->temperature_m);
#line 1392
  pos = tmp___4 + pos;
#line 1395
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_value,
                      (char *)"ttl_timestamp:", general->ttl_timestamp);
#line 1395
  pos = tmp___5 + pos;
#line 1398
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"burst_check:", dbg->burst_check, accum_dbg->burst_check,
                      delta_dbg->burst_check, max_dbg->burst_check);
#line 1398
  pos = tmp___6 + pos;
#line 1403
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"burst_count:", dbg->burst_count, accum_dbg->burst_count,
                      delta_dbg->burst_count, max_dbg->burst_count);
#line 1403
  pos = tmp___7 + pos;
#line 1408
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"wait_for_silence_timeout_count:", dbg->wait_for_silence_timeout_cnt,
                      accum_dbg->wait_for_silence_timeout_cnt, delta_dbg->wait_for_silence_timeout_cnt,
                      max_dbg->wait_for_silence_timeout_cnt);
#line 1408
  pos = tmp___8 + pos;
#line 1414
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"sleep_time:", general->sleep_time, accum_general->sleep_time,
                      delta_general->sleep_time, max_general->sleep_time);
#line 1414
  pos = tmp___9 + pos;
#line 1419
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"slots_out:", general->slots_out, accum_general->slots_out,
                       delta_general->slots_out, max_general->slots_out);
#line 1419
  pos = tmp___10 + pos;
#line 1424
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"slots_idle:", general->slots_idle, accum_general->slots_idle,
                       delta_general->slots_idle, max_general->slots_idle);
#line 1424
  pos = tmp___11 + pos;
#line 1429
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"tx_on_a:", div->tx_on_a, accum_div->tx_on_a, delta_div->tx_on_a,
                       max_div->tx_on_a);
#line 1429
  pos = tmp___12 + pos;
#line 1433
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"tx_on_b:", div->tx_on_b, accum_div->tx_on_b, delta_div->tx_on_b,
                       max_div->tx_on_b);
#line 1433
  pos = tmp___13 + pos;
#line 1437
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"exec_time:", div->exec_time, accum_div->exec_time,
                       delta_div->exec_time, max_div->exec_time);
#line 1437
  pos = tmp___14 + pos;
#line 1441
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"probe_time:", div->probe_time, accum_div->probe_time,
                       delta_div->probe_time, max_div->probe_time);
#line 1441
  pos = tmp___15 + pos;
#line 1445
  tmp___16 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"rx_enable_counter:", general->rx_enable_counter, accum_general->rx_enable_counter,
                       delta_general->rx_enable_counter, max_general->rx_enable_counter);
#line 1445
  pos = tmp___16 + pos;
#line 1451
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"num_of_sos_states:", general->num_of_sos_states, accum_general->num_of_sos_states,
                       delta_general->num_of_sos_states, max_general->num_of_sos_states);
#line 1451
  pos = tmp___17 + pos;
#line 1458
  spin_unlock_bh(& priv->statistics.lock);
#line 1460
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 1461
  kfree((void const   *)buf);
#line 1462
  return (ret);
}
}
#line 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_ucode_bt_stats_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct statistics_bt_activity *bt ;
  struct statistics_bt_activity *accum_bt ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1469
  priv = (struct iwl_priv *)file->private_data;
#line 1470
  pos = 0;
#line 1472
  bufsz = 968;
#line 1476
  tmp = iwl_is_alive(priv);
#line 1476
  if (tmp == 0) {
#line 1477
    return (-11L);
  } else {

  }
#line 1479
  if ((unsigned int )priv->bt_enable_flag == 0U) {
#line 1480
    return (-22L);
  } else {

  }
#line 1483
  ldv_mutex_lock_649(& priv->mutex);
#line 1484
  tmp___0 = iwl_send_statistics_request(priv, 0, 0);
#line 1484
  ret = (ssize_t )tmp___0;
#line 1485
  ldv_mutex_unlock_650(& priv->mutex);
#line 1487
  if (ret != 0L) {
#line 1488
    return (-11L);
  } else {

  }
#line 1489
  tmp___1 = kzalloc((size_t )bufsz, 208U);
#line 1489
  buf = (char *)tmp___1;
#line 1490
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 1491
    return (-12L);
  } else {

  }
#line 1499
  spin_lock_bh(& priv->statistics.lock);
#line 1501
  bt = & priv->statistics.bt_activity;
#line 1502
  accum_bt = & priv->accum_stats.bt_activity;
#line 1504
  tmp___2 = iwl_statistics_flag(priv, buf, bufsz);
#line 1504
  pos = tmp___2 + pos;
#line 1505
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "Statistics_BT:\n");
#line 1505
  pos = tmp___3 + pos;
#line 1506
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\t\t\tcurrent\t\t\taccumulative\n");
#line 1506
  pos = tmp___4 + pos;
#line 1508
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "hi_priority_tx_req_cnt:\t\t%u\t\t\t%u\n",
                      bt->hi_priority_tx_req_cnt, accum_bt->hi_priority_tx_req_cnt);
#line 1508
  pos = tmp___5 + pos;
#line 1512
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "hi_priority_tx_denied_cnt:\t%u\t\t\t%u\n",
                      bt->hi_priority_tx_denied_cnt, accum_bt->hi_priority_tx_denied_cnt);
#line 1512
  pos = tmp___6 + pos;
#line 1516
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "lo_priority_tx_req_cnt:\t\t%u\t\t\t%u\n",
                      bt->lo_priority_tx_req_cnt, accum_bt->lo_priority_tx_req_cnt);
#line 1516
  pos = tmp___7 + pos;
#line 1520
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "lo_priority_tx_denied_cnt:\t%u\t\t\t%u\n",
                      bt->lo_priority_tx_denied_cnt, accum_bt->lo_priority_tx_denied_cnt);
#line 1520
  pos = tmp___8 + pos;
#line 1524
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "hi_priority_rx_req_cnt:\t\t%u\t\t\t%u\n",
                      bt->hi_priority_rx_req_cnt, accum_bt->hi_priority_rx_req_cnt);
#line 1524
  pos = tmp___9 + pos;
#line 1528
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "hi_priority_rx_denied_cnt:\t%u\t\t\t%u\n",
                       bt->hi_priority_rx_denied_cnt, accum_bt->hi_priority_rx_denied_cnt);
#line 1528
  pos = tmp___10 + pos;
#line 1532
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "lo_priority_rx_req_cnt:\t\t%u\t\t\t%u\n",
                       bt->lo_priority_rx_req_cnt, accum_bt->lo_priority_rx_req_cnt);
#line 1532
  pos = tmp___11 + pos;
#line 1536
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "lo_priority_rx_denied_cnt:\t%u\t\t\t%u\n",
                       bt->lo_priority_rx_denied_cnt, accum_bt->lo_priority_rx_denied_cnt);
#line 1536
  pos = tmp___12 + pos;
#line 1541
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "(rx)num_bt_kills:\t\t%u\t\t\t%u\n",
                       priv->statistics.num_bt_kills, priv->statistics.accum_num_bt_kills);
#line 1541
  pos = tmp___13 + pos;
#line 1546
  spin_unlock_bh(& priv->statistics.lock);
#line 1548
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 1549
  kfree((void const   *)buf);
#line 1550
  return (ret);
}
}
#line 1553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_reply_tx_error_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  int tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  int tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  char const   *tmp___56 ;
  int tmp___57 ;
  char const   *tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  int tmp___63 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  char const   *tmp___66 ;
  int tmp___67 ;
  char const   *tmp___68 ;
  int tmp___69 ;
  char const   *tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;

  {
#line 1557
  priv = (struct iwl_priv *)file->private_data;
#line 1558
  pos = 0;
#line 1560
  bufsz = 3656;
#line 1564
  tmp = iwl_is_alive(priv);
#line 1564
  if (tmp == 0) {
#line 1565
    return (-11L);
  } else {

  }
#line 1567
  tmp___0 = kzalloc((size_t )bufsz, 208U);
#line 1567
  buf = (char *)tmp___0;
#line 1568
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 1569
    return (-12L);
  } else {

  }
#line 1571
  tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "Statistics_TX_Error:\n");
#line 1571
  pos = tmp___1 + pos;
#line 1572
  tmp___2 = iwl_get_tx_fail_reason(64U);
#line 1572
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t\t%u\n",
                      tmp___2, priv->reply_tx_stats.pp_delay);
#line 1572
  pos = tmp___3 + pos;
#line 1575
  tmp___4 = iwl_get_tx_fail_reason(65U);
#line 1575
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                      tmp___4, priv->reply_tx_stats.pp_few_bytes);
#line 1575
  pos = tmp___5 + pos;
#line 1578
  tmp___6 = iwl_get_tx_fail_reason(66U);
#line 1578
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                      tmp___6, priv->reply_tx_stats.pp_bt_prio);
#line 1578
  pos = tmp___7 + pos;
#line 1581
  tmp___8 = iwl_get_tx_fail_reason(67U);
#line 1581
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                      tmp___8, priv->reply_tx_stats.pp_quiet_period);
#line 1581
  pos = tmp___9 + pos;
#line 1584
  tmp___10 = iwl_get_tx_fail_reason(68U);
#line 1584
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___10, priv->reply_tx_stats.pp_calc_ttak);
#line 1584
  pos = tmp___11 + pos;
#line 1587
  tmp___12 = iwl_get_tx_fail_reason(129U);
#line 1587
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___12, priv->reply_tx_stats.int_crossed_retry);
#line 1587
  pos = tmp___13 + pos;
#line 1591
  tmp___14 = iwl_get_tx_fail_reason(130U);
#line 1591
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___14, priv->reply_tx_stats.short_limit);
#line 1591
  pos = tmp___15 + pos;
#line 1594
  tmp___16 = iwl_get_tx_fail_reason(131U);
#line 1594
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___16, priv->reply_tx_stats.long_limit);
#line 1594
  pos = tmp___17 + pos;
#line 1597
  tmp___18 = iwl_get_tx_fail_reason(132U);
#line 1597
  tmp___19 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___18, priv->reply_tx_stats.fifo_underrun);
#line 1597
  pos = tmp___19 + pos;
#line 1600
  tmp___20 = iwl_get_tx_fail_reason(133U);
#line 1600
  tmp___21 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___20, priv->reply_tx_stats.drain_flow);
#line 1600
  pos = tmp___21 + pos;
#line 1603
  tmp___22 = iwl_get_tx_fail_reason(134U);
#line 1603
  tmp___23 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___22, priv->reply_tx_stats.rfkill_flush);
#line 1603
  pos = tmp___23 + pos;
#line 1606
  tmp___24 = iwl_get_tx_fail_reason(135U);
#line 1606
  tmp___25 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___24, priv->reply_tx_stats.life_expire);
#line 1606
  pos = tmp___25 + pos;
#line 1609
  tmp___26 = iwl_get_tx_fail_reason(136U);
#line 1609
  tmp___27 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___26, priv->reply_tx_stats.dest_ps);
#line 1609
  pos = tmp___27 + pos;
#line 1612
  tmp___28 = iwl_get_tx_fail_reason(137U);
#line 1612
  tmp___29 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___28, priv->reply_tx_stats.host_abort);
#line 1612
  pos = tmp___29 + pos;
#line 1615
  tmp___30 = iwl_get_tx_fail_reason(138U);
#line 1615
  tmp___31 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___30, priv->reply_tx_stats.pp_delay);
#line 1615
  pos = tmp___31 + pos;
#line 1618
  tmp___32 = iwl_get_tx_fail_reason(139U);
#line 1618
  tmp___33 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___32, priv->reply_tx_stats.sta_invalid);
#line 1618
  pos = tmp___33 + pos;
#line 1621
  tmp___34 = iwl_get_tx_fail_reason(140U);
#line 1621
  tmp___35 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___34, priv->reply_tx_stats.frag_drop);
#line 1621
  pos = tmp___35 + pos;
#line 1624
  tmp___36 = iwl_get_tx_fail_reason(141U);
#line 1624
  tmp___37 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___36, priv->reply_tx_stats.tid_disable);
#line 1624
  pos = tmp___37 + pos;
#line 1627
  tmp___38 = iwl_get_tx_fail_reason(142U);
#line 1627
  tmp___39 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___38, priv->reply_tx_stats.fifo_flush);
#line 1627
  pos = tmp___39 + pos;
#line 1630
  tmp___40 = iwl_get_tx_fail_reason(143U);
#line 1630
  tmp___41 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___40, priv->reply_tx_stats.insuff_cf_poll);
#line 1630
  pos = tmp___41 + pos;
#line 1634
  tmp___42 = iwl_get_tx_fail_reason(144U);
#line 1634
  tmp___43 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___42, priv->reply_tx_stats.fail_hw_drop);
#line 1634
  pos = tmp___43 + pos;
#line 1637
  tmp___44 = iwl_get_tx_fail_reason(145U);
#line 1637
  tmp___45 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___44, priv->reply_tx_stats.sta_color_mismatch);
#line 1637
  pos = tmp___45 + pos;
#line 1641
  tmp___46 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "UNKNOWN:\t\t\t%u\n",
                       priv->reply_tx_stats.unknown);
#line 1641
  pos = tmp___46 + pos;
#line 1644
  tmp___47 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\nStatistics_Agg_TX_Error:\n");
#line 1644
  pos = tmp___47 + pos;
#line 1647
  tmp___48 = iwl_get_agg_tx_fail_reason(1);
#line 1647
  tmp___49 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___48, priv->reply_agg_tx_stats.underrun);
#line 1647
  pos = tmp___49 + pos;
#line 1650
  tmp___50 = iwl_get_agg_tx_fail_reason(2);
#line 1650
  tmp___51 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___50, priv->reply_agg_tx_stats.bt_prio);
#line 1650
  pos = tmp___51 + pos;
#line 1653
  tmp___52 = iwl_get_agg_tx_fail_reason(4);
#line 1653
  tmp___53 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___52, priv->reply_agg_tx_stats.few_bytes);
#line 1653
  pos = tmp___53 + pos;
#line 1656
  tmp___54 = iwl_get_agg_tx_fail_reason(8);
#line 1656
  tmp___55 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___54, priv->reply_agg_tx_stats.abort);
#line 1656
  pos = tmp___55 + pos;
#line 1659
  tmp___56 = iwl_get_agg_tx_fail_reason(16);
#line 1659
  tmp___57 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___56, priv->reply_agg_tx_stats.last_sent_ttl);
#line 1659
  pos = tmp___57 + pos;
#line 1663
  tmp___58 = iwl_get_agg_tx_fail_reason(32);
#line 1663
  tmp___59 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___58, priv->reply_agg_tx_stats.last_sent_try);
#line 1663
  pos = tmp___59 + pos;
#line 1667
  tmp___60 = iwl_get_agg_tx_fail_reason(64);
#line 1667
  tmp___61 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___60, priv->reply_agg_tx_stats.last_sent_bt_kill);
#line 1667
  pos = tmp___61 + pos;
#line 1671
  tmp___62 = iwl_get_agg_tx_fail_reason(128);
#line 1671
  tmp___63 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___62, priv->reply_agg_tx_stats.scd_query);
#line 1671
  pos = tmp___63 + pos;
#line 1674
  tmp___64 = iwl_get_agg_tx_fail_reason(256);
#line 1674
  tmp___65 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___64, priv->reply_agg_tx_stats.bad_crc32);
#line 1674
  pos = tmp___65 + pos;
#line 1678
  tmp___66 = iwl_get_agg_tx_fail_reason(511);
#line 1678
  tmp___67 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___66, priv->reply_agg_tx_stats.response);
#line 1678
  pos = tmp___67 + pos;
#line 1681
  tmp___68 = iwl_get_agg_tx_fail_reason(512);
#line 1681
  tmp___69 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___68, priv->reply_agg_tx_stats.dump_tx);
#line 1681
  pos = tmp___69 + pos;
#line 1684
  tmp___70 = iwl_get_agg_tx_fail_reason(1024);
#line 1684
  tmp___71 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___70, priv->reply_agg_tx_stats.delay_tx);
#line 1684
  pos = tmp___71 + pos;
#line 1687
  tmp___72 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "UNKNOWN:\t\t\t%u\n",
                       priv->reply_agg_tx_stats.unknown);
#line 1687
  pos = tmp___72 + pos;
#line 1690
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 1691
  kfree((void const   *)buf);
#line 1692
  return (ret);
}
}
#line 1695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_sensitivity_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  int cnt ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct iwl_sensitivity_data *data ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 1699
  priv = (struct iwl_priv *)file->private_data;
#line 1700
  pos = 0;
#line 1701
  cnt = 0;
#line 1703
  bufsz = 676;
#line 1707
  data = & priv->sensitivity_data;
#line 1708
  tmp = kzalloc((size_t )bufsz, 208U);
#line 1708
  buf = (char *)tmp;
#line 1709
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 1710
    return (-12L);
  } else {

  }
#line 1712
  tmp___0 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_ofdm:\t\t\t %u\n",
                      data->auto_corr_ofdm);
#line 1712
  pos = tmp___0 + pos;
#line 1714
  tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_ofdm_mrc:\t\t %u\n",
                      data->auto_corr_ofdm_mrc);
#line 1714
  pos = tmp___1 + pos;
#line 1717
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_ofdm_x1:\t\t %u\n",
                      data->auto_corr_ofdm_x1);
#line 1717
  pos = tmp___2 + pos;
#line 1719
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_ofdm_mrc_x1:\t\t %u\n",
                      data->auto_corr_ofdm_mrc_x1);
#line 1719
  pos = tmp___3 + pos;
#line 1722
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_cck:\t\t\t %u\n",
                      data->auto_corr_cck);
#line 1722
  pos = tmp___4 + pos;
#line 1724
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_cck_mrc:\t\t %u\n",
                      data->auto_corr_cck_mrc);
#line 1724
  pos = tmp___5 + pos;
#line 1726
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "last_bad_plcp_cnt_ofdm:\t\t %u\n",
                      data->last_bad_plcp_cnt_ofdm);
#line 1726
  pos = tmp___6 + pos;
#line 1729
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "last_fa_cnt_ofdm:\t\t %u\n",
                      data->last_fa_cnt_ofdm);
#line 1729
  pos = tmp___7 + pos;
#line 1731
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "last_bad_plcp_cnt_cck:\t\t %u\n",
                      data->last_bad_plcp_cnt_cck);
#line 1731
  pos = tmp___8 + pos;
#line 1734
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "last_fa_cnt_cck:\t\t %u\n",
                      data->last_fa_cnt_cck);
#line 1734
  pos = tmp___9 + pos;
#line 1736
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_curr_state:\t\t\t %u\n",
                       data->nrg_curr_state);
#line 1736
  pos = tmp___10 + pos;
#line 1738
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_prev_state:\t\t\t %u\n",
                       data->nrg_prev_state);
#line 1738
  pos = tmp___11 + pos;
#line 1740
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_value:\t\t\t");
#line 1740
  pos = tmp___12 + pos;
#line 1741
  cnt = 0;
#line 1741
  goto ldv_55519;
  ldv_55518: 
#line 1742
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), " %u", data->nrg_value[cnt]);
#line 1742
  pos = tmp___13 + pos;
#line 1741
  cnt = cnt + 1;
  ldv_55519: ;
#line 1741
  if (cnt <= 9) {
#line 1743
    goto ldv_55518;
  } else {

  }
#line 1745
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\n");
#line 1745
  pos = tmp___14 + pos;
#line 1746
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_silence_rssi:\t\t");
#line 1746
  pos = tmp___15 + pos;
#line 1747
  cnt = 0;
#line 1747
  goto ldv_55522;
  ldv_55521: 
#line 1748
  tmp___16 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), " %u", (int )data->nrg_silence_rssi[cnt]);
#line 1748
  pos = tmp___16 + pos;
#line 1747
  cnt = cnt + 1;
  ldv_55522: ;
#line 1747
  if (cnt <= 19) {
#line 1749
    goto ldv_55521;
  } else {

  }
#line 1751
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\n");
#line 1751
  pos = tmp___17 + pos;
#line 1752
  tmp___18 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_silence_ref:\t\t %u\n",
                       data->nrg_silence_ref);
#line 1752
  pos = tmp___18 + pos;
#line 1754
  tmp___19 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_energy_idx:\t\t\t %u\n",
                       data->nrg_energy_idx);
#line 1754
  pos = tmp___19 + pos;
#line 1756
  tmp___20 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_silence_idx:\t\t %u\n",
                       data->nrg_silence_idx);
#line 1756
  pos = tmp___20 + pos;
#line 1758
  tmp___21 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_th_cck:\t\t\t %u\n",
                       data->nrg_th_cck);
#line 1758
  pos = tmp___21 + pos;
#line 1760
  tmp___22 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_auto_corr_silence_diff:\t %u\n",
                       data->nrg_auto_corr_silence_diff);
#line 1760
  pos = tmp___22 + pos;
#line 1763
  tmp___23 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "num_in_cck_no_fa:\t\t %u\n",
                       data->num_in_cck_no_fa);
#line 1763
  pos = tmp___23 + pos;
#line 1765
  tmp___24 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_th_ofdm:\t\t\t %u\n",
                       data->nrg_th_ofdm);
#line 1765
  pos = tmp___24 + pos;
#line 1768
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 1769
  kfree((void const   *)buf);
#line 1770
  return (ret);
}
}
#line 1774 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_chain_noise_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  int cnt ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct iwl_chain_noise_data *data ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 1778
  priv = (struct iwl_priv *)file->private_data;
#line 1779
  pos = 0;
#line 1780
  cnt = 0;
#line 1782
  bufsz = 260;
#line 1786
  data = & priv->chain_noise_data;
#line 1787
  tmp = kzalloc((size_t )bufsz, 208U);
#line 1787
  buf = (char *)tmp;
#line 1788
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 1789
    return (-12L);
  } else {

  }
#line 1791
  tmp___0 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "active_chains:\t\t\t %u\n",
                      data->active_chains);
#line 1791
  pos = tmp___0 + pos;
#line 1793
  tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_noise_a:\t\t\t %u\n",
                      data->chain_noise_a);
#line 1793
  pos = tmp___1 + pos;
#line 1795
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_noise_b:\t\t\t %u\n",
                      data->chain_noise_b);
#line 1795
  pos = tmp___2 + pos;
#line 1797
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_noise_c:\t\t\t %u\n",
                      data->chain_noise_c);
#line 1797
  pos = tmp___3 + pos;
#line 1799
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_signal_a:\t\t\t %u\n",
                      data->chain_signal_a);
#line 1799
  pos = tmp___4 + pos;
#line 1801
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_signal_b:\t\t\t %u\n",
                      data->chain_signal_b);
#line 1801
  pos = tmp___5 + pos;
#line 1803
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_signal_c:\t\t\t %u\n",
                      data->chain_signal_c);
#line 1803
  pos = tmp___6 + pos;
#line 1805
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "beacon_count:\t\t\t %u\n",
                      (int )data->beacon_count);
#line 1805
  pos = tmp___7 + pos;
#line 1808
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "disconn_array:\t\t\t");
#line 1808
  pos = tmp___8 + pos;
#line 1809
  cnt = 0;
#line 1809
  goto ldv_55538;
  ldv_55537: 
#line 1810
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), " %u", (int )data->disconn_array[cnt]);
#line 1810
  pos = tmp___9 + pos;
#line 1809
  cnt = cnt + 1;
  ldv_55538: ;
#line 1809
  if (cnt <= 2) {
#line 1811
    goto ldv_55537;
  } else {

  }
#line 1813
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\n");
#line 1813
  pos = tmp___10 + pos;
#line 1814
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "delta_gain_code:\t\t");
#line 1814
  pos = tmp___11 + pos;
#line 1815
  cnt = 0;
#line 1815
  goto ldv_55541;
  ldv_55540: 
#line 1816
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), " %u", (int )data->delta_gain_code[cnt]);
#line 1816
  pos = tmp___12 + pos;
#line 1815
  cnt = cnt + 1;
  ldv_55541: ;
#line 1815
  if (cnt <= 2) {
#line 1817
    goto ldv_55540;
  } else {

  }
#line 1819
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\n");
#line 1819
  pos = tmp___13 + pos;
#line 1820
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "radio_write:\t\t\t %u\n",
                       (int )data->radio_write);
#line 1820
  pos = tmp___14 + pos;
#line 1822
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "state:\t\t\t\t %u\n",
                       (int )data->state);
#line 1822
  pos = tmp___15 + pos;
#line 1825
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
#line 1826
  kfree((void const   *)buf);
#line 1827
  return (ret);
}
}
#line 1830 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_power_save_status_read(struct file *file , char *user_buf ,
                                                size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[60U] ;
  int pos ;
  size_t bufsz ;
  u32 pwrsave_status ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1834
  priv = (struct iwl_priv *)file->private_data;
#line 1836
  pos = 0;
#line 1837
  bufsz = 60UL;
#line 1840
  tmp = iwl_read32___2(priv->trans, 36U);
#line 1840
  pwrsave_status = tmp & 50331648U;
#line 1843
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Power Save Status: ");
#line 1843
  pos = tmp___0 + pos;
#line 1844
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "%s\n", pwrsave_status != 0U ? (pwrsave_status != 16777216U ? (pwrsave_status == 33554432U ? (char *)"PHY" : (char *)"error") : (char *)"MAC") : (char *)"none");
#line 1844
  pos = tmp___1 + pos;
#line 1850
  tmp___2 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 1850
  return (tmp___2);
}
}
#line 1853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_clear_ucode_statistics_write(struct file *file , char const   *user_buf ,
                                                      size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int clear ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 1857
  priv = (struct iwl_priv *)file->private_data;
#line 1862
  memset((void *)(& buf), 0, 8UL);
#line 1863
  _min1 = count;
#line 1863
  _min2 = 7UL;
#line 1863
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 1864
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 1864
  if (tmp != 0UL) {
#line 1865
    return (-14L);
  } else {

  }
#line 1866
  tmp___0 = sscanf((char const   *)(& buf), "%d", & clear);
#line 1866
  if (tmp___0 != 1) {
#line 1867
    return (-14L);
  } else {

  }
#line 1870
  ldv_mutex_lock_651(& priv->mutex);
#line 1871
  iwl_send_statistics_request(priv, 0, 1);
#line 1872
  ldv_mutex_unlock_652(& priv->mutex);
#line 1874
  return ((ssize_t )count);
}
}
#line 1877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_ucode_tracing_read(struct file *file , char *user_buf , size_t count ,
                                            loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[128U] ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 1881
  priv = (struct iwl_priv *)file->private_data;
#line 1882
  pos = 0;
#line 1884
  bufsz = 128UL;
#line 1886
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "ucode trace timer is %s\n", (int )priv->event_log.ucode_trace ? (char *)"On" : (char *)"Off");
#line 1886
  pos = tmp + pos;
#line 1888
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "non_wraps_count:\t\t %u\n", priv->event_log.non_wraps_count);
#line 1888
  pos = tmp___0 + pos;
#line 1890
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "wraps_once_count:\t\t %u\n", priv->event_log.wraps_once_count);
#line 1890
  pos = tmp___1 + pos;
#line 1892
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "wraps_more_count:\t\t %u\n", priv->event_log.wraps_more_count);
#line 1892
  pos = tmp___2 + pos;
#line 1895
  tmp___3 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 1895
  return (tmp___3);
}
}
#line 1898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_ucode_tracing_write(struct file *file , char const   *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int trace ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1902
  priv = (struct iwl_priv *)file->private_data;
#line 1907
  memset((void *)(& buf), 0, 8UL);
#line 1908
  _min1 = count;
#line 1908
  _min2 = 7UL;
#line 1908
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 1909
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 1909
  if (tmp != 0UL) {
#line 1910
    return (-14L);
  } else {

  }
#line 1911
  tmp___0 = sscanf((char const   *)(& buf), "%d", & trace);
#line 1911
  if (tmp___0 != 1) {
#line 1912
    return (-14L);
  } else {

  }
#line 1914
  if (trace != 0) {
#line 1915
    priv->event_log.ucode_trace = 1;
#line 1916
    tmp___1 = iwl_is_alive(priv);
#line 1916
    if (tmp___1 != 0) {
#line 1918
      ldv_mod_timer_653(& priv->ucode_trace, jiffies);
    } else {

    }
  } else {
#line 1921
    priv->event_log.ucode_trace = 0;
#line 1922
    ldv_del_timer_sync_654(& priv->ucode_trace);
  }
#line 1925
  return ((ssize_t )count);
}
}
#line 1928 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_rxon_flags_read(struct file *file , char *user_buf , size_t count ,
                                         loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int len ;
  char buf[20U] ;
  ssize_t tmp ;

  {
#line 1932
  priv = (struct iwl_priv *)file->private_data;
#line 1933
  len = 0;
#line 1936
  len = sprintf((char *)(& buf), "0x%04X\n", priv->contexts[0].active.flags);
#line 1938
  tmp = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                (size_t )len);
#line 1938
  return (tmp);
}
}
#line 1941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_rxon_filter_flags_read(struct file *file , char *user_buf ,
                                                size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int len ;
  char buf[20U] ;
  ssize_t tmp ;

  {
#line 1945
  priv = (struct iwl_priv *)file->private_data;
#line 1946
  len = 0;
#line 1949
  len = sprintf((char *)(& buf), "0x%04X\n", priv->contexts[0].active.filter_flags);
#line 1951
  tmp = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                (size_t )len);
#line 1951
  return (tmp);
}
}
#line 1954 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_missed_beacon_read(struct file *file , char *user_buf , size_t count ,
                                            loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[12U] ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 1958
  priv = (struct iwl_priv *)file->private_data;
#line 1959
  pos = 0;
#line 1961
  bufsz = 12UL;
#line 1963
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "%d\n", priv->missed_beacon_threshold);
#line 1963
  pos = tmp + pos;
#line 1966
  tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 1966
  return (tmp___0);
}
}
#line 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_missed_beacon_write(struct file *file , char const   *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int missed ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 1973
  priv = (struct iwl_priv *)file->private_data;
#line 1978
  memset((void *)(& buf), 0, 8UL);
#line 1979
  _min1 = count;
#line 1979
  _min2 = 7UL;
#line 1979
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 1980
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 1980
  if (tmp != 0UL) {
#line 1981
    return (-14L);
  } else {

  }
#line 1982
  tmp___0 = sscanf((char const   *)(& buf), "%d", & missed);
#line 1982
  if (tmp___0 != 1) {
#line 1983
    return (-22L);
  } else {

  }
#line 1985
  if (missed <= 0 || missed > 5) {
#line 1987
    priv->missed_beacon_threshold = 5;
  } else {
#line 1990
    priv->missed_beacon_threshold = missed;
  }
#line 1992
  return ((ssize_t )count);
}
}
#line 1995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_plcp_delta_read(struct file *file , char *user_buf , size_t count ,
                                         loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[12U] ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 1999
  priv = (struct iwl_priv *)file->private_data;
#line 2000
  pos = 0;
#line 2002
  bufsz = 12UL;
#line 2004
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "%u\n", (int )priv->plcp_delta_threshold);
#line 2004
  pos = tmp + pos;
#line 2007
  tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 2007
  return (tmp___0);
}
}
#line 2010 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_plcp_delta_write(struct file *file , char const   *user_buf ,
                                          size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int plcp ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 2014
  priv = (struct iwl_priv *)file->private_data;
#line 2019
  memset((void *)(& buf), 0, 8UL);
#line 2020
  _min1 = count;
#line 2020
  _min2 = 7UL;
#line 2020
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 2021
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 2021
  if (tmp != 0UL) {
#line 2022
    return (-14L);
  } else {

  }
#line 2023
  tmp___0 = sscanf((char const   *)(& buf), "%d", & plcp);
#line 2023
  if (tmp___0 != 1) {
#line 2024
    return (-22L);
  } else {

  }
#line 2025
  if (plcp <= 0 || plcp > 255) {
#line 2027
    priv->plcp_delta_threshold = 0U;
  } else {
#line 2030
    priv->plcp_delta_threshold = (u8 )plcp;
  }
#line 2031
  return ((ssize_t )count);
}
}
#line 2034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_rf_reset_read(struct file *file , char *user_buf , size_t count ,
                                       loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[300U] ;
  size_t bufsz ;
  struct iwl_rf_reset *rf_reset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 2038
  priv = (struct iwl_priv *)file->private_data;
#line 2039
  pos = 0;
#line 2041
  bufsz = 300UL;
#line 2042
  rf_reset = & priv->rf_reset;
#line 2044
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "RF reset statistics\n");
#line 2044
  pos = tmp + pos;
#line 2046
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "\tnumber of reset request: %d\n", rf_reset->reset_request_count);
#line 2046
  pos = tmp___0 + pos;
#line 2049
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "\tnumber of reset request success: %d\n", rf_reset->reset_success_count);
#line 2049
  pos = tmp___1 + pos;
#line 2052
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "\tnumber of reset request reject: %d\n", rf_reset->reset_reject_count);
#line 2052
  pos = tmp___2 + pos;
#line 2056
  tmp___3 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 2056
  return (tmp___3);
}
}
#line 2059 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_rf_reset_write(struct file *file , char const   *user_buf ,
                                        size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int ret ;

  {
#line 2063
  priv = (struct iwl_priv *)file->private_data;
#line 2066
  ret = iwl_force_rf_reset(priv, 1);
#line 2067
  return ((ssize_t )(ret != 0 ? (size_t )ret : count));
}
}
#line 2070 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_txfifo_flush_write(struct file *file , char const   *user_buf ,
                                            size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int flush ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2074
  priv = (struct iwl_priv *)file->private_data;
#line 2079
  memset((void *)(& buf), 0, 8UL);
#line 2080
  _min1 = count;
#line 2080
  _min2 = 7UL;
#line 2080
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 2081
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 2081
  if (tmp != 0UL) {
#line 2082
    return (-14L);
  } else {

  }
#line 2083
  tmp___0 = sscanf((char const   *)(& buf), "%d", & flush);
#line 2083
  if (tmp___0 != 1) {
#line 2084
    return (-22L);
  } else {

  }
#line 2086
  tmp___1 = iwl_is_rfkill(priv);
#line 2086
  if (tmp___1 != 0) {
#line 2087
    return (-14L);
  } else {

  }
#line 2089
  iwlagn_dev_txfifo_flush(priv);
#line 2091
  return ((ssize_t )count);
}
}
#line 2094 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_bt_traffic_read(struct file *file , char *user_buf , size_t count ,
                                         loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[200U] ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;

  {
#line 2098
  priv = (struct iwl_priv *)file->private_data;
#line 2099
  pos = 0;
#line 2101
  bufsz = 200UL;
#line 2103
  if ((unsigned int )priv->bt_enable_flag == 0U) {
#line 2104
    tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                    "BT coex disabled\n");
#line 2104
    pos = tmp + pos;
#line 2105
    tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                      (size_t )pos);
#line 2105
    return (tmp___0);
  } else {

  }
#line 2107
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "BT enable flag: 0x%x\n", (int )priv->bt_enable_flag);
#line 2107
  pos = tmp___1 + pos;
#line 2109
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "BT in %s mode\n", (int )priv->bt_full_concurrent ? (char *)"full concurrency" : (char *)"3-wire");
#line 2109
  pos = tmp___2 + pos;
#line 2111
  tmp___3 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "BT status: %s, last traffic notif: %d\n", (unsigned int )priv->bt_status != 0U ? (char *)"On" : (char *)"Off",
                      (int )priv->last_bt_traffic_load);
#line 2111
  pos = tmp___3 + pos;
#line 2114
  tmp___4 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "ch_announcement: %d, kill_ack_mask: %x, kill_cts_mask: %x\n",
                      (int )priv->bt_ch_announce, priv->kill_ack_mask, priv->kill_cts_mask);
#line 2114
  pos = tmp___4 + pos;
#line 2119
  tmp___5 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "bluetooth traffic load: ");
#line 2119
  pos = tmp___5 + pos;
#line 2120
  switch ((int )priv->bt_traffic_load) {
  case 3: 
#line 2122
  tmp___6 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Continuous\n");
#line 2122
  pos = tmp___6 + pos;
#line 2123
  goto ldv_55697;
  case 2: 
#line 2125
  tmp___7 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "High\n");
#line 2125
  pos = tmp___7 + pos;
#line 2126
  goto ldv_55697;
  case 1: 
#line 2128
  tmp___8 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Low\n");
#line 2128
  pos = tmp___8 + pos;
#line 2129
  goto ldv_55697;
  case 0: ;
  default: 
#line 2132
  tmp___9 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "None\n");
#line 2132
  pos = tmp___9 + pos;
#line 2133
  goto ldv_55697;
  }
  ldv_55697: 
#line 2136
  tmp___10 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                     (size_t )pos);
#line 2136
  return (tmp___10);
}
}
#line 2139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_protection_mode_read(struct file *file , char *user_buf ,
                                              size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[40U] ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 2143
  priv = (struct iwl_priv *)file->private_data;
#line 2145
  pos = 0;
#line 2147
  bufsz = 40UL;
#line 2149
  if ((unsigned long )(priv->cfg)->ht_params != (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) {
#line 2150
    tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                    "use %s for aggregation\n", (int )priv->hw_params.use_rts_for_aggregation ? (char *)"rts/cts" : (char *)"cts-to-self");
#line 2150
    pos = tmp + pos;
  } else {
#line 2155
    tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "N/A");
#line 2155
    pos = tmp___0 + pos;
  }
#line 2157
  tmp___1 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 2157
  return (tmp___1);
}
}
#line 2160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_protection_mode_write(struct file *file , char const   *user_buf ,
                                               size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int rts ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 2164
  priv = (struct iwl_priv *)file->private_data;
#line 2169
  if ((unsigned long )(priv->cfg)->ht_params == (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) {
#line 2170
    return (-22L);
  } else {

  }
#line 2172
  memset((void *)(& buf), 0, 8UL);
#line 2173
  _min1 = count;
#line 2173
  _min2 = 7UL;
#line 2173
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 2174
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 2174
  if (tmp != 0UL) {
#line 2175
    return (-14L);
  } else {

  }
#line 2176
  tmp___0 = sscanf((char const   *)(& buf), "%d", & rts);
#line 2176
  if (tmp___0 != 1) {
#line 2177
    return (-22L);
  } else {

  }
#line 2178
  if (rts != 0) {
#line 2179
    priv->hw_params.use_rts_for_aggregation = 1;
  } else {
#line 2181
    priv->hw_params.use_rts_for_aggregation = 0;
  }
#line 2182
  return ((ssize_t )count);
}
}
#line 2185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static int iwl_cmd_echo_test(struct iwl_priv *priv ) 
{ 
  int ret ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;

  {
#line 2188
  cmd.data[0] = 0;
#line 2188
  cmd.data[1] = 0;
#line 2188
  cmd.resp_pkt = 0;
#line 2188
  cmd._rx_page_addr = 0UL;
#line 2188
  cmd._rx_page_order = 0U;
#line 2188
  cmd.handler_status = 0;
#line 2188
  cmd.flags = 0U;
#line 2188
  cmd.len[0] = 0U;
#line 2188
  tmp = 1U;
#line 2188
  while (1) {
#line 2188
    if (tmp >= 2U) {
#line 2188
      break;
    } else {

    }
#line 2188
    cmd.len[tmp] = (unsigned short)0;
#line 2188
    tmp = tmp + 1U;
  }
#line 2188
  cmd.dataflags[0] = (unsigned char)0;
#line 2188
  cmd.dataflags[1] = (unsigned char)0;
#line 2188
  cmd.id = 3U;
#line 2193
  ret = iwl_dvm_send_cmd(priv, & cmd);
#line 2194
  if (ret != 0) {
#line 2195
    __iwl_err(priv->dev, 0, 0, "echo testing fail: 0X%x\n", ret);
  } else {
#line 2197
    __iwl_dbg(priv->dev, 1U, 0, "iwl_cmd_echo_test", "echo testing pass\n");
  }
#line 2198
  return (ret);
}
}
#line 2201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_echo_test_write(struct file *file , char const   *user_buf ,
                                         size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;

  {
#line 2205
  priv = (struct iwl_priv *)file->private_data;
#line 2209
  memset((void *)(& buf), 0, 8UL);
#line 2210
  _min1 = count;
#line 2210
  _min2 = 7UL;
#line 2210
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 2211
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 2211
  if (tmp != 0UL) {
#line 2212
    return (-14L);
  } else {

  }
#line 2214
  iwl_cmd_echo_test(priv);
#line 2215
  return ((ssize_t )count);
}
}
#line 2219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_log_event_read(struct file *file , char *user_buf , size_t count ,
                                        loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char *buf ;
  ssize_t ret ;
  int tmp ;

  {
#line 2223
  priv = (struct iwl_priv *)file->private_data;
#line 2224
  buf = (char *)0;
#line 2227
  tmp = iwl_dump_nic_event_log(priv, 1, & buf);
#line 2227
  ret = (ssize_t )tmp;
#line 2228
  if (ret > 0L) {
#line 2229
    ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                  (size_t )ret);
  } else {

  }
#line 2230
  kfree((void const   *)buf);
#line 2231
  return (ret);
}
}
#line 2234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_log_event_write(struct file *file , char const   *user_buf ,
                                         size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  u32 event_log_flag ;
  char buf[8U] ;
  int buf_size ;
  int tmp ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 2238
  priv = (struct iwl_priv *)file->private_data;
#line 2244
  tmp = iwl_is_ready(priv);
#line 2244
  if (tmp == 0) {
#line 2245
    return (-11L);
  } else {

  }
#line 2247
  memset((void *)(& buf), 0, 8UL);
#line 2248
  _min1 = count;
#line 2248
  _min2 = 7UL;
#line 2248
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 2249
  tmp___0 = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 2249
  if (tmp___0 != 0UL) {
#line 2250
    return (-14L);
  } else {

  }
#line 2251
  tmp___1 = sscanf((char const   *)(& buf), "%d", & event_log_flag);
#line 2251
  if (tmp___1 != 1) {
#line 2252
    return (-14L);
  } else {

  }
#line 2253
  if (event_log_flag == 1U) {
#line 2254
    iwl_dump_nic_event_log(priv, 1, (char **)0);
  } else {

  }
#line 2256
  return ((ssize_t )count);
}
}
#line 2260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_calib_disabled_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[120U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 2264
  priv = (struct iwl_priv *)file->private_data;
#line 2266
  pos = 0;
#line 2267
  bufsz = 120UL;
#line 2269
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "Sensitivity calibrations %s\n", (int )priv->calib_disabled & 1 ? (char *)"DISABLED" : (char *)"ENABLED");
#line 2269
  pos = tmp + pos;
#line 2274
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Chain noise calibrations %s\n", (priv->calib_disabled & 2U) != 0U ? (char *)"DISABLED" : (char *)"ENABLED");
#line 2274
  pos = tmp___0 + pos;
#line 2279
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Tx power calibrations %s\n", (priv->calib_disabled & 4U) != 0U ? (char *)"DISABLED" : (char *)"ENABLED");
#line 2279
  pos = tmp___1 + pos;
#line 2285
  tmp___2 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
#line 2285
  return (tmp___2);
}
}
#line 2288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_calib_disabled_write(struct file *file , char const   *user_buf ,
                                              size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  u32 calib_disabled ;
  int buf_size ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 2292
  priv = (struct iwl_priv *)file->private_data;
#line 2297
  memset((void *)(& buf), 0, 8UL);
#line 2298
  _min1 = count;
#line 2298
  _min2 = 7UL;
#line 2298
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
#line 2299
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
#line 2299
  if (tmp != 0UL) {
#line 2300
    return (-14L);
  } else {

  }
#line 2301
  tmp___0 = sscanf((char const   *)(& buf), "%x", & calib_disabled);
#line 2301
  if (tmp___0 != 1) {
#line 2302
    return (-14L);
  } else {

  }
#line 2304
  priv->calib_disabled = calib_disabled;
#line 2306
  return ((ssize_t )count);
}
}
#line 2309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static ssize_t iwl_dbgfs_fw_restart_write(struct file *file , char const   *user_buf ,
                                          size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  bool restart_fw ;
  int ret ;

  {
#line 2313
  priv = (struct iwl_priv *)file->private_data;
#line 2314
  restart_fw = iwlwifi_mod_params.restart_fw;
#line 2317
  iwlwifi_mod_params.restart_fw = 1;
#line 2319
  ldv_mutex_lock_655(& priv->mutex);
#line 2322
  ret = iwl_dvm_send_cmd_pdu(priv, 2, 0U, 0, (void const   *)0);
#line 2324
  ldv_mutex_unlock_656(& priv->mutex);
#line 2326
  iwlwifi_mod_params.restart_fw = restart_fw;
#line 2328
  return ((ssize_t )count);
}
}
#line 2331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_ucode_rx_stats_ops  = 
#line 2331
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_rx_stats_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_ucode_tx_stats_ops  = 
#line 2332
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_tx_stats_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_ucode_general_stats_ops  = 
#line 2333
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_general_stats_read, 0, 0, 0, 0, 0,
    0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_sensitivity_ops  = 
#line 2334
     {0, & generic_file_llseek, & iwl_dbgfs_sensitivity_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_chain_noise_ops  = 
#line 2335
     {0, & generic_file_llseek, & iwl_dbgfs_chain_noise_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_power_save_status_ops  = 
#line 2336
     {0, & generic_file_llseek, & iwl_dbgfs_power_save_status_read, 0, 0, 0, 0, 0, 0,
    0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_clear_ucode_statistics_ops  = 
#line 2337
     {0, & generic_file_llseek, 0, & iwl_dbgfs_clear_ucode_statistics_write, 0, 0, 0,
    0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_ucode_tracing_ops  = 
#line 2338
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_tracing_read, & iwl_dbgfs_ucode_tracing_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 2339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_missed_beacon_ops  = 
#line 2339
     {0, & generic_file_llseek, & iwl_dbgfs_missed_beacon_read, & iwl_dbgfs_missed_beacon_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 2340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_plcp_delta_ops  = 
#line 2340
     {0, & generic_file_llseek, & iwl_dbgfs_plcp_delta_read, & iwl_dbgfs_plcp_delta_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 2341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_rf_reset_ops  = 
#line 2341
     {0, & generic_file_llseek, & iwl_dbgfs_rf_reset_read, & iwl_dbgfs_rf_reset_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 2342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_rxon_flags_ops  = 
#line 2342
     {0, & generic_file_llseek, & iwl_dbgfs_rxon_flags_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_rxon_filter_flags_ops  = 
#line 2343
     {0, & generic_file_llseek, & iwl_dbgfs_rxon_filter_flags_read, 0, 0, 0, 0, 0, 0,
    0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_txfifo_flush_ops  = 
#line 2344
     {0, & generic_file_llseek, 0, & iwl_dbgfs_txfifo_flush_write, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_ucode_bt_stats_ops  = 
#line 2345
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_bt_stats_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_bt_traffic_ops  = 
#line 2346
     {0, & generic_file_llseek, & iwl_dbgfs_bt_traffic_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_protection_mode_ops  = 
#line 2347
     {0, & generic_file_llseek, & iwl_dbgfs_protection_mode_read, & iwl_dbgfs_protection_mode_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 2348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_reply_tx_error_ops  = 
#line 2348
     {0, & generic_file_llseek, & iwl_dbgfs_reply_tx_error_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_echo_test_ops  = 
#line 2349
     {0, & generic_file_llseek, 0, & iwl_dbgfs_echo_test_write, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_fw_restart_ops  = 
#line 2350
     {0, & generic_file_llseek, 0, & iwl_dbgfs_fw_restart_write, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_log_event_ops  = 
#line 2352
     {0, & generic_file_llseek, & iwl_dbgfs_log_event_read, & iwl_dbgfs_log_event_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 2354 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
static struct file_operations  const  iwl_dbgfs_calib_disabled_ops  = 
#line 2354
     {0, & generic_file_llseek, & iwl_dbgfs_calib_disabled_read, & iwl_dbgfs_calib_disabled_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 2360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.c"
int iwl_dbgfs_register(struct iwl_priv *priv , struct dentry *dbgfs_dir ) 
{ 
  struct dentry *dir_data ;
  struct dentry *dir_rf ;
  struct dentry *dir_debug ;
  struct dentry *tmp ;
  struct dentry *tmp___0 ;
  struct dentry *tmp___1 ;
  struct dentry *tmp___2 ;
  struct dentry *tmp___3 ;
  struct dentry *tmp___4 ;
  struct dentry *tmp___5 ;
  struct dentry *tmp___6 ;
  struct dentry *tmp___7 ;
  struct dentry *tmp___8 ;
  struct dentry *tmp___9 ;
  struct dentry *tmp___10 ;
  struct dentry *tmp___11 ;
  struct dentry *tmp___12 ;
  struct dentry *tmp___13 ;
  struct dentry *tmp___14 ;
  struct dentry *tmp___15 ;
  struct dentry *tmp___16 ;
  struct dentry *tmp___17 ;
  struct dentry *tmp___18 ;
  struct dentry *tmp___19 ;
  struct dentry *tmp___20 ;
  struct dentry *tmp___21 ;
  struct dentry *tmp___22 ;
  struct dentry *tmp___23 ;
  struct dentry *tmp___24 ;
  struct dentry *tmp___25 ;
  struct dentry *tmp___26 ;
  struct dentry *tmp___27 ;
  struct dentry *tmp___28 ;
  struct dentry *tmp___29 ;
  struct dentry *tmp___30 ;
  struct dentry *tmp___31 ;
  struct dentry *tmp___32 ;
  bool tmp___33 ;
  struct dentry *tmp___34 ;
  char buf[100U] ;
  struct dentry *mac80211_dir ;
  struct dentry *dev_dir ;
  struct dentry *root_dir ;
  struct dentry *tmp___35 ;

  {
#line 2364
  priv->debugfs_dir = dbgfs_dir;
#line 2366
  dir_data = debugfs_create_dir("data", dbgfs_dir);
#line 2367
  if ((unsigned long )dir_data == (unsigned long )((struct dentry *)0)) {
#line 2368
    goto err;
  } else {

  }
#line 2369
  dir_rf = debugfs_create_dir("rf", dbgfs_dir);
#line 2370
  if ((unsigned long )dir_rf == (unsigned long )((struct dentry *)0)) {
#line 2371
    goto err;
  } else {

  }
#line 2372
  dir_debug = debugfs_create_dir("debug", dbgfs_dir);
#line 2373
  if ((unsigned long )dir_debug == (unsigned long )((struct dentry *)0)) {
#line 2374
    goto err;
  } else {

  }
#line 2376
  tmp = debugfs_create_file("nvm", 256, dir_data, (void *)priv, & iwl_dbgfs_nvm_ops);
#line 2376
  if ((unsigned long )tmp == (unsigned long )((struct dentry *)0)) {
#line 2376
    goto err;
  } else {

  }
#line 2377
  tmp___0 = debugfs_create_file("sram", 384, dir_data, (void *)priv, & iwl_dbgfs_sram_ops);
#line 2377
  if ((unsigned long )tmp___0 == (unsigned long )((struct dentry *)0)) {
#line 2377
    goto err;
  } else {

  }
#line 2378
  tmp___1 = debugfs_create_file("wowlan_sram", 256, dir_data, (void *)priv, & iwl_dbgfs_wowlan_sram_ops);
#line 2378
  if ((unsigned long )tmp___1 == (unsigned long )((struct dentry *)0)) {
#line 2378
    goto err;
  } else {

  }
#line 2379
  tmp___2 = debugfs_create_file("stations", 256, dir_data, (void *)priv, & iwl_dbgfs_stations_ops);
#line 2379
  if ((unsigned long )tmp___2 == (unsigned long )((struct dentry *)0)) {
#line 2379
    goto err;
  } else {

  }
#line 2380
  tmp___3 = debugfs_create_file("channels", 256, dir_data, (void *)priv, & iwl_dbgfs_channels_ops);
#line 2380
  if ((unsigned long )tmp___3 == (unsigned long )((struct dentry *)0)) {
#line 2380
    goto err;
  } else {

  }
#line 2381
  tmp___4 = debugfs_create_file("status", 256, dir_data, (void *)priv, & iwl_dbgfs_status_ops);
#line 2381
  if ((unsigned long )tmp___4 == (unsigned long )((struct dentry *)0)) {
#line 2381
    goto err;
  } else {

  }
#line 2382
  tmp___5 = debugfs_create_file("rx_handlers", 384, dir_data, (void *)priv, & iwl_dbgfs_rx_handlers_ops);
#line 2382
  if ((unsigned long )tmp___5 == (unsigned long )((struct dentry *)0)) {
#line 2382
    goto err;
  } else {

  }
#line 2383
  tmp___6 = debugfs_create_file("qos", 256, dir_data, (void *)priv, & iwl_dbgfs_qos_ops);
#line 2383
  if ((unsigned long )tmp___6 == (unsigned long )((struct dentry *)0)) {
#line 2383
    goto err;
  } else {

  }
#line 2384
  tmp___7 = debugfs_create_file("sleep_level_override", 384, dir_data, (void *)priv,
                                & iwl_dbgfs_sleep_level_override_ops);
#line 2384
  if ((unsigned long )tmp___7 == (unsigned long )((struct dentry *)0)) {
#line 2384
    goto err;
  } else {

  }
#line 2385
  tmp___8 = debugfs_create_file("current_sleep_command", 256, dir_data, (void *)priv,
                                & iwl_dbgfs_current_sleep_command_ops);
#line 2385
  if ((unsigned long )tmp___8 == (unsigned long )((struct dentry *)0)) {
#line 2385
    goto err;
  } else {

  }
#line 2386
  tmp___9 = debugfs_create_file("thermal_throttling", 256, dir_data, (void *)priv,
                                & iwl_dbgfs_thermal_throttling_ops);
#line 2386
  if ((unsigned long )tmp___9 == (unsigned long )((struct dentry *)0)) {
#line 2386
    goto err;
  } else {

  }
#line 2387
  tmp___10 = debugfs_create_file("disable_ht40", 384, dir_data, (void *)priv, & iwl_dbgfs_disable_ht40_ops);
#line 2387
  if ((unsigned long )tmp___10 == (unsigned long )((struct dentry *)0)) {
#line 2387
    goto err;
  } else {

  }
#line 2388
  tmp___11 = debugfs_create_file("temperature", 256, dir_data, (void *)priv, & iwl_dbgfs_temperature_ops);
#line 2388
  if ((unsigned long )tmp___11 == (unsigned long )((struct dentry *)0)) {
#line 2388
    goto err;
  } else {

  }
#line 2390
  tmp___12 = debugfs_create_file("power_save_status", 256, dir_debug, (void *)priv,
                                 & iwl_dbgfs_power_save_status_ops);
#line 2390
  if ((unsigned long )tmp___12 == (unsigned long )((struct dentry *)0)) {
#line 2390
    goto err;
  } else {

  }
#line 2391
  tmp___13 = debugfs_create_file("clear_ucode_statistics", 128, dir_debug, (void *)priv,
                                 & iwl_dbgfs_clear_ucode_statistics_ops);
#line 2391
  if ((unsigned long )tmp___13 == (unsigned long )((struct dentry *)0)) {
#line 2391
    goto err;
  } else {

  }
#line 2392
  tmp___14 = debugfs_create_file("missed_beacon", 128, dir_debug, (void *)priv, & iwl_dbgfs_missed_beacon_ops);
#line 2392
  if ((unsigned long )tmp___14 == (unsigned long )((struct dentry *)0)) {
#line 2392
    goto err;
  } else {

  }
#line 2393
  tmp___15 = debugfs_create_file("plcp_delta", 384, dir_debug, (void *)priv, & iwl_dbgfs_plcp_delta_ops);
#line 2393
  if ((unsigned long )tmp___15 == (unsigned long )((struct dentry *)0)) {
#line 2393
    goto err;
  } else {

  }
#line 2394
  tmp___16 = debugfs_create_file("rf_reset", 384, dir_debug, (void *)priv, & iwl_dbgfs_rf_reset_ops);
#line 2394
  if ((unsigned long )tmp___16 == (unsigned long )((struct dentry *)0)) {
#line 2394
    goto err;
  } else {

  }
#line 2395
  tmp___17 = debugfs_create_file("ucode_rx_stats", 256, dir_debug, (void *)priv, & iwl_dbgfs_ucode_rx_stats_ops);
#line 2395
  if ((unsigned long )tmp___17 == (unsigned long )((struct dentry *)0)) {
#line 2395
    goto err;
  } else {

  }
#line 2396
  tmp___18 = debugfs_create_file("ucode_tx_stats", 256, dir_debug, (void *)priv, & iwl_dbgfs_ucode_tx_stats_ops);
#line 2396
  if ((unsigned long )tmp___18 == (unsigned long )((struct dentry *)0)) {
#line 2396
    goto err;
  } else {

  }
#line 2397
  tmp___19 = debugfs_create_file("ucode_general_stats", 256, dir_debug, (void *)priv,
                                 & iwl_dbgfs_ucode_general_stats_ops);
#line 2397
  if ((unsigned long )tmp___19 == (unsigned long )((struct dentry *)0)) {
#line 2397
    goto err;
  } else {

  }
#line 2398
  tmp___20 = debugfs_create_file("txfifo_flush", 128, dir_debug, (void *)priv, & iwl_dbgfs_txfifo_flush_ops);
#line 2398
  if ((unsigned long )tmp___20 == (unsigned long )((struct dentry *)0)) {
#line 2398
    goto err;
  } else {

  }
#line 2399
  tmp___21 = debugfs_create_file("protection_mode", 384, dir_debug, (void *)priv,
                                 & iwl_dbgfs_protection_mode_ops);
#line 2399
  if ((unsigned long )tmp___21 == (unsigned long )((struct dentry *)0)) {
#line 2399
    goto err;
  } else {

  }
#line 2400
  tmp___22 = debugfs_create_file("sensitivity", 256, dir_debug, (void *)priv, & iwl_dbgfs_sensitivity_ops);
#line 2400
  if ((unsigned long )tmp___22 == (unsigned long )((struct dentry *)0)) {
#line 2400
    goto err;
  } else {

  }
#line 2401
  tmp___23 = debugfs_create_file("chain_noise", 256, dir_debug, (void *)priv, & iwl_dbgfs_chain_noise_ops);
#line 2401
  if ((unsigned long )tmp___23 == (unsigned long )((struct dentry *)0)) {
#line 2401
    goto err;
  } else {

  }
#line 2402
  tmp___24 = debugfs_create_file("ucode_tracing", 384, dir_debug, (void *)priv, & iwl_dbgfs_ucode_tracing_ops);
#line 2402
  if ((unsigned long )tmp___24 == (unsigned long )((struct dentry *)0)) {
#line 2402
    goto err;
  } else {

  }
#line 2403
  tmp___25 = debugfs_create_file("ucode_bt_stats", 256, dir_debug, (void *)priv, & iwl_dbgfs_ucode_bt_stats_ops);
#line 2403
  if ((unsigned long )tmp___25 == (unsigned long )((struct dentry *)0)) {
#line 2403
    goto err;
  } else {

  }
#line 2404
  tmp___26 = debugfs_create_file("reply_tx_error", 256, dir_debug, (void *)priv, & iwl_dbgfs_reply_tx_error_ops);
#line 2404
  if ((unsigned long )tmp___26 == (unsigned long )((struct dentry *)0)) {
#line 2404
    goto err;
  } else {

  }
#line 2405
  tmp___27 = debugfs_create_file("rxon_flags", 128, dir_debug, (void *)priv, & iwl_dbgfs_rxon_flags_ops);
#line 2405
  if ((unsigned long )tmp___27 == (unsigned long )((struct dentry *)0)) {
#line 2405
    goto err;
  } else {

  }
#line 2406
  tmp___28 = debugfs_create_file("rxon_filter_flags", 128, dir_debug, (void *)priv,
                                 & iwl_dbgfs_rxon_filter_flags_ops);
#line 2406
  if ((unsigned long )tmp___28 == (unsigned long )((struct dentry *)0)) {
#line 2406
    goto err;
  } else {

  }
#line 2407
  tmp___29 = debugfs_create_file("echo_test", 128, dir_debug, (void *)priv, & iwl_dbgfs_echo_test_ops);
#line 2407
  if ((unsigned long )tmp___29 == (unsigned long )((struct dentry *)0)) {
#line 2407
    goto err;
  } else {

  }
#line 2408
  tmp___30 = debugfs_create_file("fw_restart", 128, dir_debug, (void *)priv, & iwl_dbgfs_fw_restart_ops);
#line 2408
  if ((unsigned long )tmp___30 == (unsigned long )((struct dentry *)0)) {
#line 2408
    goto err;
  } else {

  }
#line 2410
  tmp___31 = debugfs_create_file("log_event", 384, dir_debug, (void *)priv, & iwl_dbgfs_log_event_ops);
#line 2410
  if ((unsigned long )tmp___31 == (unsigned long )((struct dentry *)0)) {
#line 2410
    goto err;
  } else {

  }
#line 2413
  tmp___33 = iwl_advanced_bt_coexist(priv);
#line 2413
  if ((int )tmp___33) {
#line 2414
    tmp___32 = debugfs_create_file("bt_traffic", 256, dir_debug, (void *)priv, & iwl_dbgfs_bt_traffic_ops);
#line 2414
    if ((unsigned long )tmp___32 == (unsigned long )((struct dentry *)0)) {
#line 2414
      goto err;
    } else {

    }
  } else {

  }
#line 2417
  tmp___34 = debugfs_create_file("calib_disabled", 384, dir_rf, (void *)priv, & iwl_dbgfs_calib_disabled_ops);
#line 2417
  if ((unsigned long )tmp___34 == (unsigned long )((struct dentry *)0)) {
#line 2417
    goto err;
  } else {

  }
#line 2425
  if ((unsigned int )priv->mac80211_registered != 0U) {
#line 2429
    dev_dir = dbgfs_dir->d_parent;
#line 2430
    root_dir = dev_dir->d_parent;
#line 2431
    mac80211_dir = ((priv->hw)->wiphy)->debugfsdir;
#line 2433
    snprintf((char *)(& buf), 100UL, "../../%s/%s", root_dir->d_name.name, dev_dir->d_name.name);
#line 2436
    tmp___35 = debugfs_create_symlink("iwlwifi", mac80211_dir, (char const   *)(& buf));
#line 2436
    if ((unsigned long )tmp___35 == (unsigned long )((struct dentry *)0)) {
#line 2437
      goto err;
    } else {

    }
  } else {

  }
#line 2440
  return (0);
  err: 
#line 2443
  __iwl_err(priv->dev, 0, 0, "failed to create the dvm debugfs entries\n");
#line 2444
  return (-12);
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
extern int ldv_release_52(void) ;
#line 550
extern int ldv_release_43(void) ;
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_33  ;
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_2  ;
#line 553
extern int ldv_release_36(void) ;
#line 554
extern int ldv_release_44(void) ;
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_26  ;
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_0  ;
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_11  ;
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_1  ;
#line 559
extern int ldv_release_42(void) ;
#line 560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_28  ;
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_25  ;
#line 562
extern int ldv_release_53(void) ;
#line 563
extern int ldv_release_38(void) ;
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_15  ;
#line 565
extern int ldv_release_19(void) ;
#line 566
extern int ldv_release_39(void) ;
#line 567
extern int ldv_release_32(void) ;
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_24  ;
#line 569
extern int ldv_release_23(void) ;
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_32  ;
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_8  ;
#line 572
extern int ldv_release_51(void) ;
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_31  ;
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_7  ;
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_14  ;
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_17  ;
#line 577
extern int ldv_release_30(void) ;
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_34  ;
#line 579
extern int ldv_release_27(void) ;
#line 580
extern int ldv_release_50(void) ;
#line 581
extern int ldv_release_37(void) ;
#line 582
extern int ldv_release_48(void) ;
#line 583
extern int ldv_release_20(void) ;
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_18  ;
#line 585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_35  ;
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_5  ;
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_23  ;
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_22  ;
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_36  ;
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_27  ;
#line 591
extern int ldv_release_41(void) ;
#line 592
extern int ldv_release_47(void) ;
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_37  ;
#line 594
extern int ldv_release_22(void) ;
#line 595
extern int ldv_release_46(void) ;
#line 596 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_29  ;
#line 597
extern int ldv_release_40(void) ;
#line 598
extern int ldv_release_24(void) ;
#line 599
extern int ldv_release_25(void) ;
#line 600
extern int ldv_release_33(void) ;
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_38  ;
#line 602
extern int ldv_release_31(void) ;
#line 603
extern int ldv_release_29(void) ;
#line 604
extern int ldv_release_49(void) ;
#line 605
extern int ldv_release_35(void) ;
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_12  ;
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_6  ;
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_39  ;
#line 609
extern int ldv_release_28(void) ;
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_21  ;
#line 611
extern int ldv_release_26(void) ;
#line 612
extern int ldv_release_21(void) ;
#line 613 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_9  ;
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_10  ;
#line 615
extern int ldv_release_34(void) ;
#line 616
extern int ldv_release_45(void) ;
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_4  ;
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_retval_3  ;
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_20(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 622
  tmp = ldv_init_zalloc(1000UL);
#line 622
  iwl_dbgfs_log_event_ops_group1 = (struct inode *)tmp;
#line 623
  tmp___0 = ldv_init_zalloc(504UL);
#line 623
  iwl_dbgfs_log_event_ops_group2 = (struct file *)tmp___0;
#line 624
  return;
}
}
#line 627 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_26(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 628
  tmp = ldv_init_zalloc(1000UL);
#line 628
  iwl_dbgfs_ucode_bt_stats_ops_group1 = (struct inode *)tmp;
#line 629
  tmp___0 = ldv_init_zalloc(504UL);
#line 629
  iwl_dbgfs_ucode_bt_stats_ops_group2 = (struct file *)tmp___0;
#line 630
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_41(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 634
  tmp = ldv_init_zalloc(1000UL);
#line 634
  iwl_dbgfs_current_sleep_command_ops_group1 = (struct inode *)tmp;
#line 635
  tmp___0 = ldv_init_zalloc(504UL);
#line 635
  iwl_dbgfs_current_sleep_command_ops_group2 = (struct file *)tmp___0;
#line 636
  return;
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_40(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 640
  tmp = ldv_init_zalloc(1000UL);
#line 640
  iwl_dbgfs_ucode_rx_stats_ops_group1 = (struct inode *)tmp;
#line 641
  tmp___0 = ldv_init_zalloc(504UL);
#line 641
  iwl_dbgfs_ucode_rx_stats_ops_group2 = (struct file *)tmp___0;
#line 642
  return;
}
}
#line 645 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_24(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 646
  tmp = ldv_init_zalloc(1000UL);
#line 646
  iwl_dbgfs_protection_mode_ops_group1 = (struct inode *)tmp;
#line 647
  tmp___0 = ldv_init_zalloc(504UL);
#line 647
  iwl_dbgfs_protection_mode_ops_group2 = (struct file *)tmp___0;
#line 648
  return;
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_50(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 652
  tmp = ldv_init_zalloc(1000UL);
#line 652
  iwl_dbgfs_stations_ops_group1 = (struct inode *)tmp;
#line 653
  tmp___0 = ldv_init_zalloc(504UL);
#line 653
  iwl_dbgfs_stations_ops_group2 = (struct file *)tmp___0;
#line 654
  return;
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_51(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 658
  tmp = ldv_init_zalloc(1000UL);
#line 658
  iwl_dbgfs_nvm_ops_group1 = (struct inode *)tmp;
#line 659
  tmp___0 = ldv_init_zalloc(504UL);
#line 659
  iwl_dbgfs_nvm_ops_group2 = (struct file *)tmp___0;
#line 660
  return;
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_34(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 664
  tmp = ldv_init_zalloc(1000UL);
#line 664
  iwl_dbgfs_clear_ucode_statistics_ops_group1 = (struct inode *)tmp;
#line 665
  tmp___0 = ldv_init_zalloc(504UL);
#line 665
  iwl_dbgfs_clear_ucode_statistics_ops_group2 = (struct file *)tmp___0;
#line 666
  return;
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_39(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 670
  tmp = ldv_init_zalloc(1000UL);
#line 670
  iwl_dbgfs_ucode_tx_stats_ops_group1 = (struct inode *)tmp;
#line 671
  tmp___0 = ldv_init_zalloc(504UL);
#line 671
  iwl_dbgfs_ucode_tx_stats_ops_group2 = (struct file *)tmp___0;
#line 672
  return;
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_31(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 676
  tmp = ldv_init_zalloc(1000UL);
#line 676
  iwl_dbgfs_plcp_delta_ops_group1 = (struct inode *)tmp;
#line 677
  tmp___0 = ldv_init_zalloc(504UL);
#line 677
  iwl_dbgfs_plcp_delta_ops_group2 = (struct file *)tmp___0;
#line 678
  return;
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_29(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 682
  tmp = ldv_init_zalloc(1000UL);
#line 682
  iwl_dbgfs_rxon_flags_ops_group1 = (struct inode *)tmp;
#line 683
  tmp___0 = ldv_init_zalloc(504UL);
#line 683
  iwl_dbgfs_rxon_flags_ops_group2 = (struct file *)tmp___0;
#line 684
  return;
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_42(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 688
  tmp = ldv_init_zalloc(1000UL);
#line 688
  iwl_dbgfs_sleep_level_override_ops_group1 = (struct inode *)tmp;
#line 689
  tmp___0 = ldv_init_zalloc(504UL);
#line 689
  iwl_dbgfs_sleep_level_override_ops_group2 = (struct file *)tmp___0;
#line 690
  return;
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_33(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 694
  tmp = ldv_init_zalloc(1000UL);
#line 694
  iwl_dbgfs_ucode_tracing_ops_group1 = (struct inode *)tmp;
#line 695
  tmp___0 = ldv_init_zalloc(504UL);
#line 695
  iwl_dbgfs_ucode_tracing_ops_group2 = (struct file *)tmp___0;
#line 696
  return;
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_48(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 700
  tmp = ldv_init_zalloc(1000UL);
#line 700
  iwl_dbgfs_status_ops_group1 = (struct inode *)tmp;
#line 701
  tmp___0 = ldv_init_zalloc(504UL);
#line 701
  iwl_dbgfs_status_ops_group2 = (struct file *)tmp___0;
#line 702
  return;
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_30(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 706
  tmp = ldv_init_zalloc(1000UL);
#line 706
  iwl_dbgfs_rf_reset_ops_group1 = (struct inode *)tmp;
#line 707
  tmp___0 = ldv_init_zalloc(504UL);
#line 707
  iwl_dbgfs_rf_reset_ops_group2 = (struct file *)tmp___0;
#line 708
  return;
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_23(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 712
  tmp = ldv_init_zalloc(1000UL);
#line 712
  iwl_dbgfs_reply_tx_error_ops_group1 = (struct inode *)tmp;
#line 713
  tmp___0 = ldv_init_zalloc(504UL);
#line 713
  iwl_dbgfs_reply_tx_error_ops_group2 = (struct file *)tmp___0;
#line 714
  return;
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_19(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 718
  tmp = ldv_init_zalloc(1000UL);
#line 718
  iwl_dbgfs_calib_disabled_ops_group1 = (struct inode *)tmp;
#line 719
  tmp___0 = ldv_init_zalloc(504UL);
#line 719
  iwl_dbgfs_calib_disabled_ops_group2 = (struct file *)tmp___0;
#line 720
  return;
}
}
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_49(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 724
  tmp = ldv_init_zalloc(1000UL);
#line 724
  iwl_dbgfs_channels_ops_group1 = (struct inode *)tmp;
#line 725
  tmp___0 = ldv_init_zalloc(504UL);
#line 725
  iwl_dbgfs_channels_ops_group2 = (struct file *)tmp___0;
#line 726
  return;
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_32(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 730
  tmp = ldv_init_zalloc(1000UL);
#line 730
  iwl_dbgfs_missed_beacon_ops_group1 = (struct inode *)tmp;
#line 731
  tmp___0 = ldv_init_zalloc(504UL);
#line 731
  iwl_dbgfs_missed_beacon_ops_group2 = (struct file *)tmp___0;
#line 732
  return;
}
}
#line 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_25(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 736
  tmp = ldv_init_zalloc(1000UL);
#line 736
  iwl_dbgfs_bt_traffic_ops_group1 = (struct inode *)tmp;
#line 737
  tmp___0 = ldv_init_zalloc(504UL);
#line 737
  iwl_dbgfs_bt_traffic_ops_group2 = (struct file *)tmp___0;
#line 738
  return;
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_45(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 742
  tmp = ldv_init_zalloc(1000UL);
#line 742
  iwl_dbgfs_thermal_throttling_ops_group1 = (struct inode *)tmp;
#line 743
  tmp___0 = ldv_init_zalloc(504UL);
#line 743
  iwl_dbgfs_thermal_throttling_ops_group2 = (struct file *)tmp___0;
#line 744
  return;
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_28(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 748
  tmp = ldv_init_zalloc(1000UL);
#line 748
  iwl_dbgfs_rxon_filter_flags_ops_group1 = (struct inode *)tmp;
#line 749
  tmp___0 = ldv_init_zalloc(504UL);
#line 749
  iwl_dbgfs_rxon_filter_flags_ops_group2 = (struct file *)tmp___0;
#line 750
  return;
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_43(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 754
  tmp = ldv_init_zalloc(1000UL);
#line 754
  iwl_dbgfs_temperature_ops_group1 = (struct inode *)tmp;
#line 755
  tmp___0 = ldv_init_zalloc(504UL);
#line 755
  iwl_dbgfs_temperature_ops_group2 = (struct file *)tmp___0;
#line 756
  return;
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_38(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 760
  tmp = ldv_init_zalloc(1000UL);
#line 760
  iwl_dbgfs_ucode_general_stats_ops_group1 = (struct inode *)tmp;
#line 761
  tmp___0 = ldv_init_zalloc(504UL);
#line 761
  iwl_dbgfs_ucode_general_stats_ops_group2 = (struct file *)tmp___0;
#line 762
  return;
}
}
#line 765 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_22(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 766
  tmp = ldv_init_zalloc(1000UL);
#line 766
  iwl_dbgfs_echo_test_ops_group1 = (struct inode *)tmp;
#line 767
  tmp___0 = ldv_init_zalloc(504UL);
#line 767
  iwl_dbgfs_echo_test_ops_group2 = (struct file *)tmp___0;
#line 768
  return;
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_35(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 772
  tmp = ldv_init_zalloc(1000UL);
#line 772
  iwl_dbgfs_power_save_status_ops_group1 = (struct inode *)tmp;
#line 773
  tmp___0 = ldv_init_zalloc(504UL);
#line 773
  iwl_dbgfs_power_save_status_ops_group2 = (struct file *)tmp___0;
#line 774
  return;
}
}
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_46(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 778
  tmp = ldv_init_zalloc(1000UL);
#line 778
  iwl_dbgfs_qos_ops_group1 = (struct inode *)tmp;
#line 779
  tmp___0 = ldv_init_zalloc(504UL);
#line 779
  iwl_dbgfs_qos_ops_group2 = (struct file *)tmp___0;
#line 780
  return;
}
}
#line 783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_44(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 784
  tmp = ldv_init_zalloc(1000UL);
#line 784
  iwl_dbgfs_disable_ht40_ops_group1 = (struct inode *)tmp;
#line 785
  tmp___0 = ldv_init_zalloc(504UL);
#line 785
  iwl_dbgfs_disable_ht40_ops_group2 = (struct file *)tmp___0;
#line 786
  return;
}
}
#line 789 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_37(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 790
  tmp = ldv_init_zalloc(1000UL);
#line 790
  iwl_dbgfs_sensitivity_ops_group1 = (struct inode *)tmp;
#line 791
  tmp___0 = ldv_init_zalloc(504UL);
#line 791
  iwl_dbgfs_sensitivity_ops_group2 = (struct file *)tmp___0;
#line 792
  return;
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_21(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 796
  tmp = ldv_init_zalloc(1000UL);
#line 796
  iwl_dbgfs_fw_restart_ops_group1 = (struct inode *)tmp;
#line 797
  tmp___0 = ldv_init_zalloc(504UL);
#line 797
  iwl_dbgfs_fw_restart_ops_group2 = (struct file *)tmp___0;
#line 798
  return;
}
}
#line 801 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_36(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 802
  tmp = ldv_init_zalloc(1000UL);
#line 802
  iwl_dbgfs_chain_noise_ops_group1 = (struct inode *)tmp;
#line 803
  tmp___0 = ldv_init_zalloc(504UL);
#line 803
  iwl_dbgfs_chain_noise_ops_group2 = (struct file *)tmp___0;
#line 804
  return;
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_27(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 808
  tmp = ldv_init_zalloc(1000UL);
#line 808
  iwl_dbgfs_txfifo_flush_ops_group1 = (struct inode *)tmp;
#line 809
  tmp___0 = ldv_init_zalloc(504UL);
#line 809
  iwl_dbgfs_txfifo_flush_ops_group2 = (struct file *)tmp___0;
#line 810
  return;
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_52(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 814
  tmp = ldv_init_zalloc(1000UL);
#line 814
  iwl_dbgfs_wowlan_sram_ops_group1 = (struct inode *)tmp;
#line 815
  tmp___0 = ldv_init_zalloc(504UL);
#line 815
  iwl_dbgfs_wowlan_sram_ops_group2 = (struct file *)tmp___0;
#line 816
  return;
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_47(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 820
  tmp = ldv_init_zalloc(1000UL);
#line 820
  iwl_dbgfs_rx_handlers_ops_group1 = (struct inode *)tmp;
#line 821
  tmp___0 = ldv_init_zalloc(504UL);
#line 821
  iwl_dbgfs_rx_handlers_ops_group2 = (struct file *)tmp___0;
#line 822
  return;
}
}
#line 825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_file_operations_53(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 826
  tmp = ldv_init_zalloc(1000UL);
#line 826
  iwl_dbgfs_sram_ops_group1 = (struct inode *)tmp;
#line 827
  tmp___0 = ldv_init_zalloc(504UL);
#line 827
  iwl_dbgfs_sram_ops_group2 = (struct file *)tmp___0;
#line 828
  return;
}
}
#line 831 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_33(void) 
{ 
  loff_t *ldvarg2 ;
  void *tmp ;
  char *ldvarg4 ;
  void *tmp___0 ;
  loff_t ldvarg1 ;
  size_t ldvarg6 ;
  loff_t *ldvarg5 ;
  void *tmp___1 ;
  int ldvarg0 ;
  size_t ldvarg3 ;
  char *ldvarg7 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 832
  tmp = ldv_init_zalloc(8UL);
#line 832
  ldvarg2 = (loff_t *)tmp;
#line 833
  tmp___0 = ldv_init_zalloc(1UL);
#line 833
  ldvarg4 = (char *)tmp___0;
#line 836
  tmp___1 = ldv_init_zalloc(8UL);
#line 836
  ldvarg5 = (loff_t *)tmp___1;
#line 839
  tmp___2 = ldv_init_zalloc(1UL);
#line 839
  ldvarg7 = (char *)tmp___2;
#line 834
  ldv_memset((void *)(& ldvarg1), 0, 8UL);
#line 835
  ldv_memset((void *)(& ldvarg6), 0, 8UL);
#line 837
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
#line 838
  ldv_memset((void *)(& ldvarg3), 0, 8UL);
#line 841
  tmp___3 = __VERIFIER_nondet_int();
#line 841
  switch (tmp___3) {
  case 0: ;
#line 844
  if (ldv_state_variable_33 == 1) {
#line 846
    ldv_retval_0 = simple_open(iwl_dbgfs_ucode_tracing_ops_group1, iwl_dbgfs_ucode_tracing_ops_group2);
#line 847
    if (ldv_retval_0 == 0) {
#line 848
      ldv_state_variable_33 = 2;
#line 849
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 853
  goto ldv_56053;
  case 1: ;
#line 856
  if (ldv_state_variable_33 == 1) {
#line 858
    iwl_dbgfs_ucode_tracing_write(iwl_dbgfs_ucode_tracing_ops_group2, (char const   *)ldvarg7,
                                  ldvarg6, ldvarg5);
#line 860
    ldv_state_variable_33 = 1;
  } else {

  }
#line 863
  if (ldv_state_variable_33 == 2) {
#line 865
    iwl_dbgfs_ucode_tracing_write(iwl_dbgfs_ucode_tracing_ops_group2, (char const   *)ldvarg7,
                                  ldvarg6, ldvarg5);
#line 867
    ldv_state_variable_33 = 2;
  } else {

  }
#line 870
  goto ldv_56053;
  case 2: ;
#line 873
  if (ldv_state_variable_33 == 2) {
#line 875
    iwl_dbgfs_ucode_tracing_read(iwl_dbgfs_ucode_tracing_ops_group2, ldvarg4, ldvarg3,
                                 ldvarg2);
#line 877
    ldv_state_variable_33 = 2;
  } else {

  }
#line 880
  goto ldv_56053;
  case 3: ;
#line 883
  if (ldv_state_variable_33 == 2) {
#line 885
    generic_file_llseek(iwl_dbgfs_ucode_tracing_ops_group2, ldvarg1, ldvarg0);
#line 887
    ldv_state_variable_33 = 2;
  } else {

  }
#line 890
  goto ldv_56053;
  case 4: ;
#line 893
  if (ldv_state_variable_33 == 2) {
#line 895
    ldv_release_33();
#line 896
    ldv_state_variable_33 = 1;
#line 897
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 900
  goto ldv_56053;
  default: 
#line 901
  ldv_stop();
  }
  ldv_56053: ;
#line 905
  return;
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_32(void) 
{ 
  loff_t ldvarg9 ;
  loff_t *ldvarg10 ;
  void *tmp ;
  loff_t *ldvarg13 ;
  void *tmp___0 ;
  size_t ldvarg14 ;
  int ldvarg8 ;
  char *ldvarg15 ;
  void *tmp___1 ;
  char *ldvarg12 ;
  void *tmp___2 ;
  size_t ldvarg11 ;
  int tmp___3 ;

  {
#line 909
  tmp = ldv_init_zalloc(8UL);
#line 909
  ldvarg10 = (loff_t *)tmp;
#line 910
  tmp___0 = ldv_init_zalloc(8UL);
#line 910
  ldvarg13 = (loff_t *)tmp___0;
#line 913
  tmp___1 = ldv_init_zalloc(1UL);
#line 913
  ldvarg15 = (char *)tmp___1;
#line 914
  tmp___2 = ldv_init_zalloc(1UL);
#line 914
  ldvarg12 = (char *)tmp___2;
#line 908
  ldv_memset((void *)(& ldvarg9), 0, 8UL);
#line 911
  ldv_memset((void *)(& ldvarg14), 0, 8UL);
#line 912
  ldv_memset((void *)(& ldvarg8), 0, 4UL);
#line 915
  ldv_memset((void *)(& ldvarg11), 0, 8UL);
#line 917
  tmp___3 = __VERIFIER_nondet_int();
#line 917
  switch (tmp___3) {
  case 0: ;
#line 920
  if (ldv_state_variable_32 == 1) {
#line 922
    ldv_retval_1 = simple_open(iwl_dbgfs_missed_beacon_ops_group1, iwl_dbgfs_missed_beacon_ops_group2);
#line 923
    if (ldv_retval_1 == 0) {
#line 924
      ldv_state_variable_32 = 2;
#line 925
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 929
  goto ldv_56071;
  case 1: ;
#line 932
  if (ldv_state_variable_32 == 1) {
#line 934
    iwl_dbgfs_missed_beacon_write(iwl_dbgfs_missed_beacon_ops_group2, (char const   *)ldvarg15,
                                  ldvarg14, ldvarg13);
#line 936
    ldv_state_variable_32 = 1;
  } else {

  }
#line 939
  if (ldv_state_variable_32 == 2) {
#line 941
    iwl_dbgfs_missed_beacon_write(iwl_dbgfs_missed_beacon_ops_group2, (char const   *)ldvarg15,
                                  ldvarg14, ldvarg13);
#line 943
    ldv_state_variable_32 = 2;
  } else {

  }
#line 946
  goto ldv_56071;
  case 2: ;
#line 949
  if (ldv_state_variable_32 == 2) {
#line 951
    iwl_dbgfs_missed_beacon_read(iwl_dbgfs_missed_beacon_ops_group2, ldvarg12, ldvarg11,
                                 ldvarg10);
#line 953
    ldv_state_variable_32 = 2;
  } else {

  }
#line 956
  goto ldv_56071;
  case 3: ;
#line 959
  if (ldv_state_variable_32 == 2) {
#line 961
    generic_file_llseek(iwl_dbgfs_missed_beacon_ops_group2, ldvarg9, ldvarg8);
#line 963
    ldv_state_variable_32 = 2;
  } else {

  }
#line 966
  goto ldv_56071;
  case 4: ;
#line 969
  if (ldv_state_variable_32 == 2) {
#line 971
    ldv_release_32();
#line 972
    ldv_state_variable_32 = 1;
#line 973
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 976
  goto ldv_56071;
  default: 
#line 977
  ldv_stop();
  }
  ldv_56071: ;
#line 981
  return;
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_21(void) 
{ 
  int ldvarg16 ;
  size_t ldvarg19 ;
  loff_t ldvarg17 ;
  char *ldvarg20 ;
  void *tmp ;
  loff_t *ldvarg18 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 987
  tmp = ldv_init_zalloc(1UL);
#line 987
  ldvarg20 = (char *)tmp;
#line 988
  tmp___0 = ldv_init_zalloc(8UL);
#line 988
  ldvarg18 = (loff_t *)tmp___0;
#line 984
  ldv_memset((void *)(& ldvarg16), 0, 4UL);
#line 985
  ldv_memset((void *)(& ldvarg19), 0, 8UL);
#line 986
  ldv_memset((void *)(& ldvarg17), 0, 8UL);
#line 990
  tmp___1 = __VERIFIER_nondet_int();
#line 990
  switch (tmp___1) {
  case 0: ;
#line 993
  if (ldv_state_variable_21 == 1) {
#line 995
    ldv_retval_2 = simple_open(iwl_dbgfs_fw_restart_ops_group1, iwl_dbgfs_fw_restart_ops_group2);
#line 996
    if (ldv_retval_2 == 0) {
#line 997
      ldv_state_variable_21 = 2;
#line 998
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1002
  goto ldv_56086;
  case 1: ;
#line 1005
  if (ldv_state_variable_21 == 1) {
#line 1007
    iwl_dbgfs_fw_restart_write(iwl_dbgfs_fw_restart_ops_group2, (char const   *)ldvarg20,
                               ldvarg19, ldvarg18);
#line 1009
    ldv_state_variable_21 = 1;
  } else {

  }
#line 1012
  if (ldv_state_variable_21 == 2) {
#line 1014
    iwl_dbgfs_fw_restart_write(iwl_dbgfs_fw_restart_ops_group2, (char const   *)ldvarg20,
                               ldvarg19, ldvarg18);
#line 1016
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1019
  goto ldv_56086;
  case 2: ;
#line 1022
  if (ldv_state_variable_21 == 2) {
#line 1024
    generic_file_llseek(iwl_dbgfs_fw_restart_ops_group2, ldvarg17, ldvarg16);
#line 1026
    ldv_state_variable_21 = 2;
  } else {

  }
#line 1029
  goto ldv_56086;
  case 3: ;
#line 1032
  if (ldv_state_variable_21 == 2) {
#line 1034
    ldv_release_21();
#line 1035
    ldv_state_variable_21 = 1;
#line 1036
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1039
  goto ldv_56086;
  default: 
#line 1040
  ldv_stop();
  }
  ldv_56086: ;
#line 1044
  return;
}
}
#line 1046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_26(void) 
{ 
  loff_t ldvarg22 ;
  loff_t *ldvarg23 ;
  void *tmp ;
  char *ldvarg25 ;
  void *tmp___0 ;
  int ldvarg21 ;
  size_t ldvarg24 ;
  int tmp___1 ;

  {
#line 1048
  tmp = ldv_init_zalloc(8UL);
#line 1048
  ldvarg23 = (loff_t *)tmp;
#line 1049
  tmp___0 = ldv_init_zalloc(1UL);
#line 1049
  ldvarg25 = (char *)tmp___0;
#line 1047
  ldv_memset((void *)(& ldvarg22), 0, 8UL);
#line 1050
  ldv_memset((void *)(& ldvarg21), 0, 4UL);
#line 1051
  ldv_memset((void *)(& ldvarg24), 0, 8UL);
#line 1053
  tmp___1 = __VERIFIER_nondet_int();
#line 1053
  switch (tmp___1) {
  case 0: ;
#line 1056
  if (ldv_state_variable_26 == 1) {
#line 1058
    ldv_retval_3 = simple_open(iwl_dbgfs_ucode_bt_stats_ops_group1, iwl_dbgfs_ucode_bt_stats_ops_group2);
#line 1059
    if (ldv_retval_3 == 0) {
#line 1060
      ldv_state_variable_26 = 2;
#line 1061
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1065
  goto ldv_56100;
  case 1: ;
#line 1068
  if (ldv_state_variable_26 == 2) {
#line 1070
    iwl_dbgfs_ucode_bt_stats_read(iwl_dbgfs_ucode_bt_stats_ops_group2, ldvarg25, ldvarg24,
                                  ldvarg23);
#line 1072
    ldv_state_variable_26 = 2;
  } else {

  }
#line 1075
  goto ldv_56100;
  case 2: ;
#line 1078
  if (ldv_state_variable_26 == 2) {
#line 1080
    generic_file_llseek(iwl_dbgfs_ucode_bt_stats_ops_group2, ldvarg22, ldvarg21);
#line 1082
    ldv_state_variable_26 = 2;
  } else {

  }
#line 1085
  goto ldv_56100;
  case 3: ;
#line 1088
  if (ldv_state_variable_26 == 2) {
#line 1090
    ldv_release_26();
#line 1091
    ldv_state_variable_26 = 1;
#line 1092
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1095
  goto ldv_56100;
  default: 
#line 1096
  ldv_stop();
  }
  ldv_56100: ;
#line 1100
  return;
}
}
#line 1102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_30(void) 
{ 
  char *ldvarg206 ;
  void *tmp ;
  loff_t *ldvarg201 ;
  void *tmp___0 ;
  int ldvarg199 ;
  size_t ldvarg205 ;
  size_t ldvarg202 ;
  loff_t ldvarg200 ;
  char *ldvarg203 ;
  void *tmp___1 ;
  loff_t *ldvarg204 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1103
  tmp = ldv_init_zalloc(1UL);
#line 1103
  ldvarg206 = (char *)tmp;
#line 1104
  tmp___0 = ldv_init_zalloc(8UL);
#line 1104
  ldvarg201 = (loff_t *)tmp___0;
#line 1109
  tmp___1 = ldv_init_zalloc(1UL);
#line 1109
  ldvarg203 = (char *)tmp___1;
#line 1110
  tmp___2 = ldv_init_zalloc(8UL);
#line 1110
  ldvarg204 = (loff_t *)tmp___2;
#line 1105
  ldv_memset((void *)(& ldvarg199), 0, 4UL);
#line 1106
  ldv_memset((void *)(& ldvarg205), 0, 8UL);
#line 1107
  ldv_memset((void *)(& ldvarg202), 0, 8UL);
#line 1108
  ldv_memset((void *)(& ldvarg200), 0, 8UL);
#line 1112
  tmp___3 = __VERIFIER_nondet_int();
#line 1112
  switch (tmp___3) {
  case 0: ;
#line 1115
  if (ldv_state_variable_30 == 1) {
#line 1117
    ldv_retval_21 = simple_open(iwl_dbgfs_rf_reset_ops_group1, iwl_dbgfs_rf_reset_ops_group2);
#line 1118
    if (ldv_retval_21 == 0) {
#line 1119
      ldv_state_variable_30 = 2;
#line 1120
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1124
  goto ldv_56117;
  case 1: ;
#line 1127
  if (ldv_state_variable_30 == 1) {
#line 1129
    iwl_dbgfs_rf_reset_write(iwl_dbgfs_rf_reset_ops_group2, (char const   *)ldvarg206,
                             ldvarg205, ldvarg204);
#line 1131
    ldv_state_variable_30 = 1;
  } else {

  }
#line 1134
  if (ldv_state_variable_30 == 2) {
#line 1136
    iwl_dbgfs_rf_reset_write(iwl_dbgfs_rf_reset_ops_group2, (char const   *)ldvarg206,
                             ldvarg205, ldvarg204);
#line 1138
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1141
  goto ldv_56117;
  case 2: ;
#line 1144
  if (ldv_state_variable_30 == 2) {
#line 1146
    iwl_dbgfs_rf_reset_read(iwl_dbgfs_rf_reset_ops_group2, ldvarg203, ldvarg202, ldvarg201);
#line 1148
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1151
  goto ldv_56117;
  case 3: ;
#line 1154
  if (ldv_state_variable_30 == 2) {
#line 1156
    generic_file_llseek(iwl_dbgfs_rf_reset_ops_group2, ldvarg200, ldvarg199);
#line 1158
    ldv_state_variable_30 = 2;
  } else {

  }
#line 1161
  goto ldv_56117;
  case 4: ;
#line 1164
  if (ldv_state_variable_30 == 2) {
#line 1166
    ldv_release_30();
#line 1167
    ldv_state_variable_30 = 1;
#line 1168
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1171
  goto ldv_56117;
  default: 
#line 1172
  ldv_stop();
  }
  ldv_56117: ;
#line 1176
  return;
}
}
#line 1178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_44(void) 
{ 
  loff_t *ldvarg28 ;
  void *tmp ;
  size_t ldvarg29 ;
  char *ldvarg30 ;
  void *tmp___0 ;
  char *ldvarg33 ;
  void *tmp___1 ;
  loff_t *ldvarg31 ;
  void *tmp___2 ;
  size_t ldvarg32 ;
  int ldvarg26 ;
  loff_t ldvarg27 ;
  int tmp___3 ;

  {
#line 1179
  tmp = ldv_init_zalloc(8UL);
#line 1179
  ldvarg28 = (loff_t *)tmp;
#line 1181
  tmp___0 = ldv_init_zalloc(1UL);
#line 1181
  ldvarg30 = (char *)tmp___0;
#line 1182
  tmp___1 = ldv_init_zalloc(1UL);
#line 1182
  ldvarg33 = (char *)tmp___1;
#line 1183
  tmp___2 = ldv_init_zalloc(8UL);
#line 1183
  ldvarg31 = (loff_t *)tmp___2;
#line 1180
  ldv_memset((void *)(& ldvarg29), 0, 8UL);
#line 1184
  ldv_memset((void *)(& ldvarg32), 0, 8UL);
#line 1185
  ldv_memset((void *)(& ldvarg26), 0, 4UL);
#line 1186
  ldv_memset((void *)(& ldvarg27), 0, 8UL);
#line 1188
  tmp___3 = __VERIFIER_nondet_int();
#line 1188
  switch (tmp___3) {
  case 0: ;
#line 1191
  if (ldv_state_variable_44 == 1) {
#line 1193
    ldv_retval_4 = simple_open(iwl_dbgfs_disable_ht40_ops_group1, iwl_dbgfs_disable_ht40_ops_group2);
#line 1194
    if (ldv_retval_4 == 0) {
#line 1195
      ldv_state_variable_44 = 2;
#line 1196
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1200
  goto ldv_56135;
  case 1: ;
#line 1203
  if (ldv_state_variable_44 == 1) {
#line 1205
    iwl_dbgfs_disable_ht40_write(iwl_dbgfs_disable_ht40_ops_group2, (char const   *)ldvarg33,
                                 ldvarg32, ldvarg31);
#line 1207
    ldv_state_variable_44 = 1;
  } else {

  }
#line 1210
  if (ldv_state_variable_44 == 2) {
#line 1212
    iwl_dbgfs_disable_ht40_write(iwl_dbgfs_disable_ht40_ops_group2, (char const   *)ldvarg33,
                                 ldvarg32, ldvarg31);
#line 1214
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1217
  goto ldv_56135;
  case 2: ;
#line 1220
  if (ldv_state_variable_44 == 2) {
#line 1222
    iwl_dbgfs_disable_ht40_read(iwl_dbgfs_disable_ht40_ops_group2, ldvarg30, ldvarg29,
                                ldvarg28);
#line 1224
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1227
  goto ldv_56135;
  case 3: ;
#line 1230
  if (ldv_state_variable_44 == 2) {
#line 1232
    generic_file_llseek(iwl_dbgfs_disable_ht40_ops_group2, ldvarg27, ldvarg26);
#line 1234
    ldv_state_variable_44 = 2;
  } else {

  }
#line 1237
  goto ldv_56135;
  case 4: ;
#line 1240
  if (ldv_state_variable_44 == 2) {
#line 1242
    ldv_release_44();
#line 1243
    ldv_state_variable_44 = 1;
#line 1244
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1247
  goto ldv_56135;
  default: 
#line 1248
  ldv_stop();
  }
  ldv_56135: ;
#line 1252
  return;
}
}
#line 1254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_25(void) 
{ 
  size_t ldvarg210 ;
  int ldvarg207 ;
  loff_t ldvarg208 ;
  char *ldvarg211 ;
  void *tmp ;
  loff_t *ldvarg209 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1258
  tmp = ldv_init_zalloc(1UL);
#line 1258
  ldvarg211 = (char *)tmp;
#line 1259
  tmp___0 = ldv_init_zalloc(8UL);
#line 1259
  ldvarg209 = (loff_t *)tmp___0;
#line 1255
  ldv_memset((void *)(& ldvarg210), 0, 8UL);
#line 1256
  ldv_memset((void *)(& ldvarg207), 0, 4UL);
#line 1257
  ldv_memset((void *)(& ldvarg208), 0, 8UL);
#line 1261
  tmp___1 = __VERIFIER_nondet_int();
#line 1261
  switch (tmp___1) {
  case 0: ;
#line 1264
  if (ldv_state_variable_25 == 1) {
#line 1266
    ldv_retval_22 = simple_open(iwl_dbgfs_bt_traffic_ops_group1, iwl_dbgfs_bt_traffic_ops_group2);
#line 1267
    if (ldv_retval_22 == 0) {
#line 1268
      ldv_state_variable_25 = 2;
#line 1269
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1273
  goto ldv_56150;
  case 1: ;
#line 1276
  if (ldv_state_variable_25 == 2) {
#line 1278
    iwl_dbgfs_bt_traffic_read(iwl_dbgfs_bt_traffic_ops_group2, ldvarg211, ldvarg210,
                              ldvarg209);
#line 1280
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1283
  goto ldv_56150;
  case 2: ;
#line 1286
  if (ldv_state_variable_25 == 2) {
#line 1288
    generic_file_llseek(iwl_dbgfs_bt_traffic_ops_group2, ldvarg208, ldvarg207);
#line 1290
    ldv_state_variable_25 = 2;
  } else {

  }
#line 1293
  goto ldv_56150;
  case 3: ;
#line 1296
  if (ldv_state_variable_25 == 2) {
#line 1298
    ldv_release_25();
#line 1299
    ldv_state_variable_25 = 1;
#line 1300
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1303
  goto ldv_56150;
  default: 
#line 1304
  ldv_stop();
  }
  ldv_56150: ;
#line 1308
  return;
}
}
#line 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_27(void) 
{ 
  size_t ldvarg38 ;
  loff_t ldvarg36 ;
  int ldvarg35 ;
  loff_t *ldvarg37 ;
  void *tmp ;
  char *ldvarg39 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1314
  tmp = ldv_init_zalloc(8UL);
#line 1314
  ldvarg37 = (loff_t *)tmp;
#line 1315
  tmp___0 = ldv_init_zalloc(1UL);
#line 1315
  ldvarg39 = (char *)tmp___0;
#line 1311
  ldv_memset((void *)(& ldvarg38), 0, 8UL);
#line 1312
  ldv_memset((void *)(& ldvarg36), 0, 8UL);
#line 1313
  ldv_memset((void *)(& ldvarg35), 0, 4UL);
#line 1317
  tmp___1 = __VERIFIER_nondet_int();
#line 1317
  switch (tmp___1) {
  case 0: ;
#line 1320
  if (ldv_state_variable_27 == 1) {
#line 1322
    ldv_retval_5 = simple_open(iwl_dbgfs_txfifo_flush_ops_group1, iwl_dbgfs_txfifo_flush_ops_group2);
#line 1323
    if (ldv_retval_5 == 0) {
#line 1324
      ldv_state_variable_27 = 2;
#line 1325
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1329
  goto ldv_56164;
  case 1: ;
#line 1332
  if (ldv_state_variable_27 == 1) {
#line 1334
    iwl_dbgfs_txfifo_flush_write(iwl_dbgfs_txfifo_flush_ops_group2, (char const   *)ldvarg39,
                                 ldvarg38, ldvarg37);
#line 1336
    ldv_state_variable_27 = 1;
  } else {

  }
#line 1339
  if (ldv_state_variable_27 == 2) {
#line 1341
    iwl_dbgfs_txfifo_flush_write(iwl_dbgfs_txfifo_flush_ops_group2, (char const   *)ldvarg39,
                                 ldvarg38, ldvarg37);
#line 1343
    ldv_state_variable_27 = 2;
  } else {

  }
#line 1346
  goto ldv_56164;
  case 2: ;
#line 1349
  if (ldv_state_variable_27 == 2) {
#line 1351
    generic_file_llseek(iwl_dbgfs_txfifo_flush_ops_group2, ldvarg36, ldvarg35);
#line 1353
    ldv_state_variable_27 = 2;
  } else {

  }
#line 1356
  goto ldv_56164;
  case 3: ;
#line 1359
  if (ldv_state_variable_27 == 2) {
#line 1361
    ldv_release_27();
#line 1362
    ldv_state_variable_27 = 1;
#line 1363
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1366
  goto ldv_56164;
  default: 
#line 1367
  ldv_stop();
  }
  ldv_56164: ;
#line 1371
  return;
}
}
#line 1373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_28(void) 
{ 
  char *ldvarg216 ;
  void *tmp ;
  int ldvarg212 ;
  loff_t *ldvarg214 ;
  void *tmp___0 ;
  size_t ldvarg215 ;
  loff_t ldvarg213 ;
  int tmp___1 ;

  {
#line 1374
  tmp = ldv_init_zalloc(1UL);
#line 1374
  ldvarg216 = (char *)tmp;
#line 1376
  tmp___0 = ldv_init_zalloc(8UL);
#line 1376
  ldvarg214 = (loff_t *)tmp___0;
#line 1375
  ldv_memset((void *)(& ldvarg212), 0, 4UL);
#line 1377
  ldv_memset((void *)(& ldvarg215), 0, 8UL);
#line 1378
  ldv_memset((void *)(& ldvarg213), 0, 8UL);
#line 1380
  tmp___1 = __VERIFIER_nondet_int();
#line 1380
  switch (tmp___1) {
  case 0: ;
#line 1383
  if (ldv_state_variable_28 == 1) {
#line 1385
    ldv_retval_23 = simple_open(iwl_dbgfs_rxon_filter_flags_ops_group1, iwl_dbgfs_rxon_filter_flags_ops_group2);
#line 1386
    if (ldv_retval_23 == 0) {
#line 1387
      ldv_state_variable_28 = 2;
#line 1388
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1392
  goto ldv_56178;
  case 1: ;
#line 1395
  if (ldv_state_variable_28 == 2) {
#line 1397
    iwl_dbgfs_rxon_filter_flags_read(iwl_dbgfs_rxon_filter_flags_ops_group2, ldvarg216,
                                     ldvarg215, ldvarg214);
#line 1399
    ldv_state_variable_28 = 2;
  } else {

  }
#line 1402
  goto ldv_56178;
  case 2: ;
#line 1405
  if (ldv_state_variable_28 == 2) {
#line 1407
    generic_file_llseek(iwl_dbgfs_rxon_filter_flags_ops_group2, ldvarg213, ldvarg212);
#line 1409
    ldv_state_variable_28 = 2;
  } else {

  }
#line 1412
  goto ldv_56178;
  case 3: ;
#line 1415
  if (ldv_state_variable_28 == 2) {
#line 1417
    ldv_release_28();
#line 1418
    ldv_state_variable_28 = 1;
#line 1419
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1422
  goto ldv_56178;
  default: 
#line 1423
  ldv_stop();
  }
  ldv_56178: ;
#line 1427
  return;
}
}
#line 1429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_40(void) 
{ 
  loff_t *ldvarg219 ;
  void *tmp ;
  char *ldvarg221 ;
  void *tmp___0 ;
  int ldvarg217 ;
  loff_t ldvarg218 ;
  size_t ldvarg220 ;
  int tmp___1 ;

  {
#line 1430
  tmp = ldv_init_zalloc(8UL);
#line 1430
  ldvarg219 = (loff_t *)tmp;
#line 1431
  tmp___0 = ldv_init_zalloc(1UL);
#line 1431
  ldvarg221 = (char *)tmp___0;
#line 1432
  ldv_memset((void *)(& ldvarg217), 0, 4UL);
#line 1433
  ldv_memset((void *)(& ldvarg218), 0, 8UL);
#line 1434
  ldv_memset((void *)(& ldvarg220), 0, 8UL);
#line 1436
  tmp___1 = __VERIFIER_nondet_int();
#line 1436
  switch (tmp___1) {
  case 0: ;
#line 1439
  if (ldv_state_variable_40 == 1) {
#line 1441
    ldv_retval_24 = simple_open(iwl_dbgfs_ucode_rx_stats_ops_group1, iwl_dbgfs_ucode_rx_stats_ops_group2);
#line 1442
    if (ldv_retval_24 == 0) {
#line 1443
      ldv_state_variable_40 = 2;
#line 1444
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1448
  goto ldv_56192;
  case 1: ;
#line 1451
  if (ldv_state_variable_40 == 2) {
#line 1453
    iwl_dbgfs_ucode_rx_stats_read(iwl_dbgfs_ucode_rx_stats_ops_group2, ldvarg221,
                                  ldvarg220, ldvarg219);
#line 1455
    ldv_state_variable_40 = 2;
  } else {

  }
#line 1458
  goto ldv_56192;
  case 2: ;
#line 1461
  if (ldv_state_variable_40 == 2) {
#line 1463
    generic_file_llseek(iwl_dbgfs_ucode_rx_stats_ops_group2, ldvarg218, ldvarg217);
#line 1465
    ldv_state_variable_40 = 2;
  } else {

  }
#line 1468
  goto ldv_56192;
  case 3: ;
#line 1471
  if (ldv_state_variable_40 == 2) {
#line 1473
    ldv_release_40();
#line 1474
    ldv_state_variable_40 = 1;
#line 1475
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1478
  goto ldv_56192;
  default: 
#line 1479
  ldv_stop();
  }
  ldv_56192: ;
#line 1483
  return;
}
}
#line 1485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_20(void) 
{ 
  size_t ldvarg47 ;
  size_t ldvarg44 ;
  char *ldvarg48 ;
  void *tmp ;
  loff_t *ldvarg46 ;
  void *tmp___0 ;
  loff_t ldvarg42 ;
  loff_t *ldvarg43 ;
  void *tmp___1 ;
  int ldvarg41 ;
  char *ldvarg45 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1488
  tmp = ldv_init_zalloc(1UL);
#line 1488
  ldvarg48 = (char *)tmp;
#line 1489
  tmp___0 = ldv_init_zalloc(8UL);
#line 1489
  ldvarg46 = (loff_t *)tmp___0;
#line 1491
  tmp___1 = ldv_init_zalloc(8UL);
#line 1491
  ldvarg43 = (loff_t *)tmp___1;
#line 1493
  tmp___2 = ldv_init_zalloc(1UL);
#line 1493
  ldvarg45 = (char *)tmp___2;
#line 1486
  ldv_memset((void *)(& ldvarg47), 0, 8UL);
#line 1487
  ldv_memset((void *)(& ldvarg44), 0, 8UL);
#line 1490
  ldv_memset((void *)(& ldvarg42), 0, 8UL);
#line 1492
  ldv_memset((void *)(& ldvarg41), 0, 4UL);
#line 1495
  tmp___3 = __VERIFIER_nondet_int();
#line 1495
  switch (tmp___3) {
  case 0: ;
#line 1498
  if (ldv_state_variable_20 == 1) {
#line 1500
    ldv_retval_6 = simple_open(iwl_dbgfs_log_event_ops_group1, iwl_dbgfs_log_event_ops_group2);
#line 1501
    if (ldv_retval_6 == 0) {
#line 1502
      ldv_state_variable_20 = 2;
#line 1503
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1507
  goto ldv_56209;
  case 1: ;
#line 1510
  if (ldv_state_variable_20 == 1) {
#line 1512
    iwl_dbgfs_log_event_write(iwl_dbgfs_log_event_ops_group2, (char const   *)ldvarg48,
                              ldvarg47, ldvarg46);
#line 1514
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1517
  if (ldv_state_variable_20 == 2) {
#line 1519
    iwl_dbgfs_log_event_write(iwl_dbgfs_log_event_ops_group2, (char const   *)ldvarg48,
                              ldvarg47, ldvarg46);
#line 1521
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1524
  goto ldv_56209;
  case 2: ;
#line 1527
  if (ldv_state_variable_20 == 2) {
#line 1529
    iwl_dbgfs_log_event_read(iwl_dbgfs_log_event_ops_group2, ldvarg45, ldvarg44, ldvarg43);
#line 1531
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1534
  goto ldv_56209;
  case 3: ;
#line 1537
  if (ldv_state_variable_20 == 2) {
#line 1539
    generic_file_llseek(iwl_dbgfs_log_event_ops_group2, ldvarg42, ldvarg41);
#line 1541
    ldv_state_variable_20 = 2;
  } else {

  }
#line 1544
  goto ldv_56209;
  case 4: ;
#line 1547
  if (ldv_state_variable_20 == 2) {
#line 1549
    ldv_release_20();
#line 1550
    ldv_state_variable_20 = 1;
#line 1551
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1554
  goto ldv_56209;
  default: 
#line 1555
  ldv_stop();
  }
  ldv_56209: ;
#line 1559
  return;
}
}
#line 1561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_49(void) 
{ 
  loff_t *ldvarg239 ;
  void *tmp ;
  char *ldvarg241 ;
  void *tmp___0 ;
  size_t ldvarg240 ;
  int ldvarg237 ;
  loff_t ldvarg238 ;
  int tmp___1 ;

  {
#line 1562
  tmp = ldv_init_zalloc(8UL);
#line 1562
  ldvarg239 = (loff_t *)tmp;
#line 1563
  tmp___0 = ldv_init_zalloc(1UL);
#line 1563
  ldvarg241 = (char *)tmp___0;
#line 1564
  ldv_memset((void *)(& ldvarg240), 0, 8UL);
#line 1565
  ldv_memset((void *)(& ldvarg237), 0, 4UL);
#line 1566
  ldv_memset((void *)(& ldvarg238), 0, 8UL);
#line 1568
  tmp___1 = __VERIFIER_nondet_int();
#line 1568
  switch (tmp___1) {
  case 0: ;
#line 1571
  if (ldv_state_variable_49 == 1) {
#line 1573
    ldv_retval_25 = simple_open(iwl_dbgfs_channels_ops_group1, iwl_dbgfs_channels_ops_group2);
#line 1574
    if (ldv_retval_25 == 0) {
#line 1575
      ldv_state_variable_49 = 2;
#line 1576
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1580
  goto ldv_56224;
  case 1: ;
#line 1583
  if (ldv_state_variable_49 == 2) {
#line 1585
    iwl_dbgfs_channels_read(iwl_dbgfs_channels_ops_group2, ldvarg241, ldvarg240, ldvarg239);
#line 1587
    ldv_state_variable_49 = 2;
  } else {

  }
#line 1590
  goto ldv_56224;
  case 2: ;
#line 1593
  if (ldv_state_variable_49 == 2) {
#line 1595
    generic_file_llseek(iwl_dbgfs_channels_ops_group2, ldvarg238, ldvarg237);
#line 1597
    ldv_state_variable_49 = 2;
  } else {

  }
#line 1600
  goto ldv_56224;
  case 3: ;
#line 1603
  if (ldv_state_variable_49 == 2) {
#line 1605
    ldv_release_49();
#line 1606
    ldv_state_variable_49 = 1;
#line 1607
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1610
  goto ldv_56224;
  default: 
#line 1611
  ldv_stop();
  }
  ldv_56224: ;
#line 1615
  return;
}
}
#line 1617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_24(void) 
{ 
  size_t ldvarg245 ;
  loff_t ldvarg243 ;
  size_t ldvarg248 ;
  char *ldvarg249 ;
  void *tmp ;
  loff_t *ldvarg244 ;
  void *tmp___0 ;
  loff_t *ldvarg247 ;
  void *tmp___1 ;
  char *ldvarg246 ;
  void *tmp___2 ;
  int ldvarg242 ;
  int tmp___3 ;

  {
#line 1621
  tmp = ldv_init_zalloc(1UL);
#line 1621
  ldvarg249 = (char *)tmp;
#line 1622
  tmp___0 = ldv_init_zalloc(8UL);
#line 1622
  ldvarg244 = (loff_t *)tmp___0;
#line 1623
  tmp___1 = ldv_init_zalloc(8UL);
#line 1623
  ldvarg247 = (loff_t *)tmp___1;
#line 1624
  tmp___2 = ldv_init_zalloc(1UL);
#line 1624
  ldvarg246 = (char *)tmp___2;
#line 1618
  ldv_memset((void *)(& ldvarg245), 0, 8UL);
#line 1619
  ldv_memset((void *)(& ldvarg243), 0, 8UL);
#line 1620
  ldv_memset((void *)(& ldvarg248), 0, 8UL);
#line 1625
  ldv_memset((void *)(& ldvarg242), 0, 4UL);
#line 1627
  tmp___3 = __VERIFIER_nondet_int();
#line 1627
  switch (tmp___3) {
  case 0: ;
#line 1630
  if (ldv_state_variable_24 == 1) {
#line 1632
    ldv_retval_26 = simple_open(iwl_dbgfs_protection_mode_ops_group1, iwl_dbgfs_protection_mode_ops_group2);
#line 1633
    if (ldv_retval_26 == 0) {
#line 1634
      ldv_state_variable_24 = 2;
#line 1635
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1639
  goto ldv_56241;
  case 1: ;
#line 1642
  if (ldv_state_variable_24 == 1) {
#line 1644
    iwl_dbgfs_protection_mode_write(iwl_dbgfs_protection_mode_ops_group2, (char const   *)ldvarg249,
                                    ldvarg248, ldvarg247);
#line 1646
    ldv_state_variable_24 = 1;
  } else {

  }
#line 1649
  if (ldv_state_variable_24 == 2) {
#line 1651
    iwl_dbgfs_protection_mode_write(iwl_dbgfs_protection_mode_ops_group2, (char const   *)ldvarg249,
                                    ldvarg248, ldvarg247);
#line 1653
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1656
  goto ldv_56241;
  case 2: ;
#line 1659
  if (ldv_state_variable_24 == 2) {
#line 1661
    iwl_dbgfs_protection_mode_read(iwl_dbgfs_protection_mode_ops_group2, ldvarg246,
                                   ldvarg245, ldvarg244);
#line 1663
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1666
  goto ldv_56241;
  case 3: ;
#line 1669
  if (ldv_state_variable_24 == 2) {
#line 1671
    generic_file_llseek(iwl_dbgfs_protection_mode_ops_group2, ldvarg243, ldvarg242);
#line 1673
    ldv_state_variable_24 = 2;
  } else {

  }
#line 1676
  goto ldv_56241;
  case 4: ;
#line 1679
  if (ldv_state_variable_24 == 2) {
#line 1681
    ldv_release_24();
#line 1682
    ldv_state_variable_24 = 1;
#line 1683
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1686
  goto ldv_56241;
  default: 
#line 1687
  ldv_stop();
  }
  ldv_56241: ;
#line 1691
  return;
}
}
#line 1693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_31(void) 
{ 
  size_t ldvarg52 ;
  size_t ldvarg55 ;
  char *ldvarg53 ;
  void *tmp ;
  loff_t *ldvarg54 ;
  void *tmp___0 ;
  loff_t ldvarg50 ;
  int ldvarg49 ;
  char *ldvarg56 ;
  void *tmp___1 ;
  loff_t *ldvarg51 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1696
  tmp = ldv_init_zalloc(1UL);
#line 1696
  ldvarg53 = (char *)tmp;
#line 1697
  tmp___0 = ldv_init_zalloc(8UL);
#line 1697
  ldvarg54 = (loff_t *)tmp___0;
#line 1700
  tmp___1 = ldv_init_zalloc(1UL);
#line 1700
  ldvarg56 = (char *)tmp___1;
#line 1701
  tmp___2 = ldv_init_zalloc(8UL);
#line 1701
  ldvarg51 = (loff_t *)tmp___2;
#line 1694
  ldv_memset((void *)(& ldvarg52), 0, 8UL);
#line 1695
  ldv_memset((void *)(& ldvarg55), 0, 8UL);
#line 1698
  ldv_memset((void *)(& ldvarg50), 0, 8UL);
#line 1699
  ldv_memset((void *)(& ldvarg49), 0, 4UL);
#line 1703
  tmp___3 = __VERIFIER_nondet_int();
#line 1703
  switch (tmp___3) {
  case 0: ;
#line 1706
  if (ldv_state_variable_31 == 1) {
#line 1708
    ldv_retval_7 = simple_open(iwl_dbgfs_plcp_delta_ops_group1, iwl_dbgfs_plcp_delta_ops_group2);
#line 1709
    if (ldv_retval_7 == 0) {
#line 1710
      ldv_state_variable_31 = 2;
#line 1711
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1715
  goto ldv_56259;
  case 1: ;
#line 1718
  if (ldv_state_variable_31 == 1) {
#line 1720
    iwl_dbgfs_plcp_delta_write(iwl_dbgfs_plcp_delta_ops_group2, (char const   *)ldvarg56,
                               ldvarg55, ldvarg54);
#line 1722
    ldv_state_variable_31 = 1;
  } else {

  }
#line 1725
  if (ldv_state_variable_31 == 2) {
#line 1727
    iwl_dbgfs_plcp_delta_write(iwl_dbgfs_plcp_delta_ops_group2, (char const   *)ldvarg56,
                               ldvarg55, ldvarg54);
#line 1729
    ldv_state_variable_31 = 2;
  } else {

  }
#line 1732
  goto ldv_56259;
  case 2: ;
#line 1735
  if (ldv_state_variable_31 == 2) {
#line 1737
    iwl_dbgfs_plcp_delta_read(iwl_dbgfs_plcp_delta_ops_group2, ldvarg53, ldvarg52,
                              ldvarg51);
#line 1739
    ldv_state_variable_31 = 2;
  } else {

  }
#line 1742
  goto ldv_56259;
  case 3: ;
#line 1745
  if (ldv_state_variable_31 == 2) {
#line 1747
    generic_file_llseek(iwl_dbgfs_plcp_delta_ops_group2, ldvarg50, ldvarg49);
#line 1749
    ldv_state_variable_31 = 2;
  } else {

  }
#line 1752
  goto ldv_56259;
  case 4: ;
#line 1755
  if (ldv_state_variable_31 == 2) {
#line 1757
    ldv_release_31();
#line 1758
    ldv_state_variable_31 = 1;
#line 1759
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1762
  goto ldv_56259;
  default: 
#line 1763
  ldv_stop();
  }
  ldv_56259: ;
#line 1767
  return;
}
}
#line 1769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_35(void) 
{ 
  loff_t *ldvarg59 ;
  void *tmp ;
  size_t ldvarg60 ;
  char *ldvarg61 ;
  void *tmp___0 ;
  loff_t ldvarg58 ;
  int ldvarg57 ;
  int tmp___1 ;

  {
#line 1770
  tmp = ldv_init_zalloc(8UL);
#line 1770
  ldvarg59 = (loff_t *)tmp;
#line 1772
  tmp___0 = ldv_init_zalloc(1UL);
#line 1772
  ldvarg61 = (char *)tmp___0;
#line 1771
  ldv_memset((void *)(& ldvarg60), 0, 8UL);
#line 1773
  ldv_memset((void *)(& ldvarg58), 0, 8UL);
#line 1774
  ldv_memset((void *)(& ldvarg57), 0, 4UL);
#line 1776
  tmp___1 = __VERIFIER_nondet_int();
#line 1776
  switch (tmp___1) {
  case 0: ;
#line 1779
  if (ldv_state_variable_35 == 1) {
#line 1781
    ldv_retval_8 = simple_open(iwl_dbgfs_power_save_status_ops_group1, iwl_dbgfs_power_save_status_ops_group2);
#line 1782
    if (ldv_retval_8 == 0) {
#line 1783
      ldv_state_variable_35 = 2;
#line 1784
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1788
  goto ldv_56274;
  case 1: ;
#line 1791
  if (ldv_state_variable_35 == 2) {
#line 1793
    iwl_dbgfs_power_save_status_read(iwl_dbgfs_power_save_status_ops_group2, ldvarg61,
                                     ldvarg60, ldvarg59);
#line 1795
    ldv_state_variable_35 = 2;
  } else {

  }
#line 1798
  goto ldv_56274;
  case 2: ;
#line 1801
  if (ldv_state_variable_35 == 2) {
#line 1803
    generic_file_llseek(iwl_dbgfs_power_save_status_ops_group2, ldvarg58, ldvarg57);
#line 1805
    ldv_state_variable_35 = 2;
  } else {

  }
#line 1808
  goto ldv_56274;
  case 3: ;
#line 1811
  if (ldv_state_variable_35 == 2) {
#line 1813
    ldv_release_35();
#line 1814
    ldv_state_variable_35 = 1;
#line 1815
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1818
  goto ldv_56274;
  default: 
#line 1819
  ldv_stop();
  }
  ldv_56274: ;
#line 1823
  return;
}
}
#line 1825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_53(void) 
{ 
  loff_t *ldvarg255 ;
  void *tmp ;
  size_t ldvarg253 ;
  char *ldvarg254 ;
  void *tmp___0 ;
  int ldvarg250 ;
  loff_t ldvarg251 ;
  char *ldvarg257 ;
  void *tmp___1 ;
  loff_t *ldvarg252 ;
  void *tmp___2 ;
  size_t ldvarg256 ;
  int tmp___3 ;

  {
#line 1826
  tmp = ldv_init_zalloc(8UL);
#line 1826
  ldvarg255 = (loff_t *)tmp;
#line 1828
  tmp___0 = ldv_init_zalloc(1UL);
#line 1828
  ldvarg254 = (char *)tmp___0;
#line 1831
  tmp___1 = ldv_init_zalloc(1UL);
#line 1831
  ldvarg257 = (char *)tmp___1;
#line 1832
  tmp___2 = ldv_init_zalloc(8UL);
#line 1832
  ldvarg252 = (loff_t *)tmp___2;
#line 1827
  ldv_memset((void *)(& ldvarg253), 0, 8UL);
#line 1829
  ldv_memset((void *)(& ldvarg250), 0, 4UL);
#line 1830
  ldv_memset((void *)(& ldvarg251), 0, 8UL);
#line 1833
  ldv_memset((void *)(& ldvarg256), 0, 8UL);
#line 1835
  tmp___3 = __VERIFIER_nondet_int();
#line 1835
  switch (tmp___3) {
  case 0: ;
#line 1838
  if (ldv_state_variable_53 == 1) {
#line 1840
    ldv_retval_27 = simple_open(iwl_dbgfs_sram_ops_group1, iwl_dbgfs_sram_ops_group2);
#line 1841
    if (ldv_retval_27 == 0) {
#line 1842
      ldv_state_variable_53 = 2;
#line 1843
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1847
  goto ldv_56291;
  case 1: ;
#line 1850
  if (ldv_state_variable_53 == 1) {
#line 1852
    iwl_dbgfs_sram_write(iwl_dbgfs_sram_ops_group2, (char const   *)ldvarg257, ldvarg256,
                         ldvarg255);
#line 1854
    ldv_state_variable_53 = 1;
  } else {

  }
#line 1857
  if (ldv_state_variable_53 == 2) {
#line 1859
    iwl_dbgfs_sram_write(iwl_dbgfs_sram_ops_group2, (char const   *)ldvarg257, ldvarg256,
                         ldvarg255);
#line 1861
    ldv_state_variable_53 = 2;
  } else {

  }
#line 1864
  goto ldv_56291;
  case 2: ;
#line 1867
  if (ldv_state_variable_53 == 2) {
#line 1869
    iwl_dbgfs_sram_read(iwl_dbgfs_sram_ops_group2, ldvarg254, ldvarg253, ldvarg252);
#line 1871
    ldv_state_variable_53 = 2;
  } else {

  }
#line 1874
  goto ldv_56291;
  case 3: ;
#line 1877
  if (ldv_state_variable_53 == 2) {
#line 1879
    generic_file_llseek(iwl_dbgfs_sram_ops_group2, ldvarg251, ldvarg250);
#line 1881
    ldv_state_variable_53 = 2;
  } else {

  }
#line 1884
  goto ldv_56291;
  case 4: ;
#line 1887
  if (ldv_state_variable_53 == 2) {
#line 1889
    ldv_release_53();
#line 1890
    ldv_state_variable_53 = 1;
#line 1891
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1894
  goto ldv_56291;
  default: 
#line 1895
  ldv_stop();
  }
  ldv_56291: ;
#line 1899
  return;
}
}
#line 1901 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_48(void) 
{ 
  int ldvarg62 ;
  loff_t *ldvarg64 ;
  void *tmp ;
  char *ldvarg66 ;
  void *tmp___0 ;
  loff_t ldvarg63 ;
  size_t ldvarg65 ;
  int tmp___1 ;

  {
#line 1903
  tmp = ldv_init_zalloc(8UL);
#line 1903
  ldvarg64 = (loff_t *)tmp;
#line 1904
  tmp___0 = ldv_init_zalloc(1UL);
#line 1904
  ldvarg66 = (char *)tmp___0;
#line 1902
  ldv_memset((void *)(& ldvarg62), 0, 4UL);
#line 1905
  ldv_memset((void *)(& ldvarg63), 0, 8UL);
#line 1906
  ldv_memset((void *)(& ldvarg65), 0, 8UL);
#line 1908
  tmp___1 = __VERIFIER_nondet_int();
#line 1908
  switch (tmp___1) {
  case 0: ;
#line 1911
  if (ldv_state_variable_48 == 1) {
#line 1913
    ldv_retval_9 = simple_open(iwl_dbgfs_status_ops_group1, iwl_dbgfs_status_ops_group2);
#line 1914
    if (ldv_retval_9 == 0) {
#line 1915
      ldv_state_variable_48 = 2;
#line 1916
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1920
  goto ldv_56306;
  case 1: ;
#line 1923
  if (ldv_state_variable_48 == 2) {
#line 1925
    iwl_dbgfs_status_read(iwl_dbgfs_status_ops_group2, ldvarg66, ldvarg65, ldvarg64);
#line 1927
    ldv_state_variable_48 = 2;
  } else {

  }
#line 1930
  goto ldv_56306;
  case 2: ;
#line 1933
  if (ldv_state_variable_48 == 2) {
#line 1935
    generic_file_llseek(iwl_dbgfs_status_ops_group2, ldvarg63, ldvarg62);
#line 1937
    ldv_state_variable_48 = 2;
  } else {

  }
#line 1940
  goto ldv_56306;
  case 3: ;
#line 1943
  if (ldv_state_variable_48 == 2) {
#line 1945
    ldv_release_48();
#line 1946
    ldv_state_variable_48 = 1;
#line 1947
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1950
  goto ldv_56306;
  default: 
#line 1951
  ldv_stop();
  }
  ldv_56306: ;
#line 1955
  return;
}
}
#line 1957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_22(void) 
{ 
  loff_t *ldvarg260 ;
  void *tmp ;
  size_t ldvarg261 ;
  int ldvarg258 ;
  char *ldvarg262 ;
  void *tmp___0 ;
  loff_t ldvarg259 ;
  int tmp___1 ;

  {
#line 1958
  tmp = ldv_init_zalloc(8UL);
#line 1958
  ldvarg260 = (loff_t *)tmp;
#line 1961
  tmp___0 = ldv_init_zalloc(1UL);
#line 1961
  ldvarg262 = (char *)tmp___0;
#line 1959
  ldv_memset((void *)(& ldvarg261), 0, 8UL);
#line 1960
  ldv_memset((void *)(& ldvarg258), 0, 4UL);
#line 1962
  ldv_memset((void *)(& ldvarg259), 0, 8UL);
#line 1964
  tmp___1 = __VERIFIER_nondet_int();
#line 1964
  switch (tmp___1) {
  case 0: ;
#line 1967
  if (ldv_state_variable_22 == 1) {
#line 1969
    ldv_retval_28 = simple_open(iwl_dbgfs_echo_test_ops_group1, iwl_dbgfs_echo_test_ops_group2);
#line 1970
    if (ldv_retval_28 == 0) {
#line 1971
      ldv_state_variable_22 = 2;
#line 1972
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1976
  goto ldv_56320;
  case 1: ;
#line 1979
  if (ldv_state_variable_22 == 1) {
#line 1981
    iwl_dbgfs_echo_test_write(iwl_dbgfs_echo_test_ops_group2, (char const   *)ldvarg262,
                              ldvarg261, ldvarg260);
#line 1983
    ldv_state_variable_22 = 1;
  } else {

  }
#line 1986
  if (ldv_state_variable_22 == 2) {
#line 1988
    iwl_dbgfs_echo_test_write(iwl_dbgfs_echo_test_ops_group2, (char const   *)ldvarg262,
                              ldvarg261, ldvarg260);
#line 1990
    ldv_state_variable_22 = 2;
  } else {

  }
#line 1993
  goto ldv_56320;
  case 2: ;
#line 1996
  if (ldv_state_variable_22 == 2) {
#line 1998
    generic_file_llseek(iwl_dbgfs_echo_test_ops_group2, ldvarg259, ldvarg258);
#line 2000
    ldv_state_variable_22 = 2;
  } else {

  }
#line 2003
  goto ldv_56320;
  case 3: ;
#line 2006
  if (ldv_state_variable_22 == 2) {
#line 2008
    ldv_release_22();
#line 2009
    ldv_state_variable_22 = 1;
#line 2010
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2013
  goto ldv_56320;
  default: 
#line 2014
  ldv_stop();
  }
  ldv_56320: ;
#line 2018
  return;
}
}
#line 2020 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_42(void) 
{ 
  char *ldvarg267 ;
  void *tmp ;
  int ldvarg263 ;
  size_t ldvarg266 ;
  loff_t *ldvarg265 ;
  void *tmp___0 ;
  char *ldvarg270 ;
  void *tmp___1 ;
  loff_t *ldvarg268 ;
  void *tmp___2 ;
  size_t ldvarg269 ;
  loff_t ldvarg264 ;
  int tmp___3 ;

  {
#line 2021
  tmp = ldv_init_zalloc(1UL);
#line 2021
  ldvarg267 = (char *)tmp;
#line 2024
  tmp___0 = ldv_init_zalloc(8UL);
#line 2024
  ldvarg265 = (loff_t *)tmp___0;
#line 2025
  tmp___1 = ldv_init_zalloc(1UL);
#line 2025
  ldvarg270 = (char *)tmp___1;
#line 2026
  tmp___2 = ldv_init_zalloc(8UL);
#line 2026
  ldvarg268 = (loff_t *)tmp___2;
#line 2022
  ldv_memset((void *)(& ldvarg263), 0, 4UL);
#line 2023
  ldv_memset((void *)(& ldvarg266), 0, 8UL);
#line 2027
  ldv_memset((void *)(& ldvarg269), 0, 8UL);
#line 2028
  ldv_memset((void *)(& ldvarg264), 0, 8UL);
#line 2030
  tmp___3 = __VERIFIER_nondet_int();
#line 2030
  switch (tmp___3) {
  case 0: ;
#line 2033
  if (ldv_state_variable_42 == 1) {
#line 2035
    ldv_retval_29 = simple_open(iwl_dbgfs_sleep_level_override_ops_group1, iwl_dbgfs_sleep_level_override_ops_group2);
#line 2036
    if (ldv_retval_29 == 0) {
#line 2037
      ldv_state_variable_42 = 2;
#line 2038
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2042
  goto ldv_56337;
  case 1: ;
#line 2045
  if (ldv_state_variable_42 == 1) {
#line 2047
    iwl_dbgfs_sleep_level_override_write(iwl_dbgfs_sleep_level_override_ops_group2,
                                         (char const   *)ldvarg270, ldvarg269, ldvarg268);
#line 2049
    ldv_state_variable_42 = 1;
  } else {

  }
#line 2052
  if (ldv_state_variable_42 == 2) {
#line 2054
    iwl_dbgfs_sleep_level_override_write(iwl_dbgfs_sleep_level_override_ops_group2,
                                         (char const   *)ldvarg270, ldvarg269, ldvarg268);
#line 2056
    ldv_state_variable_42 = 2;
  } else {

  }
#line 2059
  goto ldv_56337;
  case 2: ;
#line 2062
  if (ldv_state_variable_42 == 2) {
#line 2064
    iwl_dbgfs_sleep_level_override_read(iwl_dbgfs_sleep_level_override_ops_group2,
                                        ldvarg267, ldvarg266, ldvarg265);
#line 2066
    ldv_state_variable_42 = 2;
  } else {

  }
#line 2069
  goto ldv_56337;
  case 3: ;
#line 2072
  if (ldv_state_variable_42 == 2) {
#line 2074
    generic_file_llseek(iwl_dbgfs_sleep_level_override_ops_group2, ldvarg264, ldvarg263);
#line 2076
    ldv_state_variable_42 = 2;
  } else {

  }
#line 2079
  goto ldv_56337;
  case 4: ;
#line 2082
  if (ldv_state_variable_42 == 2) {
#line 2084
    ldv_release_42();
#line 2085
    ldv_state_variable_42 = 1;
#line 2086
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2089
  goto ldv_56337;
  default: 
#line 2090
  ldv_stop();
  }
  ldv_56337: ;
#line 2094
  return;
}
}
#line 2096 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_46(void) 
{ 
  size_t ldvarg274 ;
  loff_t *ldvarg273 ;
  void *tmp ;
  char *ldvarg275 ;
  void *tmp___0 ;
  int ldvarg271 ;
  loff_t ldvarg272 ;
  int tmp___1 ;

  {
#line 2098
  tmp = ldv_init_zalloc(8UL);
#line 2098
  ldvarg273 = (loff_t *)tmp;
#line 2099
  tmp___0 = ldv_init_zalloc(1UL);
#line 2099
  ldvarg275 = (char *)tmp___0;
#line 2097
  ldv_memset((void *)(& ldvarg274), 0, 8UL);
#line 2100
  ldv_memset((void *)(& ldvarg271), 0, 4UL);
#line 2101
  ldv_memset((void *)(& ldvarg272), 0, 8UL);
#line 2103
  tmp___1 = __VERIFIER_nondet_int();
#line 2103
  switch (tmp___1) {
  case 0: ;
#line 2106
  if (ldv_state_variable_46 == 1) {
#line 2108
    ldv_retval_31 = simple_open(iwl_dbgfs_qos_ops_group1, iwl_dbgfs_qos_ops_group2);
#line 2109
    if (ldv_retval_31 == 0) {
#line 2110
      ldv_state_variable_46 = 2;
#line 2111
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2115
  goto ldv_56352;
  case 1: ;
#line 2118
  if (ldv_state_variable_46 == 2) {
#line 2120
    iwl_dbgfs_qos_read(iwl_dbgfs_qos_ops_group2, ldvarg275, ldvarg274, ldvarg273);
#line 2122
    ldv_state_variable_46 = 2;
  } else {

  }
#line 2125
  goto ldv_56352;
  case 2: ;
#line 2128
  if (ldv_state_variable_46 == 2) {
#line 2130
    generic_file_llseek(iwl_dbgfs_qos_ops_group2, ldvarg272, ldvarg271);
#line 2132
    ldv_state_variable_46 = 2;
  } else {

  }
#line 2135
  goto ldv_56352;
  case 3: ;
#line 2138
  if (ldv_state_variable_46 == 2) {
#line 2140
    ldv_release_46();
#line 2141
    ldv_state_variable_46 = 1;
#line 2142
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2145
  goto ldv_56352;
  default: 
#line 2146
  ldv_stop();
  }
  ldv_56352: ;
#line 2150
  return;
}
}
#line 2152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_23(void) 
{ 
  int ldvarg276 ;
  size_t ldvarg279 ;
  loff_t ldvarg277 ;
  char *ldvarg280 ;
  void *tmp ;
  loff_t *ldvarg278 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2156
  tmp = ldv_init_zalloc(1UL);
#line 2156
  ldvarg280 = (char *)tmp;
#line 2157
  tmp___0 = ldv_init_zalloc(8UL);
#line 2157
  ldvarg278 = (loff_t *)tmp___0;
#line 2153
  ldv_memset((void *)(& ldvarg276), 0, 4UL);
#line 2154
  ldv_memset((void *)(& ldvarg279), 0, 8UL);
#line 2155
  ldv_memset((void *)(& ldvarg277), 0, 8UL);
#line 2159
  tmp___1 = __VERIFIER_nondet_int();
#line 2159
  switch (tmp___1) {
  case 0: ;
#line 2162
  if (ldv_state_variable_23 == 1) {
#line 2164
    ldv_retval_32 = simple_open(iwl_dbgfs_reply_tx_error_ops_group1, iwl_dbgfs_reply_tx_error_ops_group2);
#line 2165
    if (ldv_retval_32 == 0) {
#line 2166
      ldv_state_variable_23 = 2;
#line 2167
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2171
  goto ldv_56366;
  case 1: ;
#line 2174
  if (ldv_state_variable_23 == 2) {
#line 2176
    iwl_dbgfs_reply_tx_error_read(iwl_dbgfs_reply_tx_error_ops_group2, ldvarg280,
                                  ldvarg279, ldvarg278);
#line 2178
    ldv_state_variable_23 = 2;
  } else {

  }
#line 2181
  goto ldv_56366;
  case 2: ;
#line 2184
  if (ldv_state_variable_23 == 2) {
#line 2186
    generic_file_llseek(iwl_dbgfs_reply_tx_error_ops_group2, ldvarg277, ldvarg276);
#line 2188
    ldv_state_variable_23 = 2;
  } else {

  }
#line 2191
  goto ldv_56366;
  case 3: ;
#line 2194
  if (ldv_state_variable_23 == 2) {
#line 2196
    ldv_release_23();
#line 2197
    ldv_state_variable_23 = 1;
#line 2198
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2201
  goto ldv_56366;
  default: 
#line 2202
  ldv_stop();
  }
  ldv_56366: ;
#line 2206
  return;
}
}
#line 2208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_29(void) 
{ 
  int ldvarg86 ;
  loff_t ldvarg87 ;
  char *ldvarg90 ;
  void *tmp ;
  size_t ldvarg89 ;
  loff_t *ldvarg88 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2211
  tmp = ldv_init_zalloc(1UL);
#line 2211
  ldvarg90 = (char *)tmp;
#line 2213
  tmp___0 = ldv_init_zalloc(8UL);
#line 2213
  ldvarg88 = (loff_t *)tmp___0;
#line 2209
  ldv_memset((void *)(& ldvarg86), 0, 4UL);
#line 2210
  ldv_memset((void *)(& ldvarg87), 0, 8UL);
#line 2212
  ldv_memset((void *)(& ldvarg89), 0, 8UL);
#line 2215
  tmp___1 = __VERIFIER_nondet_int();
#line 2215
  switch (tmp___1) {
  case 0: ;
#line 2218
  if (ldv_state_variable_29 == 1) {
#line 2220
    ldv_retval_10 = simple_open(iwl_dbgfs_rxon_flags_ops_group1, iwl_dbgfs_rxon_flags_ops_group2);
#line 2221
    if (ldv_retval_10 == 0) {
#line 2222
      ldv_state_variable_29 = 2;
#line 2223
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2227
  goto ldv_56380;
  case 1: ;
#line 2230
  if (ldv_state_variable_29 == 2) {
#line 2232
    iwl_dbgfs_rxon_flags_read(iwl_dbgfs_rxon_flags_ops_group2, ldvarg90, ldvarg89,
                              ldvarg88);
#line 2234
    ldv_state_variable_29 = 2;
  } else {

  }
#line 2237
  goto ldv_56380;
  case 2: ;
#line 2240
  if (ldv_state_variable_29 == 2) {
#line 2242
    generic_file_llseek(iwl_dbgfs_rxon_flags_ops_group2, ldvarg87, ldvarg86);
#line 2244
    ldv_state_variable_29 = 2;
  } else {

  }
#line 2247
  goto ldv_56380;
  case 3: ;
#line 2250
  if (ldv_state_variable_29 == 2) {
#line 2252
    ldv_release_29();
#line 2253
    ldv_state_variable_29 = 1;
#line 2254
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2257
  goto ldv_56380;
  default: 
#line 2258
  ldv_stop();
  }
  ldv_56380: ;
#line 2262
  return;
}
}
#line 2264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_50(void) 
{ 
  loff_t ldvarg92 ;
  int ldvarg91 ;
  size_t ldvarg94 ;
  char *ldvarg95 ;
  void *tmp ;
  loff_t *ldvarg93 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2268
  tmp = ldv_init_zalloc(1UL);
#line 2268
  ldvarg95 = (char *)tmp;
#line 2269
  tmp___0 = ldv_init_zalloc(8UL);
#line 2269
  ldvarg93 = (loff_t *)tmp___0;
#line 2265
  ldv_memset((void *)(& ldvarg92), 0, 8UL);
#line 2266
  ldv_memset((void *)(& ldvarg91), 0, 4UL);
#line 2267
  ldv_memset((void *)(& ldvarg94), 0, 8UL);
#line 2271
  tmp___1 = __VERIFIER_nondet_int();
#line 2271
  switch (tmp___1) {
  case 0: ;
#line 2274
  if (ldv_state_variable_50 == 1) {
#line 2276
    ldv_retval_11 = simple_open(iwl_dbgfs_stations_ops_group1, iwl_dbgfs_stations_ops_group2);
#line 2277
    if (ldv_retval_11 == 0) {
#line 2278
      ldv_state_variable_50 = 2;
#line 2279
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2283
  goto ldv_56394;
  case 1: ;
#line 2286
  if (ldv_state_variable_50 == 2) {
#line 2288
    iwl_dbgfs_stations_read(iwl_dbgfs_stations_ops_group2, ldvarg95, ldvarg94, ldvarg93);
#line 2290
    ldv_state_variable_50 = 2;
  } else {

  }
#line 2293
  goto ldv_56394;
  case 2: ;
#line 2296
  if (ldv_state_variable_50 == 2) {
#line 2298
    generic_file_llseek(iwl_dbgfs_stations_ops_group2, ldvarg92, ldvarg91);
#line 2300
    ldv_state_variable_50 = 2;
  } else {

  }
#line 2303
  goto ldv_56394;
  case 3: ;
#line 2306
  if (ldv_state_variable_50 == 2) {
#line 2308
    ldv_release_50();
#line 2309
    ldv_state_variable_50 = 1;
#line 2310
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2313
  goto ldv_56394;
  default: 
#line 2314
  ldv_stop();
  }
  ldv_56394: ;
#line 2318
  return;
}
}
#line 2320 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_39(void) 
{ 
  size_t ldvarg99 ;
  int ldvarg96 ;
  char *ldvarg100 ;
  void *tmp ;
  loff_t ldvarg97 ;
  loff_t *ldvarg98 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2323
  tmp = ldv_init_zalloc(1UL);
#line 2323
  ldvarg100 = (char *)tmp;
#line 2325
  tmp___0 = ldv_init_zalloc(8UL);
#line 2325
  ldvarg98 = (loff_t *)tmp___0;
#line 2321
  ldv_memset((void *)(& ldvarg99), 0, 8UL);
#line 2322
  ldv_memset((void *)(& ldvarg96), 0, 4UL);
#line 2324
  ldv_memset((void *)(& ldvarg97), 0, 8UL);
#line 2327
  tmp___1 = __VERIFIER_nondet_int();
#line 2327
  switch (tmp___1) {
  case 0: ;
#line 2330
  if (ldv_state_variable_39 == 1) {
#line 2332
    ldv_retval_12 = simple_open(iwl_dbgfs_ucode_tx_stats_ops_group1, iwl_dbgfs_ucode_tx_stats_ops_group2);
#line 2333
    if (ldv_retval_12 == 0) {
#line 2334
      ldv_state_variable_39 = 2;
#line 2335
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2339
  goto ldv_56408;
  case 1: ;
#line 2342
  if (ldv_state_variable_39 == 2) {
#line 2344
    iwl_dbgfs_ucode_tx_stats_read(iwl_dbgfs_ucode_tx_stats_ops_group2, ldvarg100,
                                  ldvarg99, ldvarg98);
#line 2346
    ldv_state_variable_39 = 2;
  } else {

  }
#line 2349
  goto ldv_56408;
  case 2: ;
#line 2352
  if (ldv_state_variable_39 == 2) {
#line 2354
    generic_file_llseek(iwl_dbgfs_ucode_tx_stats_ops_group2, ldvarg97, ldvarg96);
#line 2356
    ldv_state_variable_39 = 2;
  } else {

  }
#line 2359
  goto ldv_56408;
  case 3: ;
#line 2362
  if (ldv_state_variable_39 == 2) {
#line 2364
    ldv_release_39();
#line 2365
    ldv_state_variable_39 = 1;
#line 2366
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2369
  goto ldv_56408;
  default: 
#line 2370
  ldv_stop();
  }
  ldv_56408: ;
#line 2374
  return;
}
}
#line 2376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_36(void) 
{ 
  int ldvarg281 ;
  loff_t *ldvarg283 ;
  void *tmp ;
  loff_t ldvarg282 ;
  size_t ldvarg284 ;
  char *ldvarg285 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2378
  tmp = ldv_init_zalloc(8UL);
#line 2378
  ldvarg283 = (loff_t *)tmp;
#line 2381
  tmp___0 = ldv_init_zalloc(1UL);
#line 2381
  ldvarg285 = (char *)tmp___0;
#line 2377
  ldv_memset((void *)(& ldvarg281), 0, 4UL);
#line 2379
  ldv_memset((void *)(& ldvarg282), 0, 8UL);
#line 2380
  ldv_memset((void *)(& ldvarg284), 0, 8UL);
#line 2383
  tmp___1 = __VERIFIER_nondet_int();
#line 2383
  switch (tmp___1) {
  case 0: ;
#line 2386
  if (ldv_state_variable_36 == 1) {
#line 2388
    ldv_retval_33 = simple_open(iwl_dbgfs_chain_noise_ops_group1, iwl_dbgfs_chain_noise_ops_group2);
#line 2389
    if (ldv_retval_33 == 0) {
#line 2390
      ldv_state_variable_36 = 2;
#line 2391
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2395
  goto ldv_56422;
  case 1: ;
#line 2398
  if (ldv_state_variable_36 == 2) {
#line 2400
    iwl_dbgfs_chain_noise_read(iwl_dbgfs_chain_noise_ops_group2, ldvarg285, ldvarg284,
                               ldvarg283);
#line 2402
    ldv_state_variable_36 = 2;
  } else {

  }
#line 2405
  goto ldv_56422;
  case 2: ;
#line 2408
  if (ldv_state_variable_36 == 2) {
#line 2410
    generic_file_llseek(iwl_dbgfs_chain_noise_ops_group2, ldvarg282, ldvarg281);
#line 2412
    ldv_state_variable_36 = 2;
  } else {

  }
#line 2415
  goto ldv_56422;
  case 3: ;
#line 2418
  if (ldv_state_variable_36 == 2) {
#line 2420
    ldv_release_36();
#line 2421
    ldv_state_variable_36 = 1;
#line 2422
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2425
  goto ldv_56422;
  default: 
#line 2426
  ldv_stop();
  }
  ldv_56422: ;
#line 2430
  return;
}
}
#line 2432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_51(void) 
{ 
  size_t ldvarg289 ;
  int ldvarg286 ;
  loff_t ldvarg287 ;
  loff_t *ldvarg288 ;
  void *tmp ;
  char *ldvarg290 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2436
  tmp = ldv_init_zalloc(8UL);
#line 2436
  ldvarg288 = (loff_t *)tmp;
#line 2437
  tmp___0 = ldv_init_zalloc(1UL);
#line 2437
  ldvarg290 = (char *)tmp___0;
#line 2433
  ldv_memset((void *)(& ldvarg289), 0, 8UL);
#line 2434
  ldv_memset((void *)(& ldvarg286), 0, 4UL);
#line 2435
  ldv_memset((void *)(& ldvarg287), 0, 8UL);
#line 2439
  tmp___1 = __VERIFIER_nondet_int();
#line 2439
  switch (tmp___1) {
  case 0: ;
#line 2442
  if (ldv_state_variable_51 == 1) {
#line 2444
    ldv_retval_34 = simple_open(iwl_dbgfs_nvm_ops_group1, iwl_dbgfs_nvm_ops_group2);
#line 2445
    if (ldv_retval_34 == 0) {
#line 2446
      ldv_state_variable_51 = 2;
#line 2447
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2451
  goto ldv_56436;
  case 1: ;
#line 2454
  if (ldv_state_variable_51 == 2) {
#line 2456
    iwl_dbgfs_nvm_read(iwl_dbgfs_nvm_ops_group2, ldvarg290, ldvarg289, ldvarg288);
#line 2458
    ldv_state_variable_51 = 2;
  } else {

  }
#line 2461
  goto ldv_56436;
  case 2: ;
#line 2464
  if (ldv_state_variable_51 == 2) {
#line 2466
    generic_file_llseek(iwl_dbgfs_nvm_ops_group2, ldvarg287, ldvarg286);
#line 2468
    ldv_state_variable_51 = 2;
  } else {

  }
#line 2471
  goto ldv_56436;
  case 3: ;
#line 2474
  if (ldv_state_variable_51 == 2) {
#line 2476
    ldv_release_51();
#line 2477
    ldv_state_variable_51 = 1;
#line 2478
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2481
  goto ldv_56436;
  default: 
#line 2482
  ldv_stop();
  }
  ldv_56436: ;
#line 2486
  return;
}
}
#line 2488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_41(void) 
{ 
  loff_t *ldvarg158 ;
  void *tmp ;
  char *ldvarg160 ;
  void *tmp___0 ;
  loff_t ldvarg157 ;
  size_t ldvarg159 ;
  int ldvarg156 ;
  int tmp___1 ;

  {
#line 2489
  tmp = ldv_init_zalloc(8UL);
#line 2489
  ldvarg158 = (loff_t *)tmp;
#line 2490
  tmp___0 = ldv_init_zalloc(1UL);
#line 2490
  ldvarg160 = (char *)tmp___0;
#line 2491
  ldv_memset((void *)(& ldvarg157), 0, 8UL);
#line 2492
  ldv_memset((void *)(& ldvarg159), 0, 8UL);
#line 2493
  ldv_memset((void *)(& ldvarg156), 0, 4UL);
#line 2495
  tmp___1 = __VERIFIER_nondet_int();
#line 2495
  switch (tmp___1) {
  case 0: ;
#line 2498
  if (ldv_state_variable_41 == 1) {
#line 2500
    ldv_retval_14 = simple_open(iwl_dbgfs_current_sleep_command_ops_group1, iwl_dbgfs_current_sleep_command_ops_group2);
#line 2501
    if (ldv_retval_14 == 0) {
#line 2502
      ldv_state_variable_41 = 2;
#line 2503
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2507
  goto ldv_56450;
  case 1: ;
#line 2510
  if (ldv_state_variable_41 == 2) {
#line 2512
    iwl_dbgfs_current_sleep_command_read(iwl_dbgfs_current_sleep_command_ops_group2,
                                         ldvarg160, ldvarg159, ldvarg158);
#line 2514
    ldv_state_variable_41 = 2;
  } else {

  }
#line 2517
  goto ldv_56450;
  case 2: ;
#line 2520
  if (ldv_state_variable_41 == 2) {
#line 2522
    generic_file_llseek(iwl_dbgfs_current_sleep_command_ops_group2, ldvarg157, ldvarg156);
#line 2524
    ldv_state_variable_41 = 2;
  } else {

  }
#line 2527
  goto ldv_56450;
  case 3: ;
#line 2530
  if (ldv_state_variable_41 == 2) {
#line 2532
    ldv_release_41();
#line 2533
    ldv_state_variable_41 = 1;
#line 2534
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2537
  goto ldv_56450;
  default: 
#line 2538
  ldv_stop();
  }
  ldv_56450: ;
#line 2542
  return;
}
}
#line 2544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_47(void) 
{ 
  size_t ldvarg294 ;
  char *ldvarg298 ;
  void *tmp ;
  loff_t ldvarg292 ;
  int ldvarg291 ;
  size_t ldvarg297 ;
  loff_t *ldvarg293 ;
  void *tmp___0 ;
  loff_t *ldvarg296 ;
  void *tmp___1 ;
  char *ldvarg295 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 2546
  tmp = ldv_init_zalloc(1UL);
#line 2546
  ldvarg298 = (char *)tmp;
#line 2550
  tmp___0 = ldv_init_zalloc(8UL);
#line 2550
  ldvarg293 = (loff_t *)tmp___0;
#line 2551
  tmp___1 = ldv_init_zalloc(8UL);
#line 2551
  ldvarg296 = (loff_t *)tmp___1;
#line 2552
  tmp___2 = ldv_init_zalloc(1UL);
#line 2552
  ldvarg295 = (char *)tmp___2;
#line 2545
  ldv_memset((void *)(& ldvarg294), 0, 8UL);
#line 2547
  ldv_memset((void *)(& ldvarg292), 0, 8UL);
#line 2548
  ldv_memset((void *)(& ldvarg291), 0, 4UL);
#line 2549
  ldv_memset((void *)(& ldvarg297), 0, 8UL);
#line 2554
  tmp___3 = __VERIFIER_nondet_int();
#line 2554
  switch (tmp___3) {
  case 0: ;
#line 2557
  if (ldv_state_variable_47 == 1) {
#line 2559
    ldv_retval_35 = simple_open(iwl_dbgfs_rx_handlers_ops_group1, iwl_dbgfs_rx_handlers_ops_group2);
#line 2560
    if (ldv_retval_35 == 0) {
#line 2561
      ldv_state_variable_47 = 2;
#line 2562
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2566
  goto ldv_56467;
  case 1: ;
#line 2569
  if (ldv_state_variable_47 == 1) {
#line 2571
    iwl_dbgfs_rx_handlers_write(iwl_dbgfs_rx_handlers_ops_group2, (char const   *)ldvarg298,
                                ldvarg297, ldvarg296);
#line 2573
    ldv_state_variable_47 = 1;
  } else {

  }
#line 2576
  if (ldv_state_variable_47 == 2) {
#line 2578
    iwl_dbgfs_rx_handlers_write(iwl_dbgfs_rx_handlers_ops_group2, (char const   *)ldvarg298,
                                ldvarg297, ldvarg296);
#line 2580
    ldv_state_variable_47 = 2;
  } else {

  }
#line 2583
  goto ldv_56467;
  case 2: ;
#line 2586
  if (ldv_state_variable_47 == 2) {
#line 2588
    iwl_dbgfs_rx_handlers_read(iwl_dbgfs_rx_handlers_ops_group2, ldvarg295, ldvarg294,
                               ldvarg293);
#line 2590
    ldv_state_variable_47 = 2;
  } else {

  }
#line 2593
  goto ldv_56467;
  case 3: ;
#line 2596
  if (ldv_state_variable_47 == 2) {
#line 2598
    generic_file_llseek(iwl_dbgfs_rx_handlers_ops_group2, ldvarg292, ldvarg291);
#line 2600
    ldv_state_variable_47 = 2;
  } else {

  }
#line 2603
  goto ldv_56467;
  case 4: ;
#line 2606
  if (ldv_state_variable_47 == 2) {
#line 2608
    ldv_release_47();
#line 2609
    ldv_state_variable_47 = 1;
#line 2610
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2613
  goto ldv_56467;
  default: 
#line 2614
  ldv_stop();
  }
  ldv_56467: ;
#line 2618
  return;
}
}
#line 2620 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_52(void) 
{ 
  int ldvarg161 ;
  loff_t ldvarg162 ;
  loff_t *ldvarg163 ;
  void *tmp ;
  char *ldvarg165 ;
  void *tmp___0 ;
  size_t ldvarg164 ;
  int tmp___1 ;

  {
#line 2623
  tmp = ldv_init_zalloc(8UL);
#line 2623
  ldvarg163 = (loff_t *)tmp;
#line 2624
  tmp___0 = ldv_init_zalloc(1UL);
#line 2624
  ldvarg165 = (char *)tmp___0;
#line 2621
  ldv_memset((void *)(& ldvarg161), 0, 4UL);
#line 2622
  ldv_memset((void *)(& ldvarg162), 0, 8UL);
#line 2625
  ldv_memset((void *)(& ldvarg164), 0, 8UL);
#line 2627
  tmp___1 = __VERIFIER_nondet_int();
#line 2627
  switch (tmp___1) {
  case 0: ;
#line 2630
  if (ldv_state_variable_52 == 1) {
#line 2632
    ldv_retval_15 = simple_open(iwl_dbgfs_wowlan_sram_ops_group1, iwl_dbgfs_wowlan_sram_ops_group2);
#line 2633
    if (ldv_retval_15 == 0) {
#line 2634
      ldv_state_variable_52 = 2;
#line 2635
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2639
  goto ldv_56482;
  case 1: ;
#line 2642
  if (ldv_state_variable_52 == 2) {
#line 2644
    iwl_dbgfs_wowlan_sram_read(iwl_dbgfs_wowlan_sram_ops_group2, ldvarg165, ldvarg164,
                               ldvarg163);
#line 2646
    ldv_state_variable_52 = 2;
  } else {

  }
#line 2649
  goto ldv_56482;
  case 2: ;
#line 2652
  if (ldv_state_variable_52 == 2) {
#line 2654
    generic_file_llseek(iwl_dbgfs_wowlan_sram_ops_group2, ldvarg162, ldvarg161);
#line 2656
    ldv_state_variable_52 = 2;
  } else {

  }
#line 2659
  goto ldv_56482;
  case 3: ;
#line 2662
  if (ldv_state_variable_52 == 2) {
#line 2664
    ldv_release_52();
#line 2665
    ldv_state_variable_52 = 1;
#line 2666
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2669
  goto ldv_56482;
  default: 
#line 2670
  ldv_stop();
  }
  ldv_56482: ;
#line 2674
  return;
}
}
#line 2676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_38(void) 
{ 
  loff_t *ldvarg301 ;
  void *tmp ;
  size_t ldvarg302 ;
  char *ldvarg303 ;
  void *tmp___0 ;
  loff_t ldvarg300 ;
  int ldvarg299 ;
  int tmp___1 ;

  {
#line 2677
  tmp = ldv_init_zalloc(8UL);
#line 2677
  ldvarg301 = (loff_t *)tmp;
#line 2679
  tmp___0 = ldv_init_zalloc(1UL);
#line 2679
  ldvarg303 = (char *)tmp___0;
#line 2678
  ldv_memset((void *)(& ldvarg302), 0, 8UL);
#line 2680
  ldv_memset((void *)(& ldvarg300), 0, 8UL);
#line 2681
  ldv_memset((void *)(& ldvarg299), 0, 4UL);
#line 2683
  tmp___1 = __VERIFIER_nondet_int();
#line 2683
  switch (tmp___1) {
  case 0: ;
#line 2686
  if (ldv_state_variable_38 == 1) {
#line 2688
    ldv_retval_36 = simple_open(iwl_dbgfs_ucode_general_stats_ops_group1, iwl_dbgfs_ucode_general_stats_ops_group2);
#line 2689
    if (ldv_retval_36 == 0) {
#line 2690
      ldv_state_variable_38 = 2;
#line 2691
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2695
  goto ldv_56496;
  case 1: ;
#line 2698
  if (ldv_state_variable_38 == 2) {
#line 2700
    iwl_dbgfs_ucode_general_stats_read(iwl_dbgfs_ucode_general_stats_ops_group2, ldvarg303,
                                       ldvarg302, ldvarg301);
#line 2702
    ldv_state_variable_38 = 2;
  } else {

  }
#line 2705
  goto ldv_56496;
  case 2: ;
#line 2708
  if (ldv_state_variable_38 == 2) {
#line 2710
    generic_file_llseek(iwl_dbgfs_ucode_general_stats_ops_group2, ldvarg300, ldvarg299);
#line 2712
    ldv_state_variable_38 = 2;
  } else {

  }
#line 2715
  goto ldv_56496;
  case 3: ;
#line 2718
  if (ldv_state_variable_38 == 2) {
#line 2720
    ldv_release_38();
#line 2721
    ldv_state_variable_38 = 1;
#line 2722
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2725
  goto ldv_56496;
  default: 
#line 2726
  ldv_stop();
  }
  ldv_56496: ;
#line 2730
  return;
}
}
#line 2732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_34(void) 
{ 
  int ldvarg304 ;
  loff_t *ldvarg306 ;
  void *tmp ;
  loff_t ldvarg305 ;
  char *ldvarg308 ;
  void *tmp___0 ;
  size_t ldvarg307 ;
  int tmp___1 ;

  {
#line 2734
  tmp = ldv_init_zalloc(8UL);
#line 2734
  ldvarg306 = (loff_t *)tmp;
#line 2736
  tmp___0 = ldv_init_zalloc(1UL);
#line 2736
  ldvarg308 = (char *)tmp___0;
#line 2733
  ldv_memset((void *)(& ldvarg304), 0, 4UL);
#line 2735
  ldv_memset((void *)(& ldvarg305), 0, 8UL);
#line 2737
  ldv_memset((void *)(& ldvarg307), 0, 8UL);
#line 2739
  tmp___1 = __VERIFIER_nondet_int();
#line 2739
  switch (tmp___1) {
  case 0: ;
#line 2742
  if (ldv_state_variable_34 == 1) {
#line 2744
    ldv_retval_37 = simple_open(iwl_dbgfs_clear_ucode_statistics_ops_group1, iwl_dbgfs_clear_ucode_statistics_ops_group2);
#line 2745
    if (ldv_retval_37 == 0) {
#line 2746
      ldv_state_variable_34 = 2;
#line 2747
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2751
  goto ldv_56510;
  case 1: ;
#line 2754
  if (ldv_state_variable_34 == 1) {
#line 2756
    iwl_dbgfs_clear_ucode_statistics_write(iwl_dbgfs_clear_ucode_statistics_ops_group2,
                                           (char const   *)ldvarg308, ldvarg307, ldvarg306);
#line 2758
    ldv_state_variable_34 = 1;
  } else {

  }
#line 2761
  if (ldv_state_variable_34 == 2) {
#line 2763
    iwl_dbgfs_clear_ucode_statistics_write(iwl_dbgfs_clear_ucode_statistics_ops_group2,
                                           (char const   *)ldvarg308, ldvarg307, ldvarg306);
#line 2765
    ldv_state_variable_34 = 2;
  } else {

  }
#line 2768
  goto ldv_56510;
  case 2: ;
#line 2771
  if (ldv_state_variable_34 == 2) {
#line 2773
    generic_file_llseek(iwl_dbgfs_clear_ucode_statistics_ops_group2, ldvarg305, ldvarg304);
#line 2775
    ldv_state_variable_34 = 2;
  } else {

  }
#line 2778
  goto ldv_56510;
  case 3: ;
#line 2781
  if (ldv_state_variable_34 == 2) {
#line 2783
    ldv_release_34();
#line 2784
    ldv_state_variable_34 = 1;
#line 2785
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2788
  goto ldv_56510;
  default: 
#line 2789
  ldv_stop();
  }
  ldv_56510: ;
#line 2793
  return;
}
}
#line 2795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_37(void) 
{ 
  int ldvarg309 ;
  loff_t *ldvarg311 ;
  void *tmp ;
  size_t ldvarg312 ;
  loff_t ldvarg310 ;
  char *ldvarg313 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2797
  tmp = ldv_init_zalloc(8UL);
#line 2797
  ldvarg311 = (loff_t *)tmp;
#line 2800
  tmp___0 = ldv_init_zalloc(1UL);
#line 2800
  ldvarg313 = (char *)tmp___0;
#line 2796
  ldv_memset((void *)(& ldvarg309), 0, 4UL);
#line 2798
  ldv_memset((void *)(& ldvarg312), 0, 8UL);
#line 2799
  ldv_memset((void *)(& ldvarg310), 0, 8UL);
#line 2802
  tmp___1 = __VERIFIER_nondet_int();
#line 2802
  switch (tmp___1) {
  case 0: ;
#line 2805
  if (ldv_state_variable_37 == 1) {
#line 2807
    ldv_retval_38 = simple_open(iwl_dbgfs_sensitivity_ops_group1, iwl_dbgfs_sensitivity_ops_group2);
#line 2808
    if (ldv_retval_38 == 0) {
#line 2809
      ldv_state_variable_37 = 2;
#line 2810
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2814
  goto ldv_56524;
  case 1: ;
#line 2817
  if (ldv_state_variable_37 == 2) {
#line 2819
    iwl_dbgfs_sensitivity_read(iwl_dbgfs_sensitivity_ops_group2, ldvarg313, ldvarg312,
                               ldvarg311);
#line 2821
    ldv_state_variable_37 = 2;
  } else {

  }
#line 2824
  goto ldv_56524;
  case 2: ;
#line 2827
  if (ldv_state_variable_37 == 2) {
#line 2829
    generic_file_llseek(iwl_dbgfs_sensitivity_ops_group2, ldvarg310, ldvarg309);
#line 2831
    ldv_state_variable_37 = 2;
  } else {

  }
#line 2834
  goto ldv_56524;
  case 3: ;
#line 2837
  if (ldv_state_variable_37 == 2) {
#line 2839
    ldv_release_37();
#line 2840
    ldv_state_variable_37 = 1;
#line 2841
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2844
  goto ldv_56524;
  default: 
#line 2845
  ldv_stop();
  }
  ldv_56524: ;
#line 2849
  return;
}
}
#line 2851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_45(void) 
{ 
  int ldvarg172 ;
  loff_t ldvarg173 ;
  char *ldvarg176 ;
  void *tmp ;
  loff_t *ldvarg174 ;
  void *tmp___0 ;
  size_t ldvarg175 ;
  int tmp___1 ;

  {
#line 2854
  tmp = ldv_init_zalloc(1UL);
#line 2854
  ldvarg176 = (char *)tmp;
#line 2855
  tmp___0 = ldv_init_zalloc(8UL);
#line 2855
  ldvarg174 = (loff_t *)tmp___0;
#line 2852
  ldv_memset((void *)(& ldvarg172), 0, 4UL);
#line 2853
  ldv_memset((void *)(& ldvarg173), 0, 8UL);
#line 2856
  ldv_memset((void *)(& ldvarg175), 0, 8UL);
#line 2858
  tmp___1 = __VERIFIER_nondet_int();
#line 2858
  switch (tmp___1) {
  case 0: ;
#line 2861
  if (ldv_state_variable_45 == 1) {
#line 2863
    ldv_retval_17 = simple_open(iwl_dbgfs_thermal_throttling_ops_group1, iwl_dbgfs_thermal_throttling_ops_group2);
#line 2864
    if (ldv_retval_17 == 0) {
#line 2865
      ldv_state_variable_45 = 2;
#line 2866
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2870
  goto ldv_56538;
  case 1: ;
#line 2873
  if (ldv_state_variable_45 == 2) {
#line 2875
    iwl_dbgfs_thermal_throttling_read(iwl_dbgfs_thermal_throttling_ops_group2, ldvarg176,
                                      ldvarg175, ldvarg174);
#line 2877
    ldv_state_variable_45 = 2;
  } else {

  }
#line 2880
  goto ldv_56538;
  case 2: ;
#line 2883
  if (ldv_state_variable_45 == 2) {
#line 2885
    generic_file_llseek(iwl_dbgfs_thermal_throttling_ops_group2, ldvarg173, ldvarg172);
#line 2887
    ldv_state_variable_45 = 2;
  } else {

  }
#line 2890
  goto ldv_56538;
  case 3: ;
#line 2893
  if (ldv_state_variable_45 == 2) {
#line 2895
    ldv_release_45();
#line 2896
    ldv_state_variable_45 = 1;
#line 2897
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2900
  goto ldv_56538;
  default: 
#line 2901
  ldv_stop();
  }
  ldv_56538: ;
#line 2905
  return;
}
}
#line 2907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_19(void) 
{ 
  loff_t *ldvarg182 ;
  void *tmp ;
  char *ldvarg181 ;
  void *tmp___0 ;
  size_t ldvarg180 ;
  int ldvarg177 ;
  loff_t *ldvarg179 ;
  void *tmp___1 ;
  char *ldvarg184 ;
  void *tmp___2 ;
  loff_t ldvarg178 ;
  size_t ldvarg183 ;
  int tmp___3 ;

  {
#line 2908
  tmp = ldv_init_zalloc(8UL);
#line 2908
  ldvarg182 = (loff_t *)tmp;
#line 2909
  tmp___0 = ldv_init_zalloc(1UL);
#line 2909
  ldvarg181 = (char *)tmp___0;
#line 2912
  tmp___1 = ldv_init_zalloc(8UL);
#line 2912
  ldvarg179 = (loff_t *)tmp___1;
#line 2913
  tmp___2 = ldv_init_zalloc(1UL);
#line 2913
  ldvarg184 = (char *)tmp___2;
#line 2910
  ldv_memset((void *)(& ldvarg180), 0, 8UL);
#line 2911
  ldv_memset((void *)(& ldvarg177), 0, 4UL);
#line 2914
  ldv_memset((void *)(& ldvarg178), 0, 8UL);
#line 2915
  ldv_memset((void *)(& ldvarg183), 0, 8UL);
#line 2917
  tmp___3 = __VERIFIER_nondet_int();
#line 2917
  switch (tmp___3) {
  case 0: ;
#line 2920
  if (ldv_state_variable_19 == 1) {
#line 2922
    ldv_retval_18 = simple_open(iwl_dbgfs_calib_disabled_ops_group1, iwl_dbgfs_calib_disabled_ops_group2);
#line 2923
    if (ldv_retval_18 == 0) {
#line 2924
      ldv_state_variable_19 = 2;
#line 2925
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 2929
  goto ldv_56555;
  case 1: ;
#line 2932
  if (ldv_state_variable_19 == 1) {
#line 2934
    iwl_dbgfs_calib_disabled_write(iwl_dbgfs_calib_disabled_ops_group2, (char const   *)ldvarg184,
                                   ldvarg183, ldvarg182);
#line 2936
    ldv_state_variable_19 = 1;
  } else {

  }
#line 2939
  if (ldv_state_variable_19 == 2) {
#line 2941
    iwl_dbgfs_calib_disabled_write(iwl_dbgfs_calib_disabled_ops_group2, (char const   *)ldvarg184,
                                   ldvarg183, ldvarg182);
#line 2943
    ldv_state_variable_19 = 2;
  } else {

  }
#line 2946
  goto ldv_56555;
  case 2: ;
#line 2949
  if (ldv_state_variable_19 == 2) {
#line 2951
    iwl_dbgfs_calib_disabled_read(iwl_dbgfs_calib_disabled_ops_group2, ldvarg181,
                                  ldvarg180, ldvarg179);
#line 2953
    ldv_state_variable_19 = 2;
  } else {

  }
#line 2956
  goto ldv_56555;
  case 3: ;
#line 2959
  if (ldv_state_variable_19 == 2) {
#line 2961
    generic_file_llseek(iwl_dbgfs_calib_disabled_ops_group2, ldvarg178, ldvarg177);
#line 2963
    ldv_state_variable_19 = 2;
  } else {

  }
#line 2966
  goto ldv_56555;
  case 4: ;
#line 2969
  if (ldv_state_variable_19 == 2) {
#line 2971
    ldv_release_19();
#line 2972
    ldv_state_variable_19 = 1;
#line 2973
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2976
  goto ldv_56555;
  default: 
#line 2977
  ldv_stop();
  }
  ldv_56555: ;
#line 2981
  return;
}
}
#line 2983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_main_exported_43(void) 
{ 
  loff_t *ldvarg316 ;
  void *tmp ;
  char *ldvarg318 ;
  void *tmp___0 ;
  size_t ldvarg317 ;
  loff_t ldvarg315 ;
  int ldvarg314 ;
  int tmp___1 ;

  {
#line 2984
  tmp = ldv_init_zalloc(8UL);
#line 2984
  ldvarg316 = (loff_t *)tmp;
#line 2985
  tmp___0 = ldv_init_zalloc(1UL);
#line 2985
  ldvarg318 = (char *)tmp___0;
#line 2986
  ldv_memset((void *)(& ldvarg317), 0, 8UL);
#line 2987
  ldv_memset((void *)(& ldvarg315), 0, 8UL);
#line 2988
  ldv_memset((void *)(& ldvarg314), 0, 4UL);
#line 2990
  tmp___1 = __VERIFIER_nondet_int();
#line 2990
  switch (tmp___1) {
  case 0: ;
#line 2993
  if (ldv_state_variable_43 == 1) {
#line 2995
    ldv_retval_39 = simple_open(iwl_dbgfs_temperature_ops_group1, iwl_dbgfs_temperature_ops_group2);
#line 2996
    if (ldv_retval_39 == 0) {
#line 2997
      ldv_state_variable_43 = 2;
#line 2998
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 3002
  goto ldv_56570;
  case 1: ;
#line 3005
  if (ldv_state_variable_43 == 2) {
#line 3007
    iwl_dbgfs_temperature_read(iwl_dbgfs_temperature_ops_group2, ldvarg318, ldvarg317,
                               ldvarg316);
#line 3009
    ldv_state_variable_43 = 2;
  } else {

  }
#line 3012
  goto ldv_56570;
  case 2: ;
#line 3015
  if (ldv_state_variable_43 == 2) {
#line 3017
    generic_file_llseek(iwl_dbgfs_temperature_ops_group2, ldvarg315, ldvarg314);
#line 3019
    ldv_state_variable_43 = 2;
  } else {

  }
#line 3022
  goto ldv_56570;
  case 3: ;
#line 3025
  if (ldv_state_variable_43 == 2) {
#line 3027
    ldv_release_43();
#line 3028
    ldv_state_variable_43 = 1;
#line 3029
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3032
  goto ldv_56570;
  default: 
#line 3033
  ldv_stop();
  }
  ldv_56570: ;
#line 3037
  return;
}
}
#line 3062 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
bool ldv_queue_work_on_635(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 3066
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 3066
  ldv_func_res = tmp;
#line 3068
  activate_work_7(ldv_func_arg3, 2);
#line 3070
  return (ldv_func_res);
}
}
#line 3073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
bool ldv_queue_delayed_work_on_636(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 3077
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 3077
  ldv_func_res = tmp;
#line 3079
  activate_work_7(& ldv_func_arg3->work, 2);
#line 3081
  return (ldv_func_res);
}
}
#line 3084 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
bool ldv_queue_work_on_637(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 3088
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 3088
  ldv_func_res = tmp;
#line 3090
  activate_work_7(ldv_func_arg3, 2);
#line 3092
  return (ldv_func_res);
}
}
#line 3095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_flush_workqueue_638(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 3098
  flush_workqueue(ldv_func_arg1);
#line 3100
  call_and_disable_all_7(2);
#line 3101
  return;
}
}
#line 3103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
bool ldv_queue_delayed_work_on_639(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 3107
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 3107
  ldv_func_res = tmp;
#line 3109
  activate_work_7(& ldv_func_arg3->work, 2);
#line 3111
  return (ldv_func_res);
}
}
#line 3114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_lock_640(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3117
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 3119
  mutex_lock(ldv_func_arg1);
#line 3120
  return;
}
}
#line 3122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_unlock_641(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3125
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 3127
  mutex_unlock(ldv_func_arg1);
#line 3128
  return;
}
}
#line 3130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_unlock_642(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3133
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 3135
  mutex_unlock(ldv_func_arg1);
#line 3136
  return;
}
}
#line 3138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_lock_643(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3141
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 3143
  mutex_lock(ldv_func_arg1);
#line 3144
  return;
}
}
#line 3146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_lock_644(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3149
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 3151
  mutex_lock(ldv_func_arg1);
#line 3152
  return;
}
}
#line 3154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_mutex_trylock_645(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 3158
  tmp = mutex_trylock(ldv_func_arg1);
#line 3158
  ldv_func_res = tmp;
#line 3160
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 3160
  return (tmp___0);
#line 3162
  return (ldv_func_res);
}
}
#line 3165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_unlock_646(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3168
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 3170
  mutex_unlock(ldv_func_arg1);
#line 3171
  return;
}
}
#line 3173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_lock_647(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3176
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3178
  mutex_lock(ldv_func_arg1);
#line 3179
  return;
}
}
#line 3181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_unlock_648(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3184
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3186
  mutex_unlock(ldv_func_arg1);
#line 3187
  return;
}
}
#line 3189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_lock_649(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3192
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3194
  mutex_lock(ldv_func_arg1);
#line 3195
  return;
}
}
#line 3197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_unlock_650(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3200
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3202
  mutex_unlock(ldv_func_arg1);
#line 3203
  return;
}
}
#line 3205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_lock_651(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3208
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3210
  mutex_lock(ldv_func_arg1);
#line 3211
  return;
}
}
#line 3213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_unlock_652(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3216
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3218
  mutex_unlock(ldv_func_arg1);
#line 3219
  return;
}
}
#line 3221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_mod_timer_653(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 3225
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3225
  ldv_func_res = tmp;
#line 3227
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
#line 3229
  return (ldv_func_res);
}
}
#line 3232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
int ldv_del_timer_sync_654(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 3236
  tmp = del_timer_sync(ldv_func_arg1);
#line 3236
  ldv_func_res = tmp;
#line 3238
  disable_suitable_timer_18(ldv_func_arg1);
#line 3240
  return (ldv_func_res);
}
}
#line 3243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_lock_655(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3246
  ldv_mutex_lock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3248
  mutex_lock(ldv_func_arg1);
#line 3249
  return;
}
}
#line 3251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/32_7a/drivers/net/wireless/iwlwifi/dvm/debugfs.o.c.prepared"
void ldv_mutex_unlock_656(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 3254
  ldv_mutex_unlock_mutex_of_iwl_priv(ldv_func_arg1);
#line 3256
  mutex_unlock(ldv_func_arg1);
#line 3257
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 34
  tmp = ldv_undef_int();
#line 34
  ret = tmp;
#line 36
  if (ret >= 0) {
#line 36
    ldv_stop();
  } else {

  }
#line 38
  return (ret);
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex_of_inode  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 16
    ldv_error();
  } else {

  }
#line 19
  nondetermined = ldv_undef_int();
#line 22
  if (nondetermined != 0) {
#line 25
    ldv_mutex_i_mutex_of_inode = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 42
    ldv_error();
  } else {

  }
#line 45
  nondetermined = ldv_undef_int();
#line 48
  if (nondetermined != 0) {
#line 51
    ldv_mutex_i_mutex_of_inode = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 66
    ldv_error();
  } else {

  }
#line 68
  ldv_mutex_i_mutex_of_inode = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 77
    ldv_error();
  } else {

  }
#line 80
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 83
  if (is_mutex_held_by_another_thread != 0) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_i_mutex_of_inode = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 103
    ldv_error();
  } else {

  }
#line 106
  atomic_value_after_dec = ldv_undef_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_i_mutex_of_inode = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_i_mutex_of_inode == 1) {
#line 130
    nondetermined = ldv_undef_int();
#line 133
    if (nondetermined != 0) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_i_mutex_of_inode != 2) {
#line 155
    ldv_error();
  } else {

  }
#line 157
  ldv_mutex_i_mutex_of_inode = 1;
#line 158
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
#line 166
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
#line 172
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 178
  tmp___0 = ldv_undef_int();
#line 178
  if (tmp___0 != 0) {
#line 180
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 182
    return (0);
  } else {
#line 185
    tmp = ldv_undef_int_negative();
#line 185
    return (tmp);
  }
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
#line 191
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  =    1;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 202
  if (ldv_mutex_lock != 1) {
#line 202
    ldv_error();
  } else {

  }
#line 205
  nondetermined = ldv_undef_int();
#line 208
  if (nondetermined != 0) {
#line 211
    ldv_mutex_lock = 2;
#line 213
    return (0);
  } else {
#line 218
    return (-4);
  }
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 228
  if (ldv_mutex_lock != 1) {
#line 228
    ldv_error();
  } else {

  }
#line 231
  nondetermined = ldv_undef_int();
#line 234
  if (nondetermined != 0) {
#line 237
    ldv_mutex_lock = 2;
#line 239
    return (0);
  } else {
#line 244
    return (-4);
  }
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 252
  if (ldv_mutex_lock != 1) {
#line 252
    ldv_error();
  } else {

  }
#line 254
  ldv_mutex_lock = 2;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 263
  if (ldv_mutex_lock != 1) {
#line 263
    ldv_error();
  } else {

  }
#line 266
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 269
  if (is_mutex_held_by_another_thread != 0) {
#line 272
    return (0);
  } else {
#line 277
    ldv_mutex_lock = 2;
#line 279
    return (1);
  }
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 289
  if (ldv_mutex_lock != 1) {
#line 289
    ldv_error();
  } else {

  }
#line 292
  atomic_value_after_dec = ldv_undef_int();
#line 295
  if (atomic_value_after_dec == 0) {
#line 298
    ldv_mutex_lock = 2;
#line 300
    return (1);
  } else {

  }
#line 304
  return (0);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 313
  if (ldv_mutex_lock == 1) {
#line 316
    nondetermined = ldv_undef_int();
#line 319
    if (nondetermined != 0) {
#line 322
      return (0);
    } else {
#line 327
      return (1);
    }
  } else {
#line 333
    return (1);
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 341
  if (ldv_mutex_lock != 2) {
#line 341
    ldv_error();
  } else {

  }
#line 343
  ldv_mutex_lock = 1;
#line 344
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock(void) 
{ 


  {
#line 352
  ldv_mutex_lock_lock((struct mutex *)0);
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
#line 358
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 364
  tmp___0 = ldv_undef_int();
#line 364
  if (tmp___0 != 0) {
#line 366
    ldv_mutex_lock_lock((struct mutex *)0);
#line 368
    return (0);
  } else {
#line 371
    tmp = ldv_undef_int_negative();
#line 371
    return (tmp);
  }
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock(void) 
{ 


  {
#line 377
  ldv_mutex_unlock_lock((struct mutex *)0);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  =    1;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 388
  if (ldv_mutex_mutex_of_device != 1) {
#line 388
    ldv_error();
  } else {

  }
#line 391
  nondetermined = ldv_undef_int();
#line 394
  if (nondetermined != 0) {
#line 397
    ldv_mutex_mutex_of_device = 2;
#line 399
    return (0);
  } else {
#line 404
    return (-4);
  }
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 414
  if (ldv_mutex_mutex_of_device != 1) {
#line 414
    ldv_error();
  } else {

  }
#line 417
  nondetermined = ldv_undef_int();
#line 420
  if (nondetermined != 0) {
#line 423
    ldv_mutex_mutex_of_device = 2;
#line 425
    return (0);
  } else {
#line 430
    return (-4);
  }
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 438
  if (ldv_mutex_mutex_of_device != 1) {
#line 438
    ldv_error();
  } else {

  }
#line 440
  ldv_mutex_mutex_of_device = 2;
#line 441
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 449
  if (ldv_mutex_mutex_of_device != 1) {
#line 449
    ldv_error();
  } else {

  }
#line 452
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 455
  if (is_mutex_held_by_another_thread != 0) {
#line 458
    return (0);
  } else {
#line 463
    ldv_mutex_mutex_of_device = 2;
#line 465
    return (1);
  }
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 475
  if (ldv_mutex_mutex_of_device != 1) {
#line 475
    ldv_error();
  } else {

  }
#line 478
  atomic_value_after_dec = ldv_undef_int();
#line 481
  if (atomic_value_after_dec == 0) {
#line 484
    ldv_mutex_mutex_of_device = 2;
#line 486
    return (1);
  } else {

  }
#line 490
  return (0);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 499
  if (ldv_mutex_mutex_of_device == 1) {
#line 502
    nondetermined = ldv_undef_int();
#line 505
    if (nondetermined != 0) {
#line 508
      return (0);
    } else {
#line 513
      return (1);
    }
  } else {
#line 519
    return (1);
  }
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 527
  if (ldv_mutex_mutex_of_device != 2) {
#line 527
    ldv_error();
  } else {

  }
#line 529
  ldv_mutex_mutex_of_device = 1;
#line 530
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
#line 538
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
#line 544
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
#line 544
  return (tmp);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 550
  tmp___0 = ldv_undef_int();
#line 550
  if (tmp___0 != 0) {
#line 552
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 554
    return (0);
  } else {
#line 557
    tmp = ldv_undef_int_negative();
#line 557
    return (tmp);
  }
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
#line 563
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_iwl_priv  =    1;
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_iwl_priv(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 574
  if (ldv_mutex_mutex_of_iwl_priv != 1) {
#line 574
    ldv_error();
  } else {

  }
#line 577
  nondetermined = ldv_undef_int();
#line 580
  if (nondetermined != 0) {
#line 583
    ldv_mutex_mutex_of_iwl_priv = 2;
#line 585
    return (0);
  } else {
#line 590
    return (-4);
  }
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_iwl_priv(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 600
  if (ldv_mutex_mutex_of_iwl_priv != 1) {
#line 600
    ldv_error();
  } else {

  }
#line 603
  nondetermined = ldv_undef_int();
#line 606
  if (nondetermined != 0) {
#line 609
    ldv_mutex_mutex_of_iwl_priv = 2;
#line 611
    return (0);
  } else {
#line 616
    return (-4);
  }
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_iwl_priv(struct mutex *lock ) 
{ 


  {
#line 624
  if (ldv_mutex_mutex_of_iwl_priv != 1) {
#line 624
    ldv_error();
  } else {

  }
#line 626
  ldv_mutex_mutex_of_iwl_priv = 2;
#line 627
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_iwl_priv(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 635
  if (ldv_mutex_mutex_of_iwl_priv != 1) {
#line 635
    ldv_error();
  } else {

  }
#line 638
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 641
  if (is_mutex_held_by_another_thread != 0) {
#line 644
    return (0);
  } else {
#line 649
    ldv_mutex_mutex_of_iwl_priv = 2;
#line 651
    return (1);
  }
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_iwl_priv(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 661
  if (ldv_mutex_mutex_of_iwl_priv != 1) {
#line 661
    ldv_error();
  } else {

  }
#line 664
  atomic_value_after_dec = ldv_undef_int();
#line 667
  if (atomic_value_after_dec == 0) {
#line 670
    ldv_mutex_mutex_of_iwl_priv = 2;
#line 672
    return (1);
  } else {

  }
#line 676
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_iwl_priv(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 685
  if (ldv_mutex_mutex_of_iwl_priv == 1) {
#line 688
    nondetermined = ldv_undef_int();
#line 691
    if (nondetermined != 0) {
#line 694
      return (0);
    } else {
#line 699
      return (1);
    }
  } else {
#line 705
    return (1);
  }
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_iwl_priv(struct mutex *lock ) 
{ 


  {
#line 713
  if (ldv_mutex_mutex_of_iwl_priv != 2) {
#line 713
    ldv_error();
  } else {

  }
#line 715
  ldv_mutex_mutex_of_iwl_priv = 1;
#line 716
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_iwl_priv(void) 
{ 


  {
#line 724
  ldv_mutex_lock_mutex_of_iwl_priv((struct mutex *)0);
#line 725
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_iwl_priv(void) 
{ 
  int tmp ;

  {
#line 730
  tmp = ldv_mutex_trylock_mutex_of_iwl_priv((struct mutex *)0);
#line 730
  return (tmp);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_iwl_priv(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 736
  tmp___0 = ldv_undef_int();
#line 736
  if (tmp___0 != 0) {
#line 738
    ldv_mutex_lock_mutex_of_iwl_priv((struct mutex *)0);
#line 740
    return (0);
  } else {
#line 743
    tmp = ldv_undef_int_negative();
#line 743
    return (tmp);
  }
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_iwl_priv(void) 
{ 


  {
#line 749
  ldv_mutex_unlock_mutex_of_iwl_priv((struct mutex *)0);
#line 750
  return;
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 757
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 757
    ldv_error();
  } else {

  }
#line 759
  if (ldv_mutex_lock != 1) {
#line 759
    ldv_error();
  } else {

  }
#line 761
  if (ldv_mutex_mutex_of_device != 1) {
#line 761
    ldv_error();
  } else {

  }
#line 763
  if (ldv_mutex_mutex_of_iwl_priv != 1) {
#line 763
    ldv_error();
  } else {

  }
#line 767
  return;
}
}
