extern void __VERIFIER_error();
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

typedef unsigned char __u8;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
typedef int __kernel_pid_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u32 __wsum;
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct module;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef unsigned int uint;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef unsigned int oom_flags_t;
struct __anonstruct_atomic_t_6 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
typedef unsigned long pteval_t;
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
typedef struct __anonstruct_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct page;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct thread_struct;
struct mm_struct;
struct task_struct;
struct cpumask;
struct qspinlock {
   atomic_t val ;
};
typedef struct qspinlock arch_spinlock_t;
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
typedef struct qrwlock arch_rwlock_t;
typedef void (*ctor_fn_t)(void);
struct device;
struct net_device;
struct file_operations;
struct completion;
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
struct timespec;
struct compat_timespec;
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
struct cpumask {
   unsigned long bits[128U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
struct seq_operations;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
typedef atomic64_t atomic_long_t;
struct lockdep_map;
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
struct lockdep_subclass_key {
   char __one_byte ;
};
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
typedef struct seqcount seqcount_t;
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct user_namespace;
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
typedef struct __anonstruct_kuid_t_46 kuid_t;
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
typedef struct __anonstruct_kgid_t_47 kgid_t;
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct vm_area_struct;
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
struct optimistic_spin_queue {
   atomic_t tail ;
};
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct notifier_block;
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct ctl_table;
struct nsproxy;
struct ctl_table_root;
struct ctl_table_header;
struct ctl_dir;
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
struct ctl_table_set;
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
struct workqueue_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct wake_irq;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
struct dev_pm_qos;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
struct bio_vec;
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
struct cred;
struct inode;
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
struct uprobe;
struct return_instance;
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
struct xol_area;
struct uprobes_state {
   struct xol_area *xol_area ;
};
struct address_space;
struct mem_cgroup;
typedef void compound_page_dtor(struct page * );
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
struct slab;
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
struct kmem_cache;
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct kioctx_table;
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
struct dentry;
struct iattr;
struct super_block;
struct file_system_type;
struct kernfs_open_node;
struct kernfs_iattrs;
struct kernfs_root;
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
struct kernfs_node;
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
struct kernfs_ops;
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
struct sock;
struct kobject;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct bin_attribute;
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
struct kernel_param;
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
struct latch_tree_node {
   struct rb_node node[2U] ;
};
struct mod_arch_specific {

};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct tracepoint;
struct trace_event_call;
struct trace_enum_map;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
typedef unsigned long cputime_t;
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct user_struct;
struct sysv_shm {
   struct list_head shm_clist ;
};
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_180 sigset_t;
struct siginfo;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct seccomp_filter;
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
struct rt_mutex_waiter;
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
struct assoc_array_ptr;
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct key_type;
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
struct key_user;
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
struct percpu_ref;
typedef void percpu_ref_func_t(struct percpu_ref * );
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
struct cgroup;
struct cgroup_root;
struct cgroup_subsys;
struct cgroup_taskset;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct nameidata;
struct cfs_rq;
struct task_group;
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
struct autogroup;
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
struct backing_dev_info;
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct wake_q_node {
   struct wake_q_node *next ;
};
struct io_context;
struct pipe_inode_info;
struct uts_namespace;
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
struct sched_class;
struct files_struct;
struct compat_robust_list_head;
struct numa_group;
struct ftrace_ret_stack;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
struct wiphy;
struct wireless_dev;
struct usb_interface;
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct path;
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct pinctrl;
struct pinctrl_state;
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
struct dma_map_ops;
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct device_private;
struct device_driver;
struct driver_private;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct fwnode_handle;
struct iommu_ops;
struct iommu_group;
struct device_attribute;
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
struct device_type;
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
struct of_device_id;
struct acpi_device_id;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct cma;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
union __anonunion____missing_field_name_217 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   unsigned long nr_segs ;
};
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
struct file_ra_state;
struct writeback_control;
struct bdi_writeback;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
typedef unsigned short __kernel_sa_family_t;
typedef __kernel_sa_family_t sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
struct kiocb;
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
struct __anonstruct_sync_serial_settings_219 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
typedef struct __anonstruct_sync_serial_settings_219 sync_serial_settings;
struct __anonstruct_te1_settings_220 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
typedef struct __anonstruct_te1_settings_220 te1_settings;
struct __anonstruct_raw_hdlc_proto_221 {
   unsigned short encoding ;
   unsigned short parity ;
};
typedef struct __anonstruct_raw_hdlc_proto_221 raw_hdlc_proto;
struct __anonstruct_fr_proto_222 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
typedef struct __anonstruct_fr_proto_222 fr_proto;
struct __anonstruct_fr_proto_pvc_223 {
   unsigned int dlci ;
};
typedef struct __anonstruct_fr_proto_pvc_223 fr_proto_pvc;
struct __anonstruct_fr_proto_pvc_info_224 {
   unsigned int dlci ;
   char master[16U] ;
};
typedef struct __anonstruct_fr_proto_pvc_info_224 fr_proto_pvc_info;
struct __anonstruct_cisco_proto_225 {
   unsigned int interval ;
   unsigned int timeout ;
};
typedef struct __anonstruct_cisco_proto_225 cisco_proto;
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifs_ifsu_226 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_226 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_227 {
   char ifrn_name[16U] ;
};
union __anonunion_ifr_ifru_228 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_227 ifr_ifrn ;
   union __anonunion_ifr_ifru_228 ifr_ifru ;
};
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct __anonstruct____missing_field_name_233 {
   spinlock_t lock ;
   int count ;
};
union __anonunion____missing_field_name_232 {
   struct __anonstruct____missing_field_name_233 __annonCompField59 ;
};
struct lockref {
   union __anonunion____missing_field_name_232 __annonCompField60 ;
};
struct vfsmount;
struct __anonstruct____missing_field_name_235 {
   u32 hash ;
   u32 len ;
};
union __anonunion____missing_field_name_234 {
   struct __anonstruct____missing_field_name_235 __annonCompField61 ;
   u64 hash_len ;
};
struct qstr {
   union __anonunion____missing_field_name_234 __annonCompField62 ;
   unsigned char const   *name ;
};
struct dentry_operations;
union __anonunion_d_u_236 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_236 d_u ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
struct __anonstruct____missing_field_name_240 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
union __anonunion____missing_field_name_239 {
   struct __anonstruct____missing_field_name_240 __annonCompField63 ;
   struct callback_head callback_head ;
};
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_239 __annonCompField64 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct block_device;
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
struct export_operations;
struct poll_table_struct;
struct kstatfs;
struct swap_info_struct;
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct dquot;
typedef __kernel_uid32_t projid_t;
struct __anonstruct_kprojid_t_244 {
   projid_t val ;
};
typedef struct __anonstruct_kprojid_t_244 kprojid_t;
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
typedef long long qsize_t;
union __anonunion____missing_field_name_245 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
struct kqid {
   union __anonunion____missing_field_name_245 __annonCompField66 ;
   enum quota_type type ;
};
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
struct request_queue;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion____missing_field_name_248 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
union __anonunion____missing_field_name_249 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
struct file_lock_context;
struct cdev;
union __anonunion____missing_field_name_250 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_248 __annonCompField67 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_249 __annonCompField68 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_250 __annonCompField69 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_251 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_251 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
typedef void *fl_owner_t;
struct file_lock;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
struct net;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_253 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_252 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_253 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_252 fl_u ;
};
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
struct dir_context;
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
typedef s32 compat_time_t;
typedef s32 compat_long_t;
typedef u32 compat_uptr_t;
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
struct compat_robust_list {
   compat_uptr_t next ;
};
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
enum ldv_23609 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
typedef enum ldv_23609 socket_state;
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
struct proto_ops;
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
struct exception_table_entry {
   int insn ;
   int fixup ;
};
struct in6_addr;
struct sk_buff;
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
typedef u64 netdev_features_t;
union __anonunion_in6_u_268 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
struct in6_addr {
   union __anonunion_in6_u_268 in6_u ;
};
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
struct pipe_buf_operations;
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
struct napi_struct;
struct nf_conntrack {
   atomic_t use ;
};
union __anonunion____missing_field_name_273 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
union __anonunion____missing_field_name_274 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_273 __annonCompField73 ;
   union __anonunion____missing_field_name_274 __annonCompField74 ;
};
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
typedef unsigned int sk_buff_data_t;
struct __anonstruct____missing_field_name_277 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
union __anonunion____missing_field_name_276 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_277 __annonCompField75 ;
};
struct skb_mstamp {
   union __anonunion____missing_field_name_276 __annonCompField76 ;
};
union __anonunion____missing_field_name_280 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
struct __anonstruct____missing_field_name_279 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_280 __annonCompField77 ;
};
union __anonunion____missing_field_name_278 {
   struct __anonstruct____missing_field_name_279 __annonCompField78 ;
   struct rb_node rbnode ;
};
struct sec_path;
struct __anonstruct____missing_field_name_282 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
union __anonunion____missing_field_name_281 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_282 __annonCompField80 ;
};
union __anonunion____missing_field_name_283 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
union __anonunion____missing_field_name_284 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
union __anonunion____missing_field_name_285 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
struct sk_buff {
   union __anonunion____missing_field_name_278 __annonCompField79 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_281 __annonCompField81 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_283 __annonCompField82 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_284 __annonCompField83 ;
   union __anonunion____missing_field_name_285 __annonCompField84 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
struct dst_entry;
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
struct prot_inuse;
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
struct u64_stats_sync {

};
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
struct icmp_mib {
   unsigned long mibs[28U] ;
};
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
struct tcp_mib {
   unsigned long mibs[16U] ;
};
struct udp_mib {
   unsigned long mibs[9U] ;
};
struct linux_mib {
   unsigned long mibs[115U] ;
};
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
struct proc_dir_entry;
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
struct ipv4_devconf;
struct fib_rules_ops;
struct fib_table;
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
struct inet_peer_base;
struct xt_table;
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
struct neighbour;
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
struct ipv6_devconf;
struct rt6_info;
struct rt6_statistics;
struct fib6_table;
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
struct sctp_mib;
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
struct nf_logger;
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
struct ebt_table;
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
struct hlist_nulls_node;
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
struct ip_conntrack_stat;
struct nf_ct_event_notifier;
struct nf_exp_event_notifier;
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
struct nft_af_info;
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
struct mpls_route;
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
struct proc_ns_operations;
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
struct net_generic;
struct netns_ipvs;
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
struct __anonstruct_possible_net_t_302 {
   struct net *net ;
};
typedef struct __anonstruct_possible_net_t_302 possible_net_t;
typedef unsigned long kernel_ulong_t;
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
typedef u32 phandle;
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
enum ldv_27839 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
typedef enum ldv_27839 phy_interface_t;
enum ldv_27893 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
struct phy_device;
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_27893 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
struct phy_driver;
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
struct packet_type;
struct dsa_switch;
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
struct dsa_switch_driver;
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
struct mnt_namespace;
struct ipc_namespace;
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
struct netpoll_info;
struct wpan_dev;
struct mpls_dev;
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
typedef enum netdev_tx netdev_tx_t;
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
struct neigh_parms;
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
typedef enum rx_handler_result rx_handler_result_t;
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
struct Qdisc;
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
struct __anonstruct_adj_list_315 {
   struct list_head upper ;
   struct list_head lower ;
};
struct __anonstruct_all_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};
struct iw_handler_def;
struct iw_public_data;
struct switchdev_ops;
struct vlan_info;
struct tipc_bearer;
struct in_device;
struct dn_dev;
struct inet6_dev;
struct tcf_proto;
struct cpu_rmap;
struct pcpu_lstats;
struct pcpu_sw_netstats;
struct pcpu_dstats;
struct pcpu_vstats;
union __anonunion____missing_field_name_317 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
struct garp_port;
struct mrp_port;
struct rtnl_link_ops;
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_315 adj_list ;
   struct __anonstruct_all_adj_list_316 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_317 __annonCompField94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NUM_NL80211_IFTYPES = 12,
    NL80211_IFTYPE_MAX = 11
} ;
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
} ;
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
} ;
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
} ;
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
} ;
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
} ;
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
} ;
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
} ;
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
} ;
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};
struct ieee80211_ht_operation {
   u8 primary_chan ;
   u8 ht_param ;
   __le16 operation_mode ;
   __le16 stbc_param ;
   u8 basic_set[16U] ;
};
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
} ;
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
} ;
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};
struct mac_address {
   u8 addr[6U] ;
};
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   u32 delay ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   struct ieee80211_channel *channels[0U] ;
};
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
} ;
struct cfg80211_ibss_params {
   u8 const   *ssid ;
   u8 const   *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const   *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const   *bssid ;
   u8 const   *bssid_hint ;
   u8 const   *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const   *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
struct cfg80211_pkt_pattern {
   u8 const   *mask ;
   u8 const   *pattern ;
   int pattern_len ;
   int pkt_offset ;
};
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const   *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const   *wake_data ;
   u8 const   *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
   struct cfg80211_sched_scan_request *nd_config ;
};
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit  const  *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature  const  *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   int max_nd_match_sets ;
   struct wiphy_wowlan_tcp_support  const  *tcp ;
};
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy * , struct wireless_dev * , void const   * , int  ) ;
};
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes  const  *mgmt_stypes ;
   struct ieee80211_iface_combination  const  *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[1U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const   *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support  const  *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const   *extended_capabilities ;
   u8 const   *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const   *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy * , struct regulatory_request * ) ;
   struct ieee80211_regdomain  const  *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap  const  *ht_capa_mod_mask ;
   struct ieee80211_vht_cap  const  *vht_capa_mod_mask ;
   possible_net_t _net ;
   struct iw_handler_def  const  *wext ;
   struct wiphy_coalesce_support  const  *coalesce ;
   struct wiphy_vendor_command  const  *vendor_commands ;
   struct nl80211_vendor_cmd_info  const  *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};
struct cfg80211_conn;
struct cfg80211_internal_bss;
struct cfg80211_cached_keys;
struct __anonstruct_wext_370 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const   *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_370 wext ;
};
struct rtw_queue {
   struct list_head queue ;
   spinlock_t lock ;
};
struct wlan_bcn_info {
   u8 encryp_protocol ;
   int group_cipher ;
   int pairwise_cipher ;
   int is_8021x ;
};
struct wlan_bssid_ex {
   u32 Length ;
   u8 MacAddress[6U] ;
   u16 reserved ;
   struct cfg80211_ssid Ssid ;
   u32 Privacy ;
   long Rssi ;
   u16 beacon_interval ;
   u16 capability ;
   u64 tsf ;
   u32 ATIMWindow ;
   u32 DSConfig ;
   enum nl80211_iftype ifmode ;
   unsigned char SupportedRates[16U] ;
   u8 SignalStrength ;
   u8 SignalQuality ;
   u32 IELength ;
   u8 IEs[768U] ;
};
struct wlan_network {
   struct list_head list ;
   int network_type ;
   int fixed ;
   unsigned long last_scanned ;
   int join_res ;
   struct wlan_bssid_ex network ;
   struct wlan_bcn_info BcnInfo ;
};
struct AC_param {
   u8 ACI_AIFSN ;
   u8 CW ;
   __le16 TXOP_limit ;
};
struct WMM_para_element {
   unsigned char QoS_info ;
   unsigned char reserved ;
   struct AC_param ac_param[4U] ;
};
struct ADDBA_request {
   u8 dialog_token ;
   __le16 BA_para_set ;
   __le16 BA_timeout_value ;
   __le16 BA_starting_seqctrl ;
};
struct ht_priv {
   bool ht_option ;
   bool ampdu_enable ;
   u32 tx_amsdu_enable ;
   u32 tx_amdsu_maxlen ;
   u32 rx_ampdu_maxlen ;
   u8 bwmode ;
   u8 ch_offset ;
   u8 sgi ;
   u16 agg_enable_bitmap ;
   u16 candidate_tid_bitmap ;
   struct ieee80211_ht_cap ht_cap ;
};
struct rtw_ieee80211_channel {
   u16 hw_value ;
   u32 flags ;
};
struct registry_priv;
struct rtw_adapter;
struct cmd_obj {
   struct work_struct work ;
   struct rtw_adapter *padapter ;
   u16 cmdcode ;
   int res ;
   u32 cmdsz ;
   u8 *parmbuf ;
   u8 *rsp ;
   u32 rspsz ;
};
struct cmd_priv {
   struct workqueue_struct *wq ;
   u32 cmd_issued_cnt ;
   u32 cmd_done_cnt ;
   u32 rsp_cnt ;
   struct rtw_adapter *padapter ;
};
struct evt_priv {
   struct workqueue_struct *wq ;
   struct work_struct irq_wk ;
};
struct c2h_evt_hdr {
   unsigned char id : 4 ;
   unsigned char plen : 4 ;
   u8 seq ;
   u8 payload[0U] ;
};
union __anonunion_u_371 {
   struct c2h_evt_hdr c2h_evt ;
   u8 buf[16U] ;
};
struct evt_work {
   union __anonunion_u_371 u ;
   struct work_struct work ;
   struct rtw_adapter *adapter ;
};
struct disconnect_parm {
   u32 deauth_timeout_ms ;
};
struct setopmode_parm {
   enum nl80211_iftype mode ;
};
struct sitesurvey_parm {
   int scan_mode ;
   u8 ssid_num ;
   u8 ch_num ;
   struct cfg80211_ssid ssid[9U] ;
   struct rtw_ieee80211_channel ch[51U] ;
};
struct set_stakey_parm {
   u8 addr[6U] ;
   u8 id ;
   u32 algorithm ;
   u8 key[16U] ;
};
struct set_stakey_rsp {
   u8 addr[6U] ;
   u8 keyid ;
   u8 rsvd ;
};
struct set_assocsta_parm {
   u8 addr[6U] ;
};
struct set_assocsta_rsp {
   u8 cam_id ;
   u8 rsvd[3U] ;
};
struct drvextra_cmd_parm {
   int ec_id ;
   int type_size ;
   unsigned char *pbuf ;
};
struct addBaReq_parm {
   unsigned int tid ;
   u8 addr[6U] ;
};
struct _cmd_callback {
   u32 cmd_code ;
   void (*callback)(struct rtw_adapter * , struct cmd_obj * ) ;
};
struct hw_xmit {
   struct rtw_queue *sta_queue ;
   int accnt ;
};
struct sta_info;
struct submit_ctx {
   u32 timeout_ms ;
   int status ;
   struct completion done ;
};
struct urb;
struct tx_servq {
   struct list_head tx_pending ;
   struct rtw_queue sta_pending ;
   int qcnt ;
};
struct sta_xmit_priv {
   spinlock_t lock ;
   int option ;
   int apsd_setting ;
   struct tx_servq be_q ;
   struct tx_servq bk_q ;
   struct tx_servq vi_q ;
   struct tx_servq vo_q ;
   struct list_head legacy_dz ;
   struct list_head apsd ;
   u16 txseq_tid[16U] ;
};
struct xmit_priv {
   spinlock_t lock ;
   struct semaphore xmit_sema ;
   struct semaphore terminate_xmitthread_sema ;
   struct rtw_queue be_pending ;
   struct rtw_queue bk_pending ;
   struct rtw_queue vi_pending ;
   struct rtw_queue vo_pending ;
   struct rtw_queue bm_pending ;
   int free_xmitframe_cnt ;
   struct rtw_queue free_xmit_queue ;
   int free_xframe_ext_cnt ;
   struct rtw_queue free_xframe_ext_queue ;
   uint frag_len ;
   struct rtw_adapter *adapter ;
   u64 tx_bytes ;
   u64 tx_pkts ;
   u64 tx_drop ;
   u64 last_tx_bytes ;
   u64 last_tx_pkts ;
   struct hw_xmit *hwxmits ;
   u8 hwxmit_entry ;
   u8 vcs ;
   u8 nqos_ssn ;
   u8 wmm_para_seq[4U] ;
   struct semaphore tx_retevt ;
   struct tasklet_struct xmit_tasklet ;
   struct rtw_queue free_xmitbuf_queue ;
   struct list_head xmitbuf_list ;
   struct rtw_queue pending_xmitbuf_queue ;
   uint free_xmitbuf_cnt ;
   struct rtw_queue free_xmit_extbuf_queue ;
   struct list_head xmitextbuf_list ;
   uint free_xmit_extbuf_cnt ;
   int ack_tx ;
   struct mutex ack_tx_mutex ;
   struct submit_ctx ack_tx_ops ;
   spinlock_t lock_sctx ;
};
struct recv_reorder_ctrl {
   struct rtw_adapter *padapter ;
   u8 enable ;
   u16 indicate_seq ;
   u16 wend_b ;
   u8 wsize_b ;
   struct rtw_queue pending_recvframe_queue ;
   struct timer_list reordering_ctrl_timer ;
};
struct stainfo_rxcache {
   u16 tid_rxseq[16U] ;
};
struct signal_stat {
   u8 update_req ;
   u8 avg_val ;
   u32 total_num ;
   u32 total_val ;
};
struct recv_priv {
   spinlock_t lock ;
   struct rtw_queue free_recv_queue ;
   struct rtw_queue recv_pending_queue ;
   struct rtw_queue uc_swdec_pending_queue ;
   int free_recvframe_cnt ;
   struct rtw_adapter *adapter ;
   u32 bIsAnyNonBEPkts ;
   u64 rx_bytes ;
   u64 rx_pkts ;
   u64 rx_drop ;
   u64 last_rx_bytes ;
   uint rx_icv_err ;
   uint rx_largepacket_crcerr ;
   uint rx_smallpacket_crcerr ;
   uint rx_middlepacket_crcerr ;
   u8 rx_pending_cnt ;
   struct urb *int_in_urb ;
   u8 *int_in_buf ;
   struct tasklet_struct irq_prepare_beacon_tasklet ;
   struct tasklet_struct recv_tasklet ;
   struct sk_buff_head free_recv_skb_queue ;
   struct sk_buff_head rx_skb_queue ;
   u8 *precv_buf ;
   s8 rxpwdb ;
   u8 signal_strength ;
   u8 signal_qual ;
   u8 noise ;
   int RxSNRdB[2U] ;
   s8 RxRssi[2U] ;
   int FalseAlmCnt_all ;
   struct timer_list signal_stat_timer ;
   u32 signal_stat_sampling_interval ;
   struct signal_stat signal_qual_data ;
   struct signal_stat signal_strength_data ;
};
struct sta_recv_priv {
   spinlock_t lock ;
   int option ;
   struct rtw_queue defrag_q ;
   struct stainfo_rxcache rxcache ;
};
struct __anonstruct__byte__372 {
   u8 TSC0 ;
   u8 TSC1 ;
   u8 TSC2 ;
   u8 TSC3 ;
   u8 TSC4 ;
   u8 TSC5 ;
   u8 TSC6 ;
   u8 TSC7 ;
};
union pn48 {
   u64 val ;
   struct __anonstruct__byte__372 _byte_ ;
};
union Keytype {
   u8 skey[16U] ;
   u32 lkey[4U] ;
};
struct rtw_wep_key {
   u8 key[14U] ;
   u16 keylen ;
};
struct rt_pmkid_list {
   u8 bUsed ;
   u8 Bssid[6U] ;
   u8 PMKID[16U] ;
   u8 SsidBuf[33U] ;
   u8 *ssid_octet ;
   u16 ssid_length ;
};
struct security_priv {
   u32 dot11AuthAlgrthm ;
   u32 dot11PrivacyAlgrthm ;
   u32 dot11PrivacyKeyIndex ;
   struct rtw_wep_key wep_key[4U] ;
   u32 dot118021XGrpPrivacy ;
   u32 dot118021XGrpKeyid ;
   union Keytype dot118021XGrpKey[4U] ;
   union Keytype dot118021XGrptxmickey[4U] ;
   union Keytype dot118021XGrprxmickey[4U] ;
   union pn48 dot11Grptxpn ;
   union pn48 dot11Grprxpn ;
   unsigned int dot8021xalg ;
   unsigned int wpa_psk ;
   unsigned int wpa_group_cipher ;
   unsigned int wpa2_group_cipher ;
   unsigned int wpa_pairwise_cipher ;
   unsigned int wpa2_pairwise_cipher ;
   u8 wps_ie[256U] ;
   int wps_ie_len ;
   unsigned char binstallGrpkey : 1 ;
   unsigned char busetkipkey : 1 ;
   unsigned char bcheck_grpkey : 1 ;
   unsigned char hw_decrypted : 1 ;
   u32 ndisauthtype ;
   u32 ndisencryptstatus ;
   struct wlan_bssid_ex sec_bss ;
   u8 assoc_info[600U] ;
   u8 szofcapability[256U] ;
   u8 oidassociation[512U] ;
   u8 supplicant_ie[256U] ;
   unsigned long last_mic_err_time ;
   u8 btkip_countermeasure ;
   u8 btkip_wait_report ;
   unsigned long btkip_countermeasure_time ;
   struct rt_pmkid_list PMKIDList[16U] ;
   u8 PMKIDIndex ;
   u8 bWepDefaultKeyIdxSet ;
};
enum rt_rf_power_state {
    rf_on = 0,
    rf_sleep = 1,
    rf_off = 2,
    rf_max = 3
} ;
struct pwrctrl_priv {
   struct semaphore lock ;
   u8 volatile   rpwm ;
   u8 volatile   cpwm ;
   u8 volatile   tog ;
   u8 pwr_mode ;
   u8 smart_ps ;
   u8 bcn_ant_mode ;
   u8 bpower_saving ;
   u8 reg_rfoff ;
   u32 rfoff_reason ;
   u32 cur_ps_level ;
   u32 reg_rfps_level ;
   uint ips_enter23a_cnts ;
   uint ips_leave23a_cnts ;
   u8 ips_mode ;
   u8 ips_mode_req ;
   uint bips_processing ;
   unsigned long ips_deny_time ;
   u8 ps_processing ;
   u8 bLeisurePs ;
   u8 LpsIdleCount ;
   u8 power_mgnt ;
   u8 bFwCurrentInPSMode ;
   unsigned long DelayLPSLastTimeStamp ;
   u8 btcoex_rfon ;
   u8 bInSuspend ;
   u8 bAutoResume ;
   u8 autopm_cnt ;
   u8 bSupportRemoteWakeup ;
   struct timer_list pwr_state_check_timer ;
   int pwr_state_check_interval ;
   u8 pwr_state_check_cnts ;
   enum rt_rf_power_state rf_pwrstate ;
   enum rt_rf_power_state change_rfpwrstate ;
   u8 bkeepfwalive ;
   unsigned long PS_BBRegBackup[4U] ;
};
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
struct usb_device;
struct wusb_dev;
struct ep_device;
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
struct mon_bus;
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
struct usb_tt;
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
struct eeprom_priv {
   u8 mac_addr[6U] ;
   u8 bautoload_fail_flag ;
   u8 bloadfile_fail_flag ;
   u8 bloadmac_fail_flag ;
   u16 channel_plan ;
   u8 EepromOrEfuse ;
   u8 efuse_eeprom_data[512U] ;
};
struct rtw_wlan_acl_node {
   struct list_head list ;
   u8 addr[6U] ;
   u8 valid ;
};
struct wlan_acl_pool {
   int mode ;
   int num ;
   struct rtw_wlan_acl_node aclnode[16U] ;
   struct rtw_queue acl_node_q ;
};
struct rssi_sta {
   s32 UndecoratedSmoothedPWDB ;
   s32 UndecoratedSmoothedCCK ;
   s32 UndecoratedSmoothedOFDM ;
   u64 PacketMap ;
   u8 ValidBit ;
};
struct stainfo_stats {
   u64 rx_mgnt_pkts ;
   u64 rx_beacon_pkts ;
   u64 rx_probereq_pkts ;
   u64 rx_probersp_pkts ;
   u64 rx_probersp_bm_pkts ;
   u64 rx_probersp_uo_pkts ;
   u64 rx_ctrl_pkts ;
   u64 rx_data_pkts ;
   u64 last_rx_mgnt_pkts ;
   u64 last_rx_beacon_pkts ;
   u64 last_rx_probereq_pkts ;
   u64 last_rx_probersp_pkts ;
   u64 last_rx_probersp_bm_pkts ;
   u64 last_rx_probersp_uo_pkts ;
   u64 last_rx_ctrl_pkts ;
   u64 last_rx_data_pkts ;
   u64 rx_bytes ;
   u64 rx_drops ;
   u64 tx_pkts ;
   u64 tx_bytes ;
   u64 tx_drops ;
};
struct sta_info {
   spinlock_t lock ;
   struct list_head list ;
   struct list_head hash_list ;
   struct rtw_adapter *padapter ;
   struct sta_xmit_priv sta_xmitpriv ;
   struct sta_recv_priv sta_recvpriv ;
   struct rtw_queue sleep_q ;
   unsigned int sleepq_len ;
   uint state ;
   uint aid ;
   uint mac_id ;
   uint qos_option ;
   u8 hwaddr[6U] ;
   uint ieee8021x_blocked ;
   u32 dot118021XPrivacy ;
   union Keytype dot11tkiptxmickey ;
   union Keytype dot11tkiprxmickey ;
   union Keytype dot118021x_UncstKey ;
   union pn48 dot11txpn ;
   union pn48 dot11rxpn ;
   u8 bssrateset[16U] ;
   u32 bssratelen ;
   s32 rssi ;
   s32 signal_quality ;
   u8 cts2self ;
   u8 rtsen ;
   u8 raid ;
   u8 init_rate ;
   u32 ra_mask ;
   u8 wireless_mode ;
   struct stainfo_stats sta_stats ;
   struct timer_list addba_retry_timer ;
   struct recv_reorder_ctrl recvreorder_ctrl[16U] ;
   u16 BA_starting_seqctrl[16U] ;
   struct ht_priv htpriv ;
   struct list_head asoc_list ;
   struct list_head auth_list ;
   unsigned int expire_to ;
   unsigned int auth_seq ;
   unsigned int authalg ;
   unsigned char chg_txt[128U] ;
   u16 capability ;
   int flags ;
   int dot8021xalg ;
   int wpa_psk ;
   int wpa_group_cipher ;
   int wpa2_group_cipher ;
   int wpa_pairwise_cipher ;
   int wpa2_pairwise_cipher ;
   u8 bpairwise_key_installed ;
   u8 wpa_ie[32U] ;
   u8 nonerp_set ;
   u8 no_short_slot_time_set ;
   u8 no_short_preamble_set ;
   u8 no_ht_gf_set ;
   u8 no_ht_set ;
   u8 ht_20mhz_set ;
   unsigned int tx_ra_bitmap ;
   u8 qos_info ;
   u8 max_sp_len ;
   u8 uapsd_bk ;
   u8 uapsd_be ;
   u8 uapsd_vi ;
   u8 uapsd_vo ;
   u8 has_legacy_ac ;
   unsigned int sleepq_ac_len ;
   u8 is_p2p_device ;
   u8 p2p_status_code ;
   u8 keep_alive_trycnt ;
   u8 dev_addr[6U] ;
   u8 dev_cap ;
   u16 config_methods ;
   u8 primary_dev_type[8U] ;
   u8 num_of_secdev_type ;
   u8 secdev_types_list[32U] ;
   u16 dev_name_len ;
   u8 dev_name[32U] ;
   u8 *passoc_req ;
   u32 assoc_req_len ;
   struct rssi_sta rssi_stat ;
   u8 bValid ;
   u8 rssi_level ;
   u8 RSSI_Path[4U] ;
   u8 RSSI_Ave ;
   u8 RXEVM[4U] ;
   u8 RXSNR[4U] ;
   u16 RxMgmtFrameSeqNum ;
};
struct sta_priv {
   spinlock_t sta_hash_lock ;
   struct list_head sta_hash[32U] ;
   int asoc_sta_count ;
   struct rtw_adapter *padapter ;
   struct list_head asoc_list ;
   struct list_head auth_list ;
   spinlock_t asoc_list_lock ;
   spinlock_t auth_list_lock ;
   u8 asoc_list_cnt ;
   u8 auth_list_cnt ;
   unsigned int auth_to ;
   unsigned int assoc_to ;
   unsigned int expire_to ;
   struct sta_info *sta_aid[32U] ;
   u16 sta_dz_bitmap ;
   u16 tim_bitmap ;
   u16 max_num_sta ;
   struct wlan_acl_pool acl_list ;
};
enum rt_scan_type {
    SCAN_PASSIVE = 0,
    SCAN_ACTIVE = 1,
    SCAN_MIX = 2
} ;
struct rt_link_detect {
   u32 NumTxOkInPeriod ;
   u32 NumRxOkInPeriod ;
   u32 NumRxUnicastOkInPeriod ;
   bool bBusyTraffic ;
   bool bTxBusyTraffic ;
   bool bRxBusyTraffic ;
   bool bHigherBusyTraffic ;
   bool bHigherBusyRxTraffic ;
   bool bHigherBusyTxTraffic ;
};
struct mlme_priv {
   spinlock_t lock ;
   int fw_state ;
   u8 bScanInProcess ;
   u8 to_join ;
   u8 to_roaming ;
   struct rtw_adapter *nic_hdl ;
   u8 not_indic_disco ;
   struct rtw_queue scanned_queue ;
   struct cfg80211_ssid assoc_ssid ;
   u8 assoc_bssid[6U] ;
   struct wlan_network cur_network ;
   u32 scan_interval ;
   struct timer_list assoc_timer ;
   uint assoc_by_bssid ;
   uint assoc_by_rssi ;
   struct timer_list scan_to_timer ;
   struct timer_list set_scan_deny_timer ;
   atomic_t set_scan_deny ;
   unsigned int qos_option ;
   int num_sta_no_ht ;
   int num_FortyMHzIntolerant ;
   struct ht_priv htpriv ;
   struct rt_link_detect LinkDetectInfo ;
   struct timer_list dynamic_chk_timer ;
   u8 key_mask ;
   u8 acm_mask ;
   u8 ChannelPlan ;
   enum rt_scan_type scan_mode ;
   u8 *wps_probe_req_ie ;
   u32 wps_probe_req_ie_len ;
   u8 *assoc_req ;
   u32 assoc_req_len ;
   u32 assoc_rsp_len ;
   u8 *assoc_rsp ;
   int num_sta_non_erp ;
   int num_sta_no_short_slot_time ;
   int num_sta_no_short_preamble ;
   int olbc ;
   int num_sta_ht_no_gf ;
   int num_sta_ht_20mhz ;
   int olbc_ht ;
   u16 ht_op_mode ;
   spinlock_t bcn_update_lock ;
   u8 update_bcn ;
};
struct ss_res {
   int state ;
   int bss_cnt ;
   int channel_idx ;
   int scan_mode ;
   u8 ssid_num ;
   u8 ch_num ;
   struct cfg80211_ssid ssid[9U] ;
   struct rtw_ieee80211_channel ch[51U] ;
};
struct FW_Sta_Info {
   struct sta_info *psta ;
   u32 status ;
   u32 rx_pkt ;
   u32 retry ;
   unsigned char SupportedRates[16U] ;
};
struct mlme_ext_info {
   u32 state ;
   u32 reauth_count ;
   u32 reassoc_count ;
   u32 link_count ;
   u32 auth_seq ;
   u32 auth_algo ;
   u32 authModeToggle ;
   u32 enc_algo ;
   u32 key_index ;
   u32 iv ;
   u8 chg_txt[128U] ;
   u16 aid ;
   u16 bcn_interval ;
   u16 capability ;
   u8 assoc_AP_vendor ;
   u8 slotTime ;
   u8 preamble_mode ;
   u8 WMM_enable ;
   u8 ERP_enable ;
   u8 ERP_IE ;
   u8 HT_enable ;
   u8 HT_caps_enable ;
   u8 HT_info_enable ;
   u8 HT_protection ;
   u8 turboMode_cts2self ;
   u8 turboMode_rtsen ;
   u8 SM_PS ;
   u8 ADDBA_retry_count ;
   u8 dialogToken ;
   bool bAcceptAddbaReq ;
   u8 bwmode_updated ;
   u8 hidden_ssid_mode ;
   struct ADDBA_request ADDBA_req ;
   struct WMM_para_element WMM_param ;
   struct ieee80211_ht_cap ht_cap ;
   struct ieee80211_ht_operation HT_info ;
   struct wlan_bssid_ex network ;
   struct FW_Sta_Info FW_sta_info[32U] ;
};
struct rt_channel_info {
   u8 ChannelNum ;
   enum rt_scan_type ScanType ;
};
struct p2p_reg_class {
   u8 reg_class ;
   u8 channel[20U] ;
   size_t channels ;
};
struct p2p_channels {
   struct p2p_reg_class reg_class[10U] ;
   size_t reg_classes ;
};
struct mlme_ext_priv {
   struct rtw_adapter *padapter ;
   u8 mlmeext_init ;
   atomic_t event_seq ;
   u16 mgnt_seq ;
   unsigned char cur_channel ;
   unsigned char cur_bwmode ;
   unsigned char cur_ch_offset ;
   unsigned char cur_wireless_mode ;
   unsigned char max_chan_nums ;
   struct rt_channel_info channel_set[38U] ;
   struct p2p_channels channel_list ;
   unsigned char basicrate[13U] ;
   unsigned char datarate[13U] ;
   struct ss_res sitesurvey_res ;
   struct mlme_ext_info mlmext_info ;
   struct timer_list survey_timer ;
   struct timer_list link_timer ;
   u16 chan_scan_time ;
   u8 scan_abort ;
   u8 tx_rate ;
   u32 retry ;
   u64 TSFValue ;
   unsigned char bstart_bss ;
   u8 update_channel_plan_by_ap_done ;
   u8 action_public_dialog_token ;
   u16 action_public_rxseq ;
   u8 active_keep_alive_check ;
};
struct cmd_hdl {
   uint parmsize ;
   int (*h2cfuns)(struct rtw_adapter * , u8 const   * ) ;
};
struct registry_priv {
   u8 chip_version ;
   u8 rfintfs ;
   struct cfg80211_ssid ssid ;
   u8 channel ;
   u8 wireless_mode ;
   u8 scan_mode ;
   u8 preamble ;
   u8 vrtl_carrier_sense ;
   u8 vcs_type ;
   u16 rts_thresh ;
   u16 frag_thresh ;
   u8 adhoc_tx_pwr ;
   u8 soft_ap ;
   u8 power_mgnt ;
   u8 ips_mode ;
   u8 smart_ps ;
   u8 long_retry_lmt ;
   u8 short_retry_lmt ;
   u16 busy_thresh ;
   u8 ack_policy ;
   u8 software_encrypt ;
   u8 software_decrypt ;
   u8 acm_method ;
   u8 wmm_enable ;
   u8 uapsd_enable ;
   struct wlan_bssid_ex dev_network ;
   u8 ht_enable ;
   u8 cbw40_enable ;
   u8 ampdu_enable ;
   u8 rx_stbc ;
   u8 ampdu_amsdu ;
   u8 lowrate_two_xmit ;
   u8 rf_config ;
   u8 low_power ;
   u8 wifi_spec ;
   u8 channel_plan ;
   u8 btcoex ;
   u8 bt_iso ;
   u8 bt_sco ;
   u8 bt_ampdu ;
   bool bAcceptAddbaReq ;
   u8 antdiv_cfg ;
   u8 antdiv_type ;
   u8 hwpdn_mode ;
   u8 hwpwrp_detect ;
   u8 hw_wps_pbc ;
   u8 max_roaming_times ;
   u8 enable80211d ;
   u8 ifname[16U] ;
   u8 if2name[16U] ;
   u8 notch_filter ;
   u8 regulatory_tid ;
};
union __anonunion_usb_buf_373 {
   __le32 val32 ;
   __le16 val16 ;
   u8 val8 ;
};
struct dvobj_priv {
   struct rtw_adapter *if1 ;
   struct rtw_adapter *if2 ;
   struct mutex hw_init_mutex ;
   struct mutex h2c_fwcmd_mutex ;
   struct mutex setch_mutex ;
   struct mutex setbw_mutex ;
   unsigned char oper_channel ;
   unsigned char oper_bwmode ;
   unsigned char oper_ch_offset ;
   struct rtw_adapter *padapters[4U] ;
   u8 iface_nums ;
   u8 InterfaceNumber ;
   u8 NumInterfaces ;
   int RtInPipe[2U] ;
   int RtOutPipe[3U] ;
   u8 Queue2Pipe[8U] ;
   u8 nr_endpoint ;
   u8 ishighspeed ;
   u8 RtNumInPipes ;
   u8 RtNumOutPipes ;
   int ep_num[5U] ;
   struct mutex usb_vendor_req_mutex ;
   union __anonunion_usb_buf_373 usb_buf ;
   struct usb_interface *pusbintf ;
   struct usb_device *pusbdev ;
   atomic_t continual_urb_error ;
};
struct rtw_adapter {
   int pid[3U] ;
   int bDongle ;
   u16 chip_type ;
   u16 HardwareType ;
   struct dvobj_priv *dvobj ;
   struct mlme_priv mlmepriv ;
   struct mlme_ext_priv mlmeextpriv ;
   struct cmd_priv cmdpriv ;
   struct evt_priv evtpriv ;
   struct xmit_priv xmitpriv ;
   struct recv_priv recvpriv ;
   struct sta_priv stapriv ;
   struct security_priv securitypriv ;
   struct registry_priv registrypriv ;
   struct pwrctrl_priv pwrctrlpriv ;
   struct eeprom_priv eeprompriv ;
   u32 setband ;
   void *HalData ;
   s32 bDriverStopped ;
   s32 bSurpriseRemoved ;
   s32 bCardDisableWOHSM ;
   u32 IsrContent ;
   u32 ImrContent ;
   u8 EepromAddressSize ;
   u8 hw_init_completed ;
   u8 bDriverIsGoingToUnload ;
   u8 init_adpt_in_progress ;
   u8 bHaltInProgress ;
   struct net_device *pnetdev ;
   int bup ;
   struct net_device_stats stats ;
   struct wireless_dev *rtw_wdev ;
   int net_closed ;
   u8 bFWReady ;
   u8 bReadPortCancel ;
   u8 bWritePortCancel ;
   u8 iface_id ;
};
enum rt_media_status;
enum rt_media_status;
enum rt_media_status {
    RT_MEDIA_DISCONNECT = 0,
    RT_MEDIA_CONNECT = 1
} ;
typedef bool ldv_func_ret_type;
typedef bool ldv_func_ret_type___0;
typedef bool ldv_func_ret_type___1;
typedef bool ldv_func_ret_type___2;
typedef bool ldv_func_ret_type___3;
typedef int ldv_func_ret_type___4;
typedef int ldv_func_ret_type___5;
typedef int ldv_func_ret_type___6;
typedef int ldv_func_ret_type___7;
typedef int ldv_func_ret_type___8;
typedef int ldv_func_ret_type___9;
typedef int ldv_func_ret_type___10;
enum hrtimer_restart;
enum hrtimer_restart;
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};
struct setauth_parm {
   u8 mode ;
   u8 _1x ;
   u8 rsvd[2U] ;
};
struct setkey_parm {
   u32 algorithm ;
   u8 keyid ;
   u8 grpkey ;
   u8 set_tx ;
   u8 key[16U] ;
};
struct pkt_attrib {
   u16 type ;
   u8 bswenc ;
   u8 dhcp_pkt ;
   u16 ether_type ;
   u16 seqnum ;
   u16 pkt_hdrlen ;
   u16 hdrlen ;
   u32 pktlen ;
   u32 last_txcmdsz ;
   u32 encrypt ;
   u8 nr_frags ;
   u8 iv_len ;
   u8 icv_len ;
   u8 iv[18U] ;
   u8 icv[16U] ;
   u8 priority ;
   u8 ack_policy ;
   u8 mac_id ;
   u8 vcs_mode ;
   u8 dst[6U] ;
   u8 src[6U] ;
   u8 ta[6U] ;
   u8 ra[6U] ;
   u8 key_idx ;
   u8 qos_en ;
   u8 ht_en ;
   u8 raid ;
   u8 bwmode ;
   u8 ch_offset ;
   u8 sgi ;
   u8 ampdu_en ;
   u8 mdata ;
   u8 pctrl ;
   u8 triggered ;
   u8 qsel ;
   u8 eosp ;
   u8 rate ;
   u8 retry_ctrl ;
   struct sta_info *psta ;
};
struct xmit_buf {
   struct list_head list ;
   struct list_head list2 ;
   struct rtw_adapter *padapter ;
   u8 *pallocated_buf ;
   u8 *pbuf ;
   void *priv_data ;
   u16 ext_tag ;
   u16 flags ;
   u32 alloc_sz ;
   u32 len ;
   struct submit_ctx *sctx ;
   u32 ff_hwaddr ;
   struct urb *pxmit_urb[8U] ;
   u8 bpending[8U] ;
   int last[8U] ;
};
struct xmit_frame {
   struct list_head list ;
   struct pkt_attrib attrib ;
   struct sk_buff *pkt ;
   int frame_tag ;
   struct rtw_adapter *padapter ;
   u8 *buf_addr ;
   struct xmit_buf *pxmitbuf ;
   s8 pkt_offset ;
   u8 ack_report ;
   u8 ext_tag ;
};
enum hal_def_variable {
    HAL_DEF_UNDERCORATEDSMOOTHEDPWDB = 0,
    HAL_DEF_IS_SUPPORT_ANT_DIV = 1,
    HAL_DEF_CURRENT_ANTENNA = 2,
    HAL_DEF_DRVINFO_SZ = 3,
    HAL_DEF_MAX_RECVBUF_SZ = 4,
    HAL_DEF_RX_PACKET_OFFSET = 5,
    HAL_DEF_DBG_DUMP_RXPKT = 6,
    HAL_DEF_DBG_DM_FUNC = 7,
    HAL_DEF_RA_DECISION_RATE = 8,
    HAL_DEF_RA_SGI = 9,
    HAL_DEF_PT_PWR_STATUS = 10,
    HW_VAR_MAX_RX_AMPDU_FACTOR = 11,
    HW_DEF_RA_INFO_DUMP = 12,
    HAL_DEF_DBG_DUMP_TXPKT = 13,
    HW_DEF_FA_CNT_DUMP = 14,
    HW_DEF_ODM_DBG_FLAG = 15
} ;
enum hal_odm_variable {
    HAL_ODM_STA_INFO = 0,
    HAL_ODM_P2P_STATE = 1,
    HAL_ODM_WIFI_DISPLAY_STATE = 2
} ;
struct survey_event {
   struct wlan_bssid_ex *bss ;
};
struct stassoc_event {
   unsigned char macaddr[6U] ;
   unsigned char rsvd[2U] ;
   int cam_id ;
};
struct stadel_event {
   unsigned char macaddr[6U] ;
   unsigned char rsvd[2U] ;
   int mac_id ;
};
struct rtw_wdev_priv {
   struct wireless_dev *rtw_wdev ;
   struct rtw_adapter *padapter ;
   struct cfg80211_scan_request *scan_request ;
   spinlock_t scan_req_lock ;
   struct net_device *pmon_ndev ;
   char ifname_mon[17U] ;
   u8 p2p_enabled ;
   bool power_mgmt ;
};
typedef int ldv_func_ret_type___11;
typedef int ldv_func_ret_type___12;
typedef int ldv_func_ret_type___13;
typedef __u64 __le64;
enum hrtimer_restart;
struct ieee80211_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   u8 addr4[6U] ;
};
struct ieee80211_qos_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   __le16 qos_ctrl ;
};
struct ieee80211_msrment_ie {
   u8 token ;
   u8 mode ;
   u8 type ;
   u8 request[0U] ;
};
struct ieee80211_ext_chansw_ie {
   u8 mode ;
   u8 new_operating_class ;
   u8 new_ch_num ;
   u8 count ;
};
struct ieee80211_tpc_report_ie {
   u8 tx_power ;
   u8 link_margin ;
};
struct __anonstruct_auth_331 {
   __le16 auth_alg ;
   __le16 auth_transaction ;
   __le16 status_code ;
   u8 variable[0U] ;
};
struct __anonstruct_deauth_332 {
   __le16 reason_code ;
};
struct __anonstruct_assoc_req_333 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 variable[0U] ;
};
struct __anonstruct_assoc_resp_334 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
struct __anonstruct_reassoc_resp_335 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
struct __anonstruct_reassoc_req_336 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 current_ap[6U] ;
   u8 variable[0U] ;
};
struct __anonstruct_disassoc_337 {
   __le16 reason_code ;
};
struct __anonstruct_beacon_338 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
struct __anonstruct_probe_req_339 {
   u8 variable[0U] ;
};
struct __anonstruct_probe_resp_340 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
struct __anonstruct_wme_action_343 {
   u8 action_code ;
   u8 dialog_token ;
   u8 status_code ;
   u8 variable[0U] ;
};
struct __anonstruct_chan_switch_344 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_ext_chan_switch_345 {
   u8 action_code ;
   struct ieee80211_ext_chansw_ie data ;
   u8 variable[0U] ;
};
struct __anonstruct_measurement_346 {
   u8 action_code ;
   u8 dialog_token ;
   u8 element_id ;
   u8 length ;
   struct ieee80211_msrment_ie msr_elem ;
};
struct __anonstruct_addba_req_347 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capab ;
   __le16 timeout ;
   __le16 start_seq_num ;
};
struct __anonstruct_addba_resp_348 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 status ;
   __le16 capab ;
   __le16 timeout ;
};
struct __anonstruct_delba_349 {
   u8 action_code ;
   __le16 params ;
   __le16 reason_code ;
};
struct __anonstruct_self_prot_350 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_mesh_action_351 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_sa_query_352 {
   u8 action ;
   u8 trans_id[2U] ;
};
struct __anonstruct_ht_smps_353 {
   u8 action ;
   u8 smps_control ;
};
struct __anonstruct_ht_notify_cw_354 {
   u8 action_code ;
   u8 chanwidth ;
};
struct __anonstruct_tdls_discover_resp_355 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capability ;
   u8 variable[0U] ;
};
struct __anonstruct_vht_opmode_notif_356 {
   u8 action_code ;
   u8 operating_mode ;
};
struct __anonstruct_tpc_report_357 {
   u8 action_code ;
   u8 dialog_token ;
   u8 tpc_elem_id ;
   u8 tpc_elem_length ;
   struct ieee80211_tpc_report_ie tpc ;
};
union __anonunion_u_342 {
   struct __anonstruct_wme_action_343 wme_action ;
   struct __anonstruct_chan_switch_344 chan_switch ;
   struct __anonstruct_ext_chan_switch_345 ext_chan_switch ;
   struct __anonstruct_measurement_346 measurement ;
   struct __anonstruct_addba_req_347 addba_req ;
   struct __anonstruct_addba_resp_348 addba_resp ;
   struct __anonstruct_delba_349 delba ;
   struct __anonstruct_self_prot_350 self_prot ;
   struct __anonstruct_mesh_action_351 mesh_action ;
   struct __anonstruct_sa_query_352 sa_query ;
   struct __anonstruct_ht_smps_353 ht_smps ;
   struct __anonstruct_ht_notify_cw_354 ht_notify_cw ;
   struct __anonstruct_tdls_discover_resp_355 tdls_discover_resp ;
   struct __anonstruct_vht_opmode_notif_356 vht_opmode_notif ;
   struct __anonstruct_tpc_report_357 tpc_report ;
};
struct __anonstruct_action_341 {
   u8 category ;
   union __anonunion_u_342 u ;
};
union __anonunion_u_330 {
   struct __anonstruct_auth_331 auth ;
   struct __anonstruct_deauth_332 deauth ;
   struct __anonstruct_assoc_req_333 assoc_req ;
   struct __anonstruct_assoc_resp_334 assoc_resp ;
   struct __anonstruct_reassoc_resp_335 reassoc_resp ;
   struct __anonstruct_reassoc_req_336 reassoc_req ;
   struct __anonstruct_disassoc_337 disassoc ;
   struct __anonstruct_beacon_338 beacon ;
   struct __anonstruct_probe_req_339 probe_req ;
   struct __anonstruct_probe_resp_340 probe_resp ;
   struct __anonstruct_action_341 action ;
};
struct ieee80211_mgmt {
   __le16 frame_control ;
   __le16 duration ;
   u8 da[6U] ;
   u8 sa[6U] ;
   u8 bssid[6U] ;
   __le16 seq_ctrl ;
   union __anonunion_u_330 u ;
};
struct Tx_Beacon_param {
   struct wlan_bssid_ex network ;
};
struct set_ch_parm {
   u8 ch ;
   u8 bw ;
   u8 ch_offset ;
};
struct SetChannelPlan_param {
   u8 channel_plan ;
};
struct led_8723a;
struct LedBlink_param {
   struct led_8723a *pLed ;
};
struct phy_info {
   u8 RxPWDBAll ;
   u8 SignalQuality ;
   u8 RxMIMOSignalQuality[2U] ;
   u8 RxMIMOSignalStrength[2U] ;
   s8 RxPower ;
   s8 RecvSignalPower ;
   u8 BTRxRSSIPercentage ;
   u8 SignalStrength ;
   u8 RxPwr[2U] ;
   u8 RxSNR[2U] ;
};
struct rx_pkt_attrib {
   u16 pkt_len ;
   u8 physt ;
   u8 drvinfo_sz ;
   u8 shift_sz ;
   u8 hdrlen ;
   u8 amsdu ;
   u8 qos ;
   u8 priority ;
   u8 pw_save ;
   u8 mdata ;
   u16 seq_num ;
   u8 frag_num ;
   u8 mfrag ;
   u8 order ;
   u8 privacy ;
   u8 bdecrypted ;
   u32 encrypt ;
   u8 iv_len ;
   u8 icv_len ;
   u8 crc_err ;
   u8 icv_err ;
   u16 eth_type ;
   u8 dst[6U] ;
   u8 src[6U] ;
   u8 ta[6U] ;
   u8 ra[6U] ;
   u8 bssid[6U] ;
   u8 ack_policy ;
   u8 tcpchk_valid ;
   u8 ip_chkrpt ;
   u8 tcp_chkrpt ;
   u8 key_index ;
   u8 mcs_rate ;
   u8 rxht ;
   u8 sgi ;
   u8 pkt_rpt_type ;
   u32 MacIDValidEntry[2U] ;
   struct phy_info phy_info ;
};
struct recv_frame {
   struct list_head list ;
   struct sk_buff *pkt ;
   struct rtw_adapter *adapter ;
   struct rx_pkt_attrib attrib ;
   struct sta_info *psta ;
   struct recv_reorder_ctrl *preorder_ctrl ;
};
struct surveydone_event {
   unsigned int bss_cnt ;
};
struct joinbss_event {
   struct wlan_network network ;
};
struct fwevent {
   u32 parmsize ;
   void (*event_callback)(struct rtw_adapter * , u8 const   * ) ;
};
struct rt_channel_plan {
   unsigned char Channel[38U] ;
   unsigned char Len ;
};
struct rt_channel_plan_2g {
   unsigned char Channel[14U] ;
   unsigned char Len ;
};
struct rt_channel_plan_5g {
   unsigned char Channel[24U] ;
   unsigned char Len ;
};
struct rt_channel_plan_map {
   unsigned char Index2G ;
   unsigned char Index5G ;
};
struct mlme_handler {
   char *str ;
   int (*func)(struct rtw_adapter * , struct recv_frame * ) ;
};
struct action_handler {
   unsigned int num ;
   char *str ;
   int (*func)(struct rtw_adapter * , struct recv_frame * ) ;
};
enum hw_mode {
    IEEE80211G = 0,
    IEEE80211A = 1
} ;
enum ldv_34415 {
    BW20 = 0,
    BW40PLUS = 1,
    BW40MINUS = 2
} ;
struct p2p_oper_class_map {
   enum hw_mode mode ;
   u8 op_class ;
   u8 min_chan ;
   u8 max_chan ;
   u8 inc ;
   enum ldv_34415 bw ;
};
struct C2HEvent_Header {
   unsigned short len ;
   unsigned char ID ;
   unsigned char seq ;
   unsigned int rsvd ;
};
typedef int ldv_func_ret_type___14;
typedef int ldv_func_ret_type___15;
typedef int ldv_func_ret_type___16;
typedef int ldv_func_ret_type___17;
typedef int ldv_func_ret_type___18;
typedef int ldv_func_ret_type___19;
typedef int ldv_func_ret_type___20;
typedef int ldv_func_ret_type___21;
typedef int ldv_func_ret_type___22;
typedef int ldv_func_ret_type___23;
typedef int ldv_func_ret_type___24;
enum hrtimer_restart;
enum hrtimer_restart;
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
struct ieee80211_pspoll {
   __le16 frame_control ;
   __le16 aid ;
   u8 bssid[6U] ;
   u8 ta[6U] ;
};
struct recv_buf {
   struct list_head list ;
   struct rtw_adapter *adapter ;
   struct urb *purb ;
   struct sk_buff *pskb ;
};
enum hrtimer_restart;
struct mic_data {
   u32 K0 ;
   u32 K1 ;
   u32 L ;
   u32 R ;
   u32 M ;
   u32 nBytesInM ;
};
struct arc4context {
   u32 x ;
   u32 y ;
   u8 state[256U] ;
};
enum hrtimer_restart;
enum ht_channel_width {
    HT_CHANNEL_WIDTH_20 = 0,
    HT_CHANNEL_WIDTH_40 = 1,
    HT_CHANNEL_WIDTH_80 = 2,
    HT_CHANNEL_WIDTH_160 = 3,
    HT_CHANNEL_WIDTH_10 = 4
} ;
enum WIRELESS_MODE {
    WIRELESS_MODE_UNKNOWN = 0,
    WIRELESS_MODE_A = 4,
    WIRELESS_MODE_B = 1,
    WIRELESS_MODE_G = 2,
    WIRELESS_MODE_AUTO = 32,
    WIRELESS_MODE_N_24G = 8,
    WIRELESS_MODE_N_5G = 16,
    WIRELESS_MODE_AC = 64
} ;
struct bb_reg_define {
   u32 rfintfs ;
   u32 rfintfi ;
   u32 rfintfo ;
   u32 rfintfe ;
   u32 rf3wireOffset ;
   u32 rfLSSI_Select ;
   u32 rfTxGainStage ;
   u32 rfHSSIPara1 ;
   u32 rfHSSIPara2 ;
   u32 rfSwitchControl ;
   u32 rfAGCControl1 ;
   u32 rfAGCControl2 ;
   u32 rfRxIQImbalance ;
   u32 rfRxAFE ;
   u32 rfTxIQImbalance ;
   u32 rfTxAFE ;
   u32 rfLSSIReadBack ;
   u32 rfLSSIReadBackPi ;
};
enum hal_ic_type {
    CHIP_8192S = 0,
    CHIP_8188C = 1,
    CHIP_8192C = 2,
    CHIP_8192D = 3,
    CHIP_8723A = 4,
    CHIP_8188E = 5,
    CHIP_8881A = 6,
    CHIP_8812A = 7,
    CHIP_8821A = 8,
    CHIP_8723B = 9,
    CHIP_8192E = 10
} ;
enum hal_chip_type {
    TEST_CHIP = 0,
    NORMAL_CHIP = 1,
    FPGA = 2
} ;
enum hal_cut_version {
    A_CUT_VERSION = 0,
    B_CUT_VERSION = 1,
    C_CUT_VERSION = 2,
    D_CUT_VERSION = 3,
    E_CUT_VERSION = 4,
    F_CUT_VERSION = 5,
    G_CUT_VERSION = 6
} ;
enum hal_vendor {
    CHIP_VENDOR_TSMC = 0,
    CHIP_VENDOR_UMC = 1
} ;
struct hal_version {
   enum hal_ic_type ICType ;
   enum hal_chip_type ChipType ;
   enum hal_cut_version CUTVersion ;
   enum hal_vendor VendorType ;
   u8 ROMVer ;
};
enum rt_customer_id {
    RT_CID_DEFAULT = 0,
    RT_CID_8187_ALPHA0 = 1,
    RT_CID_8187_SERCOMM_PS = 2,
    RT_CID_8187_HW_LED = 3,
    RT_CID_8187_NETGEAR = 4,
    RT_CID_WHQL = 5,
    RT_CID_819x_CAMEO = 6,
    RT_CID_819x_RUNTOP = 7,
    RT_CID_819x_Senao = 8,
    RT_CID_TOSHIBA = 9,
    RT_CID_819x_Netcore = 10,
    RT_CID_Nettronix = 11,
    RT_CID_DLINK = 12,
    RT_CID_PRONET = 13,
    RT_CID_COREGA = 14,
    RT_CID_CHINA_MOBILE = 15,
    RT_CID_819x_ALPHA = 16,
    RT_CID_819x_Sitecom = 17,
    RT_CID_CCX = 18,
    RT_CID_819x_Lenovo = 19,
    RT_CID_819x_QMI = 20,
    RT_CID_819x_Edimax_Belkin = 21,
    RT_CID_819x_Sercomm_Belkin = 22,
    RT_CID_819x_CAMEO1 = 23,
    RT_CID_819x_MSI = 24,
    RT_CID_819x_Acer = 25,
    RT_CID_819x_AzWave_ASUS = 26,
    RT_CID_819x_AzWave = 27,
    RT_CID_819x_HP = 28,
    RT_CID_819x_WNC_COREGA = 29,
    RT_CID_819x_Arcadyan_Belkin = 30,
    RT_CID_819x_SAMSUNG = 31,
    RT_CID_819x_CLEVO = 32,
    RT_CID_819x_DELL = 33,
    RT_CID_819x_PRONETS = 34,
    RT_CID_819x_Edimax_ASUS = 35,
    RT_CID_819x_CAMEO_NETGEAR = 36,
    RT_CID_PLANEX = 37,
    RT_CID_CC_C = 38,
    RT_CID_819x_Xavi = 39,
    RT_CID_819x_FUNAI_TV = 40,
    RT_CID_819x_ALPHA_WD = 41
} ;
struct sreset_priv {
   struct mutex silentreset_mutex ;
   u8 silent_reset_inprogress ;
   unsigned long last_tx_time ;
   unsigned long last_tx_complete_time ;
};
struct dig_t {
   u8 Dig_Enable_Flag ;
   u8 Dig_Ext_Port_Stage ;
   int RssiLowThresh ;
   int RssiHighThresh ;
   u32 FALowThresh ;
   u32 FAHighThresh ;
   u8 CurSTAConnectState ;
   u8 PreSTAConnectState ;
   u8 CurMultiSTAConnectState ;
   u8 PreIGValue ;
   u8 CurIGValue ;
   u8 BackupIGValue ;
   s8 BackoffVal ;
   s8 BackoffVal_range_max ;
   s8 BackoffVal_range_min ;
   u8 rx_gain_range_max ;
   u8 rx_gain_range_min ;
   u8 Rssi_val_min ;
   u8 PreCCK_CCAThres ;
   u8 CurCCK_CCAThres ;
   u8 PreCCKPDState ;
   u8 CurCCKPDState ;
   u8 LargeFAHit ;
   u8 ForbiddenIGI ;
   u32 Recover_cnt ;
   u8 DIG_Dynamic_MIN_0 ;
   u8 DIG_Dynamic_MIN_1 ;
   bool bMediaConnect_0 ;
   bool bMediaConnect_1 ;
   u32 RSSI_max ;
};
struct dynamic_pwr_sav {
   u8 PreCCAState ;
   u8 CurCCAState ;
   u8 PreRFState ;
   u8 CurRFState ;
   int Rssi_val_min ;
   u8 initialize ;
   u32 Reg874 ;
   u32 RegC70 ;
   u32 Reg85C ;
   u32 RegA74 ;
};
struct false_alarm_stats {
   u32 Cnt_Parity_Fail ;
   u32 Cnt_Rate_Illegal ;
   u32 Cnt_Crc8_fail ;
   u32 Cnt_Mcs_fail ;
   u32 Cnt_Ofdm_fail ;
   u32 Cnt_Cck_fail ;
   u32 Cnt_all ;
   u32 Cnt_Fast_Fsync ;
   u32 Cnt_SB_Search_fail ;
   u32 Cnt_OFDM_CCA ;
   u32 Cnt_CCK_CCA ;
   u32 Cnt_CCA_all ;
   u32 Cnt_BW_USC ;
   u32 Cnt_BW_LSC ;
};
struct sw_ant_sw {
   u8 try_flag ;
   s32 PreRSSI ;
   u8 CurAntenna ;
   u8 PreAntenna ;
   u8 RSSI_Trying ;
   u8 TestMode ;
   u8 bTriggerAntennaSwitch ;
   u8 SelectAntennaMap ;
   u8 RSSI_target ;
   u8 SWAS_NoLink_State ;
   u32 SWAS_NoLink_BK_Reg860 ;
   bool ANTA_ON ;
   bool ANTB_ON ;
   s32 RSSI_sum_A ;
   s32 RSSI_sum_B ;
   s32 RSSI_cnt_A ;
   s32 RSSI_cnt_B ;
   u64 lastTxOkCnt ;
   u64 lastRxOkCnt ;
   u64 TXByteCnt_A ;
   u64 TXByteCnt_B ;
   u64 RXByteCnt_A ;
   u64 RXByteCnt_B ;
   u8 TrafficLoad ;
};
struct edca_turbo {
   bool bCurrentTurboEDCA ;
   u32 prv_traffic_idx ;
};
struct odm_rate_adapt {
   u8 Type ;
   u8 HighRSSIThresh ;
   u8 LowRSSIThresh ;
   u8 RATRState ;
   u32 LastRATR ;
};
struct odm_phy_dbg_info {
   s8 RxSNRdB[2U] ;
   u64 NumQryPhyStatus ;
   u64 NumQryPhyStatusCCK ;
   u64 NumQryPhyStatusOFDM ;
   s32 RxEVM[2U] ;
};
struct iqk_matrix_regs_set {
   bool bIQKDone ;
   s32 Value[1U][8U] ;
};
struct odm_rf_cal_t {
   u32 RegA24 ;
   s32 RegE94 ;
   s32 RegE9C ;
   s32 RegEB4 ;
   s32 RegEBC ;
   u8 TXPowercount ;
   bool bTXPowerTrackingInit ;
   bool bTXPowerTracking ;
   u8 TxPowerTrackControl ;
   u8 TM_Trigger ;
   u8 InternalPA5G[2U] ;
   u8 ThermalMeter[2U] ;
   u8 ThermalValue ;
   u8 ThermalValue_LCK ;
   u8 ThermalValue_IQK ;
   u8 ThermalValue_DPK ;
   u8 ThermalValue_AVG[8U] ;
   u8 ThermalValue_AVG_index ;
   u8 ThermalValue_RxGain ;
   u8 ThermalValue_Crystal ;
   u8 ThermalValue_DPKstore ;
   u8 ThermalValue_DPKtrack ;
   bool TxPowerTrackingInProgress ;
   bool bDPKenable ;
   bool bReloadtxpowerindex ;
   u8 bRfPiEnable ;
   u32 TXPowerTrackingCallbackCnt ;
   u8 bCCKinCH14 ;
   u8 CCK_index ;
   u8 OFDM_index[2U] ;
   bool bDoneTxpower ;
   u8 ThermalValue_HP[8U] ;
   u8 ThermalValue_HP_index ;
   struct iqk_matrix_regs_set IQKMatrixRegSetting[46U] ;
   u8 Delta_IQK ;
   u8 Delta_LCK ;
   u32 RegC04 ;
   u32 Reg874 ;
   u32 RegC08 ;
   u32 RegB68 ;
   u32 RegB6C ;
   u32 Reg870 ;
   u32 Reg860 ;
   u32 Reg864 ;
   bool bIQKInitialized ;
   bool bLCKInProgress ;
   bool bAntennaDetected ;
   u32 ADDA_backup[16U] ;
   u32 IQK_MAC_backup[4U] ;
   u32 IQK_BB_backup_recover[9U] ;
   u32 IQK_BB_backup[9U] ;
   u32 APKoutput[2U][2U] ;
   u8 bAPKdone ;
   u8 bAPKThermalMeterIgnore ;
   u8 bDPdone ;
   u8 bDPPathAOK ;
   u8 bDPPathBOK ;
};
struct dm_odm_t {
   struct rtw_adapter *Adapter ;
   u64 DebugComponents ;
   u32 DebugLevel ;
   bool bCckHighPower ;
   u8 RFPathRxEnable ;
   u32 SupportAbility ;
   u32 SupportICType ;
   u8 CutVersion ;
   u8 FabVersion ;
   u8 BoardType ;
   u8 ExtLNA ;
   u8 ExtPA ;
   u8 ExtTRSW ;
   bool bInHctTest ;
   bool bWIFITest ;
   bool bDualMacSmartConcurrent ;
   u32 BK_SupportAbility ;
   u8 u8_temp ;
   bool bool_temp ;
   struct rtw_adapter *PADAPTER_temp ;
   bool bWIFI_Direct ;
   bool bWIFI_Display ;
   bool bLinked ;
   u8 RSSI_Min ;
   u8 InterfaceIndex ;
   bool bIsMPChip ;
   bool bOneEntryOnly ;
   bool bBtDisabled ;
   bool bBtHsOperation ;
   u8 btHsDigVal ;
   bool bBtDisableEdcaTurbo ;
   bool bBtBusy ;
   struct sta_info *pODM_StaInfo[32U] ;
   struct odm_phy_dbg_info PhyDbgInfo ;
   struct dig_t DM_DigTable ;
   struct dynamic_pwr_sav DM_PSTable ;
   struct false_alarm_stats FalseAlmCnt ;
   struct false_alarm_stats FlaseAlmCntBuddyAdapter ;
   struct sw_ant_sw DM_SWAT_Table ;
   struct edca_turbo DM_EDCA_Table ;
   u32 WMMEDCA_BE ;
   u8 RSSI_BT ;
   struct odm_rate_adapt RateAdaptive ;
   struct odm_rf_cal_t RFCalibrateInfo ;
};
struct hal_data_8723a;
struct octet_string {
   u8 *Octet ;
   u16 Length ;
};
enum hci_status {
    HCI_STATUS_SUCCESS = 0,
    HCI_STATUS_UNKNOW_HCI_CMD = 1,
    HCI_STATUS_UNKNOW_CONNECT_ID = 2,
    HCI_STATUS_HW_FAIL = 3,
    HCI_STATUS_PAGE_TIMEOUT = 4,
    HCI_STATUS_AUTH_FAIL = 5,
    HCI_STATUS_PIN_OR_KEY_MISSING = 6,
    HCI_STATUS_MEM_CAP_EXCEED = 7,
    HCI_STATUS_CONNECT_TIMEOUT = 8,
    HCI_STATUS_CONNECT_LIMIT = 9,
    HCI_STATUS_SYN_CONNECT_LIMIT = 10,
    HCI_STATUS_ACL_CONNECT_EXISTS = 11,
    HCI_STATUS_CMD_DISALLOW = 12,
    HCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE = 13,
    HCI_STATUS_CONNECT_RJT_SEC_REASON = 14,
    HCI_STATUS_CONNECT_RJT_UNACCEPT_BD_ADDR = 15,
    HCI_STATUS_CONNECT_ACCEPT_TIMEOUT = 16,
    HCI_STATUS_UNSUPPORT_FEATURE_PARA_VALUE = 17,
    HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE = 18,
    HCI_STATUS_REMOTE_USER_TERMINATE_CONNECT = 19,
    HCI_STATUS_REMOTE_DEV_TERMINATE_LOW_RESOURCE = 20,
    HCI_STATUS_REMOTE_DEV_TERMINATE_CONNECT_POWER_OFF = 21,
    HCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST = 22,
    HCI_STATUS_REPEATE_ATTEMPT = 23,
    HCI_STATUS_PAIR_NOT_ALLOW = 24,
    HCI_STATUS_UNKNOW_LMP_PDU = 25,
    HCI_STATUS_UNSUPPORT_REMOTE_LMP_FEATURE = 26,
    HCI_STATUS_SOC_OFFSET_REJECT = 27,
    HCI_STATUS_SOC_INTERVAL_REJECT = 28,
    HCI_STATUS_SOC_AIR_MODE_REJECT = 29,
    HCI_STATUS_INVALID_LMP_PARA = 30,
    HCI_STATUS_UNSPECIFIC_ERROR = 31,
    HCI_STATUS_UNSUPPORT_LMP_PARA_VALUE = 32,
    HCI_STATUS_ROLE_CHANGE_NOT_ALLOW = 33,
    HCI_STATUS_LMP_RESPONSE_TIMEOUT = 34,
    HCI_STATUS_LMP_ERROR_TRANSACTION_COLLISION = 35,
    HCI_STATUS_LMP_PDU_NOT_ALLOW = 36,
    HCI_STATUS_ENCRYPTION_MODE_NOT_ALLOW = 37,
    HCI_STATUS_LINK_KEY_CAN_NOT_CHANGE = 38,
    HCI_STATUS_REQUEST_QOS_NOT_SUPPORT = 39,
    HCI_STATUS_INSTANT_PASSED = 40,
    HCI_STATUS_PAIRING_UNIT_KEY_NOT_SUPPORT = 41,
    HCI_STATUS_DIFFERENT_TRANSACTION_COLLISION = 42,
    HCI_STATUS_RESERVE_1 = 43,
    HCI_STATUS_QOS_UNACCEPT_PARA = 44,
    HCI_STATUS_QOS_REJECT = 45,
    HCI_STATUS_CHNL_CLASSIFICATION_NOT_SUPPORT = 46,
    HCI_STATUS_INSUFFICIENT_SECURITY = 47,
    HCI_STATUS_PARA_OUT_OF_RANGE = 48,
    HCI_STATUS_RESERVE_2 = 49,
    HCI_STATUS_ROLE_SWITCH_PENDING = 50,
    HCI_STATUS_RESERVE_3 = 51,
    HCI_STATUS_RESERVE_SOLT_VIOLATION = 52,
    HCI_STATUS_ROLE_SWITCH_FAIL = 53,
    HCI_STATUS_EXTEND_INQUIRY_RSP_TOO_LARGE = 54,
    HCI_STATUS_SEC_SIMPLE_PAIRING_NOT_SUPPORT = 55,
    HCI_STATUS_HOST_BUSY_PAIRING = 56,
    HCI_STATUS_CONNECT_REJ_NOT_SUIT_CHNL_FOUND = 57,
    HCI_STATUS_CONTROLLER_BUSY = 58
} ;
enum amp_btap_type {
    AMP_BTAP_NONE = 0,
    AMP_BTAP_CREATOR = 1,
    AMP_BTAP_JOINER = 2
} ;
enum bt_connect_type {
    BT_CONNECT_AUTH_REQ = 0,
    BT_CONNECT_AUTH_RSP = 1,
    BT_CONNECT_ASOC_REQ = 2,
    BT_CONNECT_ASOC_RSP = 3,
    BT_DISCONNECT = 4
} ;
enum bt_state_wpa_auth {
    STATE_WPA_AUTH_UNINITIALIZED = 0,
    STATE_WPA_AUTH_WAIT_PACKET_1 = 1,
    STATE_WPA_AUTH_WAIT_PACKET_2 = 2,
    STATE_WPA_AUTH_WAIT_PACKET_3 = 3,
    STATE_WPA_AUTH_WAIT_PACKET_4 = 4,
    STATE_WPA_AUTH_SUCCESSED = 5
} ;
struct hci_flow_spec {
   u8 Identifier ;
   u8 ServiceType ;
   u16 MaximumSDUSize ;
   u32 SDUInterArrivalTime ;
   u32 AccessLatency ;
   u32 FlushTimeout ;
};
struct hci_log_link_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 BtLogLinkhandle ;
   u8 BtTxFlowSpecID ;
   struct hci_flow_spec Tx_Flow_Spec ;
   struct hci_flow_spec Rx_Flow_Spec ;
   u32 TxPacketCount ;
   u32 BestEffortFlushTimeout ;
   u8 bLLCompleteEventIsSet ;
   u8 bLLCancelCMDIsSetandComplete ;
};
struct hci_phy_link_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 LinkSuperversionTimeout ;
   u8 BtAMPKeyLen ;
   u8 BtAMPKeyType ;
   u8 BtAMPKey[32U] ;
};
struct amp_assoc_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 LenSoFar ;
   u16 MaxRemoteASSOCLen ;
   u16 AMPAssocRemLen ;
   void *AMPAssocfragment ;
};
struct hci_link_info {
   u16 ConnectHandle ;
   u8 IncomingTrafficMode ;
   u8 OutgoingTrafficMode ;
   u8 BTProfile ;
   u8 BTCoreSpec ;
   s8 BT_RSSI ;
   u8 TrafficProfile ;
   u8 linkRole ;
};
struct hci_ext_config {
   struct hci_link_info linkInfo[2U] ;
   u8 btOperationCode ;
   u16 CurrentConnectHandle ;
   u8 CurrentIncomingTrafficMode ;
   u8 CurrentOutgoingTrafficMode ;
   s8 MIN_BT_RSSI ;
   u8 NumberOfHandle ;
   u8 NumberOfSCO ;
   u8 CurrentBTStatus ;
   u16 HCIExtensionVer ;
   u8 btProfileCase ;
   u8 btProfileAction ;
   u8 bManualControl ;
   u8 bBTBusy ;
   u8 bBTA2DPBusy ;
   u8 bEnableWifiScanNotify ;
   u8 bHoldForBtOperation ;
   u32 bHoldPeriodCnt ;
};
struct hci_acl_packet_data {
   u16 ACLDataPacketLen ;
   u8 SyncDataPacketLen ;
   u16 TotalNumACLDataPackets ;
   u16 TotalSyncNumDataPackets ;
};
struct hci_phy_link_bss_info {
   u16 bdCap ;
};
struct bt_asoc_entry {
   u8 bUsed ;
   u8 mAssoc ;
   u8 b4waySuccess ;
   u8 Bssid[6U] ;
   struct hci_phy_link_cmd_data PhyLinkCmdData ;
   struct hci_log_link_cmd_data LogLinkCmdData[2U] ;
   struct hci_acl_packet_data ACLPacketsData ;
   struct amp_assoc_cmd_data AmpAsocCmdData ;
   struct octet_string BTSsid ;
   u8 BTSsidBuf[33U] ;
   enum hci_status PhyLinkDisconnectReason ;
   u8 bSendSupervisionPacket ;
   u32 NoRxPktCnt ;
   enum amp_btap_type AMPRole ;
   u8 BtCurrentState ;
   u8 BtNextState ;
   u8 bNeedPhysLinkCompleteEvent ;
   enum hci_status PhysLinkCompleteStatus ;
   u8 BTRemoteMACAddr[6U] ;
   u32 BTCapability ;
   u8 SyncDataPacketLen ;
   u16 TotalSyncNumDataPackets ;
   u16 TotalNumACLDataPackets ;
   u8 ShortRangeMode ;
   u8 PTK[64U] ;
   u8 GTK[32U] ;
   u8 ANonce[32U] ;
   u8 SNonce[32U] ;
   u64 KeyReplayCounter ;
   u8 WPAAuthReplayCount ;
   u8 AESKeyBuf[256U] ;
   u8 PMK[32U] ;
   enum bt_state_wpa_auth BTWPAAuthState ;
   s32 UndecoratedSmoothedPWDB ;
   u8 HwCAMIndex ;
   u8 bPeerQosSta ;
   u32 rxSuvpPktCnt ;
};
struct bt_traffic_statistics {
   u8 bTxBusyTraffic ;
   u8 bRxBusyTraffic ;
   u8 bIdle ;
   u32 TxPktCntInPeriod ;
   u32 RxPktCntInPeriod ;
   u64 TxPktLenInPeriod ;
   u64 RxPktLenInPeriod ;
};
struct bt_mgnt {
   u8 bBTConnectInProgress ;
   u8 bLogLinkInProgress ;
   u8 bPhyLinkInProgress ;
   u8 bPhyLinkInProgressStartLL ;
   u8 BtCurrentPhyLinkhandle ;
   u16 BtCurrentLogLinkhandle ;
   u8 CurrentConnectEntryNum ;
   u8 DisconnectEntryNum ;
   u8 CurrentBTConnectionCnt ;
   enum bt_connect_type BTCurrentConnectType ;
   enum bt_connect_type BTReceiveConnectPkt ;
   u8 BTAuthCount ;
   u8 BTAsocCount ;
   u8 bStartSendSupervisionPkt ;
   u8 BtOperationOn ;
   u8 BTNeedAMPStatusChg ;
   u8 JoinerNeedSendAuth ;
   struct hci_phy_link_bss_info bssDesc ;
   struct hci_ext_config ExtConfig ;
   u8 bNeedNotifyAMPNoCap ;
   u8 bCreateSpportQos ;
   u8 bSupportProfile ;
   u8 BTChannel ;
   u8 CheckChnlIsSuit ;
   u8 bBtScan ;
   u8 btLogoTest ;
};
struct bt_hci_dgb_info {
   u32 hciCmdCnt ;
   u32 hciCmdCntUnknown ;
   u32 hciCmdCntCreatePhyLink ;
   u32 hciCmdCntAcceptPhyLink ;
   u32 hciCmdCntDisconnectPhyLink ;
   u32 hciCmdPhyLinkStatus ;
   u32 hciCmdCntCreateLogLink ;
   u32 hciCmdCntAcceptLogLink ;
   u32 hciCmdCntDisconnectLogLink ;
   u32 hciCmdCntReadLocalAmpAssoc ;
   u32 hciCmdCntWriteRemoteAmpAssoc ;
   u32 hciCmdCntSetAclLinkStatus ;
   u32 hciCmdCntSetScoLinkStatus ;
   u32 hciCmdCntExtensionVersionNotify ;
   u32 hciCmdCntLinkStatusNotify ;
};
struct bt_irp_dgb_info {
   u32 irpMJCreate ;
   u32 irpIoControl ;
   u32 irpIoCtrlHciCmd ;
   u32 irpIoCtrlHciEvent ;
   u32 irpIoCtrlHciTxData ;
   u32 irpIoCtrlHciRxData ;
   u32 irpIoCtrlUnknown ;
   u32 irpIoCtrlHciTxData1s ;
};
struct bt_packet_dgb_info {
   u32 btPktTxProbReq ;
   u32 btPktRxProbReq ;
   u32 btPktRxProbReqFail ;
   u32 btPktTxProbRsp ;
   u32 btPktRxProbRsp ;
   u32 btPktTxAuth ;
   u32 btPktRxAuth ;
   u32 btPktRxAuthButDrop ;
   u32 btPktTxAssocReq ;
   u32 btPktRxAssocReq ;
   u32 btPktRxAssocReqButDrop ;
   u32 btPktTxAssocRsp ;
   u32 btPktRxAssocRsp ;
   u32 btPktTxDisassoc ;
   u32 btPktRxDisassoc ;
   u32 btPktRxDeauth ;
   u32 btPktTx4way1st ;
   u32 btPktRx4way1st ;
   u32 btPktTx4way2nd ;
   u32 btPktRx4way2nd ;
   u32 btPktTx4way3rd ;
   u32 btPktRx4way3rd ;
   u32 btPktTx4way4th ;
   u32 btPktRx4way4th ;
   u32 btPktTxLinkSuperReq ;
   u32 btPktRxLinkSuperReq ;
   u32 btPktTxLinkSuperRsp ;
   u32 btPktRxLinkSuperRsp ;
   u32 btPktTxData ;
   u32 btPktRxData ;
};
struct bt_dgb {
   u8 dbgCtrl ;
   u32 dbgProfile ;
   struct bt_hci_dgb_info dbgHciInfo ;
   struct bt_irp_dgb_info dbgIrpInfo ;
   struct bt_packet_dgb_info dbgBtPkt ;
};
struct bt_hci_info {
   u8 BTPalVersion ;
   u16 BTPalCompanyID ;
   u16 BTPalsubversion ;
   u16 BTConnectChnlListLen ;
   u8 BTConnectChnllist[64U] ;
   u16 FailContactCount ;
   u64 BTEventMask ;
   u64 BTEventMaskPage2 ;
   u16 ConnAcceptTimeout ;
   u16 LogicalAcceptTimeout ;
   u16 PageTimeout ;
   u8 LocationDomainAware ;
   u16 LocationDomain ;
   u8 LocationDomainOptions ;
   u8 LocationOptions ;
   u8 FlowControlMode ;
   u16 BtPreChnlListLen ;
   u8 BTPreChnllist[64U] ;
   u16 enFlush_LLH ;
   u16 FLTO_LLH ;
   u8 bInTestMode ;
   u8 bTestIsEnd ;
   u8 bTestNeedReport ;
   u8 TestScenario ;
   u8 TestReportInterval ;
   u8 TestCtrType ;
   u32 TestEventType ;
   u16 TestNumOfFrame ;
   u16 TestNumOfErrFrame ;
   u16 TestNumOfBits ;
   u16 TestNumOfErrBits ;
};
struct bt_traffic {
   u8 LastRxUniFragNum ;
   u16 LastRxUniSeqNum ;
   struct bt_traffic_statistics Bt30TrafficStatistics ;
};
struct bt_security {
   struct octet_string RSNIE ;
   u8 RSNIEBuf[256U] ;
   u8 bRegNoEncrypt ;
   u8 bUsedHwEncrypt ;
};
struct bt_30info {
   struct rtw_adapter *padapter ;
   struct bt_asoc_entry BtAsocEntry[2U] ;
   struct bt_mgnt BtMgnt ;
   struct bt_dgb BtDbg ;
   struct bt_hci_info BtHciInfo ;
   struct bt_traffic BtTraffic ;
   struct bt_security BtSec ;
   struct work_struct HCICmdWorkItem ;
   struct timer_list BTHCICmdTimer ;
   struct work_struct BTPsDisableWorkItem ;
   struct work_struct BTConnectWorkItem ;
   struct timer_list BTHCIDiscardAclDataTimer ;
   struct timer_list BTHCIJoinTimeoutTimer ;
   struct timer_list BTTestSendPacketTimer ;
   struct timer_list BTDisconnectPhyLinkTimer ;
   struct timer_list BTBeaconTimer ;
   u8 BTBeaconTmrOn ;
   struct timer_list BTPsDisableTimer ;
   void *pBtChnlList ;
};
struct btdm_8723a_1ant {
   u8 prePsTdma ;
   u8 curPsTdma ;
   u8 psTdmaDuAdjType ;
   u8 bPrePsTdmaOn ;
   u8 bCurPsTdmaOn ;
   u8 preWifiPara ;
   u8 curWifiPara ;
   u8 preCoexWifiCon ;
   u8 curCoexWifiCon ;
   u8 wifiRssiThresh ;
   u32 psTdmaMonitorCnt ;
   u32 psTdmaGlobalCnt ;
   u32 psTdmaMonitorCntForSCO ;
   u8 psTdmaDuAdjTypeForSCO ;
   u8 RSSI_WiFi_Last ;
   u8 RSSI_BT_Last ;
   u8 bWiFiHalt ;
   u8 bRAChanged ;
};
struct btdm_8723a_2ant {
   u8 bPreDecBtPwr ;
   u8 bCurDecBtPwr ;
   u8 preWlanActHi ;
   u8 curWlanActHi ;
   u8 preWlanActLo ;
   u8 curWlanActLo ;
   u8 preFwDacSwingLvl ;
   u8 curFwDacSwingLvl ;
   u8 bPreRfRxLpfShrink ;
   u8 bCurRfRxLpfShrink ;
   u8 bPreLowPenaltyRa ;
   u8 bCurLowPenaltyRa ;
   u8 preBtRetryIndex ;
   u8 curBtRetryIndex ;
   u8 bPreDacSwingOn ;
   u32 preDacSwingLvl ;
   u8 bCurDacSwingOn ;
   u32 curDacSwingLvl ;
   u8 bPreAdcBackOff ;
   u8 bCurAdcBackOff ;
   u8 bPreAgcTableEn ;
   u8 bCurAgcTableEn ;
   u32 preVal0x6c0 ;
   u32 curVal0x6c0 ;
   u32 preVal0x6c8 ;
   u32 curVal0x6c8 ;
   u8 preVal0x6cc ;
   u8 curVal0x6cc ;
   u8 bCurIgnoreWlanAct ;
   u8 bPreIgnoreWlanAct ;
   u8 prePsTdma ;
   u8 curPsTdma ;
   u8 psTdmaDuAdjType ;
   u8 bPrePsTdmaOn ;
   u8 bCurPsTdmaOn ;
   u8 preAlgorithm ;
   u8 curAlgorithm ;
   u8 bResetTdmaAdjust ;
   u8 btStatus ;
};
struct bt_coexist_8723a {
   u32 highPriorityTx ;
   u32 highPriorityRx ;
   u32 lowPriorityTx ;
   u32 lowPriorityRx ;
   u8 btRssi ;
   u8 TotalAntNum ;
   u8 bC2hBtInfoSupport ;
   u8 c2hBtInfo ;
   u8 c2hBtInfoOriginal ;
   u8 prec2hBtInfo ;
   u8 bC2hBtInquiryPage ;
   unsigned long btInqPageStartTime ;
   u8 c2hBtProfile ;
   u8 btRetryCnt ;
   u8 btInfoExt ;
   u8 bC2hBtInfoReqSent ;
   u8 bForceFwBtInfo ;
   u8 bForceA2dpSink ;
   struct btdm_8723a_2ant btdm2Ant ;
   struct btdm_8723a_1ant btdm1Ant ;
};
struct bt_coexist_str {
   u8 BluetoothCoexist ;
   u8 BT_Ant_Num ;
   u8 BT_CoexistType ;
   u8 BT_Ant_isolation ;
   u8 bt_radiosharedtype ;
   u32 Ratio_Tx ;
   u32 Ratio_PRI ;
   u8 bInitlized ;
   u32 BtRfRegOrigin1E ;
   u32 BtRfRegOrigin1F ;
   u8 bBTBusyTraffic ;
   u8 bBTTrafficModeSet ;
   u8 bBTNonTrafficModeSet ;
   struct bt_traffic_statistics BT21TrafficStatistics ;
   u64 CurrentState ;
   u64 PreviousState ;
   u8 preRssiState ;
   u8 preRssiState1 ;
   u8 preRssiStateBeacon ;
   u8 bFWCoexistAllOff ;
   u8 bSWCoexistAllOff ;
   u8 bHWCoexistAllOff ;
   u8 bBalanceOn ;
   u8 bSingleAntOn ;
   u8 bInterruptOn ;
   u8 bMultiNAVOn ;
   u8 PreWLANActH ;
   u8 PreWLANActL ;
   u8 WLANActH ;
   u8 WLANActL ;
   u8 A2DPState ;
   u8 AntennaState ;
   u32 lastBtEdca ;
   u16 last_aggr_num ;
   u8 bEDCAInitialized ;
   u8 exec_cnt ;
   u8 b8723aAgcTableOn ;
   u8 b92DAgcTableOn ;
   struct bt_coexist_8723a halCoex8723 ;
   u8 btActiveZeroCnt ;
   u8 bCurBtDisabled ;
   u8 bPreBtDisabled ;
   u8 bNeedToRoamForBtDisableEnable ;
   u8 fw3aVal[5U] ;
};
struct dm_priv {
   u32 InitODMFlag ;
   int UndecoratedSmoothedPWDB ;
   int UndecoratedSmoothedCCK ;
   int EntryMinUndecoratedSmoothedPWDB ;
   int EntryMaxUndecoratedSmoothedPWDB ;
   int MinUndecoratedPWDBForDM ;
   int LastMinUndecoratedPWDBForDM ;
   s32 UndecoratedSmoothedBeacon ;
   s32 BT_EntryMinUndecoratedSmoothedPWDB ;
   s32 BT_EntryMaxUndecoratedSmoothedPWDB ;
   u8 DynamicTxHighPowerLvl ;
   u8 bTXPowerTracking ;
   u8 TXPowercount ;
   u8 bTXPowerTrackingInit ;
   u8 TxPowerTrackControl ;
   u8 TM_Trigger ;
   u8 ThermalMeter[2U] ;
   u8 ThermalValue ;
   u8 ThermalValue_LCK ;
   u8 ThermalValue_IQK ;
   u8 ThermalValue_DPK ;
   u8 bRfPiEnable ;
   u32 APKoutput[2U][2U] ;
   u8 bAPKdone ;
   u8 bAPKThermalMeterIgnore ;
   u8 bDPdone ;
   u8 bDPPathAOK ;
   u8 bDPPathBOK ;
   u32 RegC04 ;
   u32 Reg874 ;
   u32 RegC08 ;
   u32 RegB68 ;
   u32 RegB6C ;
   u32 Reg870 ;
   u32 Reg860 ;
   u32 Reg864 ;
   u32 ADDA_backup[16U] ;
   u32 IQK_MAC_backup[4U] ;
   u32 IQK_BB_backup_recover[9U] ;
   u32 IQK_BB_backup[9U] ;
   u8 PowerIndex_backup[6U] ;
   u8 bCCKinCH14 ;
   u8 CCK_index ;
   u8 OFDM_index[2U] ;
   u8 bDoneTxpower ;
   u8 CCK_index_HP ;
   u8 OFDM_index_HP[2U] ;
   u8 ThermalValue_HP[8U] ;
   u8 ThermalValue_HP_index ;
   s32 RegE94 ;
   s32 RegE9C ;
   s32 RegEB4 ;
   s32 RegEBC ;
   u32 TXPowerTrackingCallbackCnt ;
   u32 prv_traffic_idx ;
   s32 OFDM_Pkt_Cnt ;
   u8 RSSI_Select ;
   u8 INIDATA_RATE[32U] ;
};
enum RT_MULTI_FUNC {
    RT_MULTI_FUNC_NONE = 0,
    RT_MULTI_FUNC_WIFI = 1,
    RT_MULTI_FUNC_BT = 2,
    RT_MULTI_FUNC_GPS = 4
} ;
enum RT_POLARITY_CTL {
    RT_POLARITY_LOW_ACT = 0,
    RT_POLARITY_HIGH_ACT = 1
} ;
enum RT_REGULATOR_MODE {
    RT_SWITCHING_REGULATOR = 0,
    RT_LDO_REGULATOR = 1
} ;
struct hal_data_8723a {
   struct hal_version VersionID ;
   enum rt_customer_id CustomerID ;
   u16 FirmwareVersion ;
   u16 FirmwareVersionRev ;
   u16 FirmwareSubVersion ;
   u16 FirmwareSignature ;
   u32 ReceiveConfig ;
   enum WIRELESS_MODE CurrentWirelessMode ;
   enum ht_channel_width CurrentChannelBW ;
   u8 CurrentChannel ;
   u8 nCur40MhzPrimeSC ;
   u16 BasicRateSet ;
   u8 rf_type ;
   u8 NumTotalRFPath ;
   u8 BoardType ;
   u8 CrystalCap ;
   u8 EEPROMVersion ;
   u8 EEPROMCustomerID ;
   u8 EEPROMSubCustomerID ;
   u8 EEPROMRegulatory ;
   u8 EEPROMThermalMeter ;
   u8 EEPROMBluetoothCoexist ;
   u8 EEPROMBluetoothType ;
   u8 EEPROMBluetoothAntNum ;
   u8 EEPROMBluetoothAntIsolation ;
   u8 EEPROMBluetoothRadioShared ;
   u8 bTXPowerDataReadFromEEPORM ;
   u8 bAPKThermalMeterIgnore ;
   u8 bIQKInitialized ;
   u8 bAntennaDetected ;
   u8 TxPwrLevelCck[2U][14U] ;
   u8 TxPwrLevelHT40_1S[2U][14U] ;
   u8 TxPwrLevelHT40_2S[2U][14U] ;
   u8 TxPwrHt20Diff[2U][14U] ;
   u8 TxPwrLegacyHtDiff[2U][14U] ;
   u8 PwrGroupHT20[2U][14U] ;
   u8 PwrGroupHT40[2U][14U] ;
   u8 LegacyHTTxPowerDiff ;
   u8 framesync ;
   u32 framesyncC34 ;
   u8 framesyncMonitor ;
   u8 pwrGroupCnt ;
   u32 MCSTxPowerLevelOriginalOffset[7U][16U] ;
   u32 CCKTxPowerLevelOriginalOffset ;
   u32 AntennaTxPath ;
   u32 AntennaRxPath ;
   u8 ExternalPA ;
   u8 bLedOpenDrain ;
   u8 b1x1RecvCombine ;
   u32 AcParam_BE ;
   u8 CurrentCckTxPwrIdx ;
   u8 CurrentOfdm24GTxPwrIdx ;
   struct bb_reg_define PHYRegDef[4U] ;
   bool bRFPathRxEnable[4U] ;
   u32 RfRegChnlVal[2U] ;
   u8 bCckHighPower ;
   bool bRDGEnable ;
   u8 LastHMEBoxNum ;
   u8 RegTxPause ;
   u8 RegFwHwTxQCtrl ;
   u8 RegReg542 ;
   struct dm_priv dmpriv ;
   struct dm_odm_t odmpriv ;
   struct sreset_priv srestpriv ;
   u8 bBTMode ;
   struct bt_30info BtInfo ;
   struct bt_coexist_str bt_coexist ;
   u8 bDumpRxPkt ;
   u8 FwRsvdPageStartOffset ;
   u8 pwrdown ;
   u8 OutEpQueueSel ;
   u8 OutEpNumber ;
   u8 EepromOrEfuse ;
   u16 EfuseUsedBytes ;
   u16 BTEfuseUsedBytes ;
   u32 SysIntrStatus ;
   u32 SysIntrMask ;
   enum RT_MULTI_FUNC MultiFunc ;
   enum RT_POLARITY_CTL PolarityCtl ;
   enum RT_REGULATOR_MODE RegulatorMode ;
   u32 IntArray[2U] ;
   u32 IntrMask[2U] ;
};
enum hrtimer_restart;
typedef __u16 __sum16;
enum hrtimer_restart;
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct wlan_pwr_cfg {
   u16 offset ;
   u8 cut_msk ;
   unsigned char fab_msk : 4 ;
   unsigned char interface_msk : 4 ;
   unsigned char base : 4 ;
   unsigned char cmd : 4 ;
   u8 msk ;
   u8 value ;
};
enum hrtimer_restart;
enum RF_RADIO_PATH {
    RF_PATH_A = 0,
    RF_PATH_B = 1,
    RF_PATH_MAX = 2
} ;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct va_list;

typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct va_format {
   char const   *fmt ;
   va_list *va ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct odm_packet_info {
   u8 Rate ;
   u8 StationID ;
   bool bPacketMatchBSSID ;
   bool bPacketToSelf ;
   bool bPacketBeacon ;
};
struct phy_rx_agc_info {
   unsigned char gain : 7 ;
   unsigned char trsw : 1 ;
};
struct phy_status_rpt {
   struct phy_rx_agc_info path_agc[2U] ;
   u8 ch_corr[2U] ;
   u8 cck_sig_qual_ofdm_pwdb_all ;
   u8 cck_agc_rpt_ofdm_cfosho_a ;
   u8 cck_rpt_b_ofdm_cfosho_b ;
   u8 rsvd_1 ;
   u8 noise_power_db_msb ;
   u8 path_cfotail[2U] ;
   u8 pcts_mask[2U] ;
   s8 stream_rxevm[2U] ;
   u8 path_rxsnr[2U] ;
   u8 noise_power_db_lsb ;
   u8 rsvd_2[3U] ;
   u8 stream_csi[2U] ;
   u8 stream_target_csi[2U] ;
   s8 sig_evm ;
   u8 rsvd_3 ;
   unsigned char antsel_rx_keep_2 : 1 ;
   unsigned char sgi_en : 1 ;
   unsigned char rxsc : 2 ;
   unsigned char idle_long : 1 ;
   unsigned char r_ant_train_en : 1 ;
   unsigned char ant_sel_b : 1 ;
   unsigned char ant_sel : 1 ;
};
enum hrtimer_restart;
enum odm_cmninfo {
    ODM_CMNINFO_MP_TEST_CHIP = 2,
    ODM_CMNINFO_IC_TYPE = 3,
    ODM_CMNINFO_CUT_VER = 4,
    ODM_CMNINFO_FAB_VER = 5,
    ODM_CMNINFO_BOARD_TYPE = 6,
    ODM_CMNINFO_EXT_LNA = 7,
    ODM_CMNINFO_EXT_PA = 8,
    ODM_CMNINFO_EXT_TRSW = 9,
    ODM_CMNINFO_BINHCT_TEST = 10,
    ODM_CMNINFO_BWIFI_TEST = 11,
    ODM_CMNINFO_SMART_CONCURRENT = 12,
    ODM_CMNINFO_MP_MODE = 13,
    ODM_CMNINFO_WIFI_DIRECT = 14,
    ODM_CMNINFO_WIFI_DISPLAY = 15,
    ODM_CMNINFO_LINK = 16,
    ODM_CMNINFO_RSSI_MIN = 17,
    ODM_CMNINFO_DBG_COMP = 18,
    ODM_CMNINFO_DBG_LEVEL = 19,
    ODM_CMNINFO_RA_THRESHOLD_HIGH = 20,
    ODM_CMNINFO_RA_THRESHOLD_LOW = 21,
    ODM_CMNINFO_RF_ANTENNA_TYPE = 22,
    ODM_CMNINFO_BT_DISABLED = 23,
    ODM_CMNINFO_BT_OPERATION = 24,
    ODM_CMNINFO_BT_DIG = 25,
    ODM_CMNINFO_BT_BUSY = 26,
    ODM_CMNINFO_BT_DISABLE_EDCA = 27,
    ODM_CMNINFO_STA_STATUS = 28,
    ODM_CMNINFO_PHY_STATUS = 29,
    ODM_CMNINFO_MAC_STATUS = 30,
    ODM_CMNINFO_MAX = 31
} ;
enum hrtimer_restart;
struct setpwrmode_parm {
   u8 Mode ;
   u8 SmartPS ;
   u8 AwakeInterval ;
   u8 bAllQueueUAPSD ;
   u8 BcnAntMode ;
};
struct joinbssrpt_parm {
   u8 OpMode ;
};
struct rsvdpage_loc {
   u8 LocProbeRsp ;
   u8 LocPsPoll ;
   u8 LocNullData ;
   u8 LocQosNull ;
   u8 LocBTQosNull ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
struct tx_desc {
   __le32 txdw0 ;
   __le32 txdw1 ;
   __le32 txdw2 ;
   __le32 txdw3 ;
   __le32 txdw4 ;
   __le32 txdw5 ;
   __le32 txdw6 ;
   __le32 txdw7 ;
};
struct txpowerinfo {
   u8 CCKIndex[2U][12U] ;
   u8 HT40_1SIndex[2U][12U] ;
   u8 HT40_2SIndexDiff[2U][12U] ;
   u8 HT20IndexDiff[2U][12U] ;
   u8 OFDMIndexDiff[2U][12U] ;
   u8 HT40MaxOffset[2U][12U] ;
   u8 HT20MaxOffset[2U][12U] ;
   u8 TSSI_A[3U] ;
   u8 TSSI_B[3U] ;
   u8 TSSI_A_5G[3U] ;
   u8 TSSI_B_5G[3U] ;
};
struct txrpt_ccx_8723a {
   unsigned char tag1 : 1 ;
   unsigned char rsvd : 4 ;
   unsigned char int_bt : 1 ;
   unsigned char int_tri : 1 ;
   unsigned char int_ccx : 1 ;
   unsigned char mac_id : 5 ;
   unsigned char pkt_drop : 1 ;
   unsigned char pkt_ok : 1 ;
   unsigned char bmc : 1 ;
   unsigned char retry_cnt : 6 ;
   unsigned char lifetime_over : 1 ;
   unsigned char retry_over : 1 ;
   u8 ccx_qtime0 ;
   u8 ccx_qtime1 ;
   u8 final_data_rate ;
   unsigned char sw1 : 4 ;
   unsigned char qsel : 4 ;
   u8 sw0 ;
};
struct rt_8723a_firmware_hdr {
   __le16 Signature ;
   u8 Category ;
   u8 Function ;
   __le16 Version ;
   u8 Subversion ;
   u8 Rsvd1 ;
   u8 Month ;
   u8 Date ;
   u8 Hour ;
   u8 Minute ;
   __le16 RamCodeSize ;
   __le16 Rsvd2 ;
   __le32 SvnIdx ;
   __le32 Rsvd3 ;
   __le32 Rsvd4 ;
   __le32 Rsvd5 ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct recv_stat {
   __le32 rxdw0 ;
   __le32 rxdw1 ;
   __le32 rxdw2 ;
   __le32 rxdw3 ;
   __le32 rxdw4 ;
   __le32 rxdw5 ;
};
struct phy_stat {
   unsigned int phydw0 ;
   unsigned int phydw1 ;
   unsigned int phydw2 ;
   unsigned int phydw3 ;
   unsigned int phydw4 ;
   unsigned int phydw5 ;
   unsigned int phydw6 ;
   unsigned int phydw7 ;
};
struct rxreport_8723a {
   unsigned short pktlen : 14 ;
   unsigned char crc32 : 1 ;
   unsigned char icverr : 1 ;
   unsigned char drvinfosize : 4 ;
   unsigned char security : 3 ;
   unsigned char qos : 1 ;
   unsigned char shift : 2 ;
   unsigned char physt : 1 ;
   unsigned char swdec : 1 ;
   unsigned char ls : 1 ;
   unsigned char fs : 1 ;
   unsigned char eor : 1 ;
   unsigned char own : 1 ;
   unsigned char macid : 5 ;
   unsigned char tid : 4 ;
   unsigned char hwrsvd : 4 ;
   unsigned char amsdu : 1 ;
   unsigned char paggr : 1 ;
   unsigned char faggr : 1 ;
   unsigned char a1fit : 4 ;
   unsigned char a2fit : 4 ;
   unsigned char pam : 1 ;
   unsigned char pwr : 1 ;
   unsigned char md : 1 ;
   unsigned char mf : 1 ;
   unsigned char type : 2 ;
   unsigned char mc : 1 ;
   unsigned char bc : 1 ;
   unsigned short seq : 12 ;
   unsigned char frag : 4 ;
   unsigned short nextpktlen : 14 ;
   unsigned char nextind : 1 ;
   unsigned char rsvd0831 : 1 ;
   unsigned char rxmcs : 6 ;
   unsigned char rxht : 1 ;
   unsigned char gf : 1 ;
   unsigned char splcp : 1 ;
   unsigned char bw : 1 ;
   unsigned char htc : 1 ;
   unsigned char eosp : 1 ;
   unsigned char bssidfit : 2 ;
   unsigned short rsvd1214 ;
   unsigned char unicastwake : 1 ;
   unsigned char magicwake : 1 ;
   unsigned char pattern0match : 1 ;
   unsigned char pattern1match : 1 ;
   unsigned char pattern2match : 1 ;
   unsigned char pattern3match : 1 ;
   unsigned char pattern4match : 1 ;
   unsigned char pattern5match : 1 ;
   unsigned char pattern6match : 1 ;
   unsigned char pattern7match : 1 ;
   unsigned char pattern8match : 1 ;
   unsigned char pattern9match : 1 ;
   unsigned char patternamatch : 1 ;
   unsigned char patternbmatch : 1 ;
   unsigned char patterncmatch : 1 ;
   unsigned int rsvd1613 : 19 ;
   u32 tsfl ;
   unsigned short bassn : 12 ;
   unsigned char bavld : 1 ;
   unsigned int rsvd2413 : 19 ;
};
struct recv_stat_cpu {
   u32 rxdw0 ;
   u32 rxdw1 ;
   u32 rxdw2 ;
   u32 rxdw3 ;
   u32 rxdw4 ;
   u32 rxdw5 ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct reportpwrstate_parm {
   unsigned char mode ;
   unsigned char state ;
   unsigned short rsvd ;
};
enum hrtimer_restart;
struct station_info;
struct cfg80211_pmksa;
struct vif_params;
struct station_parameters;
struct ieee80211_radiotap_header {
   u8 it_version ;
   u8 it_pad ;
   __le16 it_len ;
   __le32 it_present ;
};
struct nl80211_sta_flag_update {
   __u32 mask ;
   __u32 set ;
};
enum nl80211_mesh_power_mode {
    NL80211_MESH_POWER_UNKNOWN = 0,
    NL80211_MESH_POWER_ACTIVE = 1,
    NL80211_MESH_POWER_LIGHT_SLEEP = 2,
    NL80211_MESH_POWER_DEEP_SLEEP = 3,
    __NL80211_MESH_POWER_AFTER_LAST = 4,
    NL80211_MESH_POWER_MAX = 3
} ;
enum nl80211_ac {
    NL80211_AC_VO = 0,
    NL80211_AC_VI = 1,
    NL80211_AC_BE = 2,
    NL80211_AC_BK = 3,
    NL80211_NUM_ACS = 4
} ;
enum nl80211_txrate_gi {
    NL80211_TXRATE_DEFAULT_GI = 0,
    NL80211_TXRATE_FORCE_SGI = 1,
    NL80211_TXRATE_FORCE_LGI = 2
} ;
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
} ;
enum nl80211_coalesce_condition {
    NL80211_COALESCE_CONDITION_MATCH = 0,
    NL80211_COALESCE_CONDITION_NO_MATCH = 1
} ;
enum nl80211_hidden_ssid {
    NL80211_HIDDEN_SSID_NOT_IN_USE = 0,
    NL80211_HIDDEN_SSID_ZERO_LEN = 1,
    NL80211_HIDDEN_SSID_ZERO_CONTENTS = 2
} ;
enum nl80211_tdls_operation {
    NL80211_TDLS_DISCOVERY_REQ = 0,
    NL80211_TDLS_SETUP = 1,
    NL80211_TDLS_TEARDOWN = 2,
    NL80211_TDLS_ENABLE_LINK = 3,
    NL80211_TDLS_DISABLE_LINK = 4
} ;
enum nl80211_acl_policy {
    NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED = 0,
    NL80211_ACL_POLICY_DENY_UNLESS_LISTED = 1
} ;
enum nl80211_smps_mode {
    NL80211_SMPS_OFF = 0,
    NL80211_SMPS_STATIC = 1,
    NL80211_SMPS_DYNAMIC = 2,
    __NL80211_SMPS_AFTER_LAST = 3,
    NL80211_SMPS_MAX = 2
} ;
enum nl80211_crit_proto_id {
    NL80211_CRIT_PROTO_UNSPEC = 0,
    NL80211_CRIT_PROTO_DHCP = 1,
    NL80211_CRIT_PROTO_EAPOL = 2,
    NL80211_CRIT_PROTO_APIPA = 3,
    NUM_NL80211_CRIT_PROTO = 4
} ;
struct vif_params {
   int use_4addr ;
   u8 macaddr[6U] ;
};
struct key_params {
   u8 const   *key ;
   u8 const   *seq ;
   int key_len ;
   int seq_len ;
   u32 cipher ;
};
struct survey_info {
   struct ieee80211_channel *channel ;
   u64 time ;
   u64 time_busy ;
   u64 time_ext_busy ;
   u64 time_rx ;
   u64 time_tx ;
   u64 time_scan ;
   u32 filled ;
   s8 noise ;
};
struct cfg80211_beacon_data {
   u8 const   *head ;
   u8 const   *tail ;
   u8 const   *beacon_ies ;
   u8 const   *proberesp_ies ;
   u8 const   *assocresp_ies ;
   u8 const   *probe_resp ;
   size_t head_len ;
   size_t tail_len ;
   size_t beacon_ies_len ;
   size_t proberesp_ies_len ;
   size_t assocresp_ies_len ;
   size_t probe_resp_len ;
};
struct cfg80211_acl_data {
   enum nl80211_acl_policy acl_policy ;
   int n_acl_entries ;
   struct mac_address mac_addrs[] ;
};
struct cfg80211_ap_settings {
   struct cfg80211_chan_def chandef ;
   struct cfg80211_beacon_data beacon ;
   int beacon_interval ;
   int dtim_period ;
   u8 const   *ssid ;
   size_t ssid_len ;
   enum nl80211_hidden_ssid hidden_ssid ;
   struct cfg80211_crypto_settings crypto ;
   bool privacy ;
   enum nl80211_auth_type auth_type ;
   enum nl80211_smps_mode smps_mode ;
   int inactivity_timeout ;
   u8 p2p_ctwindow ;
   bool p2p_opp_ps ;
   struct cfg80211_acl_data  const  *acl ;
};
struct cfg80211_csa_settings {
   struct cfg80211_chan_def chandef ;
   struct cfg80211_beacon_data beacon_csa ;
   u16 const   *counter_offsets_beacon ;
   u16 const   *counter_offsets_presp ;
   unsigned int n_counter_offsets_beacon ;
   unsigned int n_counter_offsets_presp ;
   struct cfg80211_beacon_data beacon_after ;
   bool radar_required ;
   bool block_tx ;
   u8 count ;
};
struct station_parameters {
   u8 const   *supported_rates ;
   struct net_device *vlan ;
   u32 sta_flags_mask ;
   u32 sta_flags_set ;
   u32 sta_modify_mask ;
   int listen_interval ;
   u16 aid ;
   u8 supported_rates_len ;
   u8 plink_action ;
   u8 plink_state ;
   struct ieee80211_ht_cap  const  *ht_capa ;
   struct ieee80211_vht_cap  const  *vht_capa ;
   u8 uapsd_queues ;
   u8 max_sp ;
   enum nl80211_mesh_power_mode local_pm ;
   u16 capability ;
   u8 const   *ext_capab ;
   u8 ext_capab_len ;
   u8 const   *supported_channels ;
   u8 supported_channels_len ;
   u8 const   *supported_oper_classes ;
   u8 supported_oper_classes_len ;
   u8 opmode_notif ;
   bool opmode_notif_used ;
};
struct station_del_parameters {
   u8 const   *mac ;
   u8 subtype ;
   u16 reason_code ;
};
struct rate_info {
   u8 flags ;
   u8 mcs ;
   u16 legacy ;
   u8 nss ;
   u8 bw ;
};
struct sta_bss_parameters {
   u8 flags ;
   u8 dtim_period ;
   u16 beacon_interval ;
};
struct cfg80211_tid_stats {
   u32 filled ;
   u64 rx_msdu ;
   u64 tx_msdu ;
   u64 tx_msdu_retries ;
   u64 tx_msdu_failed ;
};
struct station_info {
   u32 filled ;
   u32 connected_time ;
   u32 inactive_time ;
   u64 rx_bytes ;
   u64 tx_bytes ;
   u16 llid ;
   u16 plid ;
   u8 plink_state ;
   s8 signal ;
   s8 signal_avg ;
   u8 chains ;
   s8 chain_signal[4U] ;
   s8 chain_signal_avg[4U] ;
   struct rate_info txrate ;
   struct rate_info rxrate ;
   u32 rx_packets ;
   u32 tx_packets ;
   u32 tx_retries ;
   u32 tx_failed ;
   u32 rx_dropped_misc ;
   struct sta_bss_parameters bss_param ;
   struct nl80211_sta_flag_update sta_flags ;
   int generation ;
   u8 const   *assoc_req_ies ;
   size_t assoc_req_ies_len ;
   u32 beacon_loss_count ;
   s64 t_offset ;
   enum nl80211_mesh_power_mode local_pm ;
   enum nl80211_mesh_power_mode peer_pm ;
   enum nl80211_mesh_power_mode nonpeer_pm ;
   u32 expected_throughput ;
   u64 rx_beacon ;
   u8 rx_beacon_signal_avg ;
   struct cfg80211_tid_stats pertid[17U] ;
};
struct mpath_info {
   u32 filled ;
   u32 frame_qlen ;
   u32 sn ;
   u32 metric ;
   u32 exptime ;
   u32 discovery_timeout ;
   u8 discovery_retries ;
   u8 flags ;
   int generation ;
};
struct bss_parameters {
   int use_cts_prot ;
   int use_short_preamble ;
   int use_short_slot_time ;
   u8 const   *basic_rates ;
   u8 basic_rates_len ;
   int ap_isolate ;
   int ht_opmode ;
   s8 p2p_ctwindow ;
   s8 p2p_opp_ps ;
};
struct mesh_config {
   u16 dot11MeshRetryTimeout ;
   u16 dot11MeshConfirmTimeout ;
   u16 dot11MeshHoldingTimeout ;
   u16 dot11MeshMaxPeerLinks ;
   u8 dot11MeshMaxRetries ;
   u8 dot11MeshTTL ;
   u8 element_ttl ;
   bool auto_open_plinks ;
   u32 dot11MeshNbrOffsetMaxNeighbor ;
   u8 dot11MeshHWMPmaxPREQretries ;
   u32 path_refresh_time ;
   u16 min_discovery_timeout ;
   u32 dot11MeshHWMPactivePathTimeout ;
   u16 dot11MeshHWMPpreqMinInterval ;
   u16 dot11MeshHWMPperrMinInterval ;
   u16 dot11MeshHWMPnetDiameterTraversalTime ;
   u8 dot11MeshHWMPRootMode ;
   u16 dot11MeshHWMPRannInterval ;
   bool dot11MeshGateAnnouncementProtocol ;
   bool dot11MeshForwarding ;
   s32 rssi_threshold ;
   u16 ht_opmode ;
   u32 dot11MeshHWMPactivePathToRootTimeout ;
   u16 dot11MeshHWMProotInterval ;
   u16 dot11MeshHWMPconfirmationInterval ;
   enum nl80211_mesh_power_mode power_mode ;
   u16 dot11MeshAwakeWindowDuration ;
   u32 plink_timeout ;
};
struct mesh_setup {
   struct cfg80211_chan_def chandef ;
   u8 const   *mesh_id ;
   u8 mesh_id_len ;
   u8 sync_method ;
   u8 path_sel_proto ;
   u8 path_metric ;
   u8 auth_id ;
   u8 const   *ie ;
   u8 ie_len ;
   bool is_authenticated ;
   bool is_secure ;
   bool user_mpm ;
   u8 dtim_period ;
   u16 beacon_interval ;
   int mcast_rate[3U] ;
   u32 basic_rates ;
};
struct ocb_setup {
   struct cfg80211_chan_def chandef ;
};
struct ieee80211_txq_params {
   enum nl80211_ac ac ;
   u16 txop ;
   u16 cwmin ;
   u16 cwmax ;
   u8 aifs ;
};
struct cfg80211_bss_ies {
   u64 tsf ;
   struct callback_head callback_head ;
   int len ;
   bool from_beacon ;
   u8 data[] ;
};
struct cfg80211_bss {
   struct ieee80211_channel *channel ;
   enum nl80211_bss_scan_width scan_width ;
   struct cfg80211_bss_ies  const  *ies ;
   struct cfg80211_bss_ies  const  *beacon_ies ;
   struct cfg80211_bss_ies  const  *proberesp_ies ;
   struct cfg80211_bss *hidden_beacon_bss ;
   s32 signal ;
   u16 beacon_interval ;
   u16 capability ;
   u8 bssid[6U] ;
   u8 priv[0U] ;
};
struct cfg80211_auth_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   size_t ie_len ;
   enum nl80211_auth_type auth_type ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
   u8 const   *sae_data ;
   size_t sae_data_len ;
};
struct cfg80211_assoc_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   u8 const   *prev_bssid ;
   size_t ie_len ;
   struct cfg80211_crypto_settings crypto ;
   bool use_mfp ;
   u32 flags ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
struct cfg80211_deauth_request {
   u8 const   *bssid ;
   u8 const   *ie ;
   size_t ie_len ;
   u16 reason_code ;
   bool local_state_change ;
};
struct cfg80211_disassoc_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   size_t ie_len ;
   u16 reason_code ;
   bool local_state_change ;
};
struct __anonstruct_control_369 {
   u32 legacy ;
   u8 ht_mcs[10U] ;
   u16 vht_mcs[8U] ;
   enum nl80211_txrate_gi gi ;
};
struct cfg80211_bitrate_mask {
   struct __anonstruct_control_369 control[3U] ;
};
struct cfg80211_pmksa {
   u8 const   *bssid ;
   u8 const   *pmkid ;
};
struct cfg80211_coalesce_rules {
   int delay ;
   enum nl80211_coalesce_condition condition ;
   struct cfg80211_pkt_pattern *patterns ;
   int n_patterns ;
};
struct cfg80211_coalesce {
   struct cfg80211_coalesce_rules *rules ;
   int n_rules ;
};
struct cfg80211_gtk_rekey_data {
   u8 const   *kek ;
   u8 const   *kck ;
   u8 const   *replay_ctr ;
};
struct cfg80211_update_ft_ies_params {
   u16 md ;
   u8 const   *ie ;
   size_t ie_len ;
};
struct cfg80211_mgmt_tx_params {
   struct ieee80211_channel *chan ;
   bool offchan ;
   unsigned int wait ;
   u8 const   *buf ;
   size_t len ;
   bool no_cck ;
   bool dont_wait_for_ack ;
   int n_csa_offsets ;
   u16 const   *csa_offsets ;
};
struct cfg80211_dscp_exception {
   u8 dscp ;
   u8 up ;
};
struct cfg80211_dscp_range {
   u8 low ;
   u8 high ;
};
struct cfg80211_qos_map {
   u8 num_des ;
   struct cfg80211_dscp_exception dscp_exception[21U] ;
   struct cfg80211_dscp_range up[8U] ;
};
struct cfg80211_ops {
   int (*suspend)(struct wiphy * , struct cfg80211_wowlan * ) ;
   int (*resume)(struct wiphy * ) ;
   void (*set_wakeup)(struct wiphy * , bool  ) ;
   struct wireless_dev *(*add_virtual_intf)(struct wiphy * , char const   * , unsigned char  ,
                                            enum nl80211_iftype  , u32 * , struct vif_params * ) ;
   int (*del_virtual_intf)(struct wiphy * , struct wireless_dev * ) ;
   int (*change_virtual_intf)(struct wiphy * , struct net_device * , enum nl80211_iftype  ,
                              u32 * , struct vif_params * ) ;
   int (*add_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ,
                  struct key_params * ) ;
   int (*get_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ,
                  void * , void (*)(void * , struct key_params * ) ) ;
   int (*del_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ) ;
   int (*set_default_key)(struct wiphy * , struct net_device * , u8  , bool  , bool  ) ;
   int (*set_default_mgmt_key)(struct wiphy * , struct net_device * , u8  ) ;
   int (*start_ap)(struct wiphy * , struct net_device * , struct cfg80211_ap_settings * ) ;
   int (*change_beacon)(struct wiphy * , struct net_device * , struct cfg80211_beacon_data * ) ;
   int (*stop_ap)(struct wiphy * , struct net_device * ) ;
   int (*add_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_parameters * ) ;
   int (*del_station)(struct wiphy * , struct net_device * , struct station_del_parameters * ) ;
   int (*change_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_parameters * ) ;
   int (*get_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_info * ) ;
   int (*dump_station)(struct wiphy * , struct net_device * , int  , u8 * , struct station_info * ) ;
   int (*add_mpath)(struct wiphy * , struct net_device * , u8 const   * , u8 const   * ) ;
   int (*del_mpath)(struct wiphy * , struct net_device * , u8 const   * ) ;
   int (*change_mpath)(struct wiphy * , struct net_device * , u8 const   * , u8 const   * ) ;
   int (*get_mpath)(struct wiphy * , struct net_device * , u8 * , u8 * , struct mpath_info * ) ;
   int (*dump_mpath)(struct wiphy * , struct net_device * , int  , u8 * , u8 * , struct mpath_info * ) ;
   int (*get_mpp)(struct wiphy * , struct net_device * , u8 * , u8 * , struct mpath_info * ) ;
   int (*dump_mpp)(struct wiphy * , struct net_device * , int  , u8 * , u8 * , struct mpath_info * ) ;
   int (*get_mesh_config)(struct wiphy * , struct net_device * , struct mesh_config * ) ;
   int (*update_mesh_config)(struct wiphy * , struct net_device * , u32  , struct mesh_config  const  * ) ;
   int (*join_mesh)(struct wiphy * , struct net_device * , struct mesh_config  const  * ,
                    struct mesh_setup  const  * ) ;
   int (*leave_mesh)(struct wiphy * , struct net_device * ) ;
   int (*join_ocb)(struct wiphy * , struct net_device * , struct ocb_setup * ) ;
   int (*leave_ocb)(struct wiphy * , struct net_device * ) ;
   int (*change_bss)(struct wiphy * , struct net_device * , struct bss_parameters * ) ;
   int (*set_txq_params)(struct wiphy * , struct net_device * , struct ieee80211_txq_params * ) ;
   int (*libertas_set_mesh_channel)(struct wiphy * , struct net_device * , struct ieee80211_channel * ) ;
   int (*set_monitor_channel)(struct wiphy * , struct cfg80211_chan_def * ) ;
   int (*scan)(struct wiphy * , struct cfg80211_scan_request * ) ;
   int (*auth)(struct wiphy * , struct net_device * , struct cfg80211_auth_request * ) ;
   int (*assoc)(struct wiphy * , struct net_device * , struct cfg80211_assoc_request * ) ;
   int (*deauth)(struct wiphy * , struct net_device * , struct cfg80211_deauth_request * ) ;
   int (*disassoc)(struct wiphy * , struct net_device * , struct cfg80211_disassoc_request * ) ;
   int (*connect)(struct wiphy * , struct net_device * , struct cfg80211_connect_params * ) ;
   int (*disconnect)(struct wiphy * , struct net_device * , u16  ) ;
   int (*join_ibss)(struct wiphy * , struct net_device * , struct cfg80211_ibss_params * ) ;
   int (*leave_ibss)(struct wiphy * , struct net_device * ) ;
   int (*set_mcast_rate)(struct wiphy * , struct net_device * , int * ) ;
   int (*set_wiphy_params)(struct wiphy * , u32  ) ;
   int (*set_tx_power)(struct wiphy * , struct wireless_dev * , enum nl80211_tx_power_setting  ,
                       int  ) ;
   int (*get_tx_power)(struct wiphy * , struct wireless_dev * , int * ) ;
   int (*set_wds_peer)(struct wiphy * , struct net_device * , u8 const   * ) ;
   void (*rfkill_poll)(struct wiphy * ) ;
   int (*testmode_cmd)(struct wiphy * , struct wireless_dev * , void * , int  ) ;
   int (*testmode_dump)(struct wiphy * , struct sk_buff * , struct netlink_callback * ,
                        void * , int  ) ;
   int (*set_bitrate_mask)(struct wiphy * , struct net_device * , u8 const   * , struct cfg80211_bitrate_mask  const  * ) ;
   int (*dump_survey)(struct wiphy * , struct net_device * , int  , struct survey_info * ) ;
   int (*set_pmksa)(struct wiphy * , struct net_device * , struct cfg80211_pmksa * ) ;
   int (*del_pmksa)(struct wiphy * , struct net_device * , struct cfg80211_pmksa * ) ;
   int (*flush_pmksa)(struct wiphy * , struct net_device * ) ;
   int (*remain_on_channel)(struct wiphy * , struct wireless_dev * , struct ieee80211_channel * ,
                            unsigned int  , u64 * ) ;
   int (*cancel_remain_on_channel)(struct wiphy * , struct wireless_dev * , u64  ) ;
   int (*mgmt_tx)(struct wiphy * , struct wireless_dev * , struct cfg80211_mgmt_tx_params * ,
                  u64 * ) ;
   int (*mgmt_tx_cancel_wait)(struct wiphy * , struct wireless_dev * , u64  ) ;
   int (*set_power_mgmt)(struct wiphy * , struct net_device * , bool  , int  ) ;
   int (*set_cqm_rssi_config)(struct wiphy * , struct net_device * , s32  , u32  ) ;
   int (*set_cqm_txe_config)(struct wiphy * , struct net_device * , u32  , u32  ,
                             u32  ) ;
   void (*mgmt_frame_register)(struct wiphy * , struct wireless_dev * , u16  , bool  ) ;
   int (*set_antenna)(struct wiphy * , u32  , u32  ) ;
   int (*get_antenna)(struct wiphy * , u32 * , u32 * ) ;
   int (*sched_scan_start)(struct wiphy * , struct net_device * , struct cfg80211_sched_scan_request * ) ;
   int (*sched_scan_stop)(struct wiphy * , struct net_device * ) ;
   int (*set_rekey_data)(struct wiphy * , struct net_device * , struct cfg80211_gtk_rekey_data * ) ;
   int (*tdls_mgmt)(struct wiphy * , struct net_device * , u8 const   * , u8  , u8  ,
                    u16  , u32  , bool  , u8 const   * , size_t  ) ;
   int (*tdls_oper)(struct wiphy * , struct net_device * , u8 const   * , enum nl80211_tdls_operation  ) ;
   int (*probe_client)(struct wiphy * , struct net_device * , u8 const   * , u64 * ) ;
   int (*set_noack_map)(struct wiphy * , struct net_device * , u16  ) ;
   int (*get_channel)(struct wiphy * , struct wireless_dev * , struct cfg80211_chan_def * ) ;
   int (*start_p2p_device)(struct wiphy * , struct wireless_dev * ) ;
   void (*stop_p2p_device)(struct wiphy * , struct wireless_dev * ) ;
   int (*set_mac_acl)(struct wiphy * , struct net_device * , struct cfg80211_acl_data  const  * ) ;
   int (*start_radar_detection)(struct wiphy * , struct net_device * , struct cfg80211_chan_def * ,
                                u32  ) ;
   int (*update_ft_ies)(struct wiphy * , struct net_device * , struct cfg80211_update_ft_ies_params * ) ;
   int (*crit_proto_start)(struct wiphy * , struct wireless_dev * , enum nl80211_crit_proto_id  ,
                           u16  ) ;
   void (*crit_proto_stop)(struct wiphy * , struct wireless_dev * ) ;
   int (*set_coalesce)(struct wiphy * , struct cfg80211_coalesce * ) ;
   int (*channel_switch)(struct wiphy * , struct net_device * , struct cfg80211_csa_settings * ) ;
   int (*set_qos_map)(struct wiphy * , struct net_device * , struct cfg80211_qos_map * ) ;
   int (*set_ap_chanwidth)(struct wiphy * , struct net_device * , struct cfg80211_chan_def * ) ;
   int (*add_tx_ts)(struct wiphy * , struct net_device * , u8  , u8 const   * , u8  ,
                    u16  ) ;
   int (*del_tx_ts)(struct wiphy * , struct net_device * , u8  , u8 const   * ) ;
   int (*tdls_channel_switch)(struct wiphy * , struct net_device * , u8 const   * ,
                              u8  , struct cfg80211_chan_def * ) ;
   void (*tdls_cancel_channel_switch)(struct wiphy * , struct net_device * , u8 const   * ) ;
};
enum cfg80211_bss_frame_type {
    CFG80211_BSS_FTYPE_UNKNOWN = 0,
    CFG80211_BSS_FTYPE_BEACON = 1,
    CFG80211_BSS_FTYPE_PRESP = 2
} ;
enum hrtimer_restart;
enum hrtimer_restart;
typedef short __s16;
enum hrtimer_restart;
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
struct iw_michaelmicfailure {
   __u32 flags ;
   struct sockaddr src_addr ;
   __u8 tsc[8U] ;
};
union iwreq_data {
   char name[16U] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
enum nl80211_key_type {
    NL80211_KEYTYPE_GROUP = 0,
    NL80211_KEYTYPE_PAIRWISE = 1,
    NL80211_KEYTYPE_PEERKEY = 2,
    NUM_NL80211_KEYTYPES = 3
} ;
enum hrtimer_restart;
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
struct usb_driver;
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id  const  * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int  , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t  ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char disable_hub_initiated_lpm : 1 ;
   unsigned char soft_unbind : 1 ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum rt_media_status;
enum rt_media_status;
enum rt_status {
    RT_STATUS_SUCCESS = 0,
    RT_STATUS_FAILURE = 1,
    RT_STATUS_PENDING = 2,
    RT_STATUS_RESOURCE = 3,
    RT_STATUS_INVALID_CONTEXT = 4,
    RT_STATUS_INVALID_PARAMETER = 5,
    RT_STATUS_NOT_SUPPORT = 6,
    RT_STATUS_OS_API_FAILED = 7
} ;
struct chnl_txpower_triple {
   u8 FirstChnl ;
   u8 NumChnls ;
   s8 MaxTxPowerInDbm ;
};
enum hci_state_with_cmd {
    STATE_CMD_CREATE_PHY_LINK = 0,
    STATE_CMD_ACCEPT_PHY_LINK = 1,
    STATE_CMD_DISCONNECT_PHY_LINK = 2,
    STATE_CMD_CONNECT_ACCEPT_TIMEOUT = 3,
    STATE_CMD_MAC_START_COMPLETE = 4,
    STATE_CMD_MAC_START_FAILED = 5,
    STATE_CMD_MAC_CONNECT_COMPLETE = 6,
    STATE_CMD_MAC_CONNECT_FAILED = 7,
    STATE_CMD_MAC_DISCONNECT_INDICATE = 8,
    STATE_CMD_MAC_CONNECT_CANCEL_INDICATE = 9,
    STATE_CMD_4WAY_FAILED = 10,
    STATE_CMD_4WAY_SUCCESSED = 11,
    STATE_CMD_ENTER_STATE = 12,
    STATE_CMD_NO_SUCH_CMD = 13
} ;
enum bt_traffic_mode_profile {
    BT_PROFILE_NONE = 0,
    BT_PROFILE_A2DP = 1,
    BT_PROFILE_PAN = 2,
    BT_PROFILE_HID = 3,
    BT_PROFILE_SCO = 4
} ;
struct amp_assoc_structure {
   u8 TypeID ;
   u16 Length ;
   u8 Data[1U] ;
};
struct amp_pref_chnl_regulatory {
   u8 reXId ;
   u8 regulatoryClass ;
   u8 coverageClass ;
};
struct packet_irp_hcicmd_data {
   unsigned short OCF : 10 ;
   unsigned char OGF : 6 ;
   u8 Length ;
   u8 Data[20U] ;
};
struct packet_irp_hcievent_data {
   u8 EventCode ;
   u8 Length ;
   u8 Data[20U] ;
};
struct common_triple {
   u8 byte_1st ;
   u8 byte_2nd ;
   u8 byte_3rd ;
};
enum bt_state_1ant {
    BT_INFO_STATE_DISABLED = 0,
    BT_INFO_STATE_NO_CONNECTION = 1,
    BT_INFO_STATE_CONNECT_IDLE = 2,
    BT_INFO_STATE_INQ_OR_PAG = 3,
    BT_INFO_STATE_ACL_ONLY_BUSY = 4,
    BT_INFO_STATE_SCO_ONLY_BUSY = 5,
    BT_INFO_STATE_ACL_SCO_BUSY = 6,
    BT_INFO_STATE_ACL_INQ_OR_PAG = 7,
    BT_INFO_STATE_MAX = 8
} ;
enum hrtimer_restart;
extern int printk(char const   *  , ...) ;
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  __list_add(new, head->prev, head);
  return;
}
}
extern void *memcpy(void * , void const   * , size_t  ) ;
extern void *memset(void * , int  , size_t  ) ;
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
  return;
}
}
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
  return;
}
}
extern unsigned long volatile   jiffies ;
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
  tmp___0 = __msecs_to_jiffies(m);
  return (tmp___0);
}
}
extern int mod_timer(struct timer_list * , unsigned long  ) ;
int ldv_mod_timer_11(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_12(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_13(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_14(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_15(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_16(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
extern int del_timer_sync(struct timer_list * ) ;
int ldv_del_timer_sync_17(struct timer_list *ldv_func_arg1 ) ;
extern void __init_work(struct work_struct * , int  ) ;
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
extern void flush_workqueue(struct workqueue_struct * ) ;
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
extern bool cancel_work_sync(struct work_struct * ) ;
bool ldv_cancel_work_sync_10(struct work_struct *ldv_func_arg1 ) ;
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_5(8192, wq, work);
  return (tmp);
}
}
extern void kfree(void const   * ) ;
extern void *__kmalloc(size_t  , gfp_t  ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  tmp___2 = __kmalloc(size, flags);
  return (tmp___2);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  tmp = kmalloc(size, flags | 32768U);
  return (tmp);
}
}
extern void *malloc(size_t  ) ;
extern void *calloc(size_t  , size_t  ) ;
extern int __VERIFIER_nondet_int(void) ;
extern unsigned long __VERIFIER_nondet_ulong(void) ;
extern void *__VERIFIER_nondet_pointer(void) ;
extern void __VERIFIER_assume(int  ) ;
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = malloc(size);
    p = tmp;
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
    return (p);
  }
}
}
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = calloc(1UL, size);
    p = tmp;
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
    return (p);
  }
}
}
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  tmp = calloc(1UL, size);
  p = tmp;
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
  return (p);
}
}
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
  tmp = memset(s, c, n);
  return (tmp);
}
}
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  return (tmp);
}
}
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  tmp = __VERIFIER_nondet_pointer();
  return (tmp);
}
}
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  tmp = __VERIFIER_nondet_ulong();
  return (tmp);
}
}
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
  goto LDV_STOP;
}
}
int ldv_work_1_1 ;
struct work_struct *ldv_work_struct_2_0 ;
struct work_struct *ldv_work_struct_2_2 ;
struct work_struct *ldv_work_struct_1_1 ;
int ldv_work_1_3 ;
struct work_struct *ldv_work_struct_2_1 ;
int LDV_IN_INTERRUPT  =    1;
int ldv_work_1_0 ;
int ldv_work_2_1 ;
struct work_struct *ldv_work_struct_1_3 ;
struct work_struct *ldv_work_struct_2_3 ;
struct work_struct *ldv_work_struct_1_0 ;
int ldv_work_2_0 ;
int ldv_work_1_2 ;
struct work_struct *ldv_work_struct_1_2 ;
int ldv_work_2_2 ;
int ldv_work_2_3 ;
void call_and_disable_work_1(struct work_struct *work ) ;
void call_and_disable_all_2(int state ) ;
void activate_work_1(struct work_struct *work , int state ) ;
void disable_work_1(struct work_struct *work ) ;
void work_init_1(void) ;
void disable_suitable_timer_11(struct timer_list *timer ) ;
void invoke_work_2(void) ;
void work_init_2(void) ;
void call_and_disable_all_1(int state ) ;
void activate_work_2(struct work_struct *work , int state ) ;
void disable_work_2(struct work_struct *work ) ;
void invoke_work_1(void) ;
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void call_and_disable_work_2(struct work_struct *work ) ;
extern void msleep(unsigned int  ) ;
__inline static void ether_addr_copy(u8 *dst , u8 const   *src ) 
{ 


  {
  *((u32 *)dst) = *((u32 const   *)src);
  *((u16 *)dst + 4U) = *((u16 const   *)src + 4U);
  return;
}
}
__inline static uint get_wlan_bssid_ex_sz(struct wlan_bssid_ex *bss ) 
{ 


  {
  return (bss->IELength + 103U);
}
}
void rtw_evt_work(struct work_struct *work ) ;
int rtw_enqueue_cmd23a(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) ;
void rtw_free_cmd_obj23a(struct cmd_obj *pcmd ) ;
int rtw_init_cmd_priv23a(struct cmd_priv *pcmdpriv ) ;
u32 rtw_init_evt_priv23a(struct evt_priv *pevtpriv ) ;
void rtw_free_evt_priv23a(struct evt_priv *pevtpriv ) ;
int rtw_sitesurvey_cmd23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ,
                          int ssid_num , struct rtw_ieee80211_channel *ch , int ch_num ) ;
int rtw_createbss_cmd23a(struct rtw_adapter *padapter ) ;
int rtw_setstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 unicast_key ) ;
int rtw_clearstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 entry , u8 enqueue ) ;
int rtw_joinbss_cmd23a(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) ;
int rtw_disassoc_cmd23a(struct rtw_adapter *padapter , u32 deauth_timeout_ms , bool enqueue ) ;
int rtw_setopmode_cmd23a(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) ;
int rtw_addbareq_cmd23a(struct rtw_adapter *padapter , u8 tid , u8 *addr ) ;
int rtw_dynamic_chk_wk_cmd23a(struct rtw_adapter *padapter ) ;
int rtw_lps_ctrl_wk_cmd23a(struct rtw_adapter *padapter , u8 lps_ctrl_type , u8 enqueue ) ;
int rtw_ps_cmd23a(struct rtw_adapter *padapter ) ;
int rtw_chk_hi_queue_cmd23a(struct rtw_adapter *padapter ) ;
int rtw_c2h_wk_cmd23a(struct rtw_adapter *padapter , u8 *c2h_evt ) ;
int rtw_drvextra_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
void rtw_survey_cmd_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_disassoc_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_joinbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_createbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_getbbrfreg_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_setstaKey_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_setassocsta_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
struct _cmd_callback rtw_cmd_callback[63U] ;
void c2h_evt_clear23a(struct rtw_adapter *adapter ) ;
s32 c2h_evt_read23a(struct rtw_adapter *adapter , u8 *buf ) ;
bool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter ) ;
void rtw_ps_processor23a(struct rtw_adapter *padapter ) ;
void LPS_Enter23a(struct rtw_adapter *padapter ) ;
void LPS_Leave23a(struct rtw_adapter *padapter ) ;
struct sta_info *rtw_alloc_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ,
                                      gfp_t gfp ) ;
struct sta_info *rtw_get_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ) ;
struct sta_info *rtw_get_bcmc_stainfo23a(struct rtw_adapter *padapter ) ;
void rtw_free_network_queue23a(struct rtw_adapter *padapter ) ;
__inline static bool check_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
  if ((pmlmepriv->fw_state & state) != 0) {
    return (1);
  } else {

  }
  return (0);
}
}
__inline static void set_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
  pmlmepriv->fw_state = pmlmepriv->fw_state | state;
  if (state == 2048) {
    pmlmepriv->bScanInProcess = 1U;
  } else {

  }
  return;
}
}
__inline static void _clr_fwstate_(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
  pmlmepriv->fw_state = pmlmepriv->fw_state & ~ state;
  if (state == 2048) {
    pmlmepriv->bScanInProcess = 0U;
  } else {

  }
  return;
}
}
__inline static void clr_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 
  bool tmp ;

  {
  spin_lock_bh(& pmlmepriv->lock);
  tmp = check_fwstate(pmlmepriv, state);
  if ((int )tmp) {
    pmlmepriv->fw_state = pmlmepriv->fw_state ^ state;
  } else {

  }
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
struct wlan_network *rtw_get_oldest_wlan_network23a(struct rtw_queue *scanned_queue ) ;
void rtw_indicate_connect23a(struct rtw_adapter *padapter ) ;
int rtw_restruct_sec_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len ) ;
int rtw_restruct_wmm_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len , uint initial_out_len ) ;
struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv , gfp_t gfp ) ;
bool rtw_restructure_ht_ie23a(struct rtw_adapter *padapter , u8 *in_ie , u8 *out_ie ,
                              uint in_len , uint *pout_len ) ;
u32 GlobalDebugLevel23A ;
void rt_trace(int comp , int level , char const   *fmt  , ...) ;
void clear_cam_entry23a(struct rtw_adapter *padapter , u8 entry ) ;
unsigned char check_assoc_AP23a(u8 *pframe , uint len ) ;
void linked_status_chk23a(struct rtw_adapter *padapter ) ;
int NULL_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int join_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int disconnect_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int createbss_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int setopmode_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int sitesurvey_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int setauth_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int setkey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int set_stakey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int add_ba_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int mlme_evt_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int h2c_msg_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int tx_beacon_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int set_ch_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int set_chplan_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int led_blink_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int set_csa_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
int tdls_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
void update_beacon23a(struct rtw_adapter *padapter , u8 ie_id , u8 *oui , u8 tx ) ;
void expire_timeout_chk23a(struct rtw_adapter *padapter ) ;
void rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter , u8 mstatus ) ;
bool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter ) ;
bool rtl8723a_BT_coexist(struct rtw_adapter *padapter ) ;
void rtl8723a_BT_do_coexist(struct rtw_adapter *padapter ) ;
void rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter , u8 scanType ) ;
void rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) ;
void rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter ) ;
void rtl8723a_BT_lps_leave(struct rtw_adapter *padapter ) ;
void rtl8723a_HalDmWatchDog(struct rtw_adapter *Adapter ) ;
void rtl8723a_sreset_xmit_status_check(struct rtw_adapter *padapter ) ;
bool c2h_id_filter_ccx_8723a(u8 id ) ;
int c2h_handler_8723a(struct rtw_adapter *padapter , struct c2h_evt_hdr *c2h_evt ) ;
static struct cmd_hdl wlancmds[63U]  = 
  {      {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {871U, & join_cmd_hdl23a}, 
        {4U, & disconnect_hdl23a}, 
        {871U, & createbss_hdl23a}, 
        {4U, & setopmode_hdl23a}, 
        {712U, & sitesurvey_cmd_hdl23a}, 
        {4U, & setauth_hdl23a}, 
        {24U, & setkey_hdl23a}, 
        {28U, & set_stakey_hdl23a}, 
        {6U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {6U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {8U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {13U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {14U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {128U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {2U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {12U, & add_ba_hdl23a}, 
        {3U, & set_ch_hdl23a}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {871U, & tx_beacon_hdl23a}, 
        {0U, & mlme_evt_hdl23a}, 
        {0U, & rtw_drvextra_cmd_hdl23a}, 
        {0U, & h2c_msg_hdl23a}, 
        {1U, & set_chplan_hdl23a}, 
        {8U, & led_blink_hdl23a}, 
        {1U, & set_csa_hdl23a}, 
        {7U, & tdls_hdl23a}};
struct _cmd_callback rtw_cmd_callback[63U]  = 
  {      {0U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {1U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {2U, & rtw_getbbrfreg_cmdrsp_callback23a}, 
        {3U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {4U, & rtw_getbbrfreg_cmdrsp_callback23a}, 
        {5U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {6U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {7U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {8U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {9U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {10U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {11U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {12U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {13U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {14U, & rtw_joinbss_cmd23a_callback}, 
        {15U, & rtw_disassoc_cmd23a_callback}, 
        {16U, & rtw_createbss_cmd23a_callback}, 
        {17U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {18U, & rtw_survey_cmd_callback23a}, 
        {19U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {20U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {21U, & rtw_setstaKey_cmdrsp_callback23a}, 
        {22U, & rtw_setassocsta_cmdrsp_callback23a}, 
        {23U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {24U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {25U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {26U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {27U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {28U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {29U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {30U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {31U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {32U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {33U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {34U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {35U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {36U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {37U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {38U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {39U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {40U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {41U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {42U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {43U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {44U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {45U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {46U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {47U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {48U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {49U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {50U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {51U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {52U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {53U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {54U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {55U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {56U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {57U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {58U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {59U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {60U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {61U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {62U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}};
int rtw_init_cmd_priv23a(struct cmd_priv *pcmdpriv ) 
{ 
  int res ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
  res = 1;
  pcmdpriv->cmd_issued_cnt = 0U;
  pcmdpriv->cmd_done_cnt = 0U;
  pcmdpriv->rsp_cnt = 0U;
  __lock_name = "\"rtl8723au_cmd\"";
  tmp = __alloc_workqueue_key("rtl8723au_cmd", 0U, 1, & __key, __lock_name);
  pcmdpriv->wq = tmp;
  if ((unsigned long )pcmdpriv->wq == (unsigned long )((struct workqueue_struct *)0)) {
    res = 0;
  } else {

  }
  return (res);
}
}
static void rtw_irq_work(struct work_struct *work ) ;
u32 rtw_init_evt_priv23a(struct evt_priv *pevtpriv ) 
{ 
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;

  {
  __lock_name = "\"rtl8723au_evt\"";
  tmp = __alloc_workqueue_key("rtl8723au_evt", 0U, 1, & __key, __lock_name);
  pevtpriv->wq = tmp;
  __init_work(& pevtpriv->irq_wk, 0);
  __constr_expr_0.counter = 137438953408L;
  pevtpriv->irq_wk.data = __constr_expr_0;
  lockdep_init_map(& pevtpriv->irq_wk.lockdep_map, "(&pevtpriv->irq_wk)", & __key___0,
                   0);
  INIT_LIST_HEAD(& pevtpriv->irq_wk.entry);
  pevtpriv->irq_wk.func = & rtw_irq_work;
  return (1U);
}
}
void rtw_free_evt_priv23a(struct evt_priv *pevtpriv ) 
{ 


  {
  ldv_cancel_work_sync_10(& pevtpriv->irq_wk);
  return;
}
}
static int rtw_cmd_filter(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) 
{ 
  u8 bAllow ;

  {
  bAllow = 0U;
  if ((unsigned int )cmd_obj->cmdcode == 59U) {
    bAllow = 1U;
  } else {

  }
  if ((unsigned int )(pcmdpriv->padapter)->hw_init_completed == 0U && (unsigned int )bAllow == 0U) {
    return (0);
  } else {

  }
  return (1);
}
}
static void rtw_cmd_work(struct work_struct *work ) ;
int rtw_enqueue_cmd23a(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) 
{ 
  int res ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  bool tmp ;

  {
  res = 0;
  if ((unsigned long )cmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    goto exit;
  } else {

  }
  cmd_obj->padapter = pcmdpriv->padapter;
  res = rtw_cmd_filter(pcmdpriv, cmd_obj);
  if (res == 0) {
    rtw_free_cmd_obj23a(cmd_obj);
    goto exit;
  } else {

  }
  __init_work(& cmd_obj->work, 0);
  __constr_expr_0.counter = 137438953408L;
  cmd_obj->work.data = __constr_expr_0;
  lockdep_init_map(& cmd_obj->work.lockdep_map, "(&cmd_obj->work)", & __key, 0);
  INIT_LIST_HEAD(& cmd_obj->work.entry);
  cmd_obj->work.func = & rtw_cmd_work;
  tmp = queue_work(pcmdpriv->wq, & cmd_obj->work);
  res = (int )tmp;
  if (res == 0) {
    printk("\v%s: Call to queue_work() failed\n", "rtw_enqueue_cmd23a");
    res = 0;
  } else {
    res = 1;
  }
  exit: ;
  return (res);
}
}
void rtw_free_cmd_obj23a(struct cmd_obj *pcmd ) 
{ 


  {
  if ((unsigned int )pcmd->cmdcode != 14U && (unsigned int )pcmd->cmdcode != 16U) {
    kfree((void const   *)pcmd->parmbuf);
  } else {

  }
  if ((unsigned long )pcmd->rsp != (unsigned long )((u8 *)0U)) {
    if (pcmd->rspsz != 0U) {
      kfree((void const   *)pcmd->rsp);
    } else {

    }
  } else {

  }
  kfree((void const   *)pcmd);
  return;
}
}
static void rtw_cmd_work(struct work_struct *work ) 
{ 
  int (*cmd_hdl)(struct rtw_adapter * , u8 const   * ) ;
  void (*pcmd_callback)(struct rtw_adapter * , struct cmd_obj * ) ;
  struct cmd_priv *pcmdpriv ;
  struct cmd_obj *pcmd ;
  struct work_struct  const  *__mptr ;
  int tmp ;

  {
  __mptr = (struct work_struct  const  *)work;
  pcmd = (struct cmd_obj *)__mptr;
  pcmdpriv = & (pcmd->padapter)->cmdpriv;
  tmp = rtw_cmd_filter(pcmdpriv, pcmd);
  if (tmp == 0) {
    pcmd->res = 3;
    goto post_process;
  } else {

  }
  pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_issued_cnt + 1U;
  pcmd->cmdsz = (pcmd->cmdsz + 3U) & 4294967292U;
  if ((unsigned int )pcmd->cmdcode <= 62U) {
    cmd_hdl = wlancmds[(int )pcmd->cmdcode].h2cfuns;
    if ((unsigned long )cmd_hdl != (unsigned long )((int (*)(struct rtw_adapter * ,
                                                             u8 const   * ))0)) {
      pcmd->res = (*cmd_hdl)(pcmd->padapter, (u8 const   *)pcmd->parmbuf);
    } else {
      pcmd->res = 3;
    }
  } else {
    pcmd->res = 4;
  }
  post_process: ;
  if ((unsigned int )pcmd->cmdcode <= 62U) {
    pcmd_callback = rtw_cmd_callback[(int )pcmd->cmdcode].callback;
    if ((unsigned long )pcmd_callback == (unsigned long )((void (*)(struct rtw_adapter * ,
                                                                    struct cmd_obj * ))0)) {
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(128, 7, "mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n",
                 pcmd_callback, (int )pcmd->cmdcode);
      } else {

      }
      rtw_free_cmd_obj23a(pcmd);
    } else {
      (*pcmd_callback)(pcmd->padapter, pcmd);
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "%s: cmdcode = 0x%x callback not defined!\n", "rtw_cmd_work",
               (int )pcmd->cmdcode);
    } else {

    }
    rtw_free_cmd_obj23a(pcmd);
  }
  return;
}
}
int rtw_sitesurvey_cmd23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ,
                          int ssid_num , struct rtw_ieee80211_channel *ch , int ch_num ) 
{ 
  int res ;
  struct cmd_obj *ph2c ;
  struct sitesurvey_parm *psurveyPara ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int i ;
  int i___0 ;
  unsigned long tmp___2 ;

  {
  res = 0;
  pcmdpriv = & padapter->cmdpriv;
  pmlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    rtw_lps_ctrl_wk_cmd23a(padapter, 0, 1);
  } else {

  }
  tmp___0 = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp___0;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    return (0);
  } else {

  }
  tmp___1 = kzalloc(712UL, 32U);
  psurveyPara = (struct sitesurvey_parm *)tmp___1;
  if ((unsigned long )psurveyPara == (unsigned long )((struct sitesurvey_parm *)0)) {
    kfree((void const   *)ph2c);
    return (0);
  } else {

  }
  rtw_free_network_queue23a(padapter);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(128, 7, "%s: flush network queue\n", "rtw_sitesurvey_cmd23a");
  } else {

  }
  ph2c->cmdcode = 18U;
  ph2c->parmbuf = (u8 *)psurveyPara;
  ph2c->cmdsz = 712U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  psurveyPara->scan_mode = (int )pmlmepriv->scan_mode;
  if ((unsigned long )ssid != (unsigned long )((struct cfg80211_ssid *)0)) {
    i = 0;
    goto ldv_55841;
    ldv_55840: ;
    if ((unsigned int )(ssid + (unsigned long )i)->ssid_len != 0U) {
      memcpy((void *)(& psurveyPara->ssid) + (unsigned long )i, (void const   *)ssid + (unsigned long )i,
               33UL);
      psurveyPara->ssid_num = (u8 )((int )psurveyPara->ssid_num + 1);
    } else {

    }
    i = i + 1;
    ldv_55841: ;
    if (i < ssid_num && i <= 8) {
      goto ldv_55840;
    } else {

    }

  } else {

  }
  if ((unsigned long )ch != (unsigned long )((struct rtw_ieee80211_channel *)0)) {
    i___0 = 0;
    goto ldv_55845;
    ldv_55844: ;
    if ((unsigned int )(ch + (unsigned long )i___0)->hw_value != 0U && ((ch + (unsigned long )i___0)->flags & 1U) == 0U) {
      memcpy((void *)(& psurveyPara->ch) + (unsigned long )i___0, (void const   *)ch + (unsigned long )i___0,
               8UL);
      psurveyPara->ch_num = (u8 )((int )psurveyPara->ch_num + 1);
    } else {

    }
    i___0 = i___0 + 1;
    ldv_55845: ;
    if (i___0 < ch_num && i___0 <= 50) {
      goto ldv_55844;
    } else {

    }

  } else {

  }
  set_fwstate(pmlmepriv, 2048);
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  if (res == 1) {
    tmp___2 = msecs_to_jiffies(8000U);
    ldv_mod_timer_11(& pmlmepriv->scan_to_timer, tmp___2 + (unsigned long )jiffies);
    pmlmepriv->scan_interval = 30U;
  } else {
    _clr_fwstate_(pmlmepriv, 2048);
  }
  return (res);
}
}
void rtw_getbbrfreg_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 


  {
  kfree((void const   *)pcmd->parmbuf);
  kfree((void const   *)pcmd);
  return;
}
}
int rtw_createbss_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *pcmd ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 res ;
  void *tmp ;
  int tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  pmlmepriv = & padapter->mlmepriv;
  res = 1U;
  pdev_network = & padapter->registrypriv.dev_network;
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(128, 7, "createbss for Any SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
    } else {

    }
  } else
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(128, 7, "createbss for SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
  tmp = kzalloc(128UL, 32U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0U;
    goto exit;
  } else {

  }
  pcmd->cmdcode = 16U;
  pcmd->parmbuf = (u8 *)pdev_network;
  pcmd->cmdsz = get_wlan_bssid_ex_sz(pdev_network);
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  pdev_network->Length = pcmd->cmdsz;
  tmp___0 = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  res = (u8 )tmp___0;
  exit: ;
  return ((int )res);
}
}
int rtw_joinbss_cmd23a(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) 
{ 
  int res ;
  struct wlan_bssid_ex *psecnetwork ;
  struct cmd_obj *pcmd ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct registry_priv *pregistrypriv ;
  struct ht_priv *phtpriv ;
  enum nl80211_iftype ifmode ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  uint tmp___2 ;
  int tmp___3 ;
  u32 tmp_len ;
  int tmp___4 ;
  u32 algo ;

  {
  res = 1;
  pcmdpriv = & padapter->cmdpriv;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pregistrypriv = & padapter->registrypriv;
  phtpriv = & pmlmepriv->htpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ifmode = pnetwork->network.ifmode;
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(128, 7, "+Join cmd: Any SSid\n");
    } else {

    }
  } else
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(128, 6, "+Join cmd: SSid =[%s]\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
  tmp = kzalloc(128UL, 32U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "rtw_joinbss_cmd23a: memory allocate for cmd_obj fail!!!\n");
    } else {

    }
    goto exit;
  } else {

  }
  tmp___0 = check_fwstate(pmlmepriv, 40);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    switch ((unsigned int )ifmode) {
    case 1U: 
    set_fwstate(pmlmepriv, 32);
    goto ldv_55877;
    case 8U: ;
    case 2U: 
    set_fwstate(pmlmepriv, 8);
    goto ldv_55877;
    default: ;
    goto ldv_55877;
    }
    ldv_55877: ;
  } else {

  }
  psecnetwork = & psecuritypriv->sec_bss;
  if ((unsigned long )psecnetwork == (unsigned long )((struct wlan_bssid_ex *)0)) {
    kfree((void const   *)pcmd);
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "rtw_joinbss_cmd23a :psecnetwork == NULL!!!\n");
    } else {

    }
    goto exit;
  } else {

  }
  memset((void *)psecnetwork, 0, 871UL);
  tmp___2 = get_wlan_bssid_ex_sz(& pnetwork->network);
  memcpy((void *)psecnetwork, (void const   *)(& pnetwork->network), (size_t )tmp___2);
  psecnetwork->IELength = 0U;
  if (pmlmepriv->assoc_by_bssid == 0U) {
    ether_addr_copy((u8 *)(& pmlmepriv->assoc_bssid), (u8 const   *)(& pnetwork->network.MacAddress));
  } else {

  }
  tmp___3 = rtw_restruct_sec_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                                   pnetwork->network.IELength);
  psecnetwork->IELength = (u32 )tmp___3;
  pmlmepriv->qos_option = 0U;
  if ((unsigned int )pregistrypriv->wmm_enable != 0U) {
    tmp___4 = rtw_restruct_wmm_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                                     pnetwork->network.IELength, psecnetwork->IELength);
    tmp_len = (u32 )tmp___4;
    if (psecnetwork->IELength != tmp_len) {
      psecnetwork->IELength = tmp_len;
      pmlmepriv->qos_option = 1U;
    } else {
      pmlmepriv->qos_option = 0U;
    }
  } else {

  }
  phtpriv->ht_option = 0;
  if ((unsigned int )pregistrypriv->ht_enable != 0U) {
    algo = padapter->securitypriv.dot11PrivacyAlgrthm;
    if ((algo != 1027073U && algo != 1027077U) && algo != 1027074U) {
      rtw_restructure_ht_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                               pnetwork->network.IELength, & psecnetwork->IELength);
    } else {

    }
  } else {

  }
  pmlmeinfo->assoc_AP_vendor = check_assoc_AP23a((u8 *)(& pnetwork->network.IEs),
                                                 pnetwork->network.IELength);
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 16U) {
    padapter->pwrctrlpriv.smart_ps = 0U;
  } else {
    padapter->pwrctrlpriv.smart_ps = padapter->registrypriv.smart_ps;
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: smart_ps =%d\n", "rtw_joinbss_cmd23a", (int )padapter->pwrctrlpriv.smart_ps);
  } else {

  }
  pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);
  pcmd->cmdcode = 14U;
  pcmd->parmbuf = (u8 *)psecnetwork;
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
  return (res);
}
}
int rtw_disassoc_cmd23a(struct rtw_adapter *padapter , u32 deauth_timeout_ms , bool enqueue ) 
{ 
  struct cmd_obj *cmdobj ;
  struct disconnect_parm *param ;
  struct cmd_priv *cmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  cmdobj = (struct cmd_obj *)0;
  param = (struct disconnect_parm *)0;
  cmdpriv = & padapter->cmdpriv;
  res = 1;
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(128, 6, "+rtw_disassoc_cmd23a\n");
  } else {

  }
  tmp = kzalloc(4UL, 32U);
  param = (struct disconnect_parm *)tmp;
  if ((unsigned long )param == (unsigned long )((struct disconnect_parm *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  param->deauth_timeout_ms = deauth_timeout_ms;
  if ((int )enqueue) {
    tmp___0 = kzalloc(128UL, 32U);
    cmdobj = (struct cmd_obj *)tmp___0;
    if ((unsigned long )cmdobj == (unsigned long )((struct cmd_obj *)0)) {
      res = 0;
      kfree((void const   *)param);
      goto exit;
    } else {

    }
    cmdobj->cmdcode = 15U;
    cmdobj->parmbuf = (u8 *)param;
    cmdobj->cmdsz = 4U;
    cmdobj->rsp = (u8 *)0U;
    cmdobj->rspsz = 0U;
    res = rtw_enqueue_cmd23a(cmdpriv, cmdobj);
  } else {
    tmp___1 = disconnect_hdl23a(padapter, (u8 const   *)param);
    if (tmp___1 != 0) {
      res = 0;
    } else {

    }
    kfree((void const   *)param);
  }
  exit: ;
  return (res);
}
}
int rtw_setopmode_cmd23a(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) 
{ 
  struct cmd_obj *ph2c ;
  struct setopmode_parm *psetop ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 208U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(4UL, 208U);
  psetop = (struct setopmode_parm *)tmp___0;
  if ((unsigned long )psetop == (unsigned long )((struct setopmode_parm *)0)) {
    kfree((void const   *)ph2c);
    res = 0;
    goto exit;
  } else {

  }
  ph2c->cmdcode = 17U;
  ph2c->parmbuf = (u8 *)psetop;
  ph2c->cmdsz = 4U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  psetop->mode = ifmode;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_setstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 unicast_key ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct sta_info *sta ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  int idx ;

  {
  pcmdpriv = & padapter->cmdpriv;
  psetstakey_rsp = (struct set_stakey_rsp *)0;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  sta = (struct sta_info *)psta;
  res = 1;
  tmp = kzalloc(128UL, 208U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(28UL, 208U);
  psetstakey_para = (struct set_stakey_parm *)tmp___0;
  if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
    kfree((void const   *)ph2c);
    res = 0;
    goto exit;
  } else {

  }
  tmp___1 = kzalloc(8UL, 208U);
  psetstakey_rsp = (struct set_stakey_rsp *)tmp___1;
  if ((unsigned long )psetstakey_rsp == (unsigned long )((struct set_stakey_rsp *)0)) {
    kfree((void const   *)ph2c);
    kfree((void const   *)psetstakey_para);
    res = 0;
    goto exit;
  } else {

  }
  ph2c->cmdcode = 21U;
  ph2c->parmbuf = (u8 *)psetstakey_para;
  ph2c->cmdsz = 28U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  ph2c->rsp = (u8 *)psetstakey_rsp;
  ph2c->rspsz = 8U;
  ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& sta->hwaddr));
  tmp___2 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___2) {
    psetstakey_para->algorithm = (u32 )((unsigned char )psecuritypriv->dot11PrivacyAlgrthm);
  } else {
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
    psetstakey_para->algorithm = psecuritypriv->dot11PrivacyAlgrthm;
    goto ldv_55920;
    case 2U: 
    psetstakey_para->algorithm = sta->dot118021XPrivacy;
    goto ldv_55920;
    }
    ldv_55920: ;
  }
  if ((unsigned int )unicast_key == 1U) {
    memcpy((void *)(& psetstakey_para->key), (void const   *)(& sta->dot118021x_UncstKey),
             16UL);
  } else {
    idx = (int )psecuritypriv->dot118021XGrpKeyid;
    memcpy((void *)(& psetstakey_para->key), (void const   *)(& psecuritypriv->dot118021XGrpKey[idx].skey),
             16UL);
  }
  padapter->securitypriv.busetkipkey = 1U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_clearstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 entry , u8 enqueue ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct sta_info *sta ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  psetstakey_rsp = (struct set_stakey_rsp *)0;
  sta = (struct sta_info *)psta;
  res = 1;
  if ((unsigned int )enqueue == 0U) {
    clear_cam_entry23a(padapter, (int )entry);
  } else {
    tmp = kzalloc(128UL, 208U);
    ph2c = (struct cmd_obj *)tmp;
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
      res = 0;
      goto exit;
    } else {

    }
    tmp___0 = kzalloc(28UL, 208U);
    psetstakey_para = (struct set_stakey_parm *)tmp___0;
    if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
      kfree((void const   *)ph2c);
      res = 0;
      goto exit;
    } else {

    }
    tmp___1 = kzalloc(8UL, 208U);
    psetstakey_rsp = (struct set_stakey_rsp *)tmp___1;
    if ((unsigned long )psetstakey_rsp == (unsigned long )((struct set_stakey_rsp *)0)) {
      kfree((void const   *)ph2c);
      kfree((void const   *)psetstakey_para);
      res = 0;
      goto exit;
    } else {

    }
    ph2c->cmdcode = 21U;
    ph2c->parmbuf = (u8 *)psetstakey_para;
    ph2c->cmdsz = 28U;
    ph2c->rsp = (u8 *)0U;
    ph2c->rspsz = 0U;
    ph2c->rsp = (u8 *)psetstakey_rsp;
    ph2c->rspsz = 8U;
    ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& sta->hwaddr));
    psetstakey_para->algorithm = 0U;
    psetstakey_para->id = entry;
    res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  }
  exit: ;
  return (res);
}
}
int rtw_addbareq_cmd23a(struct rtw_adapter *padapter , u8 tid , u8 *addr ) 
{ 
  struct cmd_priv *pcmdpriv ;
  struct cmd_obj *ph2c ;
  struct addBaReq_parm *paddbareq_parm ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  if ((unsigned int )tid > 15U) {
    res = 0;
    goto exit;
  } else {

  }
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(12UL, 32U);
  paddbareq_parm = (struct addBaReq_parm *)tmp___0;
  if ((unsigned long )paddbareq_parm == (unsigned long )((struct addBaReq_parm *)0)) {
    kfree((void const   *)ph2c);
    res = 0;
    goto exit;
  } else {

  }
  paddbareq_parm->tid = (unsigned int )tid;
  ether_addr_copy((u8 *)(& paddbareq_parm->addr), (u8 const   *)addr);
  ph2c->cmdcode = 45U;
  ph2c->parmbuf = (u8 *)paddbareq_parm;
  ph2c->cmdsz = 12U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_dynamic_chk_wk_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(16UL, 32U);
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
    kfree((void const   *)ph2c);
    res = 0;
    goto exit;
  } else {

  }
  pdrvextra_cmd_parm->ec_id = 1;
  pdrvextra_cmd_parm->type_size = 0;
  pdrvextra_cmd_parm->pbuf = (unsigned char *)padapter;
  ph2c->cmdcode = 57U;
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
  ph2c->cmdsz = 16U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
static void traffic_status_watchdog(struct rtw_adapter *padapter ) 
{ 
  u8 bEnterPS ;
  u8 bBusyTraffic ;
  u8 bTxBusyTraffic ;
  u8 bRxBusyTraffic ;
  u8 bHigherBusyTraffic ;
  u8 bHigherBusyRxTraffic ;
  u8 bHigherBusyTxTraffic ;
  struct mlme_priv *pmlmepriv ;
  int BusyThreshold ;
  struct rt_link_detect *ldi ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;

  {
  bBusyTraffic = 0U;
  bTxBusyTraffic = 0U;
  bRxBusyTraffic = 0U;
  bHigherBusyTraffic = 0U;
  bHigherBusyRxTraffic = 0U;
  bHigherBusyTxTraffic = 0U;
  pmlmepriv = & padapter->mlmepriv;
  BusyThreshold = 100;
  ldi = & pmlmepriv->LinkDetectInfo;
  tmp___4 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___4) {
    tmp = rtl8723a_BT_coexist(padapter);
    if ((int )tmp) {
      BusyThreshold = 50;
    } else
    if ((int )ldi->bBusyTraffic) {
      BusyThreshold = 75;
    } else {

    }
    if (ldi->NumRxOkInPeriod > (u32 )BusyThreshold || ldi->NumTxOkInPeriod > (u32 )BusyThreshold) {
      bBusyTraffic = 1U;
      if (ldi->NumRxOkInPeriod > ldi->NumTxOkInPeriod) {
        bRxBusyTraffic = 1U;
      } else {
        bTxBusyTraffic = 1U;
      }
    } else {

    }
    if (ldi->NumRxOkInPeriod > 4000U || ldi->NumTxOkInPeriod > 4000U) {
      bHigherBusyTraffic = 1U;
      if (ldi->NumRxOkInPeriod > ldi->NumTxOkInPeriod) {
        bHigherBusyRxTraffic = 1U;
      } else {
        bHigherBusyTxTraffic = 1U;
      }
    } else {

    }
    tmp___0 = rtl8723a_BT_coexist(padapter);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      goto _L;
    } else {
      tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
      if (tmp___2) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
      if (tmp___3) {
        _L: /* CIL Label */ 
        if (ldi->NumRxUnicastOkInPeriod + ldi->NumTxOkInPeriod > 8U || ldi->NumRxUnicastOkInPeriod > 2U) {
          bEnterPS = 0U;
        } else {
          bEnterPS = 1U;
        }
        if ((unsigned int )bEnterPS != 0U) {
          LPS_Enter23a(padapter);
        } else {
          LPS_Leave23a(padapter);
        }
      } else {

      }
    }
  } else {
    LPS_Leave23a(padapter);
  }
  ldi->NumRxOkInPeriod = 0U;
  ldi->NumTxOkInPeriod = 0U;
  ldi->NumRxUnicastOkInPeriod = 0U;
  ldi->bBusyTraffic = (unsigned int )bBusyTraffic != 0U;
  ldi->bTxBusyTraffic = (unsigned int )bTxBusyTraffic != 0U;
  ldi->bRxBusyTraffic = (unsigned int )bRxBusyTraffic != 0U;
  ldi->bHigherBusyTraffic = (unsigned int )bHigherBusyTraffic != 0U;
  ldi->bHigherBusyRxTraffic = (unsigned int )bHigherBusyRxTraffic != 0U;
  ldi->bHigherBusyTxTraffic = (unsigned int )bHigherBusyTxTraffic != 0U;
  return;
}
}
static void dynamic_chk_wk_hdl(struct rtw_adapter *padapter , u8 *pbuf , int sz ) 
{ 
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
  padapter = (struct rtw_adapter *)pbuf;
  pmlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    expire_timeout_chk23a(padapter);
  } else {

  }
  rtl8723a_sreset_xmit_status_check(padapter);
  linked_status_chk23a(padapter);
  traffic_status_watchdog(padapter);
  rtl8723a_HalDmWatchDog(padapter);
  rtl8723a_BT_do_coexist(padapter);
  return;
}
}
static void lps_ctrl_wk_hdl(struct rtw_adapter *padapter , u8 lps_ctrl_type ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  u8 mstatus ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  pmlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 64);
  if ((int )tmp) {
    return;
  } else {
    tmp___0 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___0) {
      return;
    } else {

    }
  }
  switch ((int )lps_ctrl_type) {
  case 0: 
  rtl8723a_BT_wifiscan_notify(padapter, 1);
  tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    tmp___1 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___1) {
      LPS_Leave23a(padapter);
    } else {

    }
  } else {

  }
  goto ldv_55981;
  case 1: 
  LPS_Leave23a(padapter);
  goto ldv_55981;
  case 2: 
  mstatus = 1U;
  padapter->pwrctrlpriv.LpsIdleCount = 0U;
  rtl8723a_set_FwJoinBssReport_cmd(padapter, 1);
  rtl8723a_BT_mediastatus_notify(padapter, (enum rt_media_status )mstatus);
  goto ldv_55981;
  case 3: 
  mstatus = 0U;
  rtl8723a_BT_mediastatus_notify(padapter, (enum rt_media_status )mstatus);
  tmp___4 = rtl8723a_BT_using_antenna_1(padapter);
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    LPS_Leave23a(padapter);
  } else {

  }
  rtl8723a_set_FwJoinBssReport_cmd(padapter, 0);
  goto ldv_55981;
  case 4: 
  pwrpriv->DelayLPSLastTimeStamp = jiffies;
  rtl8723a_BT_specialpacket_notify(padapter);
  tmp___6 = rtl8723a_BT_using_antenna_1(padapter);
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    LPS_Leave23a(padapter);
  } else {

  }
  goto ldv_55981;
  case 5: 
  rtl8723a_BT_lps_leave(padapter);
  tmp___8 = rtl8723a_BT_using_antenna_1(padapter);
  if (tmp___8) {
    tmp___9 = 0;
  } else {
    tmp___9 = 1;
  }
  if (tmp___9) {
    LPS_Leave23a(padapter);
  } else {

  }
  goto ldv_55981;
  default: ;
  goto ldv_55981;
  }
  ldv_55981: ;
  return;
}
}
int rtw_lps_ctrl_wk_cmd23a(struct rtw_adapter *padapter , u8 lps_ctrl_type , u8 enqueue ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  if ((unsigned int )enqueue != 0U) {
    tmp = kzalloc(128UL, 32U);
    ph2c = (struct cmd_obj *)tmp;
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
      res = 0;
      goto exit;
    } else {

    }
    tmp___0 = kzalloc(16UL, 32U);
    pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
    if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
      kfree((void const   *)ph2c);
      res = 0;
      goto exit;
    } else {

    }
    pdrvextra_cmd_parm->ec_id = 5;
    pdrvextra_cmd_parm->type_size = (int )lps_ctrl_type;
    pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
    ph2c->cmdcode = 57U;
    ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
    ph2c->cmdsz = 16U;
    ph2c->rsp = (u8 *)0U;
    ph2c->rspsz = 0U;
    res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  } else {
    lps_ctrl_wk_hdl(padapter, (int )lps_ctrl_type);
  }
  exit: ;
  return (res);
}
}
int rtw_ps_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ppscmd ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 32U);
  ppscmd = (struct cmd_obj *)tmp;
  if ((unsigned long )ppscmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(16UL, 32U);
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
    kfree((void const   *)ppscmd);
    res = 0;
    goto exit;
  } else {

  }
  pdrvextra_cmd_parm->ec_id = 4;
  pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
  ppscmd->cmdcode = 57U;
  ppscmd->parmbuf = (u8 *)pdrvextra_cmd_parm;
  ppscmd->cmdsz = 16U;
  ppscmd->rsp = (u8 *)0U;
  ppscmd->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ppscmd);
  exit: ;
  return (res);
}
}
static void rtw_chk_hi_queue_hdl(struct rtw_adapter *padapter ) 
{ 
  int cnt ;
  struct sta_info *psta_bmc ;
  struct sta_priv *pstapriv ;
  bool val ;

  {
  cnt = 0;
  pstapriv = & padapter->stapriv;
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
  if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {

  }
  if (psta_bmc->sleepq_len == 0U) {
    val = rtl8723a_chk_hi_queue_empty(padapter);
    goto ldv_56015;
    ldv_56014: 
    msleep(100U);
    cnt = cnt + 1;
    if (cnt > 10) {
      goto ldv_56013;
    } else {

    }
    val = rtl8723a_chk_hi_queue_empty(padapter);
    ldv_56015: ;
    if (! val) {
      goto ldv_56014;
    } else {

    }
    ldv_56013: ;
    if (cnt <= 10) {
      pstapriv->tim_bitmap = (unsigned int )pstapriv->tim_bitmap & 65534U;
      pstapriv->sta_dz_bitmap = (unsigned int )pstapriv->sta_dz_bitmap & 65534U;
      update_beacon23a(padapter, 5, (u8 *)0U, 0);
    } else {
      rtw_chk_hi_queue_cmd23a(padapter);
    }
  } else {

  }
  return;
}
}
int rtw_chk_hi_queue_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(16UL, 32U);
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
    kfree((void const   *)ph2c);
    res = 0;
    goto exit;
  } else {

  }
  pdrvextra_cmd_parm->ec_id = 9;
  pdrvextra_cmd_parm->type_size = 0;
  pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
  ph2c->cmdcode = 57U;
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
  ph2c->cmdsz = 16U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_c2h_wk_cmd23a(struct rtw_adapter *padapter , u8 *c2h_evt ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(16UL, 32U);
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
    kfree((void const   *)ph2c);
    res = 0;
    goto exit;
  } else {

  }
  pdrvextra_cmd_parm->ec_id = 10;
  pdrvextra_cmd_parm->type_size = (unsigned long )c2h_evt != (unsigned long )((u8 *)0U) ? 16 : 0;
  pdrvextra_cmd_parm->pbuf = c2h_evt;
  ph2c->cmdcode = 57U;
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
  ph2c->cmdsz = 16U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
static int c2h_evt_hdl(struct rtw_adapter *adapter , struct c2h_evt_hdr *c2h_evt ) 
{ 
  int ret ;
  u8 buf[16U] ;
  s32 tmp ;

  {
  ret = 0;
  if ((unsigned long )c2h_evt == (unsigned long )((struct c2h_evt_hdr *)0)) {
    tmp = c2h_evt_read23a(adapter, (u8 *)(& buf));
    if (tmp == 1) {
      c2h_evt = (struct c2h_evt_hdr *)(& buf);
      ret = c2h_handler_8723a(adapter, c2h_evt);
    } else {

    }
  } else {
    ret = c2h_handler_8723a(adapter, c2h_evt);
  }
  return (ret);
}
}
static void rtw_irq_work(struct work_struct *work ) 
{ 
  struct evt_priv *evtpriv ;
  struct rtw_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct evt_priv  const  *__mptr___0 ;

  {
  __mptr = (struct work_struct  const  *)work;
  evtpriv = (struct evt_priv *)__mptr + 0xfffffffffffffff8UL;
  __mptr___0 = (struct evt_priv  const  *)evtpriv;
  adapter = (struct rtw_adapter *)__mptr___0 + 0xffffffffffffe830UL;
  c2h_evt_clear23a(adapter);
  return;
}
}
void rtw_evt_work(struct work_struct *work ) 
{ 
  struct evt_work *ework ;
  struct rtw_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  bool tmp ;

  {
  __mptr = (struct work_struct  const  *)work;
  ework = (struct evt_work *)__mptr + 0xfffffffffffffff0UL;
  adapter = ework->adapter;
  c2h_evt_clear23a(adapter);
  if ((unsigned int )*((unsigned char *)ework + 0UL) == 0U && (unsigned int )*((unsigned char *)ework + 0UL) == 0U) {
    kfree((void const   *)ework);
    return;
  } else {

  }
  tmp = c2h_id_filter_ccx_8723a((int )ework->u.c2h_evt.id);
  if ((int )tmp) {
    c2h_handler_8723a(adapter, & ework->u.c2h_evt);
    kfree((void const   *)ework);
  } else {
    rtw_c2h_wk_cmd23a(adapter, (u8 *)(& ework->u.c2h_evt));
  }
  return;
}
}
int rtw_drvextra_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct drvextra_cmd_parm  const  *pdrvextra_cmd ;

  {
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
    return (4);
  } else {

  }
  pdrvextra_cmd = (struct drvextra_cmd_parm  const  *)pbuf;
  switch (pdrvextra_cmd->ec_id) {
  case 1: 
  dynamic_chk_wk_hdl(padapter, (u8 *)pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
  goto ldv_56061;
  case 4: 
  rtw_ps_processor23a(padapter);
  goto ldv_56061;
  case 5: 
  lps_ctrl_wk_hdl(padapter, (int )((unsigned char )pdrvextra_cmd->type_size));
  goto ldv_56061;
  case 9: 
  rtw_chk_hi_queue_hdl(padapter);
  goto ldv_56061;
  case 10: 
  c2h_evt_hdl(padapter, (struct c2h_evt_hdr *)pdrvextra_cmd->pbuf);
  goto ldv_56061;
  default: ;
  goto ldv_56061;
  }
  ldv_56061: ;
  if ((unsigned long )pdrvextra_cmd->pbuf != (unsigned long )((unsigned char */* const  */)0U) && (int )pdrvextra_cmd->type_size > 0) {
    kfree((void const   *)pdrvextra_cmd->pbuf);
  } else {

  }
  return (0);
}
}
void rtw_survey_cmd_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  if (pcmd->res == 3) {
    tmp = msecs_to_jiffies(1U);
    ldv_mod_timer_12(& pmlmepriv->scan_to_timer, tmp + (unsigned long )jiffies);
  } else
  if (pcmd->res != 0) {
    tmp___0 = msecs_to_jiffies(1U);
    ldv_mod_timer_13(& pmlmepriv->scan_to_timer, tmp___0 + (unsigned long )jiffies);
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "********Error: MgntActrtw_set_802_11_bssid23a_LIST_SCAN Fail ************\n");
    } else {

    }
  } else {

  }
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_disassoc_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
  pmlmepriv = & padapter->mlmepriv;
  if (pcmd->res != 0) {
    spin_lock_bh(& pmlmepriv->lock);
    set_fwstate(pmlmepriv, 1);
    spin_unlock_bh(& pmlmepriv->lock);
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "***Error: disconnect_cmd_callback Fail ***\n");
    } else {

    }
    return;
  } else {

  }
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_joinbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  if (pcmd->res == 3) {
    tmp = msecs_to_jiffies(1U);
    ldv_mod_timer_14(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
  } else
  if (pcmd->res != 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n");
    } else {

    }
    tmp___0 = msecs_to_jiffies(1U);
    ldv_mod_timer_15(& pmlmepriv->assoc_timer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_createbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_info *psta ;
  struct wlan_network *pwlan ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_network *tgt_network ;
  unsigned long tmp ;
  uint tmp___0 ;
  bool tmp___1 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;
  tgt_network = & pmlmepriv->cur_network;
  if (pcmd->res != 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "********Error: rtw_createbss_cmd23a_callback  Fail ************\n");
    } else {

    }
    tmp = msecs_to_jiffies(1U);
    ldv_mod_timer_16(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
  } else {

  }
  ldv_del_timer_sync_17(& pmlmepriv->assoc_timer);
  tmp___1 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___1) {
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pnetwork->MacAddress));
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
      psta = rtw_alloc_stainfo23a(& padapter->stapriv, (u8 const   *)(& pnetwork->MacAddress),
                                  208U);
      if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(128, 4, "Can\'t alloc sta_info when createbss_cmd_callback\n");
        } else {

        }
        goto createbss_cmd_fail;
      } else {

      }
    } else {

    }
    spin_lock_bh(& pmlmepriv->lock);
    rtw_indicate_connect23a(padapter);
    spin_unlock_bh(& pmlmepriv->lock);
  } else {
    pwlan = rtw_alloc_network(pmlmepriv, 208U);
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
    if ((unsigned long )pwlan == (unsigned long )((struct wlan_network *)0)) {
      pwlan = rtw_get_oldest_wlan_network23a(& pmlmepriv->scanned_queue);
      if ((unsigned long )pwlan == (unsigned long )((struct wlan_network *)0)) {
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(128, 4, "Error:  can\'t get pwlan in rtw23a_joinbss_event_cb\n");
        } else {

        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        goto createbss_cmd_fail;
      } else {

      }
      pwlan->last_scanned = jiffies;
    } else {
      list_add_tail(& pwlan->list, & pmlmepriv->scanned_queue.queue);
    }
    pnetwork->Length = get_wlan_bssid_ex_sz(pnetwork);
    memcpy((void *)(& pwlan->network), (void const   *)pnetwork, (size_t )pnetwork->Length);
    tmp___0 = get_wlan_bssid_ex_sz(pnetwork);
    memcpy((void *)(& tgt_network->network), (void const   *)pnetwork, (size_t )tmp___0);
    clr_fwstate(pmlmepriv, 128);
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  }
  createbss_cmd_fail: 
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_setstaKey_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_priv *pstapriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct sta_info *psta ;

  {
  pstapriv = & padapter->stapriv;
  psetstakey_rsp = (struct set_stakey_rsp *)pcmd->rsp;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& psetstakey_rsp->addr));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "OLD_ERROR: rtw_setstaKey_cmdrsp_callback23a => can\'t get sta_info\n");
    } else {

    }
    goto exit;
  } else {

  }
  exit: 
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_setassocsta_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct set_assocsta_parm *passocsta_parm ;
  struct set_assocsta_rsp *passocsta_rsp ;
  struct sta_info *psta ;
  uint tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  pstapriv = & padapter->stapriv;
  pmlmepriv = & padapter->mlmepriv;
  passocsta_parm = (struct set_assocsta_parm *)pcmd->parmbuf;
  passocsta_rsp = (struct set_assocsta_rsp *)pcmd->rsp;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& passocsta_parm->addr));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "OLD_ERROR: setassocsta_cmdrsp_callbac => can\'t get sta_info\n");
    } else {

    }
    goto exit;
  } else {

  }
  tmp = (uint )passocsta_rsp->cam_id;
  psta->mac_id = tmp;
  psta->aid = tmp;
  spin_lock_bh(& pmlmepriv->lock);
  tmp___0 = check_fwstate(pmlmepriv, 65536);
  if ((int )tmp___0) {
    tmp___1 = check_fwstate(pmlmepriv, 128);
    if ((int )tmp___1) {
      _clr_fwstate_(pmlmepriv, 128);
    } else {

    }
  } else {

  }
  set_fwstate(pmlmepriv, 1);
  spin_unlock_bh(& pmlmepriv->lock);
  exit: 
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
    rtw_irq_work(work);
    ldv_work_1_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
    rtw_irq_work(work);
    ldv_work_1_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
    rtw_irq_work(work);
    ldv_work_1_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
    rtw_irq_work(work);
    ldv_work_1_3 = 1;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_all_2(int state ) 
{ 


  {
  if (ldv_work_2_0 == state) {
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
  if (ldv_work_2_1 == state) {
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
  if (ldv_work_2_2 == state) {
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
  if (ldv_work_2_3 == state) {
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
  return;
}
}
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_1_0 == 0) {
    ldv_work_struct_1_0 = work;
    ldv_work_1_0 = state;
    return;
  } else {

  }
  if (ldv_work_1_1 == 0) {
    ldv_work_struct_1_1 = work;
    ldv_work_1_1 = state;
    return;
  } else {

  }
  if (ldv_work_1_2 == 0) {
    ldv_work_struct_1_2 = work;
    ldv_work_1_2 = state;
    return;
  } else {

  }
  if (ldv_work_1_3 == 0) {
    ldv_work_struct_1_3 = work;
    ldv_work_1_3 = state;
    return;
  } else {

  }
  return;
}
}
void disable_work_1(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
    ldv_work_1_0 = 1;
  } else {

  }
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
    ldv_work_1_1 = 1;
  } else {

  }
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
    ldv_work_1_2 = 1;
  } else {

  }
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
    ldv_work_1_3 = 1;
  } else {

  }
  return;
}
}
void work_init_1(void) 
{ 


  {
  ldv_work_1_0 = 0;
  ldv_work_1_1 = 0;
  ldv_work_1_2 = 0;
  ldv_work_1_3 = 0;
  return;
}
}
void invoke_work_2(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
    ldv_work_2_0 = 4;
    rtw_cmd_work(ldv_work_struct_2_0);
    ldv_work_2_0 = 1;
  } else {

  }
  goto ldv_56134;
  case 1: ;
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
    ldv_work_2_1 = 4;
    rtw_cmd_work(ldv_work_struct_2_0);
    ldv_work_2_1 = 1;
  } else {

  }
  goto ldv_56134;
  case 2: ;
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
    ldv_work_2_2 = 4;
    rtw_cmd_work(ldv_work_struct_2_0);
    ldv_work_2_2 = 1;
  } else {

  }
  goto ldv_56134;
  case 3: ;
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
    ldv_work_2_3 = 4;
    rtw_cmd_work(ldv_work_struct_2_0);
    ldv_work_2_3 = 1;
  } else {

  }
  goto ldv_56134;
  default: 
  ldv_stop();
  }
  ldv_56134: ;
  return;
}
}
void work_init_2(void) 
{ 


  {
  ldv_work_2_0 = 0;
  ldv_work_2_1 = 0;
  ldv_work_2_2 = 0;
  ldv_work_2_3 = 0;
  return;
}
}
void call_and_disable_all_1(int state ) 
{ 


  {
  if (ldv_work_1_0 == state) {
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
  if (ldv_work_1_1 == state) {
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
  if (ldv_work_1_2 == state) {
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
  if (ldv_work_1_3 == state) {
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
  return;
}
}
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_2_0 == 0) {
    ldv_work_struct_2_0 = work;
    ldv_work_2_0 = state;
    return;
  } else {

  }
  if (ldv_work_2_1 == 0) {
    ldv_work_struct_2_1 = work;
    ldv_work_2_1 = state;
    return;
  } else {

  }
  if (ldv_work_2_2 == 0) {
    ldv_work_struct_2_2 = work;
    ldv_work_2_2 = state;
    return;
  } else {

  }
  if (ldv_work_2_3 == 0) {
    ldv_work_struct_2_3 = work;
    ldv_work_2_3 = state;
    return;
  } else {

  }
  return;
}
}
void disable_work_2(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
    ldv_work_2_0 = 1;
  } else {

  }
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
    ldv_work_2_1 = 1;
  } else {

  }
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
    ldv_work_2_2 = 1;
  } else {

  }
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
    ldv_work_2_3 = 1;
  } else {

  }
  return;
}
}
void invoke_work_1(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
    ldv_work_1_0 = 4;
    rtw_irq_work(ldv_work_struct_1_0);
    ldv_work_1_0 = 1;
  } else {

  }
  goto ldv_56158;
  case 1: ;
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
    ldv_work_1_1 = 4;
    rtw_irq_work(ldv_work_struct_1_0);
    ldv_work_1_1 = 1;
  } else {

  }
  goto ldv_56158;
  case 2: ;
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
    ldv_work_1_2 = 4;
    rtw_irq_work(ldv_work_struct_1_0);
    ldv_work_1_2 = 1;
  } else {

  }
  goto ldv_56158;
  case 3: ;
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
    ldv_work_1_3 = 4;
    rtw_irq_work(ldv_work_struct_1_0);
    ldv_work_1_3 = 1;
  } else {

  }
  goto ldv_56158;
  default: 
  ldv_stop();
  }
  ldv_56158: ;
  return;
}
}
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
    rtw_cmd_work(work);
    ldv_work_2_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
    rtw_cmd_work(work);
    ldv_work_2_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
    rtw_cmd_work(work);
    ldv_work_2_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
    rtw_cmd_work(work);
    ldv_work_2_3 = 1;
    return;
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_10(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_2(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_11(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_12(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_13(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_14(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_15(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_16(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_17(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
__inline static unsigned int __arch_hweight32(unsigned int w ) 
{ 
  unsigned int res ;

  {
  res = 0U;
  __asm__  ("661:\n\tcall __sw_hweight32\n662:\n.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\n663:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6641f - .\n .word ( 4*32+23)\n .byte 663b-661b\n .byte 6651f-6641f\n .byte 663b-662b\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6641:\n\t.byte 0xf3,0x40,0x0f,0xb8,0xc7\n6651:\n\t.popsection": "=a" (res): "D" (w));
  return (res);
}
}
__inline static unsigned int __arch_hweight8(unsigned int w ) 
{ 
  unsigned int tmp ;

  {
  tmp = __arch_hweight32(w & 255U);
  return (tmp);
}
}
bool ldv_queue_work_on_35(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_36(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_39(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_38(struct workqueue_struct *ldv_func_arg1 ) ;
extern void __const_udelay(unsigned long  ) ;
u16 efuse_GetMaxSize23a(struct rtw_adapter *padapter ) ;
int rtw_efuse_access23a(struct rtw_adapter *padapter , u8 bWrite , u16 start_addr ,
                        u16 cnts , u8 *data ) ;
int rtw_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts , u8 *data ) ;
int rtw_BT_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts ,
                             u8 *data ) ;
u16 Efuse_GetCurrentSize23a(struct rtw_adapter *pAdapter , u8 efuseType ) ;
u8 Efuse_CalculateWordCnts23a(u8 word_en ) ;
void ReadEFuseByte23a(struct rtw_adapter *Adapter , u16 _offset , u8 *pbuf ) ;
void EFUSE_GetEfuseDefinition23a(struct rtw_adapter *pAdapter , u8 efuseType , u8 type ,
                                 void *pOut ) ;
int efuse_OneByteRead23a(struct rtw_adapter *pAdapter , u16 addr , u8 *data ) ;
int efuse_OneByteWrite23a(struct rtw_adapter *pAdapter , u16 addr , u8 data ) ;
void efuse_WordEnableDataRead23a(u8 word_en , u8 *sourdata , u8 *targetdata ) ;
u8 EFUSE_Read1Byte23a(struct rtw_adapter *Adapter , u16 Address ) ;
void EFUSE_ShadowMapUpdate23a(struct rtw_adapter *pAdapter , u8 efuseType ) ;
void EFUSE_ShadowRead23a(struct rtw_adapter *pAdapter , u8 Type , u16 Offset , u32 *Value ) ;
void rtl8723a_readefuse(struct rtw_adapter *padapter , u8 efuseType , u16 _offset ,
                        u16 _size_byte , u8 *pbuf ) ;
u16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter ) ;
u16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter ) ;
u8 rtl8723au_read8(struct rtw_adapter *padapter , u16 addr ) ;
u16 rtl8723au_read16(struct rtw_adapter *padapter , u16 addr ) ;
u32 rtl8723au_read32(struct rtw_adapter *padapter , u16 addr ) ;
int rtl8723au_write8(struct rtw_adapter *padapter , u16 addr , u8 val ) ;
int rtl8723au_write16(struct rtw_adapter *padapter , u16 addr , u16 val ) ;
static void Efuse_PowerSwitch(struct rtw_adapter *padapter , u8 bWrite , u8 PwrState ) 
{ 
  u8 tempval ;
  u16 tmpV16 ;

  {
  if ((unsigned int )PwrState == 1U) {
    rtl8723au_write8(padapter, 207, 105);
    tmpV16 = rtl8723au_read16(padapter, 0);
    if ((int )((short )tmpV16) >= 0) {
      tmpV16 = (u16 )((unsigned int )tmpV16 | 32768U);
      rtl8723au_write16(padapter, 0, (int )tmpV16);
    } else {

    }
    tmpV16 = rtl8723au_read16(padapter, 2);
    if (((unsigned long )tmpV16 & 4096UL) == 0UL) {
      tmpV16 = (u16 )((unsigned int )tmpV16 | 4096U);
      rtl8723au_write16(padapter, 2, (int )tmpV16);
    } else {

    }
    tmpV16 = rtl8723au_read16(padapter, 8);
    if (((unsigned long )tmpV16 & 32UL) == 0UL || ((unsigned long )tmpV16 & 2UL) == 0UL) {
      tmpV16 = (u16 )((unsigned int )tmpV16 | 34U);
      rtl8723au_write16(padapter, 8, (int )tmpV16);
    } else {

    }
    if ((unsigned int )bWrite == 1U) {
      tempval = rtl8723au_read8(padapter, 55);
      tempval = (unsigned int )tempval & 15U;
      tempval = (u8 )((unsigned int )tempval | 48U);
      rtl8723au_write8(padapter, 55, (int )((unsigned int )tempval | 128U));
    } else {

    }
  } else {
    rtl8723au_write8(padapter, 207, 0);
    if ((unsigned int )bWrite == 1U) {
      tempval = rtl8723au_read8(padapter, 55);
      rtl8723au_write8(padapter, 55, (int )tempval & 127);
    } else {

    }
  }
  return;
}
}
u16 Efuse_GetCurrentSize23a(struct rtw_adapter *pAdapter , u8 efuseType ) 
{ 
  u16 ret ;

  {
  ret = 0U;
  if ((unsigned int )efuseType == 0U) {
    ret = rtl8723a_EfuseGetCurrentSize_WiFi(pAdapter);
  } else {
    ret = rtl8723a_EfuseGetCurrentSize_BT(pAdapter);
  }
  return (ret);
}
}
u8 Efuse_CalculateWordCnts23a(u8 word_en ) 
{ 
  unsigned int tmp ;

  {
  tmp = __arch_hweight8((unsigned int )(~ ((int )word_en)) & 15U);
  return ((u8 )tmp);
}
}
void ReadEFuseByte23a(struct rtw_adapter *Adapter , u16 _offset , u8 *pbuf ) 
{ 
  u32 value32 ;
  u8 readbyte ;
  u16 retry ;

  {
  rtl8723au_write8(Adapter, 49, (int )((u8 )_offset));
  readbyte = rtl8723au_read8(Adapter, 50);
  rtl8723au_write8(Adapter, 50, (int )((u8 )(((int )((signed char )((int )_offset >> 8)) & 3) | ((int )((signed char )readbyte) & -4))));
  readbyte = rtl8723au_read8(Adapter, 51);
  rtl8723au_write8(Adapter, 51, (int )readbyte & 127);
  retry = 0U;
  value32 = rtl8723au_read32(Adapter, 48);
  goto ldv_55768;
  ldv_55767: 
  value32 = rtl8723au_read32(Adapter, 48);
  retry = (u16 )((int )retry + 1);
  ldv_55768: ;
  if ((int )value32 >= 0 && (unsigned int )retry <= 9999U) {
    goto ldv_55767;
  } else {

  }
  __const_udelay(214750UL);
  value32 = rtl8723au_read32(Adapter, 48);
  *pbuf = (unsigned char )value32;
  return;
}
}
void EFUSE_GetEfuseDefinition23a(struct rtw_adapter *pAdapter , u8 efuseType , u8 type ,
                                 void *pOut ) 
{ 
  u8 *pu1Tmp ;
  u16 *pu2Tmp ;
  u8 *pMax_section ;

  {
  switch ((int )type) {
  case 0: 
  pMax_section = (u8 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pMax_section = 32U;
  } else {
    *pMax_section = 128U;
  }
  goto ldv_55780;
  case 1: 
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 512U;
  } else {
    *pu2Tmp = 1536U;
  }
  goto ldv_55780;
  case 2: 
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 497U;
  } else {
    *pu2Tmp = 496U;
  }
  goto ldv_55780;
  case 3: 
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 497U;
  } else {
    *pu2Tmp = 1488U;
  }
  goto ldv_55780;
  case 4: 
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 256U;
  } else {
    *pu2Tmp = 1024U;
  }
  goto ldv_55780;
  case 5: 
  pu1Tmp = (u8 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu1Tmp = 15U;
  } else {
    *pu1Tmp = 16U;
  }
  goto ldv_55780;
  case 6: 
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 512U;
  } else {
    *pu2Tmp = 512U;
  }
  goto ldv_55780;
  default: 
  pu1Tmp = (u8 *)pOut;
  *pu1Tmp = 0U;
  goto ldv_55780;
  }
  ldv_55780: ;
  return;
}
}
u8 EFUSE_Read1Byte23a(struct rtw_adapter *Adapter , u16 Address ) 
{ 
  u8 data ;
  u8 Bytetemp ;
  u8 temp ;
  u32 k ;
  u16 contentLen ;

  {
  Bytetemp = 0U;
  temp = 0U;
  k = 0U;
  contentLen = 0U;
  EFUSE_GetEfuseDefinition23a(Adapter, 0, 1, (void *)(& contentLen));
  if ((int )Address < (int )contentLen) {
    temp = (u8 )Address;
    rtl8723au_write8(Adapter, 49, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 50);
    temp = (u8 )(((int )((signed char )((int )Address >> 8)) & 3) | ((int )((signed char )Bytetemp) & -4));
    rtl8723au_write8(Adapter, 50, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 51);
    temp = (unsigned int )Bytetemp & 127U;
    rtl8723au_write8(Adapter, 51, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 51);
    goto ldv_55799;
    ldv_55798: 
    Bytetemp = rtl8723au_read8(Adapter, 51);
    k = k + 1U;
    if (k == 1000U) {
      k = 0U;
      goto ldv_55797;
    } else {

    }
    ldv_55799: ;
    if ((int )((signed char )Bytetemp) >= 0) {
      goto ldv_55798;
    } else {

    }
    ldv_55797: 
    data = rtl8723au_read8(Adapter, 48);
    return (data);
  } else {
    return (255U);
  }
}
}
void EFUSE_Write1Byte(struct rtw_adapter *Adapter , u16 Address , u8 Value ) ;
void EFUSE_Write1Byte(struct rtw_adapter *Adapter , u16 Address , u8 Value ) 
{ 
  u8 Bytetemp ;
  u8 temp ;
  u32 k ;
  u16 contentLen ;

  {
  Bytetemp = 0U;
  temp = 0U;
  k = 0U;
  contentLen = 0U;
  EFUSE_GetEfuseDefinition23a(Adapter, 0, 1, (void *)(& contentLen));
  if ((int )Address < (int )contentLen) {
    rtl8723au_write8(Adapter, 48, (int )Value);
    temp = (u8 )Address;
    rtl8723au_write8(Adapter, 49, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 50);
    temp = (u8 )(((int )((signed char )((int )Address >> 8)) & 3) | ((int )((signed char )Bytetemp) & -4));
    rtl8723au_write8(Adapter, 50, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 51);
    temp = (u8 )((unsigned int )Bytetemp | 128U);
    rtl8723au_write8(Adapter, 51, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 51);
    goto ldv_55815;
    ldv_55814: 
    Bytetemp = rtl8723au_read8(Adapter, 51);
    k = k + 1U;
    if (k == 100U) {
      k = 0U;
      goto ldv_55813;
    } else {

    }
    ldv_55815: ;
    if ((int )((signed char )Bytetemp) < 0) {
      goto ldv_55814;
    } else {

    }
    ldv_55813: ;
  } else {

  }
  return;
}
}
int efuse_OneByteRead23a(struct rtw_adapter *pAdapter , u16 addr , u8 *data ) 
{ 
  u8 tmpidx ;
  int bResult ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  tmpidx = 0U;
  rtl8723au_write8(pAdapter, 49, (int )((unsigned char )addr));
  tmp = rtl8723au_read8(pAdapter, 50);
  rtl8723au_write8(pAdapter, 50, (int )((u8 )(((int )((signed char )((int )addr >> 8)) & 3) | ((int )((signed char )tmp) & -4))));
  rtl8723au_write8(pAdapter, 51, 114);
  goto ldv_55824;
  ldv_55823: 
  tmpidx = (u8 )((int )tmpidx + 1);
  ldv_55824: 
  tmp___0 = rtl8723au_read8(pAdapter, 51);
  if ((int )((signed char )tmp___0) >= 0 && (unsigned int )tmpidx <= 99U) {
    goto ldv_55823;
  } else {

  }

  if ((unsigned int )tmpidx <= 99U) {
    *data = rtl8723au_read8(pAdapter, 48);
    bResult = 1;
  } else {
    *data = 255U;
    bResult = 0;
  }
  return (bResult);
}
}
int efuse_OneByteWrite23a(struct rtw_adapter *pAdapter , u16 addr , u8 data ) 
{ 
  u8 tmpidx ;
  int bResult ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  tmpidx = 0U;
  rtl8723au_write8(pAdapter, 49, (int )((unsigned char )addr));
  tmp = rtl8723au_read8(pAdapter, 50);
  rtl8723au_write8(pAdapter, 50, (int )((u8 )(((int )((signed char )tmp) & -4) | ((int )((signed char )((int )addr >> 8)) & 3))));
  rtl8723au_write8(pAdapter, 48, (int )data);
  rtl8723au_write8(pAdapter, 51, 242);
  goto ldv_55834;
  ldv_55833: 
  tmpidx = (u8 )((int )tmpidx + 1);
  ldv_55834: 
  tmp___0 = rtl8723au_read8(pAdapter, 51);
  if ((int )((signed char )tmp___0) < 0 && (unsigned int )tmpidx <= 99U) {
    goto ldv_55833;
  } else {

  }

  if ((unsigned int )tmpidx <= 99U) {
    bResult = 1;
  } else {
    bResult = 0;
  }
  return (bResult);
}
}
void efuse_WordEnableDataRead23a(u8 word_en , u8 *sourdata , u8 *targetdata ) 
{ 


  {
  if (((unsigned long )word_en & 1UL) == 0UL) {
    *targetdata = *sourdata;
    *(targetdata + 1UL) = *(sourdata + 1UL);
  } else {

  }
  if (((unsigned long )word_en & 2UL) == 0UL) {
    *(targetdata + 2UL) = *(sourdata + 2UL);
    *(targetdata + 3UL) = *(sourdata + 3UL);
  } else {

  }
  if (((unsigned long )word_en & 4UL) == 0UL) {
    *(targetdata + 4UL) = *(sourdata + 4UL);
    *(targetdata + 5UL) = *(sourdata + 5UL);
  } else {

  }
  if (((unsigned long )word_en & 8UL) == 0UL) {
    *(targetdata + 6UL) = *(sourdata + 6UL);
    *(targetdata + 7UL) = *(sourdata + 7UL);
  } else {

  }
  return;
}
}
static int efuse_read8(struct rtw_adapter *padapter , u16 address , u8 *value ) 
{ 
  int tmp ;

  {
  tmp = efuse_OneByteRead23a(padapter, (int )address, value);
  return (tmp);
}
}
static int efuse_write8(struct rtw_adapter *padapter , u16 address , u8 *value ) 
{ 
  int tmp ;

  {
  tmp = efuse_OneByteWrite23a(padapter, (int )address, (int )*value);
  return (tmp);
}
}
int rtw_efuse_access23a(struct rtw_adapter *padapter , u8 bWrite , u16 start_addr ,
                        u16 cnts , u8 *data ) 
{ 
  int i ;
  u16 real_content_len ;
  u16 max_available_size ;
  int res ;
  int (*rw8)(struct rtw_adapter * , u16  , u8 * ) ;
  u8 *tmp ;
  u16 tmp___0 ;

  {
  i = 0;
  real_content_len = 0U;
  max_available_size = 0U;
  res = 0;
  EFUSE_GetEfuseDefinition23a(padapter, 0, 1, (void *)(& real_content_len));
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& max_available_size));
  if ((int )start_addr > (int )real_content_len) {
    return (0);
  } else {

  }
  if ((unsigned int )bWrite == 1U) {
    if ((int )start_addr + (int )cnts > (int )max_available_size) {
      return (0);
    } else {

    }
    rw8 = & efuse_write8;
  } else {
    rw8 = & efuse_read8;
  }
  Efuse_PowerSwitch(padapter, (int )bWrite, 1);
  i = 0;
  goto ldv_55868;
  ldv_55867: ;
  if ((int )start_addr >= (int )real_content_len) {
    res = 0;
    goto ldv_55866;
  } else {

  }
  tmp = data;
  data = data + 1;
  tmp___0 = start_addr;
  start_addr = (u16 )((int )start_addr + 1);
  res = (*rw8)(padapter, (int )tmp___0, tmp);
  if (res == 0) {
    goto ldv_55866;
  } else {

  }
  i = i + 1;
  ldv_55868: ;
  if ((int )cnts > i) {
    goto ldv_55867;
  } else {

  }
  ldv_55866: 
  Efuse_PowerSwitch(padapter, (int )bWrite, 0);
  return (res);
}
}
u16 efuse_GetMaxSize23a(struct rtw_adapter *padapter ) 
{ 
  u16 max_size ;

  {
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& max_size));
  return (max_size);
}
}
int rtw_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts , u8 *data ) 
{ 
  u16 mapLen ;

  {
  mapLen = 0U;
  EFUSE_GetEfuseDefinition23a(padapter, 0, 4, (void *)(& mapLen));
  if ((int )addr + (int )cnts > (int )mapLen) {
    return (0);
  } else {

  }
  Efuse_PowerSwitch(padapter, 0, 1);
  rtl8723a_readefuse(padapter, 0, (int )addr, (int )cnts, data);
  Efuse_PowerSwitch(padapter, 0, 0);
  return (1);
}
}
int rtw_BT_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts ,
                             u8 *data ) 
{ 
  u16 mapLen ;

  {
  mapLen = 0U;
  EFUSE_GetEfuseDefinition23a(padapter, 1, 4, (void *)(& mapLen));
  if ((int )addr + (int )cnts > (int )mapLen) {
    return (0);
  } else {

  }
  Efuse_PowerSwitch(padapter, 0, 1);
  rtl8723a_readefuse(padapter, 1, (int )addr, (int )cnts, data);
  Efuse_PowerSwitch(padapter, 0, 0);
  return (1);
}
}
void Efuse_ReadAllMap(struct rtw_adapter *pAdapter , u8 efuseType , u8 *Efuse ) ;
void Efuse_ReadAllMap(struct rtw_adapter *pAdapter , u8 efuseType , u8 *Efuse ) 
{ 
  u16 mapLen ;

  {
  mapLen = 0U;
  Efuse_PowerSwitch(pAdapter, 0, 1);
  EFUSE_GetEfuseDefinition23a(pAdapter, (int )efuseType, 4, (void *)(& mapLen));
  rtl8723a_readefuse(pAdapter, (int )efuseType, 0, (int )mapLen, Efuse);
  Efuse_PowerSwitch(pAdapter, 0, 0);
  return;
}
}
static void efuse_ShadowRead1Byte(struct rtw_adapter *pAdapter , u16 Offset , u8 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
  pEEPROM = & pAdapter->eeprompriv;
  *Value = pEEPROM->efuse_eeprom_data[(int )Offset];
  return;
}
}
static void efuse_ShadowRead2Byte(struct rtw_adapter *pAdapter , u16 Offset , u16 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
  pEEPROM = & pAdapter->eeprompriv;
  *Value = (u16 )pEEPROM->efuse_eeprom_data[(int )Offset];
  *Value = (u16 )((int )((short )*Value) | (int )((short )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 1] << 8)));
  return;
}
}
static void efuse_ShadowRead4Byte(struct rtw_adapter *pAdapter , u16 Offset , u32 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
  pEEPROM = & pAdapter->eeprompriv;
  *Value = (u32 )pEEPROM->efuse_eeprom_data[(int )Offset];
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 1] << 8);
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 2] << 16);
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 3] << 24);
  return;
}
}
void EFUSE_ShadowMapUpdate23a(struct rtw_adapter *pAdapter , u8 efuseType ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u16 mapLen ;

  {
  pEEPROM = & pAdapter->eeprompriv;
  mapLen = 0U;
  EFUSE_GetEfuseDefinition23a(pAdapter, (int )efuseType, 4, (void *)(& mapLen));
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 1U) {
    memset((void *)(& pEEPROM->efuse_eeprom_data), 255, (size_t )mapLen);
  } else {
    Efuse_ReadAllMap(pAdapter, (int )efuseType, (u8 *)(& pEEPROM->efuse_eeprom_data));
  }
  return;
}
}
void EFUSE_ShadowRead23a(struct rtw_adapter *pAdapter , u8 Type , u16 Offset , u32 *Value ) 
{ 


  {
  if ((unsigned int )Type == 1U) {
    efuse_ShadowRead1Byte(pAdapter, (int )Offset, (u8 *)Value);
  } else
  if ((unsigned int )Type == 2U) {
    efuse_ShadowRead2Byte(pAdapter, (int )Offset, (u16 *)Value);
  } else
  if ((unsigned int )Type == 4U) {
    efuse_ShadowRead4Byte(pAdapter, (int )Offset, Value);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_35(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_36(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_38(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_39(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
__inline static __u16 __swab16p(__u16 const   *p ) 
{ 
  __u16 tmp ;

  {
  tmp = __fswab16((int )*p);
  return (tmp);
}
}
__inline static __u16 __le16_to_cpup(__le16 const   *p ) 
{ 


  {
  return ((__u16 )*p);
}
}
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ 
  __u16 tmp ;

  {
  tmp = __swab16p(p);
  return (tmp);
}
}
extern int memcmp(void const   * , void const   * , size_t  ) ;
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_52(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static u16 get_unaligned_le16(void const   *p ) 
{ 
  __u16 tmp ;

  {
  tmp = __le16_to_cpup((__le16 const   *)p);
  return (tmp);
}
}
__inline static u16 get_unaligned_be16(void const   *p ) 
{ 
  __u16 tmp ;

  {
  tmp = __be16_to_cpup((__be16 const   *)p);
  return (tmp);
}
}
extern u8 const   *cfg80211_find_ie(u8  , u8 const   * , int  ) ;
extern u8 const   *cfg80211_find_vendor_ie(unsigned int  , u8  , u8 const   * , int  ) ;
u8 RTW_WPA_OUI23A_TYPE[4U] ;
u16 RTW_WPA_VERSION23A ;
u8 WPA_AUTH_KEY_MGMT_NONE23A[4U] ;
u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] ;
u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] ;
u8 WPA_CIPHER_SUITE_NONE23A[4U] ;
u8 WPA_CIPHER_SUITE_WEP4023A[4U] ;
u8 WPA_CIPHER_SUITE_TKIP23A[4U] ;
u8 WPA_CIPHER_SUITE_WRAP23A[4U] ;
u8 WPA_CIPHER_SUITE_CCMP23A[4U] ;
u8 WPA_CIPHER_SUITE_WEP10423A[4U] ;
u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] ;
u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] ;
u8 RSN_CIPHER_SUITE_NONE23A[4U] ;
u8 RSN_CIPHER_SUITE_WEP4023A[4U] ;
u8 RSN_CIPHER_SUITE_TKIP23A[4U] ;
u8 RSN_CIPHER_SUITE_WRAP23A[4U] ;
u8 RSN_CIPHER_SUITE_CCMP23A[4U] ;
u8 RSN_CIPHER_SUITE_WEP10423A[4U] ;
u8 *rtw_set_ie23a(u8 *pbuf , int index , uint len , u8 const   *source , uint *frlen ) ;
u8 *rtw_get_ie23a(u8 *pbuf , int index , int *len , int limit ) ;
u8 *rtw_get_ie23a_ex(u8 *in_ie , uint in_len , u8 eid , u8 *oui , u8 oui_len , u8 *ie ,
                     uint *ielen ) ;
int rtw_ies_remove_ie23a(u8 *ies , uint *ies_len , uint offset , u8 eid , u8 *oui ,
                         u8 oui_len ) ;
void rtw_set_supported_rate23a(u8 *SupportedRates , uint mode ) ;
int rtw_parse_wpa_ie23a(u8 const   *wpa_ie , int wpa_ie_len , int *group_cipher ,
                        int *pairwise_cipher , int *is_8021x ) ;
int rtw_parse_wpa2_ie23a(u8 const   *rsn_ie , int rsn_ie_len , int *group_cipher ,
                         int *pairwise_cipher , int *is_8021x ) ;
u8 const   *rtw_get_wps_attr23a(u8 const   *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                u8 *buf_attr , u32 *len_attr ) ;
u8 const   *rtw_get_wps_attr_content23a(u8 const   *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                        u8 *buf_content ) ;
uint rtw_get_rateset_len23a(u8 *rateset ) ;
int rtw_generate_ie23a(struct registry_priv *pregistrypriv ) ;
int rtw_get_bit_value_from_ieee_value23a(u8 val ) ;
int rtw_check_network_type23a(unsigned char *rate , int ratelen , int channel ) ;
void rtw_get_bcn_info23a(struct wlan_network *pnetwork ) ;
u16 rtw_mcs_rate23a(u8 rf_type , u8 bw_40MHz , u8 short_GI_20 , u8 short_GI_40 , struct ieee80211_mcs_info *mcs ) ;
u8 RTW_WPA_OUI23A_TYPE[4U]  = {      0U,      80U,      242U,      1U};
u16 RTW_WPA_VERSION23A  =    1U;
u8 WPA_AUTH_KEY_MGMT_NONE23A[4U]  = {      0U,      80U,      242U,      0U};
u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U]  = {      0U,      80U,      242U,      1U};
u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U]  = {      0U,      80U,      242U,      2U};
u8 WPA_CIPHER_SUITE_NONE23A[4U]  = {      0U,      80U,      242U,      0U};
u8 WPA_CIPHER_SUITE_WEP4023A[4U]  = {      0U,      80U,      242U,      1U};
u8 WPA_CIPHER_SUITE_TKIP23A[4U]  = {      0U,      80U,      242U,      2U};
u8 WPA_CIPHER_SUITE_WRAP23A[4U]  = {      0U,      80U,      242U,      3U};
u8 WPA_CIPHER_SUITE_CCMP23A[4U]  = {      0U,      80U,      242U,      4U};
u8 WPA_CIPHER_SUITE_WEP10423A[4U]  = {      0U,      80U,      242U,      5U};
u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U]  = {      0U,      15U,      172U,      1U};
u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U]  = {      0U,      15U,      172U,      2U};
u8 RSN_CIPHER_SUITE_NONE23A[4U]  = {      0U,      15U,      172U,      0U};
u8 RSN_CIPHER_SUITE_WEP4023A[4U]  = {      0U,      15U,      172U,      1U};
u8 RSN_CIPHER_SUITE_TKIP23A[4U]  = {      0U,      15U,      172U,      2U};
u8 RSN_CIPHER_SUITE_WRAP23A[4U]  = {      0U,      15U,      172U,      3U};
u8 RSN_CIPHER_SUITE_CCMP23A[4U]  = {      0U,      15U,      172U,      4U};
u8 RSN_CIPHER_SUITE_WEP10423A[4U]  = {      0U,      15U,      172U,      5U};
static u8 WIFI_CCKRATES[4U]  = {      130U,      132U,      139U,      150U};
static u8 WIFI_OFDMRATES[8U]  = 
  {      12U,      18U,      24U,      36U, 
        48U,      72U,      96U,      108U};
int rtw_get_bit_value_from_ieee_value23a(u8 val ) 
{ 
  unsigned char dot11_rate_table[13U] ;
  int i ;

  {
  dot11_rate_table[0] = 2U;
  dot11_rate_table[1] = 4U;
  dot11_rate_table[2] = 11U;
  dot11_rate_table[3] = 22U;
  dot11_rate_table[4] = 12U;
  dot11_rate_table[5] = 18U;
  dot11_rate_table[6] = 24U;
  dot11_rate_table[7] = 36U;
  dot11_rate_table[8] = 48U;
  dot11_rate_table[9] = 72U;
  dot11_rate_table[10] = 96U;
  dot11_rate_table[11] = 108U;
  dot11_rate_table[12] = 0U;
  i = 0;
  goto ldv_53201;
  ldv_53200: ;
  if ((int )dot11_rate_table[i] == (int )val) {
    return ((int )(1UL << i));
  } else {

  }
  i = i + 1;
  ldv_53201: ;
  if ((unsigned int )dot11_rate_table[i] != 0U) {
    goto ldv_53200;
  } else {

  }

  return (0);
}
}
static bool rtw_is_cckrates_included(u8 *rate ) 
{ 
  u32 i ;

  {
  i = 0U;
  goto ldv_53208;
  ldv_53207: ;
  if (((((int )*(rate + (unsigned long )i) & 127) == 2 || ((int )*(rate + (unsigned long )i) & 127) == 4) || ((int )*(rate + (unsigned long )i) & 127) == 11) || ((int )*(rate + (unsigned long )i) & 127) == 22) {
    return (1);
  } else {

  }
  i = i + 1U;
  ldv_53208: ;
  if ((unsigned int )*(rate + (unsigned long )i) != 0U) {
    goto ldv_53207;
  } else {

  }

  return (0);
}
}
static bool rtw_is_cckratesonly_included(u8 *rate ) 
{ 
  u32 i ;

  {
  i = 0U;
  goto ldv_53215;
  ldv_53214: ;
  if (((((int )*(rate + (unsigned long )i) & 127) != 2 && ((int )*(rate + (unsigned long )i) & 127) != 4) && ((int )*(rate + (unsigned long )i) & 127) != 11) && ((int )*(rate + (unsigned long )i) & 127) != 22) {
    return (0);
  } else {

  }
  i = i + 1U;
  ldv_53215: ;
  if ((unsigned int )*(rate + (unsigned long )i) != 0U) {
    goto ldv_53214;
  } else {

  }

  return (1);
}
}
int rtw_check_network_type23a(unsigned char *rate , int ratelen , int channel ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  if (channel > 14) {
    tmp = rtw_is_cckrates_included(rate);
    if ((int )tmp) {
      return (0);
    } else {
      return (4);
    }
  } else {
    tmp___1 = rtw_is_cckratesonly_included(rate);
    if ((int )tmp___1) {
      return (1);
    } else {
      tmp___0 = rtw_is_cckrates_included(rate);
      if ((int )tmp___0) {
        return (3);
      } else {
        return (2);
      }
    }
  }
}
}
u8 *rtw_set_ie23a(u8 *pbuf , int index , uint len , u8 const   *source , uint *frlen ) 
{ 


  {
  *pbuf = (unsigned char )index;
  *(pbuf + 1UL) = (unsigned char )len;
  if (len != 0U) {
    memcpy((void *)pbuf + 2U, (void const   *)source, (size_t )len);
  } else {

  }
  *frlen = (*frlen + len) + 2U;
  return (pbuf + ((unsigned long )len + 2UL));
}
}
u8 *rtw_get_ie23a(u8 *pbuf , int index , int *len , int limit ) 
{ 
  int tmp ;
  int i ;
  u8 *p ;

  {
  if (limit <= 0) {
    return ((u8 *)0U);
  } else {

  }
  p = pbuf;
  i = 0;
  *len = 0;
  ldv_53255: ;
  if ((int )*p == index) {
    *len = (int )*(p + 1UL);
    return (p);
  } else {
    tmp = (int )*(p + 1UL);
    p = p + ((unsigned long )tmp + 2UL);
    i = (tmp + 2) + i;
  }
  if (i >= limit) {
    goto ldv_53254;
  } else {

  }
  goto ldv_53255;
  ldv_53254: ;
  return ((u8 *)0U);
}
}
u8 *rtw_get_ie23a_ex(u8 *in_ie , uint in_len , u8 eid , u8 *oui , u8 oui_len , u8 *ie ,
                     uint *ielen ) 
{ 
  uint cnt ;
  u8 *target_ie ;
  int tmp ;

  {
  target_ie = (u8 *)0U;
  if ((unsigned long )ielen != (unsigned long )((uint *)0U)) {
    *ielen = 0U;
  } else {

  }
  if ((unsigned long )in_ie == (unsigned long )((u8 *)0U) || in_len == 0U) {
    return (target_ie);
  } else {

  }
  cnt = 0U;
  goto ldv_53269;
  ldv_53268: ;
  if ((int )*(in_ie + (unsigned long )cnt) == (int )eid) {
    if ((unsigned long )oui == (unsigned long )((u8 *)0U)) {
      goto _L;
    } else {
      tmp = memcmp((void const   *)in_ie + (unsigned long )(cnt + 2U), (void const   *)oui,
                   (size_t )oui_len);
      if (tmp == 0) {
        _L: /* CIL Label */ 
        target_ie = in_ie + (unsigned long )cnt;
        if ((unsigned long )ie != (unsigned long )((u8 *)0U)) {
          memcpy((void *)ie, (void const   *)in_ie + (unsigned long )cnt, (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2));
        } else {

        }
        if ((unsigned long )ielen != (unsigned long )((uint *)0U)) {
          *ielen = (uint )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
        } else {

        }
        goto ldv_53267;
      } else {
        cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
      }
    }
  } else {
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  }
  ldv_53269: ;
  if (cnt < in_len) {
    goto ldv_53268;
  } else {

  }
  ldv_53267: ;
  return (target_ie);
}
}
int rtw_ies_remove_ie23a(u8 *ies , uint *ies_len , uint offset , u8 eid , u8 *oui ,
                         u8 oui_len ) 
{ 
  int ret ;
  u8 *target_ie ;
  u32 target_ielen ;
  u8 *start ;
  uint search_len ;
  u8 buf[768U] ;
  unsigned int tmp ;
  u8 *remain_ies ;
  uint remain_len ;

  {
  ret = 0;
  if (((unsigned long )ies == (unsigned long )((u8 *)0U) || (unsigned long )ies_len == (unsigned long )((uint *)0U)) || *ies_len <= offset) {
    goto exit;
  } else {

  }
  start = ies + (unsigned long )offset;
  search_len = *ies_len - offset;
  ldv_53288: 
  target_ie = rtw_get_ie23a_ex(start, search_len, (int )eid, oui, (int )oui_len, (u8 *)0U,
                               & target_ielen);
  if ((unsigned long )target_ie != (unsigned long )((u8 *)0U) && target_ielen != 0U) {
    buf[0] = 0U;
    tmp = 1U;
    while (1) {
      if (tmp >= 768U) {
        break;
      } else {

      }
      buf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    remain_ies = target_ie + (unsigned long )target_ielen;
    remain_len = ((uint )((long )start) - (uint )((long )remain_ies)) + search_len;
    memcpy((void *)(& buf), (void const   *)remain_ies, (size_t )remain_len);
    memcpy((void *)target_ie, (void const   *)(& buf), (size_t )remain_len);
    *ies_len = *ies_len - target_ielen;
    ret = 1;
    start = target_ie;
    search_len = remain_len;
  } else {
    goto ldv_53287;
  }
  goto ldv_53288;
  ldv_53287: ;
  exit: ;
  return (ret);
}
}
void rtw_set_supported_rate23a(u8 *SupportedRates , uint mode ) 
{ 


  {
  memset((void *)SupportedRates, 0, 16UL);
  switch (mode) {
  case 1U: 
  memcpy((void *)SupportedRates, (void const   *)(& WIFI_CCKRATES), 4UL);
  goto ldv_53294;
  case 2U: ;
  case 4U: ;
  case 16U: ;
  case 20U: 
  memcpy((void *)SupportedRates, (void const   *)(& WIFI_OFDMRATES), 8UL);
  goto ldv_53294;
  case 3U: ;
  case 10U: ;
  case 8U: ;
  case 11U: 
  memcpy((void *)SupportedRates, (void const   *)(& WIFI_CCKRATES), 4UL);
  memcpy((void *)SupportedRates + 4U, (void const   *)(& WIFI_OFDMRATES), 8UL);
  goto ldv_53294;
  }
  ldv_53294: ;
  return;
}
}
uint rtw_get_rateset_len23a(u8 *rateset ) 
{ 
  uint i ;

  {
  i = 0U;
  ldv_53308: ;
  if ((unsigned int )*(rateset + (unsigned long )i) == 0U) {
    goto ldv_53307;
  } else {

  }
  if (i > 12U) {
    goto ldv_53307;
  } else {

  }
  i = i + 1U;
  goto ldv_53308;
  ldv_53307: ;
  return (i);
}
}
int rtw_generate_ie23a(struct registry_priv *pregistrypriv ) 
{ 
  u8 wireless_mode ;
  int sz ;
  int rateLen ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *ie ;
  u16 cap ;
  uint tmp ;

  {
  sz = 0;
  pdev_network = & pregistrypriv->dev_network;
  ie = (u8 *)(& pdev_network->IEs);
  pdev_network->tsf = 0ULL;
  cap = 2U;
  if ((unsigned int )pregistrypriv->preamble == 3U) {
    cap = (u16 )((unsigned int )cap | 32U);
  } else {

  }
  if (pdev_network->Privacy != 0U) {
    cap = (u16 )((unsigned int )cap | 16U);
  } else {

  }
  pdev_network->capability = cap;
  ie = rtw_set_ie23a(ie, 0, (uint )pdev_network->Ssid.ssid_len, (u8 const   *)(& pdev_network->Ssid.ssid),
                     (uint *)(& sz));
  if ((unsigned int )pregistrypriv->wireless_mode == 31U) {
    if (pdev_network->DSConfig > 14U) {
      wireless_mode = 20U;
    } else {
      wireless_mode = 11U;
    }
  } else {
    wireless_mode = pregistrypriv->wireless_mode;
  }
  rtw_set_supported_rate23a((u8 *)(& pdev_network->SupportedRates), (uint )wireless_mode);
  tmp = rtw_get_rateset_len23a((u8 *)(& pdev_network->SupportedRates));
  rateLen = (int )tmp;
  if (rateLen > 8) {
    ie = rtw_set_ie23a(ie, 1, 8U, (u8 const   *)(& pdev_network->SupportedRates),
                       (uint *)(& sz));
  } else {
    ie = rtw_set_ie23a(ie, 1, (uint )rateLen, (u8 const   *)(& pdev_network->SupportedRates),
                       (uint *)(& sz));
  }
  ie = rtw_set_ie23a(ie, 3, 1U, (u8 const   *)(& pdev_network->DSConfig), (uint *)(& sz));
  ie = rtw_set_ie23a(ie, 6, 2U, (u8 const   *)(& pdev_network->ATIMWindow), (uint *)(& sz));
  if (rateLen > 8) {
    ie = rtw_set_ie23a(ie, 50, (uint )(rateLen + -8), (u8 const   *)(& pdev_network->SupportedRates) + 8U,
                       (uint *)(& sz));
  } else {

  }
  return (sz);
}
}
static int rtw_get_wpa_cipher_suite(u8 const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_NONE23A), 4UL);
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_WEP4023A),
                   4UL);
  if (tmp___0 == 0) {
    return (2);
  } else {

  }
  tmp___1 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_TKIP23A),
                   4UL);
  if (tmp___1 == 0) {
    return (8);
  } else {

  }
  tmp___2 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                   4UL);
  if (tmp___2 == 0) {
    return (16);
  } else {

  }
  tmp___3 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_WEP10423A),
                   4UL);
  if (tmp___3 == 0) {
    return (4);
  } else {

  }
  return (0);
}
}
static int rtw_get_wpa2_cipher_suite(u8 const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_NONE23A), 4UL);
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_WEP4023A),
                   4UL);
  if (tmp___0 == 0) {
    return (2);
  } else {

  }
  tmp___1 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_TKIP23A),
                   4UL);
  if (tmp___1 == 0) {
    return (8);
  } else {

  }
  tmp___2 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                   4UL);
  if (tmp___2 == 0) {
    return (16);
  } else {

  }
  tmp___3 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_WEP10423A),
                   4UL);
  if (tmp___3 == 0) {
    return (4);
  } else {

  }
  return (0);
}
}
int rtw_parse_wpa_ie23a(u8 const   *wpa_ie , int wpa_ie_len , int *group_cipher ,
                        int *pairwise_cipher , int *is_8021x ) 
{ 
  int i ;
  int ret ;
  int left ;
  int count ;
  u8 const   *pos ;
  u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  ret = 1;
  if (wpa_ie_len <= 0) {
    return (0);
  } else {

  }
  if ((unsigned int )((unsigned char )*(wpa_ie + 1UL)) != (unsigned int )((unsigned char )wpa_ie_len) - 2U) {
    return (0);
  } else {

  }
  pos = wpa_ie;
  pos = pos + 8UL;
  left = wpa_ie_len + -8;
  if (left > 3) {
    *group_cipher = rtw_get_wpa_cipher_suite(pos);
    pos = pos + 4UL;
    left = left + -4;
  } else
  if (left > 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "%s: ie length mismatch, %u too much\n", "rtw_parse_wpa_ie23a",
               left);
    } else {

    }
    return (0);
  } else {

  }
  if (left > 1) {
    tmp = get_unaligned_le16((void const   *)pos);
    count = (int )tmp;
    pos = pos + 2UL;
    left = left + -2;
    if (count == 0 || count * 4 > left) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16, 4, "%s: ie count botch (pairwise), count %u left %u\n", "rtw_parse_wpa_ie23a",
                 count, left);
      } else {

      }
      return (0);
    } else {

    }
    i = 0;
    goto ldv_53338;
    ldv_53337: 
    tmp___0 = rtw_get_wpa_cipher_suite(pos);
    *pairwise_cipher = *pairwise_cipher | tmp___0;
    pos = pos + 4UL;
    left = left + -4;
    i = i + 1;
    ldv_53338: ;
    if (i < count) {
      goto ldv_53337;
    } else {

    }

  } else
  if (left == 1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "%s: ie too short (for key mgmt)\n", "rtw_parse_wpa_ie23a");
    } else {

    }
    return (0);
  } else {

  }
  if ((unsigned long )is_8021x != (unsigned long )((int *)0)) {
    if (left > 5) {
      pos = pos + 2UL;
      tmp___1 = memcmp((void const   *)pos, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                       4UL);
      if (tmp___1 == 0) {
        if (GlobalDebugLevel23A > 6U) {
          rt_trace(16, 7, "%s : there has 802.1x auth\n", "rtw_parse_wpa_ie23a");
        } else {

        }
        *is_8021x = 1;
      } else {

      }
    } else {

    }
  } else {

  }
  return (ret);
}
}
int rtw_parse_wpa2_ie23a(u8 const   *rsn_ie , int rsn_ie_len , int *group_cipher ,
                         int *pairwise_cipher , int *is_8021x ) 
{ 
  int i ;
  int ret ;
  int left ;
  int count ;
  u8 const   *pos ;
  u8 SUITE_1X[4U] ;
  u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  ret = 1;
  SUITE_1X[0] = 0U;
  SUITE_1X[1] = 15U;
  SUITE_1X[2] = 172U;
  SUITE_1X[3] = 1U;
  if (rsn_ie_len <= 0) {
    return (0);
  } else {

  }
  if ((unsigned int )((unsigned char )*rsn_ie) != 48U || (unsigned int )((unsigned char )*(rsn_ie + 1UL)) != (unsigned int )((unsigned char )rsn_ie_len) - 2U) {
    return (0);
  } else {

  }
  pos = rsn_ie;
  pos = pos + 4UL;
  left = rsn_ie_len + -4;
  if (left > 3) {
    *group_cipher = rtw_get_wpa2_cipher_suite(pos);
    pos = pos + 4UL;
    left = left + -4;
  } else
  if (left > 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "%s: ie length mismatch, %u too much\n", "rtw_parse_wpa2_ie23a",
               left);
    } else {

    }
    return (0);
  } else {

  }
  if (left > 1) {
    tmp = get_unaligned_le16((void const   *)pos);
    count = (int )tmp;
    pos = pos + 2UL;
    left = left + -2;
    if (count == 0 || count * 4 > left) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16, 4, "%s: ie count botch (pairwise), count %u left %u\n", "rtw_parse_wpa2_ie23a",
                 count, left);
      } else {

      }
      return (0);
    } else {

    }
    i = 0;
    goto ldv_53355;
    ldv_53354: 
    tmp___0 = rtw_get_wpa2_cipher_suite(pos);
    *pairwise_cipher = *pairwise_cipher | tmp___0;
    pos = pos + 4UL;
    left = left + -4;
    i = i + 1;
    ldv_53355: ;
    if (i < count) {
      goto ldv_53354;
    } else {

    }

  } else
  if (left == 1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "%s: ie too short (for key mgmt)\n", "rtw_parse_wpa2_ie23a");
    } else {

    }
    return (0);
  } else {

  }
  if ((unsigned long )is_8021x != (unsigned long )((int *)0)) {
    if (left > 5) {
      pos = pos + 2UL;
      tmp___1 = memcmp((void const   *)pos, (void const   *)(& SUITE_1X), 4UL);
      if (tmp___1 == 0) {
        if (GlobalDebugLevel23A > 6U) {
          rt_trace(16, 7, "%s (): there has 802.1x auth\n", "rtw_parse_wpa2_ie23a");
        } else {

        }
        *is_8021x = 1;
      } else {

      }
    } else {

    }
  } else {

  }
  return (ret);
}
}
u8 const   *rtw_get_wps_attr23a(u8 const   *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                u8 *buf_attr , u32 *len_attr ) 
{ 
  u8 const   *attr_ptr ;
  u8 const   *target_attr_ptr ;
  u8 wps_oui[4U] ;
  int tmp ;
  u16 attr_id ;
  u16 tmp___0 ;
  u16 attr_data_len ;
  u16 tmp___1 ;
  u16 attr_len ;

  {
  attr_ptr = (u8 const   *)0U;
  target_attr_ptr = (u8 const   *)0U;
  wps_oui[0] = 0U;
  wps_oui[1] = 80U;
  wps_oui[2] = 242U;
  wps_oui[3] = 4U;
  if ((unsigned long )len_attr != (unsigned long )((u32 *)0U)) {
    *len_attr = 0U;
  } else {

  }
  if ((unsigned int )((unsigned char )*wps_ie) != 221U) {
    return (attr_ptr);
  } else {
    tmp = memcmp((void const   *)wps_ie + 2U, (void const   *)(& wps_oui), 4UL);
    if (tmp != 0) {
      return (attr_ptr);
    } else {

    }
  }
  attr_ptr = wps_ie + 6UL;
  goto ldv_53372;
  ldv_53371: 
  tmp___0 = get_unaligned_be16((void const   *)attr_ptr);
  attr_id = tmp___0;
  tmp___1 = get_unaligned_be16((void const   *)attr_ptr + 2U);
  attr_data_len = tmp___1;
  attr_len = (unsigned int )attr_data_len + 4U;
  if ((int )attr_id == (int )target_attr_id) {
    target_attr_ptr = attr_ptr;
    if ((unsigned long )buf_attr != (unsigned long )((u8 *)0U)) {
      memcpy((void *)buf_attr, (void const   *)attr_ptr, (size_t )attr_len);
    } else {

    }
    if ((unsigned long )len_attr != (unsigned long )((u32 *)0U)) {
      *len_attr = (u32 )attr_len;
    } else {

    }
    goto ldv_53370;
  } else {
    attr_ptr = attr_ptr + (unsigned long )attr_len;
  }
  ldv_53372: ;
  if ((long )attr_ptr - (long )wps_ie < (long )wps_ielen) {
    goto ldv_53371;
  } else {

  }
  ldv_53370: ;
  return (target_attr_ptr);
}
}
u8 const   *rtw_get_wps_attr_content23a(u8 const   *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                        u8 *buf_content ) 
{ 
  u8 const   *attr_ptr ;
  u32 attr_len ;

  {
  attr_ptr = rtw_get_wps_attr23a(wps_ie, wps_ielen, (int )target_attr_id, (u8 *)0U,
                                 & attr_len);
  if ((unsigned long )attr_ptr != (unsigned long )((u8 const   *)0U) && attr_len != 0U) {
    if ((unsigned long )buf_content != (unsigned long )((u8 *)0U)) {
      memcpy((void *)buf_content, (void const   *)attr_ptr + 4U, (size_t )(attr_len - 4U));
    } else {

    }
    return (attr_ptr + 4UL);
  } else {

  }
  return ((u8 const   *)0U);
}
}
static int rtw_get_cipher_info(struct wlan_network *pnetwork ) 
{ 
  u8 const   *pbuf ;
  int group_cipher ;
  int pairwise_cipher ;
  int is8021x ;
  int ret ;
  int r ;
  int plen ;
  char *pie ;

  {
  group_cipher = 0;
  pairwise_cipher = 0;
  is8021x = 0;
  ret = 0;
  pie = (char *)(& pnetwork->network.IEs);
  plen = (int )pnetwork->network.IELength;
  pbuf = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)pie, plen);
  if ((unsigned long )pbuf != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pbuf + 1UL)) != 0U) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16, 7, "rtw_get_cipher_info: wpa_ielen: %d\n", (int )*(pbuf + 1UL));
    } else {

    }
    r = rtw_parse_wpa_ie23a(pbuf, (int )*(pbuf + 1UL) + 2, & group_cipher, & pairwise_cipher,
                            & is8021x);
    if (r == 1) {
      pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
      pnetwork->BcnInfo.group_cipher = group_cipher;
      pnetwork->BcnInfo.is_8021x = is8021x;
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(16, 7, "%s: pnetwork->pairwise_cipher: %d, is_8021x is %d\n", "rtw_get_cipher_info",
                 pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.is_8021x);
      } else {

      }
      ret = 1;
    } else {

    }
  } else {
    pbuf = cfg80211_find_ie(48, (u8 const   *)pie, plen);
    if ((unsigned long )pbuf != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pbuf + 1UL)) != 0U) {
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(16, 7, "get RSN IE\n");
      } else {

      }
      r = rtw_parse_wpa2_ie23a(pbuf, (int )*(pbuf + 1UL) + 2, & group_cipher, & pairwise_cipher,
                               & is8021x);
      if (r == 1) {
        if (GlobalDebugLevel23A > 6U) {
          rt_trace(16, 7, "get RSN IE  OK!!!\n");
        } else {

        }
        pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
        pnetwork->BcnInfo.group_cipher = group_cipher;
        pnetwork->BcnInfo.is_8021x = is8021x;
        if (GlobalDebugLevel23A > 6U) {
          rt_trace(16, 7, "%s: pnetwork->pairwise_cipher: %d,pnetwork->group_cipher is %d, is_8021x is %d\n",
                   "rtw_get_cipher_info", pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.group_cipher,
                   pnetwork->BcnInfo.is_8021x);
        } else {

        }
        ret = 1;
      } else {

      }
    } else {

    }
  }
  return (ret);
}
}
void rtw_get_bcn_info23a(struct wlan_network *pnetwork ) 
{ 
  u8 bencrypt ;
  int pie_len ;
  u8 *pie ;
  u8 const   *p ;
  u8 const   *tmp ;

  {
  bencrypt = 0U;
  if (((int )pnetwork->network.capability & 16) != 0) {
    bencrypt = 1U;
    pnetwork->network.Privacy = 1U;
  } else {
    pnetwork->BcnInfo.encryp_protocol = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "%s: ssid =%s\n", "rtw_get_bcn_info23a", (u8 *)(& pnetwork->network.Ssid.ssid));
  } else {

  }
  pie = (u8 *)(& pnetwork->network.IEs);
  pie_len = (int )pnetwork->network.IELength;
  p = cfg80211_find_ie(48, (u8 const   *)pie, pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pnetwork->BcnInfo.encryp_protocol = 3U;
  } else {
    tmp = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)pie, pie_len);
    if ((unsigned long )tmp != (unsigned long )((u8 const   *)0U)) {
      pnetwork->BcnInfo.encryp_protocol = 2U;
    } else
    if ((unsigned int )bencrypt != 0U) {
      pnetwork->BcnInfo.encryp_protocol = 1U;
    } else {

    }
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "%s: pnetwork->encryp_protocol is %x\n", "rtw_get_bcn_info23a",
             (int )pnetwork->BcnInfo.encryp_protocol);
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "%s: pnetwork->encryp_protocol is %x\n", "rtw_get_bcn_info23a",
             (int )pnetwork->BcnInfo.encryp_protocol);
  } else {

  }
  rtw_get_cipher_info(pnetwork);
  return;
}
}
u16 rtw_mcs_rate23a(u8 rf_type , u8 bw_40MHz , u8 short_GI_20 , u8 short_GI_40 , struct ieee80211_mcs_info *mcs ) 
{ 
  u16 max_rate ;

  {
  max_rate = 0U;
  if ((unsigned int )rf_type == 3U) {
    if ((int )((signed char )mcs->rx_mask[0]) < 0) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1500U : 1350U) : ((unsigned int )short_GI_20 != 0U ? 722U : 650U);
    } else
    if (((unsigned long )mcs->rx_mask[0] & 64UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1350U : 1215U) : ((unsigned int )short_GI_20 != 0U ? 650U : 585U);
    } else
    if (((unsigned long )mcs->rx_mask[0] & 32UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
    } else
    if (((unsigned long )mcs->rx_mask[0] & 16UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
    } else
    if (((unsigned long )mcs->rx_mask[0] & 8UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
    } else
    if (((unsigned long )mcs->rx_mask[0] & 4UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 450U : 405U) : ((unsigned int )short_GI_20 != 0U ? 217U : 195U);
    } else
    if (((unsigned long )mcs->rx_mask[0] & 2UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
    } else
    if ((int )mcs->rx_mask[0] & 1) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 150U : 135U) : ((unsigned int )short_GI_20 != 0U ? 72U : 65U);
    } else {

    }
  } else
  if ((unsigned int )mcs->rx_mask[1] != 0U) {
    if ((int )((signed char )mcs->rx_mask[1]) < 0) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 3000U : 2700U) : ((unsigned int )short_GI_20 != 0U ? 1444U : 1300U);
    } else
    if (((unsigned long )mcs->rx_mask[1] & 64UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 2700U : 2430U) : ((unsigned int )short_GI_20 != 0U ? 1300U : 1170U);
    } else
    if (((unsigned long )mcs->rx_mask[1] & 32UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 2400U : 2160U) : ((unsigned int )short_GI_20 != 0U ? 1156U : 1040U);
    } else
    if (((unsigned long )mcs->rx_mask[1] & 16UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1800U : 1620U) : ((unsigned int )short_GI_20 != 0U ? 867U : 780U);
    } else
    if (((unsigned long )mcs->rx_mask[1] & 8UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
    } else
    if (((unsigned long )mcs->rx_mask[1] & 4UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
    } else
    if (((unsigned long )mcs->rx_mask[1] & 2UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
    } else
    if ((int )mcs->rx_mask[1] & 1) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
    } else {

    }
  } else
  if ((int )((signed char )mcs->rx_mask[0]) < 0) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1500U : 1350U) : ((unsigned int )short_GI_20 != 0U ? 722U : 650U);
  } else
  if (((unsigned long )mcs->rx_mask[0] & 64UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1350U : 1215U) : ((unsigned int )short_GI_20 != 0U ? 650U : 585U);
  } else
  if (((unsigned long )mcs->rx_mask[0] & 32UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
  } else
  if (((unsigned long )mcs->rx_mask[0] & 16UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
  } else
  if (((unsigned long )mcs->rx_mask[0] & 8UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
  } else
  if (((unsigned long )mcs->rx_mask[0] & 4UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 450U : 405U) : ((unsigned int )short_GI_20 != 0U ? 217U : 195U);
  } else
  if (((unsigned long )mcs->rx_mask[0] & 2UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
  } else
  if ((int )mcs->rx_mask[0] & 1) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 150U : 135U) : ((unsigned int )short_GI_20 != 0U ? 72U : 65U);
  } else {

  }
  return (max_rate);
}
}
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_52(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern void __list_del_entry(struct list_head * ) ;
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
  __list_del_entry(entry);
  INIT_LIST_HEAD(entry);
  return;
}
}
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
  v->counter = i;
  return;
}
}
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
  return (& lock->__annonCompField18.rlock);
}
}
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
int ldv_mod_timer_69(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_70(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_71(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_73(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_74(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_75(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_76(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_77(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_68(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_72(struct timer_list *ldv_func_arg1 ) ;
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_64(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_67(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_66(struct workqueue_struct *ldv_func_arg1 ) ;
extern struct pid *find_vpid(int  ) ;
extern int kill_pid(struct pid * , int  , int  ) ;
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
  return (exp);
}
}
struct timer_list *ldv_timer_list_7_1 ;
int ldv_timer_5_2 ;
struct timer_list *ldv_timer_list_5_0 ;
int ldv_timer_6_2 ;
struct timer_list *ldv_timer_list_5_3 ;
int ldv_timer_4_3 ;
int ldv_timer_6_0 ;
struct timer_list *ldv_timer_list_5_1 ;
struct timer_list *ldv_timer_list_6_3 ;
struct timer_list *ldv_timer_list_6_2 ;
struct timer_list *ldv_timer_list_4_0 ;
struct timer_list *ldv_timer_list_7_3 ;
struct timer_list *ldv_timer_list_6_0 ;
int ldv_timer_7_1 ;
struct timer_list *ldv_timer_list_4_3 ;
int ldv_timer_5_3 ;
struct timer_list *ldv_timer_list_7_0 ;
int ldv_timer_4_1 ;
struct timer_list *ldv_timer_list_4_1 ;
int ldv_timer_7_3 ;
int ldv_timer_4_0 ;
struct timer_list *ldv_timer_list_5_2 ;
int ldv_timer_5_1 ;
struct timer_list *ldv_timer_list_7_2 ;
struct timer_list *ldv_timer_list_6_1 ;
int ldv_timer_7_0 ;
int ldv_timer_6_3 ;
int ldv_timer_4_2 ;
int ldv_timer_5_0 ;
int ldv_timer_7_2 ;
struct timer_list *ldv_timer_list_4_2 ;
int ldv_timer_6_1 ;
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) ;
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void ldv_timer_5(int state , struct timer_list *timer ) ;
void choose_timer_5(void) ;
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void timer_init_4(void) ;
void timer_init_6(void) ;
void ldv_timer_7(int state , struct timer_list *timer ) ;
void timer_init_5(void) ;
void disable_suitable_timer_6(struct timer_list *timer ) ;
void disable_suitable_timer_5(struct timer_list *timer ) ;
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) ;
void disable_suitable_timer_7(struct timer_list *timer ) ;
void choose_timer_6(void) ;
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void ldv_timer_6(int state , struct timer_list *timer ) ;
void timer_init_7(void) ;
void choose_timer_4(void) ;
void disable_suitable_timer_4(struct timer_list *timer ) ;
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
int reg_timer_11(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void choose_timer_7(void) ;
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void ldv_timer_4(int state , struct timer_list *timer ) ;
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) ;
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) ;
extern void netif_carrier_on(struct net_device * ) ;
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 
  u32 a ;

  {
  a = *((u32 const   *)addr);
  return ((a & 1U) != 0U);
}
}
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
  return (fold == 0U);
}
}
__inline static void *wiphy_priv(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3259), "i" (12UL));
    ldv_48232: ;
    goto ldv_48232;
  } else {

  }
  return ((void *)(& wiphy->priv));
}
}
__inline static void *wdev_priv(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3512), "i" (12UL));
    ldv_48317: ;
    goto ldv_48317;
  } else {

  }
  tmp___0 = wiphy_priv(wdev->wiphy);
  return (tmp___0);
}
}
__inline static struct list_head *get_list_head(struct rtw_queue *queue ) 
{ 


  {
  return (& queue->queue);
}
}
unsigned char MCS_rate_2R23A[16U] ;
unsigned char MCS_rate_1R23A[16U] ;
void _rtw_init_queue23a(struct rtw_queue *pqueue ) ;
void rtw_update_protection23a(struct rtw_adapter *padapter , u8 *ie , uint ie_len ) ;
void rtw_os_xmit_schedule23a(struct rtw_adapter *padapter ) ;
u32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter ) ;
int GetHalDefVar8192CUsb(struct rtw_adapter *Adapter , enum hal_def_variable eVariable ,
                         void *pValue ) ;
void rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter , u8 val ) ;
u8 rtl8723a_get_rf_type(struct rtw_adapter *padapter ) ;
int rtw_free_stainfo23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void rtw_free_all_stainfo23a(struct rtw_adapter *padapter ) ;
int rtw_init_bcmc_stainfo23a(struct rtw_adapter *padapter ) ;
bool rtw_access_ctrl23a(struct rtw_adapter *padapter , u8 *mac_addr ) ;
void rtw_os_indicate_disconnect23a(struct rtw_adapter *adapter ) ;
void rtw_reset_securitypriv23a(struct rtw_adapter *adapter ) ;
void rtw_joinbss_event_prehandle23a(struct rtw_adapter *adapter , u8 *pbuf ) ;
void rtw_survey_event_cb23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
void rtw_surveydone_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
void rtw23a_joinbss_event_cb(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
void rtw_stassoc_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
void rtw_stadel_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
void rtw23a_join_to_handler(unsigned long data ) ;
int rtw_init_mlme_priv23a(struct rtw_adapter *padapter ) ;
void rtw_free_mlme_priv23a(struct mlme_priv *pmlmepriv ) ;
int rtw_do_join_adhoc(struct rtw_adapter *adapter ) ;
int rtw_do_join_network(struct rtw_adapter *adapter , struct wlan_network *candidate ) ;
int rtw_select_and_join_from_scanned_queue23a(struct mlme_priv *pmlmepriv ) ;
int rtw_set_key23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ,
                   int keyid , u8 set_tx ) ;
int rtw_set_auth23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ) ;
__inline static int get_fwstate(struct mlme_priv *pmlmepriv ) 
{ 


  {
  return (pmlmepriv->fw_state);
}
}
void rtw_generate_random_ibss23a(u8 *pibss ) ;
struct wlan_network *rtw_find_network23a(struct rtw_queue *scanned_queue , u8 *addr ) ;
void rtw_free_assoc_resources23a(struct rtw_adapter *adapter , int lock_scanned_queue ) ;
void rtw_indicate_disconnect23a(struct rtw_adapter *padapter ) ;
void rtw_scan_abort23a(struct rtw_adapter *adapter ) ;
void rtw_init_registrypriv_dev_network23a(struct rtw_adapter *adapter ) ;
void rtw_update_registrypriv_dev_network23a(struct rtw_adapter *adapter ) ;
void rtw_scan_timeout_handler23a(unsigned long data ) ;
void rtw_dynamic_check_timer_handler(unsigned long data ) ;
void rtw_clear_scan_deny(struct rtw_adapter *adapter ) ;
void rtw_set_scan_deny_timer_hdl(unsigned long data ) ;
void rtw_set_scan_deny(struct rtw_adapter *adapter , u32 ms ) ;
void rtw23a_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv ) ;
int rtw_if_up23a(struct rtw_adapter *padapter ) ;
int rtw_linked_check(struct rtw_adapter *padapter ) ;
void rtw_joinbss_reset23a(struct rtw_adapter *padapter ) ;
void rtw_update_ht_cap23a(struct rtw_adapter *padapter , u8 *pie , uint ie_len ) ;
void rtw_issue_addbareq_cmd23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
bool rtw_is_same_ibss23a(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) ;
int is_same_network23a(struct wlan_bssid_ex *src , struct wlan_bssid_ex *dst ) ;
void rtw23a_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) ;
void rtw_set_roaming(struct rtw_adapter *adapter , u8 to_roaming ) ;
void update_network23a(struct wlan_bssid_ex *dst , struct wlan_bssid_ex *src , struct rtw_adapter *padapter ,
                       bool update_ie ) ;
void update_sta_info23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void mlmeext_joinbss_event_callback23a(struct rtw_adapter *padapter , int join_res ) ;
void mlmeext_sta_del_event_callback23a(struct rtw_adapter *padapter ) ;
void mlmeext_sta_add_event_callback23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void ap_sta_info_defer_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter ) ;
void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter ) ;
void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter ) ;
void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv , bool aborted ) ;
__inline static u8 *myid(struct eeprom_priv *peepriv ) 
{ 


  {
  return ((u8 *)(& peepriv->mac_addr));
}
}
void rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter , enum hal_odm_variable eVariable ,
                           void *pValue1 , bool bSet ) ;
void rtw_sreset_reset(struct rtw_adapter *active_adapter ) ;
static struct wlan_network *rtw_select_candidate_from_queue(struct mlme_priv *pmlmepriv ) ;
static int rtw_do_join(struct rtw_adapter *padapter ) ;
static void rtw_init_mlme_timer(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
  pmlmepriv = & padapter->mlmepriv;
  reg_timer_11(& pmlmepriv->assoc_timer, & rtw23a_join_to_handler, (unsigned long )padapter);
  reg_timer_11(& pmlmepriv->scan_to_timer, & rtw_scan_timeout_handler23a, (unsigned long )padapter);
  reg_timer_11(& pmlmepriv->dynamic_chk_timer, & rtw_dynamic_check_timer_handler,
               (unsigned long )padapter);
  reg_timer_11(& pmlmepriv->set_scan_deny_timer, & rtw_set_scan_deny_timer_hdl, (unsigned long )padapter);
  return;
}
}
int rtw_init_mlme_priv23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct lock_class_key __key ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmepriv->nic_hdl = padapter;
  pmlmepriv->fw_state = 0;
  pmlmepriv->cur_network.network.ifmode = 0;
  pmlmepriv->scan_mode = 1;
  spinlock_check(& pmlmepriv->lock);
  __raw_spin_lock_init(& pmlmepriv->lock.__annonCompField18.rlock, "&(&pmlmepriv->lock)->rlock",
                       & __key);
  _rtw_init_queue23a(& pmlmepriv->scanned_queue);
  memset((void *)(& pmlmepriv->assoc_ssid), 0, 33UL);
  rtw_clear_scan_deny(padapter);
  rtw_init_mlme_timer(padapter);
  return (1);
}
}
static void rtw_free_mlme_ie_data(u8 **ppie , u32 *plen ) 
{ 


  {
  if ((unsigned long )*ppie != (unsigned long )((u8 *)0U)) {
    kfree((void const   *)*ppie);
    *plen = 0U;
    *ppie = (u8 *)0U;
  } else {

  }
  return;
}
}
void rtw23a_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv ) 
{ 


  {
  kfree((void const   *)pmlmepriv->assoc_req);
  kfree((void const   *)pmlmepriv->assoc_rsp);
  rtw_free_mlme_ie_data(& pmlmepriv->wps_probe_req_ie, & pmlmepriv->wps_probe_req_ie_len);
  return;
}
}
void rtw_free_mlme_priv23a(struct mlme_priv *pmlmepriv ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "rtw_free_mlme_priv23a\n");
  } else {

  }
  rtw23a_free_mlme_priv_ie_data(pmlmepriv);
  return;
}
}
struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv , gfp_t gfp ) 
{ 
  struct wlan_network *pnetwork ;
  void *tmp ;

  {
  tmp = kzalloc(928UL, gfp);
  pnetwork = (struct wlan_network *)tmp;
  if ((unsigned long )pnetwork != (unsigned long )((struct wlan_network *)0)) {
    INIT_LIST_HEAD(& pnetwork->list);
    pnetwork->network_type = 0;
    pnetwork->fixed = 0;
    pnetwork->last_scanned = jiffies;
    pnetwork->join_res = 0;
  } else {

  }
  return (pnetwork);
}
}
static void _rtw_free_network23a(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork ) 
{ 


  {
  if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
    return;
  } else {

  }
  if (pnetwork->fixed == 1) {
    return;
  } else {

  }
  list_del_init(& pnetwork->list);
  kfree((void const   *)pnetwork);
  return;
}
}
struct wlan_network *rtw_find_network23a(struct rtw_queue *scanned_queue , u8 *addr ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct wlan_network *pnetwork ;
  bool tmp ;
  struct list_head  const  *__mptr ;
  bool tmp___0 ;

  {
  pnetwork = (struct wlan_network *)0;
  tmp = is_zero_ether_addr((u8 const   *)addr);
  if ((int )tmp) {
    pnetwork = (struct wlan_network *)0;
    goto exit;
  } else {

  }
  phead = get_list_head(scanned_queue);
  plist = phead->next;
  goto ldv_55826;
  ldv_55825: 
  __mptr = (struct list_head  const  *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  tmp___0 = ether_addr_equal((u8 const   *)addr, (u8 const   *)(& pnetwork->network.MacAddress));
  if ((int )tmp___0) {
    goto ldv_55824;
  } else {

  }
  plist = plist->next;
  ldv_55826: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55825;
  } else {

  }
  ldv_55824: ;
  if ((unsigned long )plist == (unsigned long )phead) {
    pnetwork = (struct wlan_network *)0;
  } else {

  }
  exit: ;
  return (pnetwork);
}
}
void rtw_free_network_queue23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct wlan_network *pnetwork ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *scanned_queue ;
  struct list_head  const  *__mptr ;

  {
  pmlmepriv = & padapter->mlmepriv;
  scanned_queue = & pmlmepriv->scanned_queue;
  spin_lock_bh(& scanned_queue->lock);
  phead = get_list_head(scanned_queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_55839;
  ldv_55838: 
  __mptr = (struct list_head  const  *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  _rtw_free_network23a(pmlmepriv, pnetwork);
  plist = ptmp;
  ptmp = plist->next;
  ldv_55839: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55838;
  } else {

  }
  spin_unlock_bh(& scanned_queue->lock);
  return;
}
}
int rtw_if_up23a(struct rtw_adapter *padapter ) 
{ 
  int res ;
  bool tmp ;
  int tmp___0 ;

  {
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto _L;
  } else {
    tmp = check_fwstate(& padapter->mlmepriv, 1);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      _L: /* CIL Label */ 
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(16, 7, "rtw_if_up23a:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",
                 padapter->bDriverStopped, padapter->bSurpriseRemoved);
      } else {

      }
      res = 0;
    } else {
      res = 1;
    }
  }
  return (res);
}
}
void rtw_generate_random_ibss23a(u8 *pibss ) 
{ 
  unsigned long curtime ;

  {
  curtime = jiffies;
  *pibss = 2U;
  *(pibss + 1UL) = 17U;
  *(pibss + 2UL) = 135U;
  *(pibss + 3UL) = (u8 )curtime;
  *(pibss + 4UL) = (u8 )(curtime >> 8);
  *(pibss + 5UL) = (u8 )(curtime >> 16);
  return;
}
}
void rtw_set_roaming(struct rtw_adapter *adapter , u8 to_roaming ) 
{ 


  {
  if ((unsigned int )to_roaming == 0U) {
    adapter->mlmepriv.to_join = 0U;
  } else {

  }
  adapter->mlmepriv.to_roaming = to_roaming;
  return;
}
}
static void _rtw_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  int do_join_r ;

  {
  pmlmepriv = & padapter->mlmepriv;
  if ((unsigned long )tgt_network != (unsigned long )((struct wlan_network *)0)) {
    pnetwork = tgt_network;
  } else {
    pnetwork = & pmlmepriv->cur_network;
  }
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: roaming from %s(%pM), length:%d\n", (u8 *)(& pnetwork->network.Ssid.ssid),
             (u8 *)(& pnetwork->network.MacAddress), (int )pnetwork->network.Ssid.ssid_len);
    } else {

    }
    memcpy((void *)(& pmlmepriv->assoc_ssid), (void const   *)(& pnetwork->network.Ssid),
             33UL);
    pmlmepriv->assoc_by_bssid = 0U;
    ldv_55863: 
    do_join_r = rtw_do_join(padapter);
    if (do_join_r == 1) {
      goto ldv_55860;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: roaming do_join return %d\n", do_join_r);
      } else {

      }
      pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
      if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
        goto ldv_55861;
      } else {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s(%d) -to roaming fail, indicate_disconnect\n",
                 "_rtw_roaming", 263);
        } else {

        }
        rtw_indicate_disconnect23a(padapter);
        goto ldv_55860;
      }
    }
    ldv_55861: ;
    goto ldv_55863;
    ldv_55860: ;
  } else {

  }
  return;
}
}
void rtw23a_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
  pmlmepriv = & padapter->mlmepriv;
  spin_lock_bh(& pmlmepriv->lock);
  _rtw_roaming(padapter, tgt_network);
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
static void rtw_free_network_nolock(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork ) 
{ 


  {
  _rtw_free_network23a(pmlmepriv, pnetwork);
  return;
}
}
bool rtw_is_same_ibss23a(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) 
{ 
  int ret ;
  struct security_priv *psecuritypriv ;

  {
  psecuritypriv = & adapter->securitypriv;
  if (psecuritypriv->dot11PrivacyAlgrthm != 0U && pnetwork->network.Privacy == 0U) {
    ret = 0;
  } else
  if (psecuritypriv->dot11PrivacyAlgrthm == 0U && pnetwork->network.Privacy == 1U) {
    ret = 0;
  } else {
    ret = 1;
  }
  return (ret != 0);
}
}
__inline int is_same_ess(struct wlan_bssid_ex *a , struct wlan_bssid_ex *b ) ;
__inline int is_same_ess(struct wlan_bssid_ex *a , struct wlan_bssid_ex *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((int )a->Ssid.ssid_len == (int )b->Ssid.ssid_len) {
    tmp = memcmp((void const   *)(& a->Ssid.ssid), (void const   *)(& b->Ssid.ssid),
                 (size_t )a->Ssid.ssid_len);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int is_same_network23a(struct wlan_bssid_ex *src , struct wlan_bssid_ex *dst ) 
{ 
  u16 s_cap ;
  u16 d_cap ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  s_cap = src->capability;
  d_cap = dst->capability;
  if ((int )src->Ssid.ssid_len == (int )dst->Ssid.ssid_len) {
    tmp = ether_addr_equal((u8 const   *)(& src->MacAddress), (u8 const   *)(& dst->MacAddress));
    if ((int )tmp) {
      tmp___0 = memcmp((void const   *)(& src->Ssid.ssid), (void const   *)(& dst->Ssid.ssid),
                       (size_t )src->Ssid.ssid_len);
      if (tmp___0 == 0) {
        if ((((int )s_cap ^ (int )d_cap) & 2) == 0) {
          if ((((int )s_cap ^ (int )d_cap) & 1) == 0) {
            tmp___1 = 1;
          } else {
            tmp___1 = 0;
          }
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
struct wlan_network *rtw_get_oldest_wlan_network23a(struct rtw_queue *scanned_queue ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct wlan_network *pwlan ;
  struct wlan_network *oldest ;
  struct list_head  const  *__mptr ;

  {
  oldest = (struct wlan_network *)0;
  phead = get_list_head(scanned_queue);
  plist = phead->next;
  goto ldv_55908;
  ldv_55907: 
  __mptr = (struct list_head  const  *)plist;
  pwlan = (struct wlan_network *)__mptr;
  if (pwlan->fixed != 1) {
    if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0) || (long )(pwlan->last_scanned - oldest->last_scanned) < 0L) {
      oldest = pwlan;
    } else {

    }
  } else {

  }
  plist = plist->next;
  ldv_55908: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55907;
  } else {

  }

  return (oldest);
}
}
void update_network23a(struct wlan_bssid_ex *dst , struct wlan_bssid_ex *src , struct rtw_adapter *padapter ,
                       bool update_ie ) 
{ 
  u8 ss_ori ;
  u8 sq_ori ;
  long rssi_ori ;
  u8 ss_smp ;
  u8 sq_smp ;
  long rssi_smp ;
  u8 ss_final ;
  u8 sq_final ;
  long rssi_final ;
  bool tmp ;
  int tmp___0 ;
  uint tmp___1 ;

  {
  ss_ori = dst->SignalStrength;
  sq_ori = dst->SignalQuality;
  rssi_ori = dst->Rssi;
  ss_smp = src->SignalStrength;
  sq_smp = src->SignalQuality;
  rssi_smp = src->Rssi;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s %s(%pM, ch%u) ss_ori:%3u, sq_ori:%3u, rssi_ori:%3ld, ss_smp:%3u, sq_smp:%3u, rssi_smp:%3ld\n",
           "update_network23a", (u8 *)(& src->Ssid.ssid), (u8 *)(& src->MacAddress),
           src->DSConfig, (int )ss_ori, (int )sq_ori, rssi_ori, (int )ss_smp, (int )sq_smp,
           rssi_smp);
  } else {

  }
  tmp = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp) {
    tmp___0 = is_same_network23a(& padapter->mlmepriv.cur_network.network, src);
    if (tmp___0 != 0) {
      ss_final = padapter->recvpriv.signal_strength;
      sq_final = padapter->recvpriv.signal_qual;
      if ((unsigned int )sq_smp != 101U) {
        rssi_final = (src->Rssi + dst->Rssi * 4L) / 5L;
      } else {
        rssi_final = rssi_ori;
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((unsigned int )sq_smp != 101U) {
    ss_final = (u8 )(((unsigned int )src->SignalStrength + (unsigned int )dst->SignalStrength * 4U) / 5U);
    sq_final = (u8 )(((unsigned int )src->SignalQuality + (unsigned int )dst->SignalQuality * 4U) / 5U);
    rssi_final = src->Rssi + (dst->Rssi * 4L) / 5L;
  } else {
    ss_final = dst->SignalStrength;
    sq_final = dst->SignalQuality;
    rssi_final = dst->Rssi;
  }
  if ((int )update_ie) {
    tmp___1 = get_wlan_bssid_ex_sz(src);
    memcpy((void *)dst, (void const   *)src, (size_t )tmp___1);
  } else {

  }
  dst->SignalStrength = ss_final;
  dst->SignalQuality = sq_final;
  dst->Rssi = rssi_final;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s %s(%pM), SignalStrength:%u, SignalQuality:%u, RawRSSI:%ld\n",
           "update_network23a", (u8 *)(& dst->Ssid.ssid), (u8 *)(& dst->MacAddress),
           (int )dst->SignalStrength, (int )dst->SignalQuality, dst->Rssi);
  } else {

  }
  return;
}
}
static void update_current_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *pnetwork ) 
{ 
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    tmp___0 = is_same_network23a(& pmlmepriv->cur_network.network, pnetwork);
    if (tmp___0 != 0) {
      update_network23a(& pmlmepriv->cur_network.network, pnetwork, adapter, 1);
      rtw_update_protection23a(adapter, (u8 *)(& pmlmepriv->cur_network.network.IEs),
                               pmlmepriv->cur_network.network.IELength);
    } else {

    }
  } else {

  }
  return;
}
}
static void rtw_update_scanned_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *target ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  struct wlan_network *oldest ;
  struct rtw_queue *queue ;
  u32 bssid_ex_sz ;
  int found ;
  struct list_head  const  *__mptr ;
  int tmp ;
  bool update_ie ;

  {
  pmlmepriv = & adapter->mlmepriv;
  pnetwork = (struct wlan_network *)0;
  oldest = (struct wlan_network *)0;
  queue = & pmlmepriv->scanned_queue;
  found = 0;
  spin_lock_bh(& queue->lock);
  phead = get_list_head(queue);
  plist = phead->next;
  goto ldv_55953;
  ldv_55952: 
  __mptr = (struct list_head  const  *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  tmp = is_same_network23a(& pnetwork->network, target);
  if (tmp != 0) {
    found = 1;
    goto ldv_55945;
  } else {

  }
  if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0) || (long )(pnetwork->last_scanned - oldest->last_scanned) < 0L) {
    oldest = pnetwork;
  } else {

  }
  plist = plist->next;
  ldv_55953: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55952;
  } else {

  }
  ldv_55945: ;
  if (found == 0) {
    pnetwork = rtw_alloc_network(pmlmepriv, 32U);
    if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
      if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0)) {
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(16, 4, "something wrong here\n");
        } else {

        }
        goto exit;
      } else {

      }
      pnetwork = oldest;
    } else {
      list_add_tail(& pnetwork->list, & queue->queue);
    }
    bssid_ex_sz = get_wlan_bssid_ex_sz(target);
    target->Length = bssid_ex_sz;
    memcpy((void *)(& pnetwork->network), (void const   *)target, (size_t )bssid_ex_sz);
    pnetwork->fixed = 0;
    pnetwork->last_scanned = jiffies;
    pnetwork->network_type = 0;
    pnetwork->join_res = 0;
    if ((unsigned int )pnetwork->network.SignalQuality == 101U) {
      pnetwork->network.SignalQuality = 0U;
    } else {

    }
  } else {
    update_ie = 1;
    pnetwork->last_scanned = jiffies;
    if (pnetwork->network.IELength > target->IELength && (unsigned int )target->reserved == 1U) {
      update_ie = 0;
    } else {

    }
    update_network23a(& pnetwork->network, target, adapter, (int )update_ie);
  }
  exit: 
  spin_unlock_bh(& queue->lock);
  return;
}
}
static void rtw_add_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *pnetwork ) 
{ 


  {
  update_current_network(adapter, pnetwork);
  rtw_update_scanned_network(adapter, pnetwork);
  return;
}
}
static int rtw_is_desired_network(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) 
{ 
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  u32 desired_encmode ;
  u32 privacy ;
  int bselected ;
  u8 const   *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  psecuritypriv = & adapter->securitypriv;
  pmlmepriv = & adapter->mlmepriv;
  bselected = 1;
  desired_encmode = psecuritypriv->ndisencryptstatus;
  privacy = pnetwork->network.Privacy;
  tmp___0 = check_fwstate(pmlmepriv, 256);
  if ((int )tmp___0) {
    tmp = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)(& pnetwork->network.IEs),
                                  (int )pnetwork->network.IELength);
    if ((unsigned long )tmp != (unsigned long )((u8 const   *)0U)) {
      return (1);
    } else {
      return (0);
    }
  } else {

  }
  if ((unsigned int )adapter->registrypriv.wifi_spec == 1U) {
    if (desired_encmode == 1U && privacy != 0U) {
      bselected = 0;
    } else {

    }
  } else {

  }
  if (desired_encmode != 1U && privacy == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: desired_encmode: %d, privacy: %d\n", desired_encmode,
             privacy);
    } else {

    }
    bselected = 0;
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 32);
  if ((int )tmp___1) {
    if ((unsigned int )pnetwork->network.ifmode != (unsigned int )pmlmepriv->cur_network.network.ifmode) {
      bselected = 0;
    } else {

    }
  } else {

  }
  return (bselected);
}
}
void rtw_survey_event_cb23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  u32 len ;
  struct wlan_bssid_ex *pnetwork ;
  struct mlme_priv *pmlmepriv ;
  struct survey_event *survey ;
  struct wlan_network *ibss_wlan ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  survey = (struct survey_event *)pbuf;
  pnetwork = survey->bss;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "rtw_survey_event_cb23a, ssid=%s\n", (u8 *)(& pnetwork->Ssid.ssid));
  } else {

  }
  len = get_wlan_bssid_ex_sz(pnetwork);
  if (len > 871U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "****rtw_survey_event_cb23a: return a wrong bss ***\n");
    } else {

    }
    return;
  } else {

  }
  spin_lock_bh(& pmlmepriv->lock);
  tmp___0 = check_fwstate(pmlmepriv, 64);
  if ((int )tmp___0) {
    tmp = ether_addr_equal((u8 const   *)(& pmlmepriv->cur_network.network.MacAddress),
                           (u8 const   *)(& pnetwork->MacAddress));
    if ((int )tmp) {
      pmlmepriv->cur_network.network.beacon_interval = pnetwork->beacon_interval;
      pmlmepriv->cur_network.network.capability = pnetwork->capability;
      pmlmepriv->cur_network.network.tsf = pnetwork->tsf;
      spin_lock_bh(& pmlmepriv->scanned_queue.lock);
      ibss_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->MacAddress));
      if ((unsigned long )ibss_wlan != (unsigned long )((struct wlan_network *)0)) {
        pmlmepriv->cur_network.network.beacon_interval = ibss_wlan->network.beacon_interval;
        pmlmepriv->cur_network.network.capability = ibss_wlan->network.capability;
        pmlmepriv->cur_network.network.tsf = ibss_wlan->network.tsf;
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        goto exit;
      } else {

      }
      spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
    } else {

    }
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 128);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    if ((unsigned int )pnetwork->Ssid.ssid[0] == 0U) {
      pnetwork->Ssid.ssid_len = 0U;
    } else {

    }
    rtw_add_network(adapter, pnetwork);
  } else {

  }
  exit: 
  spin_unlock_bh(& pmlmepriv->lock);
  kfree((void const   *)survey->bss);
  survey->bss = (struct wlan_bssid_ex *)0;
  return;
}
}
void rtw_surveydone_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  pmlmeext = & adapter->mlmeextpriv;
  spin_lock_bh(& pmlmepriv->lock);
  if ((unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
    pmlmepriv->wps_probe_req_ie_len = 0U;
    kfree((void const   *)pmlmepriv->wps_probe_req_ie);
    pmlmepriv->wps_probe_req_ie = (u8 *)0U;
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    tmp = get_fwstate(pmlmepriv);
    rt_trace(16, 7, "rtw_surveydone_event_callback23a: fw_state:%x\n", tmp);
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___1) {
    ldv_del_timer_sync_68(& pmlmepriv->scan_to_timer);
    _clr_fwstate_(pmlmepriv, 2048);
  } else
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = get_fwstate(pmlmepriv);
    rt_trace(16, 4, "nic status =%x, survey done event comes too late!\n", tmp___0);
  } else {

  }
  tmp___2 = msecs_to_jiffies(adapter->recvpriv.signal_stat_sampling_interval);
  ldv_mod_timer_69(& adapter->recvpriv.signal_stat_timer, tmp___2 + (unsigned long )jiffies);
  if ((unsigned int )pmlmepriv->to_join == 1U) {
    set_fwstate(pmlmepriv, 128);
    tmp___4 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___4) {
      ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
      if (ret != 1) {
        rtw_do_join_adhoc(adapter);
      } else {

      }
    } else {
      pmlmepriv->to_join = 0U;
      ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
      if (ret != 1) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: try_to_join, but select scanning queue fail, to_roaming:%d\n",
                 (int )adapter->mlmepriv.to_roaming);
        } else {

        }
        if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
          pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
          if ((unsigned int )pmlmepriv->to_roaming == 0U) {
            rtw_set_roaming(adapter, 0);
            rtw_free_assoc_resources23a(adapter, 1);
            rtw_indicate_disconnect23a(adapter);
          } else {
            tmp___3 = rtw_sitesurvey_cmd23a(adapter, & pmlmepriv->assoc_ssid, 1, (struct rtw_ieee80211_channel *)0,
                                            0);
            if (tmp___3 != 1) {
              rtw_set_roaming(adapter, 0);
              rtw_free_assoc_resources23a(adapter, 1);
              rtw_indicate_disconnect23a(adapter);
            } else {
              pmlmepriv->to_join = 1U;
            }
          }
        } else {

        }
        _clr_fwstate_(pmlmepriv, 128);
      } else {

      }
    }
  } else {

  }
  spin_unlock_bh(& pmlmepriv->lock);
  rtw_os_xmit_schedule23a(adapter);
  if (pmlmeext->sitesurvey_res.bss_cnt == 0) {
    rtw_sreset_reset(adapter);
  } else {

  }
  rtw_cfg80211_surveydone_event_callback(adapter);
  return;
}
}
static void free_scanqueue(struct mlme_priv *pmlmepriv ) 
{ 
  struct wlan_network *pnetwork ;
  struct rtw_queue *scan_queue ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptemp ;
  struct list_head  const  *__mptr ;

  {
  scan_queue = & pmlmepriv->scanned_queue;
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(16, 6, "+free_scanqueue\n");
  } else {

  }
  spin_lock_bh(& scan_queue->lock);
  phead = get_list_head(scan_queue);
  plist = phead->next;
  ptemp = plist->next;
  goto ldv_55997;
  ldv_55996: 
  __mptr = (struct list_head  const  *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  pnetwork->fixed = 0;
  _rtw_free_network23a(pmlmepriv, pnetwork);
  plist = ptemp;
  ptemp = plist->next;
  ldv_55997: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55996;
  } else {

  }
  spin_unlock_bh(& scan_queue->lock);
  return;
}
}
void rtw_free_assoc_resources23a(struct rtw_adapter *adapter , int lock_scanned_queue ) 
{ 
  struct wlan_network *pwlan ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct wlan_network *tgt_network ;
  struct sta_info *psta ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  pstapriv = & adapter->stapriv;
  tgt_network = & pmlmepriv->cur_network;
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(16, 6, "+rtw_free_assoc_resources23a\n");
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "tgt_network->network.MacAddress=%pM ssid=%s\n", (u8 *)(& tgt_network->network.MacAddress),
             (u8 *)(& tgt_network->network.Ssid.ssid));
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 24);
  if ((int )tmp) {
    psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& tgt_network->network.MacAddress));
    spin_lock_bh(& pstapriv->sta_hash_lock);
    rtw_free_stainfo23a(adapter, psta);
    spin_unlock_bh(& pstapriv->sta_hash_lock);
  } else {

  }
  tmp___0 = check_fwstate(pmlmepriv, 112);
  if ((int )tmp___0) {
    rtw_free_all_stainfo23a(adapter);
    psta = rtw_get_bcmc_stainfo23a(adapter);
    spin_lock_bh(& pstapriv->sta_hash_lock);
    rtw_free_stainfo23a(adapter, psta);
    spin_unlock_bh(& pstapriv->sta_hash_lock);
    rtw_init_bcmc_stainfo23a(adapter);
  } else {

  }
  if (lock_scanned_queue != 0) {
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  } else {

  }
  pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
  if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
    pwlan->fixed = 0;
  } else
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "rtw_free_assoc_resources23a : pwlan== NULL\n");
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 64);
  if ((int )tmp___1 && adapter->stapriv.asoc_sta_count == 1) {
    rtw_free_network_nolock(pmlmepriv, pwlan);
  } else {

  }
  if (lock_scanned_queue != 0) {
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  } else {

  }
  pmlmepriv->key_mask = 0U;
  return;
}
}
void rtw_indicate_connect23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct pid *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "+rtw_indicate_connect23a\n");
  } else {

  }
  pmlmepriv->to_join = 0U;
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    set_fwstate(pmlmepriv, 1);
    rtw_cfg80211_indicate_connect(padapter);
    netif_carrier_on(padapter->pnetdev);
    if (padapter->pid[2] != 0) {
      tmp = find_vpid(padapter->pid[2]);
      kill_pid(tmp, 14, 1);
    } else {

    }
  } else {

  }
  rtw_set_roaming(padapter, 0);
  rtw_set_scan_deny(padapter, 3000U);
  if (GlobalDebugLevel23A > 3U) {
    tmp___2 = get_fwstate(pmlmepriv);
    rt_trace(16, 4, "-rtw_indicate_connect23a: fw_state=0x%08x\n", tmp___2);
  } else {

  }
  return;
}
}
void rtw_indicate_disconnect23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "+rtw_indicate_disconnect23a\n");
  } else {

  }
  _clr_fwstate_(pmlmepriv, 384);
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
    _clr_fwstate_(pmlmepriv, 1);
  } else {

  }
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp___0 || (unsigned int )padapter->mlmepriv.to_roaming == 0U) {
    rtw_os_indicate_disconnect23a(padapter);
    tmp = msecs_to_jiffies(3000U);
    padapter->pwrctrlpriv.ips_deny_time = tmp + (unsigned long )jiffies;
    _clr_fwstate_(pmlmepriv, 1);
    rtw_clear_scan_deny(padapter);
  } else {

  }
  rtw_lps_ctrl_wk_cmd23a(padapter, 3, 1);
  return;
}
}
void rtw_scan_abort23a(struct rtw_adapter *adapter ) 
{ 
  unsigned long start ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  bool tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  pmlmeext = & adapter->mlmeextpriv;
  start = jiffies;
  pmlmeext->scan_abort = 1U;
  goto ldv_56025;
  ldv_56024: ;
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
    goto ldv_56022;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): fw_state = _FW_UNDER_SURVEY!\n", "rtw_scan_abort23a",
           (char *)(& (adapter->pnetdev)->name));
  } else {

  }
  msleep(20U);
  ldv_56025: 
  tmp = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp) {
    tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
    if (tmp___0 <= 200U) {
      goto ldv_56024;
    } else {
      goto ldv_56022;
    }
  } else {

  }
  ldv_56022: 
  tmp___2 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___2) {
    if (adapter->bDriverStopped == 0 && adapter->bSurpriseRemoved == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(%s): waiting for scan_abort time out!\n", "rtw_scan_abort23a",
               (char *)(& (adapter->pnetdev)->name));
      } else {

      }
    } else {

    }
    tmp___1 = wdev_priv(adapter->rtw_wdev);
    rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___1, 1);
  } else {

  }
  pmlmeext->scan_abort = 0U;
  return;
}
}
static struct sta_info *rtw_joinbss_update_stainfo(struct rtw_adapter *padapter ,
                                                   struct wlan_network *pnetwork ) 
{ 
  int i ;
  struct sta_info *bmc_sta ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_priv *pstapriv ;

  {
  pstapriv = & padapter->stapriv;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pnetwork->network.MacAddress));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    psta = rtw_alloc_stainfo23a(pstapriv, (u8 const   *)(& pnetwork->network.MacAddress),
                                32U);
  } else {

  }
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s\n", "rtw_joinbss_update_stainfo");
    } else {

    }
    psta->aid = (uint )pnetwork->join_res;
    psta->mac_id = 0U;
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
    if (padapter->securitypriv.dot11AuthAlgrthm == 2U) {
      padapter->securitypriv.binstallGrpkey = 0U;
      padapter->securitypriv.busetkipkey = 0U;
      psta->ieee8021x_blocked = 1U;
      psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
      memset((void *)(& psta->dot118021x_UncstKey), 0, 16UL);
      memset((void *)(& psta->dot11tkiprxmickey), 0, 16UL);
      memset((void *)(& psta->dot11tkiptxmickey), 0, 16UL);
      memset((void *)(& psta->dot11txpn), 0, 8UL);
      memset((void *)(& psta->dot11rxpn), 0, 8UL);
    } else {

    }
    if (padapter->securitypriv.wps_ie_len != 0) {
      psta->ieee8021x_blocked = 1U;
      padapter->securitypriv.wps_ie_len = 0;
    } else {

    }
    i = 0;
    goto ldv_56037;
    ldv_56036: 
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
    preorder_ctrl->enable = 0U;
    preorder_ctrl->indicate_seq = 65535U;
    preorder_ctrl->wend_b = 65535U;
    preorder_ctrl->wsize_b = 64U;
    i = i + 1;
    ldv_56037: ;
    if (i <= 15) {
      goto ldv_56036;
    } else {

    }
    bmc_sta = rtw_get_bcmc_stainfo23a(padapter);
    if ((unsigned long )bmc_sta != (unsigned long )((struct sta_info *)0)) {
      i = 0;
      goto ldv_56040;
      ldv_56039: 
      preorder_ctrl = (struct recv_reorder_ctrl *)(& bmc_sta->recvreorder_ctrl) + (unsigned long )i;
      preorder_ctrl->enable = 0U;
      preorder_ctrl->indicate_seq = 65535U;
      preorder_ctrl->wend_b = 65535U;
      preorder_ctrl->wsize_b = 64U;
      i = i + 1;
      ldv_56040: ;
      if (i <= 15) {
        goto ldv_56039;
      } else {

      }

    } else {

    }
    update_sta_info23a(padapter, psta);
  } else {

  }
  return (psta);
}
}
static void rtw_joinbss_update_network23a(struct rtw_adapter *padapter , struct wlan_network *ptarget_wlan ,
                                          struct wlan_network *pnetwork ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_joinbss_update_network23a");
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    tmp = get_fwstate(pmlmepriv);
    rt_trace(16, 7, "fw_state:%x, BSSID:%pM\n", tmp, (u8 *)(& pnetwork->network.MacAddress));
  } else {

  }
  memcpy((void *)(& cur_network->network), (void const   *)(& pnetwork->network),
           (size_t )pnetwork->network.Length);
  cur_network->network.IELength = ptarget_wlan->network.IELength;
  memcpy((void *)(& cur_network->network.IEs), (void const   *)(& ptarget_wlan->network.IEs),
           768UL);
  cur_network->network.capability = ptarget_wlan->network.capability;
  cur_network->network.beacon_interval = ptarget_wlan->network.beacon_interval;
  cur_network->network.tsf = ptarget_wlan->network.tsf;
  tmp___0 = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
  ldv_mod_timer_70(& padapter->recvpriv.signal_stat_timer, tmp___0 + (unsigned long )jiffies);
  padapter->recvpriv.signal_strength = ptarget_wlan->network.SignalStrength;
  padapter->recvpriv.signal_qual = ptarget_wlan->network.SignalQuality;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s signal_strength:%3u, signal_qual:%3u\n", "rtw_joinbss_update_network23a",
           (int )padapter->recvpriv.signal_strength, (int )padapter->recvpriv.signal_qual);
  } else {

  }
  tmp___1 = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
  ldv_mod_timer_71(& padapter->recvpriv.signal_stat_timer, tmp___1 + (unsigned long )jiffies);
  switch ((unsigned int )pnetwork->network.ifmode) {
  case 8U: ;
  case 2U: ;
  if ((pmlmepriv->fw_state & 256) != 0) {
    pmlmepriv->fw_state = 264;
  } else {
    pmlmepriv->fw_state = 8;
  }
  goto ldv_56052;
  case 1U: 
  pmlmepriv->fw_state = 32;
  goto ldv_56052;
  default: 
  pmlmepriv->fw_state = 0;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "Invalid network_mode\n");
  } else {

  }
  goto ldv_56052;
  }
  ldv_56052: 
  rtw_update_protection23a(padapter, (u8 *)(& cur_network->network.IEs), cur_network->network.IELength);
  rtw_update_ht_cap23a(padapter, (u8 *)(& cur_network->network.IEs), cur_network->network.IELength);
  return;
}
}
void rtw_joinbss_event_prehandle23a(struct rtw_adapter *adapter , u8 *pbuf ) 
{ 
  struct sta_info *ptarget_sta ;
  struct sta_info *pcur_sta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  struct wlan_network *cur_network ;
  struct wlan_network *pcur_wlan ;
  struct wlan_network *ptarget_wlan ;
  bool the_same_macaddr ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  unsigned long tmp___11 ;

  {
  pstapriv = & adapter->stapriv;
  pmlmepriv = & adapter->mlmepriv;
  pnetwork = (struct wlan_network *)pbuf;
  cur_network = & pmlmepriv->cur_network;
  ptarget_wlan = (struct wlan_network *)0;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "joinbss event call back received with res=%d\n", pnetwork->join_res);
  } else {

  }
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "@@@@@   joinbss event call back  for Any SSid\n");
    } else {

    }
  } else
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "@@@@@   rtw23a_joinbss_event_cb for SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
  tmp = ether_addr_equal((u8 const   *)(& pnetwork->network.MacAddress), (u8 const   *)(& cur_network->network.MacAddress));
  if ((int )tmp) {
    the_same_macaddr = 1;
  } else {
    the_same_macaddr = 0;
  }
  pnetwork->network.Length = get_wlan_bssid_ex_sz(& pnetwork->network);
  if (pnetwork->network.Length > 871U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "***joinbss_evt_callback return a wrong bss ***\n");
    } else {

    }
    return;
  } else {

  }
  spin_lock_bh(& pmlmepriv->lock);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "rtw23a_joinbss_event_cb !! _enter_critical\n");
  } else {

  }
  if (pnetwork->join_res > 0) {
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
    tmp___7 = check_fwstate(pmlmepriv, 128);
    if ((int )tmp___7) {
      tmp___2 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___2) {
        if ((int )the_same_macaddr) {
          ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
        } else {
          pcur_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
          if ((unsigned long )pcur_wlan != (unsigned long )((struct wlan_network *)0)) {
            pcur_wlan->fixed = 0;
          } else {

          }
          pcur_sta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->network.MacAddress));
          if ((unsigned long )pcur_sta != (unsigned long )((struct sta_info *)0)) {
            spin_lock_bh(& pstapriv->sta_hash_lock);
            rtw_free_stainfo23a(adapter, pcur_sta);
            spin_unlock_bh(& pstapriv->sta_hash_lock);
          } else {

          }
          ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->network.MacAddress));
          tmp___0 = check_fwstate(pmlmepriv, 8);
          if ((int )tmp___0) {
            if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
              ptarget_wlan->fixed = 1;
            } else {

            }
          } else {

          }
        }
      } else {
        ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->network.MacAddress));
        tmp___1 = check_fwstate(pmlmepriv, 8);
        if ((int )tmp___1) {
          if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
            ptarget_wlan->fixed = 1;
          } else {

          }
        } else {

        }
      }
      if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
        rtw_joinbss_update_network23a(adapter, ptarget_wlan, pnetwork);
      } else {
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(16, 4, "Can\'t find ptarget_wlan when joinbss_event callback\n");
        } else {

        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        goto ignore_joinbss_callback;
      }
      tmp___3 = check_fwstate(pmlmepriv, 8);
      if ((int )tmp___3) {
        ptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);
        if ((unsigned long )ptarget_sta == (unsigned long )((struct sta_info *)0)) {
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(16, 4, "Can\'t update stainfo when joinbss_event callback\n");
          } else {

          }
          spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
          goto ignore_joinbss_callback;
        } else {

        }
      } else {

      }
      tmp___5 = check_fwstate(pmlmepriv, 8);
      if ((int )tmp___5) {
        rtw_indicate_connect23a(adapter);
      } else
      if (GlobalDebugLevel23A > 6U) {
        tmp___4 = get_fwstate(pmlmepriv);
        rt_trace(16, 7, "adhoc mode, fw_state:%x\n", tmp___4);
      } else {

      }
      ldv_del_timer_sync_72(& pmlmepriv->assoc_timer);
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(16, 7, "Cancle assoc_timer\n");
      } else {

      }
    } else {
      if (GlobalDebugLevel23A > 3U) {
        tmp___6 = get_fwstate(pmlmepriv);
        rt_trace(16, 4, "rtw23a_joinbss_event_cb err: fw_state:%x\n", tmp___6);
      } else {

      }
      spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
      goto ignore_joinbss_callback;
    }
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  } else
  if (pnetwork->join_res == -4) {
    rtw_reset_securitypriv23a(adapter);
    tmp___8 = msecs_to_jiffies(1U);
    ldv_mod_timer_73(& pmlmepriv->assoc_timer, tmp___8 + (unsigned long )jiffies);
    tmp___10 = check_fwstate(pmlmepriv, 128);
    if ((int )tmp___10) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___9 = get_fwstate(pmlmepriv);
        rt_trace(16, 4, "fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", tmp___9);
      } else {

      }
      _clr_fwstate_(pmlmepriv, 128);
    } else {

    }
  } else {
    tmp___11 = msecs_to_jiffies(1U);
    ldv_mod_timer_74(& pmlmepriv->assoc_timer, tmp___11 + (unsigned long )jiffies);
    _clr_fwstate_(pmlmepriv, 128);
  }
  ignore_joinbss_callback: 
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
void rtw23a_joinbss_event_cb(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct wlan_network *pnetwork ;

  {
  pnetwork = (struct wlan_network *)pbuf;
  mlmeext_joinbss_event_callback23a(adapter, pnetwork->join_res);
  rtw_os_xmit_schedule23a(adapter);
  return;
}
}
void rtw_stassoc_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct sta_info *psta ;
  struct mlme_priv *pmlmepriv ;
  struct stassoc_event *pstassoc ;
  struct wlan_network *cur_network ;
  struct wlan_network *ptarget_wlan ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  pstassoc = (struct stassoc_event *)pbuf;
  cur_network = & pmlmepriv->cur_network;
  tmp = rtw_access_ctrl23a(adapter, (u8 *)(& pstassoc->macaddr));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___1) {
    psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstassoc->macaddr));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      ap_sta_info_defer_update23a(adapter, psta);
    } else {

    }
    return;
  } else {

  }
  psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstassoc->macaddr));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "Error: rtw_stassoc_event_callback23a: sta has been in sta_hash_queue\n");
    } else {

    }
    return;
  } else {

  }
  psta = rtw_alloc_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstassoc->macaddr),
                              208U);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "Can\'t alloc sta_info when rtw_stassoc_event_callback23a\n");
    } else {

    }
    return;
  } else {

  }
  psta->qos_option = 0U;
  psta->mac_id = (unsigned int )pstassoc->cam_id;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_stassoc_event_callback23a");
  } else {

  }
  rtl8723a_SetHalODMVar(adapter, 0, (void *)psta, 1);
  if (adapter->securitypriv.dot11AuthAlgrthm == 2U) {
    psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
  } else {

  }
  psta->ieee8021x_blocked = 0U;
  spin_lock_bh(& pmlmepriv->lock);
  tmp___2 = check_fwstate(pmlmepriv, 64);
  if ((int )tmp___2) {
    goto _L;
  } else {
    tmp___3 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___3) {
      _L: /* CIL Label */ 
      if (adapter->stapriv.asoc_sta_count == 2) {
        spin_lock_bh(& pmlmepriv->scanned_queue.lock);
        ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
        if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
          ptarget_wlan->fixed = 1;
        } else {

        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        rtw_indicate_connect23a(adapter);
      } else {

      }
    } else {

    }
  }
  spin_unlock_bh(& pmlmepriv->lock);
  mlmeext_sta_add_event_callback23a(adapter, psta);
  return;
}
}
void rtw_stadel_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  int mac_id ;
  struct sta_info *psta ;
  struct wlan_network *pwlan ;
  struct wlan_bssid_ex *pdev_network ;
  struct mlme_priv *pmlmepriv ;
  struct stadel_event *pstadel ;
  struct sta_priv *pstapriv ;
  struct wlan_network *tgt_network ;
  bool tmp ;
  bool tmp___0 ;
  uint tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  pstadel = (struct stadel_event *)pbuf;
  pstapriv = & adapter->stapriv;
  tgt_network = & pmlmepriv->cur_network;
  psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstadel->macaddr));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    mac_id = (int )psta->mac_id;
  } else {
    mac_id = pstadel->mac_id;
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(mac_id=%d)=%pM\n", "rtw_stadel_event_callback23a", mac_id,
           (unsigned char *)(& pstadel->macaddr));
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    return;
  } else {

  }
  mlmeext_sta_del_event_callback23a(adapter);
  spin_lock_bh(& pmlmepriv->lock);
  tmp___0 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___0) {
    if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
      pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
    } else
    if ((unsigned int )adapter->mlmepriv.to_roaming == 0U) {
      rtw_set_roaming(adapter, (int )adapter->registrypriv.max_roaming_times);
    } else {

    }
    if ((unsigned int )*((u16 *)(& pstadel->rsvd)) != 65535U) {
      rtw_set_roaming(adapter, 0);
    } else {

    }
    rtw_free_uc_swdec_pending_queue23a(adapter);
    rtw_free_assoc_resources23a(adapter, 1);
    rtw_indicate_disconnect23a(adapter);
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
    pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
    if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
      pwlan->fixed = 0;
      rtw_free_network_nolock(pmlmepriv, pwlan);
    } else {

    }
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
    _rtw_roaming(adapter, tgt_network);
  } else {

  }
  tmp___2 = check_fwstate(pmlmepriv, 64);
  if ((int )tmp___2) {
    goto _L;
  } else {
    tmp___3 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___3) {
      _L: /* CIL Label */ 
      spin_lock_bh(& pstapriv->sta_hash_lock);
      rtw_free_stainfo23a(adapter, psta);
      spin_unlock_bh(& pstapriv->sta_hash_lock);
      if (adapter->stapriv.asoc_sta_count == 1) {
        spin_lock_bh(& pmlmepriv->scanned_queue.lock);
        pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
        if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
          pwlan->fixed = 0;
          rtw_free_network_nolock(pmlmepriv, pwlan);
        } else {

        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        pdev_network = & adapter->registrypriv.dev_network;
        tmp___1 = get_wlan_bssid_ex_sz(& tgt_network->network);
        memcpy((void *)pdev_network, (void const   *)(& tgt_network->network), (size_t )tmp___1);
        rtw_do_join_adhoc(adapter);
      } else {

      }
    } else {

    }
  }
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
void rtw23a_join_to_handler(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  int do_join_r ;
  int tmp ;

  {
  adapter = (struct rtw_adapter *)data;
  pmlmepriv = & adapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    tmp = get_fwstate(pmlmepriv);
    printk("\016RTL8723AU: %s, fw_state=%x\n", "rtw23a_join_to_handler", tmp);
  } else {

  }
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
    return;
  } else {

  }
  spin_lock_bh(& pmlmepriv->lock);
  if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
    ldv_56106: 
    pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
    if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s try another roaming\n", "rtw23a_join_to_handler");
      } else {

      }
      do_join_r = rtw_do_join(adapter);
      if (do_join_r != 1) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s roaming do_join return %d\n", "rtw23a_join_to_handler",
                 do_join_r);
        } else {

        }
        goto ldv_56104;
      } else {

      }
      goto ldv_56105;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s We\'ve try roaming but fail\n", "rtw23a_join_to_handler");
      } else {

      }
      rtw_indicate_disconnect23a(adapter);
      goto ldv_56105;
    }
    ldv_56104: ;
    goto ldv_56106;
    ldv_56105: ;
  } else {
    rtw_indicate_disconnect23a(adapter);
    free_scanqueue(pmlmepriv);
    rtw_cfg80211_indicate_disconnect(adapter);
  }
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
void rtw_scan_timeout_handler23a(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  int tmp ;
  void *tmp___0 ;

  {
  adapter = (struct rtw_adapter *)data;
  pmlmepriv = & adapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    tmp = get_fwstate(pmlmepriv);
    printk("\016RTL8723AU: %s(%s): fw_state =%x\n", "rtw_scan_timeout_handler23a",
           (char *)(& (adapter->pnetdev)->name), tmp);
  } else {

  }
  spin_lock_bh(& pmlmepriv->lock);
  _clr_fwstate_(pmlmepriv, 2048);
  spin_unlock_bh(& pmlmepriv->lock);
  tmp___0 = wdev_priv(adapter->rtw_wdev);
  rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___0, 1);
  return;
}
}
void rtw_dynamic_check_timer_handler(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  unsigned long tmp ;

  {
  adapter = (struct rtw_adapter *)data;
  if ((unsigned int )adapter->hw_init_completed == 0U) {
    goto out;
  } else {

  }
  if (adapter->bDriverStopped == 1 || adapter->bSurpriseRemoved == 1) {
    goto out;
  } else {

  }
  if (adapter->net_closed == 1) {
    goto out;
  } else {

  }
  rtw_dynamic_chk_wk_cmd23a(adapter);
  out: 
  tmp = msecs_to_jiffies(2000U);
  ldv_mod_timer_75(& adapter->mlmepriv.dynamic_chk_timer, tmp + (unsigned long )jiffies);
  return;
}
}
void rtw_clear_scan_deny(struct rtw_adapter *adapter ) 
{ 
  struct mlme_priv *mlmepriv ;

  {
  mlmepriv = & adapter->mlmepriv;
  atomic_set(& mlmepriv->set_scan_deny, 0);
  return;
}
}
void rtw_set_scan_deny_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;

  {
  adapter = (struct rtw_adapter *)data;
  rtw_clear_scan_deny(adapter);
  return;
}
}
void rtw_set_scan_deny(struct rtw_adapter *adapter , u32 ms ) 
{ 
  struct mlme_priv *mlmepriv ;
  unsigned long tmp ;

  {
  mlmepriv = & adapter->mlmepriv;
  atomic_set(& mlmepriv->set_scan_deny, 1);
  tmp = msecs_to_jiffies(ms);
  ldv_mod_timer_76(& mlmepriv->set_scan_deny_timer, tmp + (unsigned long )jiffies);
  return;
}
}
static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv , struct wlan_network **candidate ,
                                    struct wlan_network *competitor ) 
{ 
  int updated ;
  struct rtw_adapter *adapter ;
  struct mlme_priv  const  *__mptr ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int passed ;
  int tmp___3 ;

  {
  updated = 0;
  __mptr = (struct mlme_priv  const  *)pmlmepriv;
  adapter = (struct rtw_adapter *)__mptr + 0xffffffffffffffe0UL;
  if (pmlmepriv->assoc_by_bssid == 1U) {
    tmp = ether_addr_equal((u8 const   *)(& competitor->network.MacAddress), (u8 const   *)(& pmlmepriv->assoc_bssid));
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      goto exit;
    } else {

    }
  } else {

  }
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len != 0U) {
    if ((int )competitor->network.Ssid.ssid_len != (int )pmlmepriv->assoc_ssid.ssid_len) {
      goto exit;
    } else {
      tmp___1 = memcmp((void const   *)(& competitor->network.Ssid.ssid), (void const   *)(& pmlmepriv->assoc_ssid.ssid),
                       (size_t )pmlmepriv->assoc_ssid.ssid_len);
      if (tmp___1 != 0) {
        goto exit;
      } else {

      }
    }
  } else {

  }
  tmp___2 = rtw_is_desired_network(adapter, competitor);
  if (tmp___2 == 0) {
    goto exit;
  } else {

  }
  if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
    passed = jiffies_to_msecs((unsigned long )jiffies - competitor->last_scanned);
    if (passed > 1999U) {
      goto exit;
    } else {
      tmp___3 = is_same_ess(& competitor->network, & pmlmepriv->cur_network.network);
      if (tmp___3 == 0) {
        goto exit;
      } else {

      }
    }
  } else {

  }
  if ((unsigned long )*candidate == (unsigned long )((struct wlan_network *)0) || (*candidate)->network.Rssi < competitor->network.Rssi) {
    *candidate = competitor;
    updated = 1;
  } else {

  }
  if (updated != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: [by_bssid:%u][assoc_ssid:%s][to_roaming:%u] new candidate: %s(%pM) rssi:%d\n",
             pmlmepriv->assoc_by_bssid, (u8 *)(& pmlmepriv->assoc_ssid.ssid), (int )adapter->mlmepriv.to_roaming,
             (u8 *)(& (*candidate)->network.Ssid.ssid), (u8 *)(& (*candidate)->network.MacAddress),
             (int )(*candidate)->network.Rssi);
    } else {

    }
  } else {

  }
  exit: ;
  return (updated);
}
}
static int rtw_do_join(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  int ret ;
  bool tmp ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmepriv->cur_network.join_res = -2;
  set_fwstate(pmlmepriv, 128);
  pmlmepriv->to_join = 1U;
  ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
  if (ret == 1) {
    pmlmepriv->to_join = 0U;
  } else {
    tmp = check_fwstate(pmlmepriv, 32);
    if ((int )tmp) {
      ret = rtw_do_join_adhoc(padapter);
      if (ret != 1) {
        goto exit;
      } else {

      }
    } else {
      _clr_fwstate_(pmlmepriv, 128);
      ret = 0;
      pmlmepriv->to_join = 0U;
    }
  }
  exit: ;
  return (ret);
}
}
static struct wlan_network *rtw_select_candidate_from_queue(struct mlme_priv *pmlmepriv ) 
{ 
  struct wlan_network *pnetwork ;
  struct wlan_network *candidate ;
  struct rtw_queue *queue ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;

  {
  candidate = (struct wlan_network *)0;
  queue = & pmlmepriv->scanned_queue;
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  phead = get_list_head(queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_56166;
  ldv_56165: 
  __mptr = (struct list_head  const  *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "%s: return _FAIL:(pnetwork == NULL)\n", "rtw_select_candidate_from_queue");
    } else {

    }
    goto exit;
  } else {

  }
  rtw_check_join_candidate(pmlmepriv, & candidate, pnetwork);
  plist = ptmp;
  ptmp = plist->next;
  ldv_56166: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_56165;
  } else {

  }

  exit: 
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  return (candidate);
}
}
int rtw_do_join_adhoc(struct rtw_adapter *adapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *ibss ;
  int ret ;

  {
  pmlmepriv = & adapter->mlmepriv;
  pdev_network = & adapter->registrypriv.dev_network;
  ibss = (u8 *)(& adapter->registrypriv.dev_network.MacAddress);
  _clr_fwstate_(pmlmepriv, 2048);
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "switching to adhoc master\n");
  } else {

  }
  memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pmlmepriv->assoc_ssid),
           33UL);
  rtw_update_registrypriv_dev_network23a(adapter);
  rtw_generate_random_ibss23a(ibss);
  pmlmepriv->fw_state = 64;
  ret = rtw_createbss_cmd23a(adapter);
  if (ret != 1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "Error =>rtw_createbss_cmd23a status FAIL\n");
    } else {

    }
  } else {
    pmlmepriv->to_join = 0U;
  }
  return (ret);
}
}
int rtw_do_join_network(struct rtw_adapter *adapter , struct wlan_network *candidate ) 
{ 
  int ret ;
  bool tmp ;
  unsigned long tmp___0 ;

  {
  tmp = check_fwstate(& adapter->mlmepriv, 1);
  if ((int )tmp) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: _FW_LINKED while ask_for_joinbss!\n", "rtw_do_join_network");
    } else {

    }
    rtw_disassoc_cmd23a(adapter, 0U, 1);
    rtw_indicate_disconnect23a(adapter);
    rtw_free_assoc_resources23a(adapter, 0);
  } else {

  }
  set_fwstate(& adapter->mlmepriv, 128);
  ret = rtw_joinbss_cmd23a(adapter, candidate);
  if (ret == 1) {
    tmp___0 = msecs_to_jiffies(6500U);
    ldv_mod_timer_77(& adapter->mlmepriv.assoc_timer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
  return (ret);
}
}
int rtw_select_and_join_from_scanned_queue23a(struct mlme_priv *pmlmepriv ) 
{ 
  struct rtw_adapter *adapter ;
  struct wlan_network *candidate ;
  int ret ;

  {
  candidate = (struct wlan_network *)0;
  adapter = pmlmepriv->nic_hdl;
  candidate = rtw_select_candidate_from_queue(pmlmepriv);
  if ((unsigned long )candidate == (unsigned long )((struct wlan_network *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: return _FAIL(candidate == NULL)\n", "rtw_select_and_join_from_scanned_queue23a");
    } else {

    }
    ret = 0;
    goto exit;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: candidate: %s(%pM, ch:%u)\n", "rtw_select_and_join_from_scanned_queue23a",
           (u8 *)(& candidate->network.Ssid.ssid), (u8 *)(& candidate->network.MacAddress),
           candidate->network.DSConfig);
  } else {

  }
  ret = rtw_do_join_network(adapter, candidate);
  exit: ;
  return (ret);
}
}
int rtw_set_auth23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ) 
{ 
  struct cmd_obj *pcmd ;
  struct setauth_parm *psetauthparm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & adapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 208U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(4UL, 208U);
  psetauthparm = (struct setauth_parm *)tmp___0;
  if ((unsigned long )psetauthparm == (unsigned long )((struct setauth_parm *)0)) {
    kfree((void const   *)pcmd);
    res = 0;
    goto exit;
  } else {

  }
  psetauthparm->mode = (unsigned char )psecuritypriv->dot11AuthAlgrthm;
  pcmd->cmdcode = 19U;
  pcmd->parmbuf = (u8 *)psetauthparm;
  pcmd->cmdsz = 4U;
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "after enqueue set_auth_cmd, auth_mode=%x\n", psecuritypriv->dot11AuthAlgrthm);
  } else {

  }
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
  return (res);
}
}
int rtw_set_key23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ,
                   int keyid , u8 set_tx ) 
{ 
  u8 keylen ;
  struct cmd_obj *pcmd ;
  struct setkey_parm *psetkeyparm ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & adapter->cmdpriv;
  pmlmepriv = & adapter->mlmepriv;
  res = 1;
  if (keyid > 3) {
    res = 0;
    goto exit;
  } else {

  }
  tmp = kzalloc(128UL, 208U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(24UL, 208U);
  psetkeyparm = (struct setkey_parm *)tmp___0;
  if ((unsigned long )psetkeyparm == (unsigned long )((struct setkey_parm *)0)) {
    kfree((void const   *)pcmd);
    res = 0;
    goto exit;
  } else {

  }
  if (psecuritypriv->dot11AuthAlgrthm == 2U) {
    psetkeyparm->algorithm = (u32 )((unsigned char )psecuritypriv->dot118021XGrpPrivacy);
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "rtw_set_key23a: psetkeyparm->algorithm = (unsigned char)psecuritypriv->dot118021XGrpPrivacy =%d\n",
               psetkeyparm->algorithm);
    } else {

    }
  } else {
    psetkeyparm->algorithm = (u32 )((unsigned char )psecuritypriv->dot11PrivacyAlgrthm);
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "rtw_set_key23a: psetkeyparm->algorithm = (u8)psecuritypriv->dot11PrivacyAlgrthm =%d\n",
               psetkeyparm->algorithm);
    } else {

    }
  }
  psetkeyparm->keyid = (u8 )keyid;
  psetkeyparm->set_tx = set_tx;
  if (psetkeyparm->algorithm == 1027073U || psetkeyparm->algorithm == 1027077U) {
    pmlmepriv->key_mask = (int )pmlmepriv->key_mask | (int )((u8 )(1UL << (int )psetkeyparm->keyid));
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ==> rtw_set_key23a algorithm(%x), keyid(%x), key_mask(%x)\n",
           psetkeyparm->algorithm, (int )psetkeyparm->keyid, (int )pmlmepriv->key_mask);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "rtw_set_key23a: psetkeyparm->algorithm =%d psetkeyparm->keyid = (u8)keyid =%d\n",
             psetkeyparm->algorithm, keyid);
  } else {

  }
  switch (psetkeyparm->algorithm) {
  case 1027073U: 
  keylen = 5U;
  memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->wep_key[keyid].key),
           (size_t )keylen);
  goto ldv_56212;
  case 1027077U: 
  keylen = 13U;
  memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->wep_key[keyid].key),
           (size_t )keylen);
  goto ldv_56212;
  case 1027074U: 
  keylen = 16U;
  memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->dot118021XGrpKey) + (unsigned long )keyid,
           (size_t )keylen);
  psetkeyparm->grpkey = 1U;
  goto ldv_56212;
  case 1027076U: 
  keylen = 16U;
  memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->dot118021XGrpKey) + (unsigned long )keyid,
           (size_t )keylen);
  psetkeyparm->grpkey = 1U;
  goto ldv_56212;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16, 4, "rtw_set_key23a:psecuritypriv->dot11PrivacyAlgrthm = %x (must be 1 or 2 or 4 or 5)\n",
             psecuritypriv->dot11PrivacyAlgrthm);
  } else {

  }
  res = 0;
  kfree((void const   *)pcmd);
  kfree((void const   *)psetkeyparm);
  goto exit;
  }
  ldv_56212: 
  pcmd->cmdcode = 20U;
  pcmd->parmbuf = (u8 *)psetkeyparm;
  pcmd->cmdsz = 24U;
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
  return (res);
}
}
int rtw_restruct_wmm_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len , uint initial_out_len ) 
{ 
  int ielength ;
  u8 const   *p ;

  {
  ielength = (int )initial_out_len;
  p = cfg80211_find_vendor_ie(20722U, 2, (u8 const   *)in_ie, (int )in_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    memcpy((void *)out_ie + (unsigned long )initial_out_len, (void const   *)p,
             9UL);
    *(out_ie + (unsigned long )(initial_out_len + 1U)) = 7U;
    *(out_ie + (unsigned long )(initial_out_len + 6U)) = 0U;
    *(out_ie + (unsigned long )(initial_out_len + 8U)) = 0U;
    ielength = ielength + 9;
  } else {

  }
  return (ielength);
}
}
static int SecIsInPMKIDList(struct rtw_adapter *Adapter , u8 *bssid ) 
{ 
  struct security_priv *psecuritypriv ;
  int i ;
  bool tmp ;

  {
  psecuritypriv = & Adapter->securitypriv;
  i = 0;
  ldv_56233: ;
  if ((unsigned int )psecuritypriv->PMKIDList[i].bUsed != 0U) {
    tmp = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[i].Bssid), (u8 const   *)bssid);
    if ((int )tmp) {
      goto ldv_56232;
    } else {
      i = i + 1;
    }
  } else {
    i = i + 1;
  }
  if (i <= 15) {
    goto ldv_56233;
  } else {

  }
  ldv_56232: ;
  if (i == 16) {
    i = -1;
  } else {

  }
  return (i);
}
}
static int rtw_append_pmkid(struct rtw_adapter *Adapter , int iEntry , u8 *ie , uint ie_len ) 
{ 
  struct security_priv *psecuritypriv ;

  {
  psecuritypriv = & Adapter->securitypriv;
  if ((unsigned int )*(ie + 1UL) <= 20U) {
    *(ie + (unsigned long )ie_len) = 1U;
    ie_len = ie_len + 1U;
    *(ie + (unsigned long )ie_len) = 0U;
    ie_len = ie_len + 1U;
    memcpy((void *)ie + (unsigned long )ie_len, (void const   *)(& psecuritypriv->PMKIDList[iEntry].PMKID),
             16UL);
    ie_len = ie_len + 16U;
    *(ie + 1UL) = (unsigned int )*(ie + 1UL) + 18U;
  } else {

  }
  return ((int )ie_len);
}
}
int rtw_restruct_sec_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len ) 
{ 
  u8 authmode ;
  uint ielength ;
  int iEntry ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  uint ndisauthmode ;
  uint ndissecuritytype ;
  bool tmp ;
  int tmp___0 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  psecuritypriv = & adapter->securitypriv;
  ndisauthmode = psecuritypriv->ndisauthtype;
  ndissecuritytype = psecuritypriv->ndisencryptstatus;
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(16, 6, "+rtw_restruct_sec_ie23a: ndisauthmode=%d ndissecuritytype=%d\n",
             ndisauthmode, ndissecuritytype);
  } else {

  }
  ielength = 0U;
  if (ndisauthmode == 3U || ndisauthmode == 4U) {
    authmode = 221U;
  } else {

  }
  if (ndisauthmode == 6U || ndisauthmode == 7U) {
    authmode = 48U;
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 256);
  if ((int )tmp) {
    memcpy((void *)out_ie + (unsigned long )ielength, (void const   *)(& psecuritypriv->wps_ie),
             (size_t )psecuritypriv->wps_ie_len);
    ielength = (uint )psecuritypriv->wps_ie_len + ielength;
  } else
  if ((unsigned int )authmode == 221U || (unsigned int )authmode == 48U) {
    memcpy((void *)out_ie + (unsigned long )ielength, (void const   *)(& psecuritypriv->supplicant_ie),
             (size_t )((int )psecuritypriv->supplicant_ie[1] + 2));
    ielength = ((uint )psecuritypriv->supplicant_ie[1] + ielength) + 2U;
  } else {

  }
  iEntry = SecIsInPMKIDList(adapter, (u8 *)(& pmlmepriv->assoc_bssid));
  if (iEntry < 0) {
    return ((int )ielength);
  } else
  if ((unsigned int )authmode == 48U) {
    tmp___0 = rtw_append_pmkid(adapter, iEntry, out_ie, ielength);
    ielength = (uint )tmp___0;
  } else {

  }
  return ((int )ielength);
}
}
void rtw_init_registrypriv_dev_network23a(struct rtw_adapter *adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct eeprom_priv *peepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *myhwaddr ;
  u8 *tmp ;

  {
  pregistrypriv = & adapter->registrypriv;
  peepriv = & adapter->eeprompriv;
  pdev_network = & pregistrypriv->dev_network;
  tmp = myid(peepriv);
  myhwaddr = tmp;
  ether_addr_copy((u8 *)(& pdev_network->MacAddress), (u8 const   *)myhwaddr);
  memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pregistrypriv->ssid),
           33UL);
  pdev_network->beacon_interval = 100U;
  return;
}
}
void rtw_update_registrypriv_dev_network23a(struct rtw_adapter *adapter ) 
{ 
  int sz ;
  struct registry_priv *pregistrypriv ;
  struct wlan_bssid_ex *pdev_network ;
  struct security_priv *psecuritypriv ;
  struct wlan_network *cur_network ;

  {
  sz = 0;
  pregistrypriv = & adapter->registrypriv;
  pdev_network = & pregistrypriv->dev_network;
  psecuritypriv = & adapter->securitypriv;
  cur_network = & adapter->mlmepriv.cur_network;
  pdev_network->Privacy = psecuritypriv->dot11PrivacyAlgrthm != 0U;
  pdev_network->Rssi = 0L;
  pdev_network->DSConfig = (u32 )pregistrypriv->channel;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "pregistrypriv->channel =%d, pdev_network->DSConfig = 0x%x\n",
             (int )pregistrypriv->channel, pdev_network->DSConfig);
  } else {

  }
  if ((unsigned int )cur_network->network.ifmode == 1U) {
    pdev_network->ATIMWindow = 0U;
  } else {

  }
  pdev_network->ifmode = cur_network->network.ifmode;
  sz = rtw_generate_ie23a(pregistrypriv);
  pdev_network->IELength = (u32 )sz;
  pdev_network->Length = get_wlan_bssid_ex_sz(pdev_network);
  return;
}
}
void rtw_joinbss_reset23a(struct rtw_adapter *padapter ) 
{ 
  u8 threshold ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;

  {
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  pmlmepriv->num_FortyMHzIntolerant = 0;
  pmlmepriv->num_sta_no_ht = 0;
  phtpriv->ampdu_enable = 0;
  if ((int )phtpriv->ht_option) {
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
      threshold = 1U;
    } else {
      threshold = 0U;
    }
  } else {
    threshold = 1U;
  }
  rtl8723a_set_rxdma_agg_pg_th(padapter, (int )threshold);
  return;
}
}
bool rtw_restructure_ht_ie23a(struct rtw_adapter *padapter , u8 *in_ie , u8 *out_ie ,
                              uint in_len , uint *pout_len ) 
{ 
  u32 out_len ;
  int max_rx_ampdu_factor ;
  unsigned char *pframe ;
  u8 const   *p ;
  struct ieee80211_ht_cap ht_capie ;
  u8 WMM_IE[7U] ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  u32 rx_packet_offset ;
  u32 max_recvbuf_sz ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;

  {
  WMM_IE[0] = 0U;
  WMM_IE[1] = 80U;
  WMM_IE[2] = 242U;
  WMM_IE[3] = 2U;
  WMM_IE[4] = 0U;
  WMM_IE[5] = 1U;
  WMM_IE[6] = 0U;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  phtpriv->ht_option = 0;
  p = cfg80211_find_ie(45, (u8 const   *)in_ie, (int )in_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    if (pmlmepriv->qos_option == 0U) {
      out_len = *pout_len;
      tmp = rtw_set_ie23a(out_ie + (unsigned long )out_len, 221, 7U, (u8 const   *)(& WMM_IE),
                          pout_len);
      pframe = tmp;
      pmlmepriv->qos_option = 1U;
    } else {

    }
    out_len = *pout_len;
    memset((void *)(& ht_capie), 0, 26UL);
    ht_capie.cap_info = 4322U;
    GetHalDefVar8192CUsb(padapter, 5, (void *)(& rx_packet_offset));
    GetHalDefVar8192CUsb(padapter, 4, (void *)(& max_recvbuf_sz));
    GetHalDefVar8192CUsb(padapter, 11, (void *)(& max_rx_ampdu_factor));
    ht_capie.ampdu_params_info = (unsigned int )((u8 )max_rx_ampdu_factor) & 3U;
    if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
      ht_capie.ampdu_params_info = (u8 )((unsigned int )ht_capie.ampdu_params_info | 28U);
    } else {
      ht_capie.ampdu_params_info = ht_capie.ampdu_params_info;
    }
    tmp___0 = rtw_set_ie23a(out_ie + (unsigned long )out_len, 45, 26U, (u8 const   *)(& ht_capie),
                            pout_len);
    pframe = tmp___0;
    phtpriv->ht_option = 1;
    p = cfg80211_find_ie(61, (u8 const   *)in_ie, (int )in_len);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) == 22U) {
      out_len = *pout_len;
      tmp___1 = rtw_set_ie23a(out_ie + (unsigned long )out_len, 61, (uint )*(p + 1UL),
                              p + 2UL, pout_len);
      pframe = tmp___1;
    } else {

    }
  } else {

  }
  return (phtpriv->ht_option);
}
}
void rtw_update_ht_cap23a(struct rtw_adapter *padapter , u8 *pie , uint ie_len ) 
{ 
  u8 max_ampdu_sz ;
  u8 const   *p ;
  struct ieee80211_ht_cap *pht_capie ;
  struct ieee80211_ht_operation *pht_addtinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int i ;
  u8 rf_type ;

  {
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  pregistrypriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (! phtpriv->ht_option) {
    return;
  } else {

  }
  if ((unsigned int )pmlmeinfo->HT_info_enable == 0U || (unsigned int )pmlmeinfo->HT_caps_enable == 0U) {
    return;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +rtw_update_ht_cap23a()\n");
  } else {

  }
  if (! phtpriv->ampdu_enable && (unsigned int )pregistrypriv->ampdu_enable == 1U) {
    if ((unsigned int )pregistrypriv->wifi_spec == 1U) {
      phtpriv->ampdu_enable = 0;
    } else {
      phtpriv->ampdu_enable = 1;
    }
  } else
  if ((unsigned int )pregistrypriv->ampdu_enable == 2U) {
    phtpriv->ampdu_enable = 1;
  } else {

  }
  p = cfg80211_find_ie(45, (u8 const   *)pie, (int )ie_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_capie = (struct ieee80211_ht_cap *)p + 2U;
    max_ampdu_sz = (unsigned int )pht_capie->ampdu_params_info & 3U;
    max_ampdu_sz = (u8 )(1 << ((int )max_ampdu_sz + 3));
    phtpriv->rx_ampdu_maxlen = (u32 )max_ampdu_sz;
  } else {

  }
  p = cfg80211_find_ie(61, (u8 const   *)pie, (int )ie_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_addtinfo = (struct ieee80211_ht_operation *)p + 2U;
  } else {

  }
  if (((unsigned int )pregistrypriv->cbw40_enable != 0U && ((int )pmlmeinfo->ht_cap.cap_info & 2) != 0) && ((int )pmlmeinfo->HT_info.ht_param & 4) != 0) {
    rf_type = rtl8723a_get_rf_type(padapter);
    i = 0;
    goto ldv_56309;
    ldv_56308: ;
    if ((unsigned int )rf_type == 3U || (unsigned int )rf_type == 0U) {
      pmlmeinfo->ht_cap.mcs.rx_mask[i] = (u8 )((int )pmlmeinfo->ht_cap.mcs.rx_mask[i] & (int )MCS_rate_1R23A[i]);
    } else {
      pmlmeinfo->ht_cap.mcs.rx_mask[i] = (u8 )((int )pmlmeinfo->ht_cap.mcs.rx_mask[i] & (int )MCS_rate_2R23A[i]);
    }
    i = i + 1;
    ldv_56309: ;
    if (i <= 9) {
      goto ldv_56308;
    } else {

    }
    pmlmeext->cur_bwmode = 1U;
    switch ((int )pmlmeinfo->HT_info.ht_param & 3) {
    case 1: 
    pmlmeext->cur_ch_offset = 1U;
    goto ldv_56312;
    case 3: 
    pmlmeext->cur_ch_offset = 2U;
    goto ldv_56312;
    default: 
    pmlmeext->cur_ch_offset = 0U;
    goto ldv_56312;
    }
    ldv_56312: ;
  } else {

  }
  pmlmeinfo->SM_PS = (u8 )(((int )pmlmeinfo->ht_cap.cap_info & 12) >> 2);
  if ((unsigned int )pmlmeinfo->SM_PS == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): WLAN_HT_CAP_SM_PS_STATIC\n", "rtw_update_ht_cap23a");
    } else {

    }
  } else {

  }
  pmlmeinfo->HT_protection = (unsigned int )((u8 )pmlmeinfo->HT_info.operation_mode) & 3U;
  return;
}
}
void rtw_issue_addbareq_cmd23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u8 issued ;
  int priority ;
  struct sta_info *psta ;
  struct ht_priv *phtpriv ;
  struct pkt_attrib *pattrib ;
  s32 bmcst ;
  bool tmp ;

  {
  pattrib = & pxmitframe->attrib;
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  bmcst = (s32 )tmp;
  if (bmcst != 0 || padapter->mlmepriv.LinkDetectInfo.NumTxOkInPeriod <= 99U) {
    return;
  } else {

  }
  priority = (int )pattrib->priority;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_issue_addbareq_cmd23a");
    } else {

    }
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_issue_addbareq_cmd23a");
    } else {

    }
    return;
  } else {

  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_issue_addbareq_cmd23a",
             psta->state);
    } else {

    }
    return;
  } else {

  }
  phtpriv = & psta->htpriv;
  if ((int )phtpriv->ht_option && (int )phtpriv->ampdu_enable) {
    issued = (unsigned int )((u8 )((int )phtpriv->agg_enable_bitmap >> priority)) & 1U;
    issued = (u8 )(((int )((signed char )((int )phtpriv->candidate_tid_bitmap >> priority)) & 1) | (int )((signed char )issued));
    if ((unsigned int )issued == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: rtw_issue_addbareq_cmd23a, p =%d\n", priority);
      } else {

      }
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap | (int )((u16 )(1UL << priority));
      rtw_addbareq_cmd23a(padapter, (int )((unsigned char )priority), (u8 *)(& pattrib->ra));
    } else {

    }
  } else {

  }
  return;
}
}
int rtw_linked_check(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  tmp___0 = check_fwstate(& padapter->mlmepriv, 16);
  if ((int )tmp___0) {
    goto _L;
  } else {
    tmp___1 = check_fwstate(& padapter->mlmepriv, 96);
    if ((int )tmp___1) {
      _L: /* CIL Label */ 
      if (padapter->stapriv.asoc_sta_count > 2) {
        return (1);
      } else {

      }
    } else {
      tmp = check_fwstate(& padapter->mlmepriv, 1);
      if ((int )tmp) {
        return (1);
      } else {

      }
    }
  }
  return (0);
}
}
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_6_0 == 0 || ldv_timer_6_0 == 2) {
    ldv_timer_list_6_0 = timer;
    ldv_timer_list_6_0->data = data;
    ldv_timer_6_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_6_1 == 0 || ldv_timer_6_1 == 2) {
    ldv_timer_list_6_1 = timer;
    ldv_timer_list_6_1->data = data;
    ldv_timer_6_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_6_2 == 0 || ldv_timer_6_2 == 2) {
    ldv_timer_list_6_2 = timer;
    ldv_timer_list_6_2->data = data;
    ldv_timer_6_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_6_3 == 0 || ldv_timer_6_3 == 2) {
    ldv_timer_list_6_3 = timer;
    ldv_timer_list_6_3->data = data;
    ldv_timer_6_3 = 1;
    return;
  } else {

  }
  return;
}
}
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& rtw_set_scan_deny_timer_hdl)) {
    activate_suitable_timer_7(timer, data);
  } else {

  }
  return (0);
}
}
void ldv_timer_5(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  rtw_scan_timeout_handler23a(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void choose_timer_5(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_5_0 == 1) {
    ldv_timer_5_0 = 2;
    ldv_timer_5(ldv_timer_5_0, ldv_timer_list_5_0);
  } else {

  }
  goto ldv_56348;
  case 1: ;
  if (ldv_timer_5_1 == 1) {
    ldv_timer_5_1 = 2;
    ldv_timer_5(ldv_timer_5_1, ldv_timer_list_5_1);
  } else {

  }
  goto ldv_56348;
  case 2: ;
  if (ldv_timer_5_2 == 1) {
    ldv_timer_5_2 = 2;
    ldv_timer_5(ldv_timer_5_2, ldv_timer_list_5_2);
  } else {

  }
  goto ldv_56348;
  case 3: ;
  if (ldv_timer_5_3 == 1) {
    ldv_timer_5_3 = 2;
    ldv_timer_5(ldv_timer_5_3, ldv_timer_list_5_3);
  } else {

  }
  goto ldv_56348;
  default: 
  ldv_stop();
  }
  ldv_56348: ;
  return;
}
}
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_4_0 == (unsigned long )timer) {
    if (ldv_timer_4_0 == 2 || pending_flag != 0) {
      ldv_timer_list_4_0 = timer;
      ldv_timer_list_4_0->data = data;
      ldv_timer_4_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_4_1 == (unsigned long )timer) {
    if (ldv_timer_4_1 == 2 || pending_flag != 0) {
      ldv_timer_list_4_1 = timer;
      ldv_timer_list_4_1->data = data;
      ldv_timer_4_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_4_2 == (unsigned long )timer) {
    if (ldv_timer_4_2 == 2 || pending_flag != 0) {
      ldv_timer_list_4_2 = timer;
      ldv_timer_list_4_2->data = data;
      ldv_timer_4_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_4_3 == (unsigned long )timer) {
    if (ldv_timer_4_3 == 2 || pending_flag != 0) {
      ldv_timer_list_4_3 = timer;
      ldv_timer_list_4_3->data = data;
      ldv_timer_4_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_4(timer, data);
  return;
}
}
void timer_init_4(void) 
{ 


  {
  ldv_timer_4_0 = 0;
  ldv_timer_4_1 = 0;
  ldv_timer_4_2 = 0;
  ldv_timer_4_3 = 0;
  return;
}
}
void timer_init_6(void) 
{ 


  {
  ldv_timer_6_0 = 0;
  ldv_timer_6_1 = 0;
  ldv_timer_6_2 = 0;
  ldv_timer_6_3 = 0;
  return;
}
}
void ldv_timer_7(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  rtw_set_scan_deny_timer_hdl(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void timer_init_5(void) 
{ 


  {
  ldv_timer_5_0 = 0;
  ldv_timer_5_1 = 0;
  ldv_timer_5_2 = 0;
  ldv_timer_5_3 = 0;
  return;
}
}
void disable_suitable_timer_6(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_6_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_0) {
    ldv_timer_6_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_6_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_1) {
    ldv_timer_6_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_6_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_2) {
    ldv_timer_6_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_6_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_3) {
    ldv_timer_6_3 = 0;
    return;
  } else {

  }
  return;
}
}
void disable_suitable_timer_5(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_5_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_0) {
    ldv_timer_5_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_5_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_1) {
    ldv_timer_5_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_5_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_2) {
    ldv_timer_5_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_5_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_3) {
    ldv_timer_5_3 = 0;
    return;
  } else {

  }
  return;
}
}
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_6_0 == (unsigned long )timer) {
    if (ldv_timer_6_0 == 2 || pending_flag != 0) {
      ldv_timer_list_6_0 = timer;
      ldv_timer_list_6_0->data = data;
      ldv_timer_6_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_6_1 == (unsigned long )timer) {
    if (ldv_timer_6_1 == 2 || pending_flag != 0) {
      ldv_timer_list_6_1 = timer;
      ldv_timer_list_6_1->data = data;
      ldv_timer_6_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_6_2 == (unsigned long )timer) {
    if (ldv_timer_6_2 == 2 || pending_flag != 0) {
      ldv_timer_list_6_2 = timer;
      ldv_timer_list_6_2->data = data;
      ldv_timer_6_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_6_3 == (unsigned long )timer) {
    if (ldv_timer_6_3 == 2 || pending_flag != 0) {
      ldv_timer_list_6_3 = timer;
      ldv_timer_list_6_3->data = data;
      ldv_timer_6_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_6(timer, data);
  return;
}
}
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_4_0 == 0 || ldv_timer_4_0 == 2) {
    ldv_timer_list_4_0 = timer;
    ldv_timer_list_4_0->data = data;
    ldv_timer_4_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_4_1 == 0 || ldv_timer_4_1 == 2) {
    ldv_timer_list_4_1 = timer;
    ldv_timer_list_4_1->data = data;
    ldv_timer_4_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_4_2 == 0 || ldv_timer_4_2 == 2) {
    ldv_timer_list_4_2 = timer;
    ldv_timer_list_4_2->data = data;
    ldv_timer_4_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_4_3 == 0 || ldv_timer_4_3 == 2) {
    ldv_timer_list_4_3 = timer;
    ldv_timer_list_4_3->data = data;
    ldv_timer_4_3 = 1;
    return;
  } else {

  }
  return;
}
}
void disable_suitable_timer_7(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_7_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_0) {
    ldv_timer_7_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_7_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_1) {
    ldv_timer_7_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_7_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_2) {
    ldv_timer_7_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_7_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_3) {
    ldv_timer_7_3 = 0;
    return;
  } else {

  }
  return;
}
}
void choose_timer_6(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_6_0 == 1) {
    ldv_timer_6_0 = 2;
    ldv_timer_6(ldv_timer_6_0, ldv_timer_list_6_0);
  } else {

  }
  goto ldv_56393;
  case 1: ;
  if (ldv_timer_6_1 == 1) {
    ldv_timer_6_1 = 2;
    ldv_timer_6(ldv_timer_6_1, ldv_timer_list_6_1);
  } else {

  }
  goto ldv_56393;
  case 2: ;
  if (ldv_timer_6_2 == 1) {
    ldv_timer_6_2 = 2;
    ldv_timer_6(ldv_timer_6_2, ldv_timer_list_6_2);
  } else {

  }
  goto ldv_56393;
  case 3: ;
  if (ldv_timer_6_3 == 1) {
    ldv_timer_6_3 = 2;
    ldv_timer_6(ldv_timer_6_3, ldv_timer_list_6_3);
  } else {

  }
  goto ldv_56393;
  default: 
  ldv_stop();
  }
  ldv_56393: ;
  return;
}
}
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& rtw_dynamic_check_timer_handler)) {
    activate_suitable_timer_6(timer, data);
  } else {

  }
  return (0);
}
}
void ldv_timer_6(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  rtw_dynamic_check_timer_handler(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void timer_init_7(void) 
{ 


  {
  ldv_timer_7_0 = 0;
  ldv_timer_7_1 = 0;
  ldv_timer_7_2 = 0;
  ldv_timer_7_3 = 0;
  return;
}
}
void choose_timer_4(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_4_0 == 1) {
    ldv_timer_4_0 = 2;
    ldv_timer_4(ldv_timer_4_0, ldv_timer_list_4_0);
  } else {

  }
  goto ldv_56415;
  case 1: ;
  if (ldv_timer_4_1 == 1) {
    ldv_timer_4_1 = 2;
    ldv_timer_4(ldv_timer_4_1, ldv_timer_list_4_1);
  } else {

  }
  goto ldv_56415;
  case 2: ;
  if (ldv_timer_4_2 == 1) {
    ldv_timer_4_2 = 2;
    ldv_timer_4(ldv_timer_4_2, ldv_timer_list_4_2);
  } else {

  }
  goto ldv_56415;
  case 3: ;
  if (ldv_timer_4_3 == 1) {
    ldv_timer_4_3 = 2;
    ldv_timer_4(ldv_timer_4_3, ldv_timer_list_4_3);
  } else {

  }
  goto ldv_56415;
  default: 
  ldv_stop();
  }
  ldv_56415: ;
  return;
}
}
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_4_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_0) {
    ldv_timer_4_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_4_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_1) {
    ldv_timer_4_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_4_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_2) {
    ldv_timer_4_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_4_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_3) {
    ldv_timer_4_3 = 0;
    return;
  } else {

  }
  return;
}
}
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& rtw23a_join_to_handler)) {
    activate_suitable_timer_4(timer, data);
  } else {

  }
  return (0);
}
}
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_5_0 == (unsigned long )timer) {
    if (ldv_timer_5_0 == 2 || pending_flag != 0) {
      ldv_timer_list_5_0 = timer;
      ldv_timer_list_5_0->data = data;
      ldv_timer_5_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_5_1 == (unsigned long )timer) {
    if (ldv_timer_5_1 == 2 || pending_flag != 0) {
      ldv_timer_list_5_1 = timer;
      ldv_timer_list_5_1->data = data;
      ldv_timer_5_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_5_2 == (unsigned long )timer) {
    if (ldv_timer_5_2 == 2 || pending_flag != 0) {
      ldv_timer_list_5_2 = timer;
      ldv_timer_list_5_2->data = data;
      ldv_timer_5_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_5_3 == (unsigned long )timer) {
    if (ldv_timer_5_3 == 2 || pending_flag != 0) {
      ldv_timer_list_5_3 = timer;
      ldv_timer_list_5_3->data = data;
      ldv_timer_5_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_5(timer, data);
  return;
}
}
void choose_timer_7(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_7_0 == 1) {
    ldv_timer_7_0 = 2;
    ldv_timer_7(ldv_timer_7_0, ldv_timer_list_7_0);
  } else {

  }
  goto ldv_56438;
  case 1: ;
  if (ldv_timer_7_1 == 1) {
    ldv_timer_7_1 = 2;
    ldv_timer_7(ldv_timer_7_1, ldv_timer_list_7_1);
  } else {

  }
  goto ldv_56438;
  case 2: ;
  if (ldv_timer_7_2 == 1) {
    ldv_timer_7_2 = 2;
    ldv_timer_7(ldv_timer_7_2, ldv_timer_list_7_2);
  } else {

  }
  goto ldv_56438;
  case 3: ;
  if (ldv_timer_7_3 == 1) {
    ldv_timer_7_3 = 2;
    ldv_timer_7(ldv_timer_7_3, ldv_timer_list_7_3);
  } else {

  }
  goto ldv_56438;
  default: 
  ldv_stop();
  }
  ldv_56438: ;
  return;
}
}
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& rtw_scan_timeout_handler23a)) {
    activate_suitable_timer_5(timer, data);
  } else {

  }
  return (0);
}
}
void ldv_timer_4(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  rtw23a_join_to_handler(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_5_0 == 0 || ldv_timer_5_0 == 2) {
    ldv_timer_list_5_0 = timer;
    ldv_timer_list_5_0->data = data;
    ldv_timer_5_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_5_1 == 0 || ldv_timer_5_1 == 2) {
    ldv_timer_list_5_1 = timer;
    ldv_timer_list_5_1->data = data;
    ldv_timer_5_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_5_2 == 0 || ldv_timer_5_2 == 2) {
    ldv_timer_list_5_2 = timer;
    ldv_timer_list_5_2->data = data;
    ldv_timer_5_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_5_3 == 0 || ldv_timer_5_3 == 2) {
    ldv_timer_list_5_3 = timer;
    ldv_timer_list_5_3->data = data;
    ldv_timer_5_3 = 1;
    return;
  } else {

  }
  return;
}
}
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_7_0 == (unsigned long )timer) {
    if (ldv_timer_7_0 == 2 || pending_flag != 0) {
      ldv_timer_list_7_0 = timer;
      ldv_timer_list_7_0->data = data;
      ldv_timer_7_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_7_1 == (unsigned long )timer) {
    if (ldv_timer_7_1 == 2 || pending_flag != 0) {
      ldv_timer_list_7_1 = timer;
      ldv_timer_list_7_1->data = data;
      ldv_timer_7_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_7_2 == (unsigned long )timer) {
    if (ldv_timer_7_2 == 2 || pending_flag != 0) {
      ldv_timer_list_7_2 = timer;
      ldv_timer_list_7_2->data = data;
      ldv_timer_7_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_7_3 == (unsigned long )timer) {
    if (ldv_timer_7_3 == 2 || pending_flag != 0) {
      ldv_timer_list_7_3 = timer;
      ldv_timer_list_7_3->data = data;
      ldv_timer_7_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_7(timer, data);
  return;
}
}
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_7_0 == 0 || ldv_timer_7_0 == 2) {
    ldv_timer_list_7_0 = timer;
    ldv_timer_list_7_0->data = data;
    ldv_timer_7_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_7_1 == 0 || ldv_timer_7_1 == 2) {
    ldv_timer_list_7_1 = timer;
    ldv_timer_list_7_1->data = data;
    ldv_timer_7_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_7_2 == 0 || ldv_timer_7_2 == 2) {
    ldv_timer_list_7_2 = timer;
    ldv_timer_list_7_2->data = data;
    ldv_timer_7_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_7_3 == 0 || ldv_timer_7_3 == 2) {
    ldv_timer_list_7_3 = timer;
    ldv_timer_list_7_3->data = data;
    ldv_timer_7_3 = 1;
    return;
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_64(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_65(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_66(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_67(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_68(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_69(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_70(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_71(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_72(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_73(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_74(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_75(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_76(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_77(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 


  {
  return ((__u64 )*p);
}
}
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
extern void __xadd_wrong_size(void) ;
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
  __ret = i;
  switch (4UL) {
  case 1UL: 
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5659;
  case 2UL: 
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5659;
  case 4UL: 
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5659;
  case 8UL: 
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5659;
  default: 
  __xadd_wrong_size();
  }
  ldv_5659: ;
  return (__ret + i);
}
}
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
  return;
}
}
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
extern void mutex_unlock(struct mutex * ) ;
int ldv_mod_timer_104(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_105(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_107(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_108(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_109(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_111(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_113(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_115(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_116(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_121(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_122(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_102(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_103(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_106(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_110(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_112(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_114(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_117(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_118(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_119(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_120(struct timer_list *ldv_func_arg1 ) ;
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_98(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_100(struct workqueue_struct *ldv_func_arg1 ) ;
extern void yield(void) ;
struct timer_list *ldv_timer_list_9_3 ;
struct timer_list *ldv_timer_list_10_2 ;
struct timer_list *ldv_timer_list_8_1 ;
int ldv_timer_9_1 ;
int ldv_timer_9_0 ;
int ldv_timer_9_3 ;
struct timer_list *ldv_timer_list_10_0 ;
int ldv_timer_8_2 ;
struct timer_list *ldv_timer_list_9_2 ;
int ldv_timer_9_2 ;
struct timer_list *ldv_timer_list_8_3 ;
int ldv_timer_10_2 ;
struct timer_list *ldv_timer_list_10_1 ;
struct timer_list *ldv_timer_list_9_0 ;
int ldv_timer_8_3 ;
int ldv_timer_8_0 ;
int ldv_timer_10_0 ;
int ldv_timer_8_1 ;
int ldv_timer_10_1 ;
struct timer_list *ldv_timer_list_8_0 ;
struct timer_list *ldv_timer_list_10_3 ;
int ldv_timer_10_3 ;
struct timer_list *ldv_timer_list_8_2 ;
struct timer_list *ldv_timer_list_9_1 ;
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void disable_suitable_timer_8(struct timer_list *timer ) ;
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) ;
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void ldv_timer_9(int state , struct timer_list *timer ) ;
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void timer_init_9(void) ;
void ldv_timer_10(int state , struct timer_list *timer ) ;
void activate_suitable_timer_9(struct timer_list *timer , unsigned long data ) ;
void disable_suitable_timer_10(struct timer_list *timer ) ;
void choose_timer_8(void) ;
int reg_timer_9(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
int reg_timer_8(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void disable_suitable_timer_9(struct timer_list *timer ) ;
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) ;
void choose_timer_9(void) ;
void timer_init_10(void) ;
void ldv_timer_8(int state , struct timer_list *timer ) ;
void timer_init_8(void) ;
void activate_suitable_timer_8(struct timer_list *timer , unsigned long data ) ;
void choose_timer_10(void) ;
__inline static u64 get_unaligned_le64(void const   *p ) 
{ 
  __u64 tmp ;

  {
  tmp = __le64_to_cpup((__le64 const   *)p);
  return (tmp);
}
}
__inline static void put_unaligned_le16(u16 val , void *p ) 
{ 


  {
  *((__le16 *)p) = val;
  return;
}
}
__inline static void put_unaligned_le32(u32 val , void *p ) 
{ 


  {
  *((__le32 *)p) = val;
  return;
}
}
__inline static bool is_broadcast_ether_addr(u8 const   *addr ) 
{ 


  {
  return ((unsigned int )(((int )((unsigned short )*((u16 const   *)addr)) & (int )((unsigned short )*((u16 const   *)addr + 2U))) & (int )((unsigned short )*((u16 const   *)addr + 4U))) == 65535U);
}
}
__inline static int ieee80211_has_retry(__le16 fc ) 
{ 


  {
  return (((int )fc & 2048) != 0);
}
}
__inline static int ieee80211_is_mgmt(__le16 fc ) 
{ 


  {
  return (((int )fc & 12) == 0);
}
}
__inline static int ieee80211_is_assoc_req(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 0);
}
}
__inline static int ieee80211_is_probe_req(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 64);
}
}
__inline static int ieee80211_is_probe_resp(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 80);
}
}
__inline static int ieee80211_is_beacon(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 128);
}
}
__inline static void *wiphy_priv___0(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3259), "i" (12UL));
    ldv_48282: ;
    goto ldv_48282;
  } else {

  }
  return ((void *)(& wiphy->priv));
}
}
__inline static void *wdev_priv___0(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3512), "i" (12UL));
    ldv_48367: ;
    goto ldv_48367;
  } else {

  }
  tmp___0 = wiphy_priv___0(wdev->wiphy);
  return (tmp___0);
}
}
extern int ieee80211_channel_to_frequency(int  , enum ieee80211_band  ) ;
extern bool cfg80211_rx_mgmt(struct wireless_dev * , int  , int  , u8 const   * ,
                             size_t  , u32  ) ;
extern u8 hal_ch_offset_to_secondary_ch_offset23a(u8  ) ;
extern u8 *rtw_set_ie23a_ch_switch(u8 * , u32 * , u8  , u8  , u8  ) ;
extern u8 *rtw_set_ie23a_secondary_ch_offset(u8 * , u32 * , u8  ) ;
void rtw_sctx_init23a(struct submit_ctx *sctx , int timeout_ms ) ;
int rtw_sctx_wait23a(struct submit_ctx *sctx ) ;
struct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv ) ;
s32 rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) ;
struct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv ) ;
s32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv , struct xmit_frame *pxmitframe ) ;
int rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv , u32 timeout_ms ) ;
void mgt_dispatcher23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void hw_var_set_correct_tsf(struct rtw_adapter *padapter ) ;
void hw_var_set_mlme_disconnect(struct rtw_adapter *padapter ) ;
void hw_var_set_opmode(struct rtw_adapter *padapter , u8 mode ) ;
void hw_var_set_bssid(struct rtw_adapter *padapter , u8 *val ) ;
void hw_var_set_mlme_join(struct rtw_adapter *padapter , u8 type ) ;
void HalSetBrateCfg23a(struct rtw_adapter *padapter , u8 *mBratesOS ) ;
void rtl8723a_set_media_status(struct rtw_adapter *padapter , u8 status ) ;
void rtl8723a_set_bcn_func(struct rtw_adapter *padapter , u8 val ) ;
void rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter , u8 flag ) ;
void rtl8723a_on_rcr_am(struct rtw_adapter *padapter ) ;
void rtl8723a_set_sec_cfg(struct rtw_adapter *padapter , u8 sec ) ;
void rtl8723a_cam_write(struct rtw_adapter *padapter , u8 entry , u16 ctrl , u8 const   *mac ,
                        u8 const   *key ) ;
void rtl8723a_bcn_valid(struct rtw_adapter *padapter ) ;
bool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter ) ;
void rtl8723a_set_beacon_interval(struct rtw_adapter *padapter , u16 interval ) ;
void rtl8723a_set_initial_gain(struct rtw_adapter *padapter , u32 rx_gain ) ;
void rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter ) ;
void rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter ) ;
void rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter , u32 val ) ;
void rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter , u32 val ) ;
void rtw_wep_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
unsigned char WMM_OUI23A[4U] ;
unsigned char WPS_OUI23A[4U] ;
unsigned char WFD_OUI23A[4U] ;
unsigned char P2P_OUI23A[4U] ;
unsigned char WMM_INFO_OUI23A[6U] ;
unsigned char WMM_PARA_OUI23A[6U] ;
int rtw_ch_set_search_ch23a(struct rt_channel_info *ch_set , u32 const   ch ) ;
int init_mlme_ext_priv23a(struct rtw_adapter *padapter ) ;
int init_hw_mlme_ext23a(struct rtw_adapter *padapter ) ;
void free_mlme_ext_priv23a(struct mlme_ext_priv *pmlmeext ) ;
void init_mlme_ext_timer23a(struct rtw_adapter *padapter ) ;
void init_addba_retry_timer23a(struct sta_info *psta ) ;
struct xmit_frame *alloc_mgtxmitframe23a(struct xmit_priv *pxmitpriv ) ;
void get_rate_set23a(struct rtw_adapter *padapter , unsigned char *pbssrate , int *bssrate_len ) ;
void UpdateBrateTbl23a(struct rtw_adapter *Adapter , u8 *mBratesOS ) ;
void Update23aTblForSoftAP(u8 *bssrateset , u32 bssratelen ) ;
extern u8 rtw_get_oper_ch23a(struct rtw_adapter * ) ;
void set_channel_bwmode23a(struct rtw_adapter *padapter , unsigned char channel ,
                           unsigned char channel_offset , unsigned short bwmode ) ;
void SelectChannel23a(struct rtw_adapter *padapter , unsigned char channel ) ;
unsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval ) ;
int allocate_fw_sta_entry23a(struct rtw_adapter *padapter ) ;
void flush_all_cam_entry23a(struct rtw_adapter *padapter ) ;
bool IsLegal5GChannel(struct rtw_adapter *Adapter , u8 channel ) ;
extern u8 *get_my_bssid23a(struct wlan_bssid_ex * ) ;
bool is_client_associated_to_ap23a(struct rtw_adapter *padapter ) ;
bool is_client_associated_to_ibss23a(struct rtw_adapter *padapter ) ;
bool is_IBSS_empty23a(struct rtw_adapter *padapter ) ;
int WMM_param_handler23a(struct rtw_adapter *padapter , u8 const   *p ) ;
void WMMOnAssocRsp23a(struct rtw_adapter *padapter ) ;
void HT_caps_handler23a(struct rtw_adapter *padapter , u8 const   *p ) ;
void HT_info_handler23a(struct rtw_adapter *padapter , u8 const   *p ) ;
void HTOnAssocRsp23a(struct rtw_adapter *padapter ) ;
void ERP_IE_handler23a(struct rtw_adapter *padapter , u8 const   *p ) ;
void VCS_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void update_beacon23a_info(struct rtw_adapter *padapter , struct ieee80211_mgmt *mgmt ,
                           uint pkt_len , struct sta_info *psta ) ;
int rtw_check_bcn_info23a(struct rtw_adapter *Adapter , struct ieee80211_mgmt *mgmt ,
                          u32 pkt_len ) ;
void update_IOT_info23a(struct rtw_adapter *padapter ) ;
void update_capinfo23a(struct rtw_adapter *Adapter , u16 updateCap ) ;
void update_wireless_mode23a(struct rtw_adapter *padapter ) ;
void update_tx_basic_rate23a(struct rtw_adapter *padapter , u8 wirelessmode ) ;
void update_bmc_sta_support_rate23a(struct rtw_adapter *padapter , u32 mac_id ) ;
int update_sta_support_rate23a(struct rtw_adapter *padapter , u8 *pvar_ie , uint var_ie_len ,
                               int cam_idx ) ;
void Update_RA_Entry23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void set_sta_rate23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
int receive_disconnect23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                          unsigned short reason ) ;
int support_short_GI23a(struct rtw_adapter *padapter , struct ieee80211_ht_cap *pHT_caps ) ;
bool is_ap_in_tkip23a(struct rtw_adapter *padapter ) ;
void report_join_res23a(struct rtw_adapter *padapter , int res ) ;
void report_survey_event23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void report_surveydone_event23a(struct rtw_adapter *padapter ) ;
void report_del_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             unsigned short reason ) ;
void report_add_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             int cam_idx ) ;
int set_tx_beacon_cmd23a(struct rtw_adapter *padapter ) ;
void update_mgnt_tx_rate23a(struct rtw_adapter *padapter , u8 rate ) ;
void update_mgntframe_attrib23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) ;
void dump_mgntframe23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
s32 dump_mgntframe23a_and_wait(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ,
                               int timeout_ms ) ;
s32 dump_mgntframe23a_and_wait_ack23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
void issue_beacon23a(struct rtw_adapter *padapter , int timeout_ms ) ;
int issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                      int try_cnt , int wait_ms ) ;
int issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , u16 tid ,
                          int try_cnt , int wait_ms ) ;
int issue_deauth23a(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ) ;
void issue_action_spct_ch_switch23a(struct rtw_adapter *padapter , u8 *ra , u8 new_ch ,
                                    u8 ch_offset ) ;
void issue_action_BA23a(struct rtw_adapter *padapter , unsigned char const   *raddr ,
                        unsigned char action , unsigned short status ) ;
int send_delba23a(struct rtw_adapter *padapter , u8 initiator , u8 *addr ) ;
int send_beacon23a(struct rtw_adapter *padapter ) ;
void process_addba_req23a(struct rtw_adapter *padapter , u8 *paddba_req , u8 *addr ) ;
void init_mlme_ap_info23a(struct rtw_adapter *padapter ) ;
void associated_clients_update23a(struct rtw_adapter *padapter , u8 updated ) ;
void bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void sta_info_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
u8 ap_free_sta23a(struct rtw_adapter *padapter , struct sta_info *psta , bool active ,
                  u16 reason ) ;
void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter , u8 *pmgmt_frame ,
                                     uint frame_len ) ;
int rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
int rtl8723au_mgnt_xmit(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
void rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter ) ;
static int OnAssocReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAssocRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnProbeReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnProbeRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int DoReserved23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnBeacon23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAtim23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnDisassoc23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAuth23aClient23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnDeAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int on_action_spct23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_qos(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_dls(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_back23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int on_action_public23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_ht(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_wmm(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_p2p(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static void issue_assocreq(struct rtw_adapter *padapter ) ;
__inline static void issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                    u8 *da ) ;
static int issue_probereq_ex(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                             u8 *da , int try_cnt , int wait_ms ) ;
static void issue_probersp(struct rtw_adapter *padapter , unsigned char *da ) ;
static void issue_auth(struct rtw_adapter *padapter , struct sta_info *psta , unsigned short status ) ;
static int issue_deauth_ex(struct rtw_adapter *padapter , u8 *da , unsigned short reason ,
                           int try_cnt , int wait_ms ) ;
static void start_clnt_assoc(struct rtw_adapter *padapter ) ;
static void start_clnt_auth(struct rtw_adapter *padapter ) ;
static void start_clnt_join(struct rtw_adapter *padapter ) ;
static void start_create_ibss(struct rtw_adapter *padapter ) ;
static struct wlan_bssid_ex *collect_bss_info(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static void issue_assocrsp(struct rtw_adapter *padapter , unsigned short status ,
                           struct sta_info *pstat , u16 pkt_type ) ;
static struct mlme_handler mlme_sta_tbl[14U]  = 
  {      {(char *)"OnAssocReq23a", & OnAssocReq23a}, 
        {(char *)"OnAssocRsp23a", & OnAssocRsp23a}, 
        {(char *)"OnReAssocReq", & OnAssocReq23a}, 
        {(char *)"OnReAssocRsp", & OnAssocRsp23a}, 
        {(char *)"OnProbeReq23a", & OnProbeReq23a}, 
        {(char *)"OnProbeRsp23a", & OnProbeRsp23a}, 
        {(char *)"DoReserved23a", & DoReserved23a}, 
        {(char *)"DoReserved23a", & DoReserved23a}, 
        {(char *)"OnBeacon23a", & OnBeacon23a}, 
        {(char *)"OnATIM", & OnAtim23a}, 
        {(char *)"OnDisassoc23a", & OnDisassoc23a}, 
        {(char *)"OnAuth23a", & OnAuth23aClient23a}, 
        {(char *)"OnDeAuth23a", & OnDeAuth23a}, 
        {(char *)"OnAction23a", & OnAction23a}};
static struct action_handler OnAction23a_tbl[9U]  = 
  {      {0U, (char *)"ACTION_SPECTRUM_MGMT", & on_action_spct23a}, 
        {1U, (char *)"ACTION_QOS", & OnAction23a_qos}, 
        {2U, (char *)"ACTION_DLS", & OnAction23a_dls}, 
        {3U, (char *)"ACTION_BACK", & OnAction23a_back23a}, 
        {4U, (char *)"ACTION_PUBLIC", & on_action_public23a}, 
        {7U, (char *)"ACTION_HT", & OnAction23a_ht}, 
        {8U, (char *)"ACTION_SA_QUERY", & DoReserved23a}, 
        {17U, (char *)"ACTION_WMM", & OnAction23a_wmm}, 
        {127U, (char *)"ACTION_P2P", & OnAction23a_p2p}};
static u8 null_addr[6U]  = {      0U,      0U,      0U,      0U, 
        0U,      0U};
unsigned char WMM_OUI23A[4U]  = {      0U,      80U,      242U,      2U};
unsigned char WPS_OUI23A[4U]  = {      0U,      80U,      242U,      4U};
unsigned char P2P_OUI23A[4U]  = {      80U,      111U,      154U,      9U};
unsigned char WFD_OUI23A[4U]  = {      80U,      111U,      154U,      10U};
unsigned char WMM_INFO_OUI23A[6U]  = {      0U,      80U,      242U,      2U, 
        0U,      1U};
unsigned char WMM_PARA_OUI23A[6U]  = {      0U,      80U,      242U,      2U, 
        1U,      1U};
static unsigned char REALTEK_96B_IE[6U]  = {      0U,      224U,      76U,      2U, 
        1U,      32U};
unsigned char MCS_rate_2R23A[16U]  = 
  {      255U,      255U,      0U,      0U, 
        1U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
unsigned char MCS_rate_1R23A[16U]  = 
  {      255U,      0U,      0U,      0U, 
        1U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
static struct rt_channel_plan_2g RTW_ChannelPlan2G[6U]  = {      {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U}, 13U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U}, 13U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U}, 11U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U, 14U}, 14U}, 
        {{10U, 11U, 12U, 13U}, 4U}, 
        {{(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0U}};
static struct rt_channel_plan_5g RTW_ChannelPlan5G[20U]  = 
  {      {{(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0U}, 
        {{36U,
       40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U, 124U,
       128U, 132U, 136U, 140U}, 19U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U, 149U, 153U, 157U, 161U, 165U}, 24U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 149U, 153U, 157U, 161U, 165U}, 22U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U, 149U, 153U, 157U, 161U, 165U}, 24U}, 
        {{36U, 40U, 44U, 48U, 149U, 153U, 157U, 161U, 165U}, 9U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 149U, 153U, 157U, 161U, 165U}, 13U}, 
        {{36U,
       40U, 44U, 48U, 52U, 56U, 60U, 64U, 149U, 153U, 157U, 161U}, 12U}, 
        {{149U, 153U, 157U, 161U, 165U}, 5U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U}, 8U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 136U,
       140U, 149U, 153U, 157U, 161U, 165U}, 20U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 149U, 153U, 157U, 161U, 165U}, 20U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U}, 19U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U}, 8U}, 
        {{100U, 104U, 108U, 112U, 116U, 120U, 124U, 128U, 132U, 136U, 140U}, 11U}, 
        {{56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 136U, 140U, 149U, 153U, 157U,
       161U, 165U}, 15U}, 
        {{56U, 60U, 64U, 149U, 153U, 157U, 161U, 165U}, 8U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 132U,
       136U, 140U, 149U, 153U, 157U, 161U, 165U}, 21U}, 
        {{36U, 40U, 44U, 48U}, 4U}, 
        {{36U, 40U, 44U, 48U, 149U, 153U, 157U, 161U}, 8U}};
static struct rt_channel_plan_map RTW_ChannelPlanMap[66U]  = 
  {      {2U, 17U}, 
        {2U, 10U}, 
        {1U, 1U}, 
        {1U, 0U}, 
        {1U, 0U}, 
        {3U, 0U}, 
        {3U, 0U}, 
        {1U, 9U}, 
        {3U, 9U}, 
        {3U, 0U}, 
        {0U, 0U}, 
        {2U, 15U}, 
        {1U, 8U}, 
        {2U, 6U}, 
        {2U, 11U}, 
        {2U, 9U}, 
        {1U, 1U}, 
        {2U, 5U}, 
        {1U, 18U}, 
        {0U, 4U}, 
        {2U, 16U}, 
        {0U, 18U}, 
        {0U, 19U}, 
        {3U, 18U}, 
        {5U, 8U}, 
        {2U, 8U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {5U, 4U}, 
        {0U, 0U}, 
        {1U, 0U}, 
        {2U, 0U}, 
        {3U, 0U}, 
        {4U, 0U}, 
        {2U, 4U}, 
        {0U, 1U}, 
        {3U, 12U}, 
        {0U, 11U}, 
        {0U, 5U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 6U}, 
        {0U, 7U}, 
        {0U, 8U}, 
        {0U, 9U}, 
        {2U, 10U}, 
        {0U, 2U}, 
        {0U, 3U}, 
        {3U, 13U}, 
        {3U, 14U}, 
        {2U, 15U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {2U, 16U}, 
        {3U, 0U}};
static struct rt_channel_plan_map RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE  =    {3U, 2U};
static void dummy_event_callback(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 


  {
  return;
}
}
static struct fwevent wlanevents[25U]  = 
  {      {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & rtw_survey_event_cb23a}, 
        {4U, & rtw_surveydone_event_callback23a}, 
        {0U, & rtw23a_joinbss_event_cb}, 
        {12U, & rtw_stassoc_event_callback23a}, 
        {12U, & rtw_stadel_event_callback23a}, 
        {0U, & dummy_event_callback}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}};
static void rtw_correct_TSF(struct rtw_adapter *padapter ) 
{ 


  {
  hw_var_set_correct_tsf(padapter);
  return;
}
}
static void rtw_update_TSF(struct mlme_ext_priv *pmlmeext , struct ieee80211_mgmt *mgmt ) 
{ 


  {
  pmlmeext->TSFValue = get_unaligned_le64((void const   *)(& mgmt->u.beacon.timestamp));
  return;
}
}
int rtw_ch_set_search_ch23a(struct rt_channel_info *ch_set , u32 const   ch ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_55968;
  ldv_55967: ;
  if ((unsigned int )(ch_set + (unsigned long )i)->ChannelNum == (unsigned int )ch) {
    goto ldv_55966;
  } else {

  }
  i = i + 1;
  ldv_55968: ;
  if ((unsigned int )(ch_set + (unsigned long )i)->ChannelNum != 0U) {
    goto ldv_55967;
  } else {

  }
  ldv_55966: ;
  if ((int )(ch_set + (unsigned long )i)->ChannelNum <= i) {
    return (-1);
  } else {

  }
  return (i);
}
}
int init_hw_mlme_ext23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  return (1);
}
}
static void init_mlme_ext_priv23a_value(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char mixed_datarate[13U] ;
  unsigned char mixed_basicrate[13U] ;
  unsigned int tmp ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  mixed_datarate[0] = 0U;
  mixed_datarate[1] = 1U;
  mixed_datarate[2] = 2U;
  mixed_datarate[3] = 3U;
  mixed_datarate[4] = 4U;
  mixed_datarate[5] = 5U;
  mixed_datarate[6] = 6U;
  mixed_datarate[7] = 7U;
  mixed_datarate[8] = 8U;
  mixed_datarate[9] = 9U;
  mixed_datarate[10] = 10U;
  mixed_datarate[11] = 11U;
  mixed_datarate[12] = 255U;
  mixed_basicrate[0] = 0U;
  mixed_basicrate[1] = 1U;
  mixed_basicrate[2] = 2U;
  mixed_basicrate[3] = 3U;
  mixed_basicrate[4] = 4U;
  mixed_basicrate[5] = 6U;
  mixed_basicrate[6] = 8U;
  mixed_basicrate[7] = 255U;
  tmp = 8U;
  while (1) {
    if (tmp >= 13U) {
      break;
    } else {

    }
    mixed_basicrate[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  atomic_set(& pmlmeext->event_seq, 0);
  pmlmeext->mgnt_seq = 0U;
  pmlmeext->cur_channel = padapter->registrypriv.channel;
  pmlmeext->cur_bwmode = 0U;
  pmlmeext->cur_ch_offset = 0U;
  pmlmeext->retry = 0U;
  pmlmeext->cur_wireless_mode = padapter->registrypriv.wireless_mode;
  memcpy((void *)(& pmlmeext->datarate), (void const   *)(& mixed_datarate), 13UL);
  memcpy((void *)(& pmlmeext->basicrate), (void const   *)(& mixed_basicrate), 13UL);
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
    pmlmeext->tx_rate = 12U;
  } else {
    pmlmeext->tx_rate = 2U;
  }
  pmlmeext->sitesurvey_res.state = 0;
  pmlmeext->sitesurvey_res.channel_idx = 0;
  pmlmeext->sitesurvey_res.bss_cnt = 0;
  pmlmeext->scan_abort = 0U;
  pmlmeinfo->state = 0U;
  pmlmeinfo->reauth_count = 0U;
  pmlmeinfo->reassoc_count = 0U;
  pmlmeinfo->link_count = 0U;
  pmlmeinfo->auth_seq = 0U;
  pmlmeinfo->auth_algo = 0U;
  pmlmeinfo->key_index = 0U;
  pmlmeinfo->iv = 0U;
  pmlmeinfo->enc_algo = 0U;
  pmlmeinfo->authModeToggle = 0U;
  memset((void *)(& pmlmeinfo->chg_txt), 0, 128UL);
  pmlmeinfo->slotTime = 9U;
  pmlmeinfo->preamble_mode = 2U;
  pmlmeinfo->dialogToken = 0U;
  pmlmeext->action_public_rxseq = 65535U;
  pmlmeext->action_public_dialog_token = 255U;
  return;
}
}
static int has_channel(struct rt_channel_info *channel_set , u8 chanset_size , u8 chan ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_55987;
  ldv_55986: ;
  if ((int )(channel_set + (unsigned long )i)->ChannelNum == (int )chan) {
    return (1);
  } else {

  }
  i = i + 1;
  ldv_55987: ;
  if ((int )chanset_size > i) {
    goto ldv_55986;
  } else {

  }

  return (0);
}
}
static void init_channel_list(struct rtw_adapter *padapter , struct rt_channel_info *channel_set ,
                              u8 chanset_size , struct p2p_channels *channel_list ) 
{ 
  struct p2p_oper_class_map op_class[10U] ;
  int cla ;
  int op ;
  u8 ch ;
  struct p2p_oper_class_map *o ;
  struct p2p_reg_class *reg ;
  int tmp ;

  {
  op_class[0].mode = 0;
  op_class[0].op_class = 81U;
  op_class[0].min_chan = 1U;
  op_class[0].max_chan = 13U;
  op_class[0].inc = 1U;
  op_class[0].bw = 0;
  op_class[1].mode = 0;
  op_class[1].op_class = 82U;
  op_class[1].min_chan = 14U;
  op_class[1].max_chan = 14U;
  op_class[1].inc = 1U;
  op_class[1].bw = 0;
  op_class[2].mode = 1;
  op_class[2].op_class = 115U;
  op_class[2].min_chan = 36U;
  op_class[2].max_chan = 48U;
  op_class[2].inc = 4U;
  op_class[2].bw = 0;
  op_class[3].mode = 1;
  op_class[3].op_class = 116U;
  op_class[3].min_chan = 36U;
  op_class[3].max_chan = 44U;
  op_class[3].inc = 8U;
  op_class[3].bw = 1;
  op_class[4].mode = 1;
  op_class[4].op_class = 117U;
  op_class[4].min_chan = 40U;
  op_class[4].max_chan = 48U;
  op_class[4].inc = 8U;
  op_class[4].bw = 2;
  op_class[5].mode = 1;
  op_class[5].op_class = 124U;
  op_class[5].min_chan = 149U;
  op_class[5].max_chan = 161U;
  op_class[5].inc = 4U;
  op_class[5].bw = 0;
  op_class[6].mode = 1;
  op_class[6].op_class = 125U;
  op_class[6].min_chan = 149U;
  op_class[6].max_chan = 169U;
  op_class[6].inc = 4U;
  op_class[6].bw = 0;
  op_class[7].mode = 1;
  op_class[7].op_class = 126U;
  op_class[7].min_chan = 149U;
  op_class[7].max_chan = 157U;
  op_class[7].inc = 8U;
  op_class[7].bw = 1;
  op_class[8].mode = 1;
  op_class[8].op_class = 127U;
  op_class[8].min_chan = 153U;
  op_class[8].max_chan = 161U;
  op_class[8].inc = 8U;
  op_class[8].bw = 2;
  op_class[9].mode = 4294967295L;
  op_class[9].op_class = 0U;
  op_class[9].min_chan = 0U;
  op_class[9].max_chan = 0U;
  op_class[9].inc = 0U;
  op_class[9].bw = 0;
  cla = 0;
  op = 0;
  goto ldv_56006;
  ldv_56005: 
  o = (struct p2p_oper_class_map *)(& op_class) + (unsigned long )op;
  reg = (struct p2p_reg_class *)0;
  ch = o->min_chan;
  goto ldv_56003;
  ldv_56002: 
  tmp = has_channel(channel_set, (int )chanset_size, (int )ch);
  if (tmp == 0) {
    goto ldv_56001;
  } else {

  }
  if ((unsigned int )padapter->registrypriv.ht_enable == 0U && (unsigned int )o->inc == 8U) {
    goto ldv_56001;
  } else {

  }
  if (((unsigned long )padapter->registrypriv.cbw40_enable & 2UL) == 0UL && ((unsigned int )o->bw == 2U || (unsigned int )o->bw == 1U)) {
    goto ldv_56001;
  } else {

  }
  if ((unsigned long )reg == (unsigned long )((struct p2p_reg_class *)0)) {
    reg = (struct p2p_reg_class *)(& channel_list->reg_class) + (unsigned long )cla;
    cla = cla + 1;
    reg->reg_class = o->op_class;
    reg->channels = 0UL;
  } else {

  }
  reg->channel[reg->channels] = ch;
  reg->channels = reg->channels + 1UL;
  ldv_56001: 
  ch = (int )o->inc + (int )ch;
  ldv_56003: ;
  if ((int )o->max_chan >= (int )ch) {
    goto ldv_56002;
  } else {

  }
  op = op + 1;
  ldv_56006: ;
  if ((unsigned int )op_class[op].op_class != 0U) {
    goto ldv_56005;
  } else {

  }
  channel_list->reg_classes = (size_t )cla;
  return;
}
}
static u8 init_channel_set(struct rtw_adapter *padapter , u8 cplan , struct rt_channel_info *c_set ) 
{ 
  u8 i ;
  u8 ch_size ;
  u8 b5GBand ;
  u8 b2_4GBand ;
  u8 Index2G ;
  u8 Index5G ;

  {
  ch_size = 0U;
  b5GBand = 0U;
  b2_4GBand = 0U;
  Index2G = 0U;
  Index5G = 0U;
  memset((void *)c_set, 0, 304UL);
  if ((unsigned int )cplan > 65U && (unsigned int )cplan != 127U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ChannelPlan ID %x error !!!!!\n", (int )cplan);
    } else {

    }
    return (ch_size);
  } else {

  }
  if (((int )padapter->registrypriv.wireless_mode & 2) != 0) {
    b2_4GBand = 1U;
    if ((unsigned int )cplan == 127U) {
      Index2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;
    } else {
      Index2G = RTW_ChannelPlanMap[(int )cplan].Index2G;
    }
  } else {

  }
  if (((int )padapter->registrypriv.wireless_mode & 4) != 0) {
    b5GBand = 1U;
    if ((unsigned int )cplan == 127U) {
      Index5G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index5G;
    } else {
      Index5G = RTW_ChannelPlanMap[(int )cplan].Index5G;
    }
  } else {

  }
  if ((unsigned int )b2_4GBand != 0U) {
    i = 0U;
    goto ldv_56020;
    ldv_56019: 
    (c_set + (unsigned long )ch_size)->ChannelNum = RTW_ChannelPlan2G[(int )Index2G].Channel[(int )i];
    if ((unsigned int )cplan == 9U || (unsigned int )cplan == 65U) {
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum != 0U && (unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 11U) {
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      } else
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum > 11U && (unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 14U) {
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      } else {

      }
    } else
    if (((unsigned int )cplan == 10U || (unsigned int )cplan == 19U) || (unsigned int )Index2G == 0U) {
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 11U) {
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      } else {
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      }
    } else {
      (c_set + (unsigned long )ch_size)->ScanType = 1;
    }
    ch_size = (u8 )((int )ch_size + 1);
    i = (u8 )((int )i + 1);
    ldv_56020: ;
    if ((int )RTW_ChannelPlan2G[(int )Index2G].Len > (int )i) {
      goto ldv_56019;
    } else {

    }

  } else {

  }
  if ((unsigned int )b5GBand != 0U) {
    i = 0U;
    goto ldv_56024;
    ldv_56023: ;
    if ((unsigned int )RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i] <= 48U || (unsigned int )RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i] > 148U) {
      (c_set + (unsigned long )ch_size)->ChannelNum = RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i];
      if ((unsigned int )cplan == 19U) {
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      } else {
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(): channel_set[%d].ChannelNum = %d\n", "init_channel_set",
               (int )ch_size, (int )(c_set + (unsigned long )ch_size)->ChannelNum);
      } else {

      }
      ch_size = (u8 )((int )ch_size + 1);
    } else {

    }
    i = (u8 )((int )i + 1);
    ldv_56024: ;
    if ((int )RTW_ChannelPlan5G[(int )Index5G].Len > (int )i) {
      goto ldv_56023;
    } else {

    }

  } else {

  }
  return (ch_size);
}
}
int init_mlme_ext_priv23a(struct rtw_adapter *padapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pregistrypriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmeext->padapter = padapter;
  init_mlme_ext_priv23a_value(padapter);
  pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
  init_mlme_ext_timer23a(padapter);
  init_mlme_ap_info23a(padapter);
  pmlmeext->max_chan_nums = init_channel_set(padapter, (int )pmlmepriv->ChannelPlan,
                                             (struct rt_channel_info *)(& pmlmeext->channel_set));
  init_channel_list(padapter, (struct rt_channel_info *)(& pmlmeext->channel_set),
                    (int )pmlmeext->max_chan_nums, & pmlmeext->channel_list);
  pmlmeext->chan_scan_time = 100U;
  pmlmeext->mlmeext_init = 1U;
  pmlmeext->active_keep_alive_check = 1U;
  return (1);
}
}
void free_mlme_ext_priv23a(struct mlme_ext_priv *pmlmeext ) 
{ 
  struct rtw_adapter *padapter ;

  {
  padapter = pmlmeext->padapter;
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {

  }
  if (padapter->bDriverStopped == 1) {
    ldv_del_timer_sync_102(& pmlmeext->survey_timer);
    ldv_del_timer_sync_103(& pmlmeext->link_timer);
  } else {

  }
  return;
}
}
static void _mgt_dispatcher23a(struct rtw_adapter *padapter , struct mlme_handler *ptable ,
                               struct recv_frame *precv_frame ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  if ((unsigned long )ptable->func != (unsigned long )((int (*)(struct rtw_adapter * ,
                                                                struct recv_frame * ))0)) {
    tmp = myid(& padapter->eeprompriv);
    tmp___0 = ether_addr_equal((u8 const   *)(& hdr->addr1), (u8 const   *)tmp);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      tmp___2 = is_broadcast_ether_addr((u8 const   *)(& hdr->addr1));
      if (tmp___2) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
      if (tmp___3) {
        return;
      } else {

      }
    } else {

    }
    (*(ptable->func))(padapter, precv_frame);
  } else {

  }
  return;
}
}
void mgt_dispatcher23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_handler *ptable ;
  struct mlme_priv *pmlmepriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct sta_info *psta ;
  u16 stype ;
  int index ;
  int tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  tmp = ieee80211_is_mgmt((int )mgmt->frame_control);
  if (tmp == 0) {
    return;
  } else {

  }
  tmp___0 = myid(& padapter->eeprompriv);
  tmp___1 = ether_addr_equal((u8 const   *)(& mgmt->da), (u8 const   *)tmp___0);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    tmp___3 = is_broadcast_ether_addr((u8 const   *)(& mgmt->da));
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      return;
    } else {

    }
  } else {

  }
  ptable = (struct mlme_handler *)(& mlme_sta_tbl);
  stype = (unsigned int )mgmt->frame_control & 240U;
  index = (int )stype >> 4;
  if (index > 13) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "Currently we do not support reserved sub-fr-type =%d\n", index);
    } else {

    }
    return;
  } else {

  }
  ptable = ptable + (unsigned long )index;
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& mgmt->sa));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    tmp___5 = ieee80211_has_retry((int )mgmt->frame_control);
    if (tmp___5 != 0) {
      if ((int )precv_frame->attrib.seq_num == (int )psta->RxMgmtFrameSeqNum) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: Drop duplicate management frame with seq_num = %d.\n",
                 (int )precv_frame->attrib.seq_num);
        } else {

        }
        return;
      } else {

      }
    } else {

    }
    psta->RxMgmtFrameSeqNum = precv_frame->attrib.seq_num;
  } else {

  }
  switch ((int )stype) {
  case 176: 
  tmp___6 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___6) {
    ptable->func = & OnAuth23a;
  } else {
    ptable->func = & OnAuth23aClient23a;
  }
  case 0: ;
  case 32: 
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
  goto ldv_56058;
  case 64: 
  tmp___7 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___7) {
    _mgt_dispatcher23a(padapter, ptable, precv_frame);
  } else {
    _mgt_dispatcher23a(padapter, ptable, precv_frame);
  }
  goto ldv_56058;
  case 128: 
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
  goto ldv_56058;
  case 208: 
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
  goto ldv_56058;
  default: 
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
  goto ldv_56058;
  }
  ldv_56058: ;
  return;
}
}
static int OnProbeReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 const   *ie ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  int len ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur = & pmlmeinfo->network;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  len = (int )skb->len;
  tmp = check_fwstate(pmlmepriv, 8);
  if ((int )tmp) {
    return (1);
  } else {

  }
  tmp___0 = check_fwstate(pmlmepriv, 1);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    tmp___2 = check_fwstate(pmlmepriv, 80);
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      return (1);
    } else {

    }
  } else {

  }
  tmp___4 = ieee80211_is_probe_req((int )mgmt->frame_control);
  tmp___5 = ldv__builtin_expect(tmp___4 == 0, 0L);
  if (tmp___5 != 0L) {
    printk("\f%s: Received non probe request frame\n", "OnProbeReq23a");
    return (0);
  } else {

  }
  len = (int )((unsigned int )len - 24U);
  ie = cfg80211_find_ie(0, (u8 const   *)(& mgmt->u.probe_req.variable), len);
  if ((unsigned long )ie == (unsigned long )((u8 const   *)0U)) {
    goto out;
  } else {

  }
  if ((unsigned int )((unsigned char )*(ie + 1UL)) != 0U) {
    tmp___6 = memcmp((void const   *)ie + 2U, (void const   *)(& cur->Ssid.ssid),
                     (size_t )cur->Ssid.ssid_len);
    if (tmp___6 != 0) {
      return (1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((unsigned int )((unsigned char )*(ie + 1UL)) == 0U && (unsigned int )pmlmeinfo->hidden_ssid_mode != 0U) {
    return (1);
  } else {

  }
  tmp___7 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___7 && pmlmepriv->cur_network.join_res != 0) {
    issue_probersp(padapter, (unsigned char *)(& mgmt->sa));
  } else {

  }
  out: ;
  return (1);
}
}
static int OnProbeRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  if (pmlmeext->sitesurvey_res.state == 3) {
    report_survey_event23a(padapter, precv_frame);
    return (1);
  } else {

  }
  return (1);
}
}
static int OnBeacon23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  int cam_idx ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  int pkt_len ;
  struct wlan_bssid_ex *pbss ;
  int ret ;
  u8 *p ;
  u8 *pie ;
  int pie_len ;
  u32 ielen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  pkt_len = (int )skb->len;
  ret = 1;
  ielen = 0U;
  pie = (u8 *)(& mgmt->u.beacon.variable);
  pie_len = (int )((unsigned int )pkt_len - 36U);
  p = rtw_get_ie23a(pie, 50, (int *)(& ielen), pie_len);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ielen != 0U) {
    if ((unsigned int )*(p + (unsigned long )(ielen + 1U)) == 45U && (unsigned int )*(p + (unsigned long )(ielen + 2U)) != 45U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: [WIFIDBG] Error in ESR IE is detected in Beacon of BSSID: %pM. Fix the length of ESR IE to avoid failed Beacon parsing.\n",
               (u8 *)(& mgmt->bssid));
      } else {

      }
      *(p + 1UL) = (unsigned int )((u8 )ielen) - 1U;
    } else {

    }
  } else {

  }
  if (pmlmeext->sitesurvey_res.state == 3) {
    report_survey_event23a(padapter, precv_frame);
    return (1);
  } else {

  }
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto out;
  } else {

  }
  if ((pmlmeinfo->state & 256U) != 0U) {
    pbss = collect_bss_info(padapter, precv_frame);
    if ((unsigned long )pbss != (unsigned long )((struct wlan_bssid_ex *)0)) {
      update_network23a(& pmlmepriv->cur_network.network, pbss, padapter, 1);
      rtw_get_bcn_info23a(& pmlmepriv->cur_network);
      kfree((void const   *)pbss);
    } else {

    }
    pmlmeinfo->assoc_AP_vendor = check_assoc_AP23a((u8 *)(& mgmt->u.beacon), (uint )pkt_len - 24U);
    rtw_update_TSF(pmlmeext, mgmt);
    start_clnt_auth(padapter);
    return (1);
  } else {

  }
  if ((pmlmeinfo->state & 3U) == 3U && (pmlmeinfo->state & 16384U) != 0U) {
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      ret = rtw_check_bcn_info23a(padapter, mgmt, (u32 )pkt_len);
      if (ret != 1) {
        if (GlobalDebugLevel23A != 0U) {
          printk("\016RTL8723AU: ap has changed, disconnect now\n");
        } else {

        }
        receive_disconnect23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress),
                              65535);
        return (1);
      } else {

      }
      if ((((psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) & 15ULL) == 0ULL) {
        update_beacon23a_info(padapter, mgmt, (uint )pkt_len, psta);
      } else {

      }
    } else {

    }
  } else
  if ((pmlmeinfo->state & 3U) == 1U) {
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      if ((((psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) & 15ULL) == 0ULL) {
        update_beacon23a_info(padapter, mgmt, (uint )pkt_len, psta);
      } else {

      }
    } else {
      cam_idx = allocate_fw_sta_entry23a(padapter);
      if (cam_idx == 32) {
        goto out;
      } else {

      }
      tmp___2 = update_sta_support_rate23a(padapter, pie, (uint )pie_len, cam_idx);
      if (tmp___2 == 0) {
        pmlmeinfo->FW_sta_info[cam_idx].status = 0U;
        goto out;
      } else {

      }
      rtw_update_TSF(pmlmeext, mgmt);
      report_add_sta_event23a(padapter, (unsigned char *)(& mgmt->sa), cam_idx);
    }
  } else {

  }
  out: ;
  return (1);
}
}
static int OnAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sta_info stat ;
  struct sta_info *pstat ;
  struct sta_priv *pstapriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *pframe ;
  u8 const   *p ;
  unsigned char *sa ;
  u16 auth_mode ;
  u16 seq ;
  u16 algorithm ;
  int status ;
  int len ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  pstat = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  len = (int )skb->len;
  if ((pmlmeinfo->state & 3U) != 3U) {
    return (0);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +OnAuth23a\n");
  } else {

  }
  sa = (unsigned char *)(& mgmt->sa);
  auth_mode = (u16 )psecuritypriv->dot11AuthAlgrthm;
  pframe = (u8 *)(& mgmt->u.auth.variable);
  len = (int )(skb->len - 30U);
  seq = mgmt->u.auth.auth_transaction;
  algorithm = mgmt->u.auth.auth_alg;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: auth alg =%x, seq =%X\n", (int )algorithm, (int )seq);
  } else {

  }
  if (((unsigned int )auth_mode == 2U && psecuritypriv->dot11PrivacyAlgrthm != 1027073U) && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
    auth_mode = 0U;
  } else {

  }
  if (((unsigned int )algorithm != 0U && (unsigned int )auth_mode == 0U) || ((unsigned int )algorithm == 0U && (unsigned int )auth_mode == 1U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: auth rejected due to bad alg [alg =%d, auth_mib =%d] %02X%02X%02X%02X%02X%02X\n",
             (int )algorithm, (int )auth_mode, (int )*sa, (int )*(sa + 1UL), (int )*(sa + 2UL),
             (int )*(sa + 3UL), (int )*(sa + 4UL), (int )*(sa + 5UL));
    } else {

    }
    status = 13;
    goto auth_fail;
  } else {

  }
  tmp = rtw_access_ctrl23a(padapter, sa);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    status = 17;
    goto auth_fail;
  } else {

  }
  pstat = rtw_get_stainfo23a(pstapriv, (u8 const   *)sa);
  if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: going to alloc stainfo for sa =%pM\n", sa);
    } else {

    }
    pstat = rtw_alloc_stainfo23a(pstapriv, (u8 const   *)sa, 32U);
    if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU:  Exceed the upper limit of supported clients...\n");
      } else {

      }
      status = 17;
      goto auth_fail;
    } else {

    }
    pstat->state = 256U;
    pstat->auth_seq = 0U;
  } else {
    spin_lock_bh(& pstapriv->asoc_list_lock);
    tmp___1 = list_empty((struct list_head  const  *)(& pstat->asoc_list));
    if (tmp___1 == 0) {
      list_del_init(& pstat->asoc_list);
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
    } else {

    }
    spin_unlock_bh(& pstapriv->asoc_list_lock);
  }
  spin_lock_bh(& pstapriv->auth_list_lock);
  tmp___2 = list_empty((struct list_head  const  *)(& pstat->auth_list));
  if (tmp___2 != 0) {
    list_add_tail(& pstat->auth_list, & pstapriv->auth_list);
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt + 1);
  } else {

  }
  spin_unlock_bh(& pstapriv->auth_list_lock);
  if (pstat->auth_seq == 0U) {
    pstat->expire_to = pstapriv->auth_to;
  } else {

  }
  if (pstat->auth_seq + 1U != (unsigned int )seq) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: (1)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
             (int )seq, pstat->auth_seq + 1U);
    } else {

    }
    status = 14;
    goto auth_fail;
  } else {

  }
  if ((unsigned int )algorithm == 0U && ((unsigned int )auth_mode == 0U || (unsigned int )auth_mode == 2U)) {
    if ((unsigned int )seq == 1U) {
      pstat->state = pstat->state & 4294967039U;
      pstat->state = pstat->state | 1024U;
      pstat->expire_to = pstapriv->assoc_to;
      pstat->authalg = (unsigned int )algorithm;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: (2)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
               (int )seq, pstat->auth_seq + 1U);
      } else {

      }
      status = 14;
      goto auth_fail;
    }
  } else
  if ((unsigned int )seq == 1U) {
    pstat->state = pstat->state & 4294967039U;
    pstat->state = pstat->state | 512U;
    pstat->authalg = (unsigned int )algorithm;
    pstat->auth_seq = 2U;
  } else
  if ((unsigned int )seq == 3U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: checking for challenging txt...\n");
    } else {

    }
    p = cfg80211_find_ie(16, (u8 const   *)pframe, len);
    if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: auth rejected because challenge failure!(1)\n");
      } else {

      }
      status = 15;
      goto auth_fail;
    } else {

    }
    tmp___3 = memcmp((void const   *)p + 2U, (void const   *)(& pstat->chg_txt), 128UL);
    if (tmp___3 == 0) {
      pstat->state = pstat->state & 4294966783U;
      pstat->state = pstat->state | 1024U;
      pstat->expire_to = pstapriv->assoc_to;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: auth rejected because challenge failure!\n");
      } else {

      }
      status = 15;
      goto auth_fail;
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: (3)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
             (int )seq, pstat->auth_seq + 1U);
    } else {

    }
    status = 14;
    goto auth_fail;
  }
  pstat->auth_seq = (unsigned int )((int )seq + 1);
  issue_auth(padapter, pstat, 0);
  if ((pstat->state & 1024U) != 0U) {
    pstat->auth_seq = 0U;
  } else {

  }
  return (1);
  auth_fail: ;
  if ((unsigned long )pstat != (unsigned long )((struct sta_info *)0)) {
    rtw_free_stainfo23a(padapter, pstat);
  } else {

  }
  pstat = & stat;
  memset((void *)pstat, 0, 5656UL);
  pstat->auth_seq = 2U;
  ether_addr_copy((u8 *)(& pstat->hwaddr), (u8 const   *)sa);
  issue_auth(padapter, pstat, (int )((unsigned short )status));
  return (0);
}
}
static int OnAuth23aClient23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned int seq ;
  unsigned int status ;
  unsigned int algthm ;
  unsigned int go2asoc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 const   *p ;
  u8 *pie ;
  int plen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  go2asoc = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  plen = (int )skb->len;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAuth23aClient23a");
  } else {

  }
  tmp = myid(& padapter->eeprompriv);
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& mgmt->da));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {

  }
  if ((pmlmeinfo->state & 512U) == 0U) {
    return (1);
  } else {

  }
  pie = (u8 *)(& mgmt->u.auth.variable);
  plen = (int )((unsigned int )plen - 30U);
  algthm = (unsigned int )mgmt->u.auth.auth_alg;
  seq = (unsigned int )mgmt->u.auth.auth_transaction;
  status = (unsigned int )mgmt->u.auth.status_code;
  if (status != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: clnt auth fail, status: %d\n", status);
    } else {

    }
    if (status == 13U) {
      if (pmlmeinfo->auth_algo == 1U) {
        pmlmeinfo->auth_algo = 0U;
      } else {
        pmlmeinfo->auth_algo = 1U;
      }
    } else {

    }
    tmp___2 = msecs_to_jiffies(1U);
    ldv_mod_timer_104(& pmlmeext->link_timer, tmp___2 + (unsigned long )jiffies);
    goto authclnt_fail;
  } else {

  }
  if (seq == 2U) {
    if (pmlmeinfo->auth_algo == 1U) {
      p = cfg80211_find_ie(16, (u8 const   *)pie, plen);
      if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
        goto authclnt_fail;
      } else {

      }
      memcpy((void *)(& pmlmeinfo->chg_txt), (void const   *)p + 2U, (size_t )*(p + 1UL));
      pmlmeinfo->auth_seq = 3U;
      issue_auth(padapter, (struct sta_info *)0, 0);
      tmp___3 = msecs_to_jiffies(300U);
      ldv_mod_timer_105(& pmlmeext->link_timer, tmp___3 + (unsigned long )jiffies);
      return (1);
    } else {
      go2asoc = 1U;
    }
  } else
  if (seq == 4U) {
    if (pmlmeinfo->auth_algo == 1U) {
      go2asoc = 1U;
    } else {
      goto authclnt_fail;
    }
  } else {
    goto authclnt_fail;
  }
  if (go2asoc != 0U) {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: auth success, start assoc\n");
    } else {

    }
    start_clnt_assoc(padapter);
    return (1);
  } else {

  }
  authclnt_fail: ;
  return (0);
}
}
static int rtw_validate_vendor_specific_ies(u8 const   *pos , int elen ) 
{ 
  unsigned int oui ;

  {
  if (elen <= 3) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: short vendor specific information element ignored (len =%i)\n",
             elen);
    } else {

    }
    return (-22);
  } else {

  }
  oui = (((unsigned int )*pos << 16) | ((unsigned int )*(pos + 1UL) << 8)) | (unsigned int )*(pos + 2UL);
  switch (oui) {
  case 20722U: ;
  switch ((int )*(pos + 3UL)) {
  case 1: ;
  goto ldv_56147;
  case 2: ;
  if (elen <= 4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: short WME information element ignored (len =%i)\n", elen);
    } else {

    }
    return (-22);
  } else {

  }
  switch ((int )*(pos + 4UL)) {
  case 0: ;
  case 1: ;
  goto ldv_56151;
  case 2: ;
  goto ldv_56151;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: unknown WME information element ignored (subtype =%d len =%i)\n",
           (int )*(pos + 4UL), elen);
  } else {

  }
  return (-22);
  }
  ldv_56151: ;
  goto ldv_56147;
  case 4: ;
  goto ldv_56147;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Unknown Microsoft information element ignored (type =%d len =%i)\n",
           (int )*(pos + 3UL), elen);
  } else {

  }
  return (-22);
  }
  ldv_56147: ;
  goto ldv_56156;
  case 36940U: ;
  switch ((int )*(pos + 3UL)) {
  case 51: ;
  goto ldv_56159;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Unknown Broadcom information element ignored (type =%d len =%i)\n",
           (int )*(pos + 3UL), elen);
  } else {

  }
  return (-22);
  }
  ldv_56159: ;
  goto ldv_56156;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: unknown vendor specific information element ignored (vendor OUI %02x:%02x:%02x len =%i)\n",
           (int )*pos, (int )*(pos + 1UL), (int )*(pos + 2UL), elen);
  } else {

  }
  return (-22);
  }
  ldv_56156: ;
  return (0);
}
}
static int rtw_validate_frame_ies(u8 const   *start , uint len ) 
{ 
  u8 const   *pos ;
  int left ;
  int unknown ;
  u8 id ;
  u8 elen ;
  u8 const   *tmp ;
  u8 const   *tmp___0 ;
  int tmp___1 ;

  {
  pos = start;
  left = (int )len;
  unknown = 0;
  goto ldv_56194;
  ldv_56193: 
  tmp = pos;
  pos = pos + 1;
  id = *tmp;
  tmp___0 = pos;
  pos = pos + 1;
  elen = *tmp___0;
  left = left + -2;
  if ((int )elen > left) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: IEEE 802.11 failed (id =%d elen =%d left =%i)\n",
             "rtw_validate_frame_ies", (int )id, (int )elen, left);
    } else {

    }
    return (-22);
  } else {

  }
  switch ((int )id) {
  case 0: ;
  case 1: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 16: ;
  case 42: ;
  case 50: ;
  goto ldv_56182;
  case 221: 
  tmp___1 = rtw_validate_vendor_specific_ies(pos, (int )elen);
  if (tmp___1 != 0) {
    unknown = unknown + 1;
  } else {

  }
  goto ldv_56182;
  case 48: ;
  case 33: ;
  case 36: ;
  case 54: ;
  case 55: ;
  case 56: ;
  case 45: ;
  case 61: ;
  default: 
  unknown = unknown + 1;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s IEEE 802.11 ignored unknown element (id =%d elen =%d)\n",
           "rtw_validate_frame_ies", (int )id, (int )elen);
  } else {

  }
  goto ldv_56182;
  }
  ldv_56182: 
  left = left - (int )elen;
  pos = pos + (unsigned long )elen;
  ldv_56194: ;
  if (left > 1) {
    goto ldv_56193;
  } else {

  }

  if (left != 0) {
    return (-22);
  } else {

  }
  return (0);
}
}
static int OnAssocReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u16 capab_info ;
  u16 listen_interval ;
  struct sta_info *pstat ;
  unsigned char reassoc ;
  int i ;
  int wpa_ie_len ;
  int left ;
  unsigned char supportRate[16U] ;
  int supportRateNum ;
  unsigned short status ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 const   *pos ;
  u8 const   *p ;
  u8 const   *wpa_ie ;
  u8 const   *wps_ie ;
  u8 *pframe ;
  uint pkt_len ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int group_cipher ;
  int pairwise_cipher ;
  int copy_len ;
  u8 const   *end ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  status = 0U;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur = & pmlmeinfo->network;
  pstapriv = & padapter->stapriv;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  pframe = skb->data;
  pkt_len = skb->len;
  if ((pmlmeinfo->state & 3U) != 3U) {
    return (0);
  } else {

  }
  left = (int )(pkt_len - 24U);
  tmp = ieee80211_is_assoc_req((int )mgmt->frame_control);
  if (tmp != 0) {
    reassoc = 0U;
    pos = (u8 const   *)(& mgmt->u.assoc_req.variable);
    left = (int )((unsigned int )left - 28U);
  } else {
    reassoc = 1U;
    pos = (u8 const   *)(& mgmt->u.reassoc_req.variable);
    left = (int )((unsigned int )left - 34U);
  }
  if (left < 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: handle_assoc(reassoc =%d) - too short payload (len =%lu)\n",
             (int )reassoc, (unsigned long )pkt_len);
    } else {

    }
    return (0);
  } else {

  }
  pstat = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
  if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
    status = 6U;
    goto asoc_class2_error;
  } else {

  }
  capab_info = get_unaligned_le16((void const   *)(& mgmt->u.assoc_req.capab_info));
  listen_interval = get_unaligned_le16((void const   *)(& mgmt->u.assoc_req.listen_interval));
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAssocReq23a");
  } else {

  }
  if ((pstat->state & 1024U) == 0U) {
    if ((pstat->state & 16384U) == 0U) {
      status = 6U;
      goto asoc_class2_error;
    } else {
      pstat->state = pstat->state & 4294950911U;
      pstat->state = pstat->state | 8192U;
    }
  } else {
    pstat->state = pstat->state & 4294966271U;
    pstat->state = pstat->state | 8192U;
  }
  pstat->capability = capab_info;
  tmp___0 = rtw_validate_frame_ies(pos, (uint )left);
  if (tmp___0 != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: STA %pM sent invalid association request\n", (u8 *)(& pstat->hwaddr));
    } else {

    }
    status = 1U;
    goto OnAssocReq23aFail;
  } else {

  }
  p = cfg80211_find_ie(0, pos, left);
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: STA %pM sent invalid association request lacking an SSID\n",
             (u8 *)(& pstat->hwaddr));
    } else {

    }
    status = 1U;
    goto OnAssocReq23aFail;
  } else {
    tmp___1 = memcmp((void const   *)p + 2U, (void const   *)(& cur->Ssid.ssid), (size_t )cur->Ssid.ssid_len);
    if (tmp___1 != 0) {
      status = 1U;
    } else {

    }
    if ((int )((unsigned char )*(p + 1UL)) != (int )cur->Ssid.ssid_len) {
      status = 1U;
    } else {

    }
  }
  if ((unsigned int )status != 0U) {
    goto OnAssocReq23aFail;
  } else {

  }
  p = cfg80211_find_ie(1, pos, left);
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Rx a sta assoc-req which supported rate is empty!\n");
    } else {

    }
    status = 1U;
    goto OnAssocReq23aFail;
  } else {
    memcpy((void *)(& supportRate), (void const   *)p + 2U, (size_t )*(p + 1UL));
    supportRateNum = (int )*(p + 1UL);
    p = cfg80211_find_ie(50, pos, left);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
      if ((unsigned int )supportRateNum <= 16U) {
        memcpy((void *)(& supportRate) + (unsigned long )supportRateNum, (void const   *)p + 2U,
                 (size_t )*(p + 1UL));
        supportRateNum = (int )*(p + 1UL) + supportRateNum;
      } else {

      }
    } else {

    }
  }
  pstat->bssratelen = (u32 )supportRateNum;
  memcpy((void *)(& pstat->bssrateset), (void const   *)(& supportRate), (size_t )supportRateNum);
  Update23aTblForSoftAP((u8 *)(& pstat->bssrateset), pstat->bssratelen);
  pstat->dot8021xalg = 0;
  pstat->wpa_psk = 0;
  pstat->wpa_group_cipher = 0;
  pstat->wpa2_group_cipher = 0;
  pstat->wpa_pairwise_cipher = 0;
  pstat->wpa2_pairwise_cipher = 0;
  memset((void *)(& pstat->wpa_ie), 0, 32UL);
  wpa_ie = cfg80211_find_ie(48, pos, left);
  if ((unsigned long )wpa_ie == (unsigned long )((u8 const   *)0U)) {
    wpa_ie = cfg80211_find_vendor_ie(20722U, 1, pos, left);
  } else {

  }
  if ((unsigned long )wpa_ie != (unsigned long )((u8 const   *)0U)) {
    group_cipher = 0;
    pairwise_cipher = 0;
    wpa_ie_len = (int )*(wpa_ie + 1UL);
    if (((unsigned long )psecuritypriv->wpa_psk & 2UL) != 0UL) {
      r = rtw_parse_wpa2_ie23a(wpa_ie, wpa_ie_len + 2, & group_cipher, & pairwise_cipher,
                               (int *)0);
      if (r == 1) {
        pstat->dot8021xalg = 1;
        pstat->wpa_psk = pstat->wpa_psk | 2;
        pstat->wpa2_group_cipher = (int )(psecuritypriv->wpa2_group_cipher & (unsigned int )group_cipher);
        pstat->wpa2_pairwise_cipher = (int )(psecuritypriv->wpa2_pairwise_cipher & (unsigned int )pairwise_cipher);
      } else {
        status = 40U;
      }
    } else
    if ((int )psecuritypriv->wpa_psk & 1) {
      r = rtw_parse_wpa_ie23a(wpa_ie, wpa_ie_len + 2, & group_cipher, & pairwise_cipher,
                              (int *)0);
      if (r == 1) {
        pstat->dot8021xalg = 1;
        pstat->wpa_psk = pstat->wpa_psk | 1;
        pstat->wpa_group_cipher = (int )(psecuritypriv->wpa_group_cipher & (unsigned int )group_cipher);
        pstat->wpa_pairwise_cipher = (int )(psecuritypriv->wpa_pairwise_cipher & (unsigned int )pairwise_cipher);
      } else {
        status = 40U;
      }
    } else {
      wpa_ie = (u8 const   *)0U;
      wpa_ie_len = 0;
    }
    if ((unsigned long )wpa_ie != (unsigned long )((u8 const   *)0U) && (unsigned int )status == 0U) {
      if (pstat->wpa_group_cipher == 0) {
        status = 41U;
      } else {

      }
      if (pstat->wpa_pairwise_cipher == 0) {
        status = 42U;
      } else {

      }
    } else {

    }
  } else {

  }
  if ((unsigned int )status != 0U) {
    goto OnAssocReq23aFail;
  } else {

  }
  pstat->flags = pstat->flags & -12289;
  wps_ie = cfg80211_find_vendor_ie(20722U, 4, pos, left);
  if ((unsigned long )wpa_ie == (unsigned long )((u8 const   *)0U)) {
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: STA included WPS IE in (Re)Association Request - assume WPS is used\n");
      } else {

      }
      pstat->flags = pstat->flags | 4096;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: STA did not include WPA/RSN IE in (Re)Association Request - possible WPS use\n");
      } else {

      }
      pstat->flags = pstat->flags | 8192;
    }
  } else {
    if (psecuritypriv->wpa_psk == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: STA %pM: WPA/RSN IE in association request, but AP don\'t support WPA/RSN\n",
               (u8 *)(& pstat->hwaddr));
      } else {

      }
      status = 40U;
      goto OnAssocReq23aFail;
    } else {

    }
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: STA included WPS IE in (Re)Association Request - WPS is used\n");
      } else {

      }
      pstat->flags = pstat->flags | 4096;
      copy_len = 0;
    } else {
      copy_len = (int )(32U < (unsigned int )(wpa_ie_len + 2) ? 32U : (unsigned int )(wpa_ie_len + 2));
    }
    if (copy_len > 0) {
      memcpy((void *)(& pstat->wpa_ie), (void const   *)wpa_ie + 0xfffffffffffffffeUL,
               (size_t )copy_len);
    } else {

    }
  }
  pstat->flags = pstat->flags & -513;
  pstat->qos_option = 0U;
  pstat->qos_info = 0U;
  pstat->has_legacy_ac = 1U;
  pstat->uapsd_vo = 0U;
  pstat->uapsd_vi = 0U;
  pstat->uapsd_be = 0U;
  pstat->uapsd_bk = 0U;
  if (pmlmepriv->qos_option != 0U) {
    end = pos + (unsigned long )left;
    p = pos;
    ldv_56233: 
    left = (int )((unsigned int )((long )end) - (unsigned int )((long )p));
    p = cfg80211_find_vendor_ie(20722U, 2, p, left);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
      pstat->flags = pstat->flags | 512;
      pstat->qos_option = 1U;
      pstat->qos_info = *(p + 8UL);
      pstat->max_sp_len = (unsigned int )((u8 )((int )pstat->qos_info >> 5)) & 3U;
      if (((int )pstat->qos_info & 15) != 15) {
        pstat->has_legacy_ac = 1U;
      } else {
        pstat->has_legacy_ac = 0U;
      }
      if (((int )pstat->qos_info & 15) != 0) {
        if ((int )pstat->qos_info & 1) {
          pstat->uapsd_vo = 3U;
        } else {
          pstat->uapsd_vo = 0U;
        }
        if (((unsigned long )pstat->qos_info & 2UL) != 0UL) {
          pstat->uapsd_vi = 3U;
        } else {
          pstat->uapsd_vi = 0U;
        }
        if (((unsigned long )pstat->qos_info & 4UL) != 0UL) {
          pstat->uapsd_bk = 3U;
        } else {
          pstat->uapsd_bk = 0U;
        }
        if (((unsigned long )pstat->qos_info & 8UL) != 0UL) {
          pstat->uapsd_be = 3U;
        } else {
          pstat->uapsd_be = 0U;
        }
        goto ldv_56232;
      } else {

      }
    } else {
      goto ldv_56232;
    }
    p = p + ((unsigned long )*(p + 1UL) + 2UL);
    goto ldv_56233;
    ldv_56232: ;
  } else {

  }
  memset((void *)(& pstat->htpriv.ht_cap), 0, 26UL);
  p = cfg80211_find_ie(45, pos, left);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) > 25U) {
    pstat->flags = pstat->flags | 2048;
    pstat->flags = pstat->flags | 512;
    memcpy((void *)(& pstat->htpriv.ht_cap), (void const   *)p + 2U, 26UL);
  } else {
    pstat->flags = pstat->flags & -2049;
  }
  if (! pmlmepriv->htpriv.ht_option && ((unsigned long )pstat->flags & 2048UL) != 0UL) {
    status = 1U;
    goto OnAssocReq23aFail;
  } else {

  }
  if (((unsigned long )pstat->flags & 2048UL) != 0UL && (((unsigned long )pstat->wpa2_pairwise_cipher & 8UL) != 0UL || ((unsigned long )pstat->wpa_pairwise_cipher & 8UL) != 0UL)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: HT: %pM tried to use TKIP with HT association\n", (u8 *)(& pstat->hwaddr));
    } else {

    }
  } else {

  }
  pstat->flags = (int )((unsigned int )pstat->flags | 2147483648U);
  i = 0;
  goto ldv_56236;
  ldv_56235: ;
  if (((int )pstat->bssrateset[i] & 127) > 22) {
    pstat->flags = pstat->flags & 2147483647;
    goto ldv_56234;
  } else {

  }
  i = i + 1;
  ldv_56236: ;
  if ((u32 )i < pstat->bssratelen) {
    goto ldv_56235;
  } else {

  }
  ldv_56234: ;
  if (((int )pstat->capability & 32) != 0) {
    pstat->flags = pstat->flags | 128;
  } else {
    pstat->flags = pstat->flags & -129;
  }
  if ((unsigned int )status != 0U) {
    goto OnAssocReq23aFail;
  } else {

  }
  if (pstat->aid != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU:   old AID %d\n", pstat->aid);
    } else {

    }
  } else {
    pstat->aid = 1U;
    goto ldv_56239;
    ldv_56238: ;
    if ((unsigned long )pstapriv->sta_aid[pstat->aid - 1U] == (unsigned long )((struct sta_info *)0)) {
      goto ldv_56237;
    } else {

    }
    pstat->aid = pstat->aid + 1U;
    ldv_56239: ;
    if (pstat->aid <= 32U) {
      goto ldv_56238;
    } else {

    }
    ldv_56237: ;
    if (pstat->aid > 32U) {
      pstat->aid = 32U;
    } else {

    }
    if (pstat->aid > (uint )pstapriv->max_num_sta) {
      pstat->aid = 0U;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU:   no room for more AIDs\n");
      } else {

      }
      status = 17U;
      goto OnAssocReq23aFail;
    } else {
      pstapriv->sta_aid[pstat->aid - 1U] = pstat;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: allocate new AID = (%d)\n", pstat->aid);
      } else {

      }
    }
  }
  pstat->state = pstat->state & 4294959103U;
  pstat->state = pstat->state | 16384U;
  spin_lock_bh(& pstapriv->auth_list_lock);
  tmp___2 = list_empty((struct list_head  const  *)(& pstat->auth_list));
  if (tmp___2 == 0) {
    list_del_init(& pstat->auth_list);
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
  } else {

  }
  spin_unlock_bh(& pstapriv->auth_list_lock);
  spin_lock_bh(& pstapriv->asoc_list_lock);
  tmp___3 = list_empty((struct list_head  const  *)(& pstat->asoc_list));
  if (tmp___3 != 0) {
    pstat->expire_to = pstapriv->expire_to;
    list_add_tail(& pstat->asoc_list, & pstapriv->asoc_list);
    pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt + 1);
  } else {

  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  if (((unsigned long )pstat != (unsigned long )((struct sta_info *)0) && (pstat->state & 16384U) != 0U) && (unsigned int )status == 0U) {
    bss_cap_update_on_sta_join23a(padapter, pstat);
    sta_info_update23a(padapter, pstat);
    tmp___4 = ieee80211_is_assoc_req((int )mgmt->frame_control);
    if (tmp___4 != 0) {
      issue_assocrsp(padapter, (int )status, pstat, 16);
    } else {
      issue_assocrsp(padapter, (int )status, pstat, 48);
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: indicate_sta_join_event to upper layer - hostapd\n");
    } else {

    }
    rtw_cfg80211_indicate_sta_assoc(padapter, pframe, pkt_len);
    report_add_sta_event23a(padapter, (unsigned char *)(& pstat->hwaddr), (int )pstat->aid);
  } else {

  }
  return (1);
  asoc_class2_error: 
  issue_deauth23a(padapter, (unsigned char *)(& mgmt->sa), (int )status);
  return (0);
  OnAssocReq23aFail: 
  pstat->aid = 0U;
  tmp___5 = ieee80211_is_assoc_req((int )mgmt->frame_control);
  if (tmp___5 != 0) {
    issue_assocrsp(padapter, (int )status, pstat, 16);
  } else {
    issue_assocrsp(padapter, (int )status, pstat, 48);
  }
  return (0);
}
}
static int OnAssocRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *pmgmt ;
  int res ;
  unsigned short status ;
  u8 const   *p ;
  u8 const   *pie ;
  u8 *pframe ;
  int pkt_len ;
  int pielen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u16 tmp___2 ;
  void *tmp___3 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  pmgmt = (struct ieee80211_mgmt *)skb->data;
  pframe = skb->data;
  pkt_len = (int )skb->len;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAssocRsp23a");
  } else {

  }
  tmp = myid(& padapter->eeprompriv);
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& pmgmt->da));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {

  }
  if ((pmlmeinfo->state & 9216U) == 0U) {
    return (1);
  } else {

  }
  if ((pmlmeinfo->state & 16384U) != 0U) {
    return (1);
  } else {

  }
  ldv_del_timer_sync_106(& pmlmeext->link_timer);
  status = pmgmt->u.assoc_resp.status_code;
  if ((unsigned int )status != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: assoc reject, status code: %d\n", (int )status);
    } else {

    }
    pmlmeinfo->state = 0U;
    res = -4;
    goto report_assoc_result;
  } else {

  }
  pmlmeinfo->capability = pmgmt->u.assoc_resp.capab_info;
  pmlmeinfo->slotTime = ((unsigned long )pmlmeinfo->capability & 1024UL) != 0UL ? 9U : 20U;
  tmp___2 = (unsigned int )pmgmt->u.assoc_resp.aid & 16383U;
  pmlmeinfo->aid = tmp___2;
  res = (int )tmp___2;
  pie = (u8 const   *)pframe + 30U;
  pielen = (int )((unsigned int )pkt_len - 30U);
  p = cfg80211_find_ie(45, (u8 const   *)(& pmgmt->u.assoc_resp.variable), pielen);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    HT_caps_handler23a(padapter, p);
  } else {

  }
  p = cfg80211_find_ie(61, (u8 const   *)(& pmgmt->u.assoc_resp.variable), pielen);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    HT_info_handler23a(padapter, p);
  } else {

  }
  p = cfg80211_find_ie(42, (u8 const   *)(& pmgmt->u.assoc_resp.variable), pielen);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    ERP_IE_handler23a(padapter, p);
  } else {

  }
  pie = (u8 const   *)pframe + 30U;
  ldv_56260: 
  p = cfg80211_find_vendor_ie(20722U, 2, pie, (int )((unsigned int )((long )(pframe + (unsigned long )pkt_len)) - (unsigned int )((long )pie)));
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
    goto ldv_56258;
  } else {

  }
  pie = p + ((unsigned long )*(p + 1UL) + 2UL);
  if ((unsigned int )((unsigned char )*(p + 1UL)) <= 4U) {
    goto ldv_56259;
  } else {

  }
  if ((unsigned int )((unsigned char )*(p + 6UL)) == 1U) {
    goto ldv_56258;
  } else {

  }
  ldv_56259: ;
  goto ldv_56260;
  ldv_56258: ;
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    WMM_param_handler23a(padapter, p);
  } else {

  }
  pmlmeinfo->state = pmlmeinfo->state & 4294959103U;
  pmlmeinfo->state = pmlmeinfo->state | 16384U;
  UpdateBrateTbl23a(padapter, (u8 *)(& pmlmeinfo->network.SupportedRates));
  report_assoc_result: 
  pmlmepriv->assoc_rsp_len = 0U;
  if (res > 0) {
    kfree((void const   *)pmlmepriv->assoc_rsp);
    tmp___3 = kmalloc((size_t )pkt_len, 32U);
    pmlmepriv->assoc_rsp = (u8 *)tmp___3;
    if ((unsigned long )pmlmepriv->assoc_rsp != (unsigned long )((u8 *)0U)) {
      memcpy((void *)pmlmepriv->assoc_rsp, (void const   *)pframe, (size_t )pkt_len);
      pmlmepriv->assoc_rsp_len = (u32 )pkt_len;
    } else {

    }
  } else {
    kfree((void const   *)pmlmepriv->assoc_rsp);
  }
  report_join_res23a(padapter, res);
  return (1);
}
}
static int OnDeAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned short reason ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 updated ;
  int tmp___2 ;
  bool tmp___3 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {

  }
  reason = mgmt->u.deauth.reason_code;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s Reason code(%d)\n", "OnDeAuth23a", (int )reason);
  } else {

  }
  tmp___3 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___3) {
    pstapriv = & padapter->stapriv;
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: ap recv deauth reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->sa));
    } else {

    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      updated = 0U;
      spin_lock_bh(& pstapriv->asoc_list_lock);
      tmp___2 = list_empty((struct list_head  const  *)(& psta->asoc_list));
      if (tmp___2 == 0) {
        list_del_init(& psta->asoc_list);
        pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
        updated = ap_free_sta23a(padapter, psta, 0, (int )reason);
      } else {

      }
      spin_unlock_bh(& pstapriv->asoc_list_lock);
      associated_clients_update23a(padapter, (int )updated);
    } else {

    }
    return (1);
  } else {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: sta recv deauth reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->bssid));
    } else {

    }
    receive_disconnect23a(padapter, (unsigned char *)(& mgmt->bssid), (int )reason);
  }
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
  return (1);
}
}
static int OnDisassoc23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned short reason ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 updated ;
  int tmp___2 ;
  bool tmp___3 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {

  }
  reason = mgmt->u.disassoc.reason_code;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s Reason code(%d)\n", "OnDisassoc23a", (int )reason);
  } else {

  }
  tmp___3 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___3) {
    pstapriv = & padapter->stapriv;
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: ap recv disassoc reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->sa));
    } else {

    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      updated = 0U;
      spin_lock_bh(& pstapriv->asoc_list_lock);
      tmp___2 = list_empty((struct list_head  const  *)(& psta->asoc_list));
      if (tmp___2 == 0) {
        list_del_init(& psta->asoc_list);
        pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
        updated = ap_free_sta23a(padapter, psta, 0, (int )reason);
      } else {

      }
      spin_unlock_bh(& pstapriv->asoc_list_lock);
      associated_clients_update23a(padapter, (int )updated);
    } else {

    }
    return (1);
  } else {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: ap recv disassoc reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->bssid));
    } else {

    }
    receive_disconnect23a(padapter, (unsigned char *)(& mgmt->bssid), (int )reason);
  }
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
  return (1);
}
}
static int OnAtim23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAtim23a");
  } else {

  }
  return (1);
}
}
static int on_action_spct23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
  return (0);
}
}
static int OnAction23a_qos(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
  return (1);
}
}
static int OnAction23a_dls(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
  return (1);
}
}
static int OnAction23a_back23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 *addr ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  unsigned char category ;
  unsigned char action ;
  unsigned short tid ;
  unsigned short status ;
  unsigned short capab ;
  unsigned short params ;
  unsigned short reason_code ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct sta_priv *pstapriv ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  psta = (struct sta_info *)0;
  reason_code = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  pstapriv = & padapter->stapriv;
  tmp = myid(& padapter->eeprompriv);
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& mgmt->da));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAction23a_back23a");
  } else {

  }
  if ((pmlmeinfo->state & 3U) != 3U) {
    if ((pmlmeinfo->state & 16384U) == 0U) {
      return (1);
    } else {

    }
  } else {

  }
  addr = (u8 *)(& mgmt->sa);
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (1);
  } else {

  }
  category = mgmt->u.action.category;
  if ((unsigned int )category == 3U) {
    if ((unsigned int )pmlmeinfo->HT_enable == 0U) {
      return (1);
    } else {

    }
    action = mgmt->u.action.u.wme_action.action_code;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, action =%d\n", "OnAction23a_back23a", (int )action);
    } else {

    }
    switch ((int )action) {
    case 0: 
    memcpy((void *)(& pmlmeinfo->ADDBA_req), (void const   *)(& mgmt->u.action.u.addba_req.dialog_token),
             7UL);
    process_addba_req23a(padapter, (u8 *)(& pmlmeinfo->ADDBA_req), addr);
    if ((int )pmlmeinfo->bAcceptAddbaReq) {
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 1, 0);
    } else {
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 1, 37);
    }
    goto ldv_56327;
    case 1: 
    status = get_unaligned_le16((void const   *)(& mgmt->u.action.u.addba_resp.status));
    capab = get_unaligned_le16((void const   *)(& mgmt->u.action.u.addba_resp.capab));
    tid = (unsigned short )(((int )capab & 60) >> 2);
    if ((unsigned int )status == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: agg_enable for TID =%d\n", (int )tid);
      } else {

      }
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap | (int )((u16 )(1UL << (int )tid));
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    } else {
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    }
    goto ldv_56327;
    case 2: 
    params = get_unaligned_le16((void const   *)(& mgmt->u.action.u.delba.params));
    tid = (int )params >> 12;
    if (((int )params & 2048) != 0) {
      preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )tid;
      preorder_ctrl->enable = 0U;
      preorder_ctrl->indicate_seq = 65535U;
    } else {
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    }
    reason_code = get_unaligned_le16((void const   *)(& mgmt->u.action.u.delba.reason_code));
    goto ldv_56327;
    default: ;
    goto ldv_56327;
    }
    ldv_56327: ;
  } else {

  }
  return (1);
}
}
static int on_action_public23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 *pframe ;
  int freq ;
  int channel ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u8 tmp___2 ;
  bool tmp___3 ;

  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  pframe = skb->data;
  tmp = myid(& padapter->eeprompriv);
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& hdr->addr1));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  tmp___2 = rtw_get_oper_ch23a(padapter);
  channel = (int )tmp___2;
  if (channel <= 14) {
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
  tmp___3 = cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const   *)pframe, (size_t )skb->len,
                             0U);
  if ((int )tmp___3) {
    return (1);
  } else {

  }
  return (0);
}
}
static int OnAction23a_ht(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
  return (1);
}
}
static int OnAction23a_wmm(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
  return (1);
}
}
static int OnAction23a_p2p(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
  return (1);
}
}
static int OnAction23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  int i ;
  u8 category ;
  struct action_handler *ptable ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;

  {
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  category = mgmt->u.action.category;
  i = 0;
  goto ldv_56362;
  ldv_56361: 
  ptable = (struct action_handler *)(& OnAction23a_tbl) + (unsigned long )i;
  if ((unsigned int )category == ptable->num) {
    (*(ptable->func))(padapter, precv_frame);
  } else {

  }
  i = i + 1;
  ldv_56362: ;
  if ((unsigned int )i <= 8U) {
    goto ldv_56361;
  } else {

  }

  return (1);
}
}
static int DoReserved23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
  return (1);
}
}
struct xmit_frame *alloc_mgtxmitframe23a(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct xmit_buf *pxmitbuf ;

  {
  pmgntframe = rtw_alloc_xmitframe23a_ext(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): alloc xmitframe fail\n", "alloc_mgtxmitframe23a",
             (char *)(& ((pxmitpriv->adapter)->pnetdev)->name));
    } else {

    }
    goto exit;
  } else {

  }
  pxmitbuf = rtw_alloc_xmitbuf23a_ext(pxmitpriv);
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): alloc xmitbuf fail\n", "alloc_mgtxmitframe23a",
             (char *)(& ((pxmitpriv->adapter)->pnetdev)->name));
    } else {

    }
    rtw_free_xmitframe23a(pxmitpriv, pmgntframe);
    pmgntframe = (struct xmit_frame *)0;
    goto exit;
  } else {

  }
  pmgntframe->frame_tag = 3;
  pmgntframe->pxmitbuf = pxmitbuf;
  pmgntframe->buf_addr = pxmitbuf->pbuf;
  pxmitbuf->priv_data = (void *)pmgntframe;
  exit: ;
  return (pmgntframe);
}
}
void update_mgnt_tx_rate23a(struct rtw_adapter *padapter , u8 rate ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeext->tx_rate = rate;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(): rate = %x\n", "update_mgnt_tx_rate23a", (int )rate);
  } else {

  }
  return;
}
}
void update_mgntframe_attrib23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  memset((void *)pattrib, 0, 112UL);
  pattrib->hdrlen = 24U;
  pattrib->nr_frags = 1U;
  pattrib->priority = 7U;
  pattrib->mac_id = 0U;
  pattrib->qsel = 18U;
  pattrib->pktlen = 0U;
  if ((int )pmlmeext->cur_wireless_mode & 1) {
    pattrib->raid = 6U;
  } else {
    pattrib->raid = 5U;
  }
  pattrib->encrypt = 0U;
  pattrib->bswenc = 0U;
  pattrib->qos_en = 0U;
  pattrib->ht_en = 0U;
  pattrib->bwmode = 0U;
  pattrib->ch_offset = 0U;
  pattrib->sgi = 0U;
  pattrib->seqnum = pmlmeext->mgnt_seq;
  pattrib->retry_ctrl = 1U;
  return;
}
}
void dump_mgntframe23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 


  {
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
    return;
  } else {

  }
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
  return;
}
}
s32 dump_mgntframe23a_and_wait(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ,
                               int timeout_ms ) 
{ 
  int ret ;
  unsigned long irqL ;
  struct xmit_priv *pxmitpriv ;
  struct xmit_buf *pxmitbuf ;
  struct submit_ctx sctx ;
  raw_spinlock_t *tmp ;

  {
  ret = 0;
  pxmitpriv = & padapter->xmitpriv;
  pxmitbuf = pmgntframe->pxmitbuf;
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
    return (ret);
  } else {

  }
  rtw_sctx_init23a(& sctx, timeout_ms);
  pxmitbuf->sctx = & sctx;
  ret = rtl8723au_mgnt_xmit(padapter, pmgntframe);
  if (ret == 1) {
    ret = rtw_sctx_wait23a(& sctx);
  } else {

  }
  tmp = spinlock_check(& pxmitpriv->lock_sctx);
  irqL = _raw_spin_lock_irqsave(tmp);
  pxmitbuf->sctx = (struct submit_ctx *)0;
  spin_unlock_irqrestore(& pxmitpriv->lock_sctx, irqL);
  return (ret);
}
}
s32 dump_mgntframe23a_and_wait_ack23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 
  int ret ;
  u32 timeout_ms ;
  struct xmit_priv *pxmitpriv ;
  int tmp ;

  {
  ret = 0;
  timeout_ms = 500U;
  pxmitpriv = & padapter->xmitpriv;
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
    return (0);
  } else {

  }
  mutex_lock_nested(& pxmitpriv->ack_tx_mutex, 0U);
  pxmitpriv->ack_tx = 1;
  pmgntframe->ack_report = 1U;
  tmp = rtl8723au_mgnt_xmit(padapter, pmgntframe);
  if (tmp == 1) {
    ret = rtw_ack_tx_wait23a(pxmitpriv, timeout_ms);
  } else {

  }
  pxmitpriv->ack_tx = 0;
  mutex_unlock(& pxmitpriv->ack_tx_mutex);
  return (ret);
}
}
static int update_hidden_ssid(u8 *ies , u32 ies_len , u8 hidden_ssid_mode ) 
{ 
  u8 *ssid_ie ;
  int ssid_len_ori ;
  int len_diff ;
  u8 *next_ie ;
  u32 remain_len ;

  {
  len_diff = 0;
  ssid_ie = rtw_get_ie23a(ies, 0, & ssid_len_ori, (int )ies_len);
  if ((unsigned long )ssid_ie != (unsigned long )((u8 *)0U) && ssid_len_ori > 0) {
    switch ((int )hidden_ssid_mode) {
    case 1: 
    next_ie = ssid_ie + ((unsigned long )ssid_len_ori + 2UL);
    remain_len = ((u32 )((long )ies) - (u32 )((long )next_ie)) + ies_len;
    *(ssid_ie + 1UL) = 0U;
    memcpy((void *)ssid_ie + 2U, (void const   *)next_ie, (size_t )remain_len);
    len_diff = len_diff - ssid_len_ori;
    goto ldv_56421;
    case 2: 
    memset((void *)ssid_ie + 2U, 0, (size_t )ssid_len_ori);
    goto ldv_56421;
    default: ;
    goto ldv_56421;
    }
    ldv_56421: ;
  } else {

  }
  return (len_diff);
}
}
void issue_beacon23a(struct rtw_adapter *padapter , int timeout_ms ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_mgmt *mgmt ;
  unsigned int rate_len ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 bc_addr___0[6U] ;
  u8 const   *wps_ie ;
  u8 sr ;
  int len_diff ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *iebuf ;
  int buflen ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 erpinfo ;
  u32 ATIMWindow ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  bc_addr___0[0] = 255U;
  bc_addr___0[1] = 255U;
  bc_addr___0[2] = 255U;
  bc_addr___0[3] = 255U;
  bc_addr___0[4] = 255U;
  bc_addr___0[5] = 255U;
  sr = 0U;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, alloc mgnt frame fail\n", "issue_beacon23a");
    } else {

    }
    return;
  } else {

  }
  spin_lock_bh(& pmlmepriv->bcn_update_lock);
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->qsel = 16U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  mgmt = (struct ieee80211_mgmt *)pframe;
  mgmt->frame_control = 128U;
  mgmt->seq_ctrl = 0U;
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)(& bc_addr___0));
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
  tmp___0 = get_my_bssid23a(cur_network);
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
  put_unaligned_le16((int )cur_network->beacon_interval, (void *)(& mgmt->u.beacon.beacon_int));
  put_unaligned_le16((int )cur_network->capability, (void *)(& mgmt->u.beacon.capab_info));
  pframe = (unsigned char *)(& mgmt->u.beacon.variable);
  pattrib->pktlen = 36U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    memcpy((void *)pframe, (void const   *)(& cur_network->IEs), (size_t )cur_network->IELength);
    len_diff = update_hidden_ssid(pframe, cur_network->IELength, (int )pmlmeinfo->hidden_ssid_mode);
    pframe = pframe + (unsigned long )(cur_network->IELength + (u32 )len_diff);
    pattrib->pktlen = pattrib->pktlen + (cur_network->IELength + (u32 )len_diff);
    iebuf = (u8 *)(& mgmt->u.beacon.variable);
    buflen = (int )(pattrib->pktlen - 36U);
    wps_ie = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)iebuf, buflen);
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(wps_ie + 1UL)) != 0U) {
      rtw_get_wps_attr_content23a(wps_ie, (uint )*(wps_ie + 1UL), 4161, & sr);
    } else {

    }
    if ((unsigned int )sr != 0U) {
      set_fwstate(pmlmepriv, 256);
    } else {
      _clr_fwstate_(pmlmepriv, 256);
    }
    goto _issue_bcn;
  } else {

  }
  tmp___1 = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                          & pattrib->pktlen);
  pframe = tmp___1;
  rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  tmp___2 = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                          & pattrib->pktlen);
  pframe = tmp___2;
  tmp___3 = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig),
                          & pattrib->pktlen);
  pframe = tmp___3;
  erpinfo = 0U;
  ATIMWindow = 0U;
  tmp___4 = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pattrib->pktlen);
  pframe = tmp___4;
  tmp___5 = rtw_set_ie23a(pframe, 42, 1U, (u8 const   *)(& erpinfo), & pattrib->pktlen);
  pframe = tmp___5;
  if (rate_len > 8U) {
    tmp___6 = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                            & pattrib->pktlen);
    pframe = tmp___6;
  } else {

  }
  _issue_bcn: 
  pmlmepriv->update_bcn = 0U;
  spin_unlock_bh(& pmlmepriv->bcn_update_lock);
  if (pattrib->pktlen + 32U > 512U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: beacon frame too large\n");
    } else {

    }
    return;
  } else {

  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  if (timeout_ms > 0) {
    dump_mgntframe23a_and_wait(padapter, pmgntframe, timeout_ms);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
  }
  return;
}
}
static void issue_probersp(struct rtw_adapter *padapter , unsigned char *da ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_mgmt *mgmt ;
  unsigned char *mac ;
  unsigned char *bssid ;
  struct xmit_priv *pxmitpriv ;
  u8 const   *pwps_ie ;
  u8 *ssid_ie ;
  int ssid_ielen ;
  int ssid_ielen_diff ;
  u8 buf[768U] ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  unsigned int rate_len ;
  u8 *tmp ;
  uint remainder_ielen ;
  u8 *remainder_ie ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 erpinfo ;
  u32 ATIMWindow ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  if (cur_network->IELength > 768U) {
    return;
  } else {

  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, alloc mgnt frame fail\n", "issue_probersp");
    } else {

    }
    return;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  mgmt = (struct ieee80211_mgmt *)pframe;
  tmp = myid(& padapter->eeprompriv);
  mac = tmp;
  bssid = (unsigned char *)(& cur_network->MacAddress);
  mgmt->frame_control = 80U;
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)da);
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)mac);
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)bssid);
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pattrib->hdrlen = 24U;
  put_unaligned_le16((int )cur_network->beacon_interval, (void *)(& mgmt->u.probe_resp.beacon_int));
  put_unaligned_le16((int )cur_network->capability, (void *)(& mgmt->u.probe_resp.capab_info));
  pframe = (unsigned char *)(& mgmt->u.probe_resp.variable);
  pattrib->pktlen = 36U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    pwps_ie = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)(& cur_network->IEs),
                                      (int )cur_network->IELength);
    memcpy((void *)pframe, (void const   *)(& cur_network->IEs), (size_t )cur_network->IELength);
    pframe = pframe + (unsigned long )cur_network->IELength;
    pattrib->pktlen = pattrib->pktlen + cur_network->IELength;
    ssid_ie = rtw_get_ie23a((u8 *)(& mgmt->u.probe_resp.variable), 0, & ssid_ielen,
                            (int )((unsigned int )((long )pframe) - (unsigned int )((long )(& mgmt->u.probe_resp.variable))));
    ssid_ielen_diff = (int )cur_network->Ssid.ssid_len - ssid_ielen;
    if ((unsigned long )ssid_ie != (unsigned long )((u8 *)0U) && (unsigned int )cur_network->Ssid.ssid_len != 0U) {
      remainder_ie = ssid_ie + 2UL;
      remainder_ielen = (uint )((long )pframe) - (uint )((long )remainder_ie);
      if (GlobalDebugLevel23A > 4U) {
        printk("\016RTL8723AU: %s(%s): remainder_ielen > MAX_IE_SZ\n", "issue_probersp",
               (char *)(& (padapter->pnetdev)->name));
      } else {

      }
      if (remainder_ielen > 768U) {
        remainder_ielen = 768U;
      } else {

      }
      memcpy((void *)(& buf), (void const   *)remainder_ie, (size_t )remainder_ielen);
      memcpy((void *)remainder_ie + (unsigned long )ssid_ielen_diff, (void const   *)(& buf),
               (size_t )remainder_ielen);
      *(ssid_ie + 1UL) = cur_network->Ssid.ssid_len;
      memcpy((void *)ssid_ie + 2U, (void const   *)(& cur_network->Ssid.ssid), (size_t )cur_network->Ssid.ssid_len);
      pframe = pframe + (unsigned long )ssid_ielen_diff;
      pattrib->pktlen = pattrib->pktlen + (u32 )ssid_ielen_diff;
    } else {

    }
  } else {
    tmp___0 = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                            & pattrib->pktlen);
    pframe = tmp___0;
    rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
    tmp___1 = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                            & pattrib->pktlen);
    pframe = tmp___1;
    tmp___2 = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig),
                            & pattrib->pktlen);
    pframe = tmp___2;
    if ((pmlmeinfo->state & 3U) == 1U) {
      erpinfo = 0U;
      ATIMWindow = 0U;
      tmp___3 = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pattrib->pktlen);
      pframe = tmp___3;
      tmp___4 = rtw_set_ie23a(pframe, 42, 1U, (u8 const   *)(& erpinfo), & pattrib->pktlen);
      pframe = tmp___4;
    } else {

    }
    if (rate_len > 8U) {
      tmp___5 = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                              & pattrib->pktlen);
      pframe = tmp___5;
    } else {

    }
  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
static int _issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                           u8 *da , int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned char *mac ;
  unsigned char bssrate[13U] ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int bssrate_len ;
  u8 bc_addr___0[6U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;

  {
  ret = 0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  bssrate_len = 0;
  bc_addr___0[0] = 255U;
  bc_addr___0[1] = 255U;
  bc_addr___0[2] = 255U;
  bc_addr___0[3] = 255U;
  bc_addr___0[4] = 255U;
  bc_addr___0[5] = 255U;
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(16, 6, "+%s\n", "_issue_probereq");
  } else {

  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  tmp = myid(& padapter->eeprompriv);
  mac = tmp;
  pwlanhdr->frame_control = 64U;
  if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)da);
  } else {
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& bc_addr___0));
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& bc_addr___0));
  }
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)mac);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  if ((unsigned long )pssid != (unsigned long )((struct cfg80211_ssid *)0)) {
    tmp___0 = rtw_set_ie23a(pframe, 0, (uint )pssid->ssid_len, (u8 const   *)(& pssid->ssid),
                            & pattrib->pktlen);
    pframe = tmp___0;
  } else {
    tmp___1 = rtw_set_ie23a(pframe, 0, 0U, (u8 const   *)0U, & pattrib->pktlen);
    pframe = tmp___1;
  }
  get_rate_set23a(padapter, (unsigned char *)(& bssrate), & bssrate_len);
  if (bssrate_len > 8) {
    tmp___2 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& bssrate), & pattrib->pktlen);
    pframe = tmp___2;
    tmp___3 = rtw_set_ie23a(pframe, 50, (uint )(bssrate_len + -8), (u8 const   *)(& bssrate) + 8U,
                            & pattrib->pktlen);
    pframe = tmp___3;
  } else {
    tmp___4 = rtw_set_ie23a(pframe, 1, (uint )bssrate_len, (u8 const   *)(& bssrate),
                            & pattrib->pktlen);
    pframe = tmp___4;
  }
  if (pmlmepriv->wps_probe_req_ie_len != 0U && (unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
    memcpy((void *)pframe, (void const   *)pmlmepriv->wps_probe_req_ie, (size_t )pmlmepriv->wps_probe_req_ie_len);
    pframe = pframe + (unsigned long )pmlmepriv->wps_probe_req_ie_len;
    pattrib->pktlen = pattrib->pktlen + pmlmepriv->wps_probe_req_ie_len;
  } else {

  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(16, 6, "issuing probe_req, tx_len =%d\n", pattrib->last_txcmdsz);
  } else {

  }
  if (wait_ack != 0) {
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
    ret = 1;
  }
  exit: ;
  return (ret);
}
}
__inline static void issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                    u8 *da ) 
{ 


  {
  _issue_probereq(padapter, pssid, da, 0);
  return;
}
}
static int issue_probereq_ex(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                             u8 *da , int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  unsigned int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u8 tmp___2 ;

  {
  i = 0;
  start = jiffies;
  ldv_56509: 
  ret = _issue_probereq(padapter, pssid, da, wait_ms > 0);
  i = i + 1;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto ldv_56508;
  } else {

  }
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
    msleep((unsigned int )wait_ms);
  } else {

  }
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
    goto ldv_56509;
  } else {

  }
  ldv_56508: ;
  if (ret != 0) {
    ret = 1;
    goto exit;
  } else {

  }
  if (try_cnt != 0 && wait_ms != 0) {
    if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        tmp = jiffies_to_msecs((unsigned long )jiffies - start);
        tmp___0 = rtw_get_oper_ch23a(padapter);
        printk("\016RTL8723AU: %s(%s): to %pM, ch:%u%s, %d/%d in %u ms\n", "issue_probereq_ex",
               (char *)(& (padapter->pnetdev)->name), da, (int )tmp___0, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp);
      } else {

      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      tmp___1 = jiffies_to_msecs((unsigned long )jiffies - start);
      tmp___2 = rtw_get_oper_ch23a(padapter);
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_probereq_ex",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___2, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___1);
    } else {

    }
  } else {

  }
  exit: ;
  return (ret);
}
}
static void issue_auth(struct rtw_adapter *padapter , struct sta_info *psta , unsigned short status ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_mgmt *mgmt ;
  unsigned int val32 ;
  u16 auth_algo ;
  int use_shared_key ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned short val16 ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  struct ieee80211_mgmt *iv_mgmt ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u32 *piv ;
  u8 *tmp___5 ;

  {
  use_shared_key = 0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  mgmt = (struct ieee80211_mgmt *)pframe;
  mgmt->frame_control = 176U;
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pattrib->pktlen = 30U;
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)(& psta->hwaddr));
    tmp = myid(& padapter->eeprompriv);
    ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
    tmp___0 = myid(& padapter->eeprompriv);
    ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
    val16 = (unsigned short )psta->authalg;
    if ((unsigned int )status != 0U) {
      val16 = 0U;
    } else {

    }
    if ((unsigned int )val16 != 0U) {
      use_shared_key = 1;
    } else {

    }
    mgmt->u.auth.auth_alg = val16;
    mgmt->u.auth.auth_transaction = (unsigned short )psta->auth_seq;
    mgmt->u.auth.status_code = status;
    pframe = (unsigned char *)(& mgmt->u.auth.variable);
    if ((psta->auth_seq == 2U && (psta->state & 512U) != 0U) && use_shared_key == 1) {
      tmp___1 = rtw_set_ie23a(pframe, 16, 128U, (u8 const   *)(& psta->chg_txt), & pattrib->pktlen);
      pframe = tmp___1;
    } else {

    }
  } else {
    tmp___2 = get_my_bssid23a(& pmlmeinfo->network);
    ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)tmp___2);
    tmp___3 = myid(& padapter->eeprompriv);
    ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp___3);
    tmp___4 = get_my_bssid23a(& pmlmeinfo->network);
    ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___4);
    if (pmlmeinfo->auth_algo == 1U) {
      use_shared_key = 1;
      auth_algo = 1U;
    } else {
      auth_algo = 0U;
    }
    if ((pmlmeinfo->auth_seq == 3U && (pmlmeinfo->state & 512U) != 0U) && use_shared_key == 1) {
      piv = (u32 *)(& mgmt->u.auth);
      iv_mgmt = (struct ieee80211_mgmt *)pframe + 4U;
      val32 = (pmlmeinfo->iv & 1073741823U) | (pmlmeinfo->key_index << 30);
      pmlmeinfo->iv = pmlmeinfo->iv + 1U;
      put_unaligned_le32(val32, (void *)piv);
      pattrib->pktlen = pattrib->pktlen + 4U;
      pattrib->iv_len = 4U;
    } else {
      iv_mgmt = mgmt;
    }
    iv_mgmt->u.auth.auth_alg = auth_algo;
    iv_mgmt->u.auth.auth_transaction = (unsigned short )pmlmeinfo->auth_seq;
    iv_mgmt->u.auth.status_code = status;
    pframe = (unsigned char *)(& iv_mgmt->u.auth.variable);
    if ((pmlmeinfo->auth_seq == 3U && (pmlmeinfo->state & 512U) != 0U) && use_shared_key == 1) {
      tmp___5 = rtw_set_ie23a(pframe, 16, 128U, (u8 const   *)(& pmlmeinfo->chg_txt),
                              & pattrib->pktlen);
      pframe = tmp___5;
      mgmt->frame_control = (__le16 )((unsigned int )mgmt->frame_control | 16384U);
      pattrib->hdrlen = 24U;
      pattrib->encrypt = 1027073U;
      pattrib->icv_len = 4U;
      pattrib->pktlen = pattrib->pktlen + (u32 )pattrib->icv_len;
    } else {

    }
  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  rtw_wep_encrypt23a(padapter, pmgntframe);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "issue_auth");
  } else {

  }
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
static void issue_assocrsp(struct rtw_adapter *padapter , unsigned short status ,
                           struct sta_info *pstat , u16 pkt_type ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct ieee80211_mgmt *mgmt ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  u8 const   *p ;
  u8 *ie ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  unsigned char WMM_PARA_IE[6U] ;
  int ie_len ;
  int tmp___4 ;
  u8 *tmp___5 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  ie = (u8 *)(& pnetwork->IEs);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "issue_assocrsp");
  } else {

  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  mgmt = (struct ieee80211_mgmt *)pframe;
  mgmt->frame_control = pkt_type;
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)(& pstat->hwaddr));
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pattrib->hdrlen = 24U;
  pattrib->pktlen = 30U;
  mgmt->u.assoc_resp.capab_info = pnetwork->capability;
  mgmt->u.assoc_resp.status_code = status;
  mgmt->u.assoc_resp.aid = (unsigned int )((unsigned short )pstat->aid) | 49152U;
  pframe = (unsigned char *)(& mgmt->u.assoc_resp.variable);
  if (pstat->bssratelen <= 8U) {
    tmp___1 = rtw_set_ie23a(pframe, 1, pstat->bssratelen, (u8 const   *)(& pstat->bssrateset),
                            & pattrib->pktlen);
    pframe = tmp___1;
  } else {
    tmp___2 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& pstat->bssrateset), & pattrib->pktlen);
    pframe = tmp___2;
    tmp___3 = rtw_set_ie23a(pframe, 50, pstat->bssratelen - 8U, (u8 const   *)(& pstat->bssrateset) + 8U,
                            & pattrib->pktlen);
    pframe = tmp___3;
  }
  if (((unsigned long )pstat->flags & 2048UL) != 0UL && (int )pmlmepriv->htpriv.ht_option) {
    p = cfg80211_find_ie(45, (u8 const   *)ie, (int )pnetwork->IELength);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      memcpy((void *)pframe, (void const   *)p, (size_t )((int )*(p + 1UL) + 2));
      pframe = pframe + ((unsigned long )*(p + 1UL) + 2UL);
      pattrib->pktlen = (pattrib->pktlen + (u32 )*(p + 1UL)) + 2U;
    } else {

    }
    p = cfg80211_find_ie(61, (u8 const   *)ie, (int )pnetwork->IELength);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      memcpy((void *)pframe, (void const   *)p, (size_t )((int )*(p + 1UL) + 2));
      pframe = pframe + ((unsigned long )*(p + 1UL) + 2UL);
      pattrib->pktlen = (pattrib->pktlen + (u32 )*(p + 1UL)) + 2U;
    } else {

    }
  } else {

  }
  if (((unsigned long )pstat->flags & 512UL) != 0UL && pmlmepriv->qos_option != 0U) {
    WMM_PARA_IE[0] = 0U;
    WMM_PARA_IE[1] = 80U;
    WMM_PARA_IE[2] = 242U;
    WMM_PARA_IE[3] = 2U;
    WMM_PARA_IE[4] = 1U;
    WMM_PARA_IE[5] = 1U;
    ie_len = 0;
    p = (u8 const   *)ie;
    ldv_56552: 
    p = cfg80211_find_ie(221, p, (int )((pnetwork->IELength - (u32 )ie_len) + 4294967294U));
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
      ie_len = (int )*(p + 1UL);
    } else {
      ie_len = 0;
    }
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
      tmp___4 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_PARA_IE), 6UL);
      if (tmp___4 == 0) {
        memcpy((void *)pframe, (void const   *)p, (size_t )(ie_len + 2));
        pframe = pframe + ((unsigned long )ie_len + 2UL);
        pattrib->pktlen = (pattrib->pktlen + (u32 )ie_len) + 2U;
        goto ldv_56551;
      } else {

      }
    } else {

    }
    if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || ie_len == 0) {
      goto ldv_56551;
    } else {

    }
    p = p + ((unsigned long )ie_len + 2UL);
    goto ldv_56552;
    ldv_56551: ;
  } else {

  }
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 1U) {
    tmp___5 = rtw_set_ie23a(pframe, 221, 6U, (u8 const   *)(& REALTEK_96B_IE), & pattrib->pktlen);
    pframe = tmp___5;
  } else {

  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
static void issue_assocreq(struct rtw_adapter *padapter ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  u8 const   *p ;
  struct ieee80211_mgmt *mgmt ;
  unsigned int i ;
  unsigned int j ;
  unsigned int index ;
  unsigned char rf_type ;
  unsigned char bssrate[13U] ;
  unsigned char sta_bssrate[13U] ;
  struct registry_priv *pregpriv ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bssrate_len ;
  int sta_bssrate_len ;
  int pie_len ;
  u8 *pie ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  unsigned int tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  struct ieee80211_ht_cap *cap ;
  bool tmp___8 ;
  bool tmp___9 ;
  u8 *tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  u8 plen ;
  int tmp___13 ;
  u8 *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  u8 *tmp___18 ;
  void *tmp___19 ;

  {
  ret = 0;
  index = 0U;
  pregpriv = & padapter->registrypriv;
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  bssrate_len = 0;
  sta_bssrate_len = 0;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  mgmt = (struct ieee80211_mgmt *)pframe;
  mgmt->frame_control = 0U;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)tmp);
  tmp___0 = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp___0);
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___1);
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  put_unaligned_le16((int )pmlmeinfo->network.capability, (void *)(& mgmt->u.assoc_req.capab_info));
  put_unaligned_le16(3, (void *)(& mgmt->u.assoc_req.listen_interval));
  pframe = (unsigned char *)(& mgmt->u.assoc_req.variable);
  pattrib->pktlen = 28U;
  tmp___2 = rtw_set_ie23a(pframe, 0, (uint )pmlmeinfo->network.Ssid.ssid_len, (u8 const   *)(& pmlmeinfo->network.Ssid.ssid),
                          & pattrib->pktlen);
  pframe = tmp___2;
  get_rate_set23a(padapter, (unsigned char *)(& sta_bssrate), & sta_bssrate_len);
  if ((unsigned int )pmlmeext->cur_channel == 14U) {
    sta_bssrate_len = 4;
  } else {

  }
  i = 0U;
  goto ldv_56580;
  ldv_56579: ;
  if ((unsigned int )pmlmeinfo->network.SupportedRates[i] == 0U) {
    goto ldv_56578;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: network.SupportedRates[%d]=%02X\n", i, (int )pmlmeinfo->network.SupportedRates[i]);
  } else {

  }
  i = i + 1U;
  ldv_56580: ;
  if (i <= 15U) {
    goto ldv_56579;
  } else {

  }
  ldv_56578: 
  i = 0U;
  goto ldv_56587;
  ldv_56586: ;
  if ((unsigned int )pmlmeinfo->network.SupportedRates[i] == 0U) {
    goto ldv_56581;
  } else {

  }
  j = 0U;
  goto ldv_56584;
  ldv_56583: ;
  if (((unsigned int )pmlmeinfo->network.SupportedRates[i] | 128U) == ((unsigned int )sta_bssrate[j] | 128U)) {
    goto ldv_56582;
  } else {

  }
  j = j + 1U;
  ldv_56584: ;
  if ((unsigned int )sta_bssrate_len > j) {
    goto ldv_56583;
  } else {

  }
  ldv_56582: ;
  if ((unsigned int )sta_bssrate_len == j) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): the rate[%d]=%02X is not supported by STA!\n",
             "issue_assocreq", i, (int )pmlmeinfo->network.SupportedRates[i]);
    } else {

    }
  } else {
    tmp___3 = index;
    index = index + 1U;
    bssrate[tmp___3] = pmlmeinfo->network.SupportedRates[i];
  }
  i = i + 1U;
  ldv_56587: ;
  if (i <= 15U) {
    goto ldv_56586;
  } else {

  }
  ldv_56581: 
  bssrate_len = (int )index;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bssrate_len = %d\n", bssrate_len);
  } else {

  }
  if (bssrate_len == 0) {
    rtw_free_xmitbuf23a(pxmitpriv, pmgntframe->pxmitbuf);
    rtw_free_xmitframe23a(pxmitpriv, pmgntframe);
    goto exit;
  } else {

  }
  if (bssrate_len > 8) {
    tmp___4 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& bssrate), & pattrib->pktlen);
    pframe = tmp___4;
    tmp___5 = rtw_set_ie23a(pframe, 50, (uint )(bssrate_len + -8), (u8 const   *)(& bssrate) + 8U,
                            & pattrib->pktlen);
    pframe = tmp___5;
  } else {
    tmp___6 = rtw_set_ie23a(pframe, 1, (uint )bssrate_len, (u8 const   *)(& bssrate),
                            & pattrib->pktlen);
    pframe = tmp___6;
  }
  pie = (u8 *)(& pmlmeinfo->network.IEs);
  pie_len = (int )pmlmeinfo->network.IELength;
  p = cfg80211_find_ie(48, (u8 const   *)pie, pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
    tmp___7 = rtw_set_ie23a(pframe, 48, (uint )*(p + 1UL), p + 2UL, & pattrib->pktlen);
    pframe = tmp___7;
  } else {

  }
  if ((int )padapter->mlmepriv.htpriv.ht_option) {
    p = cfg80211_find_ie(45, (u8 const   *)pie, pie_len);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
      tmp___11 = is_ap_in_tkip23a(padapter);
      if (tmp___11) {
        tmp___12 = 0;
      } else {
        tmp___12 = 1;
      }
      if (tmp___12) {
        cap = & pmlmeinfo->ht_cap;
        memcpy((void *)cap, (void const   *)p + 2U, 26UL);
        if ((unsigned int )pregpriv->cbw40_enable == 0U) {
          cap->cap_info = (unsigned int )cap->cap_info & 65469U;
        } else {
          cap->cap_info = (__le16 )((unsigned int )cap->cap_info | 2U);
        }
        cap->cap_info = (__le16 )((unsigned int )cap->cap_info | 12U);
        rf_type = rtl8723a_get_rf_type(padapter);
        switch ((int )rf_type) {
        case 3: ;
        if ((unsigned int )pregpriv->rx_stbc != 0U) {
          cap->cap_info = (__le16 )((unsigned int )cap->cap_info | 256U);
        } else {

        }
        memcpy((void *)(& cap->mcs), (void const   *)(& MCS_rate_1R23A), 16UL);
        goto ldv_56590;
        case 2: ;
        case 0: ;
        default: ;
        if ((((unsigned int )pregpriv->rx_stbc == 3U || (((int )pmlmeext->cur_wireless_mode & 8) != 0 && (unsigned int )pregpriv->rx_stbc == 1U)) || (((int )pmlmeext->cur_wireless_mode & 16) != 0 && (unsigned int )pregpriv->rx_stbc == 2U)) || (unsigned int )pregpriv->wifi_spec == 1U) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: declare supporting RX STBC\n");
          } else {

          }
          cap->cap_info = (__le16 )((unsigned int )cap->cap_info | 512U);
        } else {

        }
        memcpy((void *)(& cap->mcs), (void const   *)(& MCS_rate_2R23A), 16UL);
        goto ldv_56590;
        }
        ldv_56590: 
        tmp___8 = rtl8723a_BT_coexist(padapter);
        if ((int )tmp___8) {
          tmp___9 = rtl8723a_BT_using_antenna_1(padapter);
          if ((int )tmp___9) {
            cap->ampdu_params_info = (unsigned int )cap->ampdu_params_info & 252U;
          } else {

          }
        } else {

        }
        tmp___10 = rtw_set_ie23a(pframe, 45, (uint )*(p + 1UL), (u8 const   *)(& pmlmeinfo->ht_cap),
                                 & pattrib->pktlen);
        pframe = tmp___10;
      } else {

      }
    } else {

    }
  } else {

  }
  i = 0U;
  goto ldv_56599;
  ldv_56598: 
  p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
  switch ((int )*p) {
  case 221: 
  tmp___15 = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                    4UL);
  if (tmp___15 == 0) {
    goto _L;
  } else {
    tmp___16 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_OUI23A), 4UL);
    if (tmp___16 == 0) {
      goto _L;
    } else {
      tmp___17 = memcmp((void const   *)p + 2U, (void const   *)(& WPS_OUI23A), 4UL);
      if (tmp___17 == 0) {
        _L: /* CIL Label */ 
        plen = *(p + 1UL);
        if ((unsigned int )padapter->registrypriv.wifi_spec == 0U) {
          tmp___13 = memcmp((void const   *)p + 2U, (void const   *)(& WPS_OUI23A),
                            4UL);
          if (tmp___13 == 0) {
            plen = 14U;
          } else {

          }
        } else {

        }
        tmp___14 = rtw_set_ie23a(pframe, 221, (uint )plen, p + 2UL, & pattrib->pktlen);
        pframe = tmp___14;
      } else {

      }
    }
  }
  goto ldv_56596;
  default: ;
  goto ldv_56596;
  }
  ldv_56596: 
  i = ((unsigned int )*(p + 1UL) + i) + 2U;
  ldv_56599: ;
  if (pmlmeinfo->network.IELength > i) {
    goto ldv_56598;
  } else {

  }

  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 1U) {
    tmp___18 = rtw_set_ie23a(pframe, 221, 6U, (u8 const   *)(& REALTEK_96B_IE), & pattrib->pktlen);
    pframe = tmp___18;
  } else {

  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  ret = 1;
  exit: 
  pmlmepriv->assoc_req_len = 0U;
  if (ret == 1) {
    kfree((void const   *)pmlmepriv->assoc_req);
    tmp___19 = kmalloc((size_t )pattrib->pktlen, 32U);
    pmlmepriv->assoc_req = (u8 *)tmp___19;
    if ((unsigned long )pmlmepriv->assoc_req != (unsigned long )((u8 *)0U)) {
      memcpy((void *)pmlmepriv->assoc_req, (void const   *)mgmt, (size_t )pattrib->pktlen);
      pmlmepriv->assoc_req_len = pattrib->pktlen;
    } else {

    }
  } else {
    kfree((void const   *)pmlmepriv->assoc_req);
  }
  return;
}
}
static int _issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                              int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
  ret = 0;
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    goto exit;
  } else {

  }
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->retry_ctrl = 0U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 72U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  } else
  if ((pmlmeinfo->state & 3U) == 2U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  } else {

  }
  if (power_mode != 0U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  } else {

  }
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  pattrib->last_txcmdsz = pattrib->pktlen;
  if (wait_ack != 0) {
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
    ret = 1;
  }
  exit: ;
  return (ret);
}
}
int issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                      int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  unsigned int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;
  u8 tmp___3 ;

  {
  i = 0;
  start = jiffies;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned long )da == (unsigned long )((unsigned char *)0U)) {
    tmp = get_my_bssid23a(& pmlmeinfo->network);
    da = tmp;
  } else {

  }
  ldv_56629: 
  ret = _issue_nulldata23a(padapter, da, power_mode, wait_ms > 0);
  i = i + 1;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto ldv_56628;
  } else {

  }
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
    msleep((unsigned int )wait_ms);
  } else {

  }
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
    goto ldv_56629;
  } else {

  }
  ldv_56628: ;
  if (ret != 0) {
    ret = 1;
    goto exit;
  } else {

  }
  if (try_cnt != 0 && wait_ms != 0) {
    if ((unsigned long )da != (unsigned long )((unsigned char *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
        tmp___1 = rtw_get_oper_ch23a(padapter);
        printk("\016RTL8723AU: %s(%s): to %pM, ch:%u%s, %d/%d in %u ms\n", "issue_nulldata23a",
               (char *)(& (padapter->pnetdev)->name), da, (int )tmp___1, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp___0);
      } else {

      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
      tmp___3 = rtw_get_oper_ch23a(padapter);
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_nulldata23a",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___3, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___2);
    } else {

    }
  } else {

  }
  exit: ;
  return (ret);
}
}
static int _issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da ,
                                  u16 tid , int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_qos_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
  ret = 0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "_issue_qos_nulldata23a");
  } else {

  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 2U;
  pattrib->qos_en = 1U;
  pattrib->eosp = 1U;
  pattrib->ack_policy = 0U;
  pattrib->mdata = 0U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_qos_hdr *)pframe;
  pwlanhdr->frame_control = 200U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  } else
  if ((pmlmeinfo->state & 3U) == 2U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  } else {

  }
  if ((unsigned int )pattrib->mdata != 0U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 8192U);
  } else {

  }
  pwlanhdr->qos_ctrl = (unsigned int )tid & 15U;
  pwlanhdr->qos_ctrl = (__le16 )((int )((short )pwlanhdr->qos_ctrl) | ((int )((short )((int )pattrib->ack_policy << 5)) & 96));
  if ((unsigned int )pattrib->eosp != 0U) {
    pwlanhdr->qos_ctrl = (__le16 )((unsigned int )pwlanhdr->qos_ctrl | 16U);
  } else {

  }
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 26UL;
  pattrib->pktlen = 26U;
  pattrib->last_txcmdsz = pattrib->pktlen;
  if (wait_ack != 0) {
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
    ret = 1;
  }
  exit: ;
  return (ret);
}
}
int issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , u16 tid ,
                          int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  unsigned int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;
  u8 tmp___3 ;

  {
  i = 0;
  start = jiffies;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned long )da == (unsigned long )((unsigned char *)0U)) {
    tmp = get_my_bssid23a(& pmlmeinfo->network);
    da = tmp;
  } else {

  }
  ldv_56661: 
  ret = _issue_qos_nulldata23a(padapter, da, (int )tid, wait_ms > 0);
  i = i + 1;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto ldv_56660;
  } else {

  }
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
    msleep((unsigned int )wait_ms);
  } else {

  }
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
    goto ldv_56661;
  } else {

  }
  ldv_56660: ;
  if (ret != 0) {
    ret = 1;
    goto exit;
  } else {

  }
  if (try_cnt != 0 && wait_ms != 0) {
    if ((unsigned long )da != (unsigned long )((unsigned char *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
        tmp___1 = rtw_get_oper_ch23a(padapter);
        printk("\016RTL8723AU: %s(%s): to %pM, ch:%u%s, %d/%d in %u ms\n", "issue_qos_nulldata23a",
               (char *)(& (padapter->pnetdev)->name), da, (int )tmp___1, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp___0);
      } else {

      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
      tmp___3 = rtw_get_oper_ch23a(padapter);
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_qos_nulldata23a",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___3, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___2);
    } else {

    }
  } else {

  }
  exit: ;
  return (ret);
}
}
static int _issue_deauth(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ,
                         u8 wait_ack ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int ret ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ret = 0;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->retry_ctrl = 0U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  mgmt = (struct ieee80211_mgmt *)pmgntframe->buf_addr + 40U;
  mgmt->frame_control = 192U;
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)da);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pattrib->pktlen = 26U;
  mgmt->u.deauth.reason_code = reason;
  pattrib->last_txcmdsz = pattrib->pktlen;
  if ((unsigned int )wait_ack != 0U) {
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
    ret = 1;
  }
  exit: ;
  return (ret);
}
}
int issue_deauth23a(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ) 
{ 
  int tmp ;

  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s to %pM\n", "issue_deauth23a", da);
  } else {

  }
  tmp = _issue_deauth(padapter, da, (int )reason, 0);
  return (tmp);
}
}
static int issue_deauth_ex(struct rtw_adapter *padapter , u8 *da , unsigned short reason ,
                           int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  unsigned int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u8 tmp___2 ;

  {
  i = 0;
  start = jiffies;
  ldv_56695: 
  ret = _issue_deauth(padapter, da, (int )reason, wait_ms > 0);
  i = i + 1;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto ldv_56694;
  } else {

  }
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
    msleep((unsigned int )wait_ms);
  } else {

  }
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
    goto ldv_56695;
  } else {

  }
  ldv_56694: ;
  if (ret != 0) {
    ret = 1;
    goto exit;
  } else {

  }
  if (try_cnt != 0 && wait_ms != 0) {
    if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        tmp = jiffies_to_msecs((unsigned long )jiffies - start);
        tmp___0 = rtw_get_oper_ch23a(padapter);
        printk("\016RTL8723AU: %s(%s): to %pM, ch:%u%s, %d/%d in %u ms\n", "issue_deauth_ex",
               (char *)(& (padapter->pnetdev)->name), da, (int )tmp___0, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp);
      } else {

      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      tmp___1 = jiffies_to_msecs((unsigned long )jiffies - start);
      tmp___2 = rtw_get_oper_ch23a(padapter);
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_deauth_ex",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___2, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___1);
    } else {

    }
  } else {

  }
  exit: ;
  return (ret);
}
}
void issue_action_spct_ch_switch23a(struct rtw_adapter *padapter , u8 *ra , u8 new_ch ,
                                    u8 ch_offset ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 tmp___1 ;
  u8 *tmp___2 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): ra=%pM, ch:%u, offset:%u\n", "issue_action_spct_ch_switch23a",
           (char *)(& (padapter->pnetdev)->name), ra, (int )new_ch, (int )ch_offset);
  } else {

  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  mgmt = (struct ieee80211_mgmt *)pmgntframe->buf_addr + 40U;
  mgmt->frame_control = 208U;
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)ra);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)ra);
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  mgmt->u.action.category = 0U;
  mgmt->u.action.u.chan_switch.action_code = 4U;
  pframe = (unsigned char *)(& mgmt->u.action.u.chan_switch.variable);
  pattrib->pktlen = 26U;
  tmp___0 = rtw_set_ie23a_ch_switch(pframe, & pattrib->pktlen, 0, (int )new_ch, 0);
  pframe = tmp___0;
  tmp___1 = hal_ch_offset_to_secondary_ch_offset23a((int )ch_offset);
  tmp___2 = rtw_set_ie23a_secondary_ch_offset(pframe, & pattrib->pktlen, (int )tmp___1);
  pframe = tmp___2;
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
void issue_action_BA23a(struct rtw_adapter *padapter , unsigned char const   *raddr ,
                        unsigned char action , unsigned short status ) 
{ 
  u16 start_seq ;
  u16 BA_para_set ;
  u16 BA_starting_seqctrl ;
  u16 BA_para ;
  int max_rx_ampdu_factor ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct registry_priv *pregpriv ;
  u8 tendaAPMac[3U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int idx ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pstapriv = & padapter->stapriv;
  pregpriv = & padapter->registrypriv;
  tendaAPMac[0] = 200U;
  tendaAPMac[1] = 58U;
  tendaAPMac[2] = 53U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, action =%d, status =%d\n", "issue_action_BA23a", (int )action,
           (int )status);
  } else {

  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  mgmt = (struct ieee80211_mgmt *)pmgntframe->buf_addr + 40U;
  mgmt->frame_control = 208U;
  ether_addr_copy((u8 *)(& mgmt->da), raddr);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
  mgmt->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  mgmt->u.action.category = 3U;
  pattrib->pktlen = 25U;
  switch ((int )action) {
  case 0: 
  pattrib->pktlen = pattrib->pktlen + 8U;
  mgmt->u.action.u.addba_req.action_code = action;
  ldv_56734: 
  pmlmeinfo->dialogToken = (u8 )((int )pmlmeinfo->dialogToken + 1);
  if ((unsigned int )pmlmeinfo->dialogToken == 0U) {
    goto ldv_56734;
  } else {

  }
  mgmt->u.action.u.addba_req.dialog_token = pmlmeinfo->dialogToken;
  tmp___1 = rtl8723a_BT_coexist(padapter);
  if ((int )tmp___1) {
    tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
    if ((int )tmp___2) {
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor != 1U) {
        BA_para_set = 0U;
        BA_para_set = (u16 )((unsigned int )BA_para_set | 2U);
        BA_para_set = (u16 )(((int )((short )((int )status << 2)) & 60) | (int )((short )BA_para_set));
        BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
      } else {
        tmp___3 = memcmp((void const   *)raddr, (void const   *)(& tendaAPMac), 3UL);
        if (tmp___3 != 0) {
          BA_para_set = 0U;
          BA_para_set = (u16 )((unsigned int )BA_para_set | 2U);
          BA_para_set = (u16 )(((int )((short )((int )status << 2)) & 60) | (int )((short )BA_para_set));
          BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
        } else {
          BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
        }
      }
    } else {
      BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
    }
  } else {
    BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
  }
  put_unaligned_le16((int )BA_para_set, (void *)(& mgmt->u.action.u.addba_req.capab));
  put_unaligned_le16(5000, (void *)(& mgmt->u.action.u.addba_req.timeout));
  psta = rtw_get_stainfo23a(pstapriv, raddr);
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    idx = (int )status & 7;
    start_seq = ((unsigned int )psta->sta_xmitpriv.txseq_tid[idx] & 4095U) + 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: BA_starting_seqctrl = %d for TID =%d\n", (int )start_seq,
             idx);
    } else {

    }
    psta->BA_starting_seqctrl[idx] = start_seq;
    BA_starting_seqctrl = (int )start_seq << 4U;
  } else {
    BA_starting_seqctrl = 0U;
  }
  put_unaligned_le16((int )BA_starting_seqctrl, (void *)(& mgmt->u.action.u.addba_req.start_seq_num));
  goto ldv_56737;
  case 1: 
  pattrib->pktlen = pattrib->pktlen + 8U;
  mgmt->u.action.u.addba_resp.action_code = action;
  mgmt->u.action.u.addba_resp.dialog_token = pmlmeinfo->ADDBA_req.dialog_token;
  put_unaligned_le16((int )status, (void *)(& mgmt->u.action.u.addba_resp.status));
  GetHalDefVar8192CUsb(padapter, 11, (void *)(& max_rx_ampdu_factor));
  BA_para = (unsigned int )pmlmeinfo->ADDBA_req.BA_para_set & 63U;
  if (max_rx_ampdu_factor == 3) {
    BA_para_set = (u16 )((unsigned int )BA_para | 4096U);
  } else
  if (max_rx_ampdu_factor == 2) {
    BA_para_set = (u16 )((unsigned int )BA_para | 2048U);
  } else
  if (max_rx_ampdu_factor == 1) {
    BA_para_set = (u16 )((unsigned int )BA_para | 1024U);
  } else
  if (max_rx_ampdu_factor == 0) {
    BA_para_set = (u16 )((unsigned int )BA_para | 512U);
  } else {
    BA_para_set = (u16 )((unsigned int )BA_para | 4096U);
  }
  tmp___4 = rtl8723a_BT_coexist(padapter);
  if ((int )tmp___4) {
    tmp___5 = rtl8723a_BT_using_antenna_1(padapter);
    if ((int )tmp___5) {
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor != 1U) {
        BA_para_set = (unsigned int )BA_para_set & 63U;
        BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
      } else {
        tmp___6 = memcmp((void const   *)raddr, (void const   *)(& tendaAPMac), 3UL);
        if (tmp___6 != 0) {
          BA_para_set = (unsigned int )BA_para_set & 63U;
          BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
        } else {

        }
      }
    } else {

    }
  } else {

  }
  if ((unsigned int )pregpriv->ampdu_amsdu == 0U) {
    BA_para_set = (unsigned int )BA_para_set & 65534U;
  } else
  if ((unsigned int )pregpriv->ampdu_amsdu == 1U) {
    BA_para_set = (u16 )((unsigned int )BA_para_set | 1U);
  } else {

  }
  put_unaligned_le16((int )BA_para_set, (void *)(& mgmt->u.action.u.addba_resp.capab));
  mgmt->u.action.u.addba_resp.timeout = pmlmeinfo->ADDBA_req.BA_timeout_value;
  pattrib->pktlen = pattrib->pktlen + 8U;
  goto ldv_56737;
  case 2: 
  pattrib->pktlen = pattrib->pktlen + 5U;
  mgmt->u.action.u.delba.action_code = action;
  BA_para_set = (unsigned int )((u16 )((int )status << 3)) & 255U;
  mgmt->u.action.u.delba.params = BA_para_set;
  mgmt->u.action.u.delba.reason_code = 37U;
  pattrib->pktlen = pattrib->pktlen + 5U;
  goto ldv_56737;
  default: ;
  goto ldv_56737;
  }
  ldv_56737: 
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
int send_delba23a(struct rtw_adapter *padapter , u8 initiator , u8 *addr ) 
{ 
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u16 tid ;

  {
  pstapriv = & padapter->stapriv;
  psta = (struct sta_info *)0;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((pmlmeinfo->state & 3U) != 3U) {
    if ((pmlmeinfo->state & 16384U) == 0U) {
      return (1);
    } else {

    }
  } else {

  }
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (1);
  } else {

  }
  if ((unsigned int )initiator == 0U) {
    tid = 0U;
    goto ldv_56752;
    ldv_56751: ;
    if ((unsigned int )psta->recvreorder_ctrl[(int )tid].enable == 1U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: rx agg disable tid(%d)\n", (int )tid);
      } else {

      }
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 2, (int )((unsigned short )((int )((short )((int )tid << 1)) | (int )((short )initiator))) & 31);
      psta->recvreorder_ctrl[(int )tid].enable = 0U;
      psta->recvreorder_ctrl[(int )tid].indicate_seq = 65535U;
    } else {

    }
    tid = (u16 )((int )tid + 1);
    ldv_56752: ;
    if ((unsigned int )tid <= 15U) {
      goto ldv_56751;
    } else {

    }

  } else
  if ((unsigned int )initiator == 1U) {
    tid = 0U;
    goto ldv_56755;
    ldv_56754: ;
    if ((int )((unsigned long )psta->htpriv.agg_enable_bitmap >> (int )tid) & 1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: tx agg disable tid(%d)\n", (int )tid);
      } else {

      }
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 2, (int )((unsigned short )((int )((short )((int )tid << 1)) | (int )((short )initiator))) & 31);
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    } else {

    }
    tid = (u16 )((int )tid + 1);
    ldv_56755: ;
    if ((unsigned int )tid <= 15U) {
      goto ldv_56754;
    } else {

    }

  } else {

  }
  return (1);
}
}
int send_beacon23a(struct rtw_adapter *padapter ) 
{ 
  bool bxmitok ;
  int issue ;
  int poll ;
  unsigned long start ;
  unsigned int passing_time ;

  {
  issue = 0;
  poll = 0;
  start = jiffies;
  rtl8723a_bcn_valid(padapter);
  ldv_56767: 
  issue_beacon23a(padapter, 100);
  issue = issue + 1;
  ldv_56765: 
  yield();
  bxmitok = rtl8723a_get_bcn_valid(padapter);
  poll = poll + 1;
  if (((poll % 10 != 0 && ! bxmitok) && padapter->bSurpriseRemoved == 0) && padapter->bDriverStopped == 0) {
    goto ldv_56765;
  } else {

  }

  if (((! bxmitok && issue <= 99) && padapter->bSurpriseRemoved == 0) && padapter->bDriverStopped == 0) {
    goto ldv_56767;
  } else {

  }

  if (padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) {
    return (0);
  } else {

  }
  passing_time = jiffies_to_msecs((unsigned long )jiffies - start);
  if (! bxmitok) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s fail! %u ms\n", "send_beacon23a", passing_time);
    } else {

    }
    return (0);
  } else {
    if (passing_time > 100U || issue > 3) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s success, issue:%d, poll:%d, %u ms\n", "send_beacon23a",
               issue, poll, passing_time);
      } else {

      }
    } else {

    }
    return (1);
  }
}
}
bool IsLegal5GChannel(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  int i ;
  u8 Channel_5G[45U] ;

  {
  i = 0;
  Channel_5G[0] = 36U;
  Channel_5G[1] = 38U;
  Channel_5G[2] = 40U;
  Channel_5G[3] = 42U;
  Channel_5G[4] = 44U;
  Channel_5G[5] = 46U;
  Channel_5G[6] = 48U;
  Channel_5G[7] = 50U;
  Channel_5G[8] = 52U;
  Channel_5G[9] = 54U;
  Channel_5G[10] = 56U;
  Channel_5G[11] = 58U;
  Channel_5G[12] = 60U;
  Channel_5G[13] = 62U;
  Channel_5G[14] = 64U;
  Channel_5G[15] = 100U;
  Channel_5G[16] = 102U;
  Channel_5G[17] = 104U;
  Channel_5G[18] = 106U;
  Channel_5G[19] = 108U;
  Channel_5G[20] = 110U;
  Channel_5G[21] = 112U;
  Channel_5G[22] = 114U;
  Channel_5G[23] = 116U;
  Channel_5G[24] = 118U;
  Channel_5G[25] = 120U;
  Channel_5G[26] = 122U;
  Channel_5G[27] = 124U;
  Channel_5G[28] = 126U;
  Channel_5G[29] = 128U;
  Channel_5G[30] = 130U;
  Channel_5G[31] = 132U;
  Channel_5G[32] = 134U;
  Channel_5G[33] = 136U;
  Channel_5G[34] = 138U;
  Channel_5G[35] = 140U;
  Channel_5G[36] = 149U;
  Channel_5G[37] = 151U;
  Channel_5G[38] = 153U;
  Channel_5G[39] = 155U;
  Channel_5G[40] = 157U;
  Channel_5G[41] = 159U;
  Channel_5G[42] = 161U;
  Channel_5G[43] = 163U;
  Channel_5G[44] = 165U;
  i = 0;
  goto ldv_56777;
  ldv_56776: ;
  if ((int )Channel_5G[i] == (int )channel) {
    return (1);
  } else {

  }
  i = i + 1;
  ldv_56777: ;
  if ((unsigned int )i <= 44U) {
    goto ldv_56776;
  } else {

  }

  return (0);
}
}
static void rtw_site_survey(struct rtw_adapter *padapter ) 
{ 
  unsigned char survey_channel ;
  enum rt_scan_type ScanType ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct rtw_ieee80211_channel *ch ;
  int i ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
  survey_channel = 0U;
  ScanType = 0;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (pmlmeext->sitesurvey_res.channel_idx < (int )pmlmeext->sitesurvey_res.ch_num) {
    ch = (struct rtw_ieee80211_channel *)(& pmlmeext->sitesurvey_res.ch) + (unsigned long )pmlmeext->sitesurvey_res.channel_idx;
    survey_channel = (unsigned char )ch->hw_value;
    ScanType = (ch->flags & 2U) == 0U;
  } else {

  }
  if ((unsigned int )survey_channel != 0U) {
    if (pmlmeext->sitesurvey_res.channel_idx == 0) {
      set_channel_bwmode23a(padapter, (int )survey_channel, 0, 0);
    } else {
      SelectChannel23a(padapter, (int )survey_channel);
    }
    if ((unsigned int )ScanType == 1U) {
      i = 0;
      goto ldv_56789;
      ldv_56788: ;
      if ((unsigned int )pmlmeext->sitesurvey_res.ssid[i].ssid_len != 0U) {
        issue_probereq(padapter, (struct cfg80211_ssid *)(& pmlmeext->sitesurvey_res.ssid) + (unsigned long )i,
                       (u8 *)0U);
        issue_probereq(padapter, (struct cfg80211_ssid *)(& pmlmeext->sitesurvey_res.ssid) + (unsigned long )i,
                       (u8 *)0U);
      } else {

      }
      i = i + 1;
      ldv_56789: ;
      if (i <= 8) {
        goto ldv_56788;
      } else {

      }

      if (pmlmeext->sitesurvey_res.scan_mode == 1) {
        issue_probereq(padapter, (struct cfg80211_ssid *)0, (u8 *)0U);
        issue_probereq(padapter, (struct cfg80211_ssid *)0, (u8 *)0U);
      } else {

      }
    } else {

    }
    tmp = msecs_to_jiffies((unsigned int const   )pmlmeext->chan_scan_time);
    ldv_mod_timer_107(& pmlmeext->survey_timer, tmp + (unsigned long )jiffies);
  } else {
    pmlmeext->sitesurvey_res.state = 4;
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
    rtl8723a_set_media_status(padapter, (int )((u8 )pmlmeinfo->state) & 3);
    rtl8723a_set_initial_gain(padapter, 255U);
    rtl8723a_odm_support_ability_restore(padapter);
    tmp___0 = is_client_associated_to_ap23a(padapter);
    if ((int )tmp___0) {
      issue_nulldata23a(padapter, (unsigned char *)0U, 0U, 3, 500);
    } else {

    }
    rtl8723a_mlme_sitesurvey(padapter, 0);
    report_surveydone_event23a(padapter);
    pmlmeext->chan_scan_time = 100U;
    pmlmeext->sitesurvey_res.state = 0;
  }
  return;
}
}
static struct wlan_bssid_ex *collect_bss_info(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *bssid ;
  u8 const   *p ;
  u8 *pie ;
  unsigned int length ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ieee80211_ht_operation *HT_info ;
  u8 tmp___3 ;
  int tmp___4 ;
  struct mlme_priv *pmlmepriv ;
  struct ieee80211_ht_cap *pHT_caps ;
  u8 tmp___5 ;

  {
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  pregistrypriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  length = skb->len;
  tmp = kzalloc(871UL, 32U);
  bssid = (struct wlan_bssid_ex *)tmp;
  if ((unsigned long )bssid == (unsigned long )((struct wlan_bssid_ex *)0)) {
    return ((struct wlan_bssid_ex *)0);
  } else {

  }
  tmp___2 = ieee80211_is_beacon((int )mgmt->frame_control);
  if (tmp___2 != 0) {
    length = length - 36U;
    pie = (u8 *)(& mgmt->u.beacon.variable);
    bssid->reserved = 1U;
    bssid->capability = get_unaligned_le16((void const   *)(& mgmt->u.beacon.capab_info));
    bssid->beacon_interval = get_unaligned_le16((void const   *)(& mgmt->u.beacon.beacon_int));
    bssid->tsf = get_unaligned_le64((void const   *)(& mgmt->u.beacon.timestamp));
  } else {
    tmp___1 = ieee80211_is_probe_req((int )mgmt->frame_control);
    if (tmp___1 != 0) {
      length = length - 24U;
      pie = (u8 *)(& mgmt->u.probe_req.variable);
      bssid->reserved = 2U;
      bssid->capability = 0U;
      bssid->beacon_interval = padapter->registrypriv.dev_network.beacon_interval;
      bssid->tsf = 0ULL;
    } else {
      tmp___0 = ieee80211_is_probe_resp((int )mgmt->frame_control);
      if (tmp___0 != 0) {
        length = length - 36U;
        pie = (u8 *)(& mgmt->u.probe_resp.variable);
        bssid->reserved = 3U;
        bssid->capability = get_unaligned_le16((void const   *)(& mgmt->u.probe_resp.capab_info));
        bssid->beacon_interval = get_unaligned_le16((void const   *)(& mgmt->u.probe_resp.beacon_int));
        bssid->tsf = get_unaligned_le64((void const   *)(& mgmt->u.probe_resp.timestamp));
      } else {
        length = length - 36U;
        pie = (u8 *)(& mgmt->u.beacon.variable);
        bssid->reserved = 0U;
        bssid->capability = get_unaligned_le16((void const   *)(& mgmt->u.beacon.capab_info));
        bssid->beacon_interval = padapter->registrypriv.dev_network.beacon_interval;
        bssid->tsf = 0ULL;
      }
    }
  }
  if (length > 768U) {
    kfree((void const   *)bssid);
    return ((struct wlan_bssid_ex *)0);
  } else {

  }
  bssid->Length = length + 103U;
  bssid->IELength = length;
  memcpy((void *)(& bssid->IEs), (void const   *)pie, (size_t )bssid->IELength);
  bssid->Rssi = (long )precv_frame->attrib.phy_info.RecvSignalPower;
  bssid->SignalQuality = precv_frame->attrib.phy_info.SignalQuality;
  bssid->SignalStrength = precv_frame->attrib.phy_info.SignalStrength;
  p = cfg80211_find_ie(0, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: marc: cannot find SSID for survey event\n");
    } else {

    }
    goto fail;
  } else {

  }
  if ((unsigned int )((unsigned char )*(p + 1UL)) > 32U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info",
             4198, (int )*(p + 1UL));
    } else {

    }
    goto fail;
  } else {

  }
  memcpy((void *)(& bssid->Ssid.ssid), (void const   *)p + 2U, (size_t )*(p + 1UL));
  bssid->Ssid.ssid_len = *(p + 1UL);
  i = 0;
  p = cfg80211_find_ie(1, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
    if ((unsigned int )((unsigned char )*(p + 1UL)) > 16U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info",
               4210, (int )*(p + 1UL));
      } else {

      }
      goto fail;
    } else {

    }
    memcpy((void *)(& bssid->SupportedRates), (void const   *)p + 2U, (size_t )*(p + 1UL));
    i = (int )*(p + 1UL);
  } else {

  }
  p = cfg80211_find_ie(50, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
    if ((int )*(p + 1UL) > 16 - i) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info",
               4222, (int )*(p + 1UL));
      } else {

      }
      goto fail;
    } else {

    }
    memcpy((void *)(& bssid->SupportedRates) + (unsigned long )i, (void const   *)p + 2U,
             (size_t )*(p + 1UL));
  } else {

  }
  p = cfg80211_find_ie(3, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
  bssid->DSConfig = 0U;
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
    bssid->DSConfig = (u32 )*(p + 2UL);
  } else {
    p = cfg80211_find_ie(61, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
      HT_info = (struct ieee80211_ht_operation *)p + 2U;
      bssid->DSConfig = (u32 )HT_info->primary_chan;
    } else {
      tmp___3 = rtw_get_oper_ch23a(padapter);
      bssid->DSConfig = (u32 )tmp___3;
    }
  }
  tmp___4 = ieee80211_is_probe_req((int )mgmt->frame_control);
  if (tmp___4 != 0) {
    bssid->ifmode = 2;
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->sa));
    bssid->Privacy = 1U;
    return (bssid);
  } else {

  }
  if ((int )bssid->capability & 1) {
    bssid->ifmode = 2;
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->sa));
  } else {
    bssid->ifmode = 1;
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->bssid));
  }
  if (((int )bssid->capability & 16) != 0) {
    bssid->Privacy = 1U;
  } else {
    bssid->Privacy = 0U;
  }
  bssid->ATIMWindow = 0U;
  if ((unsigned int )pregistrypriv->wifi_spec == 1U && (unsigned int )pmlmeinfo->bwmode_updated == 0U) {
    pmlmepriv = & padapter->mlmepriv;
    p = cfg80211_find_ie(45, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      pHT_caps = (struct ieee80211_ht_cap *)p + 2U;
      if (((int )pHT_caps->cap_info & 16384) != 0) {
        pmlmepriv->num_FortyMHzIntolerant = pmlmepriv->num_FortyMHzIntolerant + 1;
      } else {

      }
    } else {
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht + 1;
    }
  } else {

  }
  tmp___5 = rtw_get_oper_ch23a(padapter);
  if (bssid->DSConfig != (u32 )tmp___5) {
    bssid->SignalQuality = 101U;
  } else {

  }
  return (bssid);
  fail: 
  kfree((void const   *)bssid);
  return ((struct wlan_bssid_ex *)0);
}
}
static void start_create_ibss(struct rtw_adapter *padapter ) 
{ 
  unsigned short caps ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  int tmp ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  pmlmeext->cur_channel = (unsigned char )pnetwork->DSConfig;
  pmlmeinfo->bcn_interval = pnetwork->beacon_interval;
  update_wireless_mode23a(padapter);
  caps = pnetwork->capability;
  update_capinfo23a(padapter, (int )caps);
  if (((int )caps & 2) != 0) {
    rtl8723a_set_sec_cfg(padapter, 207);
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, 0, 0);
    rtl8723a_SetBeaconRelatedRegisters(padapter);
    pmlmeinfo->state = 1U;
    rtl8723a_set_media_status(padapter, (int )((u8 )pmlmeinfo->state) & 3);
    tmp = send_beacon23a(padapter);
    if (tmp == 0) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16, 4, "issuing beacon frame fail....\n");
      } else {

      }
      report_join_res23a(padapter, -1);
      pmlmeinfo->state = 0U;
    } else {
      hw_var_set_bssid(padapter, (u8 *)(& padapter->registrypriv.dev_network.MacAddress));
      hw_var_set_mlme_join(padapter, 0);
      report_join_res23a(padapter, 1);
      pmlmeinfo->state = pmlmeinfo->state | 16384U;
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: invalid cap:%x\n", "start_create_ibss", (int )caps);
    } else {

    }
    return;
  }
  return;
}
}
static void start_clnt_join(struct rtw_adapter *padapter ) 
{ 
  unsigned short caps ;
  u8 val8 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  int beacon_timeout ;
  unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  pmlmeext->cur_channel = (unsigned char )pnetwork->DSConfig;
  pmlmeinfo->bcn_interval = pnetwork->beacon_interval;
  update_wireless_mode23a(padapter);
  caps = pnetwork->capability;
  update_capinfo23a(padapter, (int )caps);
  if ((int )caps & 1) {
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
    rtl8723a_set_media_status(padapter, 2);
    val8 = pmlmeinfo->auth_algo == 2U ? 204U : 207U;
    rtl8723a_set_sec_cfg(padapter, (int )val8);
    tmp = decide_wait_for_beacon_timeout23a((unsigned int )pmlmeinfo->bcn_interval);
    beacon_timeout = (int )tmp;
    tmp___0 = msecs_to_jiffies((unsigned int const   )beacon_timeout);
    ldv_mod_timer_108(& pmlmeext->link_timer, tmp___0 + (unsigned long )jiffies);
    tmp___1 = msecs_to_jiffies((unsigned int const   )(beacon_timeout + 2400));
    ldv_mod_timer_109(& padapter->mlmepriv.assoc_timer, tmp___1 + (unsigned long )jiffies);
    pmlmeinfo->state = 258U;
  } else
  if (((int )caps & 2) != 0) {
    rtl8723a_set_media_status(padapter, 1);
    rtl8723a_set_sec_cfg(padapter, 207);
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
    rtl8723a_SetBeaconRelatedRegisters(padapter);
    pmlmeinfo->state = 1U;
    report_join_res23a(padapter, 1);
  } else {
    return;
  }
  return;
}
}
static void start_clnt_auth(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ldv_del_timer_sync_110(& pmlmeext->link_timer);
  pmlmeinfo->state = pmlmeinfo->state & 4294967039U;
  pmlmeinfo->state = pmlmeinfo->state | 512U;
  pmlmeinfo->auth_seq = 1U;
  pmlmeinfo->reauth_count = 0U;
  pmlmeinfo->reassoc_count = 0U;
  pmlmeinfo->link_count = 0U;
  pmlmeext->retry = 0U;
  issue_deauth23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress), 3);
  if (GlobalDebugLevel23A != 0U) {
    printk("\016RTL8723AU: start auth\n");
  } else {

  }
  issue_auth(padapter, (struct sta_info *)0, 0);
  tmp = msecs_to_jiffies(300U);
  ldv_mod_timer_111(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
  return;
}
}
static void start_clnt_assoc(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ldv_del_timer_sync_112(& pmlmeext->link_timer);
  pmlmeinfo->state = pmlmeinfo->state & 4294966527U;
  pmlmeinfo->state = pmlmeinfo->state | 9216U;
  issue_assocreq(padapter);
  tmp = msecs_to_jiffies(300U);
  ldv_mod_timer_113(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
  return;
}
}
int receive_disconnect23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                          unsigned short reason ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  tmp___0 = ether_addr_equal((u8 const   *)MacAddr, (u8 const   *)tmp);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "receive_disconnect23a");
  } else {

  }
  if ((pmlmeinfo->state & 3U) == 2U) {
    if ((pmlmeinfo->state & 16384U) != 0U) {
      pmlmeinfo->state = 0U;
      report_del_sta_event23a(padapter, MacAddr, (int )reason);
    } else
    if ((pmlmeinfo->state & 9984U) != 0U) {
      pmlmeinfo->state = 0U;
      report_join_res23a(padapter, -2);
    } else {

    }
  } else {

  }
  return (1);
}
}
static void process_80211d(struct rtw_adapter *padapter , struct wlan_bssid_ex *bssid ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct rt_channel_info *chplan_new ;
  u8 channel ;
  u8 i ;
  u8 const   *ie ;
  u8 const   *p ;
  struct rt_channel_plan chplan_ap ;
  struct rt_channel_info chplan_sta[38U] ;
  u8 country[4U] ;
  u8 fcn ;
  u8 noc ;
  u8 j ;
  u8 k ;
  u8 const   *tmp ;
  u8 const   *tmp___0 ;
  u8 tmp___1 ;

  {
  pregistrypriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned int )pregistrypriv->enable80211d != 0U && (unsigned int )pmlmeext->update_channel_plan_by_ap_done == 0U) {
    ie = cfg80211_find_ie(7, (u8 const   *)(& bssid->IEs), (int )bssid->IELength);
    if ((unsigned long )ie == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(ie + 1UL)) <= 5U) {
      return;
    } else {

    }
    p = ie + 2UL;
    ie = ie + (unsigned long )*(ie + 1UL);
    ie = ie + 2UL;
    memcpy((void *)(& country), (void const   *)p, 3UL);
    country[3] = 0U;
    p = p + 3UL;
    if (GlobalDebugLevel23A > 5U) {
      rt_trace(16, 6, "%s: 802.11d country =%s\n", "process_80211d", (u8 *)(& country));
    } else {

    }
    i = 0U;
    goto ldv_56868;
    ldv_56867: 
    tmp = p;
    p = p + 1;
    fcn = *tmp;
    tmp___0 = p;
    p = p + 1;
    noc = *tmp___0;
    p = p + 1;
    j = 0U;
    goto ldv_56865;
    ldv_56864: ;
    if ((unsigned int )fcn <= 14U) {
      channel = (int )fcn + (int )j;
    } else {
      channel = (unsigned int )j * 4U + (unsigned int )fcn;
    }
    tmp___1 = i;
    i = (u8 )((int )i + 1);
    chplan_ap.Channel[(int )tmp___1] = channel;
    j = (u8 )((int )j + 1);
    ldv_56865: ;
    if ((int )j < (int )noc) {
      goto ldv_56864;
    } else {

    }

    ldv_56868: ;
    if ((long )ie - (long )p > 2L) {
      goto ldv_56867;
    } else {

    }
    chplan_ap.Len = i;
    memcpy((void *)(& chplan_sta), (void const   *)(& pmlmeext->channel_set), 304UL);
    memset((void *)(& pmlmeext->channel_set), 0, 304UL);
    chplan_new = (struct rt_channel_info *)(& pmlmeext->channel_set);
    k = 0U;
    j = k;
    i = j;
    if (((int )pregistrypriv->wireless_mode & 2) != 0) {
      ldv_56871: ;
      if (((unsigned int )i == 38U || (unsigned int )chplan_sta[(int )i].ChannelNum == 0U) || (unsigned int )chplan_sta[(int )i].ChannelNum > 14U) {
        goto ldv_56870;
      } else {

      }
      if ((int )chplan_ap.Len == (int )j || (unsigned int )chplan_ap.Channel[(int )j] > 14U) {
        goto ldv_56870;
      } else {

      }
      if ((int )chplan_sta[(int )i].ChannelNum == (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
        (chplan_new + (unsigned long )k)->ScanType = 1;
        i = (u8 )((int )i + 1);
        j = (u8 )((int )j + 1);
        k = (u8 )((int )k + 1);
      } else
      if ((int )chplan_sta[(int )i].ChannelNum < (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
        (chplan_new + (unsigned long )k)->ScanType = 0;
        i = (u8 )((int )i + 1);
        k = (u8 )((int )k + 1);
      } else
      if ((int )chplan_sta[(int )i].ChannelNum > (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
        (chplan_new + (unsigned long )k)->ScanType = 1;
        j = (u8 )((int )j + 1);
        k = (u8 )((int )k + 1);
      } else {

      }
      goto ldv_56871;
      ldv_56870: ;
      goto ldv_56873;
      ldv_56872: 
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
      (chplan_new + (unsigned long )k)->ScanType = 0;
      i = (u8 )((int )i + 1);
      k = (u8 )((int )k + 1);
      ldv_56873: ;
      if (((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) && (unsigned int )chplan_sta[(int )i].ChannelNum <= 14U) {
        goto ldv_56872;
      } else {

      }

      goto ldv_56876;
      ldv_56875: 
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
      (chplan_new + (unsigned long )k)->ScanType = 1;
      j = (u8 )((int )j + 1);
      k = (u8 )((int )k + 1);
      ldv_56876: ;
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] <= 14U) {
        goto ldv_56875;
      } else {

      }

    } else {
      goto ldv_56879;
      ldv_56878: 
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
      (chplan_new + (unsigned long )k)->ScanType = chplan_sta[(int )i].ScanType;
      i = (u8 )((int )i + 1);
      k = (u8 )((int )k + 1);
      ldv_56879: ;
      if (((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) && (unsigned int )chplan_sta[(int )i].ChannelNum <= 14U) {
        goto ldv_56878;
      } else {

      }

      goto ldv_56882;
      ldv_56881: 
      j = (u8 )((int )j + 1);
      ldv_56882: ;
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] <= 14U) {
        goto ldv_56881;
      } else {

      }

    }
    if (((int )pregistrypriv->wireless_mode & 4) != 0) {
      ldv_56885: ;
      if ((unsigned int )i == 38U || (unsigned int )chplan_sta[(int )i].ChannelNum == 0U) {
        goto ldv_56884;
      } else {

      }
      if ((int )chplan_ap.Len == (int )j || (unsigned int )chplan_ap.Channel[(int )j] == 0U) {
        goto ldv_56884;
      } else {

      }
      if ((int )chplan_sta[(int )i].ChannelNum == (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
        (chplan_new + (unsigned long )k)->ScanType = 1;
        i = (u8 )((int )i + 1);
        j = (u8 )((int )j + 1);
        k = (u8 )((int )k + 1);
      } else
      if ((int )chplan_sta[(int )i].ChannelNum < (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
        (chplan_new + (unsigned long )k)->ScanType = 0;
        i = (u8 )((int )i + 1);
        k = (u8 )((int )k + 1);
      } else
      if ((int )chplan_sta[(int )i].ChannelNum > (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
        (chplan_new + (unsigned long )k)->ScanType = 1;
        j = (u8 )((int )j + 1);
        k = (u8 )((int )k + 1);
      } else {

      }
      goto ldv_56885;
      ldv_56884: ;
      goto ldv_56887;
      ldv_56886: 
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
      (chplan_new + (unsigned long )k)->ScanType = 0;
      i = (u8 )((int )i + 1);
      k = (u8 )((int )k + 1);
      ldv_56887: ;
      if ((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) {
        goto ldv_56886;
      } else {

      }

      goto ldv_56890;
      ldv_56889: 
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
      (chplan_new + (unsigned long )k)->ScanType = 1;
      j = (u8 )((int )j + 1);
      k = (u8 )((int )k + 1);
      ldv_56890: ;
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] != 0U) {
        goto ldv_56889;
      } else {

      }

    } else {
      goto ldv_56893;
      ldv_56892: 
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
      (chplan_new + (unsigned long )k)->ScanType = chplan_sta[(int )i].ScanType;
      i = (u8 )((int )i + 1);
      k = (u8 )((int )k + 1);
      ldv_56893: ;
      if ((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) {
        goto ldv_56892;
      } else {

      }

    }
    pmlmeext->update_channel_plan_by_ap_done = 1U;
  } else {

  }
  channel = (u8 )bssid->DSConfig;
  chplan_new = (struct rt_channel_info *)(& pmlmeext->channel_set);
  i = 0U;
  goto ldv_56897;
  ldv_56896: ;
  if ((int )(chplan_new + (unsigned long )i)->ChannelNum == (int )channel) {
    if ((unsigned int )(chplan_new + (unsigned long )i)->ScanType == 0U) {
      if ((unsigned int )channel > 51U && (unsigned int )channel <= 144U) {
        goto ldv_56895;
      } else {

      }
      (chplan_new + (unsigned long )i)->ScanType = 1;
      if (GlobalDebugLevel23A > 5U) {
        rt_trace(16, 6, "%s: change channel %d scan type from passive to active\n",
                 "process_80211d", (int )channel);
      } else {

      }
    } else {

    }
    goto ldv_56895;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56897: ;
  if ((unsigned int )i <= 37U && (unsigned int )(chplan_new + (unsigned long )i)->ChannelNum != 0U) {
    goto ldv_56896;
  } else {

  }
  ldv_56895: ;
  return;
}
}
void report_survey_event23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct survey_event *psurvey_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {

  }
  pmlmeext = & padapter->mlmeextpriv;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {

  }
  cmdsz = 16U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const   *)pcmd_obj);
    return;
  } else {

  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 8U;
  pc2h_evt_hdr->ID = 8U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  psurvey_evt = (struct survey_event *)pevtcmd + 8U;
  psurvey_evt->bss = collect_bss_info(padapter, precv_frame);
  if ((unsigned long )psurvey_evt->bss == (unsigned long )((struct wlan_bssid_ex *)0)) {
    kfree((void const   *)pcmd_obj);
    kfree((void const   *)pevtcmd);
    return;
  } else {

  }
  process_80211d(padapter, psurvey_evt->bss);
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  pmlmeext->sitesurvey_res.bss_cnt = pmlmeext->sitesurvey_res.bss_cnt + 1;
  return;
}
}
void report_surveydone_event23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct surveydone_event *psurveydone_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {

  }
  cmdsz = 12U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const   *)pcmd_obj);
    return;
  } else {

  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 4U;
  pc2h_evt_hdr->ID = 9U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  psurveydone_evt = (struct surveydone_event *)pevtcmd + 8U;
  psurveydone_evt->bss_cnt = (unsigned int )pmlmeext->sitesurvey_res.bss_cnt;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: survey done event(%x)\n", psurveydone_evt->bss_cnt);
  } else {

  }
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  return;
}
}
void report_join_res23a(struct rtw_adapter *padapter , int res ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct joinbss_event *pjoinbss_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {

  }
  cmdsz = 936U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const   *)pcmd_obj);
    return;
  } else {

  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 928U;
  pc2h_evt_hdr->ID = 10U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  pjoinbss_evt = (struct joinbss_event *)pevtcmd + 8U;
  memcpy((void *)(& pjoinbss_evt->network.network), (void const   *)(& pmlmeinfo->network),
           871UL);
  pjoinbss_evt->network.join_res = res;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: report_join_res23a(%d)\n", res);
  } else {

  }
  rtw_joinbss_event_prehandle23a(padapter, (u8 *)(& pjoinbss_evt->network));
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  return;
}
}
void report_del_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             unsigned short reason ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct sta_info *psta ;
  int mac_id ;
  struct stadel_event *pdel_sta_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {

  }
  cmdsz = 20U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const   *)pcmd_obj);
    return;
  } else {

  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 12U;
  pc2h_evt_hdr->ID = 12U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  pdel_sta_evt = (struct stadel_event *)pevtcmd + 8U;
  ether_addr_copy((u8 *)(& pdel_sta_evt->macaddr), (u8 const   *)MacAddr);
  memcpy((void *)(& pdel_sta_evt->rsvd), (void const   *)(& reason), 2UL);
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)MacAddr);
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    mac_id = (int )psta->mac_id;
  } else {
    mac_id = -1;
  }
  pdel_sta_evt->mac_id = mac_id;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: report_del_sta_event23a: delete STA, mac_id =%d\n", mac_id);
  } else {

  }
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  return;
}
}
void report_add_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             int cam_idx ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct stassoc_event *padd_sta_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {

  }
  cmdsz = 20U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const   *)pcmd_obj);
    return;
  } else {

  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 12U;
  pc2h_evt_hdr->ID = 11U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  padd_sta_evt = (struct stassoc_event *)pevtcmd + 8U;
  ether_addr_copy((u8 *)(& padd_sta_evt->macaddr), (u8 const   *)MacAddr);
  padd_sta_evt->cam_id = cam_idx;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: report_add_sta_event23a: add STA\n");
  } else {

  }
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  return;
}
}
void update_sta_info23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  VCS_update23a(padapter, psta);
  if ((int )pmlmepriv->htpriv.ht_option) {
    psta->htpriv.ht_option = 1;
    psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
    tmp = support_short_GI23a(padapter, & pmlmeinfo->ht_cap);
    if (tmp != 0) {
      psta->htpriv.sgi = 1U;
    } else {

    }
    psta->qos_option = 1U;
  } else {
    psta->htpriv.ht_option = 0;
    psta->htpriv.ampdu_enable = 0;
    psta->htpriv.sgi = 0U;
    psta->qos_option = 0U;
  }
  psta->htpriv.bwmode = pmlmeext->cur_bwmode;
  psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
  psta->htpriv.agg_enable_bitmap = 0U;
  psta->htpriv.candidate_tid_bitmap = 0U;
  if (pmlmepriv->qos_option != 0U) {
    psta->qos_option = 1U;
  } else {

  }
  psta->state = 1U;
  return;
}
}
void mlmeext_joinbss_event_callback23a(struct rtw_adapter *padapter , int join_res ) 
{ 
  struct sta_info *psta ;
  struct sta_info *psta_bmc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_priv *pstapriv ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  pstapriv = & padapter->stapriv;
  if (join_res < 0) {
    hw_var_set_mlme_join(padapter, 1);
    hw_var_set_bssid(padapter, (u8 *)(& null_addr));
    update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
    goto exit_mlmeext_joinbss_event_callback23a;
  } else {

  }
  if ((pmlmeinfo->state & 3U) == 1U) {
    psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
    if ((unsigned long )psta_bmc != (unsigned long )((struct sta_info *)0)) {
      pmlmeinfo->FW_sta_info[psta_bmc->mac_id].psta = psta_bmc;
      update_bmc_sta_support_rate23a(padapter, psta_bmc->mac_id);
      Update_RA_Entry23a(padapter, psta_bmc);
    } else {

    }
  } else {

  }
  rtl8723a_odm_support_ability_set(padapter, 268435455U);
  update_IOT_info23a(padapter);
  HalSetBrateCfg23a(padapter, (u8 *)(& cur_network->SupportedRates));
  rtl8723a_set_beacon_interval(padapter, (int )pmlmeinfo->bcn_interval);
  update_capinfo23a(padapter, (int )pmlmeinfo->capability);
  WMMOnAssocRsp23a(padapter);
  HTOnAssocRsp23a(padapter);
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
    psta->wireless_mode = pmlmeext->cur_wireless_mode;
    set_sta_rate23a(padapter, psta);
  } else {

  }
  hw_var_set_mlme_join(padapter, 2);
  if ((pmlmeinfo->state & 3U) == 2U) {
    rtw_correct_TSF(padapter);
  } else {

  }
  rtw_lps_ctrl_wk_cmd23a(padapter, 2, 0);
  exit_mlmeext_joinbss_event_callback23a: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: =>%s\n", "mlmeext_joinbss_event_callback23a");
  } else {

  }
  return;
}
}
void mlmeext_sta_add_event_callback23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "mlmeext_sta_add_event_callback23a");
  } else {

  }
  if ((pmlmeinfo->state & 3U) == 1U) {
    if ((pmlmeinfo->state & 16384U) != 0U) {

    } else {
      rtw_correct_TSF(padapter);
      tmp = send_beacon23a(padapter);
      if (tmp != 1) {
        pmlmeinfo->FW_sta_info[psta->mac_id].status = 0U;
        pmlmeinfo->state = pmlmeinfo->state ^ 1U;
        return;
      } else {

      }
      pmlmeinfo->state = pmlmeinfo->state | 16384U;
    }
    hw_var_set_mlme_join(padapter, 2);
  } else {

  }
  pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
  Update_RA_Entry23a(padapter, psta);
  update_sta_info23a(padapter, psta);
  return;
}
}
void mlmeext_sta_del_event_callback23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  bool tmp___0 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  tmp = is_client_associated_to_ap23a(padapter);
  if ((int )tmp) {
    goto _L;
  } else {
    tmp___0 = is_IBSS_empty23a(padapter);
    if ((int )tmp___0) {
      _L: /* CIL Label */ 
      hw_var_set_mlme_disconnect(padapter);
      hw_var_set_bssid(padapter, (u8 *)(& null_addr));
      update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
      pmlmeext->cur_bwmode = 0U;
      pmlmeext->cur_ch_offset = 0U;
      set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                            (int )pmlmeext->cur_bwmode);
      flush_all_cam_entry23a(padapter);
      pmlmeinfo->state = 0U;
      rtl8723a_set_media_status(padapter, 2);
      ldv_del_timer_sync_114(& pmlmeext->link_timer);
    } else {

    }
  }
  return;
}
}
static u8 chk_ap_is_alive(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 ret ;

  {
  ret = 0U;
  if ((psta->sta_stats.rx_data_pkts == psta->sta_stats.last_rx_data_pkts && psta->sta_stats.rx_beacon_pkts == psta->sta_stats.last_rx_beacon_pkts) && psta->sta_stats.rx_probersp_pkts == psta->sta_stats.last_rx_probersp_pkts) {
    ret = 0U;
  } else {
    ret = 1U;
  }
  psta->sta_stats.last_rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts;
  psta->sta_stats.last_rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts;
  psta->sta_stats.last_rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts;
  psta->sta_stats.last_rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts;
  psta->sta_stats.last_rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts;
  psta->sta_stats.last_rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts;
  psta->sta_stats.last_rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts;
  psta->sta_stats.last_rx_data_pkts = psta->sta_stats.rx_data_pkts;
  return (ret);
}
}
void linked_status_chk23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct sta_info *psta ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_priv *pstapriv ;
  int tx_chk ;
  int rx_chk ;
  int rx_chk_limit ;
  bool is_p2p_enable ;
  u8 tmp ;
  u8 backup_oper_channel ;
  u8 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pstapriv = & padapter->stapriv;
  tmp___4 = is_client_associated_to_ap23a(padapter);
  if ((int )tmp___4) {
    tx_chk = 1;
    rx_chk = 1;
    rx_chk_limit = 4;
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pmlmeinfo->network.MacAddress));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      is_p2p_enable = 0;
      tmp = chk_ap_is_alive(padapter, psta);
      if ((unsigned int )tmp == 0U) {
        rx_chk = 0;
      } else {

      }
      if (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts) {
        tx_chk = 0;
      } else {

      }
      if ((unsigned int )pmlmeext->active_keep_alive_check != 0U && (rx_chk == 0 || tx_chk == 0)) {
        backup_oper_channel = 0U;
        tmp___0 = rtw_get_oper_ch23a(padapter);
        if ((int )tmp___0 != (int )pmlmeext->cur_channel) {
          backup_oper_channel = rtw_get_oper_ch23a(padapter);
          SelectChannel23a(padapter, (int )pmlmeext->cur_channel);
        } else {

        }
        if (rx_chk != 1) {
          issue_probereq_ex(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& psta->hwaddr),
                            3, 1);
        } else {

        }
        if (tx_chk != 1) {
          tmp___1 = pmlmeinfo->link_count;
          pmlmeinfo->link_count = pmlmeinfo->link_count + 1U;
          if (tmp___1 == 15U) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (rx_chk != 1) {
          _L: /* CIL Label */ 
          tx_chk = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr),
                                     0U, 3, 1);
          if (tx_chk == 1 && ! is_p2p_enable) {
            rx_chk = 1;
          } else {

          }
        } else {

        }
        if ((unsigned int )backup_oper_channel != 0U) {
          SelectChannel23a(padapter, (int )backup_oper_channel);
        } else {

        }
      } else {
        if (rx_chk != 1) {
          if (pmlmeext->retry == 0U) {
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
          } else {

          }
        } else {

        }
        if (tx_chk != 1) {
          tmp___2 = pmlmeinfo->link_count;
          pmlmeinfo->link_count = pmlmeinfo->link_count + 1U;
          if (tmp___2 == 15U) {
            tx_chk = issue_nulldata23a(padapter, (unsigned char *)0U, 0U, 1, 0);
          } else {

          }
        } else {

        }
      }
      if (rx_chk == 0) {
        pmlmeext->retry = pmlmeext->retry + 1U;
        if (pmlmeext->retry > (u32 )rx_chk_limit) {
          if (GlobalDebugLevel23A != 0U) {
            printk("\016RTL8723AU: %s(%s): disconnect or roaming\n", "linked_status_chk23a",
                   (char *)(& (padapter->pnetdev)->name));
          } else {

          }
          receive_disconnect23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress),
                                65535);
          return;
        } else {

        }
      } else {
        pmlmeext->retry = 0U;
      }
      if (tx_chk == 0) {
        pmlmeinfo->link_count = pmlmeinfo->link_count & 15U;
      } else {
        pxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;
        pmlmeinfo->link_count = 0U;
      }
    } else {

    }
  } else {
    tmp___3 = is_client_associated_to_ibss23a(padapter);
    if ((int )tmp___3) {
      i = 2U;
      goto ldv_57010;
      ldv_57009: ;
      if (pmlmeinfo->FW_sta_info[i].status == 1U) {
        psta = pmlmeinfo->FW_sta_info[i].psta;
        if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
          goto ldv_57008;
        } else {

        }
        if ((u64 )pmlmeinfo->FW_sta_info[i].rx_pkt == (psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) {
          if (pmlmeinfo->FW_sta_info[i].retry <= 2U) {
            pmlmeinfo->FW_sta_info[i].retry = pmlmeinfo->FW_sta_info[i].retry + 1U;
          } else {
            pmlmeinfo->FW_sta_info[i].retry = 0U;
            pmlmeinfo->FW_sta_info[i].status = 0U;
            report_del_sta_event23a(padapter, (unsigned char *)(& psta->hwaddr), 65535);
          }
        } else {
          pmlmeinfo->FW_sta_info[i].retry = 0U;
          pmlmeinfo->FW_sta_info[i].rx_pkt = ((unsigned int )psta->sta_stats.rx_mgnt_pkts + (unsigned int )psta->sta_stats.rx_ctrl_pkts) + (unsigned int )psta->sta_stats.rx_data_pkts;
        }
      } else {

      }
      ldv_57008: 
      i = i + 1U;
      ldv_57010: ;
      if (i <= 31U) {
        goto ldv_57009;
      } else {

      }

    } else {

    }
  }
  return;
}
}
static void survey_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;
  struct cmd_obj *ph2c ;
  struct sitesurvey_parm *psurveyPara ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_ext_priv *pmlmeext ;
  void *tmp ;
  void *tmp___0 ;

  {
  padapter = (struct rtw_adapter *)data;
  pcmdpriv = & padapter->cmdpriv;
  pmlmeext = & padapter->mlmeextpriv;
  if (pmlmeext->sitesurvey_res.state > 1) {
    if (pmlmeext->sitesurvey_res.state == 3) {
      pmlmeext->sitesurvey_res.channel_idx = pmlmeext->sitesurvey_res.channel_idx + 1;
    } else {

    }
    if ((unsigned int )pmlmeext->scan_abort == 1U) {
      pmlmeext->sitesurvey_res.channel_idx = (int )pmlmeext->sitesurvey_res.ch_num;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s idx:%d\n", "survey_timer_hdl", pmlmeext->sitesurvey_res.channel_idx);
      } else {

      }
      pmlmeext->scan_abort = 0U;
    } else {

    }
    tmp = kzalloc(128UL, 32U);
    ph2c = (struct cmd_obj *)tmp;
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
      goto exit_survey_timer_hdl;
    } else {

    }
    tmp___0 = kzalloc(712UL, 32U);
    psurveyPara = (struct sitesurvey_parm *)tmp___0;
    if ((unsigned long )psurveyPara == (unsigned long )((struct sitesurvey_parm *)0)) {
      kfree((void const   *)ph2c);
      goto exit_survey_timer_hdl;
    } else {

    }
    ph2c->cmdcode = 18U;
    ph2c->parmbuf = (u8 *)psurveyPara;
    ph2c->cmdsz = 712U;
    ph2c->rsp = (u8 *)0U;
    ph2c->rspsz = 0U;
    rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  } else {

  }
  exit_survey_timer_hdl: ;
  return;
}
}
static void link_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  padapter = (struct rtw_adapter *)data;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((pmlmeinfo->state & 256U) != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link_timer_hdl:no beacon while connecting\n");
    } else {

    }
    pmlmeinfo->state = 0U;
    report_join_res23a(padapter, -3);
  } else
  if ((pmlmeinfo->state & 512U) != 0U) {
    pmlmeinfo->reauth_count = pmlmeinfo->reauth_count + 1U;
    if (pmlmeinfo->reauth_count > 4U) {
      pmlmeinfo->state = 0U;
      report_join_res23a(padapter, -1);
      return;
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link_timer_hdl: auth timeout and try again\n");
    } else {

    }
    pmlmeinfo->auth_seq = 1U;
    issue_auth(padapter, (struct sta_info *)0, 0);
    tmp = msecs_to_jiffies(300U);
    ldv_mod_timer_115(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
  } else
  if ((pmlmeinfo->state & 8192U) != 0U) {
    pmlmeinfo->reassoc_count = pmlmeinfo->reassoc_count + 1U;
    if (pmlmeinfo->reassoc_count > 4U) {
      pmlmeinfo->state = 0U;
      report_join_res23a(padapter, -2);
      return;
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link_timer_hdl: assoc timeout and try again\n");
    } else {

    }
    issue_assocreq(padapter);
    tmp___0 = msecs_to_jiffies(300U);
    ldv_mod_timer_116(& pmlmeext->link_timer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
  return;
}
}
static void addba_timer_hdl(unsigned long data ) 
{ 
  struct sta_info *psta ;
  struct ht_priv *phtpriv ;

  {
  psta = (struct sta_info *)data;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {

  }
  phtpriv = & psta->htpriv;
  if ((int )phtpriv->ht_option && (int )phtpriv->ampdu_enable) {
    if ((unsigned int )phtpriv->candidate_tid_bitmap != 0U) {
      phtpriv->candidate_tid_bitmap = 0U;
    } else {

    }
  } else {

  }
  return;
}
}
void init_addba_retry_timer23a(struct sta_info *psta ) 
{ 


  {
  reg_timer_11(& psta->addba_retry_timer, & addba_timer_hdl, (unsigned long )psta);
  return;
}
}
void init_mlme_ext_timer23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  reg_timer_11(& pmlmeext->survey_timer, & survey_timer_hdl, (unsigned long )padapter);
  reg_timer_11(& pmlmeext->link_timer, & link_timer_hdl, (unsigned long )padapter);
  return;
}
}
int NULL_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
  return (0);
}
}
int setopmode_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  enum nl80211_iftype type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct setopmode_parm  const  *psetop ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  psetop = (struct setopmode_parm  const  *)pbuf;
  switch ((unsigned int )psetop->mode) {
  case 9U: ;
  case 3U: 
  pmlmeinfo->state = 3U;
  type = 3;
  goto ldv_57054;
  case 8U: ;
  case 2U: 
  pmlmeinfo->state = pmlmeinfo->state & 4294967292U;
  pmlmeinfo->state = pmlmeinfo->state | 2U;
  type = 2;
  goto ldv_57054;
  case 1U: 
  type = 1;
  goto ldv_57054;
  default: 
  type = 0;
  goto ldv_57054;
  }
  ldv_57054: 
  hw_var_set_opmode(padapter, (int )((u8 )type));
  return (0);
}
}
int createbss_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_bssid_ex  const  *pparm ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  pparm = (struct wlan_bssid_ex  const  *)pbuf;
  if ((unsigned int )pparm->ifmode == 3U || (unsigned int )pparm->ifmode == 9U) {
    if (pmlmeinfo->state == 3U) {
      return (0);
    } else {

    }
  } else {

  }
  if ((unsigned int )pparm->ifmode == 1U) {
    rtw_joinbss_reset23a(padapter);
    pmlmeext->cur_bwmode = 0U;
    pmlmeext->cur_ch_offset = 0U;
    pmlmeinfo->ERP_enable = 0U;
    pmlmeinfo->WMM_enable = 0U;
    pmlmeinfo->HT_enable = 0U;
    pmlmeinfo->HT_caps_enable = 0U;
    pmlmeinfo->HT_info_enable = 0U;
    rtl8723a_odm_support_ability_backup(padapter);
    rtl8723a_odm_support_ability_clr(padapter, 0U);
    ldv_del_timer_sync_117(& pmlmeext->link_timer);
    flush_all_cam_entry23a(padapter);
    if ((unsigned int )pparm->IELength > 768U) {
      return (4);
    } else {

    }
    memcpy((void *)pnetwork, (void const   *)pparm, 871UL);
    start_create_ibss(padapter);
  } else {

  }
  return (0);
}
}
int join_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_bssid_ex  const  *pparm ;
  struct ieee80211_ht_operation *pht_info ;
  u32 i ;
  u8 *p ;
  int tmp ;

  {
  pregpriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  pparm = (struct wlan_bssid_ex  const  *)pbuf;
  if ((pmlmeinfo->state & 16384U) != 0U) {
    if ((pmlmeinfo->state & 2U) != 0U) {
      issue_deauth_ex(padapter, (u8 *)(& pnetwork->MacAddress), 3, 5, 100);
    } else {

    }
    pmlmeinfo->state = 0U;
    flush_all_cam_entry23a(padapter);
    ldv_del_timer_sync_118(& pmlmeext->link_timer);
    rtl8723a_set_media_status(padapter, 2);
    hw_var_set_mlme_disconnect(padapter);
  } else {

  }
  rtw_joinbss_reset23a(padapter);
  pmlmeext->cur_bwmode = 0U;
  pmlmeext->cur_ch_offset = 0U;
  pmlmeinfo->ERP_enable = 0U;
  pmlmeinfo->WMM_enable = 0U;
  pmlmeinfo->HT_enable = 0U;
  pmlmeinfo->HT_caps_enable = 0U;
  pmlmeinfo->HT_info_enable = 0U;
  pmlmeinfo->bwmode_updated = 0U;
  if ((unsigned int )pparm->IELength > 768U) {
    return (4);
  } else {

  }
  memcpy((void *)pnetwork, (void const   *)pbuf, 871UL);
  i = 0U;
  goto ldv_57089;
  ldv_57088: 
  p = (u8 *)(& pnetwork->IEs) + (unsigned long )i;
  switch ((int )*p) {
  case 221: 
  tmp = memcmp((void const   *)p + 2U, (void const   *)(& WMM_OUI23A), 4UL);
  if (tmp == 0) {
    pmlmeinfo->WMM_enable = 1U;
  } else {

  }
  goto ldv_57080;
  case 45: 
  pmlmeinfo->HT_caps_enable = 1U;
  goto ldv_57080;
  case 61: 
  pmlmeinfo->HT_info_enable = 1U;
  pht_info = (struct ieee80211_ht_operation *)p + 2U;
  if ((unsigned int )pregpriv->cbw40_enable != 0U && ((int )pht_info->ht_param & 4) != 0) {
    pmlmeext->cur_bwmode = 1U;
    switch ((int )pht_info->ht_param & 3) {
    case 1: 
    pmlmeext->cur_ch_offset = 1U;
    goto ldv_57084;
    case 3: 
    pmlmeext->cur_ch_offset = 2U;
    goto ldv_57084;
    default: 
    pmlmeext->cur_ch_offset = 0U;
    goto ldv_57084;
    }
    ldv_57084: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: set ch/bw before connected\n");
    } else {

    }
  } else {

  }
  goto ldv_57080;
  default: ;
  goto ldv_57080;
  }
  ldv_57080: 
  i = ((u32 )*(p + 1UL) + i) + 2U;
  ldv_57089: ;
  if (pnetwork->IELength > i) {
    goto ldv_57088;
  } else {

  }
  hw_var_set_bssid(padapter, (u8 *)(& pmlmeinfo->network.MacAddress));
  hw_var_set_mlme_join(padapter, 0);
  ldv_del_timer_sync_119(& pmlmeext->link_timer);
  start_clnt_join(padapter);
  return (0);
}
}
int disconnect_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct disconnect_parm  const  *param ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  bool tmp ;

  {
  param = (struct disconnect_parm  const  *)pbuf;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  tmp = is_client_associated_to_ap23a(padapter);
  if ((int )tmp) {
    issue_deauth_ex(padapter, (u8 *)(& pnetwork->MacAddress), 3, (int )((unsigned int )param->deauth_timeout_ms / 100U),
                    100);
  } else {

  }
  hw_var_set_mlme_disconnect(padapter);
  hw_var_set_bssid(padapter, (u8 *)(& null_addr));
  update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
    rtl8723a_set_bcn_func(padapter, 0);
  } else {

  }
  rtl8723a_set_media_status(padapter, 2);
  pmlmeinfo->state = 0U;
  pmlmeext->cur_bwmode = 0U;
  pmlmeext->cur_ch_offset = 0U;
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  flush_all_cam_entry23a(padapter);
  ldv_del_timer_sync_120(& pmlmeext->link_timer);
  rtw_free_uc_swdec_pending_queue23a(padapter);
  return (0);
}
}
static int rtw_scan_ch_decision(struct rtw_adapter *padapter , struct rtw_ieee80211_channel *out ,
                                u32 out_num , struct rtw_ieee80211_channel  const  *in ,
                                u32 in_num ) 
{ 
  int i ;
  int j ;
  int scan_ch_num ;
  int set_idx ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;

  {
  scan_ch_num = 0;
  pmlmeext = & padapter->mlmeextpriv;
  memset((void *)out, 0, (unsigned long )out_num * 8UL);
  j = 0;
  i = 0;
  goto ldv_57113;
  ldv_57112: ;
  if ((unsigned int )((unsigned short )(in + (unsigned long )i)->hw_value) != 0U && ((unsigned int )(in + (unsigned long )i)->flags & 1U) == 0U) {
    set_idx = rtw_ch_set_search_ch23a((struct rt_channel_info *)(& pmlmeext->channel_set),
                                      (u32 const   )(in + (unsigned long )i)->hw_value);
    if (set_idx >= 0) {
      memcpy((void *)out + (unsigned long )j, (void const   *)in + (unsigned long )i,
               8UL);
      if ((unsigned int )pmlmeext->channel_set[set_idx].ScanType == 0U) {
        (out + (unsigned long )j)->flags = (out + (unsigned long )j)->flags & 2U;
      } else {

      }
      j = j + 1;
    } else {

    }
  } else {

  }
  if ((u32 )j >= out_num) {
    goto ldv_57111;
  } else {

  }
  i = i + 1;
  ldv_57113: ;
  if ((u32 )i < in_num) {
    goto ldv_57112;
  } else {

  }
  ldv_57111: ;
  if (j == 0) {
    i = 0;
    goto ldv_57115;
    ldv_57114: 
    (out + (unsigned long )i)->hw_value = (u16 )pmlmeext->channel_set[i].ChannelNum;
    if ((unsigned int )pmlmeext->channel_set[i].ScanType == 0U) {
      (out + (unsigned long )i)->flags = (out + (unsigned long )i)->flags & 2U;
    } else {

    }
    j = j + 1;
    i = i + 1;
    ldv_57115: ;
    if ((int )pmlmeext->max_chan_nums > i) {
      goto ldv_57114;
    } else {

    }

  } else {

  }
  if (padapter->setband == 2U) {
    i = 0;
    goto ldv_57118;
    ldv_57117: ;
    if ((unsigned int )(out + (unsigned long )i)->hw_value > 35U) {
      memset((void *)out + (unsigned long )i, 0, 8UL);
    } else {
      scan_ch_num = scan_ch_num + 1;
    }
    i = i + 1;
    ldv_57118: ;
    if (i < j) {
      goto ldv_57117;
    } else {

    }
    j = scan_ch_num;
  } else
  if (padapter->setband == 1U) {
    i = 0;
    goto ldv_57121;
    ldv_57120: ;
    if ((unsigned int )(out + (unsigned long )i)->hw_value > 35U) {
      tmp = scan_ch_num;
      scan_ch_num = scan_ch_num + 1;
      memcpy((void *)out + (unsigned long )tmp, (void const   *)out + (unsigned long )i,
               8UL);
    } else {

    }
    i = i + 1;
    ldv_57121: ;
    if (i < j) {
      goto ldv_57120;
    } else {

    }
    j = scan_ch_num;
  } else {

  }
  return (j);
}
}
int sitesurvey_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct sitesurvey_parm  const  *pparm ;
  u8 bdelayscan ;
  u32 initialgain ;
  u32 i ;
  int tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  void *tmp___3 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pparm = (struct sitesurvey_parm  const  *)pbuf;
  bdelayscan = 0U;
  if (pmlmeext->sitesurvey_res.state == 0) {
    pmlmeext->sitesurvey_res.state = 1;
    pmlmeext->sitesurvey_res.bss_cnt = 0;
    pmlmeext->sitesurvey_res.channel_idx = 0;
    i = 0U;
    goto ldv_57133;
    ldv_57132: ;
    if ((unsigned int )((unsigned char )pparm->ssid[i].ssid_len) != 0U) {
      memcpy((void *)(& pmlmeext->sitesurvey_res.ssid[i].ssid), (void const   *)(& pparm->ssid[i].ssid),
               32UL);
      pmlmeext->sitesurvey_res.ssid[i].ssid_len = pparm->ssid[i].ssid_len;
    } else {
      pmlmeext->sitesurvey_res.ssid[i].ssid_len = 0U;
    }
    i = i + 1U;
    ldv_57133: ;
    if (i <= 8U) {
      goto ldv_57132;
    } else {

    }
    tmp = rtw_scan_ch_decision(padapter, (struct rtw_ieee80211_channel *)(& pmlmeext->sitesurvey_res.ch),
                               51U, (struct rtw_ieee80211_channel  const  *)(& pparm->ch),
                               (u32 )pparm->ch_num);
    pmlmeext->sitesurvey_res.ch_num = (u8 )tmp;
    pmlmeext->sitesurvey_res.scan_mode = pparm->scan_mode;
    tmp___1 = is_client_associated_to_ap23a(padapter);
    if ((int )tmp___1) {
      pmlmeext->sitesurvey_res.state = 2;
      tmp___0 = rtw_get_oper_ch23a(padapter);
      if ((int )tmp___0 != (int )pmlmeext->cur_channel) {
        SelectChannel23a(padapter, (int )pmlmeext->cur_channel);
      } else {

      }
      issue_nulldata23a(padapter, (unsigned char *)0U, 1U, 3, 500);
      bdelayscan = 1U;
    } else {

    }
    if ((unsigned int )bdelayscan != 0U) {
      tmp___2 = msecs_to_jiffies(50U);
      ldv_mod_timer_121(& pmlmeext->survey_timer, tmp___2 + (unsigned long )jiffies);
      return (0);
    } else {

    }
  } else {

  }
  if (pmlmeext->sitesurvey_res.state == 1 || pmlmeext->sitesurvey_res.state == 2) {
    rtl8723a_odm_support_ability_backup(padapter);
    rtl8723a_odm_support_ability_clr(padapter, 0U);
    tmp___3 = wdev_priv___0(padapter->rtw_wdev);
    if ((unsigned int )((struct rtw_wdev_priv *)tmp___3)->p2p_enabled == 1U) {
      initialgain = 48U;
    } else {
      initialgain = 30U;
    }
    rtl8723a_set_initial_gain(padapter, initialgain);
    rtl8723a_set_media_status(padapter, 0);
    rtl8723a_mlme_sitesurvey(padapter, 1);
    pmlmeext->sitesurvey_res.state = 3;
  } else {

  }
  rtw_site_survey(padapter);
  return (0);
}
}
int setauth_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct setauth_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pparm = (struct setauth_parm  const  *)pbuf;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )((unsigned char )pparm->mode) <= 3U) {
    pmlmeinfo->auth_algo = (u32 )pparm->mode;
  } else {

  }
  return (0);
}
}
int setkey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  unsigned short ctrl ;
  struct setkey_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char null_sta[6U] ;

  {
  pparm = (struct setkey_parm  const  *)pbuf;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  null_sta[0] = 0U;
  null_sta[1] = 0U;
  null_sta[2] = 0U;
  null_sta[3] = 0U;
  null_sta[4] = 0U;
  null_sta[5] = 0U;
  if ((unsigned int )((unsigned char )pparm->set_tx) != 0U) {
    pmlmeinfo->key_index = (u32 )pparm->keyid;
  } else {

  }
  ctrl = (unsigned int )(((int )((unsigned short )pparm->algorithm) << 2U) | (int )((unsigned short )pparm->keyid)) | 32768U;
  if (GlobalDebugLevel23A != 0U) {
    printk("\016RTL8723AU: set group key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) keyid:%d\n",
           pparm->algorithm, (int )pparm->keyid);
  } else {

  }
  rtl8723a_cam_write(padapter, (int )pparm->keyid, (int )ctrl, (u8 const   *)(& null_sta),
                     (u8 const   *)(& pparm->key));
  rtl8723a_on_rcr_am(padapter);
  return (0);
}
}
int set_stakey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  u16 ctrl ;
  u8 cam_id ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct set_stakey_parm  const  *pparm ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;

  {
  ctrl = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pparm = (struct set_stakey_parm  const  *)pbuf;
  cam_id = 4U;
  if (GlobalDebugLevel23A != 0U) {
    printk("\016RTL8723AU: set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) camid:%d\n",
           pparm->algorithm, (int )cam_id);
  } else {

  }
  if ((pmlmeinfo->state & 3U) == 3U) {
    pstapriv = & padapter->stapriv;
    if ((unsigned int )pparm->algorithm == 0U) {
      clear_cam_entry23a(padapter, (int )pparm->id);
      return (1);
    } else {

    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pparm->addr));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      ctrl = (unsigned int )((int )((u16 )pparm->algorithm) << 2U) | 32768U;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: r871x_set_stakey_hdl23a(): enc_algorithm =%d\n", pparm->algorithm);
      } else {

      }
      if (psta->mac_id == 0U || psta->mac_id > 28U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: r871x_set_stakey_hdl23a():set_stakey failed, mac_id(aid) =%d\n",
                 psta->mac_id);
        } else {

        }
        return (5);
      } else {

      }
      cam_id = (unsigned int )((u8 )psta->mac_id) + 3U;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Write CAM, mac_addr =%x:%x:%x:%x:%x:%x, cam_entry =%d\n",
               (int )pparm->addr[0], (int )pparm->addr[1], (int )pparm->addr[2], (int )pparm->addr[3],
               (int )pparm->addr[4], (int )pparm->addr[5], (int )cam_id);
      } else {

      }
      rtl8723a_cam_write(padapter, (int )cam_id, (int )ctrl, (u8 const   *)(& pparm->addr),
                         (u8 const   *)(& pparm->key));
      return (1);
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: r871x_set_stakey_hdl23a(): sta has been free\n");
      } else {

      }
      return (5);
    }
  } else {

  }
  if ((unsigned int )pparm->algorithm == 0U) {
    clear_cam_entry23a(padapter, (int )pparm->id);
    return (0);
  } else {

  }
  ctrl = (unsigned int )((int )((u16 )pparm->algorithm) << 2U) | 32768U;
  rtl8723a_cam_write(padapter, (int )cam_id, (int )ctrl, (u8 const   *)(& pparm->addr),
                     (u8 const   *)(& pparm->key));
  pmlmeinfo->enc_algo = pparm->algorithm;
  return (0);
}
}
int add_ba_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct addBaReq_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_info *psta ;
  unsigned long tmp ;

  {
  pparm = (struct addBaReq_parm  const  *)pbuf;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pparm->addr));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (0);
  } else {

  }
  if (((pmlmeinfo->state & 16384U) != 0U && (unsigned int )pmlmeinfo->HT_enable != 0U) || (pmlmeinfo->state & 3U) == 3U) {
    issue_action_BA23a(padapter, (unsigned char const   *)(& pparm->addr), 0, (int )((unsigned short )pparm->tid));
    tmp = msecs_to_jiffies(2000U);
    ldv_mod_timer_122(& psta->addba_retry_timer, tmp + (unsigned long )jiffies);
  } else {
    psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )pparm->tid)));
  }
  return (0);
}
}
int set_tx_beacon_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct Tx_Beacon_param *ptxBeacon_parm ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 res ;
  int len_diff ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  res = 1U;
  len_diff = 0;
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0U;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(871UL, 32U);
  ptxBeacon_parm = (struct Tx_Beacon_param *)tmp___0;
  if ((unsigned long )ptxBeacon_parm == (unsigned long )((struct Tx_Beacon_param *)0)) {
    kfree((void const   *)ph2c);
    res = 0U;
    goto exit;
  } else {

  }
  memcpy((void *)(& ptxBeacon_parm->network), (void const   *)(& pmlmeinfo->network),
           871UL);
  len_diff = update_hidden_ssid((u8 *)(& ptxBeacon_parm->network.IEs), ptxBeacon_parm->network.IELength,
                                (int )pmlmeinfo->hidden_ssid_mode);
  ptxBeacon_parm->network.IELength = ptxBeacon_parm->network.IELength + (u32 )len_diff;
  ph2c->cmdcode = 55U;
  ph2c->parmbuf = (u8 *)ptxBeacon_parm;
  ph2c->cmdsz = 871U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  tmp___1 = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  res = (u8 )tmp___1;
  exit: ;
  return ((int )res);
}
}
int mlme_evt_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  u8 evt_code ;
  u8 evt_seq ;
  u16 evt_sz ;
  struct C2HEvent_Header  const  *c2h ;
  void (*event_callback)(struct rtw_adapter * , u8 const   * ) ;

  {
  c2h = (struct C2HEvent_Header  const  *)pbuf;
  evt_sz = c2h->len;
  evt_seq = c2h->seq;
  evt_code = c2h->ID;
  if ((unsigned int )evt_code > 24U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "Event Code(%d) mismatch!\n", (int )evt_code);
    } else {

    }
    goto _abort_event_;
  } else {

  }
  if (wlanevents[(int )evt_code].parmsize != 0U && wlanevents[(int )evt_code].parmsize != (u32 )evt_sz) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(128, 4, "Event(%d) Parm Size mismatch (%d vs %d)!\n", (int )evt_code,
               wlanevents[(int )evt_code].parmsize, (int )evt_sz);
    } else {

    }
    goto _abort_event_;
  } else {

  }
  event_callback = wlanevents[(int )evt_code].event_callback;
  (*event_callback)(padapter, pbuf + 8UL);
  _abort_event_: ;
  return (0);
}
}
int h2c_msg_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
    return (4);
  } else {

  }
  return (0);
}
}
int tx_beacon_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct sta_info *psta_bmc ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct xmit_priv *pxmitpriv ;
  struct sta_priv *pstapriv ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  tmp = send_beacon23a(padapter);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: issue_beacon23a, fail!\n");
    } else {

    }
    return (4);
  } else {
    pxmitpriv = & padapter->xmitpriv;
    pstapriv = & padapter->stapriv;
    psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
    if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
      return (0);
    } else {

    }
    if ((int )pstapriv->tim_bitmap & 1 && psta_bmc->sleepq_len != 0U) {
      msleep(10U);
      spin_lock_bh(& pxmitpriv->lock);
      phead = get_list_head(& psta_bmc->sleep_q);
      plist = phead->next;
      ptmp = plist->next;
      goto ldv_57211;
      ldv_57210: 
      __mptr = (struct list_head  const  *)plist;
      pxmitframe = (struct xmit_frame *)__mptr;
      list_del_init(& pxmitframe->list);
      psta_bmc->sleepq_len = psta_bmc->sleepq_len - 1U;
      if (psta_bmc->sleepq_len != 0U) {
        pxmitframe->attrib.mdata = 1U;
      } else {
        pxmitframe->attrib.mdata = 0U;
      }
      pxmitframe->attrib.triggered = 1U;
      pxmitframe->attrib.qsel = 17U;
      rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
      plist = ptmp;
      ptmp = plist->next;
      ldv_57211: ;
      if ((unsigned long )plist != (unsigned long )phead) {
        goto ldv_57210;
      } else {

      }
      spin_unlock_bh(& pxmitpriv->lock);
    } else {

    }
  }
  return (0);
}
}
int set_ch_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct set_ch_parm  const  *set_ch_parm ;
  struct mlme_ext_priv *pmlmeext ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
    return (4);
  } else {

  }
  set_ch_parm = (struct set_ch_parm  const  *)pbuf;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): ch:%u, bw:%u, ch_offset:%u\n", "set_ch_hdl23a",
           (char *)(& (padapter->pnetdev)->name), (int )set_ch_parm->ch, (int )set_ch_parm->bw,
           (int )set_ch_parm->ch_offset);
  } else {

  }
  pmlmeext->cur_channel = set_ch_parm->ch;
  pmlmeext->cur_ch_offset = set_ch_parm->ch_offset;
  pmlmeext->cur_bwmode = set_ch_parm->bw;
  set_channel_bwmode23a(padapter, (int )set_ch_parm->ch, (int )set_ch_parm->ch_offset,
                        (int )set_ch_parm->bw);
  return (0);
}
}
int set_chplan_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct SetChannelPlan_param  const  *setChannelPlan_param ;
  struct mlme_ext_priv *pmlmeext ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
    return (4);
  } else {

  }
  setChannelPlan_param = (struct SetChannelPlan_param  const  *)pbuf;
  pmlmeext->max_chan_nums = init_channel_set(padapter, (int )setChannelPlan_param->channel_plan,
                                             (struct rt_channel_info *)(& pmlmeext->channel_set));
  init_channel_list(padapter, (struct rt_channel_info *)(& pmlmeext->channel_set),
                    (int )pmlmeext->max_chan_nums, & pmlmeext->channel_list);
  return (0);
}
}
int led_blink_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct LedBlink_param *ledBlink_param ;

  {
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
    return (4);
  } else {

  }
  ledBlink_param = (struct LedBlink_param *)pbuf;
  return (0);
}
}
int set_csa_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
  return (5);
}
}
int tdls_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
  return (5);
}
}
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_9_0 == (unsigned long )timer) {
    if (ldv_timer_9_0 == 2 || pending_flag != 0) {
      ldv_timer_list_9_0 = timer;
      ldv_timer_list_9_0->data = data;
      ldv_timer_9_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_9_1 == (unsigned long )timer) {
    if (ldv_timer_9_1 == 2 || pending_flag != 0) {
      ldv_timer_list_9_1 = timer;
      ldv_timer_list_9_1->data = data;
      ldv_timer_9_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_9_2 == (unsigned long )timer) {
    if (ldv_timer_9_2 == 2 || pending_flag != 0) {
      ldv_timer_list_9_2 = timer;
      ldv_timer_list_9_2->data = data;
      ldv_timer_9_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_9_3 == (unsigned long )timer) {
    if (ldv_timer_9_3 == 2 || pending_flag != 0) {
      ldv_timer_list_9_3 = timer;
      ldv_timer_list_9_3->data = data;
      ldv_timer_9_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_9(timer, data);
  return;
}
}
void disable_suitable_timer_8(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_8_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_0) {
    ldv_timer_8_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_8_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_1) {
    ldv_timer_8_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_8_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_2) {
    ldv_timer_8_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_8_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_3) {
    ldv_timer_8_3 = 0;
    return;
  } else {

  }
  return;
}
}
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_10_0 == (unsigned long )timer) {
    if (ldv_timer_10_0 == 2 || pending_flag != 0) {
      ldv_timer_list_10_0 = timer;
      ldv_timer_list_10_0->data = data;
      ldv_timer_10_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_10_1 == (unsigned long )timer) {
    if (ldv_timer_10_1 == 2 || pending_flag != 0) {
      ldv_timer_list_10_1 = timer;
      ldv_timer_list_10_1->data = data;
      ldv_timer_10_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_10_2 == (unsigned long )timer) {
    if (ldv_timer_10_2 == 2 || pending_flag != 0) {
      ldv_timer_list_10_2 = timer;
      ldv_timer_list_10_2->data = data;
      ldv_timer_10_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_10_3 == (unsigned long )timer) {
    if (ldv_timer_10_3 == 2 || pending_flag != 0) {
      ldv_timer_list_10_3 = timer;
      ldv_timer_list_10_3->data = data;
      ldv_timer_10_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_10(timer, data);
  return;
}
}
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& link_timer_hdl)) {
    activate_suitable_timer_10(timer, data);
  } else {

  }
  return (0);
}
}
void ldv_timer_9(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  survey_timer_hdl(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_8_0 == (unsigned long )timer) {
    if (ldv_timer_8_0 == 2 || pending_flag != 0) {
      ldv_timer_list_8_0 = timer;
      ldv_timer_list_8_0->data = data;
      ldv_timer_8_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_8_1 == (unsigned long )timer) {
    if (ldv_timer_8_1 == 2 || pending_flag != 0) {
      ldv_timer_list_8_1 = timer;
      ldv_timer_list_8_1->data = data;
      ldv_timer_8_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_8_2 == (unsigned long )timer) {
    if (ldv_timer_8_2 == 2 || pending_flag != 0) {
      ldv_timer_list_8_2 = timer;
      ldv_timer_list_8_2->data = data;
      ldv_timer_8_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_8_3 == (unsigned long )timer) {
    if (ldv_timer_8_3 == 2 || pending_flag != 0) {
      ldv_timer_list_8_3 = timer;
      ldv_timer_list_8_3->data = data;
      ldv_timer_8_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_8(timer, data);
  return;
}
}
void timer_init_9(void) 
{ 


  {
  ldv_timer_9_0 = 0;
  ldv_timer_9_1 = 0;
  ldv_timer_9_2 = 0;
  ldv_timer_9_3 = 0;
  return;
}
}
void ldv_timer_10(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  link_timer_hdl(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void activate_suitable_timer_9(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_9_0 == 0 || ldv_timer_9_0 == 2) {
    ldv_timer_list_9_0 = timer;
    ldv_timer_list_9_0->data = data;
    ldv_timer_9_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_9_1 == 0 || ldv_timer_9_1 == 2) {
    ldv_timer_list_9_1 = timer;
    ldv_timer_list_9_1->data = data;
    ldv_timer_9_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_9_2 == 0 || ldv_timer_9_2 == 2) {
    ldv_timer_list_9_2 = timer;
    ldv_timer_list_9_2->data = data;
    ldv_timer_9_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_9_3 == 0 || ldv_timer_9_3 == 2) {
    ldv_timer_list_9_3 = timer;
    ldv_timer_list_9_3->data = data;
    ldv_timer_9_3 = 1;
    return;
  } else {

  }
  return;
}
}
void disable_suitable_timer_10(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_10_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_0) {
    ldv_timer_10_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_10_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_1) {
    ldv_timer_10_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_10_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_2) {
    ldv_timer_10_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_10_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_3) {
    ldv_timer_10_3 = 0;
    return;
  } else {

  }
  return;
}
}
void choose_timer_8(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_8_0 == 1) {
    ldv_timer_8_0 = 2;
    ldv_timer_8(ldv_timer_8_0, ldv_timer_list_8_0);
  } else {

  }
  goto ldv_57285;
  case 1: ;
  if (ldv_timer_8_1 == 1) {
    ldv_timer_8_1 = 2;
    ldv_timer_8(ldv_timer_8_1, ldv_timer_list_8_1);
  } else {

  }
  goto ldv_57285;
  case 2: ;
  if (ldv_timer_8_2 == 1) {
    ldv_timer_8_2 = 2;
    ldv_timer_8(ldv_timer_8_2, ldv_timer_list_8_2);
  } else {

  }
  goto ldv_57285;
  case 3: ;
  if (ldv_timer_8_3 == 1) {
    ldv_timer_8_3 = 2;
    ldv_timer_8(ldv_timer_8_3, ldv_timer_list_8_3);
  } else {

  }
  goto ldv_57285;
  default: 
  ldv_stop();
  }
  ldv_57285: ;
  return;
}
}
int reg_timer_9(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& survey_timer_hdl)) {
    activate_suitable_timer_9(timer, data);
  } else {

  }
  return (0);
}
}
int reg_timer_8(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& addba_timer_hdl)) {
    activate_suitable_timer_8(timer, data);
  } else {

  }
  return (0);
}
}
void disable_suitable_timer_9(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_9_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_0) {
    ldv_timer_9_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_9_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_1) {
    ldv_timer_9_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_9_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_2) {
    ldv_timer_9_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_9_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_3) {
    ldv_timer_9_3 = 0;
    return;
  } else {

  }
  return;
}
}
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_10_0 == 0 || ldv_timer_10_0 == 2) {
    ldv_timer_list_10_0 = timer;
    ldv_timer_list_10_0->data = data;
    ldv_timer_10_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_10_1 == 0 || ldv_timer_10_1 == 2) {
    ldv_timer_list_10_1 = timer;
    ldv_timer_list_10_1->data = data;
    ldv_timer_10_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_10_2 == 0 || ldv_timer_10_2 == 2) {
    ldv_timer_list_10_2 = timer;
    ldv_timer_list_10_2->data = data;
    ldv_timer_10_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_10_3 == 0 || ldv_timer_10_3 == 2) {
    ldv_timer_list_10_3 = timer;
    ldv_timer_list_10_3->data = data;
    ldv_timer_10_3 = 1;
    return;
  } else {

  }
  return;
}
}
void choose_timer_9(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_9_0 == 1) {
    ldv_timer_9_0 = 2;
    ldv_timer_9(ldv_timer_9_0, ldv_timer_list_9_0);
  } else {

  }
  goto ldv_57313;
  case 1: ;
  if (ldv_timer_9_1 == 1) {
    ldv_timer_9_1 = 2;
    ldv_timer_9(ldv_timer_9_1, ldv_timer_list_9_1);
  } else {

  }
  goto ldv_57313;
  case 2: ;
  if (ldv_timer_9_2 == 1) {
    ldv_timer_9_2 = 2;
    ldv_timer_9(ldv_timer_9_2, ldv_timer_list_9_2);
  } else {

  }
  goto ldv_57313;
  case 3: ;
  if (ldv_timer_9_3 == 1) {
    ldv_timer_9_3 = 2;
    ldv_timer_9(ldv_timer_9_3, ldv_timer_list_9_3);
  } else {

  }
  goto ldv_57313;
  default: 
  ldv_stop();
  }
  ldv_57313: ;
  return;
}
}
void timer_init_10(void) 
{ 


  {
  ldv_timer_10_0 = 0;
  ldv_timer_10_1 = 0;
  ldv_timer_10_2 = 0;
  ldv_timer_10_3 = 0;
  return;
}
}
void ldv_timer_8(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  addba_timer_hdl(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void timer_init_8(void) 
{ 


  {
  ldv_timer_8_0 = 0;
  ldv_timer_8_1 = 0;
  ldv_timer_8_2 = 0;
  ldv_timer_8_3 = 0;
  return;
}
}
void activate_suitable_timer_8(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_8_0 == 0 || ldv_timer_8_0 == 2) {
    ldv_timer_list_8_0 = timer;
    ldv_timer_list_8_0->data = data;
    ldv_timer_8_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_8_1 == 0 || ldv_timer_8_1 == 2) {
    ldv_timer_list_8_1 = timer;
    ldv_timer_list_8_1->data = data;
    ldv_timer_8_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_8_2 == 0 || ldv_timer_8_2 == 2) {
    ldv_timer_list_8_2 = timer;
    ldv_timer_list_8_2->data = data;
    ldv_timer_8_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_8_3 == 0 || ldv_timer_8_3 == 2) {
    ldv_timer_list_8_3 = timer;
    ldv_timer_list_8_3->data = data;
    ldv_timer_8_3 = 1;
    return;
  } else {

  }
  return;
}
}
void choose_timer_10(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_10_0 == 1) {
    ldv_timer_10_0 = 2;
    ldv_timer_10(ldv_timer_10_0, ldv_timer_list_10_0);
  } else {

  }
  goto ldv_57336;
  case 1: ;
  if (ldv_timer_10_1 == 1) {
    ldv_timer_10_1 = 2;
    ldv_timer_10(ldv_timer_10_1, ldv_timer_list_10_1);
  } else {

  }
  goto ldv_57336;
  case 2: ;
  if (ldv_timer_10_2 == 1) {
    ldv_timer_10_2 = 2;
    ldv_timer_10(ldv_timer_10_2, ldv_timer_list_10_2);
  } else {

  }
  goto ldv_57336;
  case 3: ;
  if (ldv_timer_10_3 == 1) {
    ldv_timer_10_3 = 2;
    ldv_timer_10(ldv_timer_10_3, ldv_timer_list_10_3);
  } else {

  }
  goto ldv_57336;
  default: 
  ldv_stop();
  }
  ldv_57336: ;
  return;
}
}
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_98(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_100(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_101(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_102(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_103(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_104(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_105(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_106(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_107(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_108(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_109(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_110(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_111(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_112(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_113(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_114(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_115(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_116(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_117(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_118(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_119(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___21 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_120(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___22 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_121(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___23 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_122(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___24 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_158(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
bool ldv_queue_work_on_153(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_155(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_154(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_157(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_156(struct workqueue_struct *ldv_func_arg1 ) ;
int ldv_timer_11_0 ;
struct timer_list *ldv_timer_list_11_1 ;
int ldv_timer_11_2 ;
int ldv_timer_11_1 ;
struct timer_list *ldv_timer_list_11_2 ;
struct timer_list *ldv_timer_list_11_0 ;
int ldv_timer_11_3 ;
struct timer_list *ldv_timer_list_11_3 ;
void ldv_timer_11(int state , struct timer_list *timer ) ;
void choose_timer_11(void) ;
void timer_init_11(void) ;
void activate_suitable_timer_11(struct timer_list *timer , unsigned long data ) ;
__inline static void sema_init(struct semaphore *sem , int val ) 
{ 
  struct lock_class_key __key ;
  struct semaphore __constr_expr_0 ;

  {
  __constr_expr_0.lock.raw_lock.val.counter = 0;
  __constr_expr_0.lock.magic = 3735899821U;
  __constr_expr_0.lock.owner_cpu = 4294967295U;
  __constr_expr_0.lock.owner = (void *)-1;
  __constr_expr_0.lock.dep_map.key = 0;
  __constr_expr_0.lock.dep_map.class_cache[0] = 0;
  __constr_expr_0.lock.dep_map.class_cache[1] = 0;
  __constr_expr_0.lock.dep_map.name = "(*sem).lock";
  __constr_expr_0.lock.dep_map.cpu = 0;
  __constr_expr_0.lock.dep_map.ip = 0UL;
  __constr_expr_0.count = (unsigned int )val;
  __constr_expr_0.wait_list.next = & sem->wait_list;
  __constr_expr_0.wait_list.prev = & sem->wait_list;
  *sem = __constr_expr_0;
  lockdep_init_map(& sem->lock.dep_map, "semaphore->lock", & __key, 0);
  return;
}
}
extern void down(struct semaphore * ) ;
extern void up(struct semaphore * ) ;
void rtl8723a_set_rpwm(struct rtw_adapter *padapter , u8 val ) ;
bool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter ) ;
void rtw_init_pwrctrl_priv23a(struct rtw_adapter *padapter ) ;
void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter ) ;
void rtw_set_ps_mode23a(struct rtw_adapter *padapter , u8 ps_mode , u8 smart_ps ,
                        u8 bcn_ant_mode ) ;
void rtw_set_rpwm23a(struct rtw_adapter *padapter , u8 pslv ) ;
void LeaveAllPowerSaveMode23a(struct rtw_adapter *Adapter ) ;
void ips_enter23a(struct rtw_adapter *padapter ) ;
int ips_leave23a(struct rtw_adapter *padapter ) ;
s32 LPS_RF_ON_check23a(struct rtw_adapter *padapter , u32 delay_ms ) ;
int _rtw_pwr_wakeup23a(struct rtw_adapter *padapter , u32 ips_deffer_ms , char const   *caller ) ;
int rtw_pm_set_ips23a(struct rtw_adapter *padapter , u8 mode ) ;
int rtw_pm_set_lps23a(struct rtw_adapter *padapter , u8 mode ) ;
int rtw_ips_pwr_up23a(struct rtw_adapter *padapter ) ;
void rtw_ips_pwr_down23a(struct rtw_adapter *padapter ) ;
extern bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter * ) ;
void rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter , u8 Mode ) ;
void rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter ) ;
bool rtw_sreset_inprogress(struct rtw_adapter *padapter ) ;
void ips_enter23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  down(& pwrpriv->lock);
  pwrpriv->bips_processing = 1U;
  pwrpriv->ips_mode = pwrpriv->ips_mode_req;
  pwrpriv->ips_enter23a_cnts = pwrpriv->ips_enter23a_cnts + 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ==>ips_enter23a cnts:%d\n", pwrpriv->ips_enter23a_cnts);
  } else {

  }
  rtl8723a_BT_disable_coexist(padapter);
  if ((unsigned int )pwrpriv->change_rfpwrstate == 2U) {
    pwrpriv->bpower_saving = 1U;
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: nolinked power save enter\n");
    } else {

    }
    if ((unsigned int )pwrpriv->ips_mode == 2U) {
      pwrpriv->bkeepfwalive = 1U;
    } else {

    }
    rtw_ips_pwr_down23a(padapter);
    pwrpriv->rf_pwrstate = 2;
  } else {

  }
  pwrpriv->bips_processing = 0U;
  up(& pwrpriv->lock);
  return;
}
}
int ips_leave23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  int result ;
  int keyid ;
  u32 tmp ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmepriv = & padapter->mlmepriv;
  result = 1;
  down(& pwrpriv->lock);
  if ((unsigned int )pwrpriv->rf_pwrstate == 2U && pwrpriv->bips_processing == 0U) {
    pwrpriv->bips_processing = 1U;
    pwrpriv->change_rfpwrstate = 0;
    pwrpriv->ips_leave23a_cnts = pwrpriv->ips_leave23a_cnts + 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ==>ips_leave23a cnts:%d\n", pwrpriv->ips_leave23a_cnts);
    } else {

    }
    result = rtw_ips_pwr_up23a(padapter);
    if (result == 1) {
      pwrpriv->rf_pwrstate = 0;
    } else {

    }
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: nolinked power save leave\n");
    } else {

    }
    if (psecuritypriv->dot11PrivacyAlgrthm == 1027073U || psecuritypriv->dot11PrivacyAlgrthm == 1027077U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: ==>%s, channel(%d), processing(%x)\n", "ips_leave23a",
               (int )padapter->mlmeextpriv.cur_channel, pwrpriv->bips_processing);
      } else {

      }
      set_channel_bwmode23a(padapter, (int )padapter->mlmeextpriv.cur_channel, 0,
                            0);
      keyid = 0;
      goto ldv_55764;
      ldv_55763: ;
      if ((int )((unsigned long )pmlmepriv->key_mask >> keyid) & 1) {
        if ((u32 )keyid == psecuritypriv->dot11PrivacyKeyIndex) {
          result = rtw_set_key23a(padapter, psecuritypriv, keyid, 1);
        } else {
          result = rtw_set_key23a(padapter, psecuritypriv, keyid, 0);
        }
      } else {

      }
      keyid = keyid + 1;
      ldv_55764: ;
      if (keyid <= 3) {
        goto ldv_55763;
      } else {

      }

    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      tmp = rtl8723au_read32(padapter, 76);
      printk("\016RTL8723AU: ==> ips_leave23a.....LED(0x%08x)...\n", tmp);
    } else {

    }
    pwrpriv->bips_processing = 0U;
    pwrpriv->bkeepfwalive = 0U;
    pwrpriv->bpower_saving = 0U;
  } else {

  }
  up(& pwrpriv->lock);
  return (result);
}
}
static bool rtw_pwr_unassociated_idle(struct rtw_adapter *adapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmit_priv ;
  bool ret ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  pmlmepriv = & adapter->mlmepriv;
  pxmit_priv = & adapter->xmitpriv;
  ret = 0;
  if ((long )(adapter->pwrctrlpriv.ips_deny_time - (unsigned long )jiffies) >= 0L) {
    goto exit;
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 2049);
  if ((int )tmp) {
    goto exit;
  } else {
    tmp___0 = check_fwstate(pmlmepriv, 384);
    if ((int )tmp___0) {
      goto exit;
    } else {
      tmp___1 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___1) {
        goto exit;
      } else {
        tmp___2 = check_fwstate(pmlmepriv, 96);
        if ((int )tmp___2) {
          goto exit;
        } else {

        }
      }
    }
  }
  if (pxmit_priv->free_xmitbuf_cnt != 4U || pxmit_priv->free_xmit_extbuf_cnt != 32U) {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: There are some pkts to transmit\n");
    } else {

    }
    if (GlobalDebugLevel23A > 6U) {
      printk("\016RTL8723AU: free_xmitbuf_cnt: %d, free_xmit_extbuf_cnt: %d\n", pxmit_priv->free_xmitbuf_cnt,
             pxmit_priv->free_xmit_extbuf_cnt);
    } else {

    }
    goto exit;
  } else {

  }
  ret = 1;
  exit: ;
  return (ret);
}
}
void rtw_ps_processor23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  pmlmepriv = & padapter->mlmepriv;
  pwrpriv->ps_processing = 1U;
  if (pwrpriv->bips_processing == 1U) {
    goto exit;
  } else {

  }
  if ((unsigned int )pwrpriv->ips_mode_req == 0U) {
    goto exit;
  } else {

  }
  tmp = rtw_pwr_unassociated_idle(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    goto exit;
  } else {

  }
  if ((unsigned int )pwrpriv->rf_pwrstate == 0U && ((unsigned int )pwrpriv->pwr_state_check_cnts & 3U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      tmp___1 = get_fwstate(pmlmepriv);
      printk("\016RTL8723AU: ==>%s .fw_state(%x)\n", "rtw_ps_processor23a", tmp___1);
    } else {

    }
    pwrpriv->change_rfpwrstate = 2;
    ips_enter23a(padapter);
  } else {

  }
  exit: 
  tmp___2 = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
  ldv_mod_timer_158(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp___2 + (unsigned long )jiffies);
  pwrpriv->ps_processing = 0U;
  return;
}
}
static void pwr_state_check_handler(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;

  {
  padapter = (struct rtw_adapter *)data;
  rtw_ps_cmd23a(padapter);
  return;
}
}
void rtw_set_rpwm23a(struct rtw_adapter *padapter , u8 pslv ) 
{ 
  u8 rpwm ;
  struct pwrctrl_priv *pwrpriv ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  pslv = (unsigned int )pslv & 15U;
  if ((unsigned int )pwrpriv->btcoex_rfon != 0U) {
    if ((unsigned int )pslv <= 11U) {
      pslv = 4U;
    } else {

    }
  } else {

  }
  if ((int )((unsigned char )pwrpriv->rpwm) == (int )pslv) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(524288, 4, "%s: Already set rpwm[0x%02X], new = 0x%02X!\n", "rtw_set_rpwm23a",
               (int )pwrpriv->rpwm, (int )pslv);
    } else {

    }
    return;
  } else {

  }
  if (padapter->bSurpriseRemoved == 1 || (unsigned int )padapter->hw_init_completed == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(524288, 4, "%s: SurpriseRemoved(%d) hw_init_completed(%d)\n", "rtw_set_rpwm23a",
               padapter->bSurpriseRemoved, (int )padapter->hw_init_completed);
    } else {

    }
    pwrpriv->cpwm = 12U;
    return;
  } else {

  }
  if (padapter->bDriverStopped == 1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(524288, 4, "%s: change power state(0x%02X) when DriverStopped\n", "rtw_set_rpwm23a",
               (int )pslv);
    } else {

    }
    if ((unsigned int )pslv <= 1U) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(524288, 4, "%s: Reject to enter PS_STATE(0x%02X) lower than S2 when DriverStopped!!\n",
                 "rtw_set_rpwm23a", (int )pslv);
      } else {

      }
      return;
    } else {

    }
  } else {

  }
  rpwm = (u8 )((int )((unsigned char )pwrpriv->tog) | (int )pslv);
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(524288, 6, "rtw_set_rpwm23a: rpwm = 0x%02x cpwm = 0x%02x\n", (int )rpwm,
             (int )pwrpriv->cpwm);
  } else {

  }
  pwrpriv->rpwm = pslv;
  rtl8723a_set_rpwm(padapter, (int )rpwm);
  pwrpriv->tog = (unsigned int )pwrpriv->tog + 128U;
  pwrpriv->cpwm = pslv;
  return;
}
}
static bool PS_RDY_CHECK(struct rtw_adapter *padapter ) 
{ 
  unsigned long delta_time ;
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  pmlmepriv = & padapter->mlmepriv;
  delta_time = (unsigned long )jiffies - pwrpriv->DelayLPSLastTimeStamp;
  if (delta_time <= 249UL) {
    return (0);
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {
    tmp___1 = check_fwstate(pmlmepriv, 2048);
    if ((int )tmp___1) {
      return (0);
    } else {
      tmp___2 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___2) {
        return (0);
      } else {
        tmp___3 = check_fwstate(pmlmepriv, 64);
        if ((int )tmp___3) {
          return (0);
        } else {
          tmp___4 = check_fwstate(pmlmepriv, 32);
          if ((int )tmp___4) {
            return (0);
          } else {

          }
        }
      }
    }
  }
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
    return (0);
  } else {

  }
  if (padapter->securitypriv.dot11AuthAlgrthm == 2U && (unsigned int )*((unsigned char *)padapter + 10948UL) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Group handshake still in progress !!!\n");
    } else {

    }
    return (0);
  } else {

  }
  tmp___5 = rtw_cfg80211_pwr_mgmt(padapter);
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    return (0);
  } else {

  }
  return (1);
}
}
void rtw_set_ps_mode23a(struct rtw_adapter *padapter , u8 ps_mode , u8 smart_ps ,
                        u8 bcn_ant_mode ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  bool tmp ;
  bool tmp___0 ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(524288, 6, "%s: PowerMode =%d Smart_PS =%d\n", "rtw_set_ps_mode23a",
             (int )ps_mode, (int )smart_ps);
  } else {

  }
  if ((unsigned int )ps_mode > 10U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(524288, 4, "ps_mode:%d error\n", (int )ps_mode);
    } else {

    }
    return;
  } else {

  }
  if ((int )pwrpriv->pwr_mode == (int )ps_mode) {
    if ((unsigned int )ps_mode == 0U) {
      return;
    } else {

    }
    if ((int )pwrpriv->smart_ps == (int )smart_ps && (int )pwrpriv->bcn_ant_mode == (int )bcn_ant_mode) {
      return;
    } else {

    }
  } else {

  }
  if ((unsigned int )ps_mode == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_set_ps_mode23a: Leave 802.11 power save\n");
    } else {

    }
    pwrpriv->pwr_mode = ps_mode;
    rtw_set_rpwm23a(padapter, 12);
    rtl8723a_set_FwPwrMode_cmd(padapter, (int )ps_mode);
    pwrpriv->bFwCurrentInPSMode = 0U;
  } else {
    tmp = PS_RDY_CHECK(padapter);
    if ((int )tmp) {
      goto _L;
    } else {
      tmp___0 = rtl8723a_BT_using_antenna_1(padapter);
      if ((int )tmp___0) {
        _L: /* CIL Label */ 
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s: Enter 802.11 power save\n", "rtw_set_ps_mode23a");
        } else {

        }
        pwrpriv->bFwCurrentInPSMode = 1U;
        pwrpriv->pwr_mode = ps_mode;
        pwrpriv->smart_ps = smart_ps;
        pwrpriv->bcn_ant_mode = bcn_ant_mode;
        rtl8723a_set_FwPwrMode_cmd(padapter, (int )ps_mode);
        rtw_set_rpwm23a(padapter, 2);
      } else {

      }
    }
  }
  return;
}
}
s32 LPS_RF_ON_check23a(struct rtw_adapter *padapter , u32 delay_ms ) 
{ 
  unsigned long start_time ;
  unsigned long end_time ;
  u8 bAwake ;
  s32 err ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
  bAwake = 0U;
  err = 0;
  start_time = jiffies;
  tmp = msecs_to_jiffies(delay_ms);
  end_time = tmp + start_time;
  ldv_55827: 
  tmp___0 = rtl8723a_get_fwlps_rf_on(padapter);
  bAwake = (u8 )tmp___0;
  if ((unsigned int )bAwake == 1U) {
    goto ldv_55819;
  } else {

  }
  if (padapter->bSurpriseRemoved == 1) {
    err = -2;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: device surprise removed!!\n", "LPS_RF_ON_check23a");
    } else {

    }
    goto ldv_55819;
  } else {

  }
  if ((long )(end_time - (unsigned long )jiffies) < 0L) {
    err = -1;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: Wait for FW LPS leave more than %u ms!\n", "LPS_RF_ON_check23a",
             delay_ms);
    } else {

    }
    goto ldv_55819;
  } else {

  }
  __const_udelay(429500UL);
  goto ldv_55827;
  ldv_55819: ;
  return (err);
}
}
void LPS_Enter23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  bool tmp ;
  int tmp___0 ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  tmp = PS_RDY_CHECK(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  if ((unsigned int )pwrpriv->bLeisurePs != 0U) {
    if ((unsigned int )pwrpriv->LpsIdleCount > 1U) {
      if ((unsigned int )pwrpriv->pwr_mode == 0U) {
        pwrpriv->bpower_saving = 1U;
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s smart_ps:%d\n", "LPS_Enter23a", (int )pwrpriv->smart_ps);
        } else {

        }
        rtw_set_ps_mode23a(padapter, (int )pwrpriv->power_mgnt, (int )pwrpriv->smart_ps,
                           0);
      } else {

      }
    } else {
      pwrpriv->LpsIdleCount = (u8 )((int )pwrpriv->LpsIdleCount + 1);
    }
  } else {

  }
  return;
}
}
void LPS_Leave23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  if ((unsigned int )pwrpriv->bLeisurePs != 0U) {
    if ((unsigned int )pwrpriv->pwr_mode != 0U) {
      rtw_set_ps_mode23a(padapter, 0, 0, 0);
      if ((unsigned int )pwrpriv->pwr_mode == 0U) {
        LPS_RF_ON_check23a(padapter, 100U);
      } else {

      }
    } else {

    }
  } else {

  }
  pwrpriv->bpower_saving = 0U;
  return;
}
}
void LeaveAllPowerSaveMode23a(struct rtw_adapter *Adapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  u8 enqueue ;
  bool tmp ;

  {
  pmlmepriv = & Adapter->mlmepriv;
  enqueue = 0U;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    rtw_lps_ctrl_wk_cmd23a(Adapter, 5, (int )enqueue);
  } else {

  }
  return;
}
}
void rtw_init_pwrctrl_priv23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrctrlpriv ;

  {
  pwrctrlpriv = & padapter->pwrctrlpriv;
  sema_init(& pwrctrlpriv->lock, 1);
  pwrctrlpriv->rf_pwrstate = 0;
  pwrctrlpriv->ips_enter23a_cnts = 0U;
  pwrctrlpriv->ips_leave23a_cnts = 0U;
  pwrctrlpriv->bips_processing = 0U;
  pwrctrlpriv->ips_mode = padapter->registrypriv.ips_mode;
  pwrctrlpriv->ips_mode_req = padapter->registrypriv.ips_mode;
  pwrctrlpriv->pwr_state_check_interval = 2000;
  pwrctrlpriv->pwr_state_check_cnts = 0U;
  pwrctrlpriv->bInSuspend = 0U;
  pwrctrlpriv->bkeepfwalive = 0U;
  pwrctrlpriv->LpsIdleCount = 0U;
  pwrctrlpriv->power_mgnt = padapter->registrypriv.power_mgnt;
  pwrctrlpriv->bLeisurePs = (unsigned int )pwrctrlpriv->power_mgnt != 0U;
  pwrctrlpriv->bFwCurrentInPSMode = 0U;
  pwrctrlpriv->rpwm = 0U;
  pwrctrlpriv->cpwm = 12U;
  pwrctrlpriv->pwr_mode = 0U;
  pwrctrlpriv->smart_ps = padapter->registrypriv.smart_ps;
  pwrctrlpriv->bcn_ant_mode = 0U;
  pwrctrlpriv->tog = 128U;
  pwrctrlpriv->btcoex_rfon = 0U;
  reg_timer_11(& pwrctrlpriv->pwr_state_check_timer, & pwr_state_check_handler, (unsigned long )padapter);
  return;
}
}
void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter ) 
{ 


  {
  return;
}
}
int _rtw_pwr_wakeup23a(struct rtw_adapter *padapter , u32 ips_deffer_ms , char const   *caller ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  int ret ;
  unsigned long start ;
  unsigned long new_deny_time ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  bool tmp___1 ;
  unsigned int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  unsigned int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  pmlmepriv = & padapter->mlmepriv;
  ret = 1;
  start = jiffies;
  tmp = msecs_to_jiffies(ips_deffer_ms);
  new_deny_time = tmp + (unsigned long )jiffies;
  if ((long )(pwrpriv->ips_deny_time - new_deny_time) < 0L) {
    pwrpriv->ips_deny_time = new_deny_time;
  } else {

  }
  if ((unsigned int )pwrpriv->ps_processing != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait ps_processing...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
    goto ldv_55872;
    ldv_55871: 
    msleep(10U);
    ldv_55872: ;
    if ((unsigned int )pwrpriv->ps_processing != 0U) {
      tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
      if (tmp___0 <= 3000U) {
        goto ldv_55871;
      } else {
        goto ldv_55873;
      }
    } else {

    }
    ldv_55873: ;
    if ((unsigned int )pwrpriv->ps_processing != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s wait ps_processing timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait ps_processing done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
  tmp___4 = rtw_sreset_inprogress(padapter);
  if ((int )tmp___4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait sreset_inprogress...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
    goto ldv_55875;
    ldv_55874: 
    msleep(10U);
    ldv_55875: 
    tmp___1 = rtw_sreset_inprogress(padapter);
    if ((int )tmp___1) {
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
      if (tmp___2 <= 4000U) {
        goto ldv_55874;
      } else {
        goto ldv_55876;
      }
    } else {

    }
    ldv_55876: 
    tmp___3 = rtw_sreset_inprogress(padapter);
    if ((int )tmp___3) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s wait sreset_inprogress timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait sreset_inprogress done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait bInSuspend...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
    goto ldv_55878;
    ldv_55877: 
    msleep(10U);
    ldv_55878: ;
    if ((unsigned int )pwrpriv->bInSuspend != 0U) {
      tmp___5 = jiffies_to_msecs((unsigned long )jiffies - start);
      if (tmp___5 <= 3000U) {
        goto ldv_55877;
      } else {
        goto ldv_55879;
      }
    } else {

    }
    ldv_55879: ;
    if ((unsigned int )pwrpriv->bInSuspend != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s wait bInSuspend timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait bInSuspend done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
    ret = 0;
    goto exit;
  } else {

  }
  tmp___6 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___6) {
    ret = 1;
    goto exit;
  } else {

  }
  if ((unsigned int )pwrpriv->rf_pwrstate == 2U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s call ips_leave23a....\n", "_rtw_pwr_wakeup23a");
    } else {

    }
    tmp___7 = ips_leave23a(padapter);
    if (tmp___7 == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: ======> ips_leave23a fail.............\n");
      } else {

      }
      ret = 0;
      goto exit;
    } else {

    }
  } else {

  }
  if ((padapter->bDriverStopped != 0 || padapter->bup == 0) || (unsigned int )padapter->hw_init_completed == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: bDriverStopped =%d, bup =%d, hw_init_completed =%u\n",
             caller, padapter->bDriverStopped, padapter->bup, (int )padapter->hw_init_completed);
    } else {

    }
    ret = 0;
    goto exit;
  } else {

  }
  exit: 
  tmp___8 = msecs_to_jiffies(ips_deffer_ms);
  new_deny_time = tmp___8 + (unsigned long )jiffies;
  if ((long )(pwrpriv->ips_deny_time - new_deny_time) < 0L) {
    pwrpriv->ips_deny_time = new_deny_time;
  } else {

  }
  return (ret);
}
}
int rtw_pm_set_lps23a(struct rtw_adapter *padapter , u8 mode ) 
{ 
  int ret ;
  struct pwrctrl_priv *pwrctrlpriv ;

  {
  ret = 0;
  pwrctrlpriv = & padapter->pwrctrlpriv;
  if ((unsigned int )mode <= 10U) {
    if ((int )pwrctrlpriv->power_mgnt != (int )mode) {
      if ((unsigned int )mode == 0U) {
        LeaveAllPowerSaveMode23a(padapter);
      } else {
        pwrctrlpriv->LpsIdleCount = 2U;
      }
      pwrctrlpriv->power_mgnt = mode;
      pwrctrlpriv->bLeisurePs = (unsigned int )pwrctrlpriv->power_mgnt != 0U;
    } else {

    }
  } else {
    ret = -22;
  }
  return (ret);
}
}
int rtw_pm_set_ips23a(struct rtw_adapter *padapter , u8 mode ) 
{ 
  struct pwrctrl_priv *pwrctrlpriv ;
  int tmp ;

  {
  pwrctrlpriv = & padapter->pwrctrlpriv;
  if (((unsigned int )mode != 1U && (unsigned int )mode != 2U) && (unsigned int )mode != 0U) {
    return (-22);
  } else {

  }
  pwrctrlpriv->ips_mode_req = mode;
  if ((unsigned int )mode == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s %s\n", "rtw_pm_set_ips23a", (char *)"IPS_NONE");
    } else {

    }
    if (padapter->bSurpriseRemoved == 0) {
      tmp = _rtw_pwr_wakeup23a(padapter, 2000U, "rtw_pm_set_ips23a");
      if (tmp == 0) {
        return (-14);
      } else {

      }
    } else {

    }
  } else {

  }
  return (0);
}
}
void disable_suitable_timer_11(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_11_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_0) {
    ldv_timer_11_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_11_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_1) {
    ldv_timer_11_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_11_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_2) {
    ldv_timer_11_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_11_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_3) {
    ldv_timer_11_3 = 0;
    return;
  } else {

  }
  return;
}
}
void ldv_timer_11(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  pwr_state_check_handler(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void choose_timer_11(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_11_0 == 1) {
    ldv_timer_11_0 = 2;
    ldv_timer_11(ldv_timer_11_0, ldv_timer_list_11_0);
  } else {

  }
  goto ldv_55910;
  case 1: ;
  if (ldv_timer_11_1 == 1) {
    ldv_timer_11_1 = 2;
    ldv_timer_11(ldv_timer_11_1, ldv_timer_list_11_1);
  } else {

  }
  goto ldv_55910;
  case 2: ;
  if (ldv_timer_11_2 == 1) {
    ldv_timer_11_2 = 2;
    ldv_timer_11(ldv_timer_11_2, ldv_timer_list_11_2);
  } else {

  }
  goto ldv_55910;
  case 3: ;
  if (ldv_timer_11_3 == 1) {
    ldv_timer_11_3 = 2;
    ldv_timer_11(ldv_timer_11_3, ldv_timer_list_11_3);
  } else {

  }
  goto ldv_55910;
  default: 
  ldv_stop();
  }
  ldv_55910: ;
  return;
}
}
void timer_init_11(void) 
{ 


  {
  ldv_timer_11_0 = 0;
  ldv_timer_11_1 = 0;
  ldv_timer_11_2 = 0;
  ldv_timer_11_3 = 0;
  return;
}
}
int reg_timer_11(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& pwr_state_check_handler)) {
    activate_suitable_timer_11(timer, data);
  } else {

  }
  return (0);
}
}
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_11_0 == (unsigned long )timer) {
    if (ldv_timer_11_0 == 2 || pending_flag != 0) {
      ldv_timer_list_11_0 = timer;
      ldv_timer_list_11_0->data = data;
      ldv_timer_11_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_11_1 == (unsigned long )timer) {
    if (ldv_timer_11_1 == 2 || pending_flag != 0) {
      ldv_timer_list_11_1 = timer;
      ldv_timer_list_11_1->data = data;
      ldv_timer_11_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_11_2 == (unsigned long )timer) {
    if (ldv_timer_11_2 == 2 || pending_flag != 0) {
      ldv_timer_list_11_2 = timer;
      ldv_timer_list_11_2->data = data;
      ldv_timer_11_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_11_3 == (unsigned long )timer) {
    if (ldv_timer_11_3 == 2 || pending_flag != 0) {
      ldv_timer_list_11_3 = timer;
      ldv_timer_list_11_3->data = data;
      ldv_timer_11_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_11(timer, data);
  return;
}
}
void activate_suitable_timer_11(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_11_0 == 0 || ldv_timer_11_0 == 2) {
    ldv_timer_list_11_0 = timer;
    ldv_timer_list_11_0->data = data;
    ldv_timer_11_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_11_1 == 0 || ldv_timer_11_1 == 2) {
    ldv_timer_list_11_1 = timer;
    ldv_timer_list_11_1->data = data;
    ldv_timer_11_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_11_2 == 0 || ldv_timer_11_2 == 2) {
    ldv_timer_list_11_2 = timer;
    ldv_timer_list_11_2->data = data;
    ldv_timer_11_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_11_3 == 0 || ldv_timer_11_3 == 2) {
    ldv_timer_list_11_3 = timer;
    ldv_timer_list_11_3->data = data;
    ldv_timer_11_3 = 1;
    return;
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_153(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_154(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_155(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_156(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_157(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_158(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
  __list_add(new, head, head->next);
  return;
}
}
extern void warn_slowpath_null(char const   * , int const    ) ;
extern void _raw_spin_lock(raw_spinlock_t * ) ;
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  _raw_spin_lock(& lock->__annonCompField18.rlock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
  return;
}
}
int ldv_mod_timer_174(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_175(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_177(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_178(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_176(struct timer_list *ldv_func_arg1 ) ;
bool ldv_queue_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_171(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_170(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_173(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_172(struct workqueue_struct *ldv_func_arg1 ) ;
struct timer_list *ldv_timer_list_12_1 ;
int ldv_timer_12_3 ;
struct timer_list *ldv_timer_list_12_0 ;
int ldv_timer_12_0 ;
int ldv_timer_12_2 ;
struct timer_list *ldv_timer_list_12_3 ;
int ldv_timer_12_1 ;
struct timer_list *ldv_timer_list_12_2 ;
void timer_init_12(void) ;
int reg_timer_12(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void activate_pending_timer_12(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void ldv_timer_12(int state , struct timer_list *timer ) ;
void activate_suitable_timer_12(struct timer_list *timer , unsigned long data ) ;
void choose_timer_12(void) ;
void disable_suitable_timer_12(struct timer_list *timer ) ;
__inline static int skb_queue_empty(struct sk_buff_head  const  *list ) 
{ 


  {
  return ((unsigned long )((struct sk_buff  const  *)list->next) == (unsigned long )((struct sk_buff  const  *)list));
}
}
__inline static struct sk_buff *skb_peek(struct sk_buff_head  const  *list_ ) 
{ 
  struct sk_buff *skb ;

  {
  skb = list_->next;
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)list_)) {
    skb = (struct sk_buff *)0;
  } else {

  }
  return (skb);
}
}
__inline static void __skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
  tmp = (struct sk_buff *)list;
  list->next = tmp;
  list->prev = tmp;
  list->qlen = 0U;
  return;
}
}
__inline static void __skb_unlink(struct sk_buff *skb , struct sk_buff_head *list ) 
{ 
  struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *tmp ;

  {
  list->qlen = list->qlen - 1U;
  next = skb->__annonCompField79.__annonCompField78.next;
  prev = skb->__annonCompField79.__annonCompField78.prev;
  tmp = (struct sk_buff *)0;
  skb->__annonCompField79.__annonCompField78.prev = tmp;
  skb->__annonCompField79.__annonCompField78.next = tmp;
  next->__annonCompField79.__annonCompField78.prev = prev;
  prev->__annonCompField79.__annonCompField78.next = next;
  return;
}
}
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  tmp = skb_peek((struct sk_buff_head  const  *)list);
  skb = tmp;
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
    __skb_unlink(skb, list);
  } else {

  }
  return (skb);
}
}
__inline static unsigned char *skb_tail_pointer(struct sk_buff  const  *skb ) 
{ 


  {
  return ((unsigned char *)skb->head + (unsigned long )skb->tail);
}
}
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
extern unsigned char *skb_pull(struct sk_buff * , unsigned int  ) ;
extern void skb_trim(struct sk_buff * , unsigned int  ) ;
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
  __dev_kfree_skb_any(skb, 1);
  return;
}
}
extern int netif_rx(struct sk_buff * ) ;
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
__inline static int ieee80211_has_tods(__le16 fc ) 
{ 


  {
  return (((int )fc & 256) != 0);
}
}
__inline static int ieee80211_has_fromds(__le16 fc ) 
{ 


  {
  return (((int )fc & 512) != 0);
}
}
__inline static int ieee80211_has_a4(__le16 fc ) 
{ 
  __le16 tmp ;

  {
  tmp = 768U;
  return (((int )fc & (int )tmp) == (int )tmp);
}
}
__inline static int ieee80211_has_morefrags(__le16 fc ) 
{ 


  {
  return (((int )fc & 1024) != 0);
}
}
__inline static int ieee80211_has_pm(__le16 fc ) 
{ 


  {
  return (((int )fc & 4096) != 0);
}
}
__inline static int ieee80211_has_moredata(__le16 fc ) 
{ 


  {
  return (((int )fc & 8192) != 0);
}
}
__inline static int ieee80211_has_protected(__le16 fc ) 
{ 


  {
  return (((int )fc & 16384) != 0);
}
}
__inline static int ieee80211_has_order(__le16 fc ) 
{ 


  {
  return ((int )((short )fc) < 0);
}
}
__inline static int ieee80211_is_ctl(__le16 fc ) 
{ 


  {
  return (((int )fc & 12) == 4);
}
}
__inline static int ieee80211_is_data(__le16 fc ) 
{ 


  {
  return (((int )fc & 12) == 8);
}
}
__inline static int ieee80211_is_data_qos(__le16 fc ) 
{ 


  {
  return (((int )fc & 140) == 136);
}
}
__inline static int ieee80211_is_pspoll(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 164);
}
}
__inline static int ieee80211_is_nullfunc(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 72);
}
}
__inline static u8 *ieee80211_get_qos_ctl(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;

  {
  tmp = ieee80211_has_a4((int )hdr->frame_control);
  if (tmp != 0) {
    return ((u8 *)hdr + 30UL);
  } else {
    return ((u8 *)hdr + 24UL);
  }
}
}
__inline static u8 *ieee80211_get_SA(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = ieee80211_has_a4((int )hdr->frame_control);
  if (tmp != 0) {
    return ((u8 *)(& hdr->addr4));
  } else {

  }
  tmp___0 = ieee80211_has_fromds((int )hdr->frame_control);
  if (tmp___0 != 0) {
    return ((u8 *)(& hdr->addr3));
  } else {

  }
  return ((u8 *)(& hdr->addr2));
}
}
__inline static u8 *ieee80211_get_DA(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;

  {
  tmp = ieee80211_has_tods((int )hdr->frame_control);
  if (tmp != 0) {
    return ((u8 *)(& hdr->addr3));
  } else {
    return ((u8 *)(& hdr->addr1));
  }
}
}
extern unsigned char const   rfc1042_header[6U] ;
extern unsigned char const   bridge_tunnel_header[6U] ;
extern void ieee80211_amsdu_to_8023s(struct sk_buff * , struct sk_buff_head * , u8 const   * ,
                                     enum nl80211_iftype  , unsigned int const    ,
                                     bool  ) ;
__inline static u32 CHKBIT(u32 x ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = x > 31U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("drivers/staging/rtl8723au/include/osdep_service.h", 70);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (x > 31U) {
    return (0U);
  } else {

  }
  return ((u32 )(1UL << (int )x));
}
}
void stop_sta_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void wakeup_sta_to_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
struct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue ) ;
int rtw_free_recvframe23a(struct recv_frame *precvframe ) ;
int rtw_enqueue_recvframe23a(struct recv_frame *precvframe , struct rtw_queue *queue ) ;
int rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf , struct rtw_queue *queue ) ;
int rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf , struct rtw_queue *queue ) ;
struct recv_buf *rtw_dequeue_recvbuf23a(struct rtw_queue *queue ) ;
void rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext ) ;
void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv ) ;
void rtw_seccalctkipmic23a(u8 *key , u8 *header , u8 *data , u32 data_len , u8 *mic_code ,
                           u8 pri ) ;
int rtw_aes_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
int rtw_tkip_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
void rtw_wep_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv ) 
{ 


  {
  return ((u8 *)(& pmlmepriv->cur_network.network.MacAddress));
}
}
int _rtw_init_recv_priv23a(struct recv_priv *precvpriv , struct rtw_adapter *padapter ) ;
void _rtw_free_recv_priv23a(struct recv_priv *precvpriv ) ;
int rtw_recv_entry23a(struct recv_frame *rframe ) ;
int rtw_recv_indicatepkt23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter , u8 bgroup ) ;
int rtl8723au_init_recv_priv(struct rtw_adapter *padapter ) ;
void rtl8723au_free_recv_priv(struct rtw_adapter *padapter ) ;
void rtw_signal_stat_timer_hdl23a(unsigned long data ) ;
void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv ) 
{ 
  struct lock_class_key __key ;

  {
  spinlock_check(& psta_recvpriv->lock);
  __raw_spin_lock_init(& psta_recvpriv->lock.__annonCompField18.rlock, "&(&psta_recvpriv->lock)->rlock",
                       & __key);
  _rtw_init_queue23a(& psta_recvpriv->defrag_q);
  return;
}
}
int _rtw_init_recv_priv23a(struct recv_priv *precvpriv , struct rtw_adapter *padapter ) 
{ 
  struct recv_frame *precvframe ;
  int i ;
  int res ;
  struct lock_class_key __key ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
  res = 1;
  spinlock_check(& precvpriv->lock);
  __raw_spin_lock_init(& precvpriv->lock.__annonCompField18.rlock, "&(&precvpriv->lock)->rlock",
                       & __key);
  _rtw_init_queue23a(& precvpriv->free_recv_queue);
  _rtw_init_queue23a(& precvpriv->recv_pending_queue);
  _rtw_init_queue23a(& precvpriv->uc_swdec_pending_queue);
  precvpriv->adapter = padapter;
  i = 0;
  goto ldv_53464;
  ldv_53463: 
  tmp = kzalloc(144UL, 208U);
  precvframe = (struct recv_frame *)tmp;
  if ((unsigned long )precvframe == (unsigned long )((struct recv_frame *)0)) {
    goto ldv_53462;
  } else {

  }
  INIT_LIST_HEAD(& precvframe->list);
  list_add_tail(& precvframe->list, & precvpriv->free_recv_queue.queue);
  precvframe->adapter = padapter;
  precvframe = precvframe + 1;
  i = i + 1;
  ldv_53464: ;
  if (i <= 255) {
    goto ldv_53463;
  } else {

  }
  ldv_53462: 
  precvpriv->free_recvframe_cnt = i;
  precvpriv->rx_pending_cnt = 1U;
  res = rtl8723au_init_recv_priv(padapter);
  reg_timer_11(& precvpriv->signal_stat_timer, & rtw_signal_stat_timer_hdl23a, (unsigned long )padapter);
  precvpriv->signal_stat_sampling_interval = 1000U;
  tmp___0 = msecs_to_jiffies(precvpriv->signal_stat_sampling_interval);
  ldv_mod_timer_174(& precvpriv->signal_stat_timer, tmp___0 + (unsigned long )jiffies);
  return (res);
}
}
void _rtw_free_recv_priv23a(struct recv_priv *precvpriv ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_frame *precvframe ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;

  {
  padapter = precvpriv->adapter;
  rtw_free_uc_swdec_pending_queue23a(padapter);
  plist = precvpriv->free_recv_queue.queue.next;
  ptmp = plist->next;
  goto ldv_53475;
  ldv_53474: 
  __mptr = (struct list_head  const  *)plist;
  precvframe = (struct recv_frame *)__mptr;
  list_del_init(& precvframe->list);
  kfree((void const   *)precvframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_53475: ;
  if ((unsigned long )(& precvpriv->free_recv_queue.queue) != (unsigned long )plist) {
    goto ldv_53474;
  } else {

  }
  rtl8723au_free_recv_priv(padapter);
  return;
}
}
struct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue ) 
{ 
  struct recv_frame *pframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  spin_lock_bh(& pfree_recv_queue->lock);
  tmp = list_empty((struct list_head  const  *)(& pfree_recv_queue->queue));
  if (tmp != 0) {
    pframe = (struct recv_frame *)0;
  } else {
    phead = get_list_head(pfree_recv_queue);
    plist = phead->next;
    __mptr = (struct list_head  const  *)plist;
    pframe = (struct recv_frame *)__mptr;
    list_del_init(& pframe->list);
    padapter = pframe->adapter;
    if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
      precvpriv = & padapter->recvpriv;
      if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )pfree_recv_queue) {
        precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt - 1;
      } else {

      }
    } else {

    }
  }
  spin_unlock_bh(& pfree_recv_queue->lock);
  return (pframe);
}
}
int rtw_free_recvframe23a(struct recv_frame *precvframe ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *pfree_recv_queue ;
  struct list_head *tmp ;

  {
  padapter = precvframe->adapter;
  precvpriv = & padapter->recvpriv;
  if ((unsigned long )precvframe->pkt != (unsigned long )((struct sk_buff *)0)) {
    dev_kfree_skb_any(precvframe->pkt);
    precvframe->pkt = (struct sk_buff *)0;
  } else {

  }
  pfree_recv_queue = & precvpriv->free_recv_queue;
  spin_lock_bh(& pfree_recv_queue->lock);
  list_del_init(& precvframe->list);
  tmp = get_list_head(pfree_recv_queue);
  list_add_tail(& precvframe->list, tmp);
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
    if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )pfree_recv_queue) {
      precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt + 1;
    } else {

    }
  } else {

  }
  spin_unlock_bh(& pfree_recv_queue->lock);
  return (1);
}
}
int rtw_enqueue_recvframe23a(struct recv_frame *precvframe , struct rtw_queue *queue ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct list_head *tmp ;

  {
  padapter = precvframe->adapter;
  precvpriv = & padapter->recvpriv;
  spin_lock_bh(& queue->lock);
  list_del_init(& precvframe->list);
  tmp = get_list_head(queue);
  list_add_tail(& precvframe->list, tmp);
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
    if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )queue) {
      precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt + 1;
    } else {

    }
  } else {

  }
  spin_unlock_bh(& queue->lock);
  return (1);
}
}
static void rtw_free_recvframe23a_queue(struct rtw_queue *pframequeue ) 
{ 
  struct recv_frame *hdr ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;

  {
  spin_lock(& pframequeue->lock);
  phead = get_list_head(pframequeue);
  plist = phead->next;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53509;
  ldv_53508: 
  __mptr = (struct list_head  const  *)plist;
  hdr = (struct recv_frame *)__mptr;
  rtw_free_recvframe23a(hdr);
  plist = ptmp;
  ptmp = plist->next;
  ldv_53509: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53508;
  } else {

  }
  spin_unlock(& pframequeue->lock);
  return;
}
}
u32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter ) 
{ 
  u32 cnt ;
  struct recv_frame *pending_frame ;

  {
  cnt = 0U;
  goto ldv_53518;
  ldv_53517: 
  rtw_free_recvframe23a(pending_frame);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: dequeue uc_swdec_pending_queue\n", "rtw_free_uc_swdec_pending_queue23a");
  } else {

  }
  cnt = cnt + 1U;
  ldv_53518: 
  pending_frame = rtw_alloc_recvframe23a(& adapter->recvpriv.uc_swdec_pending_queue);
  if ((unsigned long )pending_frame != (unsigned long )((struct recv_frame *)0)) {
    goto ldv_53517;
  } else {

  }

  return (cnt);
}
}
int rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf , struct rtw_queue *queue ) 
{ 
  struct list_head *tmp ;

  {
  spin_lock_bh(& queue->lock);
  list_del_init(& precvbuf->list);
  tmp = get_list_head(queue);
  list_add(& precvbuf->list, tmp);
  spin_unlock_bh(& queue->lock);
  return (1);
}
}
int rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf , struct rtw_queue *queue ) 
{ 
  unsigned long irqL ;
  raw_spinlock_t *tmp ;
  struct list_head *tmp___0 ;

  {
  tmp = spinlock_check(& queue->lock);
  irqL = _raw_spin_lock_irqsave(tmp);
  list_del_init(& precvbuf->list);
  tmp___0 = get_list_head(queue);
  list_add_tail(& precvbuf->list, tmp___0);
  spin_unlock_irqrestore(& queue->lock, irqL);
  return (1);
}
}
struct recv_buf *rtw_dequeue_recvbuf23a(struct rtw_queue *queue ) 
{ 
  unsigned long irqL ;
  struct recv_buf *precvbuf ;
  struct list_head *plist ;
  struct list_head *phead ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
  tmp = spinlock_check(& queue->lock);
  irqL = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& queue->queue));
  if (tmp___0 != 0) {
    precvbuf = (struct recv_buf *)0;
  } else {
    phead = get_list_head(queue);
    plist = phead->next;
    __mptr = (struct list_head  const  *)plist;
    precvbuf = (struct recv_buf *)__mptr;
    list_del_init(& precvbuf->list);
  }
  spin_unlock_irqrestore(& queue->lock, irqL);
  return (precvbuf);
}
}
int recvframe_chkmic(struct rtw_adapter *adapter , struct recv_frame *precvframe ) ;
int recvframe_chkmic(struct rtw_adapter *adapter , struct recv_frame *precvframe ) 
{ 
  int i ;
  int res ;
  u32 datalen ;
  u8 miccode[8U] ;
  u8 bmic_err ;
  u8 brpt_micerror ;
  u8 *pframe ;
  u8 *payload ;
  u8 *pframemic ;
  u8 *mickey ;
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  int i___0 ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  res = 1;
  bmic_err = 0U;
  brpt_micerror = 1U;
  prxattrib = & precvframe->attrib;
  psecuritypriv = & adapter->securitypriv;
  pmlmeext = & adapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  stainfo = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& prxattrib->ta));
  if (prxattrib->encrypt == 1027074U) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(4, 7, "recvframe_chkmic:prxattrib->encrypt == WLAN_CIPHER_SUITE_TKIP\n");
    } else {

    }
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(4, 7, "recvframe_chkmic:da = %pM\n", (u8 *)(& prxattrib->ra));
    } else {

    }
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
      tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
      if ((int )tmp) {
        mickey = (u8 *)(& psecuritypriv->dot118021XGrprxmickey[(int )prxattrib->key_index].skey);
        if (GlobalDebugLevel23A > 6U) {
          rt_trace(4, 7, "recvframe_chkmic: bcmc key\n");
        } else {

        }
        if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
          res = 0;
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(4, 4, "recvframe_chkmic:didn\'t install group key!\n");
          } else {

          }
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: \n recvframe_chkmic:didn\'t install group key!!!!!!\n");
          } else {

          }
          goto exit;
        } else {

        }
      } else {
        mickey = (u8 *)(& stainfo->dot11tkiprxmickey.skey);
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "recvframe_chkmic: unicast key\n");
        } else {

        }
      }
      datalen = ((((precvframe->pkt)->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len) - (unsigned int )prxattrib->icv_len) - 8U;
      pframe = (precvframe->pkt)->data;
      payload = pframe + ((unsigned long )prxattrib->hdrlen + (unsigned long )prxattrib->iv_len);
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(4, 7, "prxattrib->iv_len =%d prxattrib->icv_len =%d\n", (int )prxattrib->iv_len,
                 (int )prxattrib->icv_len);
      } else {

      }
      rtw_seccalctkipmic23a(mickey, pframe, payload, datalen, (u8 *)(& miccode), (int )prxattrib->priority);
      pframemic = payload + (unsigned long )datalen;
      bmic_err = 0U;
      i = 0;
      goto ldv_53568;
      ldv_53567: ;
      if ((int )miccode[i] != (int )*(pframemic + (unsigned long )i)) {
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x)\n",
                   i, (int )miccode[i], i, (int )*(pframemic + (unsigned long )i));
        } else {

        }
        bmic_err = 1U;
      } else {

      }
      i = i + 1;
      ldv_53568: ;
      if (i <= 7) {
        goto ldv_53567;
      } else {

      }

      if ((unsigned int )bmic_err == 1U) {
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "*(pframemic-8)-*(pframemic-1) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                   (int )*(pframemic + 0xfffffffffffffff8UL), (int )*(pframemic + 0xfffffffffffffff9UL),
                   (int )*(pframemic + 0xfffffffffffffffaUL), (int )*(pframemic + 0xfffffffffffffffbUL),
                   (int )*(pframemic + 0xfffffffffffffffcUL), (int )*(pframemic + 0xfffffffffffffffdUL),
                   (int )*(pframemic + 0xfffffffffffffffeUL), (int )*(pframemic + 0xffffffffffffffffUL));
        } else {

        }
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "*(pframemic-16)-*(pframemic-9) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                   (int )*(pframemic + 0xfffffffffffffff0UL), (int )*(pframemic + 0xfffffffffffffff1UL),
                   (int )*(pframemic + 0xfffffffffffffff2UL), (int )*(pframemic + 0xfffffffffffffff3UL),
                   (int )*(pframemic + 0xfffffffffffffff4UL), (int )*(pframemic + 0xfffffffffffffff5UL),
                   (int )*(pframemic + 0xfffffffffffffff6UL), (int )*(pframemic + 0xfffffffffffffff7UL));
        } else {

        }
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "====== demp packet (len =%d) ======\n", (precvframe->pkt)->len);
        } else {

        }
        i___0 = 0;
        goto ldv_53572;
        ldv_53571: ;
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                   (int )*((precvframe->pkt)->data + (unsigned long )i___0), (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 1UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 2UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 3UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 4UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 5UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 6UL)),
                   (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 7UL)));
        } else {

        }
        i___0 = i___0 + 8;
        ldv_53572: ;
        if ((unsigned int )i___0 < (precvframe->pkt)->len) {
          goto ldv_53571;
        } else {

        }

        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "====== demp packet end [len =%d]======\n", (precvframe->pkt)->len);
        } else {

        }
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "hrdlen =%d\n", (int )prxattrib->hdrlen);
        } else {

        }
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "ra = %pM psecuritypriv->binstallGrpkey =%d\n", (u8 *)(& prxattrib->ra),
                   (int )psecuritypriv->binstallGrpkey);
        } else {

        }
        tmp___0 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
        if ((int )tmp___0 && (u32 )prxattrib->key_index != pmlmeinfo->key_index) {
          brpt_micerror = 0U;
        } else {

        }
        if ((unsigned int )prxattrib->bdecrypted == 1U && (unsigned int )brpt_micerror == 1U) {
          tmp___1 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
          rtw_handle_tkip_mic_err23a(adapter, (int )tmp___1);
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(4, 4, "mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU:  mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
        } else {
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(4, 4, "mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU:  mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
        }
        res = 0;
      } else
      if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
        tmp___2 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
        if ((int )tmp___2) {
          psecuritypriv->bcheck_grpkey = 1U;
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(4, 4, "psecuritypriv->bcheck_grpkey = true\n");
          } else {

          }
        } else {

        }
      } else {

      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "recvframe_chkmic: rtw_get_stainfo23a ==NULL!!!\n");
    } else {

    }
    skb_trim(precvframe->pkt, (precvframe->pkt)->len - 8U);
  } else {

  }
  exit: ;
  return (res);
}
}
struct recv_frame *decryptor(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
struct recv_frame *decryptor(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct recv_frame *return_packet ;
  int res ;
  u8 *iv ;

  {
  prxattrib = & precv_frame->attrib;
  psecuritypriv = & padapter->securitypriv;
  return_packet = precv_frame;
  res = 1;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(4, 7, "prxstat->decrypted =%x prxattrib->encrypt = 0x%03x\n", (int )prxattrib->bdecrypted,
             prxattrib->encrypt);
  } else {

  }
  if (prxattrib->encrypt != 0U) {
    iv = (precv_frame->pkt)->data + (unsigned long )prxattrib->hdrlen;
    prxattrib->key_index = (u8 )((int )*(iv + 3UL) >> 6);
    if ((unsigned int )prxattrib->key_index > 4U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: prxattrib->key_index(%d) > WEP_KEYS\n", (int )prxattrib->key_index);
      } else {

      }
      switch (prxattrib->encrypt) {
      case 1027073U: ;
      case 1027077U: 
      prxattrib->key_index = (u8 )psecuritypriv->dot11PrivacyKeyIndex;
      goto ldv_53588;
      case 1027074U: ;
      case 1027076U: ;
      default: 
      prxattrib->key_index = (u8 )psecuritypriv->dot118021XGrpKeyid;
      goto ldv_53588;
      }
      ldv_53588: ;
    } else {

    }
  } else {

  }
  if (prxattrib->encrypt != 0U && (unsigned int )prxattrib->bdecrypted == 0U) {
    psecuritypriv->hw_decrypted = 0U;
    switch (prxattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
    rtw_wep_decrypt23a(padapter, precv_frame);
    goto ldv_53594;
    case 1027074U: 
    res = rtw_tkip_decrypt23a(padapter, precv_frame);
    goto ldv_53594;
    case 1027076U: 
    res = rtw_aes_decrypt23a(padapter, precv_frame);
    goto ldv_53594;
    default: ;
    goto ldv_53594;
    }
    ldv_53594: ;
  } else
  if (((unsigned int )prxattrib->bdecrypted == 1U && prxattrib->encrypt != 0U) && ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) != 0U || prxattrib->encrypt != 1027074U)) {
    psecuritypriv->hw_decrypted = 1U;
  } else {

  }
  if (res == 0) {
    rtw_free_recvframe23a(return_packet);
    return_packet = (struct recv_frame *)0;
  } else {

  }
  return (return_packet);
}
}
static struct recv_frame *portctrl(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 *psta_addr ;
  u8 *ptr ;
  uint auth_alg ;
  struct recv_frame *pfhdr ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct recv_frame *prtnframe ;
  u16 ether_type ;
  u16 eapol_type ;
  struct rx_pkt_attrib *pattrib ;

  {
  eapol_type = 34958U;
  pstapriv = & adapter->stapriv;
  auth_alg = adapter->securitypriv.dot11AuthAlgrthm;
  pfhdr = precv_frame;
  pattrib = & pfhdr->attrib;
  psta_addr = (u8 *)(& pattrib->ta);
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)psta_addr);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(4, 7, "########portctrl:adapter->securitypriv.dot11AuthAlgrthm =%d\n",
             adapter->securitypriv.dot11AuthAlgrthm);
  } else {

  }
  prtnframe = precv_frame;
  if (auth_alg == 2U) {
    ptr = (pfhdr->pkt)->data + (unsigned long )pfhdr->attrib.hdrlen;
    ether_type = (u16 )((int )((short )((int )*(ptr + 6UL) << 8)) | (int )((short )*(ptr + 7UL)));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0) && psta->ieee8021x_blocked != 0U) {
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(4, 7, "########portctrl:psta->ieee8021x_blocked ==1\n");
      } else {

      }
      if ((int )ether_type != (int )eapol_type) {
        rtw_free_recvframe23a(precv_frame);
        prtnframe = (struct recv_frame *)0;
      } else {

      }
    } else {

    }
  } else {

  }
  return (prtnframe);
}
}
int recv_decache(struct recv_frame *precv_frame , u8 bretry , struct stainfo_rxcache *prxcache ) ;
int recv_decache(struct recv_frame *precv_frame , u8 bretry , struct stainfo_rxcache *prxcache ) 
{ 
  int tid ;
  u16 seq_ctrl ;

  {
  tid = (int )precv_frame->attrib.priority;
  seq_ctrl = (u16 )((int )((short )((int )precv_frame->attrib.seq_num << 4)) | ((int )((short )precv_frame->attrib.frag_num) & 15));
  if (tid > 15) {
    if (GlobalDebugLevel23A > 5U) {
      rt_trace(4, 6, "recv_decache, (tid>15)! seq_ctrl = 0x%x, tid = 0x%x\n", (int )seq_ctrl,
               tid);
    } else {

    }
    return (0);
  } else {

  }
  if ((int )prxcache->tid_rxseq[tid] == (int )seq_ctrl) {
    if (GlobalDebugLevel23A > 5U) {
      rt_trace(4, 6, "recv_decache, seq_ctrl = 0x%x, tid = 0x%x, tid_rxseq = 0x%x\n",
               (int )seq_ctrl, tid, (int )prxcache->tid_rxseq[tid]);
    } else {

    }
    return (0);
  } else {

  }
  prxcache->tid_rxseq[tid] = seq_ctrl;
  return (1);
}
}
void process23a_pwrbit_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void process23a_pwrbit_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned char pwrbit ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  int tmp ;

  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  pattrib = & precv_frame->attrib;
  pstapriv = & padapter->stapriv;
  psta = (struct sta_info *)0;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    tmp = ieee80211_has_pm((int )hdr->frame_control);
    pwrbit = (unsigned char )tmp;
    if ((unsigned int )pwrbit != 0U) {
      if ((psta->state & 4U) == 0U) {
        stop_sta_xmit23a(padapter, psta);
      } else {

      }
    } else
    if ((psta->state & 4U) != 0U) {
      wakeup_sta_to_xmit23a(padapter, psta);
    } else {

    }
  } else {

  }
  return;
}
}
void process_wmmps_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void process_wmmps_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  u8 wmmps_ac ;

  {
  pattrib = & precv_frame->attrib;
  pstapriv = & padapter->stapriv;
  psta = (struct sta_info *)0;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {

  }
  if (psta->qos_option == 0U) {
    return;
  } else {

  }
  if (((int )psta->qos_info & 15) == 0) {
    return;
  } else {

  }
  if ((psta->state & 4U) != 0U) {
    wmmps_ac = 0U;
    switch ((int )pattrib->priority) {
    case 1: ;
    case 2: 
    wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
    goto ldv_53649;
    case 4: ;
    case 5: 
    wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
    goto ldv_53649;
    case 6: ;
    case 7: 
    wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
    goto ldv_53649;
    case 0: ;
    case 3: ;
    default: 
    wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
    goto ldv_53649;
    }
    ldv_53649: ;
    if ((unsigned int )wmmps_ac != 0U) {
      if (psta->sleepq_ac_len != 0U) {
        xmit_delivery_enabled_frames23a(padapter, psta);
      } else {
        issue_qos_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), (int )pattrib->priority,
                              0, 0);
      }
    } else {

    }
  } else {

  }
  return;
}
}
static void count_rx_stats(struct rtw_adapter *padapter , struct recv_frame *prframe ,
                           struct sta_info *sta ) 
{ 
  int sz ;
  struct sta_info *psta ;
  struct stainfo_stats *pstats ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_priv *precvpriv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  psta = (struct sta_info *)0;
  pstats = (struct stainfo_stats *)0;
  pattrib = & prframe->attrib;
  precvpriv = & padapter->recvpriv;
  sz = (int )(prframe->pkt)->len;
  precvpriv->rx_bytes = precvpriv->rx_bytes + (u64 )sz;
  padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod = padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod + 1U;
  tmp = is_broadcast_ether_addr((u8 const   *)(& pattrib->dst));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod = padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod + 1U;
    } else {

    }
  } else {

  }
  if ((unsigned long )sta != (unsigned long )((struct sta_info *)0)) {
    psta = sta;
  } else {
    psta = prframe->psta;
  }
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    pstats = & psta->sta_stats;
    pstats->rx_data_pkts = pstats->rx_data_pkts + 1ULL;
    pstats->rx_bytes = pstats->rx_bytes + (u64 )sz;
  } else {

  }
  return;
}
}
static int sta2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                              struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int ret ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  u8 *mybssid ;
  u8 *tmp ;
  u8 *myhwaddr ;
  u8 *tmp___0 ;
  u8 *sta_addr ;
  int bmcast ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;

  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  ret = 1;
  pattrib = & precv_frame->attrib;
  pstapriv = & adapter->stapriv;
  pmlmepriv = & adapter->mlmepriv;
  tmp = get_bssid(pmlmepriv);
  mybssid = tmp;
  tmp___0 = myid(& adapter->eeprompriv);
  myhwaddr = tmp___0;
  sta_addr = (u8 *)0U;
  tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
  bmcast = (int )tmp___1;
  tmp___18 = check_fwstate(pmlmepriv, 32);
  if ((int )tmp___18) {
    goto _L;
  } else {
    tmp___19 = check_fwstate(pmlmepriv, 64);
    if ((int )tmp___19) {
      _L: /* CIL Label */ 
      tmp___2 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->src));
      if ((int )tmp___2) {
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(4, 4, "SA == myself\n");
        } else {

        }
        ret = 0;
        goto exit;
      } else {

      }
      tmp___3 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
      if (tmp___3) {
        tmp___4 = 0;
      } else {
        tmp___4 = 1;
      }
      if (tmp___4 && bmcast == 0) {
        ret = 0;
        goto exit;
      } else {

      }
      tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)"");
      if ((int )tmp___5) {
        ret = 0;
        goto exit;
      } else {
        tmp___6 = ether_addr_equal((u8 const   *)mybssid, (u8 const   *)"");
        if ((int )tmp___6) {
          ret = 0;
          goto exit;
        } else {
          tmp___7 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
          if (tmp___7) {
            tmp___8 = 0;
          } else {
            tmp___8 = 1;
          }
          if (tmp___8) {
            ret = 0;
            goto exit;
          } else {

          }
        }
      }
      sta_addr = (u8 *)(& pattrib->src);
    } else {
      tmp___17 = check_fwstate(pmlmepriv, 8);
      if ((int )tmp___17) {
        tmp___9 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)(& pattrib->src));
        if (tmp___9) {
          tmp___10 = 0;
        } else {
          tmp___10 = 1;
        }
        if (tmp___10) {
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(4, 4, "bssid != TA under STATION_MODE; drop pkt\n");
          } else {

          }
          ret = 0;
          goto exit;
        } else {

        }
        sta_addr = (u8 *)(& pattrib->bssid);
      } else {
        tmp___16 = check_fwstate(pmlmepriv, 16);
        if ((int )tmp___16) {
          if (bmcast != 0) {
            tmp___11 = is_multicast_ether_addr((u8 const   *)(& pattrib->bssid));
            if (tmp___11) {
              tmp___12 = 0;
            } else {
              tmp___12 = 1;
            }
            if (tmp___12) {
              ret = 0;
              goto exit;
            } else {

            }
          } else {
            tmp___13 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)(& pattrib->dst));
            if (tmp___13) {
              tmp___14 = 0;
            } else {
              tmp___14 = 1;
            }
            if (tmp___14) {
              ret = 0;
              goto exit;
            } else {

            }
            sta_addr = (u8 *)(& pattrib->src);
          }
        } else {
          tmp___15 = check_fwstate(pmlmepriv, 65536);
          if ((int )tmp___15) {
            ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& hdr->addr1));
            ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& hdr->addr2));
            ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
            ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
            ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
            sta_addr = mybssid;
          } else {
            ret = 0;
          }
        }
      }
    }
  }
  if (bmcast != 0) {
    *psta = rtw_get_bcmc_stainfo23a(adapter);
  } else {
    *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)sta_addr);
  }
  if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "can\'t get psta under sta2sta_data_frame ; drop pkt\n");
    } else {

    }
    ret = 0;
    goto exit;
  } else {

  }
  exit: ;
  return (ret);
}
}
int ap2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) ;
int ap2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  int ret ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  u8 *mybssid ;
  u8 *tmp ;
  u8 *myhwaddr ;
  u8 *tmp___0 ;
  int bmcast ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;

  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  pattrib = & precv_frame->attrib;
  ret = 1;
  pstapriv = & adapter->stapriv;
  pmlmepriv = & adapter->mlmepriv;
  tmp = get_bssid(pmlmepriv);
  mybssid = tmp;
  tmp___0 = myid(& adapter->eeprompriv);
  myhwaddr = tmp___0;
  tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
  bmcast = (int )tmp___1;
  tmp___14 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___14) {
    tmp___15 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___15) {
      goto _L___2;
    } else {
      tmp___16 = check_fwstate(pmlmepriv, 128);
      if ((int )tmp___16) {
        _L___2: /* CIL Label */ 
        tmp___2 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->src));
        if ((int )tmp___2) {
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(4, 4, "SA == myself\n");
          } else {

          }
          ret = 0;
          goto exit;
        } else {

        }
        tmp___3 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
        if (tmp___3) {
          tmp___4 = 0;
        } else {
          tmp___4 = 1;
        }
        if (tmp___4 && bmcast == 0) {
          if (GlobalDebugLevel23A > 6U) {
            rt_trace(4, 7, "ap2sta_data_frame:  compare DA failed; DA=%pM\n", (u8 *)(& pattrib->dst));
          } else {

          }
          ret = 0;
          goto exit;
        } else {

        }
        tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)"");
        if ((int )tmp___5) {
          goto _L;
        } else {
          tmp___6 = ether_addr_equal((u8 const   *)mybssid, (u8 const   *)"");
          if ((int )tmp___6) {
            goto _L;
          } else {
            tmp___7 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
            if (tmp___7) {
              tmp___8 = 0;
            } else {
              tmp___8 = 1;
            }
            if (tmp___8) {
              _L: /* CIL Label */ 
              if (GlobalDebugLevel23A > 6U) {
                rt_trace(4, 7, "ap2sta_data_frame:  compare BSSID failed; BSSID=%pM\n",
                         (u8 *)(& pattrib->bssid));
              } else {

              }
              if (GlobalDebugLevel23A > 6U) {
                rt_trace(4, 7, "mybssid=%pM\n", mybssid);
              } else {

              }
              if (bmcast == 0) {
                if (GlobalDebugLevel23A > 3U) {
                  printk("\016RTL8723AU: issue_deauth23a to the nonassociated ap=%pM for the reason(7)\n",
                         (u8 *)(& pattrib->bssid));
                } else {

                }
                issue_deauth23a(adapter, (unsigned char *)(& pattrib->bssid), 7);
              } else {

              }
              ret = 0;
              goto exit;
            } else {

            }
          }
        }
        if (bmcast != 0) {
          *psta = rtw_get_bcmc_stainfo23a(adapter);
        } else {
          *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
        }
        if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(4, 4, "ap2sta: can\'t get psta under STATION_MODE; drop pkt\n");
          } else {

          }
          ret = 0;
          goto exit;
        } else {

        }
        tmp___9 = ieee80211_is_nullfunc((int )hdr->frame_control);
        if (tmp___9 != 0) {
          count_rx_stats(adapter, precv_frame, *psta);
          ret = 2;
          goto exit;
        } else {

        }
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: /* CIL Label */ 
    tmp___12 = check_fwstate(pmlmepriv, 65536);
    if ((int )tmp___12) {
      tmp___13 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___13) {
        ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& hdr->addr1));
        ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& hdr->addr2));
        ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
        ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
        ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
        ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)mybssid);
        *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
        if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(4, 4, "can\'t get psta under MP_MODE ; drop pkt\n");
          } else {

          }
          ret = 0;
          goto exit;
        } else {

        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      tmp___11 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___11) {
        ret = 2;
        goto exit;
      } else {
        tmp___10 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
        if ((int )tmp___10 && bmcast == 0) {
          *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
          if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
            if (GlobalDebugLevel23A > 3U) {
              printk("\016RTL8723AU: issue_deauth23a to the ap=%pM for the reason(7)\n",
                     (u8 *)(& pattrib->bssid));
            } else {

            }
            issue_deauth23a(adapter, (unsigned char *)(& pattrib->bssid), 7);
          } else {

          }
        } else {

        }
        ret = 0;
      }
    }
  }
  exit: ;
  return (ret);
}
}
int sta2ap_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) ;
int sta2ap_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  unsigned char *mybssid ;
  u8 *tmp ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u8 *myhwaddr ;
  u8 *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  pattrib = & precv_frame->attrib;
  pstapriv = & adapter->stapriv;
  pmlmepriv = & adapter->mlmepriv;
  tmp = get_bssid(pmlmepriv);
  mybssid = tmp;
  ret = 1;
  tmp___7 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___7) {
    tmp___0 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      ret = 0;
      goto exit;
    } else {

    }
    *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
    if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(4, 4, "can\'t get psta under AP_MODE; drop pkt\n");
      } else {

      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: issue_deauth23a to sta=%pM for the reason(7)\n", (u8 *)(& pattrib->src));
      } else {

      }
      issue_deauth23a(adapter, (unsigned char *)(& pattrib->src), 7);
      ret = 2;
      goto exit;
    } else {

    }
    process23a_pwrbit_data(adapter, precv_frame);
    tmp___2 = ieee80211_is_data_qos((int )hdr->frame_control);
    if (tmp___2 != 0) {
      process_wmmps_data(adapter, precv_frame);
    } else {

    }
    tmp___3 = ieee80211_is_nullfunc((int )hdr->frame_control);
    if (tmp___3 != 0) {
      count_rx_stats(adapter, precv_frame, *psta);
      ret = 2;
      goto exit;
    } else {

    }
  } else {
    tmp___4 = myid(& adapter->eeprompriv);
    myhwaddr = tmp___4;
    tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->ra), (u8 const   *)myhwaddr);
    if (tmp___5) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
    if (tmp___6) {
      ret = 2;
      goto exit;
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: issue_deauth23a to sta=%pM for the reason(7)\n", (u8 *)(& pattrib->src));
    } else {

    }
    issue_deauth23a(adapter, (unsigned char *)(& pattrib->src), 7);
    ret = 2;
    goto exit;
  }
  exit: ;
  return (ret);
}
}
static int validate_recv_ctrl_frame(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct ieee80211_pspoll *psp ;
  u16 aid ;
  u8 wmmps_ac ;
  struct sta_info *psta ;
  struct list_head *xmitframe_plist ;
  struct list_head *xmitframe_phead ;
  struct xmit_frame *pxmitframe ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;
  int tmp___8 ;

  {
  pattrib = & precv_frame->attrib;
  pstapriv = & padapter->stapriv;
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  tmp = ieee80211_is_ctl((int )hdr->frame_control);
  if (tmp == 0) {
    return (0);
  } else {

  }
  tmp___0 = myid(& padapter->eeprompriv);
  tmp___1 = ether_addr_equal((u8 const   *)(& hdr->addr1), (u8 const   *)tmp___0);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (0);
  } else {

  }
  tmp___8 = ieee80211_is_pspoll((int )hdr->frame_control);
  if (tmp___8 != 0) {
    psp = (struct ieee80211_pspoll *)hdr;
    wmmps_ac = 0U;
    psta = (struct sta_info *)0;
    aid = (unsigned int )psp->aid & 16383U;
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& hdr->addr2));
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0) || psta->aid != (uint )aid) {
      return (0);
    } else {

    }
    psta->sta_stats.rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts + 1ULL;
    switch ((int )pattrib->priority) {
    case 1: ;
    case 2: 
    wmmps_ac = (unsigned int )psta->uapsd_bk & 1U;
    goto ldv_53734;
    case 4: ;
    case 5: 
    wmmps_ac = (unsigned int )psta->uapsd_vi & 1U;
    goto ldv_53734;
    case 6: ;
    case 7: 
    wmmps_ac = (unsigned int )psta->uapsd_vo & 1U;
    goto ldv_53734;
    case 0: ;
    case 3: ;
    default: 
    wmmps_ac = (unsigned int )psta->uapsd_be & 1U;
    goto ldv_53734;
    }
    ldv_53734: ;
    if ((unsigned int )wmmps_ac != 0U) {
      return (0);
    } else {

    }
    if ((psta->state & 1024U) != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s alive check-rx ps-poll\n", "validate_recv_ctrl_frame");
      } else {

      }
      psta->expire_to = pstapriv->expire_to;
      psta->state = psta->state ^ 1024U;
    } else {

    }
    if ((psta->state & 4U) != 0U) {
      tmp___7 = CHKBIT(psta->aid);
      if (((u32 )pstapriv->sta_dz_bitmap & tmp___7) != 0U) {
        pxmitpriv = & padapter->xmitpriv;
        spin_lock_bh(& pxmitpriv->lock);
        xmitframe_phead = get_list_head(& psta->sleep_q);
        xmitframe_plist = xmitframe_phead->next;
        tmp___6 = list_empty((struct list_head  const  *)xmitframe_phead);
        if (tmp___6 == 0) {
          __mptr = (struct list_head  const  *)xmitframe_plist;
          pxmitframe = (struct xmit_frame *)__mptr;
          xmitframe_plist = xmitframe_plist->next;
          list_del_init(& pxmitframe->list);
          psta->sleepq_len = psta->sleepq_len - 1U;
          if (psta->sleepq_len != 0U) {
            pxmitframe->attrib.mdata = 1U;
          } else {
            pxmitframe->attrib.mdata = 0U;
          }
          pxmitframe->attrib.triggered = 1U;
          rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
          if (psta->sleepq_len == 0U) {
            tmp___3 = CHKBIT(psta->aid);
            pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___3));
            update_beacon23a(padapter, 5, (u8 *)0U, 0);
          } else {

          }
          spin_unlock_bh(& pxmitpriv->lock);
        } else {
          spin_unlock_bh(& pxmitpriv->lock);
          tmp___5 = CHKBIT(psta->aid);
          if (((u32 )pstapriv->tim_bitmap & tmp___5) != 0U) {
            if (psta->sleepq_len == 0U) {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: no buffered packets to xmit\n");
              } else {

              }
              issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 0,
                                0);
            } else {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: error!psta->sleepq_len =%d\n", psta->sleepq_len);
              } else {

              }
              psta->sleepq_len = 0U;
            }
            tmp___4 = CHKBIT(psta->aid);
            pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___4));
            update_beacon23a(padapter, 5, (u8 *)0U, 0);
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  return (0);
}
}
struct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int validate_recv_mgnt_frame(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sta_info *psta ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(4, 7, "+validate_recv_mgnt_frame\n");
  } else {

  }
  precv_frame = recvframe_chk_defrag23a(padapter, precv_frame);
  if ((unsigned long )precv_frame == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 5U) {
      rt_trace(4, 6, "%s: fragment packet\n", "validate_recv_mgnt_frame");
    } else {

    }
    return (1);
  } else {

  }
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& hdr->addr2));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    psta->sta_stats.rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts + 1ULL;
    tmp___4 = ieee80211_is_beacon((int )hdr->frame_control);
    if (tmp___4 != 0) {
      psta->sta_stats.rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts + 1ULL;
    } else {
      tmp___3 = ieee80211_is_probe_req((int )hdr->frame_control);
      if (tmp___3 != 0) {
        psta->sta_stats.rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts + 1ULL;
      } else {
        tmp___2 = ieee80211_is_probe_resp((int )hdr->frame_control);
        if (tmp___2 != 0) {
          tmp___1 = ether_addr_equal((u8 const   *)(& padapter->eeprompriv.mac_addr),
                                     (u8 const   *)(& hdr->addr1));
          if ((int )tmp___1) {
            psta->sta_stats.rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts + 1ULL;
          } else {
            tmp = is_broadcast_ether_addr((u8 const   *)(& hdr->addr1));
            if ((int )tmp) {
              psta->sta_stats.rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts + 1ULL;
            } else {
              tmp___0 = is_multicast_ether_addr((u8 const   *)(& hdr->addr1));
              if ((int )tmp___0) {
                psta->sta_stats.rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts + 1ULL;
              } else {
                psta->sta_stats.rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts + 1ULL;
              }
            }
          }
        } else {

        }
      }
    }
  } else {

  }
  mgt_dispatcher23a(padapter, precv_frame);
  return (1);
}
}
static int validate_recv_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 bretry ;
  u8 *psa ;
  u8 *pda ;
  struct sta_info *psta ;
  struct rx_pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  int ret ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  int tmp___0 ;
  __le16 *qptr ;
  u8 *tmp___1 ;
  u16 qos_ctrl ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
  psta = (struct sta_info *)0;
  pattrib = & precv_frame->attrib;
  psecuritypriv = & adapter->securitypriv;
  ret = 1;
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  tmp = ieee80211_has_retry((int )hdr->frame_control);
  bretry = (u8 )tmp;
  pda = ieee80211_get_DA(hdr);
  psa = ieee80211_get_SA(hdr);
  ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)pda);
  ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)psa);
  switch ((int )hdr->frame_control & 768) {
  case 0: 
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)pda);
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)psa);
  ret = sta2sta_data_frame(adapter, precv_frame, & psta);
  goto ldv_53774;
  case 512: 
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr2));
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)pda);
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& hdr->addr2));
  ret = ap2sta_data_frame(adapter, precv_frame, & psta);
  goto ldv_53774;
  case 256: 
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr1));
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& hdr->addr1));
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)psa);
  ret = sta2ap_data_frame(adapter, precv_frame, & psta);
  goto ldv_53774;
  case 768: 
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr1));
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& hdr->addr1));
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& hdr->addr2));
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(4, 4, "case 3\n");
  } else {

  }
  goto ldv_53774;
  }
  ldv_53774: ;
  if (ret == 0 || ret == 2) {
    goto exit;
  } else {

  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "after to_fr_ds_chk; psta == NULL\n");
    } else {

    }
    ret = 0;
    goto exit;
  } else {

  }
  precv_frame->psta = psta;
  pattrib->hdrlen = 24U;
  tmp___0 = ieee80211_has_a4((int )hdr->frame_control);
  if (tmp___0 != 0) {
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 6U;
  } else {

  }
  if ((unsigned int )pattrib->qos == 1U) {
    tmp___1 = ieee80211_get_qos_ctl(hdr);
    qptr = (__le16 *)tmp___1;
    qos_ctrl = *qptr;
    pattrib->priority = (unsigned int )((u8 )qos_ctrl) & 15U;
    pattrib->ack_policy = (unsigned int )((u8 )((int )qos_ctrl >> 5)) & 3U;
    pattrib->amsdu = (u8 )(((int )qos_ctrl & 128) >> 7);
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 2U;
    if ((unsigned int )pattrib->priority != 0U && (unsigned int )pattrib->priority != 3U) {
      adapter->recvpriv.bIsAnyNonBEPkts = 1U;
    } else {

    }
  } else {
    pattrib->priority = 0U;
    pattrib->ack_policy = 0U;
    pattrib->amsdu = 0U;
  }
  if ((unsigned int )pattrib->order != 0U) {
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 4U;
  } else {

  }
  precv_frame->preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )pattrib->priority;
  tmp___2 = recv_decache(precv_frame, (int )bretry, & psta->sta_recvpriv.rxcache);
  if (tmp___2 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "decache : drop pkt\n");
    } else {

    }
    ret = 0;
    goto exit;
  } else {

  }
  if ((unsigned int )pattrib->privacy != 0U) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(4, 7, "validate_recv_data_frame:pattrib->privacy =%x\n", (int )pattrib->privacy);
    } else {

    }
    if (GlobalDebugLevel23A > 6U) {
      tmp___3 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
      rt_trace(4, 7, "^^^^^^^^^^^is_multicast_ether_addr(pattrib->ra(0x%02x)) =%d^^^^^^^^^^^^^^^6\n",
               (int )pattrib->ra[0], (int )tmp___3);
    } else {

    }
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
    pattrib->encrypt = psecuritypriv->dot11PrivacyAlgrthm;
    goto ldv_53784;
    case 2U: 
    tmp___4 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
    if ((int )tmp___4) {
      pattrib->encrypt = psecuritypriv->dot118021XGrpPrivacy;
    } else {
      pattrib->encrypt = psta->dot118021XPrivacy;
    }
    goto ldv_53784;
    }
    ldv_53784: ;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(4, 7, "pattrib->encrypt =%d\n", pattrib->encrypt);
    } else {

    }
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
    pattrib->iv_len = 4U;
    pattrib->icv_len = 4U;
    goto ldv_53788;
    case 1027074U: 
    pattrib->iv_len = 8U;
    pattrib->icv_len = 4U;
    goto ldv_53788;
    case 1027076U: 
    pattrib->iv_len = 8U;
    pattrib->icv_len = 8U;
    goto ldv_53788;
    default: 
    pattrib->iv_len = 0U;
    pattrib->icv_len = 0U;
    goto ldv_53788;
    }
    ldv_53788: ;
  } else {
    pattrib->encrypt = 0U;
    pattrib->iv_len = 0U;
    pattrib->icv_len = 0U;
  }
  exit: ;
  return (ret);
}
}
static void dump_rx_pkt(struct sk_buff *skb , u16 type , int level ) 
{ 
  int i ;
  u8 *ptr ;

  {
  if ((level == 1 || (level == 2 && (unsigned int )type == 0U)) || (level == 3 && (unsigned int )type == 8U)) {
    ptr = skb->data;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: #############################\n");
    } else {

    }
    i = 0;
    goto ldv_53800;
    ldv_53799: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", (int )*(ptr + (unsigned long )i),
             (int )*(ptr + ((unsigned long )i + 1UL)), (int )*(ptr + ((unsigned long )i + 2UL)),
             (int )*(ptr + ((unsigned long )i + 3UL)), (int )*(ptr + ((unsigned long )i + 4UL)),
             (int )*(ptr + ((unsigned long )i + 5UL)), (int )*(ptr + ((unsigned long )i + 6UL)),
             (int )*(ptr + ((unsigned long )i + 7UL)));
    } else {

    }
    i = i + 8;
    ldv_53800: ;
    if (i <= 63) {
      goto ldv_53799;
    } else {

    }

    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: #############################\n");
    } else {

    }
  } else {

  }
  return;
}
}
static int validate_recv_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 type ;
  u8 subtype ;
  int retval ;
  struct rx_pkt_attrib *pattrib ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 ver ;
  u8 bDumpRxPkt ;
  u16 seq_ctrl ;
  u16 fctl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  struct recv_priv *precvpriv ;

  {
  retval = 1;
  pattrib = & precv_frame->attrib;
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  fctl = hdr->frame_control;
  ver = (unsigned int )((u8 )fctl) & 3U;
  type = (unsigned int )((u8 )fctl) & 12U;
  subtype = (unsigned int )((u8 )fctl) & 240U;
  if ((unsigned int )ver != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "validate_recv_data_frame fail! (ver!= 0)\n");
    } else {

    }
    retval = 0;
    goto exit;
  } else {

  }
  seq_ctrl = hdr->seq_ctrl;
  pattrib->frag_num = (unsigned int )((u8 )seq_ctrl) & 15U;
  pattrib->seq_num = (u16 )((int )seq_ctrl >> 4);
  tmp = ieee80211_has_pm((int )hdr->frame_control);
  pattrib->pw_save = (u8 )tmp;
  tmp___0 = ieee80211_has_morefrags((int )hdr->frame_control);
  pattrib->mfrag = (u8 )tmp___0;
  tmp___1 = ieee80211_has_moredata((int )hdr->frame_control);
  pattrib->mdata = (u8 )tmp___1;
  tmp___2 = ieee80211_has_protected((int )hdr->frame_control);
  pattrib->privacy = (u8 )tmp___2;
  tmp___3 = ieee80211_has_order((int )hdr->frame_control);
  pattrib->order = (u8 )tmp___3;
  GetHalDefVar8192CUsb(adapter, 6, (void *)(& bDumpRxPkt));
  tmp___4 = ldv__builtin_expect((unsigned int )bDumpRxPkt == 1U, 0L);
  if (tmp___4 != 0L) {
    dump_rx_pkt(skb, (int )type, (int )bDumpRxPkt);
  } else {

  }
  switch ((int )type) {
  case 0: 
  retval = validate_recv_mgnt_frame(adapter, precv_frame);
  if (retval == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "validate_recv_mgnt_frame fail\n");
    } else {

    }
  } else {

  }
  retval = 0;
  goto ldv_53818;
  case 4: 
  retval = validate_recv_ctrl_frame(adapter, precv_frame);
  if (retval == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "validate_recv_ctrl_frame fail\n");
    } else {

    }
  } else {

  }
  retval = 0;
  goto ldv_53818;
  case 8: 
  pattrib->qos = (int )((signed char )subtype) < 0;
  retval = validate_recv_data_frame(adapter, precv_frame);
  if (retval == 0) {
    precvpriv = & adapter->recvpriv;
    precvpriv->rx_drop = precvpriv->rx_drop + 1ULL;
  } else {

  }
  goto ldv_53818;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(4, 4, "validate_recv_data_frame fail! type = 0x%x\n", (int )type);
  } else {

  }
  retval = 0;
  goto ldv_53818;
  }
  ldv_53818: ;
  exit: ;
  return (retval);
}
}
static int wlanhdr_to_ethhdr(struct recv_frame *precvframe ) 
{ 
  u16 eth_type ;
  u16 len ;
  u16 hdrlen ;
  u8 bsnaphdr ;
  u8 *psnap ;
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  struct sk_buff *skb ;
  u8 *ptr ;
  struct rx_pkt_attrib *pattrib ;
  bool tmp ;
  bool tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  bool tmp___3 ;
  __u16 tmp___4 ;

  {
  adapter = precvframe->adapter;
  pmlmepriv = & adapter->mlmepriv;
  skb = precvframe->pkt;
  pattrib = & precvframe->attrib;
  ptr = skb->data;
  hdrlen = (u16 )pattrib->hdrlen;
  psnap = ptr + (unsigned long )hdrlen;
  eth_type = (u16 )((int )((short )((int )*(psnap + 6UL) << 8)) | (int )((short )*(psnap + 7UL)));
  tmp = ether_addr_equal((u8 const   *)psnap, (u8 const   *)(& rfc1042_header));
  if (((int )tmp && (unsigned int )eth_type != 33011U) && (unsigned int )eth_type != 33079U) {
    bsnaphdr = 1U;
    hdrlen = (unsigned int )hdrlen + 6U;
  } else {
    tmp___0 = ether_addr_equal((u8 const   *)psnap, (u8 const   *)(& bridge_tunnel_header));
    if ((int )tmp___0) {
      bsnaphdr = 1U;
      hdrlen = (unsigned int )hdrlen + 6U;
    } else {
      bsnaphdr = 0U;
      eth_type = (u16 )((int )((short )((int )*psnap << 8)) | (int )((short )*(psnap + 1UL)));
    }
  }
  len = (int )((u16 )skb->len) - (int )hdrlen;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(4, 7, "=== pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n", (int )pattrib->hdrlen,
             (int )pattrib->iv_len);
  } else {

  }
  pattrib->eth_type = eth_type;
  tmp___3 = check_fwstate(pmlmepriv, 65536);
  if ((int )tmp___3) {
    ptr = ptr + (unsigned long )hdrlen;
    *ptr = 135U;
    *(ptr + 1UL) = 18U;
    eth_type = 34578U;
    tmp___1 = skb_pull(skb, (unsigned int )hdrlen - 36U);
    ptr = tmp___1;
    memcpy((void *)ptr, (void const   *)skb->head, 24UL);
    ptr = ptr + 24UL;
  } else {
    tmp___2 = skb_pull(skb, ((unsigned int )hdrlen + ((unsigned int )bsnaphdr != 0U ? 2U : 0U)) - 14U);
    ptr = tmp___2;
  }
  ether_addr_copy(ptr, (u8 const   *)(& pattrib->dst));
  ether_addr_copy(ptr + 6UL, (u8 const   *)(& pattrib->src));
  if ((unsigned int )bsnaphdr == 0U) {
    tmp___4 = __fswab16((int )len);
    len = tmp___4;
    memcpy((void *)ptr + 12U, (void const   *)(& len), 2UL);
  } else {

  }
  return (1);
}
}
struct recv_frame *recvframe_defrag(struct rtw_adapter *adapter , struct rtw_queue *defrag_q ) ;
struct recv_frame *recvframe_defrag(struct rtw_adapter *adapter , struct rtw_queue *defrag_q ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  u8 *data ;
  u8 wlanhdr_offset ;
  u8 curfragnum ;
  struct recv_frame *pnfhdr ;
  struct recv_frame *prframe ;
  struct recv_frame *pnextrframe ;
  struct rtw_queue *pfree_recv_queue ;
  struct sk_buff *skb ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned char *tmp ;

  {
  curfragnum = 0U;
  pfree_recv_queue = & adapter->recvpriv.free_recv_queue;
  phead = get_list_head(defrag_q);
  plist = phead->next;
  __mptr = (struct list_head  const  *)plist;
  prframe = (struct recv_frame *)__mptr;
  list_del_init(& prframe->list);
  skb = prframe->pkt;
  if ((int )prframe->attrib.frag_num != (int )curfragnum) {
    rtw_free_recvframe23a(prframe);
    rtw_free_recvframe23a_queue(defrag_q);
    return ((struct recv_frame *)0);
  } else {

  }
  curfragnum = (u8 )((int )curfragnum + 1);
  phead = get_list_head(defrag_q);
  data = (prframe->pkt)->data;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53859;
  ldv_53858: 
  __mptr___0 = (struct list_head  const  *)plist;
  pnfhdr = (struct recv_frame *)__mptr___0;
  pnextrframe = pnfhdr;
  if ((int )pnfhdr->attrib.frag_num != (int )curfragnum) {
    rtw_free_recvframe23a(prframe);
    rtw_free_recvframe23a_queue(defrag_q);
    return ((struct recv_frame *)0);
  } else {

  }
  curfragnum = (u8 )((int )curfragnum + 1);
  wlanhdr_offset = (int )pnfhdr->attrib.hdrlen + (int )pnfhdr->attrib.iv_len;
  skb_pull(pnfhdr->pkt, (unsigned int )wlanhdr_offset);
  skb_trim(skb, skb->len - (unsigned int )prframe->attrib.icv_len);
  tmp = skb_tail_pointer((struct sk_buff  const  *)skb);
  memcpy((void *)tmp, (void const   *)(pnfhdr->pkt)->data, (size_t )(pnfhdr->pkt)->len);
  skb_put(skb, (pnfhdr->pkt)->len);
  prframe->attrib.icv_len = pnfhdr->attrib.icv_len;
  plist = ptmp;
  ptmp = plist->next;
  ldv_53859: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53858;
  } else {

  }
  rtw_free_recvframe23a_queue(defrag_q);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(4, 7, "Performance defrag!!!!!\n");
  } else {

  }
  return (prframe);
}
}
struct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 ismfrag ;
  u8 fragnum ;
  u8 *psta_addr ;
  struct recv_frame *pfhdr ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct list_head *phead ;
  struct recv_frame *prtnframe ;
  struct rtw_queue *pfree_recv_queue ;
  struct rtw_queue *pdefrag_q ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  prtnframe = (struct recv_frame *)0;
  pstapriv = & padapter->stapriv;
  pfhdr = precv_frame;
  pfree_recv_queue = & padapter->recvpriv.free_recv_queue;
  ismfrag = pfhdr->attrib.mfrag;
  fragnum = pfhdr->attrib.frag_num;
  psta_addr = (u8 *)(& pfhdr->attrib.ta);
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)psta_addr);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    hdr = (struct ieee80211_hdr *)(pfhdr->pkt)->data;
    tmp = ieee80211_is_data((int )hdr->frame_control);
    if (tmp == 0) {
      psta = rtw_get_bcmc_stainfo23a(padapter);
      pdefrag_q = & psta->sta_recvpriv.defrag_q;
    } else {
      pdefrag_q = (struct rtw_queue *)0;
    }
  } else {
    pdefrag_q = & psta->sta_recvpriv.defrag_q;
  }
  if ((unsigned int )ismfrag == 0U && (unsigned int )fragnum == 0U) {
    prtnframe = precv_frame;
  } else {

  }
  if ((unsigned int )ismfrag == 1U) {
    if ((unsigned long )pdefrag_q != (unsigned long )((struct rtw_queue *)0)) {
      if ((unsigned int )fragnum == 0U) {
        tmp___0 = list_empty((struct list_head  const  *)(& pdefrag_q->queue));
        if (tmp___0 == 0) {
          rtw_free_recvframe23a_queue(pdefrag_q);
        } else {

        }
      } else {

      }
      phead = get_list_head(pdefrag_q);
      list_add_tail(& pfhdr->list, phead);
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(4, 7, "Enqueuq: ismfrag = %d, fragnum = %d\n", (int )ismfrag, (int )fragnum);
      } else {

      }
      prtnframe = (struct recv_frame *)0;
    } else {
      rtw_free_recvframe23a(precv_frame);
      prtnframe = (struct recv_frame *)0;
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(4, 4, "Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",
                 (int )ismfrag, (int )fragnum);
      } else {

      }
    }
  } else {

  }
  if ((unsigned int )ismfrag == 0U && (unsigned int )fragnum != 0U) {
    if ((unsigned long )pdefrag_q != (unsigned long )((struct rtw_queue *)0)) {
      phead = get_list_head(pdefrag_q);
      list_add_tail(& pfhdr->list, phead);
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(4, 7, "defrag: ismfrag = %d, fragnum = %d\n", (int )ismfrag, (int )fragnum);
      } else {

      }
      precv_frame = recvframe_defrag(padapter, pdefrag_q);
      prtnframe = precv_frame;
    } else {
      rtw_free_recvframe23a(precv_frame);
      prtnframe = (struct recv_frame *)0;
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(4, 4, "Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",
                 (int )ismfrag, (int )fragnum);
      } else {

      }
    }
  } else {

  }
  if ((unsigned long )prtnframe != (unsigned long )((struct recv_frame *)0) && (unsigned int )prtnframe->attrib.privacy != 0U) {
    tmp___1 = recvframe_chkmic(padapter, prtnframe);
    if (tmp___1 == 0) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(4, 4, "recvframe_chkmic(padapter,  prtnframe) ==_FAIL\n");
      } else {

      }
      rtw_free_recvframe23a(prtnframe);
      prtnframe = (struct recv_frame *)0;
    } else {

    }
  } else {

  }
  return (prtnframe);
}
}
int amsdu_to_msdu(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
int amsdu_to_msdu(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sk_buff *skb ;
  struct sk_buff *sub_skb ;
  struct sk_buff_head skb_list ;
  int tmp ;

  {
  pattrib = & prframe->attrib;
  skb = prframe->pkt;
  skb_pull(skb, (unsigned int )prframe->attrib.hdrlen);
  __skb_queue_head_init(& skb_list);
  ieee80211_amsdu_to_8023s(skb, & skb_list, (u8 const   *)0U, 0, 0U, 0);
  goto ldv_53888;
  ldv_53887: 
  sub_skb = __skb_dequeue(& skb_list);
  sub_skb->protocol = eth_type_trans(sub_skb, padapter->pnetdev);
  sub_skb->dev = padapter->pnetdev;
  sub_skb->ip_summed = 0U;
  netif_rx(sub_skb);
  ldv_53888: 
  tmp = skb_queue_empty((struct sk_buff_head  const  *)(& skb_list));
  if (tmp == 0) {
    goto ldv_53887;
  } else {

  }
  prframe->pkt = (struct sk_buff *)0;
  rtw_free_recvframe23a(prframe);
  return (1);
}
}
int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl , u16 seq_num ) ;
int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl , u16 seq_num ) 
{ 
  u8 wsize ;
  u16 wend ;

  {
  wsize = preorder_ctrl->wsize_b;
  wend = (unsigned int )((u16 )((unsigned int )((int )preorder_ctrl->indicate_seq + (int )((unsigned short )wsize)) + 65535U)) & 4095U;
  if ((unsigned int )preorder_ctrl->indicate_seq == 65535U) {
    preorder_ctrl->indicate_seq = seq_num;
  } else {

  }
  if ((((int )seq_num - (int )preorder_ctrl->indicate_seq) & 2048) != 0) {
    return (0);
  } else {

  }
  if ((int )preorder_ctrl->indicate_seq == (int )seq_num) {
    preorder_ctrl->indicate_seq = (unsigned int )((u16 )((unsigned int )preorder_ctrl->indicate_seq + 1U)) & 4095U;
  } else
  if ((((int )wend - (int )seq_num) & 2048) != 0) {
    if ((int )seq_num >= (int )wsize + -1) {
      preorder_ctrl->indicate_seq = (unsigned int )((int )seq_num - (int )((u16 )wsize)) + 1U;
    } else {
      preorder_ctrl->indicate_seq = (unsigned int )((int )seq_num - (int )((u16 )wsize)) + 4097U;
    }
  } else {

  }
  return (1);
}
}
static int enqueue_reorder_recvframe23a(struct recv_reorder_ctrl *preorder_ctrl ,
                                        struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct rtw_queue *ppending_recvframe_queue ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct recv_frame *hdr ;
  struct rx_pkt_attrib *pnextattrib ;
  struct list_head  const  *__mptr ;

  {
  pattrib = & prframe->attrib;
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  phead = get_list_head(ppending_recvframe_queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53915;
  ldv_53914: 
  __mptr = (struct list_head  const  *)plist;
  hdr = (struct recv_frame *)__mptr;
  pnextattrib = & hdr->attrib;
  if ((((int )pnextattrib->seq_num - (int )pattrib->seq_num) & 2048) != 0) {
    goto ldv_53912;
  } else
  if ((int )pnextattrib->seq_num == (int )pattrib->seq_num) {
    return (0);
  } else {
    goto ldv_53913;
  }
  ldv_53912: 
  plist = ptmp;
  ptmp = plist->next;
  ldv_53915: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53914;
  } else {

  }
  ldv_53913: 
  list_del_init(& prframe->list);
  list_add_tail(& prframe->list, plist);
  return (1);
}
}
int recv_indicatepkts_in_order(struct rtw_adapter *padapter , struct recv_reorder_ctrl *preorder_ctrl ,
                               int bforced ) ;
int recv_indicatepkts_in_order(struct rtw_adapter *padapter , struct recv_reorder_ctrl *preorder_ctrl ,
                               int bforced ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct recv_frame *prframe ;
  struct rx_pkt_attrib *pattrib ;
  int bPktInBuf ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *ppending_recvframe_queue ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  bPktInBuf = 0;
  precvpriv = & padapter->recvpriv;
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  phead = get_list_head(ppending_recvframe_queue);
  plist = phead->next;
  if (bforced != 0) {
    tmp = list_empty((struct list_head  const  *)phead);
    if (tmp != 0) {
      return (1);
    } else {

    }
    __mptr = (struct list_head  const  *)plist;
    prframe = (struct recv_frame *)__mptr;
    pattrib = & prframe->attrib;
    preorder_ctrl->indicate_seq = pattrib->seq_num;
  } else {

  }
  goto ldv_53938;
  ldv_53937: 
  __mptr___0 = (struct list_head  const  *)plist;
  prframe = (struct recv_frame *)__mptr___0;
  pattrib = & prframe->attrib;
  if ((((int )preorder_ctrl->indicate_seq - (int )pattrib->seq_num) & 2048) == 0) {
    if (GlobalDebugLevel23A > 5U) {
      rt_trace(4, 6, "recv_indicatepkts_in_order: indicate =%d seq =%d amsdu =%d\n",
               (int )preorder_ctrl->indicate_seq, (int )pattrib->seq_num, (int )pattrib->amsdu);
    } else {

    }
    plist = plist->next;
    list_del_init(& prframe->list);
    if ((int )preorder_ctrl->indicate_seq == (int )pattrib->seq_num) {
      preorder_ctrl->indicate_seq = (unsigned int )((u16 )((unsigned int )preorder_ctrl->indicate_seq + 1U)) & 4095U;
    } else {

    }
    if ((unsigned int )pattrib->amsdu == 0U) {
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
        rtw_recv_indicatepkt23a(padapter, prframe);
      } else {

      }
    } else {
      tmp___0 = amsdu_to_msdu(padapter, prframe);
      if (tmp___0 != 1) {
        rtw_free_recvframe23a(prframe);
      } else {

      }
    }
    bPktInBuf = 0;
  } else {
    bPktInBuf = 1;
    goto ldv_53936;
  }
  ldv_53938: 
  tmp___1 = list_empty((struct list_head  const  *)phead);
  if (tmp___1 == 0) {
    goto ldv_53937;
  } else {

  }
  ldv_53936: ;
  return (bPktInBuf);
}
}
int recv_indicatepkt_reorder(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
int recv_indicatepkt_reorder(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int retval ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct rtw_queue *ppending_recvframe_queue ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  retval = 1;
  pattrib = & prframe->attrib;
  preorder_ctrl = prframe->preorder_ctrl;
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  if ((unsigned int )pattrib->amsdu == 0U) {
    wlanhdr_to_ethhdr(prframe);
    if (((unsigned int )pattrib->qos != 1U || (unsigned int )pattrib->eth_type == 2054U) || (unsigned int )pattrib->ack_policy != 0U) {
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
        if (GlobalDebugLevel23A > 5U) {
          rt_trace(4, 6, "@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n");
        } else {

        }
        rtw_recv_indicatepkt23a(padapter, prframe);
        return (1);
      } else {

      }
      return (0);
    } else {

    }
    if ((unsigned int )preorder_ctrl->enable == 0U) {
      preorder_ctrl->indicate_seq = pattrib->seq_num;
      rtw_recv_indicatepkt23a(padapter, prframe);
      preorder_ctrl->indicate_seq = (u16 )(((int )preorder_ctrl->indicate_seq + 1) % 4096);
      return (1);
    } else {

    }
  } else
  if ((unsigned int )preorder_ctrl->enable == 0U) {
    preorder_ctrl->indicate_seq = pattrib->seq_num;
    retval = amsdu_to_msdu(padapter, prframe);
    preorder_ctrl->indicate_seq = (u16 )(((int )preorder_ctrl->indicate_seq + 1) % 4096);
    return (retval);
  } else {

  }
  spin_lock_bh(& ppending_recvframe_queue->lock);
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(4, 6, "recv_indicatepkt_reorder: indicate =%d seq =%d\n", (int )preorder_ctrl->indicate_seq,
             (int )pattrib->seq_num);
  } else {

  }
  tmp = check_indicate_seq(preorder_ctrl, (int )pattrib->seq_num);
  if (tmp == 0) {
    goto _err_exit;
  } else {

  }
  tmp___0 = enqueue_reorder_recvframe23a(preorder_ctrl, prframe);
  if (tmp___0 == 0) {
    goto _err_exit;
  } else {

  }
  tmp___2 = recv_indicatepkts_in_order(padapter, preorder_ctrl, 0);
  if (tmp___2 == 1) {
    tmp___1 = msecs_to_jiffies(50U);
    ldv_mod_timer_175(& preorder_ctrl->reordering_ctrl_timer, tmp___1 + (unsigned long )jiffies);
    spin_unlock_bh(& ppending_recvframe_queue->lock);
  } else {
    spin_unlock_bh(& ppending_recvframe_queue->lock);
    ldv_del_timer_sync_176(& preorder_ctrl->reordering_ctrl_timer);
  }
  return (1);
  _err_exit: 
  spin_unlock_bh(& ppending_recvframe_queue->lock);
  return (0);
}
}
void rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext ) 
{ 
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct rtw_adapter *padapter ;
  struct rtw_queue *ppending_recvframe_queue ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  preorder_ctrl = (struct recv_reorder_ctrl *)pcontext;
  padapter = preorder_ctrl->padapter;
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    return;
  } else {

  }
  spin_lock_bh(& ppending_recvframe_queue->lock);
  tmp___0 = recv_indicatepkts_in_order(padapter, preorder_ctrl, 1);
  if (tmp___0 == 1) {
    tmp = msecs_to_jiffies(50U);
    ldv_mod_timer_177(& preorder_ctrl->reordering_ctrl_timer, tmp + (unsigned long )jiffies);
  } else {

  }
  spin_unlock_bh(& ppending_recvframe_queue->lock);
  return;
}
}
int process_recv_indicatepkts(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
int process_recv_indicatepkts(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int retval ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  int tmp ;

  {
  retval = 1;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  if ((int )phtpriv->ht_option) {
    tmp = recv_indicatepkt_reorder(padapter, prframe);
    if (tmp != 1) {
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
        retval = 0;
        return (retval);
      } else {

      }
    } else {

    }
  } else {
    retval = wlanhdr_to_ethhdr(prframe);
    if (retval != 1) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(4, 4, "wlanhdr_to_ethhdr: drop pkt\n");
      } else {

      }
      return (retval);
    } else {

    }
    if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
      if (GlobalDebugLevel23A > 5U) {
        rt_trace(4, 6, "@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n");
      } else {

      }
      rtw_recv_indicatepkt23a(padapter, prframe);
    } else {
      if (GlobalDebugLevel23A > 5U) {
        rt_trace(4, 6, "@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n");
      } else {

      }
      if (GlobalDebugLevel23A > 5U) {
        rt_trace(4, 6, "recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped,
                 padapter->bSurpriseRemoved);
      } else {

      }
      retval = 0;
      return (retval);
    }
  }
  return (retval);
}
}
static int recv_func_prehandle(struct rtw_adapter *padapter , struct recv_frame *rframe ) 
{ 
  int ret ;

  {
  ret = 1;
  ret = validate_recv_frame(padapter, rframe);
  if (ret != 1) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(4, 7, "recv_func: validate_recv_frame fail! drop pkt\n");
    } else {

    }
    rtw_free_recvframe23a(rframe);
    goto exit;
  } else {

  }
  exit: ;
  return (ret);
}
}
static int recv_func_posthandle(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int ret ;
  struct recv_frame *orig_prframe ;
  struct recv_priv *precvpriv ;

  {
  ret = 1;
  orig_prframe = prframe;
  precvpriv = & padapter->recvpriv;
  prframe = decryptor(padapter, prframe);
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "decryptor: drop pkt\n");
    } else {

    }
    ret = 0;
    goto _recv_data_drop;
  } else {

  }
  prframe = recvframe_chk_defrag23a(padapter, prframe);
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "recvframe_chk_defrag23a: drop pkt\n");
    } else {

    }
    goto _recv_data_drop;
  } else {

  }
  if ((unsigned int )prframe->attrib.iv_len != 0U) {
    skb_pull(prframe->pkt, (unsigned int )prframe->attrib.iv_len);
  } else {

  }
  if ((unsigned int )prframe->attrib.icv_len != 0U) {
    skb_trim(prframe->pkt, (prframe->pkt)->len - (unsigned int )prframe->attrib.icv_len);
  } else {

  }
  prframe = portctrl(padapter, prframe);
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "portctrl: drop pkt\n");
    } else {

    }
    ret = 0;
    goto _recv_data_drop;
  } else {

  }
  count_rx_stats(padapter, prframe, (struct sta_info *)0);
  ret = process_recv_indicatepkts(padapter, prframe);
  if (ret != 1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "recv_func: process_recv_indicatepkts fail!\n");
    } else {

    }
    rtw_free_recvframe23a(orig_prframe);
    goto _recv_data_drop;
  } else {

  }
  return (ret);
  _recv_data_drop: 
  precvpriv->rx_drop = precvpriv->rx_drop + 1ULL;
  return (ret);
}
}
int rtw_recv_entry23a(struct recv_frame *rframe ) 
{ 
  int ret ;
  int r ;
  struct rtw_adapter *padapter ;
  struct rx_pkt_attrib *prxattrib ;
  struct recv_priv *recvpriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *mlmepriv ;
  struct recv_frame *pending_frame ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  padapter = rframe->adapter;
  prxattrib = & rframe->attrib;
  recvpriv = & padapter->recvpriv;
  psecuritypriv = & padapter->securitypriv;
  mlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(mlmepriv, 8);
  if ((int )tmp && (unsigned int )*((unsigned char *)psecuritypriv + 580UL) != 0U) {
    goto ldv_53994;
    ldv_53993: 
    r = recv_func_posthandle(padapter, pending_frame);
    if (r == 1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s: dequeue uc_swdec_pending_queue\n", "rtw_recv_entry23a");
      } else {

      }
    } else {

    }
    ldv_53994: 
    pending_frame = rtw_alloc_recvframe23a(& padapter->recvpriv.uc_swdec_pending_queue);
    if ((unsigned long )pending_frame != (unsigned long )((struct recv_frame *)0)) {
      goto ldv_53993;
    } else {

    }

  } else {

  }
  ret = recv_func_prehandle(padapter, rframe);
  if (ret == 1) {
    tmp___0 = check_fwstate(mlmepriv, 8);
    if ((int )tmp___0) {
      tmp___1 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      if (tmp___2) {
        if (prxattrib->encrypt != 0U) {
          if ((unsigned int )prxattrib->bdecrypted == 0U) {
            if (psecuritypriv->dot11PrivacyAlgrthm != 1027073U && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
              if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
                rtw_enqueue_recvframe23a(rframe, & padapter->recvpriv.uc_swdec_pending_queue);
                if (GlobalDebugLevel23A > 3U) {
                  printk("\016RTL8723AU: %s: no key, enqueue uc_swdec_pending_queue\n",
                         "rtw_recv_entry23a");
                } else {

                }
                goto exit;
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    ret = recv_func_posthandle(padapter, rframe);
    recvpriv->rx_pkts = recvpriv->rx_pkts + 1ULL;
  } else {

  }
  exit: ;
  return (ret);
}
}
void rtw_signal_stat_timer_hdl23a(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct recv_priv *recvpriv ;
  u32 tmp_s ;
  u32 tmp_q ;
  u8 avg_signal_strength ;
  u8 avg_signal_qual ;
  u32 num_signal_strength ;
  u32 num_signal_qual ;
  u8 _alpha ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  adapter = (struct rtw_adapter *)data;
  recvpriv = & adapter->recvpriv;
  avg_signal_strength = 0U;
  avg_signal_qual = 0U;
  num_signal_strength = 0U;
  num_signal_qual = 0U;
  _alpha = 3U;
  if ((unsigned int )recvpriv->signal_strength_data.update_req == 0U) {
    avg_signal_strength = recvpriv->signal_strength_data.avg_val;
    num_signal_strength = recvpriv->signal_strength_data.total_num;
    recvpriv->signal_strength_data.update_req = 1U;
  } else {

  }
  if ((unsigned int )recvpriv->signal_qual_data.update_req == 0U) {
    avg_signal_qual = recvpriv->signal_qual_data.avg_val;
    num_signal_qual = recvpriv->signal_qual_data.total_num;
    recvpriv->signal_qual_data.update_req = 1U;
  } else {

  }
  tmp = check_fwstate(& adapter->mlmepriv, 2048);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    tmp_s = (u32 )((int )avg_signal_strength + ((int )_alpha + -1) * (int )recvpriv->signal_strength);
    if (tmp_s % (u32 )_alpha != 0U) {
      tmp_s = tmp_s / (u32 )_alpha + 1U;
    } else {
      tmp_s = tmp_s / (u32 )_alpha;
    }
    if (tmp_s > 100U) {
      tmp_s = 100U;
    } else {

    }
    tmp_q = (u32 )((int )avg_signal_qual + ((int )_alpha + -1) * (int )recvpriv->signal_qual);
    if (tmp_q % (u32 )_alpha != 0U) {
      tmp_q = tmp_q / (u32 )_alpha + 1U;
    } else {
      tmp_q = tmp_q / (u32 )_alpha;
    }
    if (tmp_q > 100U) {
      tmp_q = 100U;
    } else {

    }
    recvpriv->signal_strength = (u8 )tmp_s;
    recvpriv->signal_qual = (u8 )tmp_q;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s signal_strength:%3u, signal_qual:%3u, num_signal_strength:%u, num_signal_qual:%u\n",
             "rtw_signal_stat_timer_hdl23a", (int )recvpriv->signal_strength, (int )recvpriv->signal_qual,
             num_signal_strength, num_signal_qual);
    } else {

    }
  } else {

  }
  tmp___1 = msecs_to_jiffies(recvpriv->signal_stat_sampling_interval);
  ldv_mod_timer_178(& recvpriv->signal_stat_timer, tmp___1 + (unsigned long )jiffies);
  return;
}
}
void timer_init_12(void) 
{ 


  {
  ldv_timer_12_0 = 0;
  ldv_timer_12_1 = 0;
  ldv_timer_12_2 = 0;
  ldv_timer_12_3 = 0;
  return;
}
}
int reg_timer_12(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& rtw_signal_stat_timer_hdl23a)) {
    activate_suitable_timer_12(timer, data);
  } else {

  }
  return (0);
}
}
void activate_pending_timer_12(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_12_0 == (unsigned long )timer) {
    if (ldv_timer_12_0 == 2 || pending_flag != 0) {
      ldv_timer_list_12_0 = timer;
      ldv_timer_list_12_0->data = data;
      ldv_timer_12_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_12_1 == (unsigned long )timer) {
    if (ldv_timer_12_1 == 2 || pending_flag != 0) {
      ldv_timer_list_12_1 = timer;
      ldv_timer_list_12_1->data = data;
      ldv_timer_12_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_12_2 == (unsigned long )timer) {
    if (ldv_timer_12_2 == 2 || pending_flag != 0) {
      ldv_timer_list_12_2 = timer;
      ldv_timer_list_12_2->data = data;
      ldv_timer_12_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_12_3 == (unsigned long )timer) {
    if (ldv_timer_12_3 == 2 || pending_flag != 0) {
      ldv_timer_list_12_3 = timer;
      ldv_timer_list_12_3->data = data;
      ldv_timer_12_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_12(timer, data);
  return;
}
}
void ldv_timer_12(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  rtw_signal_stat_timer_hdl23a(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void activate_suitable_timer_12(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_12_0 == 0 || ldv_timer_12_0 == 2) {
    ldv_timer_list_12_0 = timer;
    ldv_timer_list_12_0->data = data;
    ldv_timer_12_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_12_1 == 0 || ldv_timer_12_1 == 2) {
    ldv_timer_list_12_1 = timer;
    ldv_timer_list_12_1->data = data;
    ldv_timer_12_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_12_2 == 0 || ldv_timer_12_2 == 2) {
    ldv_timer_list_12_2 = timer;
    ldv_timer_list_12_2->data = data;
    ldv_timer_12_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_12_3 == 0 || ldv_timer_12_3 == 2) {
    ldv_timer_list_12_3 = timer;
    ldv_timer_list_12_3->data = data;
    ldv_timer_12_3 = 1;
    return;
  } else {

  }
  return;
}
}
void choose_timer_12(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_12_0 == 1) {
    ldv_timer_12_0 = 2;
    ldv_timer_12(ldv_timer_12_0, ldv_timer_list_12_0);
  } else {

  }
  goto ldv_54036;
  case 1: ;
  if (ldv_timer_12_1 == 1) {
    ldv_timer_12_1 = 2;
    ldv_timer_12(ldv_timer_12_1, ldv_timer_list_12_1);
  } else {

  }
  goto ldv_54036;
  case 2: ;
  if (ldv_timer_12_2 == 1) {
    ldv_timer_12_2 = 2;
    ldv_timer_12(ldv_timer_12_2, ldv_timer_list_12_2);
  } else {

  }
  goto ldv_54036;
  case 3: ;
  if (ldv_timer_12_3 == 1) {
    ldv_timer_12_3 = 2;
    ldv_timer_12(ldv_timer_12_3, ldv_timer_list_12_3);
  } else {

  }
  goto ldv_54036;
  default: 
  ldv_stop();
  }
  ldv_54036: ;
  return;
}
}
void disable_suitable_timer_12(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_12_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_12_0) {
    ldv_timer_12_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_12_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_12_1) {
    ldv_timer_12_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_12_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_12_2) {
    ldv_timer_12_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_12_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_12_3) {
    ldv_timer_12_3 = 0;
    return;
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_170(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_171(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_172(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_173(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_174(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_175(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_176(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_177(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_178(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 


  {
  return ((__u32 )*p);
}
}
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_194(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_196(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static u32 get_unaligned_le32(void const   *p ) 
{ 
  __u32 tmp ;

  {
  tmp = __le32_to_cpup((__le32 const   *)p);
  return (tmp);
}
}
void rtw_secmicsetkey23a(struct mic_data *pmicdata , u8 *key ) ;
void rtw_secmicappend23abyte23a(struct mic_data *pmicdata , u8 b ) ;
void rtw_secmicappend23a(struct mic_data *pmicdata , u8 *src , u32 nbytes ) ;
void rtw_secgetmic23a(struct mic_data *pmicdata , u8 *dst ) ;
int rtw_aes_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
int rtw_tkip_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
void rtw_use_tkipkey_handler23a(void *FunctionContext ) ;
static void arcfour_init(struct arc4context *parc4ctx , u8 *key , u32 key_len ) 
{ 
  u32 t ;
  u32 u ;
  u32 keyindex ;
  u32 stateindex ;
  u8 *state ;
  u32 counter ;

  {
  state = (u8 *)(& parc4ctx->state);
  parc4ctx->x = 0U;
  parc4ctx->y = 0U;
  counter = 0U;
  goto ldv_53190;
  ldv_53189: 
  *(state + (unsigned long )counter) = (unsigned char )counter;
  counter = counter + 1U;
  ldv_53190: ;
  if (counter <= 255U) {
    goto ldv_53189;
  } else {

  }
  keyindex = 0U;
  stateindex = 0U;
  counter = 0U;
  goto ldv_53193;
  ldv_53192: 
  t = (u32 )*(state + (unsigned long )counter);
  stateindex = (((u32 )*(key + (unsigned long )keyindex) + stateindex) + t) & 255U;
  u = (u32 )*(state + (unsigned long )stateindex);
  *(state + (unsigned long )stateindex) = (unsigned char )t;
  *(state + (unsigned long )counter) = (unsigned char )u;
  keyindex = keyindex + 1U;
  if (keyindex >= key_len) {
    keyindex = 0U;
  } else {

  }
  counter = counter + 1U;
  ldv_53193: ;
  if (counter <= 255U) {
    goto ldv_53192;
  } else {

  }

  return;
}
}
static u32 arcfour_byte(struct arc4context *parc4ctx ) 
{ 
  u32 x ;
  u32 y ;
  u32 sx ;
  u32 sy ;
  u8 *state ;

  {
  state = (u8 *)(& parc4ctx->state);
  x = (parc4ctx->x + 1U) & 255U;
  sx = (u32 )*(state + (unsigned long )x);
  y = (parc4ctx->y + sx) & 255U;
  sy = (u32 )*(state + (unsigned long )y);
  parc4ctx->x = x;
  parc4ctx->y = y;
  *(state + (unsigned long )y) = (unsigned char )sx;
  *(state + (unsigned long )x) = (unsigned char )sy;
  return ((u32 )*(state + ((unsigned long )(sx + sy) & 255UL)));
}
}
static void arcfour_encrypt(struct arc4context *parc4ctx , u8 *dest , u8 *src , u32 len ) 
{ 
  u32 i ;
  u32 tmp ;

  {
  i = 0U;
  goto ldv_53211;
  ldv_53210: 
  tmp = arcfour_byte(parc4ctx);
  *(dest + (unsigned long )i) = (u8 )((int )*(src + (unsigned long )i) ^ (int )((unsigned char )tmp));
  i = i + 1U;
  ldv_53211: ;
  if (i < len) {
    goto ldv_53210;
  } else {

  }

  return;
}
}
static int bcrc32initialized  ;
static u32 crc32_table[256U]  ;
static u8 crc32_reverseBit(u8 data ) 
{ 
  u8 retval ;

  {
  retval = (u8 )((((((((int )((signed char )((int )data << 7)) | ((int )((signed char )((int )data << 5)) & 64)) | ((int )((signed char )((int )data << 3)) & 32)) | ((int )((signed char )((int )data << 1)) & 16)) | ((int )((signed char )((int )data >> 1)) & 8)) | ((int )((signed char )((int )data >> 3)) & 4)) | ((int )((signed char )((int )data >> 5)) & 2)) | (int )((signed char )((int )data >> 7)));
  return (retval);
}
}
static void crc32_init(void) 
{ 
  int i ;
  int j ;
  u32 c ;
  u8 *p ;
  u8 *p1 ;
  u8 k ;

  {
  if (bcrc32initialized == 1) {
    return;
  } else {

  }
  p = (u8 *)(& c);
  c = 305397760U;
  i = 0;
  goto ldv_53232;
  ldv_53231: 
  k = crc32_reverseBit((int )((unsigned char )i));
  c = (unsigned int )k << 24;
  j = 8;
  goto ldv_53229;
  ldv_53228: 
  c = (int )c < 0 ? (c << 1) ^ 79764919U : c << 1;
  j = j - 1;
  ldv_53229: ;
  if (j > 0) {
    goto ldv_53228;
  } else {

  }
  p1 = (u8 *)(& crc32_table) + (unsigned long )i;
  *p1 = crc32_reverseBit((int )*(p + 3UL));
  *(p1 + 1UL) = crc32_reverseBit((int )*(p + 2UL));
  *(p1 + 2UL) = crc32_reverseBit((int )*(p + 1UL));
  *(p1 + 3UL) = crc32_reverseBit((int )*p);
  i = i + 1;
  ldv_53232: ;
  if (i <= 255) {
    goto ldv_53231;
  } else {

  }
  bcrc32initialized = 1;
  return;
}
}
static u32 getcrc32(u8 *buf , int len ) 
{ 
  u8 *p ;
  u32 crc ;

  {
  if (bcrc32initialized == 0) {
    crc32_init();
  } else {

  }
  crc = 4294967295U;
  p = buf;
  goto ldv_53241;
  ldv_53240: 
  crc = crc32_table[((u32 )*p ^ crc) & 255U] ^ (crc >> 8);
  p = p + 1;
  len = len - 1;
  ldv_53241: ;
  if (len > 0) {
    goto ldv_53240;
  } else {

  }

  return (~ crc);
}
}
void rtw_wep_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  unsigned char crc[4U] ;
  struct arc4context mycontext ;
  int curfragnum ;
  int length ;
  int index ;
  u32 keylength ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 wepkey[16U] ;
  u8 hw_hdr_offset ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;

  {
  hw_hdr_offset = 0U;
  pattrib = & pxmitframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv = & padapter->xmitpriv;
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
    return;
  } else {

  }
  hw_hdr_offset = 40U;
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
  if (pattrib->encrypt != 1027073U && pattrib->encrypt != 1027077U) {
    return;
  } else {

  }
  index = (int )psecuritypriv->dot11PrivacyKeyIndex;
  keylength = (u32 )psecuritypriv->wep_key[index].keylen;
  curfragnum = 0;
  goto ldv_53262;
  ldv_53261: 
  iv = pframe + (unsigned long )pattrib->hdrlen;
  memcpy((void *)(& wepkey), (void const   *)iv, 3UL);
  memcpy((void *)(& wepkey) + 3U, (void const   *)(& psecuritypriv->wep_key[index].key),
           (size_t )keylength);
  payload = pframe + ((unsigned long )pattrib->iv_len + (unsigned long )pattrib->hdrlen);
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
    *((u32 *)(& crc)) = getcrc32(payload, length);
    arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
  } else {
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
    *((u32 *)(& crc)) = getcrc32(payload, length);
    arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
  curfragnum = curfragnum + 1;
  ldv_53262: ;
  if ((int )pattrib->nr_frags > curfragnum) {
    goto ldv_53261;
  } else {

  }

  return;
}
}
void rtw_wep_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  u32 actual_crc ;
  u32 expected_crc ;
  struct arc4context mycontext ;
  int length ;
  u32 keylength ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 wepkey[16U] ;
  u8 keyindex ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;

  {
  prxattrib = & precvframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  skb = precvframe->pkt;
  pframe = skb->data;
  if (prxattrib->encrypt != 1027073U && prxattrib->encrypt != 1027077U) {
    return;
  } else {

  }
  iv = pframe + (unsigned long )prxattrib->hdrlen;
  keyindex = prxattrib->key_index;
  keylength = (u32 )psecuritypriv->wep_key[(int )keyindex].keylen;
  memcpy((void *)(& wepkey), (void const   *)iv, 3UL);
  memcpy((void *)(& wepkey) + 3U, (void const   *)(& psecuritypriv->wep_key[(int )keyindex].key),
           (size_t )keylength);
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
  payload = pframe + ((unsigned long )prxattrib->iv_len + (unsigned long )prxattrib->hdrlen);
  arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
  arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
  actual_crc = getcrc32(payload, length + -4);
  expected_crc = get_unaligned_le32((void const   *)(payload + ((unsigned long )length + 0xfffffffffffffffcUL)));
  if (actual_crc != expected_crc) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4096, 4, "%s:icv CRC mismatch: actual: %08x, expected: %08x\n", "rtw_wep_decrypt23a",
               actual_crc, expected_crc);
    } else {

    }
  } else {

  }
  return;
}
}
static u32 secmicgetuint32(u8 *p ) 
{ 
  s32 i ;
  u32 res ;
  u8 *tmp ;

  {
  res = 0U;
  i = 0;
  goto ldv_53288;
  ldv_53287: 
  tmp = p;
  p = p + 1;
  res = ((unsigned int )*tmp << i * 8) | res;
  i = i + 1;
  ldv_53288: ;
  if (i <= 3) {
    goto ldv_53287;
  } else {

  }

  return (res);
}
}
static void secmicputuint32(u8 *p , u32 val ) 
{ 
  long i ;
  u8 *tmp ;

  {
  i = 0L;
  goto ldv_53296;
  ldv_53295: 
  tmp = p;
  p = p + 1;
  *tmp = (unsigned char )val;
  val = val >> 8;
  i = i + 1L;
  ldv_53296: ;
  if (i <= 3L) {
    goto ldv_53295;
  } else {

  }

  return;
}
}
static void secmicclear(struct mic_data *pmicdata ) 
{ 


  {
  pmicdata->L = pmicdata->K0;
  pmicdata->R = pmicdata->K1;
  pmicdata->nBytesInM = 0U;
  pmicdata->M = 0U;
  return;
}
}
void rtw_secmicsetkey23a(struct mic_data *pmicdata , u8 *key ) 
{ 


  {
  pmicdata->K0 = secmicgetuint32(key);
  pmicdata->K1 = secmicgetuint32(key + 4UL);
  secmicclear(pmicdata);
  return;
}
}
void rtw_secmicappend23abyte23a(struct mic_data *pmicdata , u8 b ) 
{ 


  {
  pmicdata->M = pmicdata->M | (u32 )((unsigned long )b << (int )(pmicdata->nBytesInM * 8U));
  pmicdata->nBytesInM = pmicdata->nBytesInM + 1U;
  if (pmicdata->nBytesInM > 3U) {
    pmicdata->L = pmicdata->L ^ pmicdata->M;
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 15) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 15UL)));
    pmicdata->L = pmicdata->L + pmicdata->R;
    pmicdata->R = pmicdata->R ^ (((pmicdata->L & 4278255360U) >> 8) | ((pmicdata->L & 16711935U) << 8));
    pmicdata->L = pmicdata->L + pmicdata->R;
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 29) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 29UL)));
    pmicdata->L = pmicdata->L + pmicdata->R;
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 2) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 2UL)));
    pmicdata->L = pmicdata->L + pmicdata->R;
    pmicdata->M = 0U;
    pmicdata->nBytesInM = 0U;
  } else {

  }
  return;
}
}
void rtw_secmicappend23a(struct mic_data *pmicdata , u8 *src , u32 nbytes ) 
{ 
  u8 *tmp ;

  {
  goto ldv_53315;
  ldv_53314: 
  tmp = src;
  src = src + 1;
  rtw_secmicappend23abyte23a(pmicdata, (int )*tmp);
  nbytes = nbytes - 1U;
  ldv_53315: ;
  if (nbytes != 0U) {
    goto ldv_53314;
  } else {

  }

  return;
}
}
void rtw_secgetmic23a(struct mic_data *pmicdata , u8 *dst ) 
{ 


  {
  rtw_secmicappend23abyte23a(pmicdata, 90);
  rtw_secmicappend23abyte23a(pmicdata, 0);
  rtw_secmicappend23abyte23a(pmicdata, 0);
  rtw_secmicappend23abyte23a(pmicdata, 0);
  rtw_secmicappend23abyte23a(pmicdata, 0);
  goto ldv_53322;
  ldv_53321: 
  rtw_secmicappend23abyte23a(pmicdata, 0);
  ldv_53322: ;
  if (pmicdata->nBytesInM != 0U) {
    goto ldv_53321;
  } else {

  }
  secmicputuint32(dst, pmicdata->L);
  secmicputuint32(dst + 4UL, pmicdata->R);
  secmicclear(pmicdata);
  return;
}
}
void rtw_seccalctkipmic23a(u8 *key , u8 *header , u8 *data , u32 data_len , u8 *mic_code ,
                           u8 pri ) 
{ 
  struct mic_data micdata ;
  u8 priority[4U] ;

  {
  priority[0] = 0U;
  priority[1] = 0U;
  priority[2] = 0U;
  priority[3] = 0U;
  rtw_secmicsetkey23a(& micdata, key);
  priority[0] = pri;
  if ((int )*(header + 1UL) & 1) {
    rtw_secmicappend23a(& micdata, header + 16UL, 6U);
    if (((int )*(header + 1UL) & 2) != 0) {
      rtw_secmicappend23a(& micdata, header + 24UL, 6U);
    } else {
      rtw_secmicappend23a(& micdata, header + 10UL, 6U);
    }
  } else {
    rtw_secmicappend23a(& micdata, header + 4UL, 6U);
    if (((int )*(header + 1UL) & 2) != 0) {
      rtw_secmicappend23a(& micdata, header + 16UL, 6U);
    } else {
      rtw_secmicappend23a(& micdata, header + 10UL, 6U);
    }
  }
  rtw_secmicappend23a(& micdata, (u8 *)(& priority), 4U);
  rtw_secmicappend23a(& micdata, data, data_len);
  rtw_secgetmic23a(& micdata, mic_code);
  return;
}
}
static unsigned short const   Sbox1[2U][256U]  = { {        50853U,        63620U,        61081U,        63117U, 
            65293U,        54973U,        57009U,        37204U, 
            24656U,        515U,        52905U,        22141U, 
            59161U,        46434U,        19942U,        60570U, 
            36677U,        8093U,        35136U,        64135U, 
            61205U,        45803U,        36553U,        64267U, 
            16876U,        45927U,        24573U,        17898U, 
            9151U,        21495U,        58518U,        39771U, 
            30146U,        57628U,        15790U,        19562U, 
            27738U,        32321U,        62722U,        33615U, 
            26716U,        20980U,        53556U,        63752U, 
            58003U,        43891U,        25171U,        10815U, 
            2060U,        38226U,        18021U,        40286U, 
            12328U,        14241U,        2575U,        12213U, 
            3593U,        9270U,        7067U,        57149U, 
            52518U,        20073U,        32717U,        60063U, 
            4635U,        7582U,        22644U,        13358U, 
            13869U,        56498U,        46318U,        23547U, 
            42230U,        30285U,        46945U,        32206U, 
            21115U,        56638U,        24177U,        5015U, 
            42741U,        47464U,        0U,        49452U, 
            16480U,        58143U,        31176U,        46829U, 
            54462U,        36166U,        26585U,        29259U, 
            38110U,        39124U,        45288U,        34122U, 
            47979U,        50474U,        20453U,        60694U, 
            34501U,        39639U,        26197U,        4500U, 
            35535U,        59664U,        1030U,        65153U, 
            41200U,        30788U,        9658U,        19427U, 
            41715U,        24062U,        32960U,        1418U, 
            16301U,        8636U,        28744U,        61700U, 
            25567U,        30657U,        44917U,        16995U, 
            8240U,        58650U,        64782U,        49005U, 
            33100U,        6164U,        9781U,        49967U, 
            48865U,        13730U,        35020U,        11833U, 
            37719U,        22002U,        64642U,        31303U, 
            51372U,        47847U,        12843U,        59029U, 
            49312U,        6552U,        40657U,        41855U, 
            17510U,        21630U,        15275U,        2947U, 
            36042U,        50985U,        27603U,        10300U, 
            42873U,        48354U,        5661U,        44406U, 
            56123U,        25686U,        29774U,        5150U, 
            37595U,        3082U,        18540U,        47332U, 
            40797U,        48494U,        17391U,        50342U, 
            14760U,        12708U,        54071U,        62091U, 
            54578U,        35651U,        28249U,        55991U, 
            396U,        45412U,        40146U,        18912U, 
            55476U,        44282U,        62215U,        53029U, 
            51887U,        62606U,        18409U,        4120U, 
            28629U,        61576U,        19055U,        23666U, 
            14372U,        22513U,        29639U,        38737U, 
            52003U,        41340U,        59548U,        15905U, 
            38621U,        25052U,        3462U,        3973U, 
            57488U,        31810U,        29124U,        52394U, 
            37080U,        1541U,        63233U,        7186U, 
            49827U,        27231U,        44793U,        27088U, 
            6033U,        39256U,        14887U,        10169U, 
            55608U,        60179U,        11187U,        8755U, 
            53947U,        43376U,        1929U,        13223U, 
            11702U,        15394U,        5522U,        51488U, 
            34633U,        43775U,        20600U,        42362U, 
            911U,        23032U,        2432U,        6679U, 
            26074U,        55089U,        33990U,        53432U, 
            33475U,        10672U,        23159U,        7697U, 
            31691U,        43260U,        28118U,        11322U}, 
   {        42438U,        34040U,        39406U,        36342U, 
            3583U,        48598U,        45534U,        21649U, 
            20576U,        770U,        43470U,        32086U, 
            6631U,        25269U,        58957U,        39660U, 
            17807U,        40223U,        16521U,        34810U, 
            5615U,        60338U,        51598U,        3067U, 
            60481U,        26547U,        64863U,        59973U, 
            48931U,        63315U,        38628U,        23451U, 
            49781U,        7393U,        44605U,        27212U, 
            23148U,        16766U,        757U,        20355U, 
            23656U,        62545U,        13521U,        2297U, 
            37858U,        29611U,        21346U,        16170U, 
            3080U,        21141U,        25926U,        24221U, 
            10288U,        41271U,        3850U,        46383U, 
            2318U,        13860U,        39707U,        15839U, 
            9933U,        26958U,        52607U,        40938U, 
            6930U,        40477U,        29784U,        11828U, 
            11574U,        45788U,        61108U,        64347U, 
            63140U,        19830U,        25015U,        52861U, 
            31570U,        16093U,        29022U,        38675U, 
            62886U,        26809U,        0U,        11457U, 
            24640U,        8163U,        51321U,        60854U, 
            48852U,        18061U,        55655U,        19314U, 
            56980U,        54424U,        59568U,        19077U, 
            27579U,        10949U,        58703U,        5869U, 
            50566U,        55194U,        21862U,        37905U, 
            53130U,        4329U,        1540U,        33278U, 
            61600U,        17528U,        47653U,        58187U, 
            62370U,        65117U,        49280U,        35333U, 
            44351U,        48161U,        18544U,        1265U, 
            57187U,        49527U,        30127U,        25410U, 
            12320U,        6885U,        3837U,        28095U, 
            19585U,        5144U,        13606U,        12227U, 
            57790U,        41525U,        52360U,        14638U, 
            22419U,        62037U,        33532U,        18298U, 
            44232U,        59322U,        11058U,        38374U, 
            41152U,        38937U,        53662U,        32675U, 
            26180U,        32340U,        43835U,        33547U, 
            51852U,        10695U,        54123U,        15400U, 
            31143U,        58044U,        7446U,        30381U, 
            15323U,        22116U,        20084U,        7700U, 
            56210U,        2572U,        27720U,        58552U, 
            23967U,        28349U,        61251U,        42692U, 
            43065U,        42033U,        14291U,        35826U, 
            13013U,        17291U,        22894U,        47066U, 
            35841U,        25777U,        53916U,        57417U, 
            46296U,        64172U,        2035U,        9679U, 
            45002U,        36596U,        59719U,        6160U, 
            54639U,        35056U,        28490U,        29276U, 
            9272U,        61783U,        51059U,        20887U, 
            9163U,        31905U,        40168U,        8510U, 
            56726U,        56417U,        34317U,        34063U, 
            37088U,        17020U,        50289U,        43724U, 
            55440U,        1286U,        503U,        4636U, 
            41922U,        24426U,        63918U,        53353U, 
            37143U,        22681U,        10042U,        47399U, 
            14553U,        5099U,        45867U,        13090U, 
            48082U,        28841U,        35079U,        42803U, 
            46637U,        8764U,        37397U,        8393U, 
            18823U,        65450U,        30800U,        31397U, 
            36611U,        63577U,        32777U,        5914U, 
            55909U,        12759U,        50820U,        47312U, 
            50050U,        45097U,        30554U,        4382U, 
            52091U,        64680U,        54893U,        14892U}};
static void phase1(u16 *p1k , u8 const   *tk , u8 const   *ta , u32 iv32 ) 
{ 
  int i ;

  {
  *p1k = (unsigned short )iv32;
  *(p1k + 1UL) = (unsigned short )(iv32 >> 16);
  *(p1k + 2UL) = (u16 )((int )((short )*ta) ^ (int )((short )((int )*(ta + 1UL) << 8)));
  *(p1k + 3UL) = (u16 )((int )((short )*(ta + 2UL)) ^ (int )((short )((int )*(ta + 3UL) << 8)));
  *(p1k + 4UL) = (u16 )((int )((short )*(ta + 4UL)) ^ (int )((short )((int )*(ta + 5UL) << 8)));
  i = 0;
  goto ldv_53343;
  ldv_53342: 
  *p1k = (int )*p1k + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 4UL)) ^ ((int )((signed char )*(tk + (unsigned long )((i & 1) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 4UL) ^ ((int )*(tk + (unsigned long )((i & 1) * 2)) ^ ((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 1UL) = (int )*(p1k + 1UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*p1k) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 2) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 2) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*p1k ^ ((int )*(tk + (unsigned long )(((i & 1) + 2) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 2) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 2UL) = (int )*(p1k + 2UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 1UL)) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 4) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 4) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 1UL) ^ ((int )*(tk + (unsigned long )(((i & 1) + 4) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 4) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 3UL) = (int )*(p1k + 3UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 2UL)) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 6) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 6) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 2UL) ^ ((int )*(tk + (unsigned long )(((i & 1) + 6) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 6) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 4UL) = (int )*(p1k + 4UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 3UL)) ^ ((int )((signed char )*(tk + (unsigned long )((i & 1) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 3UL) ^ ((int )*(tk + (unsigned long )((i & 1) * 2)) ^ ((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 4UL) = (int )*(p1k + 4UL) + (int )((u16 )i);
  i = i + 1;
  ldv_53343: ;
  if (i <= 7) {
    goto ldv_53342;
  } else {

  }

  return;
}
}
static void phase2(u8 *rc4key , u8 const   *tk , u16 const   *p1k , u16 iv16 ) 
{ 
  int i ;
  u16 PPK[6U] ;

  {
  i = 0;
  goto ldv_53354;
  ldv_53353: 
  PPK[i] = *(p1k + (unsigned long )i);
  i = i + 1;
  ldv_53354: ;
  if (i <= 4) {
    goto ldv_53353;
  } else {

  }
  PPK[5] = (int )((u16 )*(p1k + 4UL)) + (int )iv16;
  PPK[0] = (int )PPK[0] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[5]) ^ ((int )((signed char )*tk) ^ (int )((signed char )((int )*(tk + 1UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[5] ^ ((int )*tk ^ ((int )*(tk + 1UL) << 8))) >> 8))])));
  PPK[1] = (int )PPK[1] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[0]) ^ ((int )((signed char )*(tk + 2UL)) ^ (int )((signed char )((int )*(tk + 3UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[0] ^ ((int )*(tk + 2UL) ^ ((int )*(tk + 3UL) << 8))) >> 8))])));
  PPK[2] = (int )PPK[2] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[1]) ^ ((int )((signed char )*(tk + 4UL)) ^ (int )((signed char )((int )*(tk + 5UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[1] ^ ((int )*(tk + 4UL) ^ ((int )*(tk + 5UL) << 8))) >> 8))])));
  PPK[3] = (int )PPK[3] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[2]) ^ ((int )((signed char )*(tk + 6UL)) ^ (int )((signed char )((int )*(tk + 7UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[2] ^ ((int )*(tk + 6UL) ^ ((int )*(tk + 7UL) << 8))) >> 8))])));
  PPK[4] = (int )PPK[4] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[3]) ^ ((int )((signed char )*(tk + 8UL)) ^ (int )((signed char )((int )*(tk + 9UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[3] ^ ((int )*(tk + 8UL) ^ ((int )*(tk + 9UL) << 8))) >> 8))])));
  PPK[5] = (int )PPK[5] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[4]) ^ ((int )((signed char )*(tk + 10UL)) ^ (int )((signed char )((int )*(tk + 11UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[4] ^ ((int )*(tk + 10UL) ^ ((int )*(tk + 11UL) << 8))) >> 8))])));
  PPK[0] = (int )PPK[0] + (int )((u16 )(((int )((short )(((int )PPK[5] ^ ((int )*(tk + 12UL) ^ ((int )*(tk + 13UL) << 8))) >> 1)) & 32767) ^ (int )((short )(((int )PPK[5] ^ ((int )*(tk + 12UL) ^ ((int )*(tk + 13UL) << 8))) << 15))));
  PPK[1] = (int )PPK[1] + (int )((u16 )(((int )((short )(((int )PPK[0] ^ ((int )*(tk + 14UL) ^ ((int )*(tk + 15UL) << 8))) >> 1)) & 32767) ^ (int )((short )(((int )PPK[0] ^ ((int )*(tk + 14UL) ^ ((int )*(tk + 15UL) << 8))) << 15))));
  PPK[2] = (int )PPK[2] + (int )((u16 )((int )((short )((int )PPK[1] >> 1)) ^ (int )((short )((int )PPK[1] << 15))));
  PPK[3] = (int )PPK[3] + (int )((u16 )((int )((short )((int )PPK[2] >> 1)) ^ (int )((short )((int )PPK[2] << 15))));
  PPK[4] = (int )PPK[4] + (int )((u16 )((int )((short )((int )PPK[3] >> 1)) ^ (int )((short )((int )PPK[3] << 15))));
  PPK[5] = (int )PPK[5] + (int )((u16 )((int )((short )((int )PPK[4] >> 1)) ^ (int )((short )((int )PPK[4] << 15))));
  *rc4key = (unsigned char )((int )iv16 >> 8);
  *(rc4key + 1UL) = ((unsigned int )((u8 )((int )iv16 >> 8)) & 95U) | 32U;
  *(rc4key + 2UL) = (unsigned char )iv16;
  *(rc4key + 3UL) = (unsigned char )(((int )PPK[5] ^ ((int )*tk ^ ((int )*(tk + 1UL) << 8))) >> 1);
  i = 0;
  goto ldv_53357;
  ldv_53356: 
  *(rc4key + (unsigned long )((i + 2) * 2)) = (unsigned char )PPK[i];
  *(rc4key + (unsigned long )(i * 2 + 5)) = (unsigned char )((int )PPK[i] >> 8);
  i = i + 1;
  ldv_53357: ;
  if (i <= 5) {
    goto ldv_53356;
  } else {

  }

  return;
}
}
int rtw_tkip_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u16 pnl ;
  u32 pnh ;
  u8 rc4key[16U] ;
  u8 ttkey[16U] ;
  u8 crc[4U] ;
  u8 hw_hdr_offset ;
  struct arc4context mycontext ;
  int curfragnum ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 *prwskey ;
  union pn48 dot11txpn ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  bool tmp ;

  {
  hw_hdr_offset = 0U;
  pattrib = & pxmitframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv = & padapter->xmitpriv;
  res = 1;
  if (pattrib->encrypt != 1027074U) {
    return (0);
  } else {

  }
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
    return (0);
  } else {

  }
  hw_hdr_offset = 40U;
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    stainfo = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo()\n", "rtw_tkip_encrypt23a");
    } else {

    }
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4096, 4, "%s: stainfo == NULL!!!\n", "rtw_tkip_encrypt23a");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_tkip_encrypt23a");
    } else {

    }
    return (0);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(4096, 4, "%s: stainfo!= NULL!!!\n", "rtw_tkip_encrypt23a");
  } else {

  }
  if ((stainfo->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_tkip_encrypt23a",
             stainfo->state);
    } else {

    }
    return (0);
  } else {

  }
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  if ((int )tmp) {
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey);
  } else {
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
  prwskeylen = 16U;
  curfragnum = 0;
  goto ldv_53385;
  ldv_53384: 
  iv = pframe + (unsigned long )pattrib->hdrlen;
  payload = pframe + ((unsigned long )pattrib->iv_len + (unsigned long )pattrib->hdrlen);
  dot11txpn._byte_.TSC0 = *(iv + 2UL);
  dot11txpn._byte_.TSC1 = *iv;
  dot11txpn._byte_.TSC2 = *(iv + 4UL);
  dot11txpn._byte_.TSC3 = *(iv + 5UL);
  dot11txpn._byte_.TSC4 = *(iv + 6UL);
  dot11txpn._byte_.TSC5 = *(iv + 7UL);
  pnl = (unsigned short )dot11txpn.val;
  pnh = (unsigned int )(dot11txpn.val >> 16);
  phase1((u16 *)(& ttkey), (u8 const   *)prwskey, (u8 const   *)(& pattrib->ta), pnh);
  phase2((u8 *)(& rc4key), (u8 const   *)prwskey, (u16 const   *)(& ttkey), (int )pnl);
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(4096, 7, "pattrib->iv_len =%x, pattrib->icv_len =%x\n", (int )pattrib->iv_len,
               (int )pattrib->icv_len);
    } else {

    }
    *((u32 *)(& crc)) = getcrc32(payload, length);
    arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
  } else {
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
    *((u32 *)(& crc)) = getcrc32(payload, length);
    arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
  curfragnum = curfragnum + 1;
  ldv_53385: ;
  if ((int )pattrib->nr_frags > curfragnum) {
    goto ldv_53384;
  } else {

  }

  return (res);
}
}
int rtw_tkip_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  u16 pnl ;
  u32 pnh ;
  u8 rc4key[16U] ;
  u8 ttkey[16U] ;
  u32 actual_crc ;
  u32 expected_crc ;
  struct arc4context mycontext ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 *prwskey ;
  union pn48 dot11txpn ;
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  int res ;
  bool tmp ;

  {
  prxattrib = & precvframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  skb = precvframe->pkt;
  res = 1;
  if (prxattrib->encrypt != 1027074U) {
    return (0);
  } else {

  }
  pframe = skb->data;
  stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& prxattrib->ta));
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4096, 4, "%s: stainfo == NULL!!!\n", "rtw_tkip_decrypt23a");
    } else {

    }
    return (0);
  } else {

  }
  tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
  if ((int )tmp) {
    if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
      res = 0;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s:rx bc/mc packets, but didn\'t install group key!!!!!!!!!!\n",
               "rtw_tkip_decrypt23a");
      } else {

      }
      goto exit;
    } else {

    }
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[(int )prxattrib->key_index].skey);
    prwskeylen = 16U;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4096, 4, "%s: stainfo!= NULL!!!\n", "rtw_tkip_decrypt23a");
    } else {

    }
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
    prwskeylen = 16U;
  }
  iv = pframe + (unsigned long )prxattrib->hdrlen;
  payload = pframe + ((unsigned long )prxattrib->iv_len + (unsigned long )prxattrib->hdrlen);
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
  dot11txpn._byte_.TSC0 = *(iv + 2UL);
  dot11txpn._byte_.TSC1 = *iv;
  dot11txpn._byte_.TSC2 = *(iv + 4UL);
  dot11txpn._byte_.TSC3 = *(iv + 5UL);
  dot11txpn._byte_.TSC4 = *(iv + 6UL);
  dot11txpn._byte_.TSC5 = *(iv + 7UL);
  pnl = (unsigned short )dot11txpn.val;
  pnh = (unsigned int )(dot11txpn.val >> 16);
  phase1((u16 *)(& ttkey), (u8 const   *)prwskey, (u8 const   *)(& prxattrib->ta),
         pnh);
  phase2((u8 *)(& rc4key), (u8 const   *)prwskey, (u16 const   *)(& ttkey), (int )pnl);
  arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
  arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
  actual_crc = getcrc32(payload, length + -4);
  expected_crc = get_unaligned_le32((void const   *)(payload + ((unsigned long )length + 0xfffffffffffffffcUL)));
  if (actual_crc != expected_crc) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4096, 4, "%s:icv CRC mismatch: actual: %08x, expected: %08x\n", "rtw_tkip_decrypt23a",
               actual_crc, expected_crc);
    } else {

    }
    res = 0;
  } else {

  }
  exit: ;
  return (res);
}
}
static u8 sbox_table[256U]  = 
  {      99U,      124U,      119U,      123U, 
        242U,      107U,      111U,      197U, 
        48U,      1U,      103U,      43U, 
        254U,      215U,      171U,      118U, 
        202U,      130U,      201U,      125U, 
        250U,      89U,      71U,      240U, 
        173U,      212U,      162U,      175U, 
        156U,      164U,      114U,      192U, 
        183U,      253U,      147U,      38U, 
        54U,      63U,      247U,      204U, 
        52U,      165U,      229U,      241U, 
        113U,      216U,      49U,      21U, 
        4U,      199U,      35U,      195U, 
        24U,      150U,      5U,      154U, 
        7U,      18U,      128U,      226U, 
        235U,      39U,      178U,      117U, 
        9U,      131U,      44U,      26U, 
        27U,      110U,      90U,      160U, 
        82U,      59U,      214U,      179U, 
        41U,      227U,      47U,      132U, 
        83U,      209U,      0U,      237U, 
        32U,      252U,      177U,      91U, 
        106U,      203U,      190U,      57U, 
        74U,      76U,      88U,      207U, 
        208U,      239U,      170U,      251U, 
        67U,      77U,      51U,      133U, 
        69U,      249U,      2U,      127U, 
        80U,      60U,      159U,      168U, 
        81U,      163U,      64U,      143U, 
        146U,      157U,      56U,      245U, 
        188U,      182U,      218U,      33U, 
        16U,      255U,      243U,      210U, 
        205U,      12U,      19U,      236U, 
        95U,      151U,      68U,      23U, 
        196U,      167U,      126U,      61U, 
        100U,      93U,      25U,      115U, 
        96U,      129U,      79U,      220U, 
        34U,      42U,      144U,      136U, 
        70U,      238U,      184U,      20U, 
        222U,      94U,      11U,      219U, 
        224U,      50U,      58U,      10U, 
        73U,      6U,      36U,      92U, 
        194U,      211U,      172U,      98U, 
        145U,      149U,      228U,      121U, 
        231U,      200U,      55U,      109U, 
        141U,      213U,      78U,      169U, 
        108U,      86U,      244U,      234U, 
        101U,      122U,      174U,      8U, 
        186U,      120U,      37U,      46U, 
        28U,      166U,      180U,      198U, 
        232U,      221U,      116U,      31U, 
        75U,      189U,      139U,      138U, 
        112U,      62U,      181U,      102U, 
        72U,      3U,      246U,      14U, 
        97U,      53U,      87U,      185U, 
        134U,      193U,      29U,      158U, 
        225U,      248U,      152U,      17U, 
        105U,      217U,      142U,      148U, 
        155U,      30U,      135U,      233U, 
        206U,      85U,      40U,      223U, 
        140U,      161U,      137U,      13U, 
        191U,      230U,      66U,      104U, 
        65U,      153U,      45U,      15U, 
        176U,      84U,      187U,      22U};
static void construct_mic_header2(u8 *mic_header2 , u8 *mpdu , int a4_exists , int qc_exists ) ;
static void xor_128(u8 *a , u8 *b , u8 *out ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53425;
  ldv_53424: 
  *(out + (unsigned long )i) = (u8 )((int )*(a + (unsigned long )i) ^ (int )*(b + (unsigned long )i));
  i = i + 1;
  ldv_53425: ;
  if (i <= 15) {
    goto ldv_53424;
  } else {

  }

  return;
}
}
static void xor_32(u8 *a , u8 *b , u8 *out ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53434;
  ldv_53433: 
  *(out + (unsigned long )i) = (u8 )((int )*(a + (unsigned long )i) ^ (int )*(b + (unsigned long )i));
  i = i + 1;
  ldv_53434: ;
  if (i <= 3) {
    goto ldv_53433;
  } else {

  }

  return;
}
}
static u8 sbox(u8 a ) 
{ 


  {
  return (sbox_table[(int )a]);
}
}
static void next_key(u8 *key , int round ) 
{ 
  u8 rcon___0 ;
  u8 sbox_key[4U] ;
  u8 rcon_table[12U] ;

  {
  rcon_table[0] = 1U;
  rcon_table[1] = 2U;
  rcon_table[2] = 4U;
  rcon_table[3] = 8U;
  rcon_table[4] = 16U;
  rcon_table[5] = 32U;
  rcon_table[6] = 64U;
  rcon_table[7] = 128U;
  rcon_table[8] = 27U;
  rcon_table[9] = 54U;
  rcon_table[10] = 54U;
  rcon_table[11] = 54U;
  sbox_key[0] = sbox((int )*(key + 13UL));
  sbox_key[1] = sbox((int )*(key + 14UL));
  sbox_key[2] = sbox((int )*(key + 15UL));
  sbox_key[3] = sbox((int )*(key + 12UL));
  rcon___0 = rcon_table[round];
  xor_32(key, (u8 *)(& sbox_key), key);
  *key = (u8 )((int )*key ^ (int )rcon___0);
  xor_32(key + 4UL, key, key + 4UL);
  xor_32(key + 8UL, key + 4UL, key + 8UL);
  xor_32(key + 12UL, key + 8UL, key + 12UL);
  return;
}
}
static void byte_sub(u8 *in , u8 *out ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53452;
  ldv_53451: 
  *(out + (unsigned long )i) = sbox((int )*(in + (unsigned long )i));
  i = i + 1;
  ldv_53452: ;
  if (i <= 15) {
    goto ldv_53451;
  } else {

  }

  return;
}
}
static void shift_row(u8 *in , u8 *out ) 
{ 


  {
  *out = *in;
  *(out + 1UL) = *(in + 5UL);
  *(out + 2UL) = *(in + 10UL);
  *(out + 3UL) = *(in + 15UL);
  *(out + 4UL) = *(in + 4UL);
  *(out + 5UL) = *(in + 9UL);
  *(out + 6UL) = *(in + 14UL);
  *(out + 7UL) = *(in + 3UL);
  *(out + 8UL) = *(in + 8UL);
  *(out + 9UL) = *(in + 13UL);
  *(out + 10UL) = *(in + 2UL);
  *(out + 11UL) = *(in + 7UL);
  *(out + 12UL) = *(in + 12UL);
  *(out + 13UL) = *(in + 1UL);
  *(out + 14UL) = *(in + 6UL);
  *(out + 15UL) = *(in + 11UL);
  return;
}
}
static void mix_column(u8 *in , u8 *out ) 
{ 
  int i ;
  u8 add1b[4U] ;
  u8 add1bf7[4U] ;
  u8 rotl[4U] ;
  u8 swap_halfs[4U] ;
  u8 andf7[4U] ;
  u8 rotr___0[4U] ;
  u8 temp[4U] ;
  u8 tempb[4U] ;

  {
  i = 0;
  goto ldv_53472;
  ldv_53471: ;
  if ((int )((signed char )*(in + (unsigned long )i)) < 0) {
    add1b[i] = 27U;
  } else {
    add1b[i] = 0U;
  }
  i = i + 1;
  ldv_53472: ;
  if (i <= 3) {
    goto ldv_53471;
  } else {

  }
  swap_halfs[0] = *(in + 2UL);
  swap_halfs[1] = *(in + 3UL);
  swap_halfs[2] = *in;
  swap_halfs[3] = *(in + 1UL);
  rotl[0] = *(in + 3UL);
  rotl[1] = *in;
  rotl[2] = *(in + 1UL);
  rotl[3] = *(in + 2UL);
  andf7[0] = (unsigned int )*in & 127U;
  andf7[1] = (unsigned int )*(in + 1UL) & 127U;
  andf7[2] = (unsigned int )*(in + 2UL) & 127U;
  andf7[3] = (unsigned int )*(in + 3UL) & 127U;
  i = 3;
  goto ldv_53475;
  ldv_53474: 
  andf7[i] = (int )andf7[i] << 1U;
  if ((int )((signed char )andf7[i + -1]) < 0) {
    andf7[i] = (u8 )((unsigned int )andf7[i] | 1U);
  } else {

  }
  i = i - 1;
  ldv_53475: ;
  if (i > 0) {
    goto ldv_53474;
  } else {

  }
  andf7[0] = (int )andf7[0] << 1U;
  andf7[0] = (unsigned int )andf7[0] & 254U;
  xor_32((u8 *)(& add1b), (u8 *)(& andf7), (u8 *)(& add1bf7));
  xor_32(in, (u8 *)(& add1bf7), (u8 *)(& rotr___0));
  temp[0] = rotr___0[0];
  rotr___0[0] = rotr___0[1];
  rotr___0[1] = rotr___0[2];
  rotr___0[2] = rotr___0[3];
  rotr___0[3] = temp[0];
  xor_32((u8 *)(& add1bf7), (u8 *)(& rotr___0), (u8 *)(& temp));
  xor_32((u8 *)(& swap_halfs), (u8 *)(& rotl), (u8 *)(& tempb));
  xor_32((u8 *)(& temp), (u8 *)(& tempb), out);
  return;
}
}
static void aes128k128d(u8 *key , u8 *data , u8 *ciphertext ) 
{ 
  int round ;
  int i ;
  u8 intermediatea[16U] ;
  u8 intermediateb[16U] ;
  u8 round_key[16U] ;

  {
  i = 0;
  goto ldv_53488;
  ldv_53487: 
  round_key[i] = *(key + (unsigned long )i);
  i = i + 1;
  ldv_53488: ;
  if (i <= 15) {
    goto ldv_53487;
  } else {

  }
  round = 0;
  goto ldv_53491;
  ldv_53490: ;
  if (round == 0) {
    xor_128((u8 *)(& round_key), data, ciphertext);
    next_key((u8 *)(& round_key), round);
  } else
  if (round == 10) {
    byte_sub(ciphertext, (u8 *)(& intermediatea));
    shift_row((u8 *)(& intermediatea), (u8 *)(& intermediateb));
    xor_128((u8 *)(& intermediateb), (u8 *)(& round_key), ciphertext);
  } else {
    byte_sub(ciphertext, (u8 *)(& intermediatea));
    shift_row((u8 *)(& intermediatea), (u8 *)(& intermediateb));
    mix_column((u8 *)(& intermediateb), (u8 *)(& intermediatea));
    mix_column((u8 *)(& intermediateb) + 4UL, (u8 *)(& intermediatea) + 4UL);
    mix_column((u8 *)(& intermediateb) + 8UL, (u8 *)(& intermediatea) + 8UL);
    mix_column((u8 *)(& intermediateb) + 12UL, (u8 *)(& intermediatea) + 12UL);
    xor_128((u8 *)(& intermediatea), (u8 *)(& round_key), ciphertext);
    next_key((u8 *)(& round_key), round);
  }
  round = round + 1;
  ldv_53491: ;
  if (round <= 10) {
    goto ldv_53490;
  } else {

  }

  return;
}
}
static void construct_mic_iv(u8 *mic_iv , int qc_exists , int a4_exists , u8 *mpdu ,
                             uint payload_length , u8 *pn_vector ) 
{ 
  int i ;

  {
  *mic_iv = 89U;
  if (qc_exists != 0 && a4_exists != 0) {
    *(mic_iv + 1UL) = (unsigned int )*(mpdu + 30UL) & 15U;
  } else {

  }
  if (qc_exists != 0 && a4_exists == 0) {
    *(mic_iv + 1UL) = (unsigned int )*(mpdu + 24UL) & 15U;
  } else {

  }
  if (qc_exists == 0) {
    *(mic_iv + 1UL) = 0U;
  } else {

  }
  i = 2;
  goto ldv_53503;
  ldv_53502: 
  *(mic_iv + (unsigned long )i) = *(mpdu + ((unsigned long )i + 8UL));
  i = i + 1;
  ldv_53503: ;
  if (i <= 7) {
    goto ldv_53502;
  } else {

  }
  i = 8;
  goto ldv_53506;
  ldv_53505: 
  *(mic_iv + (unsigned long )i) = *(pn_vector + (unsigned long )(13 - i));
  i = i + 1;
  ldv_53506: ;
  if (i <= 13) {
    goto ldv_53505;
  } else {

  }
  *(mic_iv + 14UL) = (unsigned char )(payload_length / 256U);
  *(mic_iv + 15UL) = (unsigned char )payload_length;
  return;
}
}
static void construct_mic_header1(u8 *mic_header1 , int header_length , u8 *mpdu ) 
{ 


  {
  *mic_header1 = (unsigned char )((header_length + -2) / 256);
  *(mic_header1 + 1UL) = (unsigned char )((header_length + -2) % 256);
  *(mic_header1 + 2UL) = (unsigned int )*mpdu & 207U;
  *(mic_header1 + 3UL) = (unsigned int )*(mpdu + 1UL) & 199U;
  *(mic_header1 + 4UL) = *(mpdu + 4UL);
  *(mic_header1 + 5UL) = *(mpdu + 5UL);
  *(mic_header1 + 6UL) = *(mpdu + 6UL);
  *(mic_header1 + 7UL) = *(mpdu + 7UL);
  *(mic_header1 + 8UL) = *(mpdu + 8UL);
  *(mic_header1 + 9UL) = *(mpdu + 9UL);
  *(mic_header1 + 10UL) = *(mpdu + 10UL);
  *(mic_header1 + 11UL) = *(mpdu + 11UL);
  *(mic_header1 + 12UL) = *(mpdu + 12UL);
  *(mic_header1 + 13UL) = *(mpdu + 13UL);
  *(mic_header1 + 14UL) = *(mpdu + 14UL);
  *(mic_header1 + 15UL) = *(mpdu + 15UL);
  return;
}
}
static void construct_mic_header2(u8 *mic_header2 , u8 *mpdu , int a4_exists , int qc_exists ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53521;
  ldv_53520: 
  *(mic_header2 + (unsigned long )i) = 0U;
  i = i + 1;
  ldv_53521: ;
  if (i <= 15) {
    goto ldv_53520;
  } else {

  }
  *mic_header2 = *(mpdu + 16UL);
  *(mic_header2 + 1UL) = *(mpdu + 17UL);
  *(mic_header2 + 2UL) = *(mpdu + 18UL);
  *(mic_header2 + 3UL) = *(mpdu + 19UL);
  *(mic_header2 + 4UL) = *(mpdu + 20UL);
  *(mic_header2 + 5UL) = *(mpdu + 21UL);
  *(mic_header2 + 6UL) = 0U;
  *(mic_header2 + 7UL) = 0U;
  if (qc_exists == 0 && a4_exists != 0) {
    i = 0;
    goto ldv_53524;
    ldv_53523: 
    *(mic_header2 + (unsigned long )(i + 8)) = *(mpdu + (unsigned long )(i + 24));
    i = i + 1;
    ldv_53524: ;
    if (i <= 5) {
      goto ldv_53523;
    } else {

    }

  } else {

  }
  if (qc_exists != 0 && a4_exists == 0) {
    *(mic_header2 + 8UL) = (unsigned int )*(mpdu + 24UL) & 15U;
    *(mic_header2 + 9UL) = 0U;
  } else {

  }
  if (qc_exists != 0 && a4_exists != 0) {
    i = 0;
    goto ldv_53527;
    ldv_53526: 
    *(mic_header2 + (unsigned long )(i + 8)) = *(mpdu + (unsigned long )(i + 24));
    i = i + 1;
    ldv_53527: ;
    if (i <= 5) {
      goto ldv_53526;
    } else {

    }
    *(mic_header2 + 14UL) = (unsigned int )*(mpdu + 30UL) & 15U;
    *(mic_header2 + 15UL) = 0U;
  } else {

  }
  return;
}
}
static void construct_ctr_preload(u8 *ctr_preload , int a4_exists , int qc_exists ,
                                  u8 *mpdu , u8 *pn_vector , int c ) 
{ 
  int i ;

  {
  i = 0;
  i = 0;
  goto ldv_53539;
  ldv_53538: 
  *(ctr_preload + (unsigned long )i) = 0U;
  i = i + 1;
  ldv_53539: ;
  if (i <= 15) {
    goto ldv_53538;
  } else {

  }
  i = 0;
  *ctr_preload = 1U;
  if (qc_exists != 0 && a4_exists != 0) {
    *(ctr_preload + 1UL) = (unsigned int )*(mpdu + 30UL) & 15U;
  } else {

  }
  if (qc_exists != 0 && a4_exists == 0) {
    *(ctr_preload + 1UL) = (unsigned int )*(mpdu + 24UL) & 15U;
  } else {

  }
  i = 2;
  goto ldv_53542;
  ldv_53541: 
  *(ctr_preload + (unsigned long )i) = *(mpdu + ((unsigned long )i + 8UL));
  i = i + 1;
  ldv_53542: ;
  if (i <= 7) {
    goto ldv_53541;
  } else {

  }
  i = 8;
  goto ldv_53545;
  ldv_53544: 
  *(ctr_preload + (unsigned long )i) = *(pn_vector + (unsigned long )(13 - i));
  i = i + 1;
  ldv_53545: ;
  if (i <= 13) {
    goto ldv_53544;
  } else {

  }
  *(ctr_preload + 14UL) = (unsigned char )(c / 256);
  *(ctr_preload + 15UL) = (unsigned char )(c % 256);
  return;
}
}
static void bitwise_xor(u8 *ina , u8 *inb___0 , u8 *out ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53554;
  ldv_53553: 
  *(out + (unsigned long )i) = (u8 )((int )*(ina + (unsigned long )i) ^ (int )*(inb___0 + (unsigned long )i));
  i = i + 1;
  ldv_53554: ;
  if (i <= 15) {
    goto ldv_53553;
  } else {

  }

  return;
}
}
static int aes_cipher(u8 *key , uint hdrlen , u8 *pframe , uint plen ) 
{ 
  uint qc_exists ;
  uint a4_exists ;
  uint i ;
  uint j ;
  uint payload_remainder ;
  uint num_blocks ;
  uint payload_index ;
  u8 pn_vector[6U] ;
  u8 mic_iv[16U] ;
  u8 mic_header1[16U] ;
  u8 mic_header2[16U] ;
  u8 ctr_preload[16U] ;
  u8 chain_buffer[16U] ;
  u8 aes_out[16U] ;
  u8 padded_buffer[16U] ;
  u8 mic[8U] ;
  struct ieee80211_hdr *hdr ;
  u16 frsubtype ;
  int tmp ;
  uint tmp___0 ;
  uint tmp___1 ;
  uint tmp___2 ;
  uint tmp___3 ;

  {
  hdr = (struct ieee80211_hdr *)pframe;
  frsubtype = (unsigned int )hdr->frame_control & 240U;
  memset((void *)(& mic_iv), 0, 16UL);
  memset((void *)(& mic_header1), 0, 16UL);
  memset((void *)(& mic_header2), 0, 16UL);
  memset((void *)(& ctr_preload), 0, 16UL);
  memset((void *)(& chain_buffer), 0, 16UL);
  memset((void *)(& aes_out), 0, 16UL);
  memset((void *)(& padded_buffer), 0, 16UL);
  if (hdrlen == 24U || hdrlen == 26U) {
    a4_exists = 0U;
  } else {
    a4_exists = 1U;
  }
  tmp = ieee80211_is_data((int )hdr->frame_control);
  if (tmp != 0) {
    if (((unsigned int )frsubtype == 16U || (unsigned int )frsubtype == 32U) || (unsigned int )frsubtype == 48U) {
      qc_exists = 1U;
      if (hdrlen != 26U) {
        hdrlen = hdrlen + 2U;
      } else {

      }
    } else
    if ((((unsigned int )frsubtype == 128U || (unsigned int )frsubtype == 144U) || (unsigned int )frsubtype == 160U) || (unsigned int )frsubtype == 176U) {
      if (hdrlen != 26U) {
        hdrlen = hdrlen + 2U;
      } else {

      }
      qc_exists = 1U;
    } else {
      qc_exists = 0U;
    }
  } else {
    qc_exists = 0U;
  }
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
  construct_mic_iv((u8 *)(& mic_iv), (int )qc_exists, (int )a4_exists, pframe, plen,
                   (u8 *)(& pn_vector));
  construct_mic_header1((u8 *)(& mic_header1), (int )hdrlen, pframe);
  construct_mic_header2((u8 *)(& mic_header2), pframe, (int )a4_exists, (int )qc_exists);
  payload_remainder = plen & 15U;
  num_blocks = plen / 16U;
  payload_index = hdrlen + 8U;
  aes128k128d(key, (u8 *)(& mic_iv), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header1), (u8 *)(& chain_buffer));
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header2), (u8 *)(& chain_buffer));
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  i = 0U;
  goto ldv_53581;
  ldv_53580: 
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
  payload_index = payload_index + 16U;
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  i = i + 1U;
  ldv_53581: ;
  if (i < num_blocks) {
    goto ldv_53580;
  } else {

  }

  if (payload_remainder != 0U) {
    j = 0U;
    goto ldv_53584;
    ldv_53583: 
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_53584: ;
    if (j <= 15U) {
      goto ldv_53583;
    } else {

    }
    j = 0U;
    goto ldv_53587;
    ldv_53586: 
    tmp___0 = payload_index;
    payload_index = payload_index + 1U;
    padded_buffer[j] = *(pframe + (unsigned long )tmp___0);
    j = j + 1U;
    ldv_53587: ;
    if (j < payload_remainder) {
      goto ldv_53586;
    } else {

    }
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  } else {

  }
  j = 0U;
  goto ldv_53590;
  ldv_53589: 
  mic[j] = aes_out[j];
  j = j + 1U;
  ldv_53590: ;
  if (j <= 7U) {
    goto ldv_53589;
  } else {

  }
  j = 0U;
  goto ldv_53593;
  ldv_53592: 
  *(pframe + (unsigned long )(payload_index + j)) = mic[j];
  j = j + 1U;
  ldv_53593: ;
  if (j <= 7U) {
    goto ldv_53592;
  } else {

  }
  payload_index = hdrlen + 8U;
  i = 0U;
  goto ldv_53599;
  ldv_53598: 
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), (int )(i + 1U));
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_53596;
  ldv_53595: 
  tmp___1 = payload_index;
  payload_index = payload_index + 1U;
  *(pframe + (unsigned long )tmp___1) = chain_buffer[j];
  j = j + 1U;
  ldv_53596: ;
  if (j <= 15U) {
    goto ldv_53595;
  } else {

  }
  i = i + 1U;
  ldv_53599: ;
  if (i < num_blocks) {
    goto ldv_53598;
  } else {

  }

  if (payload_remainder != 0U) {
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          pframe, (u8 *)(& pn_vector), (int )(num_blocks + 1U));
    j = 0U;
    goto ldv_53602;
    ldv_53601: 
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_53602: ;
    if (j <= 15U) {
      goto ldv_53601;
    } else {

    }
    j = 0U;
    goto ldv_53605;
    ldv_53604: 
    padded_buffer[j] = *(pframe + (unsigned long )(payload_index + j));
    j = j + 1U;
    ldv_53605: ;
    if (j < payload_remainder) {
      goto ldv_53604;
    } else {

    }
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    j = 0U;
    goto ldv_53608;
    ldv_53607: 
    tmp___2 = payload_index;
    payload_index = payload_index + 1U;
    *(pframe + (unsigned long )tmp___2) = chain_buffer[j];
    j = j + 1U;
    ldv_53608: ;
    if (j < payload_remainder) {
      goto ldv_53607;
    } else {

    }

  } else {

  }
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), 0);
  j = 0U;
  goto ldv_53611;
  ldv_53610: 
  padded_buffer[j] = 0U;
  j = j + 1U;
  ldv_53611: ;
  if (j <= 15U) {
    goto ldv_53610;
  } else {

  }
  j = 0U;
  goto ldv_53614;
  ldv_53613: 
  padded_buffer[j] = *(pframe + (unsigned long )(((j + hdrlen) + plen) + 8U));
  j = j + 1U;
  ldv_53614: ;
  if (j <= 7U) {
    goto ldv_53613;
  } else {

  }
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_53617;
  ldv_53616: 
  tmp___3 = payload_index;
  payload_index = payload_index + 1U;
  *(pframe + (unsigned long )tmp___3) = chain_buffer[j];
  j = j + 1U;
  ldv_53617: ;
  if (j <= 7U) {
    goto ldv_53616;
  } else {

  }

  return (1);
}
}
int rtw_aes_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int curfragnum ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *prwskey ;
  u8 hw_hdr_offset ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  bool tmp ;

  {
  hw_hdr_offset = 0U;
  pattrib = & pxmitframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv = & padapter->xmitpriv;
  res = 1;
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
    return (0);
  } else {

  }
  hw_hdr_offset = 40U;
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
  if (pattrib->encrypt != 1027076U) {
    return (0);
  } else {

  }
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    stainfo = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_aes_encrypt23a");
    } else {

    }
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4096, 4, "%s: stainfo == NULL!!!\n", "rtw_aes_encrypt23a");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_aes_encrypt23a");
    } else {

    }
    res = 0;
    goto out;
  } else {

  }
  if ((stainfo->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_aes_encrypt23a",
             stainfo->state);
    } else {

    }
    return (0);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(4096, 4, "%s: stainfo!= NULL!!!\n", "rtw_aes_encrypt23a");
  } else {

  }
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  if ((int )tmp) {
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey);
  } else {
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
  prwskeylen = 16U;
  curfragnum = 0;
  goto ldv_53637;
  ldv_53636: ;
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
    aes_cipher(prwskey, (uint )pattrib->hdrlen, pframe, (uint )length);
  } else {
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
    aes_cipher(prwskey, (uint )pattrib->hdrlen, pframe, (uint )length);
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
  curfragnum = curfragnum + 1;
  ldv_53637: ;
  if ((int )pattrib->nr_frags > curfragnum) {
    goto ldv_53636;
  } else {

  }

  out: ;
  return (res);
}
}
static int aes_decipher(u8 *key , uint hdrlen , u8 *pframe , uint plen ) 
{ 
  u8 message[2048U] ;
  uint qc_exists ;
  uint a4_exists ;
  uint i ;
  uint j ;
  uint payload_remainder ;
  uint num_blocks ;
  uint payload_index ;
  int res ;
  u8 pn_vector[6U] ;
  u8 mic_iv[16U] ;
  u8 mic_header1[16U] ;
  u8 mic_header2[16U] ;
  u8 ctr_preload[16U] ;
  u8 chain_buffer[16U] ;
  u8 aes_out[16U] ;
  u8 padded_buffer[16U] ;
  u8 mic[8U] ;
  struct ieee80211_hdr *hdr ;
  u16 frsubtype ;
  int tmp ;
  uint tmp___0 ;
  uint tmp___1 ;
  uint tmp___2 ;
  uint tmp___3 ;
  uint tmp___4 ;
  uint tmp___5 ;

  {
  res = 1;
  hdr = (struct ieee80211_hdr *)pframe;
  frsubtype = (unsigned int )hdr->frame_control & 240U;
  memset((void *)(& mic_iv), 0, 16UL);
  memset((void *)(& mic_header1), 0, 16UL);
  memset((void *)(& mic_header2), 0, 16UL);
  memset((void *)(& ctr_preload), 0, 16UL);
  memset((void *)(& chain_buffer), 0, 16UL);
  memset((void *)(& aes_out), 0, 16UL);
  memset((void *)(& padded_buffer), 0, 16UL);
  num_blocks = (plen - 8U) / 16U;
  payload_remainder = (plen - 8U) & 15U;
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
  if (hdrlen == 24U || hdrlen == 26U) {
    a4_exists = 0U;
  } else {
    a4_exists = 1U;
  }
  tmp = ieee80211_is_data((int )hdr->frame_control);
  if (tmp != 0) {
    if (((unsigned int )frsubtype == 16U || (unsigned int )frsubtype == 32U) || (unsigned int )frsubtype == 48U) {
      qc_exists = 1U;
      if (hdrlen != 24U) {
        hdrlen = hdrlen + 2U;
      } else {

      }
    } else
    if ((((unsigned int )frsubtype == 128U || (unsigned int )frsubtype == 144U) || (unsigned int )frsubtype == 160U) || (unsigned int )frsubtype == 176U) {
      if (hdrlen != 24U) {
        hdrlen = hdrlen + 2U;
      } else {

      }
      qc_exists = 1U;
    } else {
      qc_exists = 0U;
    }
  } else {
    qc_exists = 0U;
  }
  payload_index = hdrlen + 8U;
  i = 0U;
  goto ldv_53669;
  ldv_53668: 
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), (int )(i + 1U));
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_53666;
  ldv_53665: 
  tmp___0 = payload_index;
  payload_index = payload_index + 1U;
  *(pframe + (unsigned long )tmp___0) = chain_buffer[j];
  j = j + 1U;
  ldv_53666: ;
  if (j <= 15U) {
    goto ldv_53665;
  } else {

  }
  i = i + 1U;
  ldv_53669: ;
  if (i < num_blocks) {
    goto ldv_53668;
  } else {

  }

  if (payload_remainder != 0U) {
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          pframe, (u8 *)(& pn_vector), (int )(num_blocks + 1U));
    j = 0U;
    goto ldv_53672;
    ldv_53671: 
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_53672: ;
    if (j <= 15U) {
      goto ldv_53671;
    } else {

    }
    j = 0U;
    goto ldv_53675;
    ldv_53674: 
    padded_buffer[j] = *(pframe + (unsigned long )(payload_index + j));
    j = j + 1U;
    ldv_53675: ;
    if (j < payload_remainder) {
      goto ldv_53674;
    } else {

    }
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    j = 0U;
    goto ldv_53678;
    ldv_53677: 
    tmp___1 = payload_index;
    payload_index = payload_index + 1U;
    *(pframe + (unsigned long )tmp___1) = chain_buffer[j];
    j = j + 1U;
    ldv_53678: ;
    if (j < payload_remainder) {
      goto ldv_53677;
    } else {

    }

  } else {

  }
  if ((hdrlen + plen) + 8U <= 2048U) {
    memcpy((void *)(& message), (void const   *)pframe, (size_t )((hdrlen + plen) + 8U));
  } else {

  }
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
  construct_mic_iv((u8 *)(& mic_iv), (int )qc_exists, (int )a4_exists, (u8 *)(& message),
                   plen - 8U, (u8 *)(& pn_vector));
  construct_mic_header1((u8 *)(& mic_header1), (int )hdrlen, (u8 *)(& message));
  construct_mic_header2((u8 *)(& mic_header2), (u8 *)(& message), (int )a4_exists,
                        (int )qc_exists);
  payload_remainder = (plen - 8U) & 15U;
  num_blocks = (plen - 8U) / 16U;
  payload_index = hdrlen + 8U;
  aes128k128d(key, (u8 *)(& mic_iv), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header1), (u8 *)(& chain_buffer));
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header2), (u8 *)(& chain_buffer));
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  i = 0U;
  goto ldv_53681;
  ldv_53680: 
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& message) + (unsigned long )payload_index,
              (u8 *)(& chain_buffer));
  payload_index = payload_index + 16U;
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  i = i + 1U;
  ldv_53681: ;
  if (i < num_blocks) {
    goto ldv_53680;
  } else {

  }

  if (payload_remainder != 0U) {
    j = 0U;
    goto ldv_53684;
    ldv_53683: 
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_53684: ;
    if (j <= 15U) {
      goto ldv_53683;
    } else {

    }
    j = 0U;
    goto ldv_53687;
    ldv_53686: 
    tmp___2 = payload_index;
    payload_index = payload_index + 1U;
    padded_buffer[j] = message[tmp___2];
    j = j + 1U;
    ldv_53687: ;
    if (j < payload_remainder) {
      goto ldv_53686;
    } else {

    }
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  } else {

  }
  j = 0U;
  goto ldv_53690;
  ldv_53689: 
  mic[j] = aes_out[j];
  j = j + 1U;
  ldv_53690: ;
  if (j <= 7U) {
    goto ldv_53689;
  } else {

  }
  j = 0U;
  goto ldv_53693;
  ldv_53692: 
  message[payload_index + j] = mic[j];
  j = j + 1U;
  ldv_53693: ;
  if (j <= 7U) {
    goto ldv_53692;
  } else {

  }
  payload_index = hdrlen + 8U;
  i = 0U;
  goto ldv_53699;
  ldv_53698: 
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, (u8 *)(& message),
                        (u8 *)(& pn_vector), (int )(i + 1U));
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& message) + (unsigned long )payload_index,
              (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_53696;
  ldv_53695: 
  tmp___3 = payload_index;
  payload_index = payload_index + 1U;
  message[tmp___3] = chain_buffer[j];
  j = j + 1U;
  ldv_53696: ;
  if (j <= 15U) {
    goto ldv_53695;
  } else {

  }
  i = i + 1U;
  ldv_53699: ;
  if (i < num_blocks) {
    goto ldv_53698;
  } else {

  }

  if (payload_remainder != 0U) {
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          (u8 *)(& message), (u8 *)(& pn_vector), (int )(num_blocks + 1U));
    j = 0U;
    goto ldv_53702;
    ldv_53701: 
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_53702: ;
    if (j <= 15U) {
      goto ldv_53701;
    } else {

    }
    j = 0U;
    goto ldv_53705;
    ldv_53704: 
    padded_buffer[j] = message[payload_index + j];
    j = j + 1U;
    ldv_53705: ;
    if (j < payload_remainder) {
      goto ldv_53704;
    } else {

    }
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    j = 0U;
    goto ldv_53708;
    ldv_53707: 
    tmp___4 = payload_index;
    payload_index = payload_index + 1U;
    message[tmp___4] = chain_buffer[j];
    j = j + 1U;
    ldv_53708: ;
    if (j < payload_remainder) {
      goto ldv_53707;
    } else {

    }

  } else {

  }
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, (u8 *)(& message),
                        (u8 *)(& pn_vector), 0);
  j = 0U;
  goto ldv_53711;
  ldv_53710: 
  padded_buffer[j] = 0U;
  j = j + 1U;
  ldv_53711: ;
  if (j <= 15U) {
    goto ldv_53710;
  } else {

  }
  j = 0U;
  goto ldv_53714;
  ldv_53713: 
  padded_buffer[j] = message[(j + hdrlen) + plen];
  j = j + 1U;
  ldv_53714: ;
  if (j <= 7U) {
    goto ldv_53713;
  } else {

  }
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_53717;
  ldv_53716: 
  tmp___5 = payload_index;
  payload_index = payload_index + 1U;
  message[tmp___5] = chain_buffer[j];
  j = j + 1U;
  ldv_53717: ;
  if (j <= 7U) {
    goto ldv_53716;
  } else {

  }
  i = 0U;
  goto ldv_53721;
  ldv_53720: ;
  if ((int )*(pframe + (unsigned long )((hdrlen + plen) + i)) != (int )message[(hdrlen + plen) + i]) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4096, 4, "%s:mic check error mic[%d]: pframe(%x) != message(%x)\n",
               "aes_decipher", i, (int )*(pframe + (unsigned long )((hdrlen + plen) + i)),
               (int )message[(hdrlen + plen) + i]);
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s:mic check error mic[%d]: pframe(%x) != message(%x)\n",
             "aes_decipher", i, (int )*(pframe + (unsigned long )((hdrlen + plen) + i)),
             (int )message[(hdrlen + plen) + i]);
    } else {

    }
    res = 0;
  } else {

  }
  i = i + 1U;
  ldv_53721: ;
  if (i <= 7U) {
    goto ldv_53720;
  } else {

  }

  return (res);
}
}
int rtw_aes_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  int length ;
  u8 *pframe ;
  u8 *prwskey ;
  int res ;
  bool tmp ;

  {
  prxattrib = & precvframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  skb = precvframe->pkt;
  res = 1;
  pframe = skb->data;
  if (prxattrib->encrypt != 1027076U) {
    return (0);
  } else {

  }
  stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& prxattrib->ta));
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4096, 4, "%s: stainfo == NULL!!!\n", "rtw_aes_decrypt23a");
    } else {

    }
    res = 0;
    goto exit;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(4096, 4, "%s: stainfo!= NULL!!!\n", "rtw_aes_decrypt23a");
  } else {

  }
  tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
  if ((int )tmp) {
    if ((unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
      res = 0;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s:rx bc/mc packets, but didn\'t install group key!!!!!!!!!!\n",
               "rtw_aes_decrypt23a");
      } else {

      }
      goto exit;
    } else {

    }
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[(int )prxattrib->key_index].skey);
    if (psecuritypriv->dot118021XGrpKeyid != (u32 )prxattrib->key_index) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: not match packet_index =%d, install_index =%d\n", (int )prxattrib->key_index,
               psecuritypriv->dot118021XGrpKeyid);
      } else {

      }
      res = 0;
      goto exit;
    } else {

    }
  } else {
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
  res = aes_decipher(prwskey, (uint )prxattrib->hdrlen, pframe, (uint )length);
  exit: ;
  return (res);
}
}
void rtw_use_tkipkey_handler23a(void *FunctionContext ) 
{ 
  struct rtw_adapter *padapter ;

  {
  padapter = (struct rtw_adapter *)FunctionContext;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(4096, 4, "^^^%s ^^^\n", "rtw_use_tkipkey_handler23a");
  } else {

  }
  padapter->securitypriv.busetkipkey = 1U;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(4096, 4, "^^^%s padapter->securitypriv.busetkipkey =%d^^^\n", "rtw_use_tkipkey_handler23a",
             (int )padapter->securitypriv.busetkipkey);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_193(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_194(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_196(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
  return ((int )((signed char )c) != 0);
}
}
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
int ldv_mod_timer_212(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
bool ldv_queue_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_208(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_210(struct workqueue_struct *ldv_func_arg1 ) ;
extern void __tasklet_hi_schedule(struct tasklet_struct * ) ;
__inline static void tasklet_hi_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
  if (tmp == 0) {
    __tasklet_hi_schedule(t);
  } else {

  }
  return;
}
}
extern void tasklet_kill(struct tasklet_struct * ) ;
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
extern void netif_tx_wake_queue(struct netdev_queue * ) ;
__inline static void netif_tx_wake_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
  i = 0U;
  goto ldv_42827;
  ldv_42826: 
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
  txq = tmp;
  netif_tx_wake_queue(txq);
  i = i + 1U;
  ldv_42827: ;
  if (dev->num_tx_queues > i) {
    goto ldv_42826;
  } else {

  }

  return;
}
}
extern void netif_tx_stop_all_queues(struct net_device * ) ;
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
  return (tmp != 0);
}
}
__inline static int rtw_netif_queue_stopped(struct net_device *pnetdev ) 
{ 
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  struct netdev_queue *tmp___1 ;
  bool tmp___2 ;
  struct netdev_queue *tmp___3 ;
  bool tmp___4 ;
  struct netdev_queue *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;

  {
  tmp = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 0U);
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp);
  if ((int )tmp___0) {
    tmp___1 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 1U);
    tmp___2 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___1);
    if ((int )tmp___2) {
      tmp___3 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 2U);
      tmp___4 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___3);
      if ((int )tmp___4) {
        tmp___5 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 3U);
        tmp___6 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___5);
        if ((int )tmp___6) {
          tmp___7 = 1;
        } else {
          tmp___7 = 0;
        }
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
  } else {
    tmp___7 = 0;
  }
  return (tmp___7);
}
}
void rtw_cancel_all_timer23a(struct rtw_adapter *padapter ) ;
void rtw_ap_restore_network(struct rtw_adapter *padapter ) ;
void rtw_sreset_init(struct rtw_adapter *padapter ) ;
void rtw_sreset_reset_value(struct rtw_adapter *padapter ) ;
void rtw_sreset_init(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  struct lock_class_key __key ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  __mutex_init(& psrtpriv->silentreset_mutex, "&psrtpriv->silentreset_mutex", & __key);
  psrtpriv->silent_reset_inprogress = 0U;
  psrtpriv->last_tx_time = 0UL;
  psrtpriv->last_tx_complete_time = 0UL;
  return;
}
}
void rtw_sreset_reset_value(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  psrtpriv->silent_reset_inprogress = 0U;
  psrtpriv->last_tx_time = 0UL;
  psrtpriv->last_tx_complete_time = 0UL;
  return;
}
}
bool rtw_sreset_inprogress(struct rtw_adapter *padapter ) 
{ 
  struct rtw_adapter *primary_adapter ;
  struct hal_data_8723a *pHalData ;

  {
  primary_adapter = (padapter->dvobj)->if1;
  pHalData = (struct hal_data_8723a *)primary_adapter->HalData;
  return ((unsigned int )pHalData->srestpriv.silent_reset_inprogress != 0U);
}
}
static void sreset_restore_security_station(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 val8 ;
  u8 *tmp ;

  {
  mlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  pmlmeinfo = & padapter->mlmeextpriv.mlmext_info;
  if (pmlmeinfo->auth_algo == 2U) {
    val8 = 204U;
  } else {
    val8 = 207U;
  }
  rtl8723a_set_sec_cfg(padapter, (int )val8);
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
    tmp = get_bssid(mlmepriv);
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)tmp);
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {

    } else {
      rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
      rtw_set_key23a(padapter, & padapter->securitypriv, (int )padapter->securitypriv.dot118021XGrpKeyid,
                     0);
    }
  } else {

  }
  return;
}
}
static void sreset_restore_network_station(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 threshold ;

  {
  mlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  rtw_setopmode_cmd23a(padapter, 2);
  if ((int )mlmepriv->htpriv.ht_option) {
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
      threshold = 1U;
    } else {
      threshold = 0U;
    }
  } else {
    threshold = 1U;
  }
  rtl8723a_set_rxdma_agg_pg_th(padapter, (int )threshold);
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  hw_var_set_bssid(padapter, (u8 *)(& pmlmeinfo->network.MacAddress));
  hw_var_set_mlme_join(padapter, 0);
  rtl8723a_set_media_status(padapter, (int )((u8 )pmlmeinfo->state) & 3);
  mlmeext_joinbss_event_callback23a(padapter, 1);
  rtl8723au_write8(padapter, 1244, (int )padapter->xmitpriv.nqos_ssn);
  sreset_restore_security_station(padapter);
  return;
}
}
static void sreset_restore_network_status(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
  mlmepriv = & padapter->mlmepriv;
  tmp___5 = check_fwstate(mlmepriv, 8);
  if ((int )tmp___5) {
    if (GlobalDebugLevel23A > 3U) {
      tmp = get_fwstate(mlmepriv);
      printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_STATION_STATE\n", "sreset_restore_network_status",
             (char *)(& (padapter->pnetdev)->name), tmp);
    } else {

    }
    sreset_restore_network_station(padapter);
  } else {
    tmp___4 = check_fwstate(mlmepriv, 16);
    if ((int )tmp___4) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___0 = get_fwstate(mlmepriv);
        printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_AP_STATE\n", "sreset_restore_network_status",
               (char *)(& (padapter->pnetdev)->name), tmp___0);
      } else {

      }
      rtw_ap_restore_network(padapter);
    } else {
      tmp___3 = check_fwstate(mlmepriv, 32);
      if ((int )tmp___3) {
        if (GlobalDebugLevel23A > 3U) {
          tmp___1 = get_fwstate(mlmepriv);
          printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_ADHOC_STATE\n", "sreset_restore_network_status",
                 (char *)(& (padapter->pnetdev)->name), tmp___1);
        } else {

        }
      } else
      if (GlobalDebugLevel23A > 3U) {
        tmp___2 = get_fwstate(mlmepriv);
        printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - ???\n", "sreset_restore_network_status",
               (char *)(& (padapter->pnetdev)->name), tmp___2);
      } else {

      }
    }
  }
  return;
}
}
static void sreset_stop_adapter(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pxmitpriv = & padapter->xmitpriv;
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "sreset_stop_adapter", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
  tmp = rtw_netif_queue_stopped(padapter->pnetdev);
  if (tmp == 0) {
    netif_tx_stop_all_queues(padapter->pnetdev);
  } else {

  }
  rtw_cancel_all_timer23a(padapter);
  tasklet_kill(& pxmitpriv->xmit_tasklet);
  tmp___0 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___0) {
    rtw_scan_abort23a(padapter);
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 128);
  if ((int )tmp___1) {
    rtw23a_join_to_handler((unsigned long )padapter);
  } else {

  }
  return;
}
}
static void sreset_start_adapter(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmitpriv ;
  bool tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pxmitpriv = & padapter->xmitpriv;
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "sreset_start_adapter", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    sreset_restore_network_status(padapter);
  } else {

  }
  tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  tmp___0 = msecs_to_jiffies(2000U);
  ldv_mod_timer_212(& padapter->mlmepriv.dynamic_chk_timer, tmp___0 + (unsigned long )jiffies);
  tmp___1 = rtw_netif_queue_stopped(padapter->pnetdev);
  if (tmp___1 != 0) {
    netif_tx_wake_all_queues(padapter->pnetdev);
  } else {

  }
  return;
}
}
void rtw_sreset_reset(struct rtw_adapter *active_adapter ) 
{ 
  struct rtw_adapter *padapter ;
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  struct pwrctrl_priv *pwrpriv ;
  unsigned long start ;
  unsigned int tmp ;

  {
  padapter = (active_adapter->dvobj)->if1;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  pwrpriv = & padapter->pwrctrlpriv;
  start = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_sreset_reset");
  } else {

  }
  mutex_lock_nested(& psrtpriv->silentreset_mutex, 0U);
  psrtpriv->silent_reset_inprogress = 1U;
  pwrpriv->change_rfpwrstate = 2;
  sreset_stop_adapter(padapter);
  ips_enter23a(padapter);
  ips_leave23a(padapter);
  sreset_start_adapter(padapter);
  psrtpriv->silent_reset_inprogress = 0U;
  mutex_unlock(& psrtpriv->silentreset_mutex);
  if (GlobalDebugLevel23A > 3U) {
    tmp = jiffies_to_msecs((unsigned long )jiffies - start);
    printk("\016RTL8723AU: %s done in %d ms\n", "rtw_sreset_reset", tmp);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_207(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_208(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_209(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_210(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_211(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_212(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_del_timer_sync_228(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_229(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_230(struct timer_list *ldv_func_arg1 ) ;
bool ldv_queue_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_225(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_224(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_227(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_226(struct workqueue_struct *ldv_func_arg1 ) ;
void rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv , struct rtw_queue *pframequeue ) ;
void _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv ) ;
__inline static u32 wifi_mac_hash(u8 const   *mac ) 
{ 
  u32 x ;

  {
  x = (u32 )*mac;
  x = (x << 2) ^ (u32 )*(mac + 1UL);
  x = (x << 2) ^ (u32 )*(mac + 2UL);
  x = (x << 2) ^ (u32 )*(mac + 3UL);
  x = (x << 2) ^ (u32 )*(mac + 4UL);
  x = (x << 2) ^ (u32 )*(mac + 5UL);
  x = (x >> 8) ^ x;
  x = x & 31U;
  return (x);
}
}
int _rtw_init_sta_priv23a(struct sta_priv *pstapriv ) ;
int _rtw_free_sta_priv23a(struct sta_priv *pstapriv ) ;
void rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl ) ;
static u8 const   bc_addr[6U]  = {      255U,      255U,      255U,      255U, 
        255U,      255U};
static void _rtw_init_stainfo(struct sta_info *psta ) 
{ 
  struct lock_class_key __key ;

  {
  memset((void *)psta, 0, 5656UL);
  spinlock_check(& psta->lock);
  __raw_spin_lock_init(& psta->lock.__annonCompField18.rlock, "&(&psta->lock)->rlock",
                       & __key);
  INIT_LIST_HEAD(& psta->list);
  INIT_LIST_HEAD(& psta->hash_list);
  _rtw_init_queue23a(& psta->sleep_q);
  psta->sleepq_len = 0U;
  _rtw_init_sta_xmit_priv23a(& psta->sta_xmitpriv);
  _rtw_init_sta_recv_priv23a(& psta->sta_recvpriv);
  INIT_LIST_HEAD(& psta->asoc_list);
  INIT_LIST_HEAD(& psta->auth_list);
  psta->expire_to = 0U;
  psta->flags = 0;
  psta->capability = 0U;
  psta->bpairwise_key_installed = 0U;
  psta->nonerp_set = 0U;
  psta->no_short_slot_time_set = 0U;
  psta->no_short_preamble_set = 0U;
  psta->no_ht_gf_set = 0U;
  psta->no_ht_set = 0U;
  psta->ht_20mhz_set = 0U;
  psta->keep_alive_trycnt = 0U;
  return;
}
}
int _rtw_init_sta_priv23a(struct sta_priv *pstapriv ) 
{ 
  int i ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
  spinlock_check(& pstapriv->sta_hash_lock);
  __raw_spin_lock_init(& pstapriv->sta_hash_lock.__annonCompField18.rlock, "&(&pstapriv->sta_hash_lock)->rlock",
                       & __key);
  pstapriv->asoc_sta_count = 0;
  i = 0;
  goto ldv_55749;
  ldv_55748: 
  INIT_LIST_HEAD((struct list_head *)(& pstapriv->sta_hash) + (unsigned long )i);
  i = i + 1;
  ldv_55749: ;
  if (i <= 31) {
    goto ldv_55748;
  } else {

  }
  pstapriv->sta_dz_bitmap = 0U;
  pstapriv->tim_bitmap = 0U;
  INIT_LIST_HEAD(& pstapriv->asoc_list);
  INIT_LIST_HEAD(& pstapriv->auth_list);
  spinlock_check(& pstapriv->asoc_list_lock);
  __raw_spin_lock_init(& pstapriv->asoc_list_lock.__annonCompField18.rlock, "&(&pstapriv->asoc_list_lock)->rlock",
                       & __key___0);
  spinlock_check(& pstapriv->auth_list_lock);
  __raw_spin_lock_init(& pstapriv->auth_list_lock.__annonCompField18.rlock, "&(&pstapriv->auth_list_lock)->rlock",
                       & __key___1);
  pstapriv->asoc_list_cnt = 0U;
  pstapriv->auth_list_cnt = 0U;
  pstapriv->auth_to = 3U;
  pstapriv->assoc_to = 3U;
  pstapriv->expire_to = 3U;
  pstapriv->max_num_sta = 32U;
  return (1);
}
}
int _rtw_free_sta_priv23a(struct sta_priv *pstapriv ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  int index ;
  int i ;
  struct list_head  const  *__mptr ;

  {
  if ((unsigned long )pstapriv != (unsigned long )((struct sta_priv *)0)) {
    spin_lock_bh(& pstapriv->sta_hash_lock);
    index = 0;
    goto ldv_55772;
    ldv_55771: 
    phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
    plist = phead->next;
    ptmp = plist->next;
    goto ldv_55769;
    ldv_55768: 
    __mptr = (struct list_head  const  *)plist;
    psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
    i = 0;
    goto ldv_55766;
    ldv_55765: 
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
    ldv_del_timer_sync_228(& preorder_ctrl->reordering_ctrl_timer);
    i = i + 1;
    ldv_55766: ;
    if (i <= 15) {
      goto ldv_55765;
    } else {

    }
    plist = ptmp;
    ptmp = plist->next;
    ldv_55769: ;
    if ((unsigned long )plist != (unsigned long )phead) {
      goto ldv_55768;
    } else {

    }
    index = index + 1;
    ldv_55772: ;
    if (index <= 31) {
      goto ldv_55771;
    } else {

    }
    spin_unlock_bh(& pstapriv->sta_hash_lock);
  } else {

  }
  return (1);
}
}
struct sta_info *rtw_alloc_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ,
                                      gfp_t gfp ) 
{ 
  struct list_head *phash_list ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  s32 index ;
  int i ;
  u16 wRxSeqInitialValue ;
  void *tmp ;
  u32 tmp___0 ;

  {
  i = 0;
  wRxSeqInitialValue = 65535U;
  tmp = kmalloc(5656UL, gfp);
  psta = (struct sta_info *)tmp;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return ((struct sta_info *)0);
  } else {

  }
  spin_lock_bh(& pstapriv->sta_hash_lock);
  _rtw_init_stainfo(psta);
  psta->padapter = pstapriv->padapter;
  ether_addr_copy((u8 *)(& psta->hwaddr), hwaddr);
  tmp___0 = wifi_mac_hash(hwaddr);
  index = (s32 )tmp___0;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(64, 7, "rtw_alloc_stainfo23a: index  = %x\n", index);
  } else {

  }
  if (index > 31) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(64, 4, "OLD_ERROR => rtw_alloc_stainfo23a: index >= NUM_STA\n");
    } else {

    }
    psta = (struct sta_info *)0;
    goto exit;
  } else {

  }
  phash_list = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
  list_add_tail(& psta->hash_list, phash_list);
  pstapriv->asoc_sta_count = pstapriv->asoc_sta_count + 1;
  i = 0;
  goto ldv_55787;
  ldv_55786: 
  memcpy((void *)(& psta->sta_recvpriv.rxcache.tid_rxseq) + (unsigned long )i, (void const   *)(& wRxSeqInitialValue),
           2UL);
  i = i + 1;
  ldv_55787: ;
  if (i <= 15) {
    goto ldv_55786;
  } else {

  }

  if (GlobalDebugLevel23A > 6U) {
    rt_trace(64, 7, "alloc number_%d stainfo  with hwaddr = %pM\n", pstapriv->asoc_sta_count,
             hwaddr);
  } else {

  }
  init_addba_retry_timer23a(psta);
  i = 0;
  goto ldv_55790;
  ldv_55789: 
  preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
  preorder_ctrl->padapter = pstapriv->padapter;
  preorder_ctrl->enable = 0U;
  preorder_ctrl->indicate_seq = 65535U;
  preorder_ctrl->wend_b = 65535U;
  preorder_ctrl->wsize_b = 64U;
  _rtw_init_queue23a(& preorder_ctrl->pending_recvframe_queue);
  rtw_init_recv_timer23a(preorder_ctrl);
  i = i + 1;
  ldv_55790: ;
  if (i <= 15) {
    goto ldv_55789;
  } else {

  }
  psta->rssi_stat.UndecoratedSmoothedPWDB = -1;
  psta->rssi_stat.UndecoratedSmoothedCCK = -1;
  psta->RxMgmtFrameSeqNum = 65535U;
  exit: 
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return (psta);
}
}
int rtw_free_stainfo23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_xmit_priv *pstaxmitpriv ;
  struct xmit_priv *pxmitpriv ;
  struct sta_priv *pstapriv ;
  struct hw_xmit *phwxmit ;
  int i ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct recv_frame *prframe ;
  struct rtw_queue *ppending_recvframe_queue ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pstapriv = & padapter->stapriv;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    goto exit;
  } else {

  }
  spin_lock_bh(& psta->lock);
  psta->state = psta->state & 4294967294U;
  spin_unlock_bh(& psta->lock);
  pstaxmitpriv = & psta->sta_xmitpriv;
  spin_lock_bh(& pxmitpriv->lock);
  rtw_free_xmitframe_queue23a(pxmitpriv, & psta->sleep_q);
  psta->sleepq_len = 0U;
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->vo_q.sta_pending);
  list_del_init(& pstaxmitpriv->vo_q.tx_pending);
  phwxmit = pxmitpriv->hwxmits;
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->vo_q.qcnt;
  pstaxmitpriv->vo_q.qcnt = 0;
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->vi_q.sta_pending);
  list_del_init(& pstaxmitpriv->vi_q.tx_pending);
  phwxmit = pxmitpriv->hwxmits + 1UL;
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->vi_q.qcnt;
  pstaxmitpriv->vi_q.qcnt = 0;
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->be_q.sta_pending);
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
  phwxmit = pxmitpriv->hwxmits + 2UL;
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->be_q.qcnt;
  pstaxmitpriv->be_q.qcnt = 0;
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->bk_q.sta_pending);
  list_del_init(& pstaxmitpriv->bk_q.tx_pending);
  phwxmit = pxmitpriv->hwxmits + 3UL;
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->bk_q.qcnt;
  pstaxmitpriv->bk_q.qcnt = 0;
  spin_unlock_bh(& pxmitpriv->lock);
  list_del_init(& psta->hash_list);
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(64, 4, "free number_%d stainfo  with hwaddr = %pM\n", pstapriv->asoc_sta_count,
             (u8 *)(& psta->hwaddr));
  } else {

  }
  pstapriv->asoc_sta_count = pstapriv->asoc_sta_count - 1;
  ldv_del_timer_sync_229(& psta->addba_retry_timer);
  i = 0;
  goto ldv_55813;
  ldv_55812: 
  preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
  ldv_del_timer_sync_230(& preorder_ctrl->reordering_ctrl_timer);
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  spin_lock_bh(& ppending_recvframe_queue->lock);
  phead = get_list_head(ppending_recvframe_queue);
  plist = phead->next;
  goto ldv_55810;
  ldv_55809: 
  __mptr = (struct list_head  const  *)plist;
  prframe = (struct recv_frame *)__mptr;
  plist = plist->next;
  list_del_init(& prframe->list);
  rtw_free_recvframe23a(prframe);
  ldv_55810: 
  tmp = list_empty((struct list_head  const  *)phead);
  if (tmp == 0) {
    goto ldv_55809;
  } else {

  }
  spin_unlock_bh(& ppending_recvframe_queue->lock);
  i = i + 1;
  ldv_55813: ;
  if (i <= 15) {
    goto ldv_55812;
  } else {

  }

  if ((psta->state & 16U) == 0U) {
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 0);
  } else {

  }
  spin_lock_bh(& pstapriv->auth_list_lock);
  tmp___0 = list_empty((struct list_head  const  *)(& psta->auth_list));
  if (tmp___0 == 0) {
    list_del_init(& psta->auth_list);
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
  } else {

  }
  spin_unlock_bh(& pstapriv->auth_list_lock);
  psta->expire_to = 0U;
  psta->sleepq_ac_len = 0U;
  psta->qos_info = 0U;
  psta->max_sp_len = 0U;
  psta->uapsd_bk = 0U;
  psta->uapsd_be = 0U;
  psta->uapsd_vi = 0U;
  psta->uapsd_vo = 0U;
  psta->has_legacy_ac = 0U;
  tmp___1 = CHKBIT(psta->aid);
  pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap & ~ ((int )((u16 )tmp___1));
  tmp___2 = CHKBIT(psta->aid);
  pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___2));
  if (psta->aid != 0U && (unsigned long )pstapriv->sta_aid[psta->aid - 1U] == (unsigned long )psta) {
    pstapriv->sta_aid[psta->aid - 1U] = (struct sta_info *)0;
    psta->aid = 0U;
  } else {

  }
  kfree((void const   *)psta);
  exit: ;
  return (1);
}
}
void rtw_free_all_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct sta_info *pbcmc_stainfo ;
  struct sta_info *tmp ;
  s32 index ;
  struct list_head  const  *__mptr ;

  {
  pstapriv = & padapter->stapriv;
  tmp = rtw_get_bcmc_stainfo23a(padapter);
  pbcmc_stainfo = tmp;
  if (pstapriv->asoc_sta_count == 1) {
    return;
  } else {

  }
  spin_lock_bh(& pstapriv->sta_hash_lock);
  index = 0;
  goto ldv_55831;
  ldv_55830: 
  phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_55828;
  ldv_55827: 
  __mptr = (struct list_head  const  *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
  if ((unsigned long )pbcmc_stainfo != (unsigned long )psta) {
    rtw_free_stainfo23a(padapter, psta);
  } else {

  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_55828: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55827;
  } else {

  }
  index = index + 1;
  ldv_55831: ;
  if (index <= 31) {
    goto ldv_55830;
  } else {

  }
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return;
}
}
struct sta_info *rtw_get_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct sta_info *psta ;
  u32 index ;
  u8 const   *addr ;
  bool tmp ;
  struct list_head  const  *__mptr ;
  bool tmp___0 ;

  {
  psta = (struct sta_info *)0;
  if ((unsigned long )hwaddr == (unsigned long )((u8 const   *)0U)) {
    return ((struct sta_info *)0);
  } else {

  }
  tmp = is_multicast_ether_addr(hwaddr);
  if ((int )tmp) {
    addr = (u8 const   *)(& bc_addr);
  } else {
    addr = hwaddr;
  }
  index = wifi_mac_hash(addr);
  spin_lock_bh(& pstapriv->sta_hash_lock);
  phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
  plist = phead->next;
  goto ldv_55846;
  ldv_55845: 
  __mptr = (struct list_head  const  *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
  tmp___0 = ether_addr_equal((u8 const   *)(& psta->hwaddr), addr);
  if ((int )tmp___0) {
    goto ldv_55844;
  } else {

  }
  psta = (struct sta_info *)0;
  plist = plist->next;
  ldv_55846: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55845;
  } else {

  }
  ldv_55844: 
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return (psta);
}
}
int rtw_init_bcmc_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  int res ;

  {
  pstapriv = & padapter->stapriv;
  res = 1;
  psta = rtw_alloc_stainfo23a(pstapriv, (u8 const   *)(& bc_addr), 208U);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(64, 4, "rtw_alloc_stainfo23a fail\n");
    } else {

    }
    return (res);
  } else {

  }
  psta->mac_id = 1U;
  ptxservq = & psta->sta_xmitpriv.be_q;
  return (1);
}
}
struct sta_info *rtw_get_bcmc_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;

  {
  pstapriv = & padapter->stapriv;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& bc_addr));
  return (psta);
}
}
bool rtw_access_ctrl23a(struct rtw_adapter *padapter , u8 *mac_addr ) 
{ 
  bool res ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_wlan_acl_node *paclnode ;
  bool match ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;
  bool tmp ;

  {
  res = 1;
  match = 0;
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  pacl_node_q = & pacl_list->acl_node_q;
  spin_lock_bh(& pacl_node_q->lock);
  phead = get_list_head(pacl_node_q);
  plist = phead->next;
  goto ldv_55875;
  ldv_55874: 
  __mptr = (struct list_head  const  *)plist;
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
  tmp = ether_addr_equal((u8 const   *)(& paclnode->addr), (u8 const   *)mac_addr);
  if ((int )tmp) {
    if ((unsigned int )paclnode->valid != 0U) {
      match = 1;
      goto ldv_55873;
    } else {

    }
  } else {

  }
  plist = plist->next;
  ldv_55875: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55874;
  } else {

  }
  ldv_55873: 
  spin_unlock_bh(& pacl_node_q->lock);
  if (pacl_list->mode == 1) {
    res = (int )match ? 0 : 1;
  } else
  if (pacl_list->mode == 2) {
    res = (int )match != 0;
  } else {
    res = 1;
  }
  return (res);
}
}
bool ldv_queue_work_on_223(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_224(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_225(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_226(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_227(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_228(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_229(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_230(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
extern void mutex_destroy(struct mutex * ) ;
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
  x->done = 0U;
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
  return;
}
}
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
extern void complete(struct completion * ) ;
bool ldv_queue_work_on_243(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_245(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_244(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_246(struct workqueue_struct *ldv_func_arg1 ) ;
extern void tasklet_init(struct tasklet_struct * , void (*)(unsigned long  ) , unsigned long  ) ;
__inline static void put_unaligned_be16(u16 val , void *p ) 
{ 
  __u16 tmp ;

  {
  tmp = __fswab16((int )val);
  *((__be16 *)p) = tmp;
  return;
}
}
void rtw23a_sctx_done_err(struct submit_ctx **sctx , int status ) ;
s32 rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) ;
struct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv ) ;
void rtw_count_tx_stats23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ,
                           int sz ) ;
struct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter , struct sta_info *psta ,
                                        int up___0 , u8 *ac ) ;
s32 rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
struct xmit_frame *rtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit_i ,
                                         int entry ) ;
s32 rtw_xmit23a_classifier(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
s32 rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter , struct sk_buff *skb ,
                              struct xmit_frame *pxmitframe ) ;
s32 rtw_txframes_pending23a(struct rtw_adapter *padapter ) ;
s32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) ;
void rtw_init_hwxmits23a(struct hw_xmit *phwxmit , int entry ) ;
int _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv , struct rtw_adapter *padapter ) ;
void _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv ) ;
void rtw_alloc_hwxmits23a(struct rtw_adapter *padapter ) ;
void rtw_free_hwxmits23a(struct rtw_adapter *padapter ) ;
int rtw_xmit23a(struct rtw_adapter *padapter , struct sk_buff *skb ) ;
int xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
u8 qos_acm23a(u8 acm_mask , u8 priority ) ;
u32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe ) ;
int rtw_os_xmit_resource_alloc23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ,
                                  u32 alloc_sz ) ;
void rtw_os_xmit_resource_free23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ) ;
void rtw_os_pkt_complete23a(struct rtw_adapter *padapter , struct sk_buff *pkt ) ;
void rtw_os_xmit_complete23a(struct rtw_adapter *padapter , struct xmit_frame *pxframe ) ;
void rtl8723au_xmit_tasklet(void *priv ) ;
bool rtl8723au_hal_xmit(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
static void _init_txservq(struct tx_servq *ptxservq ) 
{ 


  {
  INIT_LIST_HEAD(& ptxservq->tx_pending);
  _rtw_init_queue23a(& ptxservq->sta_pending);
  ptxservq->qcnt = 0;
  return;
}
}
void _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv ) 
{ 
  struct lock_class_key __key ;

  {
  spinlock_check(& psta_xmitpriv->lock);
  __raw_spin_lock_init(& psta_xmitpriv->lock.__annonCompField18.rlock, "&(&psta_xmitpriv->lock)->rlock",
                       & __key);
  _init_txservq(& psta_xmitpriv->be_q);
  _init_txservq(& psta_xmitpriv->bk_q);
  _init_txservq(& psta_xmitpriv->vi_q);
  _init_txservq(& psta_xmitpriv->vo_q);
  INIT_LIST_HEAD(& psta_xmitpriv->legacy_dz);
  INIT_LIST_HEAD(& psta_xmitpriv->apsd);
  return;
}
}
int _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv , struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct xmit_buf *pxmitbuf ;
  struct xmit_frame *pxframe ;
  int res ;
  u32 max_xmit_extbuf_size ;
  u32 num_xmit_extbuf ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct lock_class_key __key___1 ;

  {
  res = 1;
  max_xmit_extbuf_size = 1536U;
  num_xmit_extbuf = 32U;
  spinlock_check(& pxmitpriv->lock);
  __raw_spin_lock_init(& pxmitpriv->lock.__annonCompField18.rlock, "&(&pxmitpriv->lock)->rlock",
                       & __key);
  spinlock_check(& pxmitpriv->lock_sctx);
  __raw_spin_lock_init(& pxmitpriv->lock_sctx.__annonCompField18.rlock, "&(&pxmitpriv->lock_sctx)->rlock",
                       & __key___0);
  sema_init(& pxmitpriv->xmit_sema, 0);
  sema_init(& pxmitpriv->terminate_xmitthread_sema, 0);
  pxmitpriv->adapter = padapter;
  _rtw_init_queue23a(& pxmitpriv->be_pending);
  _rtw_init_queue23a(& pxmitpriv->bk_pending);
  _rtw_init_queue23a(& pxmitpriv->vi_pending);
  _rtw_init_queue23a(& pxmitpriv->vo_pending);
  _rtw_init_queue23a(& pxmitpriv->bm_pending);
  _rtw_init_queue23a(& pxmitpriv->free_xmit_queue);
  i = 0;
  goto ldv_53388;
  ldv_53387: 
  tmp = kzalloc(176UL, 208U);
  pxframe = (struct xmit_frame *)tmp;
  if ((unsigned long )pxframe == (unsigned long )((struct xmit_frame *)0)) {
    goto ldv_53386;
  } else {

  }
  INIT_LIST_HEAD(& pxframe->list);
  pxframe->padapter = padapter;
  pxframe->frame_tag = 0;
  list_add_tail(& pxframe->list, & pxmitpriv->free_xmit_queue.queue);
  i = i + 1;
  ldv_53388: ;
  if (i <= 255) {
    goto ldv_53387;
  } else {

  }
  ldv_53386: 
  pxmitpriv->free_xmitframe_cnt = i;
  pxmitpriv->frag_len = 2346U;
  _rtw_init_queue23a(& pxmitpriv->free_xmitbuf_queue);
  INIT_LIST_HEAD(& pxmitpriv->xmitbuf_list);
  _rtw_init_queue23a(& pxmitpriv->pending_xmitbuf_queue);
  i = 0;
  goto ldv_53391;
  ldv_53390: 
  tmp___0 = kzalloc(200UL, 208U);
  pxmitbuf = (struct xmit_buf *)tmp___0;
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    goto fail;
  } else {

  }
  INIT_LIST_HEAD(& pxmitbuf->list);
  INIT_LIST_HEAD(& pxmitbuf->list2);
  pxmitbuf->padapter = padapter;
  res = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf, 2560U);
  if (res == 0) {
    goto fail;
  } else {

  }
  list_add_tail(& pxmitbuf->list, & pxmitpriv->free_xmitbuf_queue.queue);
  list_add_tail(& pxmitbuf->list2, & pxmitpriv->xmitbuf_list);
  i = i + 1;
  ldv_53391: ;
  if (i <= 3) {
    goto ldv_53390;
  } else {

  }
  pxmitpriv->free_xmitbuf_cnt = 4U;
  _rtw_init_queue23a(& pxmitpriv->free_xframe_ext_queue);
  i = 0;
  goto ldv_53395;
  ldv_53394: 
  tmp___1 = kzalloc(176UL, 208U);
  pxframe = (struct xmit_frame *)tmp___1;
  if ((unsigned long )pxframe == (unsigned long )((struct xmit_frame *)0)) {
    goto ldv_53393;
  } else {

  }
  INIT_LIST_HEAD(& pxframe->list);
  pxframe->padapter = padapter;
  pxframe->frame_tag = 0;
  pxframe->pkt = (struct sk_buff *)0;
  pxframe->buf_addr = (u8 *)0U;
  pxframe->pxmitbuf = (struct xmit_buf *)0;
  pxframe->ext_tag = 1U;
  list_add_tail(& pxframe->list, & pxmitpriv->free_xframe_ext_queue.queue);
  i = i + 1;
  ldv_53395: ;
  if ((u32 )i < num_xmit_extbuf) {
    goto ldv_53394;
  } else {

  }
  ldv_53393: 
  pxmitpriv->free_xframe_ext_cnt = i;
  _rtw_init_queue23a(& pxmitpriv->free_xmit_extbuf_queue);
  INIT_LIST_HEAD(& pxmitpriv->xmitextbuf_list);
  i = 0;
  goto ldv_53398;
  ldv_53397: 
  tmp___2 = kzalloc(200UL, 208U);
  pxmitbuf = (struct xmit_buf *)tmp___2;
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    goto fail;
  } else {

  }
  INIT_LIST_HEAD(& pxmitbuf->list);
  INIT_LIST_HEAD(& pxmitbuf->list2);
  pxmitbuf->padapter = padapter;
  res = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf, max_xmit_extbuf_size + 512U);
  if (res == 0) {
    goto exit;
  } else {

  }
  list_add_tail(& pxmitbuf->list, & pxmitpriv->free_xmit_extbuf_queue.queue);
  list_add_tail(& pxmitbuf->list2, & pxmitpriv->xmitextbuf_list);
  i = i + 1;
  ldv_53398: ;
  if ((u32 )i < num_xmit_extbuf) {
    goto ldv_53397;
  } else {

  }
  pxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;
  rtw_alloc_hwxmits23a(padapter);
  rtw_init_hwxmits23a(pxmitpriv->hwxmits, (int )pxmitpriv->hwxmit_entry);
  i = 0;
  goto ldv_53401;
  ldv_53400: 
  pxmitpriv->wmm_para_seq[i] = (u8 )i;
  i = i + 1;
  ldv_53401: ;
  if (i <= 3) {
    goto ldv_53400;
  } else {

  }
  sema_init(& pxmitpriv->tx_retevt, 0);
  pxmitpriv->ack_tx = 0;
  __mutex_init(& pxmitpriv->ack_tx_mutex, "&pxmitpriv->ack_tx_mutex", & __key___1);
  rtw_sctx_init23a(& pxmitpriv->ack_tx_ops, 0);
  tasklet_init(& padapter->xmitpriv.xmit_tasklet, (void (*)(unsigned long  ))(& rtl8723au_xmit_tasklet),
               (unsigned long )padapter);
  exit: ;
  return (res);
  fail: ;
  goto exit;
}
}
void _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv ) 
{ 
  struct rtw_adapter *padapter ;
  struct xmit_frame *pxframe ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
  padapter = pxmitpriv->adapter;
  plist = pxmitpriv->free_xmit_queue.queue.next;
  ptmp = plist->next;
  goto ldv_53416;
  ldv_53415: 
  __mptr = (struct list_head  const  *)plist;
  pxframe = (struct xmit_frame *)__mptr;
  list_del_init(& pxframe->list);
  rtw_os_xmit_complete23a(padapter, pxframe);
  kfree((void const   *)pxframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_53416: ;
  if ((unsigned long )(& pxmitpriv->free_xmit_queue.queue) != (unsigned long )plist) {
    goto ldv_53415;
  } else {

  }
  plist = pxmitpriv->xmitbuf_list.next;
  ptmp = plist->next;
  goto ldv_53421;
  ldv_53420: 
  __mptr___0 = (struct list_head  const  *)plist;
  pxmitbuf = (struct xmit_buf *)__mptr___0 + 0xfffffffffffffff0UL;
  list_del_init(& pxmitbuf->list2);
  rtw_os_xmit_resource_free23a(padapter, pxmitbuf);
  kfree((void const   *)pxmitbuf);
  plist = ptmp;
  ptmp = plist->next;
  ldv_53421: ;
  if ((unsigned long )(& pxmitpriv->xmitbuf_list) != (unsigned long )plist) {
    goto ldv_53420;
  } else {

  }
  plist = pxmitpriv->free_xframe_ext_queue.queue.next;
  ptmp = plist->next;
  goto ldv_53426;
  ldv_53425: 
  __mptr___1 = (struct list_head  const  *)plist;
  pxframe = (struct xmit_frame *)__mptr___1;
  list_del_init(& pxframe->list);
  rtw_os_xmit_complete23a(padapter, pxframe);
  kfree((void const   *)pxframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_53426: ;
  if ((unsigned long )(& pxmitpriv->free_xframe_ext_queue.queue) != (unsigned long )plist) {
    goto ldv_53425;
  } else {

  }
  plist = pxmitpriv->xmitextbuf_list.next;
  ptmp = plist->next;
  goto ldv_53431;
  ldv_53430: 
  __mptr___2 = (struct list_head  const  *)plist;
  pxmitbuf = (struct xmit_buf *)__mptr___2 + 0xfffffffffffffff0UL;
  list_del_init(& pxmitbuf->list2);
  rtw_os_xmit_resource_free23a(padapter, pxmitbuf);
  kfree((void const   *)pxmitbuf);
  plist = ptmp;
  ptmp = plist->next;
  ldv_53431: ;
  if ((unsigned long )(& pxmitpriv->xmitextbuf_list) != (unsigned long )plist) {
    goto ldv_53430;
  } else {

  }
  rtw_free_hwxmits23a(padapter);
  mutex_destroy(& pxmitpriv->ack_tx_mutex);
  return;
}
}
static void update_attrib_vcs_info(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u32 sz ;
  struct pkt_attrib *pattrib ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 HTOpMode ;

  {
  pattrib = & pxmitframe->attrib;
  psta = pattrib->psta;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "update_attrib_vcs_info");
    } else {

    }
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "update_attrib_vcs_info");
    } else {

    }
    return;
  } else {

  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "update_attrib_vcs_info",
             psta->state);
    } else {

    }
    return;
  } else {

  }
  if ((unsigned int )pattrib->nr_frags != 1U) {
    sz = padapter->xmitpriv.frag_len;
  } else {
    sz = pattrib->last_txcmdsz;
  }
  if ((unsigned int )pmlmeext->cur_wireless_mode <= 7U || (unsigned int )padapter->registrypriv.wifi_spec != 0U) {
    if ((u32 )padapter->registrypriv.rts_thresh < sz) {
      pattrib->vcs_mode = 1U;
    } else
    if ((unsigned int )psta->rtsen != 0U) {
      pattrib->vcs_mode = 1U;
    } else
    if ((unsigned int )psta->cts2self != 0U) {
      pattrib->vcs_mode = 2U;
    } else {
      pattrib->vcs_mode = 0U;
    }
  } else {
    ldv_53445: ;
    if (((unsigned int )pmlmeinfo->assoc_AP_vendor == 5U && (unsigned int )pattrib->ampdu_en != 0U) && padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
      pattrib->vcs_mode = 2U;
      goto ldv_53443;
    } else {

    }
    if ((unsigned int )psta->rtsen != 0U || (unsigned int )psta->cts2self != 0U) {
      if ((unsigned int )psta->rtsen != 0U) {
        pattrib->vcs_mode = 1U;
      } else
      if ((unsigned int )psta->cts2self != 0U) {
        pattrib->vcs_mode = 2U;
      } else {

      }
      goto ldv_53443;
    } else {

    }
    if ((unsigned int )pattrib->ht_en != 0U) {
      HTOpMode = pmlmeinfo->HT_protection;
      if (((unsigned int )pmlmeext->cur_bwmode != 0U && ((unsigned int )HTOpMode == 2U || (unsigned int )HTOpMode == 3U)) || ((unsigned int )pmlmeext->cur_bwmode == 0U && (unsigned int )HTOpMode == 3U)) {
        pattrib->vcs_mode = 1U;
        goto ldv_53443;
      } else {

      }
    } else {

    }
    if ((u32 )padapter->registrypriv.rts_thresh < sz) {
      pattrib->vcs_mode = 1U;
      goto ldv_53443;
    } else {

    }
    if ((unsigned int )pattrib->ampdu_en != 0U) {
      pattrib->vcs_mode = 1U;
      goto ldv_53443;
    } else {

    }
    pattrib->vcs_mode = 0U;
    goto ldv_53443;
    goto ldv_53445;
    ldv_53443: ;
  }
  return;
}
}
static void update_attrib_phy_info(struct pkt_attrib *pattrib , struct sta_info *psta ) 
{ 


  {
  pattrib->mdata = 0U;
  pattrib->eosp = 0U;
  pattrib->triggered = 0U;
  pattrib->qos_en = (u8 )psta->qos_option;
  pattrib->raid = psta->raid;
  pattrib->ht_en = (u8 )psta->htpriv.ht_option;
  pattrib->bwmode = psta->htpriv.bwmode;
  pattrib->ch_offset = psta->htpriv.ch_offset;
  pattrib->sgi = psta->htpriv.sgi;
  pattrib->ampdu_en = 0U;
  pattrib->retry_ctrl = 0U;
  return;
}
}
u8 qos_acm23a(u8 acm_mask , u8 priority ) 
{ 
  u8 change_priority ;

  {
  change_priority = priority;
  switch ((int )priority) {
  case 0: ;
  case 3: ;
  if (((unsigned long )acm_mask & 2UL) != 0UL) {
    change_priority = 1U;
  } else {

  }
  goto ldv_53457;
  case 1: ;
  case 2: ;
  goto ldv_53457;
  case 4: ;
  case 5: ;
  if (((unsigned long )acm_mask & 4UL) != 0UL) {
    change_priority = 0U;
  } else {

  }
  goto ldv_53457;
  case 6: ;
  case 7: ;
  if (((unsigned long )acm_mask & 8UL) != 0UL) {
    change_priority = 5U;
  } else {

  }
  goto ldv_53457;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: qos_acm23a(): invalid pattrib->priority: %d!!!\n", (int )priority);
  } else {

  }
  change_priority = 0U;
  goto ldv_53457;
  }
  ldv_53457: ;
  return (change_priority);
}
}
static void set_qos(struct sk_buff *skb , struct pkt_attrib *pattrib ) 
{ 
  u8 *pframe ;
  struct iphdr *ip_hdr___0 ;
  u8 UserPriority ;

  {
  pframe = skb->data;
  UserPriority = 0U;
  if ((unsigned int )pattrib->ether_type == 2048U) {
    ip_hdr___0 = (struct iphdr *)pframe + 14U;
    UserPriority = (u8 )((int )ip_hdr___0->tos >> 5);
  } else
  if ((unsigned int )pattrib->ether_type == 34958U) {
    UserPriority = 7U;
  } else {

  }
  pattrib->priority = UserPriority;
  pattrib->hdrlen = 26U;
  pattrib->type = 136U;
  return;
}
}
static int update_attrib(struct rtw_adapter *padapter , struct sk_buff *skb , struct pkt_attrib *pattrib ) 
{ 
  struct sta_info *psta ;
  int bmcast ;
  struct sta_priv *pstapriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  int res ;
  struct ethhdr *ehdr ;
  __u16 tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  u8 *pframe ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;

  {
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmepriv = & padapter->mlmepriv;
  res = 1;
  ehdr = (struct ethhdr *)skb->data;
  tmp = __fswab16((int )ehdr->h_proto);
  pattrib->ether_type = tmp;
  ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& ehdr->h_dest));
  ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& ehdr->h_source));
  pattrib->pctrl = 0U;
  tmp___4 = check_fwstate(pmlmepriv, 32);
  if ((int )tmp___4) {
    ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
    ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
  } else {
    tmp___5 = check_fwstate(pmlmepriv, 64);
    if ((int )tmp___5) {
      ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
      ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
    } else {
      tmp___3 = check_fwstate(pmlmepriv, 8);
      if ((int )tmp___3) {
        tmp___0 = get_bssid(pmlmepriv);
        ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)tmp___0);
        ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
      } else {
        tmp___2 = check_fwstate(pmlmepriv, 16);
        if ((int )tmp___2) {
          ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
          tmp___1 = get_bssid(pmlmepriv);
          ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)tmp___1);
        } else {

        }
      }
    }
  }
  pattrib->pktlen = skb->len - 14U;
  if ((unsigned int )pattrib->ether_type == 2048U) {
    pattrib->dhcp_pkt = 0U;
    if (pattrib->pktlen > 306U) {
      if ((unsigned int )pattrib->ether_type == 2048U) {
        pframe = skb->data;
        pframe = pframe + 14UL;
        if (((unsigned int )*(pframe + 21UL) == 68U && (unsigned int )*(pframe + 23UL) == 67U) || ((unsigned int )*(pframe + 21UL) == 67U && (unsigned int )*(pframe + 23UL) == 68U)) {
          if (GlobalDebugLevel23A > 3U) {
            rt_trace(1, 4, "======================update_attrib: get DHCP Packet\n");
          } else {

          }
          pattrib->dhcp_pkt = 1U;
        } else {

        }
      } else {

      }
    } else {

    }
  } else
  if ((unsigned int )pattrib->ether_type == 34958U) {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: send eapol packet\n");
    } else {

    }
  } else {

  }
  if ((unsigned int )pattrib->ether_type == 34958U || (unsigned int )pattrib->dhcp_pkt == 1U) {
    rtw_set_scan_deny(padapter, 3000U);
  } else {

  }
  if (((unsigned int )pattrib->ether_type == 2054U || (unsigned int )pattrib->ether_type == 34958U) || (unsigned int )pattrib->dhcp_pkt == 1U) {
    rtw_lps_ctrl_wk_cmd23a(padapter, 4, 1);
  } else {

  }
  tmp___6 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  bmcast = (int )tmp___6;
  if (bmcast != 0) {
    psta = rtw_get_bcmc_stainfo23a(padapter);
  } else {
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
      if (GlobalDebugLevel23A > 2U) {
        rt_trace(1, 3, "update_attrib => get sta_info fail, ra:%pM\n", (u8 *)(& pattrib->ra));
      } else {

      }
      res = 0;
      goto exit;
    } else {
      tmp___7 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___7 && (psta->state & 1U) == 0U) {
        res = 0;
        goto exit;
      } else {

      }
    }
  }
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    pattrib->mac_id = (u8 )psta->mac_id;
    pattrib->psta = psta;
  } else {
    if (GlobalDebugLevel23A > 2U) {
      rt_trace(1, 3, "update_attrib => get sta_info fail, ra:%pM\n", (u8 *)(& pattrib->ra));
    } else {

    }
    res = 0;
    goto exit;
  }
  pattrib->ack_policy = 0U;
  pattrib->pkt_hdrlen = 14U;
  pattrib->hdrlen = 24U;
  pattrib->type = 8U;
  pattrib->priority = 0U;
  tmp___8 = check_fwstate(pmlmepriv, 112);
  if ((int )tmp___8) {
    if (psta->qos_option != 0U) {
      set_qos(skb, pattrib);
    } else {

    }
  } else
  if (pmlmepriv->qos_option != 0U) {
    set_qos(skb, pattrib);
    if ((unsigned int )pmlmepriv->acm_mask != 0U) {
      pattrib->priority = qos_acm23a((int )pmlmepriv->acm_mask, (int )pattrib->priority);
    } else {

    }
  } else {

  }
  if (psta->ieee8021x_blocked == 1U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "psta->ieee8021x_blocked == true\n");
    } else {

    }
    pattrib->encrypt = 0U;
    if ((unsigned int )pattrib->ether_type != 34958U) {
      tmp___9 = check_fwstate(pmlmepriv, 65536);
      if (tmp___9) {
        tmp___10 = 0;
      } else {
        tmp___10 = 1;
      }
      if (tmp___10) {
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(1, 4, "psta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n",
                   (int )pattrib->ether_type);
        } else {

        }
        res = 0;
        goto exit;
      } else {

      }
    } else {

    }
  } else {
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
    pattrib->encrypt = psecuritypriv->dot11PrivacyAlgrthm;
    goto ldv_53489;
    case 2U: ;
    if (bmcast != 0) {
      pattrib->encrypt = psecuritypriv->dot118021XGrpPrivacy;
    } else {
      pattrib->encrypt = psta->dot118021XPrivacy;
    }
    goto ldv_53489;
    }
    ldv_53489: ;
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
    pattrib->key_idx = (unsigned char )psecuritypriv->dot11PrivacyKeyIndex;
    goto ldv_53494;
    case 2U: ;
    if (bmcast != 0) {
      pattrib->key_idx = (unsigned char )psecuritypriv->dot118021XGrpKeyid;
    } else {
      pattrib->key_idx = 0U;
    }
    goto ldv_53494;
    default: 
    pattrib->key_idx = 0U;
    goto ldv_53494;
    }
    ldv_53494: ;
  }
  switch (pattrib->encrypt) {
  case 1027073U: ;
  case 1027077U: 
  pattrib->iv_len = 4U;
  pattrib->icv_len = 4U;
  goto ldv_53499;
  case 1027074U: 
  pattrib->iv_len = 8U;
  pattrib->icv_len = 4U;
  if ((unsigned int )*((unsigned char *)padapter + 10948UL) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "padapter->securitypriv.busetkipkey(%d) == false drop packet\n",
               (int )padapter->securitypriv.busetkipkey);
    } else {

    }
    res = 0;
    goto exit;
  } else {

  }
  goto ldv_53499;
  case 1027076U: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "pattrib->encrypt =%d (WLAN_CIPHER_SUITE_CCMP)\n", pattrib->encrypt);
  } else {

  }
  pattrib->iv_len = 8U;
  pattrib->icv_len = 8U;
  goto ldv_53499;
  default: 
  pattrib->iv_len = 0U;
  pattrib->icv_len = 0U;
  goto ldv_53499;
  }
  ldv_53499: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "update_attrib: encrypt =%d\n", pattrib->encrypt);
  } else {

  }
  if (pattrib->encrypt != 0U && (unsigned int )*((unsigned char *)psecuritypriv + 580UL) == 0U) {
    pattrib->bswenc = 1U;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "update_attrib: encrypt =%d bswenc = true\n", pattrib->encrypt);
    } else {

    }
  } else {
    pattrib->bswenc = 0U;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(1, 7, "update_attrib: bswenc = false\n");
    } else {

    }
  }
  update_attrib_phy_info(pattrib, psta);
  exit: ;
  return (res);
}
}
static int xmitframe_addmic(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct mic_data micdata ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int curfragnum ;
  int length ;
  u8 *pframe ;
  u8 *payload ;
  u8 mic[8U] ;
  u8 priority[4U] ;
  u8 hw_hdr_offset ;
  int bmcst ;
  bool tmp ;
  u8 null_key[16U] ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pattrib = & pxmitframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv = & padapter->xmitpriv;
  priority[0] = 0U;
  priority[1] = 0U;
  priority[2] = 0U;
  priority[3] = 0U;
  hw_hdr_offset = 0U;
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  bmcst = (int )tmp;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    stainfo = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "xmitframe_addmic");
    } else {

    }
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "xmitframe_addmic");
    } else {

    }
    return (0);
  } else {

  }
  if ((stainfo->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "xmitframe_addmic",
             stainfo->state);
    } else {

    }
    return (0);
  } else {

  }
  hw_hdr_offset = 40U;
  if (pattrib->encrypt == 1027074U) {
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
      null_key[0] = 0U;
      null_key[1] = 0U;
      null_key[2] = 0U;
      null_key[3] = 0U;
      null_key[4] = 0U;
      null_key[5] = 0U;
      null_key[6] = 0U;
      null_key[7] = 0U;
      null_key[8] = 0U;
      null_key[9] = 0U;
      null_key[10] = 0U;
      null_key[11] = 0U;
      null_key[12] = 0U;
      null_key[13] = 0U;
      null_key[14] = 0U;
      null_key[15] = 0U;
      pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
      if (bmcst != 0) {
        tmp___0 = memcmp((void const   *)(& psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey),
                         (void const   *)(& null_key), 16UL);
        if (tmp___0 == 0) {
          return (0);
        } else {

        }
        rtw_secmicsetkey23a(& micdata, (u8 *)(& psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey));
      } else {
        tmp___1 = memcmp((void const   *)(& stainfo->dot11tkiptxmickey.skey), (void const   *)(& null_key),
                         16UL);
        if (tmp___1 == 0) {
          return (0);
        } else {

        }
        rtw_secmicsetkey23a(& micdata, (u8 *)(& stainfo->dot11tkiptxmickey.skey));
      }
      if ((int )*(pframe + 1UL) & 1) {
        rtw_secmicappend23a(& micdata, pframe + 16UL, 6U);
        if (((int )*(pframe + 1UL) & 2) != 0) {
          rtw_secmicappend23a(& micdata, pframe + 24UL, 6U);
        } else {
          rtw_secmicappend23a(& micdata, pframe + 10UL, 6U);
        }
      } else {
        rtw_secmicappend23a(& micdata, pframe + 4UL, 6U);
        if (((int )*(pframe + 1UL) & 2) != 0) {
          rtw_secmicappend23a(& micdata, pframe + 16UL, 6U);
        } else {
          rtw_secmicappend23a(& micdata, pframe + 10UL, 6U);
        }
      }
      if ((unsigned int )pattrib->qos_en != 0U) {
        priority[0] = pxmitframe->attrib.priority;
      } else {

      }
      rtw_secmicappend23a(& micdata, (u8 *)(& priority), 4U);
      payload = pframe;
      curfragnum = 0;
      goto ldv_53523;
      ldv_53522: 
      payload = (u8 *)(((unsigned long )payload + 3UL) & 0xfffffffffffffffcUL);
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(1, 4, "=== curfragnum =%d, pframe = 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
                 curfragnum, (int )*payload, (int )*(payload + 1UL), (int )*(payload + 2UL),
                 (int )*(payload + 3UL), (int )*(payload + 4UL), (int )*(payload + 5UL),
                 (int )*(payload + 6UL), (int )*(payload + 7UL));
      } else {

      }
      payload = payload + ((unsigned long )pattrib->hdrlen + (unsigned long )pattrib->iv_len);
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(1, 4, "curfragnum =%d pattrib->hdrlen =%d pattrib->iv_len =%d\n",
                 curfragnum, (int )pattrib->hdrlen, (int )pattrib->iv_len);
      } else {

      }
      if (curfragnum + 1 == (int )pattrib->nr_frags) {
        length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - ((unsigned int )pattrib->bswenc != 0U ? (u32 )pattrib->icv_len : 0U));
        rtw_secmicappend23a(& micdata, payload, (u32 )length);
        payload = payload + (unsigned long )length;
      } else {
        length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - ((unsigned int )pattrib->bswenc != 0U ? (uint )pattrib->icv_len : 0U));
        rtw_secmicappend23a(& micdata, payload, (u32 )length);
        payload = payload + ((unsigned long )length + (unsigned long )pattrib->icv_len);
        if (GlobalDebugLevel23A > 3U) {
          rt_trace(1, 4, "curfragnum =%d length =%d pattrib->icv_len =%d\n", curfragnum,
                   length, (int )pattrib->icv_len);
        } else {

        }
      }
      curfragnum = curfragnum + 1;
      ldv_53523: ;
      if ((int )pattrib->nr_frags > curfragnum) {
        goto ldv_53522;
      } else {

      }
      rtw_secgetmic23a(& micdata, (u8 *)(& mic));
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(1, 4, "xmitframe_addmic: before add mic code!!\n");
      } else {

      }
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(1, 4, "xmitframe_addmic: pattrib->last_txcmdsz =%d!!!\n", pattrib->last_txcmdsz);
      } else {

      }
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(1, 4, "xmitframe_addmic: mic[0]= 0x%.2x , mic[1]=0x%.2x , mic[2]= 0x%.2x , mic[3]= 0x%.2x\nmic[4]= 0x%.2x , mic[5]= 0x%.2x , mic[6]= 0x%.2x , mic[7]= 0x%.2x !!!!\n",
                 (int )mic[0], (int )mic[1], (int )mic[2], (int )mic[3], (int )mic[4],
                 (int )mic[5], (int )mic[6], (int )mic[7]);
      } else {

      }
      memcpy((void *)payload, (void const   *)(& mic), 8UL);
      pattrib->last_txcmdsz = pattrib->last_txcmdsz + 8U;
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(1, 7, "======== last pkt ========\n");
      } else {

      }
      payload = payload + (8UL - (unsigned long )pattrib->last_txcmdsz);
      curfragnum = 0;
      goto ldv_53526;
      ldv_53525: ;
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(1, 7, "%.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x\n",
                 (int )*(payload + (unsigned long )curfragnum), (int )*(payload + ((unsigned long )curfragnum + 1UL)),
                 (int )*(payload + ((unsigned long )curfragnum + 2UL)), (int )*(payload + ((unsigned long )curfragnum + 3UL)),
                 (int )*(payload + ((unsigned long )curfragnum + 4UL)), (int )*(payload + ((unsigned long )curfragnum + 5UL)),
                 (int )*(payload + ((unsigned long )curfragnum + 6UL)), (int )*(payload + ((unsigned long )curfragnum + 7UL)));
      } else {

      }
      curfragnum = curfragnum + 8;
      ldv_53526: ;
      if ((u32 )curfragnum < pattrib->last_txcmdsz) {
        goto ldv_53525;
      } else {

      }

    } else
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "xmitframe_addmic: rtw_get_stainfo23a ==NULL!!!\n");
    } else {

    }
  } else {

  }
  return (1);
}
}
static int xmitframe_swencrypt(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct pkt_attrib *pattrib ;

  {
  pattrib = & pxmitframe->attrib;
  if ((unsigned int )pattrib->bswenc != 0U) {
    if (GlobalDebugLevel23A > 2U) {
      rt_trace(1, 3, "### xmitframe_swencrypt\n");
    } else {

    }
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
    rtw_wep_encrypt23a(padapter, pxmitframe);
    goto ldv_53535;
    case 1027074U: 
    rtw_tkip_encrypt23a(padapter, pxmitframe);
    goto ldv_53535;
    case 1027076U: 
    rtw_aes_encrypt23a(padapter, pxmitframe);
    goto ldv_53535;
    default: ;
    goto ldv_53535;
    }
    ldv_53535: ;
  } else
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(1, 6, "### xmitframe_hwencrypt\n");
  } else {

  }
  return (1);
}
}
static int rtw_make_wlanhdr(struct rtw_adapter *padapter , u8 *hdr , struct pkt_attrib *pattrib ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  struct ieee80211_qos_hdr *qoshdr ;
  struct mlme_priv *pmlmepriv ;
  u8 qos_option ;
  int res ;
  struct sta_info *psta ;
  int bmcst ;
  bool tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  u16 tx_seq ;

  {
  pwlanhdr = (struct ieee80211_hdr *)hdr;
  pmlmepriv = & padapter->mlmepriv;
  qos_option = 0U;
  res = 1;
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  bmcst = (int )tmp;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_make_wlanhdr");
    } else {

    }
    if (bmcst != 0) {
      psta = rtw_get_bcmc_stainfo23a(padapter);
    } else {
      psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
    }
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_make_wlanhdr");
    } else {

    }
    return (0);
  } else {

  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_make_wlanhdr",
             psta->state);
    } else {

    }
    return (0);
  } else {

  }
  memset((void *)hdr, 0, 64UL);
  pwlanhdr->frame_control = pattrib->type;
  if (((int )pattrib->type & 8) != 0) {
    tmp___7 = check_fwstate(pmlmepriv, 8);
    if ((int )tmp___7) {
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
      tmp___0 = get_bssid(pmlmepriv);
      ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)tmp___0);
      ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)(& pattrib->src));
      ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& pattrib->dst));
      if (pmlmepriv->qos_option != 0U) {
        qos_option = 1U;
      } else {

      }
    } else {
      tmp___6 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___6) {
        pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
        ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& pattrib->dst));
        tmp___1 = get_bssid(pmlmepriv);
        ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp___1);
        ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& pattrib->src));
        if (psta->qos_option != 0U) {
          qos_option = 1U;
        } else {

        }
      } else {
        tmp___4 = check_fwstate(pmlmepriv, 32);
        if ((int )tmp___4) {
          goto _L;
        } else {
          tmp___5 = check_fwstate(pmlmepriv, 64);
          if ((int )tmp___5) {
            _L: /* CIL Label */ 
            ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& pattrib->dst));
            ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)(& pattrib->src));
            tmp___2 = get_bssid(pmlmepriv);
            ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___2);
            if (psta->qos_option != 0U) {
              qos_option = 1U;
            } else {

            }
          } else {
            if (GlobalDebugLevel23A > 3U) {
              tmp___3 = get_fwstate(pmlmepriv);
              rt_trace(1, 4, "fw_state:%x is not allowed to xmit frame\n", tmp___3);
            } else {

            }
            res = 0;
            goto exit;
          }
        }
      }
    }
    if ((unsigned int )pattrib->mdata != 0U) {
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 8192U);
    } else {

    }
    if (pattrib->encrypt != 0U) {
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 16384U);
    } else {

    }
    if ((unsigned int )qos_option != 0U) {
      qoshdr = (struct ieee80211_qos_hdr *)hdr;
      qoshdr->qos_ctrl = (unsigned int )((unsigned short )pattrib->priority) & 15U;
      qoshdr->qos_ctrl = (__le16 )((int )((short )qoshdr->qos_ctrl) | ((int )((short )((int )pattrib->ack_policy << 5)) & 96));
      if ((unsigned int )pattrib->eosp != 0U) {
        qoshdr->qos_ctrl = (__le16 )((unsigned int )qoshdr->qos_ctrl | 16U);
      } else {

      }
    } else {

    }
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] = (u16 )((int )psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] + 1);
      psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] = (unsigned int )psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] & 4095U;
      pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority];
      pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pattrib->seqnum << 4)) & 65520U;
      if ((unsigned int )pattrib->ht_en != 0U && (int )psta->htpriv.ampdu_enable) {
        if ((unsigned int )pattrib->priority > 15U) {
          printk("\f%s: Invalid pattrib->priority %i\n", "rtw_make_wlanhdr", (int )pattrib->priority);
        } else {

        }
        if ((int )((unsigned long )psta->htpriv.agg_enable_bitmap >> (int )pattrib->priority) & 1) {
          pattrib->ampdu_en = 1U;
        } else {

        }
      } else {

      }
      if ((unsigned int )pattrib->ampdu_en != 0U) {
        tx_seq = psta->BA_starting_seqctrl[(int )pattrib->priority & 15];
        if ((((int )pattrib->seqnum - (int )tx_seq) & 2048) != 0) {
          pattrib->ampdu_en = 0U;
        } else
        if ((int )pattrib->seqnum == (int )tx_seq) {
          psta->BA_starting_seqctrl[(int )pattrib->priority & 15] = (unsigned int )((u16 )((unsigned int )tx_seq + 1U)) & 4095U;
          pattrib->ampdu_en = 1U;
        } else {
          psta->BA_starting_seqctrl[(int )pattrib->priority & 15] = (unsigned int )((u16 )((unsigned int )pattrib->seqnum + 1U)) & 4095U;
          pattrib->ampdu_en = 1U;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  exit: ;
  return (res);
}
}
s32 rtw_txframes_pending23a(struct rtw_adapter *padapter ) 
{ 
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  tmp = list_empty((struct list_head  const  *)(& pxmitpriv->be_pending.queue));
  if (tmp == 0) {
    tmp___3 = 1;
  } else {
    tmp___0 = list_empty((struct list_head  const  *)(& pxmitpriv->bk_pending.queue));
    if (tmp___0 == 0) {
      tmp___3 = 1;
    } else {
      tmp___1 = list_empty((struct list_head  const  *)(& pxmitpriv->vi_pending.queue));
      if (tmp___1 == 0) {
        tmp___3 = 1;
      } else {
        tmp___2 = list_empty((struct list_head  const  *)(& pxmitpriv->vo_pending.queue));
        if (tmp___2 == 0) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      }
    }
  }
  return (tmp___3);
}
}
s32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) 
{ 
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  int priority ;

  {
  priority = (int )pattrib->priority;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_txframes_sta_ac_pending23a");
    } else {

    }
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_txframes_sta_ac_pending23a");
    } else {

    }
    return (0);
  } else {

  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_txframes_sta_ac_pending23a",
             psta->state);
    } else {

    }
    return (0);
  } else {

  }
  switch (priority) {
  case 1: ;
  case 2: 
  ptxservq = & psta->sta_xmitpriv.bk_q;
  goto ldv_53568;
  case 4: ;
  case 5: 
  ptxservq = & psta->sta_xmitpriv.vi_q;
  goto ldv_53568;
  case 6: ;
  case 7: 
  ptxservq = & psta->sta_xmitpriv.vo_q;
  goto ldv_53568;
  case 0: ;
  case 3: ;
  default: 
  ptxservq = & psta->sta_xmitpriv.be_q;
  goto ldv_53568;
  }
  ldv_53568: ;
  return (ptxservq->qcnt);
}
}
static int rtw_put_snap(u8 *data , u16 h_proto ) 
{ 


  {
  if ((unsigned int )h_proto == 33079U || (unsigned int )h_proto == 33011U) {
    ether_addr_copy(data, (u8 const   *)(& bridge_tunnel_header));
  } else {
    ether_addr_copy(data, (u8 const   *)(& rfc1042_header));
  }
  data = data + 6UL;
  put_unaligned_be16((int )h_proto, (void *)data);
  return (8);
}
}
s32 rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter , struct sk_buff *skb ,
                              struct xmit_frame *pxmitframe ) 
{ 
  struct sta_info *psta ;
  struct xmit_priv *pxmitpriv ;
  struct pkt_attrib *pattrib ;
  struct ieee80211_hdr *hdr ;
  s32 frg_inx ;
  s32 frg_len ;
  s32 mpdu_len ;
  s32 llc_sz ;
  s32 mem_sz ;
  u8 *pframe ;
  u8 *mem_start ;
  u8 hw_hdr_offset ;
  u8 *pbuf_start ;
  u8 *pdata ;
  int data_len ;
  s32 bmcst ;
  bool tmp ;
  int res ;
  int tmp___0 ;
  s32 __min1 ;
  s32 __min2 ;
  s32 __min1___0 ;
  s32 __min2___0 ;
  int tmp___1 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pattrib = & pxmitframe->attrib;
  pdata = skb->data;
  data_len = (int )skb->len;
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  bmcst = (s32 )tmp;
  res = 1;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
    return (0);
  } else {

  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_xmitframe_coalesce23a",
             psta->state);
    } else {

    }
    return (0);
  } else {

  }
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ==> %s buf_addr == NULL\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
    return (0);
  } else {

  }
  pbuf_start = pxmitframe->buf_addr;
  hw_hdr_offset = 40U;
  mem_start = pbuf_start + (unsigned long )hw_hdr_offset;
  tmp___0 = rtw_make_wlanhdr(padapter, mem_start, pattrib);
  if (tmp___0 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "%s: rtw_make_wlanhdr fail; drop pkt\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
    res = 0;
    goto exit;
  } else {

  }
  pdata = pdata + (unsigned long )pattrib->pkt_hdrlen;
  data_len = data_len - (int )pattrib->pkt_hdrlen;
  frg_inx = 0;
  frg_len = (s32 )(pxmitpriv->frag_len - 4U);
  ldv_53616: 
  llc_sz = 0;
  mpdu_len = frg_len;
  pframe = mem_start;
  hdr = (struct ieee80211_hdr *)mem_start;
  pframe = pframe + (unsigned long )pattrib->hdrlen;
  mpdu_len = mpdu_len - (int )pattrib->hdrlen;
  if ((unsigned int )pattrib->iv_len != 0U) {
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      switch (pattrib->encrypt) {
      case 1027073U: ;
      case 1027077U: 
      pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
      pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
      pattrib->iv[2] = psta->dot11txpn._byte_.TSC2;
      pattrib->iv[3] = (u8 )((int )pattrib->key_idx << 6);
      psta->dot11txpn.val = psta->dot11txpn.val != 16777215ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      goto ldv_53606;
      case 1027074U: ;
      if (bmcst != 0) {
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC1;
        pattrib->iv[1] = ((unsigned int )psta->dot11txpn._byte_.TSC1 & 95U) | 32U;
        pattrib->iv[2] = psta->dot11txpn._byte_.TSC0;
        pattrib->iv[3] = (u8 )((int )((signed char )((int )pattrib->key_idx << 6)) | 32);
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      } else {
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC1;
        pattrib->iv[1] = ((unsigned int )psta->dot11txpn._byte_.TSC1 & 95U) | 32U;
        pattrib->iv[2] = psta->dot11txpn._byte_.TSC0;
        pattrib->iv[3] = 32U;
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      }
      goto ldv_53606;
      case 1027076U: ;
      if (bmcst != 0) {
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
        pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
        pattrib->iv[2] = 0U;
        pattrib->iv[3] = (u8 )((int )((signed char )((int )pattrib->key_idx << 6)) | 32);
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      } else {
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
        pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
        pattrib->iv[2] = 0U;
        pattrib->iv[3] = 32U;
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      }
      goto ldv_53606;
      }
      ldv_53606: ;
    } else {

    }
    memcpy((void *)pframe, (void const   *)(& pattrib->iv), (size_t )pattrib->iv_len);
    if (GlobalDebugLevel23A > 5U) {
      rt_trace(1, 6, "rtw_xmiaframe_coalesce23a: keyid =%d pattrib->iv[3]=%.2x pframe =%.2x %.2x %.2x %.2x\n",
               padapter->securitypriv.dot11PrivacyKeyIndex, (int )pattrib->iv[3],
               (int )*pframe, (int )*(pframe + 1UL), (int )*(pframe + 2UL), (int )*(pframe + 3UL));
    } else {

    }
    pframe = pframe + (unsigned long )pattrib->iv_len;
    mpdu_len = mpdu_len - (int )pattrib->iv_len;
  } else {

  }
  if (frg_inx == 0) {
    llc_sz = rtw_put_snap(pframe, (int )pattrib->ether_type);
    pframe = pframe + (unsigned long )llc_sz;
    mpdu_len = mpdu_len - llc_sz;
  } else {

  }
  if ((unsigned int )pattrib->icv_len != 0U && (unsigned int )pattrib->bswenc != 0U) {
    mpdu_len = mpdu_len - (int )pattrib->icv_len;
  } else {

  }
  if (bmcst != 0) {
    __min1 = data_len;
    __min2 = (s32 )pattrib->pktlen;
    mem_sz = __min1 < __min2 ? __min1 : __min2;
  } else {
    __min1___0 = data_len;
    __min2___0 = mpdu_len;
    mem_sz = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
  }
  memcpy((void *)pframe, (void const   *)pdata, (size_t )mem_sz);
  pframe = pframe + (unsigned long )mem_sz;
  pdata = pdata + (unsigned long )mem_sz;
  data_len = data_len - mem_sz;
  if ((unsigned int )pattrib->icv_len != 0U && (unsigned int )pattrib->bswenc != 0U) {
    memcpy((void *)pframe, (void const   *)(& pattrib->icv), (size_t )pattrib->icv_len);
    pframe = pframe + (unsigned long )pattrib->icv_len;
  } else {

  }
  frg_inx = frg_inx + 1;
  if (bmcst != 0 || data_len <= 0) {
    pattrib->nr_frags = (u8 )frg_inx;
    pattrib->last_txcmdsz = (u32 )(((((int )pattrib->hdrlen + (int )pattrib->iv_len) + ((unsigned int )pattrib->nr_frags == 1U ? llc_sz : 0)) + ((unsigned int )pattrib->bswenc != 0U ? (int )pattrib->icv_len : 0)) + mem_sz);
    hdr->frame_control = (unsigned int )hdr->frame_control & 64511U;
    goto ldv_53615;
  } else
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1, 4, "%s: There\'re still something in packet!\n", "rtw_xmitframe_coalesce23a");
  } else {

  }
  hdr->frame_control = (__le16 )((unsigned int )hdr->frame_control | 1024U);
  mem_start = (u8 *)((unsigned long )hw_hdr_offset + (((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL));
  memcpy((void *)mem_start, (void const   *)pbuf_start + (unsigned long )hw_hdr_offset,
           (size_t )pattrib->hdrlen);
  goto ldv_53616;
  ldv_53615: 
  tmp___1 = xmitframe_addmic(padapter, pxmitframe);
  if (tmp___1 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");
    } else {

    }
    res = 0;
    goto exit;
  } else {

  }
  xmitframe_swencrypt(padapter, pxmitframe);
  if (bmcst == 0) {
    update_attrib_vcs_info(padapter, pxmitframe);
  } else {
    pattrib->vcs_mode = 0U;
  }
  exit: ;
  return (res);
}
}
void rtw_update_protection23a(struct rtw_adapter *padapter , u8 *ie , uint ie_len ) 
{ 
  struct xmit_priv *pxmitpriv ;
  struct registry_priv *pregistrypriv ;
  uint protection ;
  u8 const   *p ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pregistrypriv = & padapter->registrypriv;
  switch ((int )pregistrypriv->vrtl_carrier_sense) {
  case 0: 
  pxmitpriv->vcs = 0U;
  goto ldv_53627;
  case 1: ;
  goto ldv_53627;
  case 2: ;
  default: 
  p = cfg80211_find_ie(42, (u8 const   *)ie, (int )ie_len);
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
    pxmitpriv->vcs = 0U;
  } else {
    protection = (uint )*(p + 2UL) & 2U;
    if (protection != 0U) {
      if ((unsigned int )pregistrypriv->vcs_type == 1U) {
        pxmitpriv->vcs = 1U;
      } else {
        pxmitpriv->vcs = 2U;
      }
    } else {
      pxmitpriv->vcs = 0U;
    }
  }
  goto ldv_53627;
  }
  ldv_53627: ;
  return;
}
}
void rtw_count_tx_stats23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ,
                           int sz ) 
{ 
  struct sta_info *psta ;
  struct stainfo_stats *pstats ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;

  {
  psta = (struct sta_info *)0;
  pstats = (struct stainfo_stats *)0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  if (pxmitframe->frame_tag == 1) {
    pxmitpriv->tx_bytes = pxmitpriv->tx_bytes + (u64 )sz;
    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod = pmlmepriv->LinkDetectInfo.NumTxOkInPeriod + 1U;
    psta = pxmitframe->attrib.psta;
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      pstats = & psta->sta_stats;
      pstats->tx_pkts = pstats->tx_pkts + 1ULL;
      pstats->tx_bytes = pstats->tx_bytes + (u64 )sz;
    } else {

    }
  } else {

  }
  return;
}
}
struct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv ) 
{ 
  unsigned long irqL ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *phead ;
  struct rtw_queue *pfree_queue ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
  pxmitbuf = (struct xmit_buf *)0;
  pfree_queue = & pxmitpriv->free_xmit_extbuf_queue;
  tmp = spinlock_check(& pfree_queue->lock);
  irqL = _raw_spin_lock_irqsave(tmp);
  phead = get_list_head(pfree_queue);
  tmp___0 = list_empty((struct list_head  const  *)phead);
  if (tmp___0 == 0) {
    __mptr = (struct list_head  const  *)phead->next;
    pxmitbuf = (struct xmit_buf *)__mptr;
    list_del_init(& pxmitbuf->list);
    pxmitpriv->free_xmit_extbuf_cnt = pxmitpriv->free_xmit_extbuf_cnt - 1U;
    pxmitbuf->priv_data = (void *)0;
    pxmitbuf->ext_tag = 1U;
    if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_alloc_xmitbuf23a_ext");
      } else {

      }
      rtw23a_sctx_done_err(& pxmitbuf->sctx, 3);
    } else {

    }
  } else {

  }
  spin_unlock_irqrestore(& pfree_queue->lock, irqL);
  return (pxmitbuf);
}
}
s32 rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) 
{ 
  unsigned long irqL ;
  struct rtw_queue *pfree_queue ;
  raw_spinlock_t *tmp ;
  struct list_head *tmp___0 ;

  {
  pfree_queue = & pxmitpriv->free_xmit_extbuf_queue;
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    return (0);
  } else {

  }
  tmp = spinlock_check(& pfree_queue->lock);
  irqL = _raw_spin_lock_irqsave(tmp);
  list_del_init(& pxmitbuf->list);
  tmp___0 = get_list_head(pfree_queue);
  list_add_tail(& pxmitbuf->list, tmp___0);
  pxmitpriv->free_xmit_extbuf_cnt = pxmitpriv->free_xmit_extbuf_cnt + 1U;
  spin_unlock_irqrestore(& pfree_queue->lock, irqL);
  return (1);
}
}
struct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv ) 
{ 
  unsigned long irqL ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *phead ;
  struct rtw_queue *pfree_xmitbuf_queue ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
  pxmitbuf = (struct xmit_buf *)0;
  pfree_xmitbuf_queue = & pxmitpriv->free_xmitbuf_queue;
  tmp = spinlock_check(& pfree_xmitbuf_queue->lock);
  irqL = _raw_spin_lock_irqsave(tmp);
  phead = get_list_head(pfree_xmitbuf_queue);
  tmp___0 = list_empty((struct list_head  const  *)phead);
  if (tmp___0 == 0) {
    __mptr = (struct list_head  const  *)phead->next;
    pxmitbuf = (struct xmit_buf *)__mptr;
    list_del_init(& pxmitbuf->list);
    pxmitpriv->free_xmitbuf_cnt = pxmitpriv->free_xmitbuf_cnt - 1U;
    pxmitbuf->priv_data = (void *)0;
    pxmitbuf->ext_tag = 0U;
    pxmitbuf->flags = 0U;
    if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_alloc_xmitbuf23a");
      } else {

      }
      rtw23a_sctx_done_err(& pxmitbuf->sctx, 3);
    } else {

    }
  } else {

  }
  spin_unlock_irqrestore(& pfree_xmitbuf_queue->lock, irqL);
  return (pxmitbuf);
}
}
s32 rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) 
{ 
  unsigned long irqL ;
  struct rtw_queue *pfree_xmitbuf_queue ;
  raw_spinlock_t *tmp ;
  struct list_head *tmp___0 ;

  {
  pfree_xmitbuf_queue = & pxmitpriv->free_xmitbuf_queue;
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    return (0);
  } else {

  }
  if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_free_xmitbuf23a");
    } else {

    }
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 4);
  } else {

  }
  if ((unsigned int )pxmitbuf->ext_tag != 0U) {
    rtw_free_xmitbuf_ext23a(pxmitpriv, pxmitbuf);
  } else {
    tmp = spinlock_check(& pfree_xmitbuf_queue->lock);
    irqL = _raw_spin_lock_irqsave(tmp);
    list_del_init(& pxmitbuf->list);
    tmp___0 = get_list_head(pfree_xmitbuf_queue);
    list_add_tail(& pxmitbuf->list, tmp___0);
    pxmitpriv->free_xmitbuf_cnt = pxmitpriv->free_xmitbuf_cnt + 1U;
    spin_unlock_irqrestore(& pfree_xmitbuf_queue->lock, irqL);
  }
  return (1);
}
}
static void rtw_init_xmitframe(struct xmit_frame *pxframe ) 
{ 


  {
  if ((unsigned long )pxframe != (unsigned long )((struct xmit_frame *)0)) {
    pxframe->buf_addr = (u8 *)0U;
    pxframe->pxmitbuf = (struct xmit_buf *)0;
    memset((void *)(& pxframe->attrib), 0, 112UL);
    pxframe->frame_tag = 1;
    pxframe->pkt = (struct sk_buff *)0;
    pxframe->pkt_offset = 1;
    pxframe->ack_report = 0U;
  } else {

  }
  return;
}
}
static struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pxframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_queue *pfree_xmit_queue ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  pxframe = (struct xmit_frame *)0;
  pfree_xmit_queue = & pxmitpriv->free_xmit_queue;
  spin_lock_bh(& pfree_xmit_queue->lock);
  tmp = list_empty((struct list_head  const  *)(& pfree_xmit_queue->queue));
  if (tmp != 0) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(1, 7, "rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
    pxframe = (struct xmit_frame *)0;
  } else {
    phead = get_list_head(pfree_xmit_queue);
    plist = phead->next;
    __mptr = (struct list_head  const  *)plist;
    pxframe = (struct xmit_frame *)__mptr;
    list_del_init(& pxframe->list);
    pxmitpriv->free_xmitframe_cnt = pxmitpriv->free_xmitframe_cnt - 1;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(1, 7, "rtw_alloc_xmitframe():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
  }
  spin_unlock_bh(& pfree_xmit_queue->lock);
  rtw_init_xmitframe(pxframe);
  return (pxframe);
}
}
struct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pxframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_queue *queue ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  pxframe = (struct xmit_frame *)0;
  queue = & pxmitpriv->free_xframe_ext_queue;
  spin_lock_bh(& queue->lock);
  tmp = list_empty((struct list_head  const  *)(& queue->queue));
  if (tmp != 0) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(1, 7, "rtw_alloc_xmitframe23a_ext:%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
    pxframe = (struct xmit_frame *)0;
  } else {
    phead = get_list_head(queue);
    plist = phead->next;
    __mptr = (struct list_head  const  *)plist;
    pxframe = (struct xmit_frame *)__mptr;
    list_del_init(& pxframe->list);
    pxmitpriv->free_xframe_ext_cnt = pxmitpriv->free_xframe_ext_cnt - 1;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(1, 7, "rtw_alloc_xmitframe23a_ext():free_xmitframe_cnt =%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
  }
  spin_unlock_bh(& queue->lock);
  rtw_init_xmitframe(pxframe);
  return (pxframe);
}
}
s32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv , struct xmit_frame *pxmitframe ) 
{ 
  struct rtw_queue *queue ;
  struct rtw_adapter *padapter ;
  struct sk_buff *pndis_pkt ;
  struct list_head *tmp ;

  {
  queue = (struct rtw_queue *)0;
  padapter = pxmitpriv->adapter;
  pndis_pkt = (struct sk_buff *)0;
  if ((unsigned long )pxmitframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "====== rtw_free_xmitframe23a():pxmitframe == NULL!!!!!!!!!!\n");
    } else {

    }
    goto exit;
  } else {

  }
  if ((unsigned long )pxmitframe->pkt != (unsigned long )((struct sk_buff *)0)) {
    pndis_pkt = pxmitframe->pkt;
    pxmitframe->pkt = (struct sk_buff *)0;
  } else {

  }
  if ((unsigned int )pxmitframe->ext_tag == 0U) {
    queue = & pxmitpriv->free_xmit_queue;
  } else
  if ((unsigned int )pxmitframe->ext_tag == 1U) {
    queue = & pxmitpriv->free_xframe_ext_queue;
  } else {

  }
  if ((unsigned long )queue == (unsigned long )((struct rtw_queue *)0)) {
    goto check_pkt_complete;
  } else {

  }
  spin_lock_bh(& queue->lock);
  list_del_init(& pxmitframe->list);
  tmp = get_list_head(queue);
  list_add_tail(& pxmitframe->list, tmp);
  if ((unsigned int )pxmitframe->ext_tag == 0U) {
    pxmitpriv->free_xmitframe_cnt = pxmitpriv->free_xmitframe_cnt + 1;
    if (GlobalDebugLevel23A > 7U) {
      rt_trace(1, 8, "rtw_free_xmitframe23a():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
  } else
  if ((unsigned int )pxmitframe->ext_tag == 1U) {
    pxmitpriv->free_xframe_ext_cnt = pxmitpriv->free_xframe_ext_cnt + 1;
    if (GlobalDebugLevel23A > 7U) {
      rt_trace(1, 8, "rtw_free_xmitframe23a():free_xframe_ext_cnt =%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
  } else {

  }
  spin_unlock_bh(& queue->lock);
  check_pkt_complete: ;
  if ((unsigned long )pndis_pkt != (unsigned long )((struct sk_buff *)0)) {
    rtw_os_pkt_complete23a(padapter, pndis_pkt);
  } else {

  }
  exit: ;
  return (1);
}
}
void rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv , struct rtw_queue *pframequeue ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct list_head  const  *__mptr ;

  {
  spin_lock_bh(& pframequeue->lock);
  phead = get_list_head(pframequeue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53726;
  ldv_53725: 
  __mptr = (struct list_head  const  *)plist;
  pxmitframe = (struct xmit_frame *)__mptr;
  rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_53726: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53725;
  } else {

  }
  spin_unlock_bh(& pframequeue->lock);
  return;
}
}
s32 rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  s32 tmp ;

  {
  tmp = rtw_xmit23a_classifier(padapter, pxmitframe);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "rtw_xmitframe_enqueue23a: drop xmit pkt for classifier fail\n");
    } else {

    }
    return (0);
  } else {

  }
  return (1);
}
}
static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit ,
                                                struct tx_servq *ptxservq , struct rtw_queue *pframe_queue ) 
{ 
  struct list_head *phead ;
  struct xmit_frame *pxmitframe ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  pxmitframe = (struct xmit_frame *)0;
  phead = get_list_head(pframe_queue);
  tmp = list_empty((struct list_head  const  *)phead);
  if (tmp == 0) {
    __mptr = (struct list_head  const  *)phead->next;
    pxmitframe = (struct xmit_frame *)__mptr;
    list_del_init(& pxmitframe->list);
    ptxservq->qcnt = ptxservq->qcnt - 1;
  } else {

  }
  return (pxmitframe);
}
}
struct xmit_frame *rtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit_i ,
                                         int entry ) 
{ 
  struct list_head *sta_plist ;
  struct list_head *sta_phead ;
  struct list_head *ptmp ;
  struct hw_xmit *phwxmit ;
  struct tx_servq *ptxservq ;
  struct rtw_queue *pframe_queue ;
  struct xmit_frame *pxmitframe ;
  struct rtw_adapter *padapter ;
  struct registry_priv *pregpriv ;
  int i ;
  int inx[4U] ;
  int j ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  ptxservq = (struct tx_servq *)0;
  pframe_queue = (struct rtw_queue *)0;
  pxmitframe = (struct xmit_frame *)0;
  padapter = pxmitpriv->adapter;
  pregpriv = & padapter->registrypriv;
  inx[0] = 0;
  inx[1] = 1;
  inx[2] = 2;
  inx[3] = 3;
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
    j = 0;
    goto ldv_53760;
    ldv_53759: 
    inx[j] = (int )pxmitpriv->wmm_para_seq[j];
    j = j + 1;
    ldv_53760: ;
    if (j <= 3) {
      goto ldv_53759;
    } else {

    }

  } else {

  }
  spin_lock_bh(& pxmitpriv->lock);
  i = 0;
  goto ldv_53769;
  ldv_53768: 
  phwxmit = phwxmit_i + (unsigned long )inx[i];
  sta_phead = get_list_head(phwxmit->sta_queue);
  sta_plist = sta_phead->next;
  ptmp = sta_plist->next;
  goto ldv_53766;
  ldv_53765: 
  __mptr = (struct list_head  const  *)sta_plist;
  ptxservq = (struct tx_servq *)__mptr;
  pframe_queue = & ptxservq->sta_pending;
  pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
  if ((unsigned long )pxmitframe != (unsigned long )((struct xmit_frame *)0)) {
    phwxmit->accnt = phwxmit->accnt - 1;
    tmp = list_empty((struct list_head  const  *)(& pframe_queue->queue));
    if (tmp != 0) {
      list_del_init(& ptxservq->tx_pending);
    } else {

    }
    goto exit;
  } else {

  }
  sta_plist = ptmp;
  ptmp = sta_plist->next;
  ldv_53766: ;
  if ((unsigned long )sta_plist != (unsigned long )sta_phead) {
    goto ldv_53765;
  } else {

  }
  i = i + 1;
  ldv_53769: ;
  if (i < entry) {
    goto ldv_53768;
  } else {

  }

  exit: 
  spin_unlock_bh(& pxmitpriv->lock);
  return (pxmitframe);
}
}
struct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter , struct sta_info *psta ,
                                        int up___0 , u8 *ac ) 
{ 
  struct tx_servq *ptxservq ;

  {
  ptxservq = (struct tx_servq *)0;
  switch (up___0) {
  case 1: ;
  case 2: 
  ptxservq = & psta->sta_xmitpriv.bk_q;
  *ac = 3U;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "rtw_get_sta_pending23a : BK\n");
  } else {

  }
  goto ldv_53780;
  case 4: ;
  case 5: 
  ptxservq = & psta->sta_xmitpriv.vi_q;
  *ac = 1U;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "rtw_get_sta_pending23a : VI\n");
  } else {

  }
  goto ldv_53780;
  case 6: ;
  case 7: 
  ptxservq = & psta->sta_xmitpriv.vo_q;
  *ac = 0U;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "rtw_get_sta_pending23a : VO\n");
  } else {

  }
  goto ldv_53780;
  case 0: ;
  case 3: ;
  default: 
  ptxservq = & psta->sta_xmitpriv.be_q;
  *ac = 2U;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "rtw_get_sta_pending23a : BE\n");
  } else {

  }
  goto ldv_53780;
  }
  ldv_53780: ;
  return (ptxservq);
}
}
s32 rtw_xmit23a_classifier(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  struct pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct hw_xmit *phwxmits ;
  u8 ac_index ;
  int res ;
  struct list_head *tmp ;
  int tmp___0 ;
  struct list_head *tmp___1 ;

  {
  pattrib = & pxmitframe->attrib;
  pstapriv = & padapter->stapriv;
  phwxmits = padapter->xmitpriv.hwxmits;
  res = 1;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_xmit23a_classifier");
    } else {

    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_xmit23a_classifier: psta == NULL\n");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "rtw_xmit23a_classifier: psta == NULL\n");
    } else {

    }
    goto exit;
  } else {

  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_xmit23a_classifier",
             psta->state);
    } else {

    }
    return (0);
  } else {

  }
  ptxservq = rtw_get_sta_pending23a(padapter, psta, (int )pattrib->priority, & ac_index);
  tmp___0 = list_empty((struct list_head  const  *)(& ptxservq->tx_pending));
  if (tmp___0 != 0) {
    tmp = get_list_head((phwxmits + (unsigned long )ac_index)->sta_queue);
    list_add_tail(& ptxservq->tx_pending, tmp);
  } else {

  }
  tmp___1 = get_list_head(& ptxservq->sta_pending);
  list_add_tail(& pxmitframe->list, tmp___1);
  ptxservq->qcnt = ptxservq->qcnt + 1;
  (phwxmits + (unsigned long )ac_index)->accnt = (phwxmits + (unsigned long )ac_index)->accnt + 1;
  exit: ;
  return (res);
}
}
void rtw_alloc_hwxmits23a(struct rtw_adapter *padapter ) 
{ 
  struct hw_xmit *hwxmits ;
  struct xmit_priv *pxmitpriv ;
  int size ;
  void *tmp ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pxmitpriv->hwxmit_entry = 4U;
  size = ((int )pxmitpriv->hwxmit_entry + 1) * 16;
  tmp = kzalloc((size_t )size, 208U);
  pxmitpriv->hwxmits = (struct hw_xmit *)tmp;
  hwxmits = pxmitpriv->hwxmits;
  if ((unsigned int )pxmitpriv->hwxmit_entry == 5U) {
    hwxmits->sta_queue = & pxmitpriv->bm_pending;
    (hwxmits + 1UL)->sta_queue = & pxmitpriv->vo_pending;
    (hwxmits + 2UL)->sta_queue = & pxmitpriv->vi_pending;
    (hwxmits + 3UL)->sta_queue = & pxmitpriv->bk_pending;
    (hwxmits + 4UL)->sta_queue = & pxmitpriv->be_pending;
  } else
  if ((unsigned int )pxmitpriv->hwxmit_entry == 4U) {
    hwxmits->sta_queue = & pxmitpriv->vo_pending;
    (hwxmits + 1UL)->sta_queue = & pxmitpriv->vi_pending;
    (hwxmits + 2UL)->sta_queue = & pxmitpriv->be_pending;
    (hwxmits + 3UL)->sta_queue = & pxmitpriv->bk_pending;
  } else {

  }
  return;
}
}
void rtw_free_hwxmits23a(struct rtw_adapter *padapter ) 
{ 
  struct hw_xmit *hwxmits ;
  struct xmit_priv *pxmitpriv ;

  {
  pxmitpriv = & padapter->xmitpriv;
  hwxmits = pxmitpriv->hwxmits;
  kfree((void const   *)hwxmits);
  return;
}
}
void rtw_init_hwxmits23a(struct hw_xmit *phwxmit , int entry ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53818;
  ldv_53817: 
  phwxmit->accnt = 0;
  i = i + 1;
  phwxmit = phwxmit + 1;
  ldv_53818: ;
  if (i < entry) {
    goto ldv_53817;
  } else {

  }

  return;
}
}
u32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe ) 
{ 
  u32 addr ;
  struct pkt_attrib *pattrib ;

  {
  pattrib = & pxmitframe->attrib;
  switch ((int )pattrib->qsel) {
  case 0: ;
  case 3: 
  addr = 2U;
  goto ldv_53827;
  case 1: ;
  case 2: 
  addr = 3U;
  goto ldv_53827;
  case 4: ;
  case 5: 
  addr = 1U;
  goto ldv_53827;
  case 6: ;
  case 7: 
  addr = 0U;
  goto ldv_53827;
  case 16: 
  addr = 4U;
  goto ldv_53827;
  case 17: 
  addr = 6U;
  goto ldv_53827;
  case 18: ;
  default: 
  addr = 5U;
  goto ldv_53827;
  }
  ldv_53827: ;
  return (addr);
}
}
int rtw_xmit23a(struct rtw_adapter *padapter , struct sk_buff *skb ) 
{ 
  struct xmit_priv *pxmitpriv ;
  struct xmit_frame *pxmitframe ;
  int res ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  pxmitframe = (struct xmit_frame *)0;
  pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
  if ((unsigned long )pxmitframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2, 4, "rtw_xmit23a: no more pxmitframe\n");
    } else {

    }
    return (-1);
  } else {

  }
  res = update_attrib(padapter, skb, & pxmitframe->attrib);
  if (res == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2, 4, "rtw_xmit23a: update attrib fail\n");
    } else {

    }
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    return (-1);
  } else {

  }
  pxmitframe->pkt = skb;
  pxmitframe->attrib.qsel = pxmitframe->attrib.priority;
  spin_lock_bh(& pxmitpriv->lock);
  tmp = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
  if (tmp != 0) {
    spin_unlock_bh(& pxmitpriv->lock);
    return (1);
  } else {

  }
  spin_unlock_bh(& pxmitpriv->lock);
  tmp___0 = rtl8723au_hal_xmit(padapter, pxmitframe);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {

  }
  return (0);
}
}
int xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int ret ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct pkt_attrib *pattrib ;
  struct mlme_priv *pmlmepriv ;
  int bmcst ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct list_head *tmp___2 ;
  u8 wmmps_ac ;
  struct list_head *tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;

  {
  ret = 0;
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  pattrib = & pxmitframe->attrib;
  pmlmepriv = & padapter->mlmepriv;
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  bmcst = (int )tmp;
  tmp___0 = check_fwstate(pmlmepriv, 16);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (ret);
  } else {

  }
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "xmitframe_enqueue_for_sleeping_sta23a");
    } else {

    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "xmitframe_enqueue_for_sleeping_sta23a");
    } else {

    }
    return (0);
  } else {

  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "xmitframe_enqueue_for_sleeping_sta23a",
             psta->state);
    } else {

    }
    return (0);
  } else {

  }
  if ((unsigned int )pattrib->triggered == 1U) {
    if (bmcst != 0) {
      pattrib->qsel = 17U;
    } else {

    }
    return (ret);
  } else {

  }
  if (bmcst != 0) {
    spin_lock_bh(& psta->sleep_q.lock);
    if ((unsigned int )pstapriv->sta_dz_bitmap != 0U) {
      list_del_init(& pxmitframe->list);
      tmp___2 = get_list_head(& psta->sleep_q);
      list_add_tail(& pxmitframe->list, tmp___2);
      psta->sleepq_len = psta->sleepq_len + 1U;
      pstapriv->tim_bitmap = (u16 )((unsigned int )pstapriv->tim_bitmap | 1U);
      pstapriv->sta_dz_bitmap = (u16 )((unsigned int )pstapriv->sta_dz_bitmap | 1U);
      update_beacon23a(padapter, 5, (u8 *)0U, 0);
      ret = 1;
    } else {

    }
    spin_unlock_bh(& psta->sleep_q.lock);
    return (ret);
  } else {

  }
  spin_lock_bh(& psta->sleep_q.lock);
  if ((psta->state & 4U) != 0U) {
    wmmps_ac = 0U;
    tmp___5 = CHKBIT(psta->aid);
    if (((u32 )pstapriv->sta_dz_bitmap & tmp___5) != 0U) {
      list_del_init(& pxmitframe->list);
      tmp___3 = get_list_head(& psta->sleep_q);
      list_add_tail(& pxmitframe->list, tmp___3);
      psta->sleepq_len = psta->sleepq_len + 1U;
      switch ((int )pattrib->priority) {
      case 1: ;
      case 2: 
      wmmps_ac = (unsigned int )psta->uapsd_bk & 1U;
      goto ldv_53859;
      case 4: ;
      case 5: 
      wmmps_ac = (unsigned int )psta->uapsd_vi & 1U;
      goto ldv_53859;
      case 6: ;
      case 7: 
      wmmps_ac = (unsigned int )psta->uapsd_vo & 1U;
      goto ldv_53859;
      case 0: ;
      case 3: ;
      default: 
      wmmps_ac = (unsigned int )psta->uapsd_be & 1U;
      goto ldv_53859;
      }
      ldv_53859: ;
      if ((unsigned int )wmmps_ac != 0U) {
        psta->sleepq_ac_len = psta->sleepq_ac_len + 1U;
      } else {

      }
      if (((unsigned int )psta->has_legacy_ac != 0U && (unsigned int )wmmps_ac == 0U) || ((unsigned int )psta->has_legacy_ac == 0U && (unsigned int )wmmps_ac != 0U)) {
        tmp___4 = CHKBIT(psta->aid);
        pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap | (int )((u16 )tmp___4);
        if (psta->sleepq_len == 1U) {
          update_beacon23a(padapter, 5, (u8 *)0U, 0);
        } else {

        }
      } else {

      }
      ret = 1;
    } else {

    }
  } else {

  }
  spin_unlock_bh(& psta->sleep_q.lock);
  return (ret);
}
}
static void dequeue_xmitframes_to_sleeping_queue(struct rtw_adapter *padapter , struct sta_info *psta ,
                                                 struct rtw_queue *pframequeue ) 
{ 
  int ret ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  u8 ac_index ;
  struct tx_servq *ptxservq ;
  struct pkt_attrib *pattrib ;
  struct xmit_frame *pxmitframe ;
  struct hw_xmit *phwxmits ;
  struct list_head  const  *__mptr ;

  {
  phwxmits = padapter->xmitpriv.hwxmits;
  phead = get_list_head(pframequeue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53884;
  ldv_53883: 
  __mptr = (struct list_head  const  *)plist;
  pxmitframe = (struct xmit_frame *)__mptr;
  ret = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
  if (ret == 1) {
    pattrib = & pxmitframe->attrib;
    ptxservq = rtw_get_sta_pending23a(padapter, psta, (int )pattrib->priority, & ac_index);
    ptxservq->qcnt = ptxservq->qcnt - 1;
    (phwxmits + (unsigned long )ac_index)->accnt = (phwxmits + (unsigned long )ac_index)->accnt - 1;
  } else {

  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_53884: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53883;
  } else {

  }

  return;
}
}
void stop_sta_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct sta_info *psta_bmc ;
  struct sta_xmit_priv *pstaxmitpriv ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  u32 tmp ;

  {
  pstapriv = & padapter->stapriv;
  pxmitpriv = & padapter->xmitpriv;
  pstaxmitpriv = & psta->sta_xmitpriv;
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
  spin_lock_bh(& pxmitpriv->lock);
  psta->state = psta->state | 4U;
  tmp = CHKBIT(psta->aid);
  pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap | (int )((u16 )tmp);
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->vo_q.sta_pending);
  list_del_init(& pstaxmitpriv->vo_q.tx_pending);
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->vi_q.sta_pending);
  list_del_init(& pstaxmitpriv->vi_q.tx_pending);
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->be_q.sta_pending);
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->bk_q.sta_pending);
  list_del_init(& pstaxmitpriv->bk_q.tx_pending);
  pstaxmitpriv = & psta_bmc->sta_xmitpriv;
  dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, & pstaxmitpriv->be_q.sta_pending);
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
  spin_unlock_bh(& pxmitpriv->lock);
  return;
}
}
void wakeup_sta_to_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 update_mask ;
  u8 wmmps_ac ;
  struct sta_info *psta_bmc ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp ;
  u32 tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
  update_mask = 0U;
  wmmps_ac = 0U;
  pxmitframe = (struct xmit_frame *)0;
  pstapriv = & padapter->stapriv;
  pxmitpriv = & padapter->xmitpriv;
  spin_lock_bh(& pxmitpriv->lock);
  phead = get_list_head(& psta->sleep_q);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53920;
  ldv_53919: 
  __mptr = (struct list_head  const  *)plist;
  pxmitframe = (struct xmit_frame *)__mptr;
  list_del_init(& pxmitframe->list);
  switch ((int )pxmitframe->attrib.priority) {
  case 1: ;
  case 2: 
  wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
  goto ldv_53911;
  case 4: ;
  case 5: 
  wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
  goto ldv_53911;
  case 6: ;
  case 7: 
  wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
  goto ldv_53911;
  case 0: ;
  case 3: ;
  default: 
  wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
  goto ldv_53911;
  }
  ldv_53911: 
  psta->sleepq_len = psta->sleepq_len - 1U;
  if (psta->sleepq_len != 0U) {
    pxmitframe->attrib.mdata = 1U;
  } else {
    pxmitframe->attrib.mdata = 0U;
  }
  if ((unsigned int )wmmps_ac != 0U) {
    psta->sleepq_ac_len = psta->sleepq_ac_len - 1U;
    if (psta->sleepq_ac_len != 0U) {
      pxmitframe->attrib.mdata = 1U;
      pxmitframe->attrib.eosp = 0U;
    } else {
      pxmitframe->attrib.mdata = 0U;
      pxmitframe->attrib.eosp = 1U;
    }
  } else {

  }
  pxmitframe->attrib.triggered = 1U;
  rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_53920: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53919;
  } else {

  }

  if (psta->sleepq_len == 0U) {
    tmp = CHKBIT(psta->aid);
    pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp));
    update_mask = 1U;
    if ((psta->state & 4U) != 0U) {
      psta->state = psta->state ^ 4U;
    } else {

    }
    if ((psta->state & 1024U) != 0U) {
      psta->expire_to = pstapriv->expire_to;
      psta->state = psta->state ^ 1024U;
    } else {

    }
    tmp___0 = CHKBIT(psta->aid);
    pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap & ~ ((int )((u16 )tmp___0));
  } else {

  }
  spin_unlock_bh(& pxmitpriv->lock);
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
  if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {

  }
  if (((int )pstapriv->sta_dz_bitmap & 65534) == 0) {
    spin_lock_bh(& pxmitpriv->lock);
    phead = get_list_head(& psta_bmc->sleep_q);
    plist = phead->next;
    ptmp = plist->next;
    goto ldv_53925;
    ldv_53924: 
    __mptr___0 = (struct list_head  const  *)plist;
    pxmitframe = (struct xmit_frame *)__mptr___0;
    list_del_init(& pxmitframe->list);
    psta_bmc->sleepq_len = psta_bmc->sleepq_len - 1U;
    if (psta_bmc->sleepq_len != 0U) {
      pxmitframe->attrib.mdata = 1U;
    } else {
      pxmitframe->attrib.mdata = 0U;
    }
    pxmitframe->attrib.triggered = 1U;
    rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
    plist = ptmp;
    ptmp = plist->next;
    ldv_53925: ;
    if ((unsigned long )plist != (unsigned long )phead) {
      goto ldv_53924;
    } else {

    }

    if (psta_bmc->sleepq_len == 0U) {
      pstapriv->tim_bitmap = (unsigned int )pstapriv->tim_bitmap & 65534U;
      pstapriv->sta_dz_bitmap = (unsigned int )pstapriv->sta_dz_bitmap & 65534U;
      update_mask = (u8 )((unsigned int )update_mask | 2U);
    } else {

    }
    spin_unlock_bh(& pxmitpriv->lock);
  } else {

  }
  if ((unsigned int )update_mask != 0U) {
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
  } else {

  }
  return;
}
}
void xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 wmmps_ac ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp ;

  {
  wmmps_ac = 0U;
  pstapriv = & padapter->stapriv;
  pxmitpriv = & padapter->xmitpriv;
  spin_lock_bh(& pxmitpriv->lock);
  phead = get_list_head(& psta->sleep_q);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53952;
  ldv_53951: 
  __mptr = (struct list_head  const  *)plist;
  pxmitframe = (struct xmit_frame *)__mptr;
  switch ((int )pxmitframe->attrib.priority) {
  case 1: ;
  case 2: 
  wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
  goto ldv_53942;
  case 4: ;
  case 5: 
  wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
  goto ldv_53942;
  case 6: ;
  case 7: 
  wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
  goto ldv_53942;
  case 0: ;
  case 3: ;
  default: 
  wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
  goto ldv_53942;
  }
  ldv_53942: ;
  if ((unsigned int )wmmps_ac == 0U) {
    goto ldv_53950;
  } else {

  }
  list_del_init(& pxmitframe->list);
  psta->sleepq_len = psta->sleepq_len - 1U;
  psta->sleepq_ac_len = psta->sleepq_ac_len - 1U;
  if (psta->sleepq_ac_len != 0U) {
    pxmitframe->attrib.mdata = 1U;
    pxmitframe->attrib.eosp = 0U;
  } else {
    pxmitframe->attrib.mdata = 0U;
    pxmitframe->attrib.eosp = 1U;
  }
  pxmitframe->attrib.triggered = 1U;
  rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
  if ((psta->sleepq_ac_len == 0U && (unsigned int )psta->has_legacy_ac == 0U) && (unsigned int )wmmps_ac != 0U) {
    tmp = CHKBIT(psta->aid);
    pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp));
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
  } else {

  }
  ldv_53950: 
  plist = ptmp;
  ptmp = plist->next;
  ldv_53952: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53951;
  } else {

  }
  spin_unlock_bh(& pxmitpriv->lock);
  return;
}
}
void rtw_sctx_init23a(struct submit_ctx *sctx , int timeout_ms ) 
{ 


  {
  sctx->timeout_ms = (u32 )timeout_ms;
  init_completion(& sctx->done);
  sctx->status = -1;
  return;
}
}
int rtw_sctx_wait23a(struct submit_ctx *sctx ) 
{ 
  int ret ;
  unsigned long expire ;
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  ret = 0;
  status = 0;
  if (sctx->timeout_ms != 0U) {
    tmp = msecs_to_jiffies(sctx->timeout_ms);
    expire = tmp;
  } else {
    expire = 9223372036854775807UL;
  }
  tmp___0 = wait_for_completion_timeout(& sctx->done, expire);
  if (tmp___0 == 0UL) {
    status = 2;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s timeout\n", "rtw_sctx_wait23a");
    } else {

    }
  } else {
    status = sctx->status;
  }
  if (status == 0) {
    ret = 1;
  } else {

  }
  return (ret);
}
}
static bool rtw_sctx_chk_waring_status(int status ) 
{ 


  {
  switch (status) {
  case 1: ;
  case 3: ;
  case 4: ;
  case 9: ;
  case 10: ;
  return (1);
  default: ;
  return (0);
  }
}
}
void rtw23a_sctx_done_err(struct submit_ctx **sctx , int status ) 
{ 
  bool tmp ;

  {
  if ((unsigned long )*sctx != (unsigned long )((struct submit_ctx *)0)) {
    tmp = rtw_sctx_chk_waring_status(status);
    if ((int )tmp) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s status:%d\n", "rtw23a_sctx_done_err", status);
      } else {

      }
    } else {

    }
    (*sctx)->status = status;
    complete(& (*sctx)->done);
    *sctx = (struct submit_ctx *)0;
  } else {

  }
  return;
}
}
int rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv , u32 timeout_ms ) 
{ 
  struct submit_ctx *pack_tx_ops ;
  int tmp ;

  {
  pack_tx_ops = & pxmitpriv->ack_tx_ops;
  pack_tx_ops->timeout_ms = timeout_ms;
  pack_tx_ops->status = -1;
  tmp = rtw_sctx_wait23a(pack_tx_ops);
  return (tmp);
}
}
bool ldv_queue_work_on_243(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_244(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_245(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_246(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_247(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_258(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_260(struct workqueue_struct *ldv_func_arg1 ) ;
void PHY_SetBWMode23a8723A(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ,
                           unsigned char Offset ) ;
void PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) ;
void rtw_hal_update_ra_mask23a(struct sta_info *psta , u8 rssi_level ) ;
void rtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter , u8 MinSpacingToSet ) ;
void rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter , u8 FactorToSet ) ;
void rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter , u8 ctrl ) ;
void rtl8723a_set_slot_time(struct rtw_adapter *padapter , u8 slottime ) ;
void rtl8723a_ack_preamble(struct rtw_adapter *padapter , u8 bShortPreamble ) ;
void rtl8723a_cam_invalidate_all(struct rtw_adapter *padapter ) ;
void rtl8723a_set_resp_sifs(struct rtw_adapter *padapter , u8 r2t1 , u8 r2t2 , u8 t2t1 ,
                            u8 t2t2 ) ;
void rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter , u32 vo ) ;
void rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter , u32 vi ) ;
void rtl8723a_set_ac_param_be(struct rtw_adapter *padapter , u32 be ) ;
void rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter , u32 bk ) ;
unsigned char networktype_to_raid23a(unsigned char network_type ) ;
u8 judge_network_type23a(struct rtw_adapter *padapter , unsigned char *rate , int ratelen ) ;
__inline void rtw_set_oper_ch23a(struct rtw_adapter *adapter , u8 ch ) ;
__inline void rtw_set_oper_bw23a(struct rtw_adapter *adapter , u8 bw ) ;
__inline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter , u8 offset ) ;
unsigned int update_basic_rate23a(unsigned char *ptn , unsigned int ptn_sz ) ;
unsigned int update_supported_rate23a(unsigned char *ptn , unsigned int ptn_sz ) ;
unsigned int update_MSC_rate23a(struct ieee80211_ht_cap *pHT_caps ) ;
unsigned char get_highest_rate_idx23a(u32 mask ) ;
bool is_ap_in_wep23a(struct rtw_adapter *padapter ) ;
bool should_forbid_n_rate23a(struct rtw_adapter *padapter ) ;
int cckrates_included23a(unsigned char *rate , int ratelen ) ;
int cckratesonly_included23a(unsigned char *rate , int ratelen ) ;
static unsigned char ARTHEROS_OUI1[3U]  = {      0U,      3U,      127U};
static unsigned char ARTHEROS_OUI2[3U]  = {      0U,      19U,      116U};
static unsigned char BROADCOM_OUI1[3U]  = {      0U,      16U,      24U};
static unsigned char BROADCOM_OUI2[3U]  = {      0U,      10U,      247U};
static unsigned char CISCO_OUI[3U]  = {      0U,      64U,      150U};
static unsigned char MARVELL_OUI[3U]  = {      0U,      80U,      67U};
static unsigned char RALINK_OUI[3U]  = {      0U,      12U,      67U};
static unsigned char REALTEK_OUI[3U]  = {      0U,      224U,      76U};
static unsigned char AIRGOCAP_OUI[3U]  = {      0U,      10U,      245U};
static unsigned char EPIGRAM_OUI[3U]  = {      0U,      144U,      76U};
static unsigned char WPA_TKIP_CIPHER[4U]  = {      0U,      80U,      242U,      2U};
static unsigned char RSN_TKIP_CIPHER[4U]  = {      0U,      15U,      172U,      2U};
static u8 rtw_basic_rate_cck[4U]  = {      130U,      132U,      139U,      150U};
static u8 rtw_basic_rate_ofdm[3U]  = {      140U,      152U,      176U};
static u8 rtw_basic_rate_mix[7U]  = {      130U,      132U,      139U,      150U, 
        140U,      152U,      176U};
int cckrates_included23a(unsigned char *rate , int ratelen ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53201;
  ldv_53200: ;
  if (((((int )*(rate + (unsigned long )i) & 127) == 2 || ((int )*(rate + (unsigned long )i) & 127) == 4) || ((int )*(rate + (unsigned long )i) & 127) == 11) || ((int )*(rate + (unsigned long )i) & 127) == 22) {
    return (1);
  } else {

  }
  i = i + 1;
  ldv_53201: ;
  if (i < ratelen) {
    goto ldv_53200;
  } else {

  }

  return (0);
}
}
int cckratesonly_included23a(unsigned char *rate , int ratelen ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53209;
  ldv_53208: ;
  if (((((int )*(rate + (unsigned long )i) & 127) != 2 && ((int )*(rate + (unsigned long )i) & 127) != 4) && ((int )*(rate + (unsigned long )i) & 127) != 11) && ((int )*(rate + (unsigned long )i) & 127) != 22) {
    return (0);
  } else {

  }
  i = i + 1;
  ldv_53209: ;
  if (i < ratelen) {
    goto ldv_53208;
  } else {

  }

  return (1);
}
}
unsigned char networktype_to_raid23a(unsigned char network_type ) 
{ 
  unsigned char raid ;

  {
  switch ((int )network_type) {
  case 1: 
  raid = 6U;
  goto ldv_53216;
  case 4: ;
  case 2: 
  raid = 5U;
  goto ldv_53216;
  case 3: 
  raid = 4U;
  goto ldv_53216;
  case 8: ;
  case 16: 
  raid = 3U;
  goto ldv_53216;
  case 20: ;
  case 10: 
  raid = 1U;
  goto ldv_53216;
  case 11: 
  raid = 0U;
  goto ldv_53216;
  default: 
  raid = 4U;
  goto ldv_53216;
  }
  ldv_53216: ;
  return (raid);
}
}
u8 judge_network_type23a(struct rtw_adapter *padapter , unsigned char *rate , int ratelen ) 
{ 
  u8 network_type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;
  int tmp___0 ;

  {
  network_type = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
      network_type = 16U;
    } else {

    }
    network_type = (u8 )((unsigned int )network_type | 4U);
  } else {
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
      network_type = 8U;
    } else {

    }
    tmp___0 = cckratesonly_included23a(rate, ratelen);
    if (tmp___0 == 1) {
      network_type = (u8 )((unsigned int )network_type | 1U);
    } else {
      tmp = cckrates_included23a(rate, ratelen);
      if (tmp == 1) {
        network_type = (u8 )((unsigned int )network_type | 3U);
      } else {
        network_type = (u8 )((unsigned int )network_type | 2U);
      }
    }
  }
  return (network_type);
}
}
static unsigned char ratetbl_val_2wifirate(unsigned char rate ) 
{ 
  unsigned char val ;

  {
  val = 0U;
  switch ((int )rate & 127) {
  case 0: 
  val = 2U;
  goto ldv_53239;
  case 1: 
  val = 4U;
  goto ldv_53239;
  case 2: 
  val = 11U;
  goto ldv_53239;
  case 3: 
  val = 22U;
  goto ldv_53239;
  case 4: 
  val = 12U;
  goto ldv_53239;
  case 5: 
  val = 18U;
  goto ldv_53239;
  case 6: 
  val = 24U;
  goto ldv_53239;
  case 7: 
  val = 36U;
  goto ldv_53239;
  case 8: 
  val = 48U;
  goto ldv_53239;
  case 9: 
  val = 72U;
  goto ldv_53239;
  case 10: 
  val = 96U;
  goto ldv_53239;
  case 11: 
  val = 108U;
  goto ldv_53239;
  }
  ldv_53239: ;
  return (val);
}
}
static int is_basicrate(struct rtw_adapter *padapter , unsigned char rate ) 
{ 
  int i ;
  unsigned char val ;
  struct mlme_ext_priv *pmlmeext ;
  unsigned char tmp ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  i = 0;
  goto ldv_53259;
  ldv_53258: 
  val = pmlmeext->basicrate[i];
  if ((unsigned int )val != 255U && (unsigned int )val != 254U) {
    tmp = ratetbl_val_2wifirate((int )val);
    if ((int )tmp == (int )rate) {
      return (1);
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_53259: ;
  if (i <= 12) {
    goto ldv_53258;
  } else {

  }

  return (0);
}
}
static unsigned int ratetbl2rateset(struct rtw_adapter *padapter , unsigned char *rateset ) 
{ 
  int i ;
  unsigned char rate ;
  unsigned int len ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;

  {
  len = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  i = 0;
  goto ldv_53275;
  ldv_53274: 
  rate = pmlmeext->datarate[i];
  switch ((int )rate) {
  case 255: ;
  return (len);
  case 254: ;
  goto ldv_53271;
  default: 
  rate = ratetbl_val_2wifirate((int )rate);
  tmp = is_basicrate(padapter, (int )rate);
  if (tmp == 1) {
    rate = (unsigned int )rate | 128U;
  } else {

  }
  *(rateset + (unsigned long )len) = rate;
  len = len + 1U;
  goto ldv_53273;
  }
  ldv_53273: ;
  ldv_53271: 
  i = i + 1;
  ldv_53275: ;
  if (i <= 12) {
    goto ldv_53274;
  } else {

  }

  return (len);
}
}
void get_rate_set23a(struct rtw_adapter *padapter , unsigned char *pbssrate , int *bssrate_len ) 
{ 
  unsigned char supportedrates[13U] ;
  unsigned int tmp ;

  {
  memset((void *)(& supportedrates), 0, 13UL);
  tmp = ratetbl2rateset(padapter, (unsigned char *)(& supportedrates));
  *bssrate_len = (int )tmp;
  memcpy((void *)pbssrate, (void const   *)(& supportedrates), (size_t )*bssrate_len);
  return;
}
}
void UpdateBrateTbl23a(struct rtw_adapter *Adapter , u8 *mBratesOS ) 
{ 
  u8 i ;
  u8 rate ;

  {
  i = 0U;
  goto ldv_53299;
  ldv_53298: 
  rate = (unsigned int )*(mBratesOS + (unsigned long )i) & 127U;
  switch ((int )rate) {
  case 2: ;
  case 4: ;
  case 11: ;
  case 22: ;
  case 12: ;
  case 24: ;
  case 48: 
  *(mBratesOS + (unsigned long )i) = (u8 )((unsigned int )*(mBratesOS + (unsigned long )i) | 128U);
  goto ldv_53296;
  default: ;
  goto ldv_53296;
  }
  ldv_53296: 
  i = (u8 )((int )i + 1);
  ldv_53299: ;
  if ((unsigned int )i <= 15U) {
    goto ldv_53298;
  } else {

  }

  return;
}
}
void Update23aTblForSoftAP(u8 *bssrateset , u32 bssratelen ) 
{ 
  u8 i ;
  u8 rate ;

  {
  i = 0U;
  goto ldv_53313;
  ldv_53312: 
  rate = (unsigned int )*(bssrateset + (unsigned long )i) & 127U;
  switch ((int )rate) {
  case 2: ;
  case 4: ;
  case 11: ;
  case 22: 
  *(bssrateset + (unsigned long )i) = (u8 )((unsigned int )*(bssrateset + (unsigned long )i) | 128U);
  goto ldv_53311;
  }
  ldv_53311: 
  i = (u8 )((int )i + 1);
  ldv_53313: ;
  if ((u32 )i < bssratelen) {
    goto ldv_53312;
  } else {

  }

  return;
}
}
__inline void rtw_set_oper_ch23a(struct rtw_adapter *adapter , u8 ch ) 
{ 


  {
  (adapter->dvobj)->oper_channel = ch;
  return;
}
}
__inline void rtw_set_oper_bw23a(struct rtw_adapter *adapter , u8 bw ) 
{ 


  {
  (adapter->dvobj)->oper_bwmode = bw;
  return;
}
}
__inline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter , u8 offset ) 
{ 


  {
  (adapter->dvobj)->oper_ch_offset = offset;
  return;
}
}
void SelectChannel23a(struct rtw_adapter *padapter , unsigned char channel ) 
{ 


  {
  mutex_lock_nested(& (padapter->dvobj)->setch_mutex, 0U);
  rtw_set_oper_ch23a(padapter, (int )channel);
  PHY_SwChnl8723A(padapter, (int )channel);
  mutex_unlock(& (padapter->dvobj)->setch_mutex);
  return;
}
}
static void set_bwmode(struct rtw_adapter *padapter , unsigned short bwmode , unsigned char channel_offset ) 
{ 


  {
  mutex_lock_nested(& (padapter->dvobj)->setbw_mutex, 0U);
  rtw_set_oper_bw23a(padapter, (int )((u8 )bwmode));
  rtw_set_oper_ch23aoffset23a(padapter, (int )channel_offset);
  PHY_SetBWMode23a8723A(padapter, (enum ht_channel_width )bwmode, (int )channel_offset);
  mutex_unlock(& (padapter->dvobj)->setbw_mutex);
  return;
}
}
void set_channel_bwmode23a(struct rtw_adapter *padapter , unsigned char channel ,
                           unsigned char channel_offset , unsigned short bwmode ) 
{ 
  u8 center_ch ;

  {
  if ((unsigned int )bwmode == 0U || (unsigned int )channel_offset == 0U) {
    center_ch = channel;
  } else
  if ((unsigned int )channel_offset == 1U) {
    center_ch = (unsigned int )channel + 2U;
  } else {
    center_ch = (unsigned int )channel + 254U;
  }
  mutex_lock_nested(& (padapter->dvobj)->setch_mutex, 0U);
  rtw_set_oper_ch23a(padapter, (int )channel);
  rtw_set_oper_bw23a(padapter, (int )((u8 )bwmode));
  rtw_set_oper_ch23aoffset23a(padapter, (int )channel_offset);
  PHY_SwChnl8723A(padapter, (int )center_ch);
  mutex_unlock(& (padapter->dvobj)->setch_mutex);
  set_bwmode(padapter, (int )bwmode, (int )channel_offset);
  return;
}
}
bool is_client_associated_to_ap23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return (0);
  } else {

  }
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((pmlmeinfo->state & 16384U) != 0U && (pmlmeinfo->state & 3U) == 2U) {
    return (1);
  } else {
    return (0);
  }
}
}
bool is_client_associated_to_ibss23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((pmlmeinfo->state & 16384U) != 0U && (pmlmeinfo->state & 3U) == 1U) {
    return (1);
  } else {
    return (0);
  }
}
}
bool is_IBSS_empty23a(struct rtw_adapter *padapter ) 
{ 
  unsigned int i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  i = 2U;
  goto ldv_53372;
  ldv_53371: ;
  if (pmlmeinfo->FW_sta_info[i].status == 1U) {
    return (0);
  } else {

  }
  i = i + 1U;
  ldv_53372: ;
  if (i <= 31U) {
    goto ldv_53371;
  } else {

  }

  return (1);
}
}
unsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval ) 
{ 


  {
  if (bcn_interval << 2 <= 5999U) {
    return (6000U);
  } else
  if (bcn_interval << 2 > 20000U) {
    return (20000U);
  } else {
    return (bcn_interval << 2);
  }
}
}
void clear_cam_entry23a(struct rtw_adapter *padapter , u8 entry ) 
{ 
  unsigned char null_sta[6U] ;
  unsigned char null_key[16U] ;

  {
  null_sta[0] = 0U;
  null_sta[1] = 0U;
  null_sta[2] = 0U;
  null_sta[3] = 0U;
  null_sta[4] = 0U;
  null_sta[5] = 0U;
  null_key[0] = 0U;
  null_key[1] = 0U;
  null_key[2] = 0U;
  null_key[3] = 0U;
  null_key[4] = 0U;
  null_key[5] = 0U;
  null_key[6] = 0U;
  null_key[7] = 0U;
  null_key[8] = 0U;
  null_key[9] = 0U;
  null_key[10] = 0U;
  null_key[11] = 0U;
  null_key[12] = 0U;
  null_key[13] = 0U;
  null_key[14] = 0U;
  null_key[15] = 0U;
  rtl8723a_cam_write(padapter, (int )entry, 0, (u8 const   *)(& null_sta), (u8 const   *)(& null_key));
  return;
}
}
int allocate_fw_sta_entry23a(struct rtw_adapter *padapter ) 
{ 
  unsigned int mac_id ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  mac_id = 2U;
  goto ldv_53391;
  ldv_53390: ;
  if (pmlmeinfo->FW_sta_info[mac_id].status == 0U) {
    pmlmeinfo->FW_sta_info[mac_id].status = 1U;
    pmlmeinfo->FW_sta_info[mac_id].retry = 0U;
    goto ldv_53389;
  } else {

  }
  mac_id = mac_id + 1U;
  ldv_53391: ;
  if (mac_id <= 31U) {
    goto ldv_53390;
  } else {

  }
  ldv_53389: ;
  return ((int )mac_id);
}
}
void flush_all_cam_entry23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  rtl8723a_cam_invalidate_all(padapter);
  memset((void *)(& pmlmeinfo->FW_sta_info), 0, 1280UL);
  return;
}
}
int WMM_param_handler23a(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (pmlmepriv->qos_option == 0U) {
    pmlmeinfo->WMM_enable = 0U;
    return (0);
  } else {

  }
  pmlmeinfo->WMM_enable = 1U;
  memcpy((void *)(& pmlmeinfo->WMM_param), (void const   *)p + 8U, 18UL);
  return (1);
}
}
void WMMOnAssocRsp23a(struct rtw_adapter *padapter ) 
{ 
  u8 ACI ;
  u8 ACM ;
  u8 AIFS ;
  u8 ECWMin ;
  u8 ECWMax ;
  u8 aSifsTime ;
  u8 acm_mask ;
  u16 TXOP ;
  u32 acParm ;
  u32 i ;
  u32 edca[4U] ;
  u32 inx[4U] ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct xmit_priv *pxmitpriv ;
  struct registry_priv *pregpriv ;
  u32 j ;
  u32 change_inx ;
  u32 __tmp ;
  u32 __tmp___0 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pxmitpriv = & padapter->xmitpriv;
  pregpriv = & padapter->registrypriv;
  if ((unsigned int )pmlmeinfo->WMM_enable == 0U) {
    padapter->mlmepriv.acm_mask = 0U;
    return;
  } else {

  }
  acm_mask = 0U;
  if ((unsigned int )pmlmeext->cur_wireless_mode == 1U) {
    aSifsTime = 10U;
  } else {
    aSifsTime = 16U;
  }
  i = 0U;
  goto ldv_53429;
  ldv_53428: 
  ACI = (unsigned int )((u8 )((int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5)) & 3U;
  ACM = (unsigned int )((u8 )((int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4)) & 1U;
  AIFS = ((unsigned int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 15U) * (unsigned int )pmlmeinfo->slotTime + (unsigned int )aSifsTime;
  ECWMin = (unsigned int )pmlmeinfo->WMM_param.ac_param[i].CW & 15U;
  ECWMax = (int )pmlmeinfo->WMM_param.ac_param[i].CW >> 4;
  TXOP = pmlmeinfo->WMM_param.ac_param[i].TXOP_limit;
  acParm = (u32 )((((int )AIFS | ((int )ECWMin << 8)) | ((int )ECWMax << 12)) | ((int )TXOP << 16));
  switch ((int )ACI) {
  case 0: 
  rtl8723a_set_ac_param_be(padapter, acParm);
  acm_mask = ((unsigned int )ACM != 0U ? 2U : 0U) | (unsigned int )acm_mask;
  edca[2] = acParm;
  goto ldv_53424;
  case 1: 
  rtl8723a_set_ac_param_bk(padapter, acParm);
  edca[3] = acParm;
  goto ldv_53424;
  case 2: 
  rtl8723a_set_ac_param_vi(padapter, acParm);
  acm_mask = ((unsigned int )ACM != 0U ? 4U : 0U) | (unsigned int )acm_mask;
  edca[1] = acParm;
  goto ldv_53424;
  case 3: 
  rtl8723a_set_ac_param_vo(padapter, acParm);
  acm_mask = ((unsigned int )ACM != 0U ? 8U : 0U) | (unsigned int )acm_mask;
  edca[0] = acParm;
  goto ldv_53424;
  }
  ldv_53424: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: WMM(%x): %x, %x\n", (int )ACI, (int )ACM, acParm);
  } else {

  }
  i = i + 1U;
  ldv_53429: ;
  if (i <= 3U) {
    goto ldv_53428;
  } else {

  }

  if ((unsigned int )padapter->registrypriv.acm_method == 1U) {
    rtl8723a_set_acm_ctrl(padapter, (int )acm_mask);
  } else {
    padapter->mlmepriv.acm_mask = acm_mask;
  }
  inx[0] = 0U;
  inx[1] = 1U;
  inx[2] = 2U;
  inx[3] = 3U;
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
    change_inx = 0U;
    i = 0U;
    goto ldv_53439;
    ldv_53438: 
    j = i + 1U;
    goto ldv_53436;
    ldv_53435: ;
    if ((edca[j] & 65535U) < (edca[i] & 65535U)) {
      change_inx = 1U;
    } else
    if (((edca[j] ^ edca[i]) & 65535U) == 0U) {
      if (edca[j] >> 16 > edca[i] >> 16) {
        change_inx = 1U;
      } else {

      }
    } else {

    }
    if (change_inx != 0U) {
      __tmp = edca[i];
      edca[i] = edca[j];
      edca[j] = __tmp;
      __tmp___0 = inx[i];
      inx[i] = inx[j];
      inx[j] = __tmp___0;
      change_inx = 0U;
    } else {

    }
    j = j + 1U;
    ldv_53436: ;
    if (j <= 3U) {
      goto ldv_53435;
    } else {

    }
    i = i + 1U;
    ldv_53439: ;
    if (i <= 3U) {
      goto ldv_53438;
    } else {

    }

  } else {

  }
  i = 0U;
  goto ldv_53442;
  ldv_53441: 
  pxmitpriv->wmm_para_seq[i] = (u8 )inx[i];
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: wmm_para_seq(%d): %d\n", i, (int )pxmitpriv->wmm_para_seq[i]);
  } else {

  }
  i = i + 1U;
  ldv_53442: ;
  if (i <= 3U) {
    goto ldv_53441;
  } else {

  }

  return;
}
}
static void bwmode_update_check(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  struct ieee80211_ht_operation *pHT_info ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct registry_priv *pregistrypriv ;
  struct ht_priv *phtpriv ;
  unsigned char new_bwmode ;
  unsigned char new_ch_offset ;
  struct sta_info *psta ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_priv *pstapriv ;
  struct ht_priv *phtpriv_sta ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pregistrypriv = & padapter->registrypriv;
  phtpriv = & pmlmepriv->htpriv;
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
    return;
  } else {

  }
  if (! phtpriv->ht_option) {
    return;
  } else {

  }
  if ((unsigned int )((unsigned char )*(p + 1UL)) != 22U) {
    return;
  } else {

  }
  pHT_info = (struct ieee80211_ht_operation *)p + 2U;
  if (((int )pHT_info->ht_param & 4) != 0 && (unsigned int )pregistrypriv->cbw40_enable != 0U) {
    new_bwmode = 1U;
    switch ((int )pHT_info->ht_param & 3) {
    case 1: 
    new_ch_offset = 1U;
    goto ldv_53457;
    case 3: 
    new_ch_offset = 2U;
    goto ldv_53457;
    default: 
    new_ch_offset = 0U;
    goto ldv_53457;
    }
    ldv_53457: ;
  } else {
    new_bwmode = 0U;
    new_ch_offset = 0U;
  }
  if ((int )pmlmeext->cur_bwmode != (int )new_bwmode || (int )pmlmeext->cur_ch_offset != (int )new_ch_offset) {
    pmlmeinfo->bwmode_updated = 1U;
    pmlmeext->cur_bwmode = new_bwmode;
    pmlmeext->cur_ch_offset = new_ch_offset;
    HT_info_handler23a(padapter, p);
  } else {
    pmlmeinfo->bwmode_updated = 0U;
  }
  if ((unsigned int )pmlmeinfo->bwmode_updated != 0U) {
    cur_network = & pmlmeinfo->network;
    pstapriv = & padapter->stapriv;
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      phtpriv_sta = & psta->htpriv;
      if ((int )phtpriv_sta->ht_option) {
        phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
        phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
      } else {
        phtpriv_sta->bwmode = 0U;
        phtpriv_sta->ch_offset = 0U;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void HT_caps_handler23a(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  unsigned int i ;
  u8 rf_type ;
  u8 max_AMPDU_len ;
  u8 min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  struct ieee80211_ht_cap *cap ;
  u8 *dstcap ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
    return;
  } else {

  }
  if (! phtpriv->ht_option) {
    return;
  } else {

  }
  pmlmeinfo->HT_caps_enable = 1U;
  cap = & pmlmeinfo->ht_cap;
  dstcap = (u8 *)cap;
  i = 0U;
  goto ldv_53479;
  ldv_53478: ;
  if (i != 2U) {
    *(dstcap + (unsigned long )i) = (u8 )((int )*(dstcap + (unsigned long )i) & (int )((unsigned char )*(p + (unsigned long )(i + 2U))));
  } else {
    if (((int )cap->ampdu_params_info & 3) > ((int )*(p + (unsigned long )(i + 2U)) & 3)) {
      max_AMPDU_len = (unsigned int )((u8 )*(p + (unsigned long )(i + 2U))) & 3U;
    } else {
      max_AMPDU_len = (unsigned int )cap->ampdu_params_info & 3U;
    }
    if (((int )cap->ampdu_params_info & 28) > ((int )*(p + (unsigned long )(i + 2U)) & 28)) {
      min_MPDU_spacing = (unsigned int )cap->ampdu_params_info & 28U;
    } else {
      min_MPDU_spacing = (unsigned int )((u8 )*(p + (unsigned long )(i + 2U))) & 28U;
    }
    cap->ampdu_params_info = (u8 )((int )max_AMPDU_len | (int )min_MPDU_spacing);
  }
  i = i + 1U;
  ldv_53479: ;
  if ((unsigned int )*(p + 1UL) > i) {
    goto ldv_53478;
  } else {

  }
  rf_type = rtl8723a_get_rf_type(padapter);
  i = 0U;
  goto ldv_53482;
  ldv_53481: ;
  if ((unsigned int )rf_type == 3U || (unsigned int )rf_type == 0U) {
    cap->mcs.rx_mask[i] = (u8 )((int )cap->mcs.rx_mask[i] & (int )MCS_rate_1R23A[i]);
  } else {
    cap->mcs.rx_mask[i] = (u8 )((int )cap->mcs.rx_mask[i] & (int )MCS_rate_2R23A[i]);
  }
  i = i + 1U;
  ldv_53482: ;
  if (i <= 9U) {
    goto ldv_53481;
  } else {

  }

  return;
}
}
void HT_info_handler23a(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
    return;
  } else {

  }
  if (! phtpriv->ht_option) {
    return;
  } else {

  }
  if ((unsigned int )((unsigned char )*(p + 1UL)) != 22U) {
    return;
  } else {

  }
  pmlmeinfo->HT_info_enable = 1U;
  memcpy((void *)(& pmlmeinfo->HT_info), (void const   *)p + 2U, (size_t )*(p + 1UL));
  return;
}
}
void HTOnAssocRsp23a(struct rtw_adapter *padapter ) 
{ 
  unsigned char max_AMPDU_len ;
  unsigned char min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "HTOnAssocRsp23a");
  } else {

  }
  if ((unsigned int )pmlmeinfo->HT_info_enable != 0U && (unsigned int )pmlmeinfo->HT_caps_enable != 0U) {
    pmlmeinfo->HT_enable = 1U;
  } else {
    pmlmeinfo->HT_enable = 0U;
    return;
  }
  max_AMPDU_len = (unsigned int )pmlmeinfo->ht_cap.ampdu_params_info & 3U;
  min_MPDU_spacing = (unsigned char )(((int )pmlmeinfo->ht_cap.ampdu_params_info & 28) >> 2);
  rtl8723a_set_ampdu_min_space(padapter, (int )min_MPDU_spacing);
  rtl8723a_set_ampdu_factor(padapter, (int )max_AMPDU_len);
  return;
}
}
void ERP_IE_handler23a(struct rtw_adapter *padapter , u8 const   *p ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )((unsigned char )*(p + 1UL)) > 1U) {
    return;
  } else {

  }
  pmlmeinfo->ERP_enable = 1U;
  memcpy((void *)(& pmlmeinfo->ERP_IE), (void const   *)p + 2U, (size_t )*(p + 1UL));
  return;
}
}
void VCS_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pregpriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  switch ((int )pregpriv->vrtl_carrier_sense) {
  case 0: 
  psta->rtsen = 0U;
  psta->cts2self = 0U;
  goto ldv_53514;
  case 1: ;
  if ((unsigned int )pregpriv->vcs_type == 1U) {
    psta->rtsen = 1U;
    psta->cts2self = 0U;
  } else {
    psta->rtsen = 0U;
    psta->cts2self = 1U;
  }
  goto ldv_53514;
  case 2: ;
  default: ;
  if ((unsigned int )pmlmeinfo->ERP_enable != 0U && ((unsigned long )pmlmeinfo->ERP_IE & 2UL) != 0UL) {
    if ((unsigned int )pregpriv->vcs_type == 1U) {
      psta->rtsen = 1U;
      psta->cts2self = 0U;
    } else {
      psta->rtsen = 0U;
      psta->cts2self = 1U;
    }
  } else {
    psta->rtsen = 0U;
    psta->cts2self = 0U;
  }
  goto ldv_53514;
  }
  ldv_53514: ;
  return;
}
}
int rtw_check_bcn_info23a(struct rtw_adapter *Adapter , struct ieee80211_mgmt *mgmt ,
                          u32 pkt_len ) 
{ 
  struct wlan_network *cur_network ;
  struct ieee80211_ht_operation *pht_info ;
  unsigned short val16 ;
  u8 crypto ;
  u8 bcn_channel ;
  int group_cipher ;
  int pairwise_cipher ;
  int is_8021x ;
  int r ;
  int pie_len ;
  int ssid_len ;
  int privacy ;
  u8 const   *p ;
  u8 const   *ssid ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  cur_network = & Adapter->mlmepriv.cur_network;
  group_cipher = 0;
  pairwise_cipher = 0;
  is_8021x = 0;
  tmp = is_client_associated_to_ap23a(Adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (1);
  } else {

  }
  tmp___1 = ieee80211_is_beacon((int )mgmt->frame_control);
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
  if (tmp___2 != 0L) {
    printk("\f%s: received a non beacon frame!\n", "rtw_check_bcn_info23a");
    return (0);
  } else {

  }
  tmp___3 = ether_addr_equal((u8 const   *)(& cur_network->network.MacAddress), (u8 const   *)(& mgmt->bssid));
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: linked but recv other bssid bcn %pM %pM\n", "rtw_check_bcn_info23a",
             (u8 *)(& mgmt->bssid), (u8 *)(& cur_network->network.MacAddress));
    } else {

    }
    return (0);
  } else {

  }
  pie_len = (int )(pkt_len - 36U);
  p = cfg80211_find_ie(3, (u8 const   *)(& mgmt->u.beacon.variable), pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
    bcn_channel = *(p + 2UL);
  } else {
    p = cfg80211_find_ie(61, (u8 const   *)(& mgmt->u.beacon.variable), pie_len);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      pht_info = (struct ieee80211_ht_operation *)p + 2U;
      bcn_channel = pht_info->primary_chan;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Oops: %s we don\'t find channel IE, so don\'t check it\n",
               "rtw_check_bcn_info23a");
      } else {

      }
      bcn_channel = Adapter->mlmeextpriv.cur_channel;
    }
  }
  if ((int )Adapter->mlmeextpriv.cur_channel != (int )bcn_channel) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s beacon channel:%d cur channel:%d disconnect\n", "rtw_check_bcn_info23a",
             (int )bcn_channel, (int )Adapter->mlmeextpriv.cur_channel);
    } else {

    }
    goto _mismatch;
  } else {

  }
  p = cfg80211_find_ie(0, (u8 const   *)(& mgmt->u.beacon.variable), pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    ssid = p + 2UL;
    ssid_len = (int )*(p + 1UL);
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s marc: cannot find SSID for survey event\n", "rtw_check_bcn_info23a");
    } else {

    }
    ssid = (u8 const   *)0U;
    ssid_len = 0;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "%s bssid.Ssid.Ssid:%s bssid.Ssid.SsidLength:%d cur_network->network.Ssid.Ssid:%s len:%d\n",
             "rtw_check_bcn_info23a", ssid, ssid_len, (u8 *)(& cur_network->network.Ssid.ssid),
             (int )cur_network->network.Ssid.ssid_len);
  } else {

  }
  if ((int )cur_network->network.Ssid.ssid_len != ssid_len || ssid_len > 32) {
    goto _L;
  } else
  if (ssid_len != 0) {
    tmp___5 = memcmp((void const   *)ssid, (void const   *)(& cur_network->network.Ssid.ssid),
                     (size_t )ssid_len);
    if (tmp___5 != 0) {
      _L: /* CIL Label */ 
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(), SSID is not match return FAIL\n", "rtw_check_bcn_info23a");
      } else {

      }
      goto _mismatch;
    } else {

    }
  } else {

  }
  val16 = mgmt->u.beacon.capab_info;
  if (((int )val16 & 16) != 0) {
    privacy = 1;
  } else {
    privacy = 0;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "%s(): cur_network->network.Privacy is %d, bssid.Privacy is %d\n",
             "rtw_check_bcn_info23a", cur_network->network.Privacy, privacy);
  } else {

  }
  if (cur_network->network.Privacy != (u32 )privacy) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(), privacy is not match return FAIL\n", "rtw_check_bcn_info23a");
    } else {

    }
    goto _mismatch;
  } else {

  }
  p = cfg80211_find_ie(48, (u8 const   *)(& mgmt->u.beacon.variable), pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    crypto = 3U;
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      r = rtw_parse_wpa2_ie23a(p, (int )*(p + 1UL) + 2, & group_cipher, & pairwise_cipher,
                               & is_8021x);
      if (r == 1) {
        if (GlobalDebugLevel23A > 6U) {
          rt_trace(16, 7, "%s pnetwork->pairwise_cipher: %d, pnetwork->group_cipher: %d, is_802x : %d\n",
                   "rtw_check_bcn_info23a", pairwise_cipher, group_cipher, is_8021x);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {
    p = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)(& mgmt->u.beacon.variable),
                                pie_len);
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      crypto = 2U;
      r = rtw_parse_wpa_ie23a(p, (int )*(p + 1UL) + 2, & group_cipher, & pairwise_cipher,
                              & is_8021x);
      if (r == 1) {
        if (GlobalDebugLevel23A > 6U) {
          rt_trace(16, 7, "%s pnetwork->pairwise_cipher: %d, group_cipher is %d, is_8021x is %d\n",
                   "rtw_check_bcn_info23a", pairwise_cipher, group_cipher, is_8021x);
        } else {

        }
      } else {

      }
    } else
    if (privacy != 0) {
      crypto = 1U;
    } else {
      crypto = 0U;
    }
  }
  if ((int )cur_network->BcnInfo.encryp_protocol != (int )crypto) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): encryption mismatch, return FAIL\n", "rtw_check_bcn_info23a");
    } else {

    }
    goto _mismatch;
  } else {

  }
  if ((unsigned int )crypto == 2U || (unsigned int )crypto == 3U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16, 4, "%s cur_network->group_cipher is %d: %d\n", "rtw_check_bcn_info23a",
               cur_network->BcnInfo.group_cipher, group_cipher);
    } else {

    }
    if (cur_network->BcnInfo.pairwise_cipher != pairwise_cipher || cur_network->BcnInfo.group_cipher != group_cipher) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s pairwise_cipher(%x:%x) or group_cipher (%x:%x) is not match, return FAIL\n",
               "rtw_check_bcn_info23a", pairwise_cipher, cur_network->BcnInfo.pairwise_cipher,
               group_cipher, cur_network->BcnInfo.group_cipher);
      } else {

      }
      goto _mismatch;
    } else {

    }
    if (cur_network->BcnInfo.is_8021x != is_8021x) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s authentication is not match, return FAIL\n", "rtw_check_bcn_info23a");
      } else {

      }
      goto _mismatch;
    } else {

    }
  } else {

  }
  return (1);
  _mismatch: ;
  return (0);
}
}
void update_beacon23a_info(struct rtw_adapter *padapter , struct ieee80211_mgmt *mgmt ,
                           uint pkt_len , struct sta_info *psta ) 
{ 
  unsigned int len ;
  u8 const   *p ;

  {
  len = pkt_len - 36U;
  p = cfg80211_find_ie(61, (u8 const   *)(& mgmt->u.beacon.variable), (int )len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
    bwmode_update_check(padapter, p);
  } else {

  }
  p = cfg80211_find_ie(42, (u8 const   *)(& mgmt->u.beacon.variable), (int )len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
    ERP_IE_handler23a(padapter, p);
    VCS_update23a(padapter, psta);
  } else {

  }
  return;
}
}
bool is_ap_in_tkip23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  if (((int )cur_network->capability & 16) != 0) {
    i = 0U;
    goto ldv_53560;
    ldv_53559: 
    p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
    switch ((int )*p) {
    case 221: 
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
    if (tmp == 0) {
      tmp___0 = memcmp((void const   *)p + 14U, (void const   *)(& WPA_TKIP_CIPHER),
                       4UL);
      if (tmp___0 == 0) {
        return (1);
      } else {

      }
    } else {

    }
    goto ldv_53556;
    case 48: 
    tmp___1 = memcmp((void const   *)p + 10U, (void const   *)(& RSN_TKIP_CIPHER),
                     4UL);
    if (tmp___1 == 0) {
      return (1);
    } else {

    }
    goto ldv_53556;
    default: ;
    goto ldv_53556;
    }
    ldv_53556: 
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_53560: ;
    if (pmlmeinfo->network.IELength > i) {
      goto ldv_53559;
    } else {

    }

    return (0);
  } else {
    return (0);
  }
}
}
bool should_forbid_n_rate23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network.network;
  if (((int )cur_network->capability & 16) != 0) {
    i = 0U;
    goto ldv_53574;
    ldv_53573: 
    p = (u8 const   *)(& cur_network->IEs) + (unsigned long )i;
    switch ((int )*p) {
    case 221: 
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
    if (tmp == 0) {
      tmp___0 = memcmp((void const   *)p + 14U, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                       4UL);
      if (tmp___0 == 0) {
        return (0);
      } else {
        tmp___1 = memcmp((void const   *)p + 18U, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                         4UL);
        if (tmp___1 == 0) {
          return (0);
        } else {

        }
      }
    } else {

    }
    goto ldv_53570;
    case 48: 
    tmp___2 = memcmp((void const   *)p + 10U, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                     4UL);
    if (tmp___2 == 0) {
      return (0);
    } else {
      tmp___3 = memcmp((void const   *)p + 14U, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                       4UL);
      if (tmp___3 == 0) {
        return (0);
      } else {

      }
    }
    default: ;
    goto ldv_53570;
    }
    ldv_53570: 
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_53574: ;
    if (cur_network->IELength > i) {
      goto ldv_53573;
    } else {

    }

    return (1);
  } else {
    return (0);
  }
}
}
bool is_ap_in_wep23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int tmp ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  if (((int )cur_network->capability & 16) != 0) {
    i = 0U;
    goto ldv_53589;
    ldv_53588: 
    p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
    switch ((int )*p) {
    case 221: 
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
    if (tmp == 0) {
      return (0);
    } else {

    }
    goto ldv_53585;
    case 48: ;
    return (0);
    default: ;
    goto ldv_53585;
    }
    ldv_53585: 
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_53589: ;
    if (pmlmeinfo->network.IELength > i) {
      goto ldv_53588;
    } else {

    }

    return (1);
  } else {
    return (0);
  }
}
}
static int wifirate2_ratetbl_inx23a(unsigned char rate ) 
{ 
  int inx ;

  {
  inx = 0;
  rate = (unsigned int )rate & 127U;
  switch ((int )rate) {
  case 108: 
  inx = 11;
  goto ldv_53596;
  case 96: 
  inx = 10;
  goto ldv_53596;
  case 72: 
  inx = 9;
  goto ldv_53596;
  case 48: 
  inx = 8;
  goto ldv_53596;
  case 36: 
  inx = 7;
  goto ldv_53596;
  case 24: 
  inx = 6;
  goto ldv_53596;
  case 18: 
  inx = 5;
  goto ldv_53596;
  case 12: 
  inx = 4;
  goto ldv_53596;
  case 22: 
  inx = 3;
  goto ldv_53596;
  case 11: 
  inx = 2;
  goto ldv_53596;
  case 4: 
  inx = 1;
  goto ldv_53596;
  case 2: 
  inx = 0;
  goto ldv_53596;
  }
  ldv_53596: ;
  return (inx);
}
}
unsigned int update_basic_rate23a(unsigned char *ptn , unsigned int ptn_sz ) 
{ 
  unsigned int i ;
  unsigned int num_of_rate ;
  unsigned int mask ;
  int tmp ;

  {
  mask = 0U;
  num_of_rate = 13U < ptn_sz ? 13U : ptn_sz;
  i = 0U;
  goto ldv_53616;
  ldv_53615: ;
  if ((int )((signed char )*(ptn + (unsigned long )i)) < 0) {
    tmp = wifirate2_ratetbl_inx23a((int )*(ptn + (unsigned long )i));
    mask = (unsigned int )(1 << tmp) | mask;
  } else {

  }
  i = i + 1U;
  ldv_53616: ;
  if (i < num_of_rate) {
    goto ldv_53615;
  } else {

  }

  return (mask);
}
}
unsigned int update_supported_rate23a(unsigned char *ptn , unsigned int ptn_sz ) 
{ 
  unsigned int i ;
  unsigned int num_of_rate ;
  unsigned int mask ;
  int tmp ;

  {
  mask = 0U;
  num_of_rate = 13U < ptn_sz ? 13U : ptn_sz;
  i = 0U;
  goto ldv_53626;
  ldv_53625: 
  tmp = wifirate2_ratetbl_inx23a((int )*(ptn + (unsigned long )i));
  mask = (unsigned int )(1 << tmp) | mask;
  i = i + 1U;
  ldv_53626: ;
  if (i < num_of_rate) {
    goto ldv_53625;
  } else {

  }

  return (mask);
}
}
unsigned int update_MSC_rate23a(struct ieee80211_ht_cap *pHT_caps ) 
{ 
  unsigned int mask ;

  {
  mask = 0U;
  mask = (unsigned int )(((int )pHT_caps->mcs.rx_mask[0] << 12) | ((int )pHT_caps->mcs.rx_mask[1] << 20));
  return (mask);
}
}
int support_short_GI23a(struct rtw_adapter *padapter , struct ieee80211_ht_cap *pHT_caps ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char bit_offset ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )pmlmeinfo->HT_enable == 0U) {
    return (0);
  } else {

  }
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 4U) {
    return (0);
  } else {

  }
  bit_offset = (int )pmlmeext->cur_bwmode & 1 ? 6U : 5U;
  if ((unsigned int )((int )pHT_caps->cap_info & (int )((unsigned short )(1 << (int )bit_offset))) != 0U) {
    return (1);
  } else {
    return (0);
  }
}
}
unsigned char get_highest_rate_idx23a(u32 mask ) 
{ 
  int i ;
  unsigned char rate_idx ;

  {
  rate_idx = 0U;
  i = 27;
  goto ldv_53646;
  ldv_53645: ;
  if ((int )((unsigned long )mask >> i) & 1) {
    rate_idx = (unsigned char )i;
    goto ldv_53644;
  } else {

  }
  i = i - 1;
  ldv_53646: ;
  if (i >= 0) {
    goto ldv_53645;
  } else {

  }
  ldv_53644: ;
  return (rate_idx);
}
}
void Update_RA_Entry23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
  rtw_hal_update_ra_mask23a(psta, 0);
  return;
}
}
static void enable_rate_adaptive(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
  Update_RA_Entry23a(padapter, psta);
  return;
}
}
void set_sta_rate23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
  enable_rate_adaptive(padapter, psta);
  return;
}
}
void update_tx_basic_rate23a(struct rtw_adapter *padapter , u8 wirelessmode ) 
{ 
  unsigned char supported_rates[16U] ;

  {
  memset((void *)(& supported_rates), 0, 16UL);
  if ((unsigned int )wirelessmode == 1U) {
    memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_cck),
             4UL);
  } else
  if ((int )wirelessmode & 1) {
    memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_mix),
             7UL);
  } else {
    memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_ofdm),
             3UL);
  }
  if ((int )wirelessmode & 1) {
    update_mgnt_tx_rate23a(padapter, 2);
  } else {
    update_mgnt_tx_rate23a(padapter, 12);
  }
  HalSetBrateCfg23a(padapter, (u8 *)(& supported_rates));
  return;
}
}
unsigned char check_assoc_AP23a(u8 *pframe , uint len ) 
{ 
  int i ;
  u8 epigram_vendor_flag ;
  u8 ralink_vendor_flag ;
  u8 const   *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  epigram_vendor_flag = 0U;
  ralink_vendor_flag = 0U;
  i = 0;
  goto ldv_53676;
  ldv_53675: 
  p = (u8 const   *)pframe + (unsigned long )i;
  switch ((int )*p) {
  case 221: 
  tmp___7 = memcmp((void const   *)p + 2U, (void const   *)(& ARTHEROS_OUI1), 3UL);
  if (tmp___7 == 0) {
    goto _L___0;
  } else {
    tmp___8 = memcmp((void const   *)p + 2U, (void const   *)(& ARTHEROS_OUI2), 3UL);
    if (tmp___8 == 0) {
      _L___0: /* CIL Label */ 
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: link to Artheros AP\n");
      } else {

      }
      return (5U);
    } else {
      tmp___5 = memcmp((void const   *)p + 2U, (void const   *)(& BROADCOM_OUI1),
                       3UL);
      if (tmp___5 == 0) {
        goto _L;
      } else {
        tmp___6 = memcmp((void const   *)p + 2U, (void const   *)(& BROADCOM_OUI2),
                         3UL);
        if (tmp___6 == 0) {
          _L: /* CIL Label */ 
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: link to Broadcom AP\n");
          } else {

          }
          return (3U);
        } else {
          tmp___4 = memcmp((void const   *)p + 2U, (void const   *)(& MARVELL_OUI),
                           3UL);
          if (tmp___4 == 0) {
            if (GlobalDebugLevel23A > 3U) {
              printk("\016RTL8723AU: link to Marvell AP\n");
            } else {

            }
            return (8U);
          } else {
            tmp___3 = memcmp((void const   *)p + 2U, (void const   *)(& RALINK_OUI),
                             3UL);
            if (tmp___3 == 0) {
              if ((unsigned int )ralink_vendor_flag == 0U) {
                ralink_vendor_flag = 1U;
              } else {
                if (GlobalDebugLevel23A > 3U) {
                  printk("\016RTL8723AU: link to Ralink AP\n");
                } else {

                }
                return (4U);
              }
            } else {
              tmp___2 = memcmp((void const   *)p + 2U, (void const   *)(& CISCO_OUI),
                               3UL);
              if (tmp___2 == 0) {
                if (GlobalDebugLevel23A > 3U) {
                  printk("\016RTL8723AU: link to Cisco AP\n");
                } else {

                }
                return (6U);
              } else {
                tmp___1 = memcmp((void const   *)p + 2U, (void const   *)(& REALTEK_OUI),
                                 3UL);
                if (tmp___1 == 0) {
                  if (GlobalDebugLevel23A > 3U) {
                    printk("\016RTL8723AU: link to Realtek 96B\n");
                  } else {

                  }
                  return (1U);
                } else {
                  tmp___0 = memcmp((void const   *)p + 2U, (void const   *)(& AIRGOCAP_OUI),
                                   3UL);
                  if (tmp___0 == 0) {
                    if (GlobalDebugLevel23A > 3U) {
                      printk("\016RTL8723AU: link to Airgo Cap\n");
                    } else {

                    }
                    return (11U);
                  } else {
                    tmp = memcmp((void const   *)p + 2U, (void const   *)(& EPIGRAM_OUI),
                                 3UL);
                    if (tmp == 0) {
                      epigram_vendor_flag = 1U;
                      if ((unsigned int )ralink_vendor_flag != 0U) {
                        if (GlobalDebugLevel23A > 3U) {
                          printk("\016RTL8723AU: link to Tenda W311R AP\n");
                        } else {

                        }
                        return (16U);
                      } else
                      if (GlobalDebugLevel23A > 3U) {
                        printk("\016RTL8723AU: Capture EPIGRAM_OUI\n");
                      } else {

                      }
                    } else {
                      goto ldv_53673;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  default: ;
  goto ldv_53673;
  }
  ldv_53673: 
  i = ((int )*(p + 1UL) + 2) + i;
  ldv_53676: ;
  if ((uint )i < len) {
    goto ldv_53675;
  } else {

  }

  if ((unsigned int )ralink_vendor_flag != 0U && (unsigned int )epigram_vendor_flag == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link to Ralink AP\n");
    } else {

    }
    return (4U);
  } else
  if ((unsigned int )ralink_vendor_flag != 0U && (unsigned int )epigram_vendor_flag != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link to Tenda W311R AP\n");
    } else {

    }
    return (16U);
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link to new AP\n");
    } else {

    }
    return (0U);
  }
}
}
void update_IOT_info23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  switch ((int )pmlmeinfo->assoc_AP_vendor) {
  case 8: 
  pmlmeinfo->turboMode_cts2self = 1U;
  pmlmeinfo->turboMode_rtsen = 0U;
  goto ldv_53684;
  case 4: 
  pmlmeinfo->turboMode_cts2self = 0U;
  pmlmeinfo->turboMode_rtsen = 1U;
  rtl8723a_odm_support_ability_clr(padapter, 4294967291U);
  goto ldv_53684;
  case 1: 
  rtl8723a_odm_support_ability_clr(padapter, 4294967291U);
  goto ldv_53684;
  default: 
  pmlmeinfo->turboMode_cts2self = 0U;
  pmlmeinfo->turboMode_rtsen = 1U;
  goto ldv_53684;
  }
  ldv_53684: ;
  return;
}
}
void update_capinfo23a(struct rtw_adapter *Adapter , u16 updateCap ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & Adapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (((int )updateCap & 32) != 0) {
    if ((unsigned int )pmlmeinfo->preamble_mode != 3U) {
      pmlmeinfo->preamble_mode = 3U;
      rtl8723a_ack_preamble(Adapter, 1);
    } else {

    }
  } else
  if ((unsigned int )pmlmeinfo->preamble_mode != 1U) {
    pmlmeinfo->preamble_mode = 1U;
    rtl8723a_ack_preamble(Adapter, 0);
  } else {

  }
  if (((int )updateCap & 2) != 0) {
    pmlmeinfo->slotTime = 20U;
  } else
  if (((int )pmlmeext->cur_wireless_mode & 10) != 0) {
    if (((int )updateCap & 1024) != 0) {
      if ((unsigned int )pmlmeinfo->slotTime != 9U) {
        pmlmeinfo->slotTime = 9U;
      } else {

      }
    } else
    if ((unsigned int )pmlmeinfo->slotTime != 20U) {
      pmlmeinfo->slotTime = 20U;
    } else {

    }
  } else
  if (((int )pmlmeext->cur_wireless_mode & 20) != 0) {
    pmlmeinfo->slotTime = 9U;
  } else {
    pmlmeinfo->slotTime = 20U;
  }
  rtl8723a_set_slot_time(Adapter, (int )pmlmeinfo->slotTime);
  return;
}
}
void update_wireless_mode23a(struct rtw_adapter *padapter ) 
{ 
  int ratelen ;
  int network_type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  unsigned char *rate ;
  uint tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  network_type = 0;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  rate = (unsigned char *)(& cur_network->SupportedRates);
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  ratelen = (int )tmp;
  if ((unsigned int )pmlmeinfo->HT_info_enable != 0U && (unsigned int )pmlmeinfo->HT_caps_enable != 0U) {
    pmlmeinfo->HT_enable = 1U;
  } else {

  }
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
      network_type = 16;
    } else {

    }
    network_type = network_type | 4;
  } else {
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
      network_type = 8;
    } else {

    }
    tmp___1 = cckratesonly_included23a(rate, ratelen);
    if (tmp___1 == 1) {
      network_type = network_type | 1;
    } else {
      tmp___0 = cckrates_included23a(rate, ratelen);
      if (tmp___0 == 1) {
        network_type = network_type | 3;
      } else {
        network_type = network_type | 2;
      }
    }
  }
  pmlmeext->cur_wireless_mode = (unsigned char )((int )((signed char )padapter->registrypriv.wireless_mode) & (int )((signed char )network_type));
  rtl8723a_set_resp_sifs(padapter, 8, 8, 10, 10);
  if ((int )pmlmeext->cur_wireless_mode & 1) {
    update_mgnt_tx_rate23a(padapter, 2);
  } else {
    update_mgnt_tx_rate23a(padapter, 12);
  }
  return;
}
}
void update_bmc_sta_support_rate23a(struct rtw_adapter *padapter , u32 mac_id ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((int )pmlmeext->cur_wireless_mode & 1) {
    memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates), (void const   *)(& rtw_basic_rate_cck),
             4UL);
  } else {
    memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates), (void const   *)(& rtw_basic_rate_ofdm),
             3UL);
  }
  return;
}
}
int update_sta_support_rate23a(struct rtw_adapter *padapter , u8 *pvar_ie , uint var_ie_len ,
                               int cam_idx ) 
{ 
  int supportRateNum ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 const   *p ;

  {
  supportRateNum = 0;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  p = cfg80211_find_ie(1, (u8 const   *)pvar_ie, (int )var_ie_len);
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
    return (0);
  } else {

  }
  memcpy((void *)(& pmlmeinfo->FW_sta_info[cam_idx].SupportedRates), (void const   *)p + 2U,
           (size_t )*(p + 1UL));
  supportRateNum = (int )*(p + 1UL);
  p = cfg80211_find_ie(50, (u8 const   *)pvar_ie, (int )var_ie_len);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
    memcpy((void *)(& pmlmeinfo->FW_sta_info[cam_idx].SupportedRates) + (unsigned long )supportRateNum,
             (void const   *)p + 2U, (size_t )*(p + 1UL));
  } else {

  }
  return (1);
}
}
void process_addba_req23a(struct rtw_adapter *padapter , u8 *paddba_req , u8 *addr ) 
{ 
  struct sta_info *psta ;
  u16 tid ;
  u16 start_seq ;
  u16 param ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_priv *pstapriv ;
  struct ADDBA_request *preq ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pstapriv = & padapter->stapriv;
  preq = (struct ADDBA_request *)paddba_req;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    start_seq = (u16 )((int )preq->BA_starting_seqctrl >> 4);
    param = preq->BA_para_set;
    tid = (unsigned int )((u16 )((int )param >> 2)) & 15U;
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )tid;
    preorder_ctrl->indicate_seq = 65535U;
    preorder_ctrl->enable = (u8 )pmlmeinfo->bAcceptAddbaReq;
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_258(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_260(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_261(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_271(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_273(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_272(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_275(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_274(struct workqueue_struct *ldv_func_arg1 ) ;
u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter , u8 hw_channel_plan ,
                               u8 sw_channel_plan , u8 def_channel_plan , bool AutoLoadFail ) ;
u8 MRateToHwRate23a(u8 rate ) ;
bool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter , u8 NumOutPipe ) ;
void rtl8723a_set_media_status1(struct rtw_adapter *padapter , u8 status ) ;
void rtl8723a_check_bssid(struct rtw_adapter *padapter , u8 val ) ;
void rtl8723a_off_rcr_am(struct rtw_adapter *padapter ) ;
void rtl8723a_cam_empty_entry(struct rtw_adapter *padapter , u8 ucIndex ) ;
void rtl8723a_fifo_cleanup(struct rtw_adapter *padapter ) ;
bool rtl8723a_BT_enabled(struct rtw_adapter *padapter ) ;
void ODM_Write_DIG23a(struct dm_odm_t *pDM_Odm , u8 CurrentIGI ) ;
void SetBcnCtrlReg23a(struct rtw_adapter *padapter , u8 SetBits , u8 ClearBits ) ;
int rtl8723au_write32(struct rtw_adapter *padapter , u16 addr , u32 val ) ;
u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter , u8 hw_channel_plan ,
                               u8 sw_channel_plan , u8 def_channel_plan , bool AutoLoadFail ) 
{ 
  u8 swConfig ;
  u8 chnlPlan ;

  {
  swConfig = 1U;
  if (! AutoLoadFail) {
    if ((unsigned int )sw_channel_plan > 65U && (unsigned int )sw_channel_plan != 127U) {
      swConfig = 0U;
    } else {

    }
    if ((int )((signed char )hw_channel_plan) < 0) {
      swConfig = 0U;
    } else {

    }
  } else {

  }
  if ((unsigned int )swConfig == 1U) {
    chnlPlan = sw_channel_plan;
  } else {
    chnlPlan = (unsigned int )hw_channel_plan & 127U;
  }
  if ((unsigned int )chnlPlan > 65U && (unsigned int )chnlPlan != 127U) {
    chnlPlan = def_channel_plan;
  } else {

  }
  return (chnlPlan);
}
}
u8 MRateToHwRate23a(u8 rate ) 
{ 
  u8 ret ;

  {
  ret = 0U;
  switch ((int )rate) {
  case 2: 
  ret = 0U;
  goto ldv_55758;
  case 4: 
  ret = 1U;
  goto ldv_55758;
  case 11: 
  ret = 2U;
  goto ldv_55758;
  case 22: 
  ret = 3U;
  goto ldv_55758;
  case 12: 
  ret = 4U;
  goto ldv_55758;
  case 18: 
  ret = 5U;
  goto ldv_55758;
  case 24: 
  ret = 6U;
  goto ldv_55758;
  case 36: 
  ret = 7U;
  goto ldv_55758;
  case 48: 
  ret = 8U;
  goto ldv_55758;
  case 72: 
  ret = 9U;
  goto ldv_55758;
  case 96: 
  ret = 10U;
  goto ldv_55758;
  case 108: 
  ret = 11U;
  goto ldv_55758;
  default: ;
  goto ldv_55758;
  }
  ldv_55758: ;
  return (ret);
}
}
void HalSetBrateCfg23a(struct rtw_adapter *padapter , u8 *mBratesOS ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 i ;
  u8 is_brate ;
  u8 brate ;
  u16 brate_cfg ;
  u8 rate_index ;
  u8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  brate_cfg = 0U;
  i = 0U;
  goto ldv_55795;
  ldv_55794: 
  is_brate = (unsigned int )*(mBratesOS + (unsigned long )i) & 128U;
  brate = (unsigned int )*(mBratesOS + (unsigned long )i) & 127U;
  if ((unsigned int )is_brate != 0U) {
    switch ((int )brate) {
    case 2: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 1U);
    goto ldv_55782;
    case 4: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 2U);
    goto ldv_55782;
    case 11: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 4U);
    goto ldv_55782;
    case 22: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 8U);
    goto ldv_55782;
    case 12: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 16U);
    goto ldv_55782;
    case 18: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 32U);
    goto ldv_55782;
    case 24: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 64U);
    goto ldv_55782;
    case 36: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 128U);
    goto ldv_55782;
    case 48: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 256U);
    goto ldv_55782;
    case 72: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 512U);
    goto ldv_55782;
    case 96: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 1024U);
    goto ldv_55782;
    case 108: 
    brate_cfg = (u16 )((unsigned int )brate_cfg | 2048U);
    goto ldv_55782;
    }
    ldv_55782: ;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_55795: ;
  if ((unsigned int )i <= 15U) {
    goto ldv_55794;
  } else {

  }
  brate_cfg = ((unsigned int )brate_cfg & 336U) | 13U;
  pHalData->BasicRateSet = brate_cfg;
  brate_cfg = (u16 )((unsigned int )brate_cfg | 1U);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", (int )brate_cfg);
  } else {

  }
  rtl8723au_write8(padapter, 1088, (int )((u8 )brate_cfg));
  rtl8723au_write8(padapter, 1089, (int )((u8 )((int )brate_cfg >> 8)));
  tmp = rtl8723au_read8(padapter, 1090);
  rtl8723au_write8(padapter, 1090, (int )tmp & 240);
  rate_index = 0U;
  goto ldv_55798;
  ldv_55797: 
  brate_cfg = (u16 )((int )brate_cfg >> 1);
  rate_index = (u8 )((int )rate_index + 1);
  ldv_55798: ;
  if ((unsigned int )brate_cfg > 1U) {
    goto ldv_55797;
  } else {

  }
  rtl8723au_write8(padapter, 1152, (int )rate_index);
  return;
}
}
static void _OneOutPipeMapping(struct rtw_adapter *pAdapter ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
  pdvobjpriv = pAdapter->dvobj;
  pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  return;
}
}
static void _TwoOutPipeMapping(struct rtw_adapter *pAdapter , bool bWIFICfg ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
  pdvobjpriv = pAdapter->dvobj;
  if ((int )bWIFICfg) {
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  } else {
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  }
  return;
}
}
static void _ThreeOutPipeMapping(struct rtw_adapter *pAdapter , bool bWIFICfg ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
  pdvobjpriv = pAdapter->dvobj;
  if ((int )bWIFICfg) {
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[2];
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  } else {
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[2];
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[2];
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  }
  return;
}
}
bool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter , u8 NumOutPipe ) 
{ 
  struct registry_priv *pregistrypriv ;
  bool bWIFICfg ;
  bool result ;

  {
  pregistrypriv = & pAdapter->registrypriv;
  bWIFICfg = (unsigned int )pregistrypriv->wifi_spec != 0U;
  result = 1;
  switch ((int )NumOutPipe) {
  case 2: 
  _TwoOutPipeMapping(pAdapter, (int )bWIFICfg);
  goto ldv_55822;
  case 3: 
  _ThreeOutPipeMapping(pAdapter, (int )bWIFICfg);
  goto ldv_55822;
  case 1: 
  _OneOutPipeMapping(pAdapter);
  goto ldv_55822;
  default: 
  result = 0;
  goto ldv_55822;
  }
  ldv_55822: ;
  return (result);
}
}
void c2h_evt_clear23a(struct rtw_adapter *adapter ) 
{ 


  {
  rtl8723au_write8(adapter, 431, 0);
  return;
}
}
s32 c2h_evt_read23a(struct rtw_adapter *adapter , u8 *buf ) 
{ 
  int ret ;
  struct c2h_evt_hdr *c2h_evt ;
  int i ;
  u8 trigger ;
  int __i ;
  u8 *ptr ;
  int __i___0 ;
  u8 *ptr___0 ;

  {
  ret = 0;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    goto exit;
  } else {

  }
  trigger = rtl8723au_read8(adapter, 431);
  if ((unsigned int )trigger == 0U) {
    goto exit;
  } else
  if ((unsigned int )trigger != 255U) {
    goto clear_evt;
  } else {

  }
  c2h_evt = (struct c2h_evt_hdr *)buf;
  memset((void *)c2h_evt, 0, 16UL);
  *buf = rtl8723au_read8(adapter, 416);
  *(buf + 1UL) = rtl8723au_read8(adapter, 417);
  if (GlobalDebugLevel23A > 6U) {
    ptr = (u8 *)(& c2h_evt);
    printk("\016%s", (char *)"RTL8723AU: ");
    printk("\016c2h_evt_read23a(): ");
    __i = 0;
    goto ldv_55842;
    ldv_55841: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((unsigned int )(__i + 1) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((unsigned int )(__i + 1) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1;
    ldv_55842: ;
    if (__i <= 7) {
      goto ldv_55841;
    } else {

    }
    printk("\n");
  } else {

  }
  i = 0;
  goto ldv_55846;
  ldv_55845: 
  c2h_evt->payload[i] = rtl8723au_read8(adapter, (int )((unsigned int )((u16 )i) + 418U));
  i = i + 1;
  ldv_55846: ;
  if ((int )c2h_evt->plen > i) {
    goto ldv_55845;
  } else {

  }

  if (GlobalDebugLevel23A > 6U) {
    ptr___0 = (u8 *)(& c2h_evt->payload);
    printk("\016%s", (char *)"RTL8723AU: ");
    printk("\016c2h_evt_read23a(): Command Content:\n");
    __i___0 = 0;
    goto ldv_55851;
    ldv_55850: 
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((unsigned int )(__i___0 + 1) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((unsigned int )(__i___0 + 1) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i___0 = __i___0 + 1;
    ldv_55851: ;
    if ((int )c2h_evt->plen > __i___0) {
      goto ldv_55850;
    } else {

    }
    printk("\n");
  } else {

  }
  ret = 1;
  clear_evt: 
  c2h_evt_clear23a(adapter);
  exit: ;
  return (ret);
}
}
void rtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter , u8 MinSpacingToSet ) 
{ 
  u8 SecMinSpace ;
  u8 tmp ;

  {
  if ((unsigned int )MinSpacingToSet <= 7U) {
    switch (padapter->securitypriv.dot11PrivacyAlgrthm) {
    case 0U: ;
    case 1027076U: 
    SecMinSpace = 0U;
    goto ldv_55860;
    case 1027073U: ;
    case 1027077U: ;
    case 1027074U: 
    SecMinSpace = 6U;
    goto ldv_55860;
    default: 
    SecMinSpace = 7U;
    goto ldv_55860;
    }
    ldv_55860: ;
    if ((int )MinSpacingToSet < (int )SecMinSpace) {
      MinSpacingToSet = SecMinSpace;
    } else {

    }
    tmp = rtl8723au_read8(padapter, 1116);
    MinSpacingToSet = (u8 )(((int )((signed char )tmp) & -8) | (int )((signed char )MinSpacingToSet));
    rtl8723au_write8(padapter, 1116, (int )MinSpacingToSet);
  } else {

  }
  return;
}
}
void rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter , u8 FactorToSet ) 
{ 
  u8 RegToSet_Normal[4U] ;
  u8 MaxAggNum ;
  u8 *pRegToSet ;
  u8 index ;
  bool tmp ;
  bool tmp___0 ;

  {
  RegToSet_Normal[0] = 65U;
  RegToSet_Normal[1] = 168U;
  RegToSet_Normal[2] = 114U;
  RegToSet_Normal[3] = 185U;
  index = 0U;
  pRegToSet = (u8 *)(& RegToSet_Normal);
  tmp = rtl8723a_BT_enabled(padapter);
  if ((int )tmp) {
    tmp___0 = rtl8723a_BT_using_antenna_1(padapter);
    if ((int )tmp___0) {
      MaxAggNum = 8U;
    } else {
      MaxAggNum = 15U;
    }
  } else {
    MaxAggNum = 15U;
  }
  if ((unsigned int )FactorToSet <= 3U) {
    FactorToSet = (u8 )(1 << ((int )FactorToSet + 2));
    if ((int )FactorToSet > (int )MaxAggNum) {
      FactorToSet = MaxAggNum;
    } else {

    }
    index = 0U;
    goto ldv_55874;
    ldv_55873: ;
    if (((int )*(pRegToSet + (unsigned long )index) & 240) > (int )FactorToSet << 4) {
      *(pRegToSet + (unsigned long )index) = (u8 )(((int )((signed char )*(pRegToSet + (unsigned long )index)) & 15) | (int )((signed char )((int )FactorToSet << 4)));
    } else {

    }
    if (((int )*(pRegToSet + (unsigned long )index) & 15) > (int )FactorToSet) {
      *(pRegToSet + (unsigned long )index) = (u8 )(((int )((signed char )*(pRegToSet + (unsigned long )index)) & -16) | (int )((signed char )FactorToSet));
    } else {

    }
    rtl8723au_write8(padapter, (int )((unsigned int )((u16 )index) + 1112U), (int )*(pRegToSet + (unsigned long )index));
    index = (u8 )((int )index + 1);
    ldv_55874: ;
    if ((unsigned int )index <= 3U) {
      goto ldv_55873;
    } else {

    }

  } else {

  }
  return;
}
}
void rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter , u8 ctrl ) 
{ 
  u8 hwctrl ;

  {
  hwctrl = 0U;
  if ((unsigned int )ctrl != 0U) {
    hwctrl = (u8 )((unsigned int )hwctrl | 1U);
    if (((unsigned long )ctrl & 2UL) != 0UL) {
      hwctrl = (u8 )((unsigned int )hwctrl | 2U);
    } else {

    }
    if (((unsigned long )ctrl & 4UL) != 0UL) {
      hwctrl = (u8 )((unsigned int )hwctrl | 4U);
    } else {

    }
    if (((unsigned long )ctrl & 8UL) != 0UL) {
      hwctrl = (u8 )((unsigned int )hwctrl | 8U);
    } else {

    }
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: [HW_VAR_ACM_CTRL] Write 0x%02X\n", (int )hwctrl);
  } else {

  }
  rtl8723au_write8(padapter, 1472, (int )hwctrl);
  return;
}
}
void rtl8723a_set_media_status(struct rtw_adapter *padapter , u8 status ) 
{ 
  u8 val8 ;
  u8 tmp ;

  {
  tmp = rtl8723au_read8(padapter, 258);
  val8 = (unsigned int )tmp & 12U;
  val8 = (u8 )((int )val8 | (int )status);
  rtl8723au_write8(padapter, 258, (int )val8);
  return;
}
}
void rtl8723a_set_media_status1(struct rtw_adapter *padapter , u8 status ) 
{ 
  u8 val8 ;
  u8 tmp ;

  {
  tmp = rtl8723au_read8(padapter, 258);
  val8 = (unsigned int )tmp & 3U;
  val8 = (u8 )((int )((signed char )((int )status << 2)) | (int )((signed char )val8));
  rtl8723au_write8(padapter, 258, (int )val8);
  return;
}
}
void rtl8723a_set_bcn_func(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
  if ((unsigned int )val != 0U) {
    SetBcnCtrlReg23a(padapter, 12, 0);
  } else {
    SetBcnCtrlReg23a(padapter, 0, 12);
  }
  return;
}
}
void rtl8723a_check_bssid(struct rtw_adapter *padapter , u8 val ) 
{ 
  u32 val32 ;

  {
  val32 = rtl8723au_read32(padapter, 1544);
  if ((unsigned int )val != 0U) {
    val32 = val32 | 192U;
  } else {
    val32 = val32 & 4294967103U;
  }
  rtl8723au_write32(padapter, 1544, val32);
  return;
}
}
void rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter , u8 flag ) 
{ 
  u32 v32 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 v32___0 ;
  bool tmp ;

  {
  if ((unsigned int )flag != 0U) {
    v32 = rtl8723au_read32(padapter, 1544);
    v32 = v32 & 4294967167U;
    rtl8723au_write32(padapter, 1544, v32);
    rtl8723au_write16(padapter, 1700, 0);
    SetBcnCtrlReg23a(padapter, 16, 0);
  } else {
    pmlmeext = & padapter->mlmeextpriv;
    pmlmeinfo = & pmlmeext->mlmext_info;
    tmp = is_client_associated_to_ap23a(padapter);
    if (((int )tmp || (pmlmeinfo->state & 3U) == 1U) || (pmlmeinfo->state & 3U) == 3U) {
      rtl8723au_write16(padapter, 1700, 65535);
      SetBcnCtrlReg23a(padapter, 0, 16);
    } else {

    }
    v32___0 = rtl8723au_read32(padapter, 1544);
    v32___0 = v32___0 | 128U;
    rtl8723au_write32(padapter, 1544, v32___0);
  }
  rtl8723a_BT_wifiscan_notify(padapter, (unsigned int )flag != 0U);
  return;
}
}
void rtl8723a_on_rcr_am(struct rtw_adapter *padapter ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
  tmp = rtl8723au_read32(padapter, 1544);
  rtl8723au_write32(padapter, 1544, tmp | 4U);
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = rtl8723au_read32(padapter, 1544);
    printk("\016RTL8723AU: %s, %d, RCR = %x\n", "rtl8723a_on_rcr_am", 545, tmp___0);
  } else {

  }
  return;
}
}
void rtl8723a_off_rcr_am(struct rtw_adapter *padapter ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
  tmp = rtl8723au_read32(padapter, 1544);
  rtl8723au_write32(padapter, 1544, tmp & 4294967291U);
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = rtl8723au_read32(padapter, 1544);
    printk("\016RTL8723AU: %s, %d, RCR = %x\n", "rtl8723a_off_rcr_am", 553, tmp___0);
  } else {

  }
  return;
}
}
void rtl8723a_set_slot_time(struct rtw_adapter *padapter , u8 slottime ) 
{ 
  u8 u1bAIFS ;
  u8 aSifsTime ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  rtl8723au_write8(padapter, 1307, (int )slottime);
  if ((unsigned int )pmlmeinfo->WMM_enable == 0U) {
    if ((unsigned int )pmlmeext->cur_wireless_mode == 1U) {
      aSifsTime = 10U;
    } else {
      aSifsTime = 16U;
    }
    u1bAIFS = (unsigned int )pmlmeinfo->slotTime * 2U + (unsigned int )aSifsTime;
    rtl8723au_write8(padapter, 1280, (int )u1bAIFS);
    rtl8723au_write8(padapter, 1284, (int )u1bAIFS);
    rtl8723au_write8(padapter, 1288, (int )u1bAIFS);
    rtl8723au_write8(padapter, 1292, (int )u1bAIFS);
  } else {

  }
  return;
}
}
void rtl8723a_ack_preamble(struct rtw_adapter *padapter , u8 bShortPreamble ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 regTmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  regTmp = (int )pHalData->nCur40MhzPrimeSC << 5U;
  if ((unsigned int )bShortPreamble != 0U) {
    regTmp = (u8 )((unsigned int )regTmp | 128U);
  } else {

  }
  rtl8723au_write8(padapter, 1090, (int )regTmp);
  return;
}
}
void rtl8723a_set_sec_cfg(struct rtw_adapter *padapter , u8 sec ) 
{ 


  {
  rtl8723au_write8(padapter, 1664, (int )sec);
  return;
}
}
void rtl8723a_cam_empty_entry(struct rtw_adapter *padapter , u8 ucIndex ) 
{ 
  u8 i ;
  u32 ulCommand ;
  u32 ulContent ;
  u32 ulEncAlgo ;

  {
  ulCommand = 0U;
  ulContent = 0U;
  ulEncAlgo = 4U;
  i = 0U;
  goto ldv_55943;
  ldv_55942: ;
  if ((unsigned int )i == 0U) {
    ulContent = (u32 )(((int )ucIndex & 3) | ((int )((unsigned short )ulEncAlgo) << 2)) | ulContent;
  } else {
    ulContent = 0U;
  }
  ulCommand = (u32 )((int )ucIndex * 8 + (int )i);
  ulCommand = ulCommand | 2147549184U;
  rtl8723au_write32(padapter, 1652, ulContent);
  rtl8723au_write32(padapter, 1648, ulCommand);
  i = (u8 )((int )i + 1);
  ldv_55943: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_55942;
  } else {

  }

  return;
}
}
void rtl8723a_cam_invalidate_all(struct rtw_adapter *padapter ) 
{ 


  {
  rtl8723au_write32(padapter, 1648, 3221225472U);
  return;
}
}
void rtl8723a_cam_write(struct rtw_adapter *padapter , u8 entry , u16 ctrl , u8 const   *mac ,
                        u8 const   *key ) 
{ 
  u32 cmd ;
  unsigned int i ;
  unsigned int val ;
  unsigned int addr ;
  int j ;

  {
  addr = (unsigned int )((int )entry << 3);
  j = 5;
  goto ldv_55965;
  ldv_55964: ;
  switch (j) {
  case 0: 
  val = (unsigned int )(((int )ctrl | ((int )*mac << 16)) | ((int )*(mac + 1UL) << 24));
  goto ldv_55961;
  case 1: 
  val = (unsigned int )((((int )*(mac + 2UL) | ((int )*(mac + 3UL) << 8)) | ((int )*(mac + 4UL) << 16)) | ((int )*(mac + 5UL) << 24));
  goto ldv_55961;
  default: 
  i = (unsigned int )((j + -2) << 2);
  val = (unsigned int )((((int )*(key + (unsigned long )i) | ((int )*(key + (unsigned long )(i + 1U)) << 8)) | ((int )*(key + (unsigned long )(i + 2U)) << 16)) | ((int )*(key + (unsigned long )(i + 3U)) << 24));
  goto ldv_55961;
  }
  ldv_55961: 
  rtl8723au_write32(padapter, 1652, val);
  cmd = (addr + (unsigned int )j) | 2147549184U;
  rtl8723au_write32(padapter, 1648, cmd);
  j = j - 1;
  ldv_55965: ;
  if (j >= 0) {
    goto ldv_55964;
  } else {

  }

  return;
}
}
void rtl8723a_fifo_cleanup(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  u8 trycnt ;
  u32 v32 ;
  u32 tmp ;
  u8 tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  trycnt = 100U;
  rtl8723au_write8(padapter, 1314, 255);
  padapter->xmitpriv.nqos_ssn = rtl8723au_read8(padapter, 1244);
  if ((unsigned int )pwrpriv->bkeepfwalive != 1U) {
    v32 = rtl8723au_read32(padapter, 644);
    v32 = v32 | 262144U;
    rtl8723au_write32(padapter, 644, v32);
    ldv_55974: 
    tmp = rtl8723au_read32(padapter, 644);
    v32 = tmp & 131072U;
    if (v32 == 0U) {
      goto ldv_55973;
    } else {

    }
    tmp___0 = trycnt;
    trycnt = (u8 )((int )trycnt - 1);
    if ((unsigned int )tmp___0 != 0U) {
      goto ldv_55974;
    } else {

    }
    ldv_55973: ;
    if ((unsigned int )trycnt == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Stop RX DMA failed......\n");
      } else {

      }
    } else {

    }
    rtl8723au_write16(padapter, 532, 0);
    rtl8723au_write32(padapter, 512, 2147483648U);
    __ms = 10UL;
    goto ldv_55977;
    ldv_55976: 
    __const_udelay(4295000UL);
    ldv_55977: 
    tmp___1 = __ms;
    __ms = __ms - 1UL;
    if (tmp___1 != 0UL) {
      goto ldv_55976;
    } else {

    }

  } else {

  }
  return;
}
}
void rtl8723a_bcn_valid(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
  tmp = rtl8723au_read8(padapter, 522);
  rtl8723au_write8(padapter, 522, (int )((unsigned int )tmp | 1U));
  return;
}
}
bool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter ) 
{ 
  bool retval ;
  u8 tmp ;

  {
  tmp = rtl8723au_read8(padapter, 522);
  retval = ((int )tmp & 1) != 0;
  return (retval);
}
}
void rtl8723a_set_beacon_interval(struct rtw_adapter *padapter , u16 interval ) 
{ 


  {
  rtl8723au_write16(padapter, 1364, (int )interval);
  return;
}
}
void rtl8723a_set_resp_sifs(struct rtw_adapter *padapter , u8 r2t1 , u8 r2t2 , u8 t2t1 ,
                            u8 t2t2 ) 
{ 


  {
  rtl8723au_write8(padapter, 1596, (int )r2t1);
  rtl8723au_write8(padapter, 1597, (int )r2t2);
  rtl8723au_write8(padapter, 1598, (int )t2t1);
  rtl8723au_write8(padapter, 1599, (int )t2t2);
  return;
}
}
void rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter , u32 vo ) 
{ 


  {
  rtl8723au_write32(padapter, 1280, vo);
  return;
}
}
void rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter , u32 vi ) 
{ 


  {
  rtl8723au_write32(padapter, 1284, vi);
  return;
}
}
void rtl8723a_set_ac_param_be(struct rtw_adapter *padapter , u32 be ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->AcParam_BE = be;
  rtl8723au_write32(padapter, 1288, be);
  return;
}
}
void rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter , u32 bk ) 
{ 


  {
  rtl8723au_write32(padapter, 1292, bk);
  return;
}
}
void rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
  rtl8723au_write8(padapter, 640, (int )val);
  return;
}
}
void rtl8723a_set_initial_gain(struct rtw_adapter *padapter , u32 rx_gain ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dig_t *pDigTable ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pDigTable = & pHalData->odmpriv.DM_DigTable;
  if (rx_gain == 255U) {
    ODM_Write_DIG23a(& pHalData->odmpriv, (int )pDigTable->BackupIGValue);
  } else {
    pDigTable->BackupIGValue = pDigTable->CurIGValue;
    ODM_Write_DIG23a(& pHalData->odmpriv, (int )((u8 )rx_gain));
  }
  return;
}
}
void rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->odmpriv.SupportAbility = pHalData->odmpriv.BK_SupportAbility;
  return;
}
}
void rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->odmpriv.BK_SupportAbility = pHalData->odmpriv.SupportAbility;
  return;
}
}
void rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter , u32 val ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (val == 268435455U) {
    pHalData->odmpriv.SupportAbility = pHalData->dmpriv.InitODMFlag;
  } else {
    pHalData->odmpriv.SupportAbility = pHalData->odmpriv.SupportAbility | val;
  }
  return;
}
}
void rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter , u32 val ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->odmpriv.SupportAbility = pHalData->odmpriv.SupportAbility & val;
  return;
}
}
void rtl8723a_set_rpwm(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
  rtl8723au_write8(padapter, 65112, (int )val);
  return;
}
}
u8 rtl8723a_get_rf_type(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  return (pHalData->rf_type);
}
}
bool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter ) 
{ 
  bool retval ;
  u32 valRCR ;

  {
  if (padapter->bSurpriseRemoved == 1 || (unsigned int )padapter->pwrctrlpriv.rf_pwrstate == 2U) {
    retval = 1;
  } else {
    valRCR = rtl8723au_read32(padapter, 1544);
    if ((valRCR & 458752U) != 0U) {
      retval = 0;
    } else {
      retval = 1;
    }
  }
  return (retval);
}
}
bool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter ) 
{ 
  u32 hgq ;

  {
  hgq = rtl8723au_read32(padapter, 1044);
  return ((hgq & 65280U) == 0U);
}
}
bool ldv_queue_work_on_271(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_272(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_273(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_274(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_275(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_285(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_287(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_286(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_289(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_288(struct workqueue_struct *ldv_func_arg1 ) ;
void add_RATid23a(struct rtw_adapter *padapter , struct sta_info *psta , u8 rssi_level ) ;
void rtl8723a_update_ramask(struct rtw_adapter *padapter , u32 mac_id , u8 rssi_level ) ;
void rtw_hal_update_ra_mask23a(struct sta_info *psta , u8 rssi_level ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {

  }
  padapter = psta->padapter;
  pmlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    add_RATid23a(padapter, psta, (int )rssi_level);
  } else {
    rtl8723a_update_ramask(padapter, psta->mac_id, (int )rssi_level);
  }
  return;
}
}
bool ldv_queue_work_on_285(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_286(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_287(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_288(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_289(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_301(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_300(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_303(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_302(struct workqueue_struct *ldv_func_arg1 ) ;
struct wlan_pwr_cfg rtl8723AU_power_on_flow[16U] ;
struct wlan_pwr_cfg rtl8723AU_radio_off_flow[16U] ;
struct wlan_pwr_cfg rtl8723AU_card_disable_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_card_enable_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_suspend_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_resume_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_hwpdn_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_enter_lps_flow[16U] ;
struct wlan_pwr_cfg rtl8723AU_leave_lps_flow[16U] ;
struct wlan_pwr_cfg rtl8723AU_power_on_flow[16U]  = 
  {      {32U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 2U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 2U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_radio_off_flow[16U]  = {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_card_disable_flow[31U]  = 
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 2U, 0U, 1U, 24U, 8U}, 
        {74U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_card_enable_flow[31U]  = 
  {      {5U, 255U, 15U, 15U, 0U, 1U, 136U, 0U}, 
        {74U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 2U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 2U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_suspend_flow[31U]  = 
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 2U, 0U, 1U, 24U, 8U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_resume_flow[31U]  = 
  {      {5U, 255U, 15U, 15U, 0U, 1U, 136U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 2U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 2U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_hwpdn_flow[31U]  = 
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 2U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {7U, 255U, 15U, 2U, 0U, 1U, 255U, 32U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 128U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_enter_lps_flow[16U]  = 
  {      {1314U, 255U, 15U, 15U, 0U, 1U, 255U, 255U}, 
        {1528U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1529U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1530U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1531U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 1U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 3U, 0U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 2U, 0U}, 
        {256U, 255U, 15U, 15U, 0U, 1U, 255U, 3U}, 
        {257U, 255U, 15U, 15U, 0U, 1U, 2U, 0U}, 
        {1363U, 255U, 15U, 15U, 0U, 1U, 32U, 32U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_leave_lps_flow[16U]  = 
  {      {65112U, 255U, 15U, 2U, 0U, 1U, 255U, 132U}, 
        {2U, 255U, 15U, 15U, 0U, 3U, 0U, 1U}, 
        {8U, 255U, 15U, 15U, 0U, 1U, 16U, 0U}, 
        {265U, 255U, 15U, 15U, 0U, 2U, 128U, 0U}, 
        {41U, 255U, 15U, 15U, 0U, 1U, 192U, 0U}, 
        {257U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {256U, 255U, 15U, 15U, 0U, 1U, 255U, 255U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 3U, 3U}, 
        {1314U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
bool ldv_queue_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_300(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_301(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_302(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_303(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_313(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_315(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_314(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_317(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_316(struct workqueue_struct *ldv_func_arg1 ) ;
u32 Rtl8723UPHY_REG_Array_PG[336U] ;
u32 Rtl8723UMACPHY_Array_PG[1U] ;
u32 Rtl8723UPHY_REG_Array_PG[336U]  = 
  {      3584U,      4294967295U,      168561676U,      3588U, 
        4294967295U,      33818120U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      168561934U,      3604U, 
        4294967295U,      33818120U,      3608U,      4294967295U, 
        168561934U,      3612U,      4294967295U,      33818120U, 
        2096U,      4294967295U,      168561676U,      2100U, 
        4294967295U,      33818120U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      168561934U,      2120U, 
        4294967295U,      33818120U,      2124U,      4294967295U, 
        168561934U,      2152U,      4294967295U,      33818120U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      67372036U,      3588U, 
        4294967295U,      131588U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      101058054U,      3604U, 
        4294967295U,      132102U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      67372036U,      2100U, 
        4294967295U,      131588U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      101058054U,      2120U, 
        4294967295U,      132102U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      67372036U,      3588U, 
        4294967295U,      131588U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      67372036U,      2100U, 
        4294967295U,      131588U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U};
u32 Rtl8723UMACPHY_Array_PG[1U]  = {      0U};
bool ldv_queue_work_on_313(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_314(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_315(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_316(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_317(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_327(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_329(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_328(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_331(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_330(struct workqueue_struct *ldv_func_arg1 ) ;
u32 PHY_QueryBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask ) ;
void PHY_SetBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask , u32 Data ) ;
u32 PHY_QueryRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                   u32 BitMask ) ;
void PHY_SetRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) ;
u32 OFDMSwingTable23A[43U] ;
u8 CCKSwingTable_Ch1_Ch1323A[33U][8U] ;
u8 CCKSwingTable_Ch1423A[33U][8U] ;
void rtl8723a_phy_iq_calibrate(struct rtw_adapter *pAdapter , bool bReCovery ) ;
void rtl8723a_phy_lc_calibrate(struct rtw_adapter *pAdapter ) ;
void rtl8723a_phy_ap_calibrate(struct rtw_adapter *pAdapter , char delta ) ;
void rtl8723a_odm_check_tx_power_tracking(struct rtw_adapter *Adapter ) ;
static void odm_TXPowerTrackingCallback_ThermalMeter_92C(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 ThermalValue ;
  u8 delta ;
  u8 delta_LCK ;
  u8 delta_IQK ;
  u8 delta_HP ;
  int ele_A ;
  int ele_D ;
  int TempCCk ;
  int X ;
  int value32 ;
  int Y ;
  int ele_C ;
  s8 OFDM_index[2U] ;
  s8 CCK_index ;
  s8 OFDM_index_old[2U] ;
  unsigned int tmp ;
  s8 CCK_index_old ;
  int i ;
  u8 OFDM_min_index ;
  u8 rf ;
  u8 ThermalValue_HP_count ;
  u32 ThermalValue_HP ;
  s32 index_mapping_HP[15U] ;
  s8 index_HP ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  ThermalValue = 0U;
  CCK_index = 0;
  OFDM_index_old[0] = 0;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    OFDM_index_old[tmp] = (signed char)0;
    tmp = tmp + 1U;
  }
  CCK_index_old = 0;
  i = 0;
  OFDM_min_index = 6U;
  ThermalValue_HP_count = 0U;
  ThermalValue_HP = 0U;
  index_mapping_HP[0] = 0;
  index_mapping_HP[1] = 1;
  index_mapping_HP[2] = 3;
  index_mapping_HP[3] = 4;
  index_mapping_HP[4] = 6;
  index_mapping_HP[5] = 7;
  index_mapping_HP[6] = 9;
  index_mapping_HP[7] = 10;
  index_mapping_HP[8] = 12;
  index_mapping_HP[9] = 13;
  index_mapping_HP[10] = 15;
  index_mapping_HP[11] = 16;
  index_mapping_HP[12] = 18;
  index_mapping_HP[13] = 19;
  index_mapping_HP[14] = 21;
  pdmpriv->TXPowerTrackingCallbackCnt = pdmpriv->TXPowerTrackingCallbackCnt + 1U;
  pdmpriv->bTXPowerTrackingInit = 1U;
  if ((unsigned int )pHalData->CurrentChannel == 14U && (unsigned int )pdmpriv->bCCKinCH14 == 0U) {
    pdmpriv->bCCKinCH14 = 1U;
  } else
  if ((unsigned int )pHalData->CurrentChannel != 14U && (unsigned int )pdmpriv->bCCKinCH14 != 0U) {
    pdmpriv->bCCKinCH14 = 0U;
  } else {

  }
  tmp___0 = PHY_QueryRFReg(Adapter, 0, 36U, 31U);
  ThermalValue = (unsigned char )tmp___0;
  rtl8723a_phy_ap_calibrate(Adapter, (int )((char )((int )ThermalValue - (int )pHalData->EEPROMThermalMeter)));
  if ((unsigned int )pHalData->rf_type == 2U) {
    rf = 2U;
  } else {
    rf = 1U;
  }
  if ((unsigned int )ThermalValue != 0U) {
    tmp___1 = rtl8723au_read32(Adapter, 3200);
    ele_D = (int )tmp___1 & -4194304;
    i = 0;
    goto ldv_55774;
    ldv_55773: ;
    if ((u32 )ele_D == (OFDMSwingTable23A[i] & 4290772992U)) {
      OFDM_index_old[0] = (s8 )i;
      goto ldv_55772;
    } else {

    }
    i = i + 1;
    ldv_55774: ;
    if (i <= 36) {
      goto ldv_55773;
    } else {

    }
    ldv_55772: ;
    if ((unsigned int )pHalData->rf_type == 2U) {
      tmp___2 = rtl8723au_read32(Adapter, 3208);
      ele_D = (int )tmp___2;
      ele_D = ele_D & -4194304;
      i = 0;
      goto ldv_55777;
      ldv_55776: ;
      if ((u32 )ele_D == (OFDMSwingTable23A[i] & 4290772992U)) {
        OFDM_index_old[1] = (s8 )i;
        goto ldv_55775;
      } else {

      }
      i = i + 1;
      ldv_55777: ;
      if (i <= 36) {
        goto ldv_55776;
      } else {

      }
      ldv_55775: ;
    } else {

    }
    tmp___3 = rtl8723au_read32(Adapter, 2596);
    TempCCk = (int )tmp___3 & 1061109567;
    i = 0;
    goto ldv_55780;
    ldv_55779: ;
    if ((unsigned int )pdmpriv->bCCKinCH14 != 0U) {
      tmp___4 = memcmp((void const   *)(& TempCCk), (void const   *)(& CCKSwingTable_Ch1423A) + ((unsigned long )i + 2UL),
                       4UL);
      if (tmp___4 == 0) {
        CCK_index_old = (s8 )i;
        goto ldv_55778;
      } else {

      }
    } else {
      tmp___5 = memcmp((void const   *)(& TempCCk), (void const   *)(& CCKSwingTable_Ch1_Ch1323A) + ((unsigned long )i + 2UL),
                       4UL);
      if (tmp___5 == 0) {
        CCK_index_old = (s8 )i;
        goto ldv_55778;
      } else {

      }
    }
    i = i + 1;
    ldv_55780: ;
    if (i <= 32) {
      goto ldv_55779;
    } else {

    }
    ldv_55778: ;
    if ((unsigned int )pdmpriv->ThermalValue == 0U) {
      pdmpriv->ThermalValue = pHalData->EEPROMThermalMeter;
      pdmpriv->ThermalValue_LCK = ThermalValue;
      pdmpriv->ThermalValue_IQK = ThermalValue;
      pdmpriv->ThermalValue_DPK = pHalData->EEPROMThermalMeter;
      i = 0;
      goto ldv_55782;
      ldv_55781: 
      pdmpriv->OFDM_index_HP[i] = (u8 )OFDM_index_old[i];
      pdmpriv->OFDM_index[i] = (u8 )OFDM_index_old[i];
      i = i + 1;
      ldv_55782: ;
      if ((int )rf > i) {
        goto ldv_55781;
      } else {

      }
      pdmpriv->CCK_index_HP = (u8 )CCK_index_old;
      pdmpriv->CCK_index = (u8 )CCK_index_old;
    } else {

    }
    if ((unsigned int )pHalData->BoardType == 1U) {
      pdmpriv->ThermalValue_HP[(int )pdmpriv->ThermalValue_HP_index] = ThermalValue;
      pdmpriv->ThermalValue_HP_index = (u8 )((int )pdmpriv->ThermalValue_HP_index + 1);
      if ((unsigned int )pdmpriv->ThermalValue_HP_index == 8U) {
        pdmpriv->ThermalValue_HP_index = 0U;
      } else {

      }
      i = 0;
      goto ldv_55785;
      ldv_55784: ;
      if ((unsigned int )pdmpriv->ThermalValue_HP[i] != 0U) {
        ThermalValue_HP = (u32 )pdmpriv->ThermalValue_HP[i] + ThermalValue_HP;
        ThermalValue_HP_count = (u8 )((int )ThermalValue_HP_count + 1);
      } else {

      }
      i = i + 1;
      ldv_55785: ;
      if (i <= 7) {
        goto ldv_55784;
      } else {

      }

      if ((unsigned int )ThermalValue_HP_count != 0U) {
        ThermalValue = (unsigned char )(ThermalValue_HP / (u32 )ThermalValue_HP_count);
      } else {

      }
    } else {

    }
    delta = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
    if ((unsigned int )pHalData->BoardType == 1U) {
      if ((unsigned int )pdmpriv->bDoneTxpower != 0U) {
        delta_HP = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
      } else {
        delta_HP = (int )pHalData->EEPROMThermalMeter < (int )ThermalValue ? (int )ThermalValue - (int )pHalData->EEPROMThermalMeter : (int )pHalData->EEPROMThermalMeter - (int )ThermalValue;
      }
    } else {
      delta_HP = 0U;
    }
    delta_LCK = (int )pdmpriv->ThermalValue_LCK < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue_LCK : (int )pdmpriv->ThermalValue_LCK - (int )ThermalValue;
    delta_IQK = (int )pdmpriv->ThermalValue_IQK < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue_IQK : (int )pdmpriv->ThermalValue_IQK - (int )ThermalValue;
    if ((unsigned int )delta_LCK > 1U) {
      pdmpriv->ThermalValue_LCK = ThermalValue;
      rtl8723a_phy_lc_calibrate(Adapter);
    } else {

    }
    if (((unsigned int )delta != 0U || (unsigned int )delta_HP != 0U) && (unsigned int )pdmpriv->TxPowerTrackControl != 0U) {
      if ((unsigned int )pHalData->BoardType == 1U) {
        pdmpriv->bDoneTxpower = 1U;
        delta_HP = (int )pHalData->EEPROMThermalMeter < (int )ThermalValue ? (int )ThermalValue - (int )pHalData->EEPROMThermalMeter : (int )pHalData->EEPROMThermalMeter - (int )ThermalValue;
        if ((unsigned int )delta_HP > 14U) {
          index_HP = (s8 )index_mapping_HP[14];
        } else {
          index_HP = (s8 )index_mapping_HP[(int )delta_HP];
        }
        if ((int )pHalData->EEPROMThermalMeter < (int )ThermalValue) {
          i = 0;
          goto ldv_55788;
          ldv_55787: 
          OFDM_index[i] = (s8 )((int )pdmpriv->OFDM_index_HP[i] - (int )((unsigned char )index_HP));
          i = i + 1;
          ldv_55788: ;
          if ((int )rf > i) {
            goto ldv_55787;
          } else {

          }
          CCK_index = (s8 )((int )pdmpriv->CCK_index_HP - (int )((unsigned char )index_HP));
        } else {
          i = 0;
          goto ldv_55791;
          ldv_55790: 
          OFDM_index[i] = (s8 )((int )pdmpriv->OFDM_index_HP[i] + (int )((unsigned char )index_HP));
          i = i + 1;
          ldv_55791: ;
          if ((int )rf > i) {
            goto ldv_55790;
          } else {

          }
          CCK_index = (s8 )((int )pdmpriv->CCK_index_HP + (int )((unsigned char )index_HP));
        }
        delta_HP = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
      } else
      if ((int )pdmpriv->ThermalValue < (int )ThermalValue) {
        i = 0;
        goto ldv_55794;
        ldv_55793: 
        pdmpriv->OFDM_index[i] = (int )pdmpriv->OFDM_index[i] - (int )delta;
        i = i + 1;
        ldv_55794: ;
        if ((int )rf > i) {
          goto ldv_55793;
        } else {

        }
        pdmpriv->CCK_index = (int )pdmpriv->CCK_index - (int )delta;
      } else {
        i = 0;
        goto ldv_55797;
        ldv_55796: 
        pdmpriv->OFDM_index[i] = (int )pdmpriv->OFDM_index[i] + (int )delta;
        i = i + 1;
        ldv_55797: ;
        if ((int )rf > i) {
          goto ldv_55796;
        } else {

        }
        pdmpriv->CCK_index = (int )pdmpriv->CCK_index + (int )delta;
      }
      if ((unsigned int )pHalData->BoardType != 1U) {
        if ((int )pHalData->EEPROMThermalMeter < (int )ThermalValue) {
          i = 0;
          goto ldv_55800;
          ldv_55799: 
          OFDM_index[i] = (s8 )((unsigned int )pdmpriv->OFDM_index[i] + 1U);
          i = i + 1;
          ldv_55800: ;
          if ((int )rf > i) {
            goto ldv_55799;
          } else {

          }
          CCK_index = (s8 )((unsigned int )pdmpriv->CCK_index + 1U);
        } else {
          i = 0;
          goto ldv_55803;
          ldv_55802: 
          OFDM_index[i] = (s8 )pdmpriv->OFDM_index[i];
          i = i + 1;
          ldv_55803: ;
          if ((int )rf > i) {
            goto ldv_55802;
          } else {

          }
          CCK_index = (s8 )pdmpriv->CCK_index;
        }
      } else {

      }
      i = 0;
      goto ldv_55806;
      ldv_55805: ;
      if ((int )OFDM_index[i] > 36) {
        OFDM_index[i] = 36;
      } else
      if ((int )OFDM_index[i] < (int )OFDM_min_index) {
        OFDM_index[i] = (s8 )OFDM_min_index;
      } else {

      }
      i = i + 1;
      ldv_55806: ;
      if ((int )rf > i) {
        goto ldv_55805;
      } else {

      }

      if ((int )CCK_index > 32) {
        CCK_index = 32;
      } else
      if ((int )CCK_index < 0) {
        CCK_index = 0;
      } else {

      }
    } else {

    }
    if ((unsigned int )pdmpriv->TxPowerTrackControl != 0U && ((unsigned int )delta != 0U || (unsigned int )delta_HP != 0U)) {
      ele_D = (int )(OFDMSwingTable23A[(int )OFDM_index[0]] >> 22);
      X = pdmpriv->RegE94;
      Y = pdmpriv->RegE9C;
      if (X != 0) {
        if ((X & 512) != 0) {
          X = (int )((unsigned int )X | 4294966272U);
        } else {

        }
        ele_A = (X * ele_D >> 8) & 1023;
        if ((Y & 512) != 0) {
          Y = (int )((unsigned int )Y | 4294966272U);
        } else {

        }
        ele_C = (Y * ele_D >> 8) & 1023;
        value32 = ((ele_D << 22) | ((ele_C & 63) << 16)) | ele_A;
        rtl8723au_write32(Adapter, 3200, (u32 )value32);
        value32 = (ele_C & 960) >> 6;
        PHY_SetBBReg(Adapter, 3220U, 4026531840U, (u32 )value32);
        value32 = (X * ele_D >> 7) & 1;
        PHY_SetBBReg(Adapter, 3148U, 2147483648U, (u32 )value32);
        value32 = (Y * ele_D >> 7) & 1;
        PHY_SetBBReg(Adapter, 3148U, 536870912U, (u32 )value32);
      } else {
        rtl8723au_write32(Adapter, 3200, OFDMSwingTable23A[(int )OFDM_index[0]]);
        PHY_SetBBReg(Adapter, 3220U, 4026531840U, 0U);
        PHY_SetBBReg(Adapter, 3148U, 2684354560U, 0U);
      }
      if ((unsigned int )pdmpriv->bCCKinCH14 == 0U) {
        rtl8723au_write8(Adapter, 2594, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][0]);
        rtl8723au_write8(Adapter, 2595, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][1]);
        rtl8723au_write8(Adapter, 2596, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][2]);
        rtl8723au_write8(Adapter, 2597, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][3]);
        rtl8723au_write8(Adapter, 2598, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][4]);
        rtl8723au_write8(Adapter, 2599, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][5]);
        rtl8723au_write8(Adapter, 2600, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][6]);
        rtl8723au_write8(Adapter, 2601, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][7]);
      } else {
        rtl8723au_write8(Adapter, 2594, (int )CCKSwingTable_Ch1423A[(int )CCK_index][0]);
        rtl8723au_write8(Adapter, 2595, (int )CCKSwingTable_Ch1423A[(int )CCK_index][1]);
        rtl8723au_write8(Adapter, 2596, (int )CCKSwingTable_Ch1423A[(int )CCK_index][2]);
        rtl8723au_write8(Adapter, 2597, (int )CCKSwingTable_Ch1423A[(int )CCK_index][3]);
        rtl8723au_write8(Adapter, 2598, (int )CCKSwingTable_Ch1423A[(int )CCK_index][4]);
        rtl8723au_write8(Adapter, 2599, (int )CCKSwingTable_Ch1423A[(int )CCK_index][5]);
        rtl8723au_write8(Adapter, 2600, (int )CCKSwingTable_Ch1423A[(int )CCK_index][6]);
        rtl8723au_write8(Adapter, 2601, (int )CCKSwingTable_Ch1423A[(int )CCK_index][7]);
      }
      if ((unsigned int )pHalData->rf_type == 2U) {
        ele_D = (int )(OFDMSwingTable23A[(int )((unsigned char )OFDM_index[1])] >> 22);
        X = pdmpriv->RegEB4;
        Y = pdmpriv->RegEBC;
        if (X != 0) {
          if ((X & 512) != 0) {
            X = (int )((unsigned int )X | 4294966272U);
          } else {

          }
          ele_A = (X * ele_D >> 8) & 1023;
          if ((Y & 512) != 0) {
            Y = (int )((unsigned int )Y | 4294966272U);
          } else {

          }
          ele_C = (Y * ele_D >> 8) & 1023;
          value32 = ((ele_D << 22) | ((ele_C & 63) << 16)) | ele_A;
          rtl8723au_write32(Adapter, 3208, (u32 )value32);
          value32 = (ele_C & 960) >> 6;
          PHY_SetBBReg(Adapter, 3228U, 4026531840U, (u32 )value32);
          value32 = (X * ele_D >> 7) & 1;
          PHY_SetBBReg(Adapter, 3148U, 134217728U, (u32 )value32);
          value32 = (Y * ele_D >> 7) & 1;
          PHY_SetBBReg(Adapter, 3148U, 33554432U, (u32 )value32);
        } else {
          rtl8723au_write32(Adapter, 3208, OFDMSwingTable23A[(int )OFDM_index[1]]);
          PHY_SetBBReg(Adapter, 3228U, 4026531840U, 0U);
          PHY_SetBBReg(Adapter, 3148U, 167772160U, 0U);
        }
      } else {

      }
    } else {

    }
    if ((unsigned int )delta_IQK > 3U) {
      pdmpriv->ThermalValue_IQK = ThermalValue;
      rtl8723a_phy_iq_calibrate(Adapter, 0);
    } else {

    }
    if ((unsigned int )pdmpriv->TxPowerTrackControl != 0U) {
      pdmpriv->ThermalValue = ThermalValue;
    } else {

    }
  } else {

  }
  pdmpriv->TXPowercount = 0U;
  return;
}
}
static void ODM_TXPowerTracking92CDirectCall(struct rtw_adapter *Adapter ) 
{ 


  {
  odm_TXPowerTrackingCallback_ThermalMeter_92C(Adapter);
  return;
}
}
void rtl8723a_odm_check_tx_power_tracking(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  if ((unsigned int )pdmpriv->TM_Trigger == 0U) {
    PHY_SetRFReg(Adapter, 0, 36U, 1048575U, 96U);
    pdmpriv->TM_Trigger = 1U;
    return;
  } else {
    ODM_TXPowerTracking92CDirectCall(Adapter);
    pdmpriv->TM_Trigger = 0U;
  }
  return;
}
}
static u8 _PHY_PathA_IQK(struct rtw_adapter *pAdapter , bool configPathB ) 
{ 
  u32 regEAC ;
  u32 regE94 ;
  u32 regE9C ;
  u32 regEA4 ;
  u8 result ;
  struct hal_data_8723a *pHalData ;

  {
  result = 0U;
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  rtl8723au_write32(pAdapter, 3632, 268471327U);
  rtl8723au_write32(pAdapter, 3636, 268471327U);
  rtl8723au_write32(pAdapter, 3640, 2182349058U);
  rtl8723au_write32(pAdapter, 3644, (int )configPathB ? 672530946U : (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) ? 672530946U : 672531714U));
  if ((int )configPathB) {
    rtl8723au_write32(pAdapter, 3664, 268471330U);
    rtl8723au_write32(pAdapter, 3668, 268471330U);
    rtl8723au_write32(pAdapter, 3672, 2182349058U);
    rtl8723au_write32(pAdapter, 3676, 672530946U);
  } else {

  }
  rtl8723au_write32(pAdapter, 3660, 1059025U);
  rtl8723au_write32(pAdapter, 3656, 4177526784U);
  rtl8723au_write32(pAdapter, 3656, 4160749568U);
  __const_udelay(4295000UL);
  regEAC = rtl8723au_read32(pAdapter, 3756);
  regE94 = rtl8723au_read32(pAdapter, 3732);
  regE9C = rtl8723au_read32(pAdapter, 3740);
  regEA4 = rtl8723au_read32(pAdapter, 3748);
  if ((((unsigned long )regEAC & 268435456UL) == 0UL && (regE94 & 67043328U) >> 16 != 322U) && (regE9C & 67043328U) >> 16 != 66U) {
    result = (u8 )((unsigned int )result | 1U);
  } else {
    return (result);
  }
  if ((((unsigned long )regEAC & 134217728UL) == 0UL && (regEA4 & 67043328U) >> 16 != 306U) && (regEAC & 67043328U) >> 16 != 54U) {
    result = (u8 )((unsigned int )result | 2U);
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Path A Rx IQK fail!!\n");
  } else {

  }
  return (result);
}
}
static u8 _PHY_PathB_IQK(struct rtw_adapter *pAdapter ) 
{ 
  u32 regEAC ;
  u32 regEB4 ;
  u32 regEBC ;
  u32 regEC4 ;
  u32 regECC ;
  u8 result ;

  {
  result = 0U;
  rtl8723au_write32(pAdapter, 3680, 2U);
  rtl8723au_write32(pAdapter, 3680, 0U);
  __const_udelay(4295000UL);
  regEAC = rtl8723au_read32(pAdapter, 3756);
  regEB4 = rtl8723au_read32(pAdapter, 3764);
  regEBC = rtl8723au_read32(pAdapter, 3772);
  regEC4 = rtl8723au_read32(pAdapter, 3780);
  regECC = rtl8723au_read32(pAdapter, 3788);
  if (((int )regEAC >= 0 && (regEB4 & 67043328U) >> 16 != 322U) && (regEBC & 67043328U) >> 16 != 66U) {
    result = (u8 )((unsigned int )result | 1U);
  } else {
    return (result);
  }
  if ((((unsigned long )regEAC & 1073741824UL) == 0UL && (regEC4 & 67043328U) >> 16 != 306U) && (regECC & 67043328U) >> 16 != 54U) {
    result = (u8 )((unsigned int )result | 2U);
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Path B Rx IQK fail!!\n");
  } else {

  }
  return (result);
}
}
static void _PHY_PathAFillIQKMatrix(struct rtw_adapter *pAdapter , bool bIQKOK , int (*result)[8U] ,
                                    u8 final_candidate , bool bTxOnly ) 
{ 
  u32 Oldval_0 ;
  u32 X ;
  u32 TX0_A ;
  u32 reg ;
  s32 Y ;
  s32 TX0_C ;

  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Path A IQ Calibration %s !\n", (int )bIQKOK ? (char *)"Success" : (char *)"Failed");
  } else {

  }
  if ((unsigned int )final_candidate == 255U) {
    return;
  } else
  if ((int )bIQKOK) {
    Oldval_0 = rtl8723au_read32(pAdapter, 3200);
    Oldval_0 = Oldval_0 >> 22;
    X = (u32 )(*(result + (unsigned long )final_candidate))[0];
    if ((X & 512U) != 0U) {
      X = X | 4294966272U;
    } else {

    }
    TX0_A = X * Oldval_0 >> 8;
    PHY_SetBBReg(pAdapter, 3200U, 1023U, TX0_A);
    PHY_SetBBReg(pAdapter, 3148U, 2147483648U, (X * Oldval_0 >> 7) & 1U);
    Y = (*(result + (unsigned long )final_candidate))[1];
    if ((Y & 512) != 0) {
      Y = (s32 )((unsigned int )Y | 4294966272U);
    } else {

    }
    TX0_C = (s32 )((u32 )Y * Oldval_0 >> 8);
    PHY_SetBBReg(pAdapter, 3220U, 4026531840U, (u32 )((TX0_C & 960) >> 6));
    PHY_SetBBReg(pAdapter, 3200U, 4128768U, (u32 )TX0_C & 63U);
    PHY_SetBBReg(pAdapter, 3148U, 536870912U, ((u32 )Y * Oldval_0 >> 7) & 1U);
    if ((int )bTxOnly) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: _PHY_PathAFillIQKMatrix only Tx OK\n");
      } else {

      }
      return;
    } else {

    }
    reg = (u32 )(*(result + (unsigned long )final_candidate))[2];
    PHY_SetBBReg(pAdapter, 3092U, 1023U, reg);
    reg = (u32 )(*(result + (unsigned long )final_candidate))[3] & 63U;
    PHY_SetBBReg(pAdapter, 3092U, 64512U, reg);
    reg = (u32 )((*(result + (unsigned long )final_candidate))[3] >> 6) & 15U;
    PHY_SetBBReg(pAdapter, 3232U, 4026531840U, reg);
  } else {

  }
  return;
}
}
static void _PHY_PathBFillIQKMatrix(struct rtw_adapter *pAdapter , bool bIQKOK , int (*result)[8U] ,
                                    u8 final_candidate , bool bTxOnly ) 
{ 
  u32 Oldval_1 ;
  u32 X ;
  u32 TX1_A ;
  u32 reg ;
  s32 Y ;
  s32 TX1_C ;

  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Path B IQ Calibration %s !\n", (int )bIQKOK ? (char *)"Success" : (char *)"Failed");
  } else {

  }
  if ((unsigned int )final_candidate == 255U) {
    return;
  } else
  if ((int )bIQKOK) {
    Oldval_1 = rtl8723au_read32(pAdapter, 3208);
    Oldval_1 = Oldval_1 >> 22;
    X = (u32 )(*(result + (unsigned long )final_candidate))[4];
    if ((X & 512U) != 0U) {
      X = X | 4294966272U;
    } else {

    }
    TX1_A = X * Oldval_1 >> 8;
    PHY_SetBBReg(pAdapter, 3208U, 1023U, TX1_A);
    PHY_SetBBReg(pAdapter, 3148U, 134217728U, (X * Oldval_1 >> 7) & 1U);
    Y = (*(result + (unsigned long )final_candidate))[5];
    if ((Y & 512) != 0) {
      Y = (s32 )((unsigned int )Y | 4294966272U);
    } else {

    }
    TX1_C = (s32 )((u32 )Y * Oldval_1 >> 8);
    PHY_SetBBReg(pAdapter, 3228U, 4026531840U, (u32 )((TX1_C & 960) >> 6));
    PHY_SetBBReg(pAdapter, 3208U, 4128768U, (u32 )TX1_C & 63U);
    PHY_SetBBReg(pAdapter, 3148U, 33554432U, ((u32 )Y * Oldval_1 >> 7) & 1U);
    if ((int )bTxOnly) {
      return;
    } else {

    }
    reg = (u32 )(*(result + (unsigned long )final_candidate))[6];
    PHY_SetBBReg(pAdapter, 3100U, 1023U, reg);
    reg = (u32 )(*(result + (unsigned long )final_candidate))[7] & 63U;
    PHY_SetBBReg(pAdapter, 3100U, 64512U, reg);
    reg = (u32 )((*(result + (unsigned long )final_candidate))[7] >> 6) & 15U;
    PHY_SetBBReg(pAdapter, 3192U, 61440U, reg);
  } else {

  }
  return;
}
}
static void _PHY_SaveADDARegisters(struct rtw_adapter *pAdapter , u32 *ADDAReg , u32 *ADDABackup ,
                                   u32 RegisterNum ) 
{ 
  u32 i ;

  {
  i = 0U;
  goto ldv_55869;
  ldv_55868: 
  *(ADDABackup + (unsigned long )i) = rtl8723au_read32(pAdapter, (int )((u16 )*(ADDAReg + (unsigned long )i)));
  i = i + 1U;
  ldv_55869: ;
  if (i < RegisterNum) {
    goto ldv_55868;
  } else {

  }

  return;
}
}
static void _PHY_SaveMACRegisters(struct rtw_adapter *pAdapter , u32 *MACReg , u32 *MACBackup ) 
{ 
  u32 i ;
  u8 tmp ;

  {
  i = 0U;
  goto ldv_55878;
  ldv_55877: 
  tmp = rtl8723au_read8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)));
  *(MACBackup + (unsigned long )i) = (u32 )tmp;
  i = i + 1U;
  ldv_55878: ;
  if (i <= 2U) {
    goto ldv_55877;
  } else {

  }
  *(MACBackup + (unsigned long )i) = rtl8723au_read32(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)));
  return;
}
}
static void _PHY_ReloadADDARegisters(struct rtw_adapter *pAdapter , u32 *ADDAReg ,
                                     u32 *ADDABackup , u32 RegiesterNum ) 
{ 
  u32 i ;

  {
  i = 0U;
  goto ldv_55888;
  ldv_55887: 
  rtl8723au_write32(pAdapter, (int )((u16 )*(ADDAReg + (unsigned long )i)), *(ADDABackup + (unsigned long )i));
  i = i + 1U;
  ldv_55888: ;
  if (i < RegiesterNum) {
    goto ldv_55887;
  } else {

  }

  return;
}
}
static void _PHY_ReloadMACRegisters(struct rtw_adapter *pAdapter , u32 *MACReg , u32 *MACBackup ) 
{ 
  u32 i ;

  {
  i = 0U;
  goto ldv_55897;
  ldv_55896: 
  rtl8723au_write8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), (int )((unsigned char )*(MACBackup + (unsigned long )i)));
  i = i + 1U;
  ldv_55897: ;
  if (i <= 2U) {
    goto ldv_55896;
  } else {

  }
  rtl8723au_write32(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), *(MACBackup + (unsigned long )i));
  return;
}
}
static void _PHY_PathADDAOn(struct rtw_adapter *pAdapter , u32 *ADDAReg , bool isPathAOn ,
                            bool is2T ) 
{ 
  u32 pathOn ;
  u32 i ;

  {
  pathOn = (int )isPathAOn ? 81470884U : 186328484U;
  if (! is2T) {
    pathOn = 198911392U;
    rtl8723au_write32(pAdapter, (int )((u16 )*ADDAReg), 186328480U);
  } else {
    rtl8723au_write32(pAdapter, (int )((u16 )*ADDAReg), pathOn);
  }
  i = 1U;
  goto ldv_55908;
  ldv_55907: 
  rtl8723au_write32(pAdapter, (int )((u16 )*(ADDAReg + (unsigned long )i)), pathOn);
  i = i + 1U;
  ldv_55908: ;
  if (i <= 15U) {
    goto ldv_55907;
  } else {

  }

  return;
}
}
static void _PHY_MACSettingCalibration(struct rtw_adapter *pAdapter , u32 *MACReg ,
                                       u32 *MACBackup ) 
{ 
  u32 i ;

  {
  i = 0U;
  rtl8723au_write8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), 63);
  i = 1U;
  goto ldv_55917;
  ldv_55916: 
  rtl8723au_write8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), (int )((unsigned char )*(MACBackup + (unsigned long )i)) & 247);
  i = i + 1U;
  ldv_55917: ;
  if (i <= 2U) {
    goto ldv_55916;
  } else {

  }
  rtl8723au_write8(pAdapter, (int )((u16 )*(MACReg + (unsigned long )i)), (int )((unsigned char )*(MACBackup + (unsigned long )i)) & 223);
  return;
}
}
static void _PHY_PathAStandBy(struct rtw_adapter *pAdapter ) 
{ 


  {
  rtl8723au_write32(pAdapter, 3624, 0U);
  rtl8723au_write32(pAdapter, 2112, 65536U);
  rtl8723au_write32(pAdapter, 3624, 2155872256U);
  return;
}
}
static void _PHY_PIModeSwitch(struct rtw_adapter *pAdapter , bool PIMode ) 
{ 
  u32 mode ;

  {
  mode = (int )PIMode ? 16777472U : 16777216U;
  rtl8723au_write32(pAdapter, 2080, mode);
  rtl8723au_write32(pAdapter, 2088, mode);
  return;
}
}
static bool _PHY_SimularityCompare(struct rtw_adapter *pAdapter , int (*result)[8U] ,
                                   u8 c1 , u8 c2 ) 
{ 
  u32 i ;
  u32 j ;
  u32 diff ;
  u32 SimularityBitMap ;
  u32 bound ;
  struct hal_data_8723a *pHalData ;
  u8 final_candidate[2U] ;
  bool bResult ;

  {
  bound = 0U;
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  final_candidate[0] = 255U;
  final_candidate[1] = 255U;
  bResult = 1;
  if ((unsigned int )pHalData->rf_type == 2U) {
    bound = 8U;
  } else {
    bound = 4U;
  }
  SimularityBitMap = 0U;
  i = 0U;
  goto ldv_55942;
  ldv_55941: 
  diff = (u32 )((*(result + (unsigned long )c1))[i] > (*(result + (unsigned long )c2))[i] ? (*(result + (unsigned long )c1))[i] - (*(result + (unsigned long )c2))[i] : (*(result + (unsigned long )c2))[i] - (*(result + (unsigned long )c1))[i]);
  if (diff > 5U) {
    if ((i == 2U || i == 6U) && SimularityBitMap == 0U) {
      if ((*(result + (unsigned long )c1))[i] + (*(result + (unsigned long )c1))[i + 1U] == 0) {
        final_candidate[i / 4U] = c2;
      } else
      if ((*(result + (unsigned long )c2))[i] + (*(result + (unsigned long )c2))[i + 1U] == 0) {
        final_candidate[i / 4U] = c1;
      } else {
        SimularityBitMap = (u32 )(1 << (int )i) | SimularityBitMap;
      }
    } else {
      SimularityBitMap = (u32 )(1 << (int )i) | SimularityBitMap;
    }
  } else {

  }
  i = i + 1U;
  ldv_55942: ;
  if (i < bound) {
    goto ldv_55941;
  } else {

  }

  if (SimularityBitMap == 0U) {
    i = 0U;
    goto ldv_55948;
    ldv_55947: ;
    if ((unsigned int )final_candidate[i] != 255U) {
      j = i * 4U;
      goto ldv_55945;
      ldv_55944: 
      (*(result + 3UL))[j] = (*(result + (unsigned long )final_candidate[i]))[j];
      j = j + 1U;
      ldv_55945: ;
      if ((i + 1U) * 4U - 2U > j) {
        goto ldv_55944;
      } else {

      }
      bResult = 0;
    } else {

    }
    i = i + 1U;
    ldv_55948: ;
    if (bound / 4U > i) {
      goto ldv_55947;
    } else {

    }

    return (bResult);
  } else
  if ((SimularityBitMap & 15U) == 0U) {
    i = 0U;
    goto ldv_55951;
    ldv_55950: 
    (*(result + 3UL))[i] = (*(result + (unsigned long )c1))[i];
    i = i + 1U;
    ldv_55951: ;
    if (i <= 3U) {
      goto ldv_55950;
    } else {

    }

    return (0);
  } else
  if ((SimularityBitMap & 240U) == 0U && (unsigned int )pHalData->rf_type == 2U) {
    i = 4U;
    goto ldv_55954;
    ldv_55953: 
    (*(result + 3UL))[i] = (*(result + (unsigned long )c1))[i];
    i = i + 1U;
    ldv_55954: ;
    if (i <= 7U) {
      goto ldv_55953;
    } else {

    }

    return (0);
  } else {
    return (0);
  }
}
}
static void _PHY_IQCalibrate(struct rtw_adapter *pAdapter , int (*result)[8U] , u8 t ,
                             bool is2T ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u32 i ;
  u8 PathAOK ;
  u8 PathBOK ;
  u32 ADDA_REG[16U] ;
  u32 IQK_MAC_REG[4U] ;
  u32 IQK_BB_REG_92C[9U] ;
  u32 retryCount ;
  u32 bbvalue ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;

  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  ADDA_REG[0] = 2140U;
  ADDA_REG[1] = 3692U;
  ADDA_REG[2] = 3696U;
  ADDA_REG[3] = 3700U;
  ADDA_REG[4] = 3704U;
  ADDA_REG[5] = 3708U;
  ADDA_REG[6] = 3712U;
  ADDA_REG[7] = 3716U;
  ADDA_REG[8] = 3720U;
  ADDA_REG[9] = 3724U;
  ADDA_REG[10] = 3792U;
  ADDA_REG[11] = 3796U;
  ADDA_REG[12] = 3800U;
  ADDA_REG[13] = 3804U;
  ADDA_REG[14] = 3808U;
  ADDA_REG[15] = 3820U;
  IQK_MAC_REG[0] = 1314U;
  IQK_MAC_REG[1] = 1360U;
  IQK_MAC_REG[2] = 1361U;
  IQK_MAC_REG[3] = 64U;
  IQK_BB_REG_92C[0] = 3076U;
  IQK_BB_REG_92C[1] = 3080U;
  IQK_BB_REG_92C[2] = 2164U;
  IQK_BB_REG_92C[3] = 2920U;
  IQK_BB_REG_92C[4] = 2924U;
  IQK_BB_REG_92C[5] = 2160U;
  IQK_BB_REG_92C[6] = 2144U;
  IQK_BB_REG_92C[7] = 2148U;
  IQK_BB_REG_92C[8] = 2048U;
  retryCount = 2U;
  if ((unsigned int )t == 0U) {
    bbvalue = rtl8723au_read32(pAdapter, 2048);
    _PHY_SaveADDARegisters(pAdapter, (u32 *)(& ADDA_REG), (u32 *)(& pdmpriv->ADDA_backup),
                           16U);
    _PHY_SaveMACRegisters(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
    _PHY_SaveADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup),
                           9U);
  } else {

  }
  _PHY_PathADDAOn(pAdapter, (u32 *)(& ADDA_REG), 1, (int )is2T);
  if ((unsigned int )t == 0U) {
    tmp = PHY_QueryBBReg(pAdapter, 2080U, 256U);
    pdmpriv->bRfPiEnable = (unsigned char )tmp;
  } else {

  }
  if ((unsigned int )pdmpriv->bRfPiEnable == 0U) {
    _PHY_PIModeSwitch(pAdapter, 1);
  } else {

  }
  PHY_SetBBReg(pAdapter, 2048U, 16777216U, 0U);
  rtl8723au_write32(pAdapter, 3076, 60839424U);
  rtl8723au_write32(pAdapter, 3080, 524516U);
  rtl8723au_write32(pAdapter, 2164, 572538880U);
  PHY_SetBBReg(pAdapter, 2160U, 1024U, 1U);
  PHY_SetBBReg(pAdapter, 2160U, 67108864U, 1U);
  PHY_SetBBReg(pAdapter, 2144U, 1024U, 0U);
  PHY_SetBBReg(pAdapter, 2148U, 1024U, 0U);
  if ((int )is2T) {
    rtl8723au_write32(pAdapter, 2112, 65536U);
    rtl8723au_write32(pAdapter, 2116, 65536U);
  } else {

  }
  _PHY_MACSettingCalibration(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
  rtl8723au_write32(pAdapter, 2920, 524288U);
  if ((int )is2T) {
    rtl8723au_write32(pAdapter, 2924, 524288U);
  } else {

  }
  rtl8723au_write32(pAdapter, 3624, 2155872256U);
  rtl8723au_write32(pAdapter, 3648, 16808960U);
  rtl8723au_write32(pAdapter, 3652, 16795648U);
  i = 0U;
  goto ldv_55974;
  ldv_55973: 
  PathAOK = _PHY_PathA_IQK(pAdapter, (int )is2T);
  if ((unsigned int )PathAOK == 3U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Path A IQK Success!!\n");
    } else {

    }
    tmp___0 = rtl8723au_read32(pAdapter, 3732);
    (*(result + (unsigned long )t))[0] = (int )((tmp___0 & 67043328U) >> 16);
    tmp___1 = rtl8723au_read32(pAdapter, 3740);
    (*(result + (unsigned long )t))[1] = (int )((tmp___1 & 67043328U) >> 16);
    tmp___2 = rtl8723au_read32(pAdapter, 3748);
    (*(result + (unsigned long )t))[2] = (int )((tmp___2 & 67043328U) >> 16);
    tmp___3 = rtl8723au_read32(pAdapter, 3756);
    (*(result + (unsigned long )t))[3] = (int )((tmp___3 & 67043328U) >> 16);
    goto ldv_55972;
  } else
  if (retryCount - 1U == i && (unsigned int )PathAOK == 1U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Path A IQK Only  Tx Success!!\n");
    } else {

    }
    tmp___4 = rtl8723au_read32(pAdapter, 3732);
    (*(result + (unsigned long )t))[0] = (int )((tmp___4 & 67043328U) >> 16);
    tmp___5 = rtl8723au_read32(pAdapter, 3740);
    (*(result + (unsigned long )t))[1] = (int )((tmp___5 & 67043328U) >> 16);
  } else {

  }
  i = i + 1U;
  ldv_55974: ;
  if (i < retryCount) {
    goto ldv_55973;
  } else {

  }
  ldv_55972: ;
  if ((unsigned int )PathAOK == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Path A IQK failed!!\n");
    } else {

    }
  } else {

  }
  if ((int )is2T) {
    _PHY_PathAStandBy(pAdapter);
    _PHY_PathADDAOn(pAdapter, (u32 *)(& ADDA_REG), 0, (int )is2T);
    i = 0U;
    goto ldv_55977;
    ldv_55976: 
    PathBOK = _PHY_PathB_IQK(pAdapter);
    if ((unsigned int )PathBOK == 3U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Path B IQK Success!!\n");
      } else {

      }
      tmp___6 = rtl8723au_read32(pAdapter, 3764);
      (*(result + (unsigned long )t))[4] = (int )((tmp___6 & 67043328U) >> 16);
      tmp___7 = rtl8723au_read32(pAdapter, 3772);
      (*(result + (unsigned long )t))[5] = (int )((tmp___7 & 67043328U) >> 16);
      tmp___8 = rtl8723au_read32(pAdapter, 3780);
      (*(result + (unsigned long )t))[6] = (int )((tmp___8 & 67043328U) >> 16);
      tmp___9 = rtl8723au_read32(pAdapter, 3788);
      (*(result + (unsigned long )t))[7] = (int )((tmp___9 & 67043328U) >> 16);
      goto ldv_55975;
    } else
    if (retryCount - 1U == i && (unsigned int )PathBOK == 1U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Path B Only Tx IQK Success!!\n");
      } else {

      }
      tmp___10 = rtl8723au_read32(pAdapter, 3764);
      (*(result + (unsigned long )t))[4] = (int )((tmp___10 & 67043328U) >> 16);
      tmp___11 = rtl8723au_read32(pAdapter, 3772);
      (*(result + (unsigned long )t))[5] = (int )((tmp___11 & 67043328U) >> 16);
    } else {

    }
    i = i + 1U;
    ldv_55977: ;
    if (i < retryCount) {
      goto ldv_55976;
    } else {

    }
    ldv_55975: ;
    if ((unsigned int )PathBOK == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Path B IQK failed!!\n");
      } else {

      }
    } else {

    }
  } else {

  }
  rtl8723au_write32(pAdapter, 3624, 0U);
  if ((unsigned int )t != 0U) {
    if ((unsigned int )pdmpriv->bRfPiEnable == 0U) {
      _PHY_PIModeSwitch(pAdapter, 0);
    } else {

    }
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& ADDA_REG), (u32 *)(& pdmpriv->ADDA_backup),
                             16U);
    _PHY_ReloadMACRegisters(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup),
                             9U);
    rtl8723au_write32(pAdapter, 2112, 208595U);
    if ((int )is2T) {
      rtl8723au_write32(pAdapter, 2116, 208595U);
    } else {

    }
    rtl8723au_write32(pAdapter, 3632, 16813056U);
    rtl8723au_write32(pAdapter, 3636, 16813056U);
  } else {

  }
  return;
}
}
static void _PHY_LCCalibrate(struct rtw_adapter *pAdapter , bool is2T ) 
{ 
  u8 tmpReg ;
  u32 RF_Amode ;
  u32 RF_Bmode ;
  u32 LC_Cal ;

  {
  RF_Amode = 0U;
  RF_Bmode = 0U;
  tmpReg = rtl8723au_read8(pAdapter, 3331);
  if (((int )tmpReg & 112) != 0) {
    rtl8723au_write8(pAdapter, 3331, (int )tmpReg & 143);
  } else {
    rtl8723au_write8(pAdapter, 1314, 255);
  }
  if (((int )tmpReg & 112) != 0) {
    RF_Amode = PHY_QueryRFReg(pAdapter, 0, 0U, 4095U);
    if ((int )is2T) {
      RF_Bmode = PHY_QueryRFReg(pAdapter, 1, 0U, 4095U);
    } else {

    }
    PHY_SetRFReg(pAdapter, 0, 0U, 4095U, (RF_Amode & 589823U) | 65536U);
    if ((int )is2T) {
      PHY_SetRFReg(pAdapter, 1, 0U, 4095U, (RF_Bmode & 589823U) | 65536U);
    } else {

    }
  } else {

  }
  LC_Cal = PHY_QueryRFReg(pAdapter, 0, 24U, 4095U);
  PHY_SetRFReg(pAdapter, 0, 24U, 4095U, LC_Cal | 32768U);
  msleep(100U);
  if (((int )tmpReg & 112) != 0) {
    rtl8723au_write8(pAdapter, 3331, (int )tmpReg);
    PHY_SetRFReg(pAdapter, 0, 0U, 4095U, RF_Amode);
    if ((int )is2T) {
      PHY_SetRFReg(pAdapter, 1, 0U, 4095U, RF_Bmode);
    } else {

    }
  } else {
    rtl8723au_write8(pAdapter, 1314, 0);
  }
  return;
}
}
void rtl8723a_phy_iq_calibrate(struct rtw_adapter *pAdapter , bool bReCovery ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  s32 result[4U][8U] ;
  u8 i ;
  u8 final_candidate ;
  bool bPathAOK ;
  bool bPathBOK ;
  s32 RegE94 ;
  s32 RegE9C ;
  s32 RegEA4 ;
  s32 RegEAC ;
  s32 RegEB4 ;
  s32 RegEBC ;
  s32 RegEC4 ;
  s32 RegECC ;
  s32 RegTmp ;
  bool is12simular ;
  bool is13simular ;
  bool is23simular ;
  bool bStartContTx ;
  bool bSingleTone ;
  bool bCarrierSuppression ;
  u32 IQK_BB_REG_92C[9U] ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;

  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  RegTmp = 0;
  bStartContTx = 0;
  bSingleTone = 0;
  bCarrierSuppression = 0;
  IQK_BB_REG_92C[0] = 3092U;
  IQK_BB_REG_92C[1] = 3100U;
  IQK_BB_REG_92C[2] = 3148U;
  IQK_BB_REG_92C[3] = 3192U;
  IQK_BB_REG_92C[4] = 3200U;
  IQK_BB_REG_92C[5] = 3208U;
  IQK_BB_REG_92C[6] = 3220U;
  IQK_BB_REG_92C[7] = 3228U;
  IQK_BB_REG_92C[8] = 3232U;
  if (((int )bStartContTx || (int )bSingleTone) || (int )bCarrierSuppression) {
    return;
  } else {

  }
  if ((int )bReCovery) {
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup_recover),
                             9U);
    return;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: IQK:Start!!!\n");
  } else {

  }
  i = 0U;
  goto ldv_56014;
  ldv_56013: 
  result[0][(int )i] = 0;
  result[1][(int )i] = 0;
  result[2][(int )i] = 0;
  result[3][(int )i] = 0;
  i = (u8 )((int )i + 1);
  ldv_56014: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_56013;
  } else {

  }
  final_candidate = 255U;
  bPathAOK = 0;
  bPathBOK = 0;
  is12simular = 0;
  is23simular = 0;
  is13simular = 0;
  i = 0U;
  goto ldv_56021;
  ldv_56020: ;
  if ((unsigned int )pHalData->rf_type == 2U) {
    _PHY_IQCalibrate(pAdapter, (int (*)[8])(& result), (int )i, 1);
  } else {
    _PHY_IQCalibrate(pAdapter, (int (*)[8])(& result), (int )i, 0);
  }
  if ((unsigned int )i == 1U) {
    is12simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 0, 1);
    if ((int )is12simular) {
      final_candidate = 0U;
      goto ldv_56016;
    } else {

    }
  } else {

  }
  if ((unsigned int )i == 2U) {
    is13simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 0, 2);
    if ((int )is13simular) {
      final_candidate = 0U;
      goto ldv_56016;
    } else {

    }
    is23simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 1, 2);
    if ((int )is23simular) {
      final_candidate = 1U;
    } else {
      i = 0U;
      goto ldv_56018;
      ldv_56017: 
      RegTmp = result[3][(int )i] + RegTmp;
      i = (u8 )((int )i + 1);
      ldv_56018: ;
      if ((unsigned int )i <= 7U) {
        goto ldv_56017;
      } else {

      }

      if (RegTmp != 0) {
        final_candidate = 3U;
      } else {
        final_candidate = 255U;
      }
    }
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56021: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_56020;
  } else {

  }
  ldv_56016: 
  i = 0U;
  goto ldv_56023;
  ldv_56022: 
  RegE94 = result[(int )i][0];
  RegE9C = result[(int )i][1];
  RegEA4 = result[(int )i][2];
  RegEAC = result[(int )i][3];
  RegEB4 = result[(int )i][4];
  RegEBC = result[(int )i][5];
  RegEC4 = result[(int )i][6];
  RegECC = result[(int )i][7];
  i = (u8 )((int )i + 1);
  ldv_56023: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_56022;
  } else {

  }

  if ((unsigned int )final_candidate != 255U) {
    RegE94 = result[(int )final_candidate][0];
    pdmpriv->RegE94 = RegE94;
    RegE9C = result[(int )final_candidate][1];
    pdmpriv->RegE9C = RegE9C;
    RegEA4 = result[(int )final_candidate][2];
    RegEAC = result[(int )final_candidate][3];
    RegEB4 = result[(int )final_candidate][4];
    pdmpriv->RegEB4 = RegEB4;
    RegEBC = result[(int )final_candidate][5];
    pdmpriv->RegEBC = RegEBC;
    RegEC4 = result[(int )final_candidate][6];
    RegECC = result[(int )final_candidate][7];
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: IQK: final_candidate is %x\n", (int )final_candidate);
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: IQK: RegE94 =%x RegE9C =%x RegEA4 =%x RegEAC =%x RegEB4 =%x RegEBC =%x RegEC4 =%x RegECC =%x\n ",
             RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC);
    } else {

    }
    bPathBOK = 1;
    bPathAOK = bPathBOK;
  } else {
    tmp___0 = 256;
    pdmpriv->RegEB4 = tmp___0;
    tmp = tmp___0;
    pdmpriv->RegE94 = tmp;
    RegEB4 = tmp;
    RegE94 = RegEB4;
    tmp___2 = 0;
    pdmpriv->RegEBC = tmp___2;
    tmp___1 = tmp___2;
    pdmpriv->RegE9C = tmp___1;
    RegEBC = tmp___1;
    RegE9C = RegEBC;
  }
  if (RegE94 != 0) {
    _PHY_PathAFillIQKMatrix(pAdapter, (int )bPathAOK, (int (*)[8])(& result), (int )final_candidate,
                            RegEA4 == 0);
  } else {

  }
  if ((unsigned int )pHalData->rf_type == 2U) {
    if (RegEB4 != 0) {
      _PHY_PathBFillIQKMatrix(pAdapter, (int )bPathBOK, (int (*)[8])(& result), (int )final_candidate,
                              RegEC4 == 0);
    } else {

    }
  } else {

  }
  _PHY_SaveADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup_recover),
                         9U);
  return;
}
}
void rtl8723a_phy_lc_calibrate(struct rtw_adapter *pAdapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct mlme_ext_priv *pmlmeext ;
  bool bStartContTx ;
  bool bSingleTone ;
  bool bCarrierSuppression ;

  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pmlmeext = & pAdapter->mlmeextpriv;
  bStartContTx = 0;
  bSingleTone = 0;
  bCarrierSuppression = 0;
  if (((int )bStartContTx || (int )bSingleTone) || (int )bCarrierSuppression) {
    return;
  } else {

  }
  if (pmlmeext->sitesurvey_res.state == 3) {
    return;
  } else {

  }
  if ((unsigned int )pHalData->rf_type == 2U) {
    _PHY_LCCalibrate(pAdapter, 1);
  } else {
    _PHY_LCCalibrate(pAdapter, 0);
  }
  return;
}
}
void rtl8723a_phy_ap_calibrate(struct rtw_adapter *pAdapter , char delta ) 
{ 


  {
  return;
}
}
bool ldv_queue_work_on_327(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_328(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_329(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_330(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_331(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_341(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_343(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_342(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_345(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_344(struct workqueue_struct *ldv_func_arg1 ) ;
void ODM_ReadAndConfig_AGC_TAB_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
void ODM_ReadAndConfig_PHY_REG_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
void ODM_ReadAndConfig_PHY_REG_MP_8723A(struct dm_odm_t *pDM_Odm ) ;
void odm_ConfigBB_AGC_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u32 data ) ;
void odm_ConfigBB_PHY_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u32 data ) ;
static bool CheckCondition(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
  _board = (unsigned int )Hex & 255U;
  _interface = ((unsigned int )Hex & 65280U) >> 8;
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
  cond = Condition;
  if ((unsigned int )Condition == 3452816845U) {
    return (1);
  } else {

  }
  cond = (unsigned int )Condition & 255U;
  if (_board == cond && cond != 0U) {
    return (0);
  } else {

  }
  cond = (unsigned int )Condition & 65280U;
  cond = cond >> 8;
  if ((_interface & cond) == 0U && cond != 7U) {
    return (0);
  } else {

  }
  cond = (unsigned int )Condition & 16711680U;
  cond = cond >> 16;
  if ((_platform & cond) == 0U && cond != 15U) {
    return (0);
  } else {

  }
  return (1);
}
}
static u32 Array_AGC_TAB_1T_8723A[320U]  = 
  {      3192U,      2063597569U,      3192U,      2063663105U, 
        3192U,      2063728641U,      3192U,      2063794177U, 
        3192U,      2063859713U,      3192U,      2063925249U, 
        3192U,      2047213569U,      3192U,      2030501889U, 
        3192U,      2013790209U,      3192U,      1997078529U, 
        3192U,      1980366849U,      3192U,      1963655169U, 
        3192U,      1946943489U,      3192U,      1930231809U, 
        3192U,      1913520129U,      3192U,      1896808449U, 
        3192U,      1880096769U,      3192U,      1863385089U, 
        3192U,      1846673409U,      3192U,      1829961729U, 
        3192U,      1813250049U,      3192U,      1796538369U, 
        3192U,      1779826689U,      3192U,      1763115009U, 
        3192U,      1746403329U,      3192U,      1729691649U, 
        3192U,      1712979969U,      3192U,      1696268289U, 
        3192U,      1679556609U,      3192U,      1662844929U, 
        3192U,      1646133249U,      3192U,      1629421569U, 
        3192U,      1612709889U,      3192U,      1226899457U, 
        3192U,      1210187777U,      3192U,      1193476097U, 
        3192U,      1176764417U,      3192U,      1160052737U, 
        3192U,      1143341057U,      3192U,      1126629377U, 
        3192U,      1109917697U,      3192U,      1093206017U, 
        3192U,      1076494337U,      3192U,      640352257U, 
        3192U,      623640577U,      3192U,      606928897U, 
        3192U,      590217217U,      3192U,      573505537U, 
        3192U,      556793857U,      3192U,      540082177U, 
        3192U,      103940097U,      3192U,      87228417U, 
        3192U,      70516737U,      3192U,      53805057U, 
        3192U,      37093377U,      3192U,      20381697U, 
        3192U,      3670017U,      3192U,      3735553U, 
        3192U,      3801089U,      3192U,      3866625U, 
        3192U,      3932161U,      3192U,      3997697U, 
        3192U,      4063233U,      3192U,      4128769U, 
        3192U,      2067791873U,      3192U,      2067857409U, 
        3192U,      2067922945U,      3192U,      2067988481U, 
        3192U,      2068054017U,      3192U,      2068119553U, 
        3192U,      2051407873U,      3192U,      2034696193U, 
        3192U,      2017984513U,      3192U,      2001272833U, 
        3192U,      1984561153U,      3192U,      1967849473U, 
        3192U,      1951137793U,      3192U,      1934426113U, 
        3192U,      1917714433U,      3192U,      1901002753U, 
        3192U,      1884291073U,      3192U,      1867579393U, 
        3192U,      1850867713U,      3192U,      1834156033U, 
        3192U,      1817444353U,      3192U,      1800732673U, 
        3192U,      1784020993U,      3192U,      1767309313U, 
        3192U,      1750597633U,      3192U,      1733885953U, 
        3192U,      1717174273U,      3192U,      1700462593U, 
        3192U,      1683750913U,      3192U,      1667039233U, 
        3192U,      1650327553U,      3192U,      1633615873U, 
        3192U,      1616904193U,      3192U,      1231093761U, 
        3192U,      1214382081U,      3192U,      1197670401U, 
        3192U,      1180958721U,      3192U,      1164247041U, 
        3192U,      1147535361U,      3192U,      1130823681U, 
        3192U,      1114112001U,      3192U,      1097400321U, 
        3192U,      1080688641U,      3192U,      644546561U, 
        3192U,      627834881U,      3192U,      611123201U, 
        3192U,      594411521U,      3192U,      577699841U, 
        3192U,      560988161U,      3192U,      544276481U, 
        3192U,      108134401U,      3192U,      91422721U, 
        3192U,      74711041U,      3192U,      57999361U, 
        3192U,      41287681U,      3192U,      24576001U, 
        3192U,      7864321U,      3192U,      7929857U, 
        3192U,      7995393U,      3192U,      8060929U, 
        3192U,      8126465U,      3192U,      8192001U, 
        3192U,      8257537U,      3192U,      8323073U, 
        3192U,      939524126U,      3192U,      939589662U, 
        3192U,      939655198U,      3192U,      939720734U, 
        3192U,      939786270U,      3192U,      939851806U, 
        3192U,      939917342U,      3192U,      939982878U, 
        3192U,      940048414U,      3192U,      1007222814U, 
        3192U,      1040842782U,      3192U,      1074462750U, 
        3192U,      1141637150U,      3192U,      1208811550U, 
        3192U,      1275985950U,      3192U,      1343160350U, 
        3192U,      1376780318U,      3192U,      1443954718U, 
        3192U,      1511129118U,      3192U,      1578303518U, 
        3192U,      1611923486U,      3192U,      1611989022U, 
        3192U,      1612054558U,      3192U,      1645674526U, 
        3192U,      1645740062U,      3192U,      1645805598U, 
        3192U,      1645871134U,      3192U,      1645936670U, 
        3192U,      1646002206U,      3192U,      1646067742U, 
        3192U,      1646133278U,      3192U,      1646198814U};
void ODM_ReadAndConfig_AGC_TAB_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
  platform = 4U;
  board = pDM_Odm->BoardType;
  ArrayLen = 320U;
  Array = (u32 *)(& Array_AGC_TAB_1T_8723A);
  hex = (u32 )board;
  hex = hex + 512U;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_55734;
  ldv_55733: 
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigBB_AGC_8723A(pDM_Odm, v1, v2);
    goto ldv_55723;
  } else {
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55725;
      ldv_55724: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55725: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55724;
      } else {

      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55728;
      ldv_55727: 
      odm_ConfigBB_AGC_8723A(pDM_Odm, v1, v2);
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55728: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55727;
      } else {

      }

      goto ldv_55731;
      ldv_55730: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55731: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_55730;
      } else {

      }

    }
  }
  ldv_55723: 
  i = i + 2U;
  ldv_55734: ;
  if (i < ArrayLen) {
    goto ldv_55733;
  } else {

  }

  return;
}
}
static u32 Array_PHY_REG_1T_8723A[388U]  = 
  {      2048U,      2147745792U,      2052U,      3U, 
        2056U,      64512U,      2060U,      10U, 
        2064U,      268440369U,      2068U,      34356496U, 
        2072U,      35652485U,      2076U,      0U, 
        2080U,      16777472U,      2084U,      3735556U, 
        2088U,      0U,      2092U,      0U, 
        2096U,      0U,      2100U,      0U, 
        2104U,      0U,      2108U,      0U, 
        2112U,      65536U,      2116U,      0U, 
        2120U,      0U,      2124U,      0U, 
        2128U,      0U,      2132U,      0U, 
        2136U,      1452955290U,      2140U,      1779108U, 
        2144U,      1727398160U,      2148U,      102695216U, 
        2152U,      0U,      2156U,      842150400U, 
        2160U,      117442400U,      2164U,      570441728U, 
        2168U,      2056U,      2172U,      0U, 
        2176U,      3221762160U,      2180U,      1237U, 
        2184U,      0U,      2188U,      3435135168U, 
        2192U,      2048U,      2196U,      4294967294U, 
        2200U,      1076895760U,      2204U,      7364688U, 
        2304U,      0U,      2308U,      35U, 
        2312U,      0U,      2316U,      2165444881U, 
        2560U,      13649864U,      2564U,      2164195340U, 
        2568U,      2357428992U,      2572U,      778572303U, 
        2576U,      2499853176U,      2580U,      286539816U, 
        2584U,      8917271U,      2588U,      2299793152U, 
        2592U,      437977088U,      2596U,      151917335U, 
        2600U,      516U,      2604U,      13828096U, 
        2672U,      270515968U,      2676U,      7U, 
        2680U,      2304U,      3072U,      1208425792U, 
        3076U,      60839441U,      3080U,      228U, 
        3084U,      1819044972U,      3088U,      142606336U, 
        3092U,      1073742080U,      3096U,      142606336U, 
        3100U,      1073742080U,      3104U,      0U, 
        3108U,      0U,      3112U,      0U, 
        3116U,      0U,      3120U,      1776921668U, 
        4279173407U,      43981U,      3124U,      1184256719U, 
        3452816845U,      52685U,      3124U,      1184256687U, 
        4279173407U,      57005U,      3128U,      1232689556U, 
        3132U,      177706780U,      3136U,      528236607U, 
        3140U,      65719U,      3144U,      3959554311U, 
        3148U,      8323967U,      3152U,      1767126048U, 
        3156U,      1136394388U,      3160U,      1767126048U, 
        3164U,      1128005780U,      3168U,      0U, 
        4279173407U,      43981U,      3172U,      1897301131U, 
        3452816845U,      52685U,      3172U,      1897038987U, 
        4279173407U,      57005U,      3176U,      1203768319U, 
        3180U,      54U,      3184U,      746520589U, 
        3188U,      25563355U,      3192U,      31U, 
        3196U,      12129810U,      3200U,      1073742080U, 
        3204U,      552992768U,      3208U,      1073742080U, 
        3212U,      538968064U,      3216U,      1185824U, 
        3220U,      0U,      3224U,      1185824U, 
        3228U,      32639U,      3232U,      0U, 
        3236U,      128U,      3240U,      0U, 
        3244U,      0U,      3248U,      0U, 
        3252U,      0U,      3256U,      0U, 
        3260U,      671088640U,      3264U,      0U, 
        3268U,      0U,      3272U,      0U, 
        3276U,      0U,      3280U,      0U, 
        3284U,      0U,      3288U,      1689396263U, 
        3292U,      7760178U,      3296U,      2236962U, 
        3300U,      0U,      3304U,      929317634U, 
        3308U,      798479372U,      3328U,      526144U, 
        3332U,      132097U,      3336U,      36991U, 
        3340U,      536936961U,      3344U,      2690855731U, 
        3348U,      859028547U,      3352U,      2056215403U, 
        3372U,      3432487285U,      3376U,      0U, 
        3380U,      2153807872U,      3384U,      0U, 
        3388U,      160403U,      3392U,      0U, 
        3396U,      0U,      3400U,      0U, 
        3404U,      0U,      3408U,      1681331210U, 
        3412U,      0U,      3416U,      0U, 
        3420U,      805511268U,      3424U,      1179901544U, 
        3428U,      72452668U,      3432U,      8449U, 
        3436U,      706747414U,      3440U,      403846702U, 
        3444U,      841753120U,      3448U,      932900U, 
        3584U,      707406378U,      3588U,      707406378U, 
        3592U,      59779626U,      3600U,      707406378U, 
        3604U,      707406378U,      3608U,      707406378U, 
        3612U,      707406378U,      3624U,      0U, 
        3632U,      268491807U,      3636U,      268471327U, 
        3640U,      34865410U,      3644U,      1746273474U, 
        3648U,      16808960U,      3652U,      16795648U, 
        3656U,      4211081216U,      3660U,      10449U, 
        3664U,      268491807U,      3668U,      268471327U, 
        3672U,      34865410U,      3676U,      672533765U, 
        3680U,      8U,      3688U,      1779108U, 
        3692U,      1662723488U,      3696U,      1662723488U, 
        3700U,      135996832U,      3704U,      135996832U, 
        3708U,      135996832U,      3712U,      135996832U, 
        3716U,      1662723488U,      3720U,      135996832U, 
        3724U,      1662723488U,      3792U,      1662723488U, 
        3796U,      1662723488U,      3800U,      1662723488U, 
        3804U,      1779104U,      3808U,      1779104U, 
        3820U,      1796941216U,      3860U,      3U, 
        3916U,      0U,      3840U,      768U};
void ODM_ReadAndConfig_PHY_REG_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
  hex = 0U;
  i = 0U;
  platform = 4U;
  board = pDM_Odm->BoardType;
  ArrayLen = 388U;
  Array = (u32 *)(& Array_PHY_REG_1T_8723A);
  hex = (u32 )board + hex;
  hex = hex + 512U;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_55759;
  ldv_55758: 
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigBB_PHY_8723A(pDM_Odm, v1, v2);
    goto ldv_55748;
  } else {
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55750;
      ldv_55749: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55750: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55749;
      } else {

      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55753;
      ldv_55752: 
      odm_ConfigBB_PHY_8723A(pDM_Odm, v1, v2);
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55753: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55752;
      } else {

      }

      goto ldv_55756;
      ldv_55755: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55756: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_55755;
      } else {

      }

    }
  }
  ldv_55748: 
  i = i + 2U;
  ldv_55759: ;
  if (i < ArrayLen) {
    goto ldv_55758;
  } else {

  }

  return;
}
}
static u32 Array_PHY_REG_MP_8723A[4U]  = {      3120U,      1776921674U,      3132U,      177706776U};
void ODM_ReadAndConfig_PHY_REG_MP_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
  hex = 0U;
  platform = 4U;
  board = pDM_Odm->BoardType;
  ArrayLen = 4U;
  Array = (u32 *)(& Array_PHY_REG_MP_8723A);
  hex = (u32 )board + hex;
  hex = hex + 512U;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_55784;
  ldv_55783: 
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigBB_PHY_8723A(pDM_Odm, v1, v2);
    goto ldv_55773;
  } else {
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55775;
      ldv_55774: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55775: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55774;
      } else {

      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55778;
      ldv_55777: 
      odm_ConfigBB_PHY_8723A(pDM_Odm, v1, v2);
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55778: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55777;
      } else {

      }

      goto ldv_55781;
      ldv_55780: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55781: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_55780;
      } else {

      }

    }
  }
  ldv_55773: 
  i = i + 2U;
  ldv_55784: ;
  if (i < ArrayLen) {
    goto ldv_55783;
  } else {

  }

  return;
}
}
bool ldv_queue_work_on_341(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_342(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_343(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_344(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_345(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_355(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_357(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_356(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_358(struct workqueue_struct *ldv_func_arg1 ) ;
void ODM_ReadAndConfig_MAC_REG_8723A(struct dm_odm_t *pDM_Odm ) ;
void odm_ConfigMAC_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u8 data ) ;
static bool CheckCondition___0(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
  _board = (unsigned int )Hex & 255U;
  _interface = ((unsigned int )Hex & 65280U) >> 8;
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
  cond = Condition;
  if ((unsigned int )Condition == 3452816845U) {
    return (1);
  } else {

  }
  cond = (unsigned int )Condition & 255U;
  if (_board == cond && cond != 0U) {
    return (0);
  } else {

  }
  cond = (unsigned int )Condition & 65280U;
  cond = cond >> 8;
  if ((_interface & cond) == 0U && cond != 7U) {
    return (0);
  } else {

  }
  cond = (unsigned int )Condition & 16711680U;
  cond = cond >> 16;
  if ((_platform & cond) == 0U && cond != 15U) {
    return (0);
  } else {

  }
  return (1);
}
}
static u32 Array_MAC_REG_8723A[172U]  = 
  {      1056U,      128U,      1059U,      0U, 
        1072U,      0U,      1073U,      0U, 
        1074U,      0U,      1075U,      1U, 
        1076U,      4U,      1077U,      5U, 
        1078U,      6U,      1079U,      7U, 
        1080U,      0U,      1081U,      0U, 
        1082U,      0U,      1083U,      1U, 
        1084U,      4U,      1085U,      5U, 
        1086U,      6U,      1087U,      7U, 
        1088U,      93U,      1089U,      1U, 
        1090U,      0U,      1092U,      21U, 
        1093U,      240U,      1094U,      15U, 
        1095U,      0U,      1112U,      65U, 
        1113U,      168U,      1114U,      114U, 
        1115U,      185U,      1120U,      102U, 
        1121U,      102U,      1122U,      8U, 
        1123U,      3U,      1224U,      255U, 
        1225U,      8U,      1228U,      255U, 
        1229U,      255U,      1230U,      1U, 
        1280U,      38U,      1281U,      162U, 
        1282U,      47U,      1283U,      0U, 
        1284U,      40U,      1285U,      163U, 
        1286U,      94U,      1287U,      0U, 
        1288U,      43U,      1289U,      164U, 
        1290U,      94U,      1291U,      0U, 
        1292U,      79U,      1293U,      164U, 
        1294U,      0U,      1295U,      0U, 
        1298U,      28U,      1300U,      10U, 
        1301U,      16U,      1302U,      10U, 
        1303U,      16U,      1306U,      22U, 
        1316U,      15U,      1317U,      79U, 
        1350U,      64U,      1351U,      0U, 
        1360U,      16U,      1361U,      16U, 
        1369U,      2U,      1370U,      2U, 
        1373U,      255U,      1541U,      48U, 
        1544U,      14U,      1545U,      42U, 
        1618U,      32U,      1596U,      10U, 
        1597U,      10U,      1598U,      14U, 
        1599U,      14U,      1646U,      5U, 
        1792U,      33U,      1793U,      67U, 
        1794U,      101U,      1795U,      135U, 
        1800U,      33U,      1801U,      67U, 
        1802U,      101U,      1803U,      135U};
void ODM_ReadAndConfig_MAC_REG_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
  hex = 0U;
  i = 0U;
  platform = 4U;
  board = pDM_Odm->BoardType;
  ArrayLen = 172U;
  Array = (u32 *)(& Array_MAC_REG_8723A);
  hex = (u32 )board + hex;
  hex = hex + 512U;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_55734;
  ldv_55733: 
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigMAC_8723A(pDM_Odm, v1, (int )((unsigned char )v2));
    goto ldv_55723;
  } else {
    tmp = CheckCondition___0(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55725;
      ldv_55724: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55725: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55724;
      } else {

      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55728;
      ldv_55727: 
      odm_ConfigMAC_8723A(pDM_Odm, v1, (int )((unsigned char )v2));
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55728: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55727;
      } else {

      }

      goto ldv_55731;
      ldv_55730: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55731: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_55730;
      } else {

      }

    }
  }
  ldv_55723: 
  i = i + 2U;
  ldv_55734: ;
  if (i < ArrayLen) {
    goto ldv_55733;
  } else {

  }

  return;
}
}
bool ldv_queue_work_on_355(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_356(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_357(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_358(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_369(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_371(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_370(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_373(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_372(struct workqueue_struct *ldv_func_arg1 ) ;
void ODM_ReadAndConfig_RadioA_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
void odm_ConfigRFReg_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data , enum RF_RADIO_PATH RF_PATH ,
                           u32 RegAddr ) ;
static bool CheckCondition___1(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
  _board = (unsigned int )Hex & 255U;
  _interface = ((unsigned int )Hex & 65280U) >> 8;
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
  cond = Condition;
  if ((unsigned int )Condition == 3452816845U) {
    return (1);
  } else {

  }
  cond = (unsigned int )Condition & 255U;
  if (_board == cond && cond != 0U) {
    return (0);
  } else {

  }
  cond = (unsigned int )Condition & 65280U;
  cond = cond >> 8;
  if ((_interface & cond) == 0U && cond != 7U) {
    return (0);
  } else {

  }
  cond = (unsigned int )Condition & 16711680U;
  cond = cond >> 16;
  if ((_platform & cond) == 0U && cond != 15U) {
    return (0);
  } else {

  }
  return (1);
}
}
static u32 Array_RadioA_1T_8723A[312U]  = 
  {      0U,      196953U,      1U,      201348U, 
        2U,      622592U,      4279173407U,      43981U, 
        3U,      101475U,      3452816845U,      52685U, 
        3U,      236643U,      4279173407U,      57005U, 
        4U,      135399U,      9U,      132175U, 
        10U,      107505U,      11U,      83847U, 
        12U,      562942U,      13U,      57388U, 
        14U,      236775U,      15U,      1105U, 
        25U,      0U,      26U,      197461U, 
        27U,      395776U,      28U,      1033080U, 
        29U,      660048U,      30U,      591U, 
        31U,      0U,      32U,      46612U, 
        33U,      442368U,      34U,      0U, 
        35U,      5464U,      36U,      96U, 
        37U,      1155U,      38U,      323584U, 
        39U,      968665U,      40U,      358192U, 
        41U,      18307U,      42U,      1U, 
        43U,      135988U,      42U,      0U, 
        43U,      84U,      42U,      1U, 
        43U,      2056U,      43U,      340787U, 
        44U,      12U,      42U,      2U, 
        43U,      2056U,      43U,      373555U, 
        44U,      13U,      42U,      3U, 
        43U,      2056U,      43U,      406323U, 
        44U,      13U,      42U,      4U, 
        43U,      2056U,      43U,      439091U, 
        44U,      13U,      42U,      5U, 
        43U,      2056U,      43U,      471859U, 
        44U,      13U,      42U,      6U, 
        43U,      1801U,      43U,      373555U, 
        44U,      13U,      42U,      7U, 
        43U,      1801U,      43U,      406323U, 
        44U,      13U,      42U,      8U, 
        43U,      1546U,      43U,      308019U, 
        44U,      13U,      42U,      9U, 
        43U,      1546U,      43U,      340787U, 
        44U,      13U,      42U,      10U, 
        43U,      1546U,      43U,      373555U, 
        44U,      13U,      42U,      11U, 
        43U,      1546U,      43U,      406323U, 
        44U,      13U,      42U,      12U, 
        43U,      1546U,      43U,      439091U, 
        44U,      13U,      42U,      13U, 
        43U,      1546U,      43U,      471859U, 
        44U,      13U,      42U,      14U, 
        43U,      1291U,      43U,      419430U, 
        44U,      26U,      42U,      917504U, 
        16U,      262159U,      17U,      930300U, 
        16U,      393231U,      17U,      1047032U, 
        16U,      131087U,      17U,      132089U, 
        16U,      196623U,      17U,      1045760U, 
        16U,      0U,      17U,      0U, 
        16U,      524303U,      17U,      258304U, 
        16U,      589839U,      17U,      143616U, 
        18U,      204800U,      18U,      462848U, 
        18U,      720896U,      18U,      1032192U, 
        19U,      165811U,      19U,      148663U, 
        19U,      132267U,      19U,      115871U, 
        19U,      99475U,      19U,      82587U, 
        19U,      66201U,      19U,      49820U, 
        19U,      33184U,      19U,      16556U, 
        19U,      32U,      20U,      103500U, 
        20U,      365636U,      20U,      627788U, 
        20U,      889924U,      4279173407U,      43981U, 
        21U,      62500U,      21U,      324644U, 
        21U,      586788U,      21U,      848932U, 
        3452816845U,      52685U,      21U,      62580U, 
        21U,      324727U,      21U,      586837U, 
        21U,      848981U,      4279173407U,      57005U, 
        22U,      825U,      22U,      262969U, 
        22U,      525113U,      4279173407U,      43981U, 
        22U,      787286U,      3452816845U,      52685U, 
        22U,      787302U,      4279173407U,      57005U, 
        0U,      65881U,      24U,      62465U, 
        254U,      0U,      254U,      0U, 
        31U,      3U,      254U,      0U, 
        254U,      0U,      30U,      583U, 
        31U,      0U,      0U,      196953U};
void ODM_ReadAndConfig_RadioA_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
  hex = 0U;
  i = 0U;
  platform = 4U;
  board = pDM_Odm->BoardType;
  ArrayLen = 312U;
  Array = (u32 *)(& Array_RadioA_1T_8723A);
  hex = (u32 )board + hex;
  hex = hex + 512U;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_55734;
  ldv_55733: 
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigRFReg_8723A(pDM_Odm, v1, v2, 0, v1);
    goto ldv_55723;
  } else {
    tmp = CheckCondition___1(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55725;
      ldv_55724: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55725: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55724;
      } else {

      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_55728;
      ldv_55727: 
      odm_ConfigRFReg_8723A(pDM_Odm, v1, v2, 0, v1);
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55728: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_55727;
      } else {

      }

      goto ldv_55731;
      ldv_55730: 
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_55731: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_55730;
      } else {

      }

    }
  }
  ldv_55723: 
  i = i + 2U;
  ldv_55734: ;
  if (i < ArrayLen) {
    goto ldv_55733;
  } else {

  }

  return;
}
}
bool ldv_queue_work_on_369(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_370(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_371(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_372(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_373(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_383(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_385(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_384(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_387(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_386(struct workqueue_struct *ldv_func_arg1 ) ;
extern void __udelay(unsigned long  ) ;
u8 HalPwrSeqCmdParsing23a(struct rtw_adapter *padapter , u8 CutVersion , u8 FabVersion ,
                          u8 InterfaceType , struct wlan_pwr_cfg *PwrSeqCmd ) ;
u8 HalPwrSeqCmdParsing23a(struct rtw_adapter *padapter , u8 CutVersion , u8 FabVersion ,
                          u8 InterfaceType , struct wlan_pwr_cfg *PwrSeqCmd ) 
{ 
  struct wlan_pwr_cfg PwrCfgCmd ;
  u8 bPollingBit ;
  u32 AryIdx ;
  u8 value ;
  u32 offset ;
  u32 pollingCount ;
  u32 maxPollingCnt ;
  u32 tmp ;

  {
  AryIdx = 0U;
  pollingCount = 0U;
  maxPollingCnt = 5000U;
  ldv_53256: 
  PwrCfgCmd = *(PwrSeqCmd + (unsigned long )AryIdx);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: offset(%#x) cut_msk(%#x) fab_msk(%#x) interface_msk(%#x) base(%#x) cmd(%#x) msk(%#x) value(%#x)\n",
             (int )PwrCfgCmd.offset, (int )PwrCfgCmd.cut_msk, (int )PwrCfgCmd.fab_msk,
             (int )PwrCfgCmd.interface_msk, (int )PwrCfgCmd.base, (int )PwrCfgCmd.cmd,
             (int )PwrCfgCmd.msk, (int )PwrCfgCmd.value);
  } else {

  }
  if ((((int )PwrCfgCmd.fab_msk & (int )FabVersion) != 0 && (unsigned int )((int )PwrCfgCmd.cut_msk & (int )CutVersion) != 0U) && ((int )PwrCfgCmd.interface_msk & (int )InterfaceType) != 0) {
    switch ((int )PwrCfgCmd.cmd) {
    case 0: ;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_READ\n");
    } else {

    }
    goto ldv_53248;
    case 1: ;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_WRITE\n");
    } else {

    }
    offset = (u32 )PwrCfgCmd.offset;
    value = rtl8723au_read8(padapter, (int )((u16 )offset));
    value = (u8 )(~ ((int )((signed char )PwrCfgCmd.msk)) & (int )((signed char )value));
    value = (u8 )(((int )PwrCfgCmd.value & (int )PwrCfgCmd.msk) | (int )value);
    rtl8723au_write8(padapter, (int )((u16 )offset), (int )value);
    goto ldv_53248;
    case 2: ;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_POLLING\n");
    } else {

    }
    bPollingBit = 0U;
    offset = (u32 )PwrCfgCmd.offset;
    ldv_53251: 
    value = rtl8723au_read8(padapter, (int )((u16 )offset));
    value = (u8 )((int )PwrCfgCmd.msk & (int )value);
    if (((int )PwrCfgCmd.value & (int )PwrCfgCmd.msk) == (int )value) {
      bPollingBit = 1U;
    } else {
      __const_udelay(42950UL);
    }
    tmp = pollingCount;
    pollingCount = pollingCount + 1U;
    if (tmp > maxPollingCnt) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Fail to polling Offset[%#x]\n", offset);
      } else {

      }
      return (0U);
    } else {

    }
    if ((unsigned int )bPollingBit == 0U) {
      goto ldv_53251;
    } else {

    }

    goto ldv_53248;
    case 3: ;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_DELAY\n");
    } else {

    }
    if ((unsigned int )PwrCfgCmd.value == 0U) {
      __udelay((unsigned long )PwrCfgCmd.offset);
    } else {
      __udelay((unsigned long )((int )PwrCfgCmd.offset * 1000));
    }
    goto ldv_53248;
    case 4: ;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "HalPwrSeqCmdParsing23a: PWR_CMD_END\n");
    } else {

    }
    return (1U);
    default: ;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16384, 4, "HalPwrSeqCmdParsing23a: Unknown CMD!!\n");
    } else {

    }
    goto ldv_53248;
    }
    ldv_53248: ;
  } else {

  }
  AryIdx = AryIdx + 1U;
  goto ldv_53256;
  return (1U);
}
}
bool ldv_queue_work_on_383(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_384(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_385(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_386(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_387(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_399(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_398(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_401(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_400(struct workqueue_struct *ldv_func_arg1 ) ;
void ODM_SetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) ;
void odm_ConfigRFReg_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data , enum RF_RADIO_PATH RF_PATH ,
                           u32 RegAddr ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;

  {
  if (Addr == 254U) {
    msleep(50U);
  } else
  if (Addr == 253U) {
    if (1) {
      __const_udelay(21475000UL);
    } else {
      __ms = 5UL;
      goto ldv_55753;
      ldv_55752: 
      __const_udelay(4295000UL);
      ldv_55753: 
      tmp = __ms;
      __ms = __ms - 1UL;
      if (tmp != 0UL) {
        goto ldv_55752;
      } else {

      }

    }
  } else
  if (Addr == 252U) {
    if (1) {
      __const_udelay(4295000UL);
    } else {
      __ms___0 = 1UL;
      goto ldv_55757;
      ldv_55756: 
      __const_udelay(4295000UL);
      ldv_55757: 
      tmp___0 = __ms___0;
      __ms___0 = __ms___0 - 1UL;
      if (tmp___0 != 0UL) {
        goto ldv_55756;
      } else {

      }

    }
  } else
  if (Addr == 251U) {
    __const_udelay(214750UL);
  } else
  if (Addr == 250U) {
    __const_udelay(21475UL);
  } else
  if (Addr == 249U) {
    __const_udelay(4295UL);
  } else {
    ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, 1048575U, Data);
    __const_udelay(4295UL);
  }
  return;
}
}
void odm_ConfigMAC_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u8 data ) 
{ 


  {
  rtl8723au_write8(pDM_Odm->Adapter, (int )((u16 )addr), (int )data);
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> %s: [MAC_REG] %08X %08X\n", "odm_ConfigMAC_8723A", "odm_ConfigMAC_8723A",
           addr, (int )data);
  } else {

  }
  return;
}
}
void odm_ConfigBB_AGC_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u32 data ) 
{ 


  {
  rtl8723au_write32(pDM_Odm->Adapter, (int )((u16 )addr), data);
  __const_udelay(4295UL);
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> %s: [AGC_TAB] %08X %08X\n", "odm_ConfigBB_AGC_8723A", "odm_ConfigBB_AGC_8723A",
           addr, data);
  } else {

  }
  return;
}
}
void odm_ConfigBB_PHY_8723A(struct dm_odm_t *pDM_Odm , u32 addr , u32 data ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;

  {
  if (addr == 254U) {
    msleep(50U);
  } else
  if (addr == 253U) {
    if (1) {
      __const_udelay(21475000UL);
    } else {
      __ms = 5UL;
      goto ldv_55778;
      ldv_55777: 
      __const_udelay(4295000UL);
      ldv_55778: 
      tmp = __ms;
      __ms = __ms - 1UL;
      if (tmp != 0UL) {
        goto ldv_55777;
      } else {

      }

    }
  } else
  if (addr == 252U) {
    if (1) {
      __const_udelay(4295000UL);
    } else {
      __ms___0 = 1UL;
      goto ldv_55782;
      ldv_55781: 
      __const_udelay(4295000UL);
      ldv_55782: 
      tmp___0 = __ms___0;
      __ms___0 = __ms___0 - 1UL;
      if (tmp___0 != 0UL) {
        goto ldv_55781;
      } else {

      }

    }
  } else
  if (addr == 251U) {
    __const_udelay(214750UL);
  } else
  if (addr == 250U) {
    __const_udelay(21475UL);
  } else
  if (addr == 249U) {
    __const_udelay(4295UL);
  } else
  if (addr == 2596U) {
    pDM_Odm->RFCalibrateInfo.RegA24 = data;
  } else {

  }
  rtl8723au_write32(pDM_Odm->Adapter, (int )((u16 )addr), data);
  __const_udelay(4295UL);
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> %s: [PHY_REG] %08X %08X\n", "odm_ConfigBB_PHY_8723A", "odm_ConfigBB_PHY_8723A",
           addr, data);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_397(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_398(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_399(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_400(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_401(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv__builtin_va_end(__builtin_va_list * ) ;
void ldv__builtin_va_start(__builtin_va_list * ) ;
bool ldv_queue_work_on_411(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_413(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_412(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_415(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_414(struct workqueue_struct *ldv_func_arg1 ) ;
u32 GlobalDebugLevel23A  ;
void ODM_InitDebugSetting23a(struct dm_odm_t *pDM_Odm ) ;
void ODM_InitDebugSetting23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
  pDM_Odm->DebugLevel = 5U;
  pDM_Odm->DebugComponents = 0ULL;
  return;
}
}
void rt_trace(int comp , int level , char const   *fmt  , ...) 
{ 
  struct va_format vaf ;
  va_list args ;

  {
  ldv__builtin_va_start((va_list *)(& args));
  vaf.fmt = fmt;
  vaf.va = & args;
  printk("\016RTL8723AU:  [0x%08x,%d] %pV", comp, level, & vaf);
  ldv__builtin_va_end((va_list *)(& args));
  return;
}
}
bool ldv_queue_work_on_411(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_412(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_413(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_414(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_415(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_425(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_427(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_426(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_429(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_428(struct workqueue_struct *ldv_func_arg1 ) ;
u32 ODM_GetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                 u32 BitMask ) ;
void ODM_SetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) 
{ 
  struct rtw_adapter *Adapter ;

  {
  Adapter = pDM_Odm->Adapter;
  PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data);
  return;
}
}
u32 ODM_GetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                 u32 BitMask ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;

  {
  Adapter = pDM_Odm->Adapter;
  tmp = PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask);
  return (tmp);
}
}
bool ldv_queue_work_on_425(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_426(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_427(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_428(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_429(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_439(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_441(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_440(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_443(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_442(struct workqueue_struct *ldv_func_arg1 ) ;
void odm_Init_RSSIForDM23a(struct dm_odm_t *pDM_Odm ) ;
void ODM_PhyStatusQuery23a(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                           u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) ;
static u8 odm_QueryRxPwrPercentage(s8 AntPower ) 
{ 


  {
  if ((int )AntPower < -99 || (int )AntPower > 19) {
    return (0U);
  } else
  if ((int )AntPower >= 0) {
    return (100U);
  } else {
    return ((unsigned int )((u8 )AntPower) + 100U);
  }
}
}
static s32 odm_SignalScaleMapping_92CSeries(struct dm_odm_t *pDM_Odm , s32 CurrSig ) 
{ 
  s32 RetSig ;

  {
  RetSig = 0;
  if (CurrSig > 50 && CurrSig <= 100) {
    RetSig = 100;
  } else
  if (CurrSig > 40 && CurrSig <= 50) {
    RetSig = CurrSig * 2;
  } else
  if (CurrSig > 30 && CurrSig <= 40) {
    RetSig = CurrSig + 36;
  } else
  if (CurrSig > 20 && CurrSig <= 30) {
    RetSig = CurrSig + 34;
  } else
  if (CurrSig > 9 && CurrSig <= 20) {
    RetSig = ((CurrSig + -10) * 2) / 3 + 42;
  } else
  if (CurrSig > 4 && CurrSig <= 9) {
    RetSig = (CurrSig * 3 + -15) / 2 + 22;
  } else
  if (CurrSig > 0 && CurrSig <= 4) {
    RetSig = ((CurrSig + -1) * 3) / 2 + 6;
  } else {
    RetSig = CurrSig;
  }
  return (RetSig);
}
}
static s32 odm_SignalScaleMapping(struct dm_odm_t *pDM_Odm , s32 CurrSig ) 
{ 
  s32 tmp ;

  {
  tmp = odm_SignalScaleMapping_92CSeries(pDM_Odm, CurrSig);
  return (tmp);
}
}
static u8 odm_EVMdbToPercentage(s8 Value ) 
{ 
  s8 ret_val ;

  {
  ret_val = Value;
  if ((int )ret_val >= 0) {
    ret_val = 0;
  } else {

  }
  if ((int )ret_val < -32) {
    ret_val = -33;
  } else {

  }
  ret_val = (s8 )(- ((int )((unsigned char )ret_val)));
  ret_val = (s8 )((unsigned int )((unsigned char )ret_val) * 3U);
  if ((int )ret_val == 99) {
    ret_val = 100;
  } else {

  }
  return ((u8 )ret_val);
}
}
static void odm_RxPhyStatus92CSeries_Parsing(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                             u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) 
{ 
  struct phy_status_rpt *pPhyStaRpt ;
  u8 i ;
  u8 Max_spatial_stream ;
  s8 rx_pwr[4U] ;
  s8 rx_pwr_all ;
  u8 EVM ;
  u8 PWDB_ALL ;
  u8 PWDB_ALL_BT ;
  u8 RSSI ;
  u8 total_rssi ;
  u8 isCCKrate ;
  u8 rf_rx_num ;
  u8 cck_highpwr ;
  u8 report ;
  u8 cck_agc_rpt ;
  u8 SQ ;
  u8 SQ_rpt ;
  s8 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
  pPhyStaRpt = (struct phy_status_rpt *)pPhyStatus;
  rx_pwr_all = 0;
  PWDB_ALL = 0U;
  total_rssi = 0U;
  isCCKrate = 0U;
  rf_rx_num = 0U;
  cck_highpwr = 0U;
  isCCKrate = (unsigned int )pPktinfo->Rate <= 3U;
  pPhyInfo->RxMIMOSignalQuality[0] = 255U;
  pPhyInfo->RxMIMOSignalQuality[1] = 255U;
  if ((unsigned int )isCCKrate != 0U) {
    pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK + 1ULL;
    cck_highpwr = (u8 )pDM_Odm->bCckHighPower;
    cck_agc_rpt = pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a;
    if ((unsigned int )cck_highpwr == 0U) {
      report = (int )cck_agc_rpt >> 6;
      switch ((int )report) {
      case 3: 
      rx_pwr_all = (s8 )(210U - ((unsigned int )cck_agc_rpt & 62U));
      goto ldv_55741;
      case 2: 
      rx_pwr_all = (s8 )(230U - ((unsigned int )cck_agc_rpt & 62U));
      goto ldv_55741;
      case 1: 
      rx_pwr_all = (s8 )(244U - ((unsigned int )cck_agc_rpt & 62U));
      goto ldv_55741;
      case 0: 
      rx_pwr_all = (s8 )(16U - ((unsigned int )cck_agc_rpt & 62U));
      goto ldv_55741;
      }
      ldv_55741: ;
    } else {
      report = (u8 )(((int )cck_agc_rpt & 96) >> 5);
      switch ((int )report) {
      case 3: 
      rx_pwr_all = (s8 )(210U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
      goto ldv_55746;
      case 2: 
      rx_pwr_all = (s8 )(230U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
      goto ldv_55746;
      case 1: 
      rx_pwr_all = (s8 )(244U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
      goto ldv_55746;
      case 0: 
      rx_pwr_all = (s8 )(16U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
      goto ldv_55746;
      }
      ldv_55746: ;
    }
    PWDB_ALL = odm_QueryRxPwrPercentage((int )rx_pwr_all);
    if ((unsigned int )pDM_Odm->BoardType == 1U) {
      if ((int )((signed char )cck_agc_rpt) >= 0) {
        PWDB_ALL = (unsigned int )PWDB_ALL <= 94U ? (unsigned int )PWDB_ALL + 6U : 100U;
      } else
      if ((unsigned int )PWDB_ALL > 38U) {
        PWDB_ALL = (unsigned int )PWDB_ALL + 240U;
      } else {
        PWDB_ALL = (unsigned int )PWDB_ALL <= 16U ? (u8 )((int )PWDB_ALL >> 2) : (unsigned int )PWDB_ALL + 244U;
      }
      if ((unsigned int )PWDB_ALL > 25U && (unsigned int )PWDB_ALL <= 60U) {
        PWDB_ALL = (unsigned int )PWDB_ALL + 6U;
      } else {

      }
    } else
    if ((unsigned int )PWDB_ALL > 99U) {
      PWDB_ALL = (unsigned int )PWDB_ALL + 248U;
    } else
    if ((unsigned int )PWDB_ALL > 50U && (unsigned int )PWDB_ALL <= 68U) {
      PWDB_ALL = (unsigned int )PWDB_ALL + 4U;
    } else {

    }
    pPhyInfo->RxPWDBAll = PWDB_ALL;
    pPhyInfo->BTRxRSSIPercentage = PWDB_ALL;
    pPhyInfo->RecvSignalPower = rx_pwr_all;
    if ((int )pPktinfo->bPacketMatchBSSID) {
      SQ_rpt = pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all;
      if ((unsigned int )SQ_rpt > 64U) {
        SQ = 0U;
      } else
      if ((unsigned int )SQ_rpt <= 19U) {
        SQ = 100U;
      } else {
        SQ = (u8 )(((int )SQ_rpt * -100 + 6400) / 44);
      }
      pPhyInfo->SignalQuality = SQ;
      pPhyInfo->RxMIMOSignalQuality[0] = SQ;
      pPhyInfo->RxMIMOSignalQuality[1] = 255U;
    } else {

    }
  } else {
    pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM + 1ULL;
    i = 0U;
    goto ldv_55753;
    ldv_55752: ;
    if ((int )((unsigned long )pDM_Odm->RFPathRxEnable >> (int )i) & 1) {
      rf_rx_num = (u8 )((int )rf_rx_num + 1);
    } else {

    }
    rx_pwr[(int )i] = (s8 )((unsigned int )((unsigned char )(((int )pPhyStaRpt->path_agc[(int )i].gain & 63) + -55)) * 2U);
    pPhyInfo->RxPwr[(int )i] = (u8 )rx_pwr[(int )i];
    RSSI = odm_QueryRxPwrPercentage((int )rx_pwr[(int )i]);
    total_rssi = (int )total_rssi + (int )RSSI;
    if ((unsigned int )pDM_Odm->BoardType == 1U) {
      if ((unsigned int )pPhyStaRpt->path_agc[(int )i].trsw == 1U) {
        RSSI = (unsigned int )RSSI <= 94U ? (unsigned int )RSSI + 6U : 100U;
      } else {
        RSSI = (unsigned int )RSSI <= 16U ? (u8 )((int )RSSI >> 3) : (unsigned int )RSSI + 240U;
      }
      if ((unsigned int )RSSI <= 34U && (unsigned int )RSSI > 3U) {
        RSSI = (unsigned int )RSSI + 252U;
      } else {

      }
    } else {

    }
    pPhyInfo->RxMIMOSignalStrength[(int )i] = RSSI;
    tmp = (s8 )((unsigned int )pPhyStaRpt->path_rxsnr[(int )i] / 2U);
    pDM_Odm->PhyDbgInfo.RxSNRdB[(int )i] = tmp;
    pPhyInfo->RxSNR[(int )i] = (u8 )tmp;
    i = (u8 )((int )i + 1);
    ldv_55753: ;
    if ((unsigned int )i <= 1U) {
      goto ldv_55752;
    } else {

    }
    rx_pwr_all = (s8 )((unsigned int )((int )pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all >> 1) + 146U);
    PWDB_ALL = odm_QueryRxPwrPercentage((int )rx_pwr_all);
    PWDB_ALL_BT = PWDB_ALL;
    pPhyInfo->RxPWDBAll = PWDB_ALL;
    pPhyInfo->BTRxRSSIPercentage = PWDB_ALL_BT;
    pPhyInfo->RxPower = rx_pwr_all;
    pPhyInfo->RecvSignalPower = rx_pwr_all;
    if ((unsigned int )pPktinfo->Rate > 19U && (unsigned int )pPktinfo->Rate <= 27U) {
      Max_spatial_stream = 2U;
    } else {
      Max_spatial_stream = 1U;
    }
    i = 0U;
    goto ldv_55756;
    ldv_55755: 
    EVM = odm_EVMdbToPercentage((int )pPhyStaRpt->stream_rxevm[(int )i]);
    if ((int )pPktinfo->bPacketMatchBSSID) {
      if ((unsigned int )i == 0U) {
        pPhyInfo->SignalQuality = EVM;
      } else {

      }
      pPhyInfo->RxMIMOSignalQuality[(int )i] = EVM;
    } else {

    }
    i = (u8 )((int )i + 1);
    ldv_55756: ;
    if ((int )i < (int )Max_spatial_stream) {
      goto ldv_55755;
    } else {

    }

  }
  if ((unsigned int )isCCKrate != 0U) {
    tmp___0 = odm_SignalScaleMapping(pDM_Odm, (s32 )PWDB_ALL);
    pPhyInfo->SignalStrength = (unsigned char )tmp___0;
  } else
  if ((unsigned int )rf_rx_num != 0U) {
    total_rssi = (u8 )((int )total_rssi / (int )rf_rx_num);
    tmp___1 = odm_SignalScaleMapping(pDM_Odm, (s32 )total_rssi);
    pPhyInfo->SignalStrength = (unsigned char )tmp___1;
  } else {

  }
  return;
}
}
void odm_Init_RSSIForDM23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
  return;
}
}
static void odm_Process_RSSIForDM(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                  struct odm_packet_info *pPktinfo ) 
{ 
  s32 UndecoratedSmoothedPWDB ;
  s32 UndecoratedSmoothedCCK ;
  s32 UndecoratedSmoothedOFDM ;
  s32 RSSI_Ave ;
  u8 isCCKrate ;
  u8 RSSI_max ;
  u8 RSSI_min ;
  u8 i ;
  u32 OFDM_pkt ;
  u32 Weighting ;
  struct sta_info *pEntry ;

  {
  isCCKrate = 0U;
  OFDM_pkt = 0U;
  Weighting = 0U;
  if ((unsigned int )pPktinfo->StationID == 255U) {
    return;
  } else {

  }
  pEntry = pDM_Odm->pODM_StaInfo[(int )pPktinfo->StationID];
  if ((unsigned long )pEntry == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {

  }
  if (! pPktinfo->bPacketMatchBSSID) {
    return;
  } else {

  }
  isCCKrate = (unsigned int )pPktinfo->Rate <= 3U;
  UndecoratedSmoothedCCK = pEntry->rssi_stat.UndecoratedSmoothedCCK;
  UndecoratedSmoothedOFDM = pEntry->rssi_stat.UndecoratedSmoothedOFDM;
  UndecoratedSmoothedPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
  if ((int )pPktinfo->bPacketToSelf || (int )pPktinfo->bPacketBeacon) {
    if ((unsigned int )isCCKrate == 0U) {
      if ((unsigned int )pPhyInfo->RxMIMOSignalStrength[1] == 0U) {
        RSSI_Ave = (s32 )pPhyInfo->RxMIMOSignalStrength[0];
      } else {
        if ((int )pPhyInfo->RxMIMOSignalStrength[0] > (int )pPhyInfo->RxMIMOSignalStrength[1]) {
          RSSI_max = pPhyInfo->RxMIMOSignalStrength[0];
          RSSI_min = pPhyInfo->RxMIMOSignalStrength[1];
        } else {
          RSSI_max = pPhyInfo->RxMIMOSignalStrength[1];
          RSSI_min = pPhyInfo->RxMIMOSignalStrength[0];
        }
        if ((int )RSSI_max - (int )RSSI_min <= 2) {
          RSSI_Ave = (s32 )RSSI_max;
        } else
        if ((int )RSSI_max - (int )RSSI_min <= 5) {
          RSSI_Ave = (int )RSSI_max + -1;
        } else
        if ((int )RSSI_max - (int )RSSI_min <= 9) {
          RSSI_Ave = (int )RSSI_max + -2;
        } else {
          RSSI_Ave = (int )RSSI_max + -3;
        }
      }
      if (UndecoratedSmoothedOFDM <= 0) {
        UndecoratedSmoothedOFDM = (s32 )pPhyInfo->RxPWDBAll;
      } else
      if ((unsigned int )pPhyInfo->RxPWDBAll > (unsigned int )UndecoratedSmoothedOFDM) {
        UndecoratedSmoothedOFDM = (UndecoratedSmoothedOFDM * 19 + RSSI_Ave) / 20;
        UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM + 1;
      } else {
        UndecoratedSmoothedOFDM = (UndecoratedSmoothedOFDM * 19 + RSSI_Ave) / 20;
      }
      pEntry->rssi_stat.PacketMap = (pEntry->rssi_stat.PacketMap << 1) | 1ULL;
    } else {
      RSSI_Ave = (s32 )pPhyInfo->RxPWDBAll;
      if (UndecoratedSmoothedCCK <= 0) {
        UndecoratedSmoothedCCK = (s32 )pPhyInfo->RxPWDBAll;
      } else
      if ((unsigned int )pPhyInfo->RxPWDBAll > (unsigned int )UndecoratedSmoothedCCK) {
        UndecoratedSmoothedCCK = (UndecoratedSmoothedCCK * 19 + (int )pPhyInfo->RxPWDBAll) / 20;
        UndecoratedSmoothedCCK = UndecoratedSmoothedCCK + 1;
      } else {
        UndecoratedSmoothedCCK = (UndecoratedSmoothedCCK * 19 + (int )pPhyInfo->RxPWDBAll) / 20;
      }
      pEntry->rssi_stat.PacketMap = pEntry->rssi_stat.PacketMap << 1;
    }
    if ((unsigned int )pEntry->rssi_stat.ValidBit > 63U) {
      pEntry->rssi_stat.ValidBit = 64U;
    } else {
      pEntry->rssi_stat.ValidBit = (u8 )((int )pEntry->rssi_stat.ValidBit + 1);
    }
    i = 0U;
    goto ldv_55778;
    ldv_55777: 
    OFDM_pkt = ((u32 )((unsigned char )(pEntry->rssi_stat.PacketMap >> (int )i)) & 1U) + OFDM_pkt;
    i = (u8 )((int )i + 1);
    ldv_55778: ;
    if ((int )pEntry->rssi_stat.ValidBit > (int )i) {
      goto ldv_55777;
    } else {

    }

    if ((unsigned int )pEntry->rssi_stat.ValidBit == 64U) {
      Weighting = 64U < OFDM_pkt << 4 ? 64U : OFDM_pkt << 4;
      UndecoratedSmoothedPWDB = (s32 )((Weighting * (u32 )UndecoratedSmoothedOFDM + (64U - Weighting) * (u32 )UndecoratedSmoothedCCK) >> 6);
    } else
    if ((unsigned int )pEntry->rssi_stat.ValidBit != 0U) {
      UndecoratedSmoothedPWDB = (s32 )((OFDM_pkt * (u32 )UndecoratedSmoothedOFDM + ((u32 )pEntry->rssi_stat.ValidBit - OFDM_pkt) * (u32 )UndecoratedSmoothedCCK) / (u32 )pEntry->rssi_stat.ValidBit);
    } else {
      UndecoratedSmoothedPWDB = 0;
    }
    pEntry->rssi_stat.UndecoratedSmoothedCCK = UndecoratedSmoothedCCK;
    pEntry->rssi_stat.UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM;
    pEntry->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
  } else {

  }
  return;
}
}
void ODM_PhyStatusQuery23a(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                           u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) 
{ 


  {
  odm_RxPhyStatus92CSeries_Parsing(pDM_Odm, pPhyInfo, pPhyStatus, pPktinfo);
  odm_Process_RSSIForDM(pDM_Odm, pPhyInfo, pPktinfo);
  return;
}
}
bool ldv_queue_work_on_439(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_440(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_441(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_442(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_443(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_453(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_455(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_454(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_457(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_456(struct workqueue_struct *ldv_func_arg1 ) ;
void ODM_Write_CCK_CCA_Thres23a(struct dm_odm_t *pDM_Odm , u8 CurCCK_CCAThres ) ;
void ODM_RF_Saving23a(struct dm_odm_t *pDM_Odm , u8 bForceInNormal ) ;
bool ODM_RAStateCheck23a(struct dm_odm_t *pDM_Odm , s32 RSSI , bool bForceUpdate ,
                         u8 *pRATRState ) ;
u32 ConvertTo_dB23a(u32 Value ) ;
u32 GetPSDData(struct dm_odm_t *pDM_Odm , unsigned int point , u8 initial_gain_psd ) ;
void odm_DIG23abyRSSI_LPS(struct dm_odm_t *pDM_Odm ) ;
u32 ODM_Get_Rate_Bitmap23a(struct hal_data_8723a *pHalData , u32 macid , u32 ra_mask ,
                           u8 rssi_level ) ;
void ODM23a_DMInit(struct dm_odm_t *pDM_Odm ) ;
void ODM_DMWatchdog23a(struct rtw_adapter *adapter ) ;
void ODM_CmnInfoInit23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , u32 Value ) ;
void ODM_CmnInfoPtrArrayHook23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo ,
                                u16 Index , void *pValue ) ;
void ODM_CmnInfoUpdate23a(struct dm_odm_t *pDM_Odm , u32 CmnInfo , u64 Value ) ;
void ODM_SingleDualAntennaDefaultSetting(struct dm_odm_t *pDM_Odm ) ;
bool ODM_SingleDualAntennaDetection(struct dm_odm_t *pDM_Odm , u8 mode ) ;
bool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter ) ;
int rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter , u8 *param ) ;
static u16 const   dB_Invert_Table[8U][12U]  = 
  { {        1U,        1U,        1U,        2U, 
            2U,        2U,        2U,        3U, 
            3U,        3U,        4U,        4U}, 
   {        4U,        5U,        6U,        6U, 
            7U,        8U,        9U,        10U, 
            11U,        13U,        14U,        16U}, 
   {        18U,        20U,        22U,        25U, 
            28U,        32U,        35U,        40U, 
            45U,        50U,        56U,        63U}, 
   {        71U,        79U,        89U,        100U, 
            112U,        126U,        141U,        158U, 
            178U,        200U,        224U,        251U}, 
   {        282U,        316U,        355U,        398U, 
            447U,        501U,        562U,        631U, 
            708U,        794U,        891U,        1000U}, 
   {        1122U,        1259U,        1413U,        1585U, 
            1778U,        1995U,        2239U,        2512U, 
            2818U,        3162U,        3548U,        3981U}, 
   {        4467U,        5012U,        5623U,        6310U, 
            7079U,        7943U,        8913U,        10000U, 
            11220U,        12589U,        14125U,        15849U}, 
   {        17783U,        19953U,        22387U,        25119U, 
            28184U,        31623U,        35481U,        39811U, 
            44668U,        50119U,        56234U,        65535U}};
static u32 EDCAParam[17U][3U]  = 
  { {        6202411U,        6202411U,        6202411U}, 
   {        42063U,        6202447U,        6177564U}, 
   {        6202411U,        6202411U,        6202411U}, 
   {        6202155U,        6202411U,        6177570U}, 
   {        6202402U,        42063U,        42063U}, 
   {        6202146U,        42544U,        42063U}, 
   {        6177570U,        6177570U,        6177570U}, 
   {        6202447U,        42063U,        6202411U}, 
   {        6202411U,        6202411U,        6202411U}, 
   {        6202411U,        42544U,        6177564U}};
u32 OFDMSwingTable23A[43U]  = 
  {      2139095550U,      2021655010U,      1908408775U,      1803551150U, 
        1698693525U,      1606418815U,      1514144105U,      1430258005U, 
        1350566210U,      1275068720U,      1203765535U,      1136656655U, 
        1073742080U,      1015021810U,      956301540U,      901775575U, 
        851443915U,      805306560U,      759169205U,      717226155U, 
        679477410U,      637534360U,      603979920U,      570425480U, 
        536871040U,      507510905U,      478150770U,      452984940U, 
        427819110U,      402653280U,      381681755U,      360710230U, 
        339738705U,      318767180U,      301989960U,      285212740U, 
        268435520U,      251658300U,      239075385U,      226492470U, 
        213909555U,      201326640U,      188743725U};
u8 CCKSwingTable_Ch1_Ch1323A[33U][8U]  = 
  { {        54U,        53U,        46U,        37U, 
            28U,        18U,        9U,        4U}, 
   {        51U,        50U,        43U,        35U, 
            26U,        17U,        8U,        4U}, 
   {        48U,        47U,        41U,        33U, 
            25U,        16U,        8U,        3U}, 
   {        45U,        45U,        39U,        31U, 
            24U,        15U,        8U,        3U}, 
   {        43U,        42U,        37U,        30U, 
            22U,        14U,        7U,        3U}, 
   {        40U,        40U,        34U,        28U, 
            21U,        13U,        7U,        3U}, 
   {        38U,        37U,        33U,        27U, 
            20U,        13U,        6U,        3U}, 
   {        36U,        35U,        31U,        25U, 
            19U,        12U,        6U,        3U}, 
   {        34U,        33U,        29U,        24U, 
            17U,        11U,        6U,        2U}, 
   {        32U,        32U,        27U,        22U, 
            17U,        8U,        5U,        2U}, 
   {        31U,        30U,        26U,        21U, 
            16U,        10U,        5U,        2U}, 
   {        29U,        28U,        24U,        20U, 
            15U,        10U,        5U,        2U}, 
   {        27U,        26U,        23U,        19U, 
            14U,        9U,        4U,        2U}, 
   {        26U,        25U,        22U,        18U, 
            13U,        9U,        4U,        2U}, 
   {        24U,        23U,        21U,        17U, 
            12U,        8U,        4U,        2U}, 
   {        23U,        22U,        19U,        16U, 
            12U,        8U,        4U,        2U}, 
   {        22U,        21U,        18U,        15U, 
            11U,        7U,        4U,        1U}, 
   {        20U,        20U,        17U,        14U, 
            11U,        7U,        3U,        2U}, 
   {        19U,        19U,        16U,        13U, 
            10U,        6U,        3U,        1U}, 
   {        18U,        18U,        15U,        12U, 
            9U,        6U,        3U,        1U}, 
   {        17U,        17U,        15U,        12U, 
            9U,        6U,        3U,        1U}, 
   {        16U,        16U,        14U,        11U, 
            8U,        5U,        3U,        1U}, 
   {        15U,        15U,        13U,        11U, 
            8U,        5U,        3U,        1U}, 
   {        14U,        14U,        12U,        10U, 
            8U,        5U,        2U,        1U}, 
   {        13U,        13U,        12U,        10U, 
            7U,        5U,        2U,        1U}, 
   {        13U,        12U,        11U,        9U, 
            7U,        4U,        2U,        1U}, 
   {        12U,        12U,        10U,        9U, 
            6U,        4U,        2U,        1U}, 
   {        11U,        11U,        10U,        8U, 
            6U,        4U,        2U,        1U}, 
   {        11U,        10U,        9U,        8U, 
            6U,        4U,        2U,        1U}, 
   {        10U,        10U,        9U,        7U, 
            5U,        3U,        2U,        1U}, 
   {        10U,        9U,        8U,        7U, 
            5U,        3U,        2U,        1U}, 
   {        9U,        9U,        8U,        6U, 
            5U,        3U,        1U,        1U}, 
   {        9U,        8U,        7U,        6U, 
            4U,        3U,        1U,        1U}};
u8 CCKSwingTable_Ch1423A[33U][8U]  = 
  { {        54U,        53U,        46U,        27U, 
            0U,        0U,        0U,        0U}, 
   {        51U,        50U,        43U,        25U, 
            0U,        0U,        0U,        0U}, 
   {        48U,        47U,        41U,        24U, 
            0U,        0U,        0U,        0U}, 
   {        45U,        45U,        23U,        23U, 
            0U,        0U,        0U,        0U}, 
   {        43U,        42U,        37U,        21U, 
            0U,        0U,        0U,        0U}, 
   {        40U,        40U,        36U,        20U, 
            0U,        0U,        0U,        0U}, 
   {        38U,        37U,        33U,        19U, 
            0U,        0U,        0U,        0U}, 
   {        36U,        35U,        31U,        18U, 
            0U,        0U,        0U,        0U}, 
   {        34U,        33U,        29U,        17U, 
            0U,        0U,        0U,        0U}, 
   {        32U,        32U,        27U,        16U, 
            0U,        0U,        0U,        0U}, 
   {        31U,        30U,        26U,        15U, 
            0U,        0U,        0U,        0U}, 
   {        29U,        28U,        24U,        14U, 
            0U,        0U,        0U,        0U}, 
   {        27U,        26U,        23U,        14U, 
            0U,        0U,        0U,        0U}, 
   {        26U,        25U,        22U,        13U, 
            0U,        0U,        0U,        0U}, 
   {        24U,        23U,        21U,        12U, 
            0U,        0U,        0U,        0U}, 
   {        23U,        22U,        19U,        11U, 
            0U,        0U,        0U,        0U}, 
   {        22U,        21U,        18U,        11U, 
            0U,        0U,        0U,        0U}, 
   {        20U,        20U,        17U,        10U, 
            0U,        0U,        0U,        0U}, 
   {        19U,        19U,        16U,        10U, 
            0U,        0U,        0U,        0U}, 
   {        18U,        18U,        15U,        9U, 
            0U,        0U,        0U,        0U}, 
   {        17U,        17U,        15U,        9U, 
            0U,        0U,        0U,        0U}, 
   {        16U,        16U,        14U,        8U, 
            0U,        0U,        0U,        0U}, 
   {        15U,        15U,        13U,        8U, 
            0U,        0U,        0U,        0U}, 
   {        14U,        14U,        12U,        7U, 
            0U,        0U,        0U,        0U}, 
   {        13U,        13U,        12U,        7U, 
            0U,        0U,        0U,        0U}, 
   {        13U,        12U,        11U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        12U,        12U,        10U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        11U,        11U,        10U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        11U,        10U,        9U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        10U,        10U,        9U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        10U,        9U,        8U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        9U,        9U,        8U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        9U,        8U,        7U,        4U, 
            0U,        0U,        0U,        0U}};
void odm_CommonInfoSelfInit23a(struct dm_odm_t *pDM_Odm ) ;
static void odm_CommonInfoSelfUpdate(struct hal_data_8723a *pHalData ) ;
void odm_CmnInfoInit_Debug23a(struct dm_odm_t *pDM_Odm ) ;
void odm_CmnInfoUpdate_Debug23a(struct dm_odm_t *pDM_Odm ) ;
void odm_FalseAlarmCounterStatistics23a(struct dm_odm_t *pDM_Odm ) ;
void odm_DIG23aInit(struct dm_odm_t *pDM_Odm ) ;
void odm_DIG23a(struct rtw_adapter *adapter ) ;
void odm_CCKPacketDetectionThresh23a(struct dm_odm_t *pDM_Odm ) ;
void odm23a_DynBBPSInit(struct dm_odm_t *pDM_Odm ) ;
void odm_DynamicBBPowerSaving23a(struct dm_odm_t *pDM_Odm ) ;
void odm_DynamicTxPower23aInit(struct dm_odm_t *pDM_Odm ) ;
static void odm_RSSIMonitorCheck(struct dm_odm_t *pDM_Odm ) ;
static void odm_RefreshRateAdaptiveMask(struct dm_odm_t *pDM_Odm ) ;
void odm_RateAdaptiveMaskInit23a(struct dm_odm_t *pDM_Odm ) ;
static void odm_TXPowerTrackingInit(struct dm_odm_t *pDM_Odm ) ;
static void odm_EdcaTurboCheck23a(struct dm_odm_t *pDM_Odm ) ;
static void ODM_EdcaTurboInit23a(struct dm_odm_t *pDM_Odm ) ;
void ODM23a_DMInit(struct dm_odm_t *pDM_Odm ) 
{ 


  {
  odm_CommonInfoSelfInit23a(pDM_Odm);
  odm_CmnInfoInit_Debug23a(pDM_Odm);
  odm_DIG23aInit(pDM_Odm);
  odm_RateAdaptiveMaskInit23a(pDM_Odm);
  odm23a_DynBBPSInit(pDM_Odm);
  odm_DynamicTxPower23aInit(pDM_Odm);
  odm_TXPowerTrackingInit(pDM_Odm);
  ODM_EdcaTurboInit23a(pDM_Odm);
  return;
}
}
void ODM_DMWatchdog23a(struct rtw_adapter *adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct pwrctrl_priv *pwrctrlpriv ;

  {
  pHalData = (struct hal_data_8723a *)adapter->HalData;
  pDM_Odm = & pHalData->odmpriv;
  pwrctrlpriv = & adapter->pwrctrlpriv;
  odm_CmnInfoUpdate_Debug23a(pDM_Odm);
  odm_CommonInfoSelfUpdate(pHalData);
  odm_FalseAlarmCounterStatistics23a(pDM_Odm);
  odm_RSSIMonitorCheck(pDM_Odm);
  if ((unsigned int )(pDM_Odm->Adapter)->pwrctrlpriv.pwr_mode != 0U && (pDM_Odm->SupportICType & 8U) != 0U) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): ----Step1: odm_DIG23a is in LPS mode\n", "ODM_DMWatchdog23a");
    } else {

    }
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): ---Step2: 8723AS is in LPS mode\n", "ODM_DMWatchdog23a");
    } else {

    }
    odm_DIG23abyRSSI_LPS(pDM_Odm);
  } else {
    odm_DIG23a(adapter);
  }
  odm_CCKPacketDetectionThresh23a(pDM_Odm);
  if ((unsigned int )pwrctrlpriv->bpower_saving != 0U) {
    return;
  } else {

  }
  odm_RefreshRateAdaptiveMask(pDM_Odm);
  odm_DynamicBBPowerSaving23a(pDM_Odm);
  odm_EdcaTurboCheck23a(pDM_Odm);
  return;
}
}
void ODM_CmnInfoInit23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , u32 Value ) 
{ 


  {
  switch ((unsigned int )CmnInfo) {
  case 2U: 
  pDM_Odm->bIsMPChip = (unsigned int )((unsigned char )Value) != 0U;
  goto ldv_55812;
  case 3U: 
  pDM_Odm->SupportICType = Value;
  goto ldv_55812;
  case 4U: 
  pDM_Odm->CutVersion = (unsigned char )Value;
  goto ldv_55812;
  case 5U: 
  pDM_Odm->FabVersion = (unsigned char )Value;
  goto ldv_55812;
  case 6U: 
  pDM_Odm->BoardType = (unsigned char )Value;
  goto ldv_55812;
  case 7U: 
  pDM_Odm->ExtLNA = (unsigned char )Value;
  goto ldv_55812;
  case 8U: 
  pDM_Odm->ExtPA = (unsigned char )Value;
  goto ldv_55812;
  case 9U: 
  pDM_Odm->ExtTRSW = (unsigned char )Value;
  goto ldv_55812;
  case 10U: 
  pDM_Odm->bInHctTest = Value != 0U;
  goto ldv_55812;
  case 11U: 
  pDM_Odm->bWIFITest = Value != 0U;
  goto ldv_55812;
  case 12U: 
  pDM_Odm->bDualMacSmartConcurrent = Value != 0U;
  goto ldv_55812;
  default: ;
  goto ldv_55812;
  }
  ldv_55812: ;
  return;
}
}
void ODM_CmnInfoPtrArrayHook23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo ,
                                u16 Index , void *pValue ) 
{ 


  {
  switch ((unsigned int )CmnInfo) {
  case 28U: 
  pDM_Odm->pODM_StaInfo[(int )Index] = (struct sta_info *)pValue;
  goto ldv_55831;
  default: ;
  goto ldv_55831;
  }
  ldv_55831: ;
  return;
}
}
void ODM_CmnInfoUpdate23a(struct dm_odm_t *pDM_Odm , u32 CmnInfo , u64 Value ) 
{ 


  {
  switch (CmnInfo) {
  case 14U: 
  pDM_Odm->bWIFI_Direct = Value != 0ULL;
  goto ldv_55839;
  case 15U: 
  pDM_Odm->bWIFI_Display = Value != 0ULL;
  goto ldv_55839;
  case 16U: 
  pDM_Odm->bLinked = Value != 0ULL;
  goto ldv_55839;
  case 17U: 
  pDM_Odm->RSSI_Min = (unsigned char )Value;
  goto ldv_55839;
  case 18U: 
  pDM_Odm->DebugComponents = Value;
  goto ldv_55839;
  case 19U: 
  pDM_Odm->DebugLevel = (unsigned int )Value;
  goto ldv_55839;
  case 20U: 
  pDM_Odm->RateAdaptive.HighRSSIThresh = (unsigned char )Value;
  goto ldv_55839;
  case 21U: 
  pDM_Odm->RateAdaptive.LowRSSIThresh = (unsigned char )Value;
  goto ldv_55839;
  }
  ldv_55839: ;
  return;
}
}
void odm_CommonInfoSelfInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 val32 ;
  u32 tmp ;

  {
  val32 = rtl8723au_read32(pDM_Odm->Adapter, 2084);
  if (((unsigned long )val32 & 512UL) != 0UL) {
    pDM_Odm->bCckHighPower = 1;
  } else {
    pDM_Odm->bCckHighPower = 0;
  }
  tmp = rtl8723au_read32(pDM_Odm->Adapter, 3076);
  pDM_Odm->RFPathRxEnable = (unsigned int )((u8 )tmp) & 15U;
  ODM_InitDebugSetting23a(pDM_Odm);
  return;
}
}
static void odm_CommonInfoSelfUpdate(struct hal_data_8723a *pHalData ) 
{ 
  struct dm_odm_t *pDM_Odm ;
  struct sta_info *pEntry ;
  u8 EntryCnt ;
  u8 i ;

  {
  pDM_Odm = & pHalData->odmpriv;
  EntryCnt = 0U;
  i = 0U;
  goto ldv_55859;
  ldv_55858: 
  pEntry = pDM_Odm->pODM_StaInfo[(int )i];
  if ((unsigned long )pEntry != (unsigned long )((struct sta_info *)0)) {
    EntryCnt = (u8 )((int )EntryCnt + 1);
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_55859: ;
  if ((unsigned int )i <= 31U) {
    goto ldv_55858;
  } else {

  }

  if ((unsigned int )EntryCnt == 1U) {
    pDM_Odm->bOneEntryOnly = 1;
  } else {
    pDM_Odm->bOneEntryOnly = 0;
  }
  return;
}
}
void odm_CmnInfoInit_Debug23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_CmnInfoInit_Debug23a ==>\n", "odm_CmnInfoInit_Debug23a");
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): SupportAbility = 0x%x\n", "odm_CmnInfoInit_Debug23a", pDM_Odm->SupportAbility);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): SupportICType = 0x%x\n", "odm_CmnInfoInit_Debug23a", pDM_Odm->SupportICType);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): CutVersion =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->CutVersion);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): FabVersion =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->FabVersion);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): BoardType =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->BoardType);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ExtLNA =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtLNA);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ExtPA =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtPA);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ExtTRSW =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtTRSW);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bInHctTest =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bInHctTest);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bWIFITest =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bWIFITest);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bDualMacSmartConcurrent =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bDualMacSmartConcurrent);
  } else {

  }
  return;
}
}
void odm_CmnInfoUpdate_Debug23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_CmnInfoUpdate_Debug23a ==>\n", "odm_CmnInfoUpdate_Debug23a");
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bWIFI_Direct =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bWIFI_Direct);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bWIFI_Display =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bWIFI_Display);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bLinked =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bLinked);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): RSSI_Min =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->RSSI_Min);
  } else {

  }
  return;
}
}
void ODM_Write_DIG23a(struct dm_odm_t *pDM_Odm , u8 CurrentIGI ) 
{ 
  struct rtw_adapter *adapter ;
  struct dig_t *pDM_DigTable ;
  u32 val32 ;

  {
  adapter = pDM_Odm->Adapter;
  pDM_DigTable = & pDM_Odm->DM_DigTable;
  if ((int )pDM_DigTable->CurIGValue != (int )CurrentIGI) {
    val32 = rtl8723au_read32(adapter, 3152);
    val32 = val32 & 4294967168U;
    val32 = (u32 )CurrentIGI | val32;
    rtl8723au_write32(adapter, 3152, val32);
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): CurrentIGI(0x%02x). \n", "ODM_Write_DIG23a", (int )CurrentIGI);
    } else {

    }
    pDM_DigTable->CurIGValue = CurrentIGI;
  } else {

  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ODM_Write_DIG23a():CurrentIGI = 0x%x \n", "ODM_Write_DIG23a", (int )CurrentIGI);
  } else {

  }
  return;
}
}
void odm_DIG23abyRSSI_LPS(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *pAdapter ;
  struct false_alarm_stats *pFalseAlmCnt ;
  u8 RSSI_Lower ;
  u8 bFwCurrentInPSMode ;
  u8 CurrentIGI ;

  {
  pAdapter = pDM_Odm->Adapter;
  pFalseAlmCnt = & pDM_Odm->FalseAlmCnt;
  RSSI_Lower = 30U;
  bFwCurrentInPSMode = 0U;
  CurrentIGI = pDM_Odm->RSSI_Min;
  if ((pDM_Odm->SupportICType & 8U) == 0U) {
    return;
  } else {

  }
  CurrentIGI = (unsigned int )CurrentIGI + 5U;
  bFwCurrentInPSMode = pAdapter->pwrctrlpriv.bFwCurrentInPSMode;
  if ((unsigned int )bFwCurrentInPSMode != 0U) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): ---Neil---odm_DIG23a is in LPS mode\n", "odm_DIG23abyRSSI_LPS");
    } else {

    }
    if (pFalseAlmCnt->Cnt_all > 30U) {
      CurrentIGI = (unsigned int )CurrentIGI + 2U;
    } else
    if (pFalseAlmCnt->Cnt_all > 15U) {
      CurrentIGI = (unsigned int )CurrentIGI + 1U;
    } else
    if (pFalseAlmCnt->Cnt_all <= 3U) {
      CurrentIGI = (unsigned int )CurrentIGI + 255U;
    } else {

    }
  } else {
    CurrentIGI = RSSI_Lower;
  }
  if ((int )pDM_Odm->RSSI_Min + -10 > 30) {
    RSSI_Lower = (unsigned int )pDM_Odm->RSSI_Min + 246U;
  } else {
    RSSI_Lower = 30U;
  }
  if ((unsigned int )CurrentIGI > 78U) {
    CurrentIGI = 78U;
  } else
  if ((int )CurrentIGI < (int )RSSI_Lower) {
    CurrentIGI = RSSI_Lower;
  } else {

  }
  ODM_Write_DIG23a(pDM_Odm, (int )CurrentIGI);
  return;
}
}
void odm_DIG23aInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct dig_t *pDM_DigTable ;
  u32 val32 ;

  {
  pDM_DigTable = & pDM_Odm->DM_DigTable;
  val32 = rtl8723au_read32(pDM_Odm->Adapter, 3152);
  pDM_DigTable->CurIGValue = (unsigned int )((u8 )val32) & 127U;
  pDM_DigTable->RssiLowThresh = 35;
  pDM_DigTable->RssiHighThresh = 40;
  pDM_DigTable->FALowThresh = 400U;
  pDM_DigTable->FAHighThresh = 1000U;
  if ((unsigned int )pDM_Odm->BoardType == 1U) {
    pDM_DigTable->rx_gain_range_max = 78U;
    pDM_DigTable->rx_gain_range_min = 30U;
  } else {
    pDM_DigTable->rx_gain_range_max = 78U;
    pDM_DigTable->rx_gain_range_min = 30U;
  }
  pDM_DigTable->BackoffVal = 10;
  pDM_DigTable->BackoffVal_range_max = 12;
  pDM_DigTable->BackoffVal_range_min = -4;
  pDM_DigTable->PreCCK_CCAThres = 255U;
  pDM_DigTable->CurCCK_CCAThres = 131U;
  pDM_DigTable->ForbiddenIGI = 30U;
  pDM_DigTable->LargeFAHit = 0U;
  pDM_DigTable->Recover_cnt = 0U;
  pDM_DigTable->DIG_Dynamic_MIN_0 = 30U;
  pDM_DigTable->DIG_Dynamic_MIN_1 = 30U;
  pDM_DigTable->bMediaConnect_0 = 0;
  pDM_DigTable->bMediaConnect_1 = 0;
  return;
}
}
void odm_DIG23a(struct rtw_adapter *adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct dig_t *pDM_DigTable ;
  struct false_alarm_stats *pFalseAlmCnt ;
  u8 DIG_Dynamic_MIN ;
  u8 DIG_MaxOfMin ;
  bool FirstConnect ;
  bool FirstDisConnect ;
  u8 dm_dig_max ;
  u8 dm_dig_min ;
  u8 CurrentIGI ;

  {
  pHalData = (struct hal_data_8723a *)adapter->HalData;
  pDM_Odm = & pHalData->odmpriv;
  pDM_DigTable = & pDM_Odm->DM_DigTable;
  pFalseAlmCnt = & pDM_Odm->FalseAlmCnt;
  CurrentIGI = pDM_DigTable->CurIGValue;
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a() ==>\n", "odm_DIG23a");
  } else {

  }
  if ((unsigned int )adapter->mlmepriv.bScanInProcess != 0U) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a() Return: In Scan Progress \n", "odm_DIG23a");
    } else {

    }
    return;
  } else {

  }
  DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
  FirstConnect = (bool )((int )pDM_Odm->bLinked && ! pDM_DigTable->bMediaConnect_0);
  FirstDisConnect = (bool )(! pDM_Odm->bLinked && (int )pDM_DigTable->bMediaConnect_0);
  if ((pDM_Odm->SupportICType & 8U) != 0U && ((unsigned int )pDM_Odm->BoardType == 1U || (unsigned int )pDM_Odm->ExtLNA != 0U)) {
    dm_dig_max = 70U;
    dm_dig_min = 46U;
    DIG_MaxOfMin = 66U;
  } else {
    dm_dig_max = 78U;
    dm_dig_min = 30U;
    DIG_MaxOfMin = 50U;
  }
  if ((int )pDM_Odm->bLinked) {
    if (pDM_Odm->SupportICType == 8U) {
      if ((int )pDM_Odm->RSSI_Min + 10 > 78) {
        pDM_DigTable->rx_gain_range_max = 78U;
      } else
      if ((int )pDM_Odm->RSSI_Min + 10 <= 29) {
        pDM_DigTable->rx_gain_range_max = 30U;
      } else {
        pDM_DigTable->rx_gain_range_max = (unsigned int )pDM_Odm->RSSI_Min + 10U;
      }
      DIG_Dynamic_MIN = 30U;
    } else {
      if ((int )pDM_Odm->RSSI_Min + 20 > (int )dm_dig_max) {
        pDM_DigTable->rx_gain_range_max = dm_dig_max;
      } else
      if ((int )pDM_Odm->RSSI_Min + 20 < (int )dm_dig_min) {
        pDM_DigTable->rx_gain_range_max = dm_dig_min;
      } else {
        pDM_DigTable->rx_gain_range_max = (unsigned int )pDM_Odm->RSSI_Min + 20U;
      }
      if ((int )pDM_Odm->bOneEntryOnly) {
        if ((int )pDM_Odm->RSSI_Min < (int )dm_dig_min) {
          DIG_Dynamic_MIN = dm_dig_min;
        } else
        if ((int )pDM_Odm->RSSI_Min > (int )DIG_MaxOfMin) {
          DIG_Dynamic_MIN = DIG_MaxOfMin;
        } else {
          DIG_Dynamic_MIN = pDM_Odm->RSSI_Min;
        }
        if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): odm_DIG23a() : bOneEntryOnly = true,  DIG_Dynamic_MIN = 0x%x\n",
                 "odm_DIG23a", (int )DIG_Dynamic_MIN);
        } else {

        }
        if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): odm_DIG23a() : pDM_Odm->RSSI_Min =%d\n", "odm_DIG23a", (int )pDM_Odm->RSSI_Min);
        } else {

        }
      } else {
        DIG_Dynamic_MIN = dm_dig_min;
      }
    }
  } else {
    pDM_DigTable->rx_gain_range_max = dm_dig_max;
    DIG_Dynamic_MIN = dm_dig_min;
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a() : No Link\n", "odm_DIG23a");
    } else {

    }
  }
  if (pFalseAlmCnt->Cnt_all > 10000U) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): dm_DIG(): Abnornally false alarm case. \n", "odm_DIG23a");
    } else {

    }
    if ((unsigned int )pDM_DigTable->LargeFAHit != 3U) {
      pDM_DigTable->LargeFAHit = (u8 )((int )pDM_DigTable->LargeFAHit + 1);
    } else {

    }
    if ((int )pDM_DigTable->ForbiddenIGI < (int )CurrentIGI) {
      pDM_DigTable->ForbiddenIGI = CurrentIGI;
      pDM_DigTable->LargeFAHit = 1U;
    } else {

    }
    if ((unsigned int )pDM_DigTable->LargeFAHit > 2U) {
      if ((int )pDM_DigTable->ForbiddenIGI + 1 > (int )pDM_DigTable->rx_gain_range_max) {
        pDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
      } else {
        pDM_DigTable->rx_gain_range_min = (unsigned int )pDM_DigTable->ForbiddenIGI + 1U;
      }
      pDM_DigTable->Recover_cnt = 3600U;
    } else {

    }
  } else
  if (pDM_DigTable->Recover_cnt != 0U) {
    pDM_DigTable->Recover_cnt = pDM_DigTable->Recover_cnt - 1U;
  } else
  if ((unsigned int )pDM_DigTable->LargeFAHit <= 2U) {
    if ((int )pDM_DigTable->ForbiddenIGI + -1 < (int )DIG_Dynamic_MIN) {
      pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;
      pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): odm_DIG23a(): Normal Case: At Lower Bound\n", "odm_DIG23a");
      } else {

      }
    } else {
      pDM_DigTable->ForbiddenIGI = (u8 )((int )pDM_DigTable->ForbiddenIGI - 1);
      pDM_DigTable->rx_gain_range_min = (unsigned int )pDM_DigTable->ForbiddenIGI + 1U;
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): odm_DIG23a(): Normal Case: Approach Lower Bound\n", "odm_DIG23a");
      } else {

      }
    }
  } else {
    pDM_DigTable->LargeFAHit = 0U;
  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): pDM_DigTable->LargeFAHit =%d\n", "odm_DIG23a", (int )pDM_DigTable->LargeFAHit);
  } else {

  }
  if ((int )pDM_Odm->bLinked) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a(): DIG AfterLink\n", "odm_DIG23a");
    } else {

    }
    if ((int )FirstConnect) {
      CurrentIGI = pDM_Odm->RSSI_Min;
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): DIG: First Connect\n", "odm_DIG23a");
      } else {

      }
    } else
    if (pFalseAlmCnt->Cnt_all > 1024U) {
      CurrentIGI = (unsigned int )CurrentIGI + 4U;
    } else
    if (pFalseAlmCnt->Cnt_all > 768U) {
      CurrentIGI = (unsigned int )CurrentIGI + 2U;
    } else
    if (pFalseAlmCnt->Cnt_all <= 511U) {
      CurrentIGI = (unsigned int )CurrentIGI + 254U;
    } else {

    }
  } else {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a(): DIG BeforeLink\n", "odm_DIG23a");
    } else {

    }
    if ((int )FirstDisConnect) {
      CurrentIGI = pDM_DigTable->rx_gain_range_min;
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): odm_DIG23a(): First DisConnect \n", "odm_DIG23a");
      } else {

      }
    } else {
      if (pFalseAlmCnt->Cnt_all > 10000U) {
        CurrentIGI = (unsigned int )CurrentIGI + 2U;
      } else
      if (pFalseAlmCnt->Cnt_all > 8000U) {
        CurrentIGI = (unsigned int )CurrentIGI + 1U;
      } else
      if (pFalseAlmCnt->Cnt_all <= 499U) {
        CurrentIGI = (unsigned int )CurrentIGI + 255U;
      } else {

      }
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): odm_DIG23a(): England DIG \n", "odm_DIG23a");
      } else {

      }
    }
  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): DIG End Adjust IGI\n", "odm_DIG23a");
  } else {

  }
  if ((int )pDM_DigTable->rx_gain_range_max < (int )CurrentIGI) {
    CurrentIGI = pDM_DigTable->rx_gain_range_max;
  } else {

  }
  if ((int )pDM_DigTable->rx_gain_range_min > (int )CurrentIGI) {
    CurrentIGI = pDM_DigTable->rx_gain_range_min;
  } else {

  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): rx_gain_range_max = 0x%x, rx_gain_range_min = 0x%x\n",
           "odm_DIG23a", (int )pDM_DigTable->rx_gain_range_max, (int )pDM_DigTable->rx_gain_range_min);
  } else {

  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): TotalFA =%d\n", "odm_DIG23a", pFalseAlmCnt->Cnt_all);
  } else {

  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): CurIGValue = 0x%x\n", "odm_DIG23a", (int )CurrentIGI);
  } else {

  }
  ODM_Write_DIG23a(pDM_Odm, (int )CurrentIGI);
  pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
  pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
  return;
}
}
void odm_FalseAlarmCounterStatistics23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *adapter ;
  struct false_alarm_stats *FalseAlmCnt ;
  u32 ret_value ;
  u32 val32 ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  adapter = pDM_Odm->Adapter;
  FalseAlmCnt = & pDM_Odm->FalseAlmCnt;
  val32 = rtl8723au_read32(adapter, 3072);
  val32 = val32 | 2147483648U;
  rtl8723au_write32(adapter, 3072, val32);
  val32 = rtl8723au_read32(adapter, 3328);
  val32 = val32 | 2147483648U;
  rtl8723au_write32(adapter, 3328, val32);
  ret_value = rtl8723au_read32(adapter, 3312);
  FalseAlmCnt->Cnt_Fast_Fsync = ret_value & 65535U;
  FalseAlmCnt->Cnt_SB_Search_fail = ret_value >> 16;
  ret_value = rtl8723au_read32(adapter, 3488);
  FalseAlmCnt->Cnt_OFDM_CCA = ret_value & 65535U;
  FalseAlmCnt->Cnt_Parity_Fail = ret_value >> 16;
  ret_value = rtl8723au_read32(adapter, 3492);
  FalseAlmCnt->Cnt_Rate_Illegal = ret_value & 65535U;
  FalseAlmCnt->Cnt_Crc8_fail = ret_value >> 16;
  ret_value = rtl8723au_read32(adapter, 3496);
  FalseAlmCnt->Cnt_Mcs_fail = ret_value & 65535U;
  FalseAlmCnt->Cnt_Ofdm_fail = ((((FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal) + FalseAlmCnt->Cnt_Crc8_fail) + FalseAlmCnt->Cnt_Mcs_fail) + FalseAlmCnt->Cnt_Fast_Fsync) + FalseAlmCnt->Cnt_SB_Search_fail;
  val32 = rtl8723au_read32(adapter, 2604);
  val32 = val32 | 20480U;
  rtl8723au_write32(adapter, 2604, val32);
  tmp = rtl8723au_read32(adapter, 2652);
  ret_value = tmp & 255U;
  FalseAlmCnt->Cnt_Cck_fail = ret_value;
  tmp___0 = rtl8723au_read32(adapter, 2648);
  ret_value = tmp___0 >> 16;
  FalseAlmCnt->Cnt_Cck_fail = FalseAlmCnt->Cnt_Cck_fail + (ret_value & 65280U);
  ret_value = rtl8723au_read32(adapter, 2656);
  FalseAlmCnt->Cnt_CCK_CCA = ((ret_value << 8) & 65535U) | ((ret_value & 65280U) >> 8);
  FalseAlmCnt->Cnt_all = (((((FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail) + FalseAlmCnt->Cnt_Parity_Fail) + FalseAlmCnt->Cnt_Rate_Illegal) + FalseAlmCnt->Cnt_Crc8_fail) + FalseAlmCnt->Cnt_Mcs_fail) + FalseAlmCnt->Cnt_Cck_fail;
  FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;
  if (pDM_Odm->SupportICType > 7U) {
    val32 = rtl8723au_read32(adapter, 3084);
    val32 = val32 | 2147483648U;
    rtl8723au_write32(adapter, 3084, val32);
    val32 = rtl8723au_read32(adapter, 3084);
    val32 = val32 & 2147483647U;
    rtl8723au_write32(adapter, 3084, val32);
    val32 = rtl8723au_read32(adapter, 3328);
    val32 = val32 | 134217728U;
    rtl8723au_write32(adapter, 3328, val32);
    val32 = rtl8723au_read32(adapter, 3328);
    val32 = val32 & 4160749567U;
    rtl8723au_write32(adapter, 3328, val32);
    val32 = rtl8723au_read32(adapter, 3072);
    val32 = val32 & 2147483647U;
    rtl8723au_write32(adapter, 3072, val32);
    val32 = rtl8723au_read32(adapter, 3328);
    val32 = val32 & 2147483647U;
    rtl8723au_write32(adapter, 3328, val32);
    val32 = rtl8723au_read32(adapter, 2604);
    val32 = val32 & 4294905855U;
    rtl8723au_write32(adapter, 2604, val32);
    val32 = rtl8723au_read32(adapter, 2604);
    val32 = val32 | 40960U;
    rtl8723au_write32(adapter, 2604, val32);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Enter odm_FalseAlarmCounterStatistics23a\n", "odm_FalseAlarmCounterStatistics23a");
  } else {

  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Cnt_Fast_Fsync =%d, Cnt_SB_Search_fail =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Cnt_Parity_Fail =%d, Cnt_Rate_Illegal =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Cnt_Crc8_fail =%d, Cnt_Mcs_fail =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Cnt_Cck_fail =%d\n", "odm_FalseAlarmCounterStatistics23a", FalseAlmCnt->Cnt_Cck_fail);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Cnt_Ofdm_fail =%d\n", "odm_FalseAlarmCounterStatistics23a", FalseAlmCnt->Cnt_Ofdm_fail);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Total False Alarm =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_all);
  } else {

  }
  return;
}
}
void odm_CCKPacketDetectionThresh23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct false_alarm_stats *FalseAlmCnt ;
  u8 CurCCK_CCAThres ;

  {
  FalseAlmCnt = & pDM_Odm->FalseAlmCnt;
  if ((unsigned int )pDM_Odm->ExtLNA != 0U) {
    return;
  } else {

  }
  if ((int )pDM_Odm->bLinked) {
    if ((unsigned int )pDM_Odm->RSSI_Min > 25U) {
      CurCCK_CCAThres = 205U;
    } else
    if ((unsigned int )pDM_Odm->RSSI_Min <= 25U && (unsigned int )pDM_Odm->RSSI_Min > 10U) {
      CurCCK_CCAThres = 131U;
    } else
    if (FalseAlmCnt->Cnt_Cck_fail > 1000U) {
      CurCCK_CCAThres = 131U;
    } else {
      CurCCK_CCAThres = 64U;
    }
  } else
  if (FalseAlmCnt->Cnt_Cck_fail > 1000U) {
    CurCCK_CCAThres = 131U;
  } else {
    CurCCK_CCAThres = 64U;
  }
  ODM_Write_CCK_CCA_Thres23a(pDM_Odm, (int )CurCCK_CCAThres);
  return;
}
}
void ODM_Write_CCK_CCA_Thres23a(struct dm_odm_t *pDM_Odm , u8 CurCCK_CCAThres ) 
{ 
  struct dig_t *pDM_DigTable ;

  {
  pDM_DigTable = & pDM_Odm->DM_DigTable;
  if ((int )pDM_DigTable->CurCCK_CCAThres != (int )CurCCK_CCAThres) {
    rtl8723au_write8(pDM_Odm->Adapter, 2570, (int )CurCCK_CCAThres);
  } else {

  }
  pDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;
  pDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;
  return;
}
}
void odm23a_DynBBPSInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct dynamic_pwr_sav *pDM_PSTable ;

  {
  pDM_PSTable = & pDM_Odm->DM_PSTable;
  pDM_PSTable->PreCCAState = 2U;
  pDM_PSTable->CurCCAState = 2U;
  pDM_PSTable->PreRFState = 2U;
  pDM_PSTable->CurRFState = 2U;
  pDM_PSTable->Rssi_val_min = 0;
  pDM_PSTable->initialize = 0U;
  return;
}
}
void odm_DynamicBBPowerSaving23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
  return;
}
}
void ODM_RF_Saving23a(struct dm_odm_t *pDM_Odm , u8 bForceInNormal ) 
{ 
  struct dynamic_pwr_sav *pDM_PSTable ;
  struct rtw_adapter *adapter ;
  u32 val32 ;
  u8 Rssi_Up_bound ;
  u8 Rssi_Low_bound ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
  pDM_PSTable = & pDM_Odm->DM_PSTable;
  adapter = pDM_Odm->Adapter;
  Rssi_Up_bound = 30U;
  Rssi_Low_bound = 25U;
  if ((unsigned int )pDM_PSTable->initialize == 0U) {
    tmp = rtl8723au_read32(adapter, 2164);
    pDM_PSTable->Reg874 = tmp & 1884160U;
    tmp___0 = rtl8723au_read32(adapter, 3184);
    pDM_PSTable->RegC70 = tmp___0 & 8U;
    tmp___1 = rtl8723au_read32(adapter, 2140);
    pDM_PSTable->Reg85C = tmp___1 & 4278190080U;
    tmp___2 = rtl8723au_read32(adapter, 2676);
    pDM_PSTable->RegA74 = tmp___2 & 61440U;
    pDM_PSTable->initialize = 1U;
  } else {

  }
  if ((unsigned int )bForceInNormal == 0U) {
    if ((unsigned int )pDM_Odm->RSSI_Min != 255U) {
      if ((unsigned int )pDM_PSTable->PreRFState == 1U) {
        if ((int )pDM_Odm->RSSI_Min >= (int )Rssi_Up_bound) {
          pDM_PSTable->CurRFState = 0U;
        } else {
          pDM_PSTable->CurRFState = 1U;
        }
      } else
      if ((int )pDM_Odm->RSSI_Min <= (int )Rssi_Low_bound) {
        pDM_PSTable->CurRFState = 1U;
      } else {
        pDM_PSTable->CurRFState = 0U;
      }
    } else {
      pDM_PSTable->CurRFState = 2U;
    }
  } else {
    pDM_PSTable->CurRFState = 1U;
  }
  if ((int )pDM_PSTable->PreRFState != (int )pDM_PSTable->CurRFState) {
    if ((unsigned int )pDM_PSTable->CurRFState == 0U) {
      if (pDM_Odm->SupportICType == 8U) {
        val32 = rtl8723au_read32(adapter, 2164);
        val32 = val32 | 32U;
        rtl8723au_write32(adapter, 2164, val32);
      } else {

      }
      val32 = rtl8723au_read32(adapter, 2164);
      val32 = val32 & 4293656575U;
      val32 = val32 | 524288U;
      rtl8723au_write32(adapter, 2164, val32);
      val32 = rtl8723au_read32(adapter, 3184);
      val32 = val32 & 4294967287U;
      rtl8723au_write32(adapter, 3184, val32);
      val32 = rtl8723au_read32(adapter, 2140);
      val32 = val32 & 16777215U;
      val32 = val32 | 1660944384U;
      rtl8723au_write32(adapter, 2140, val32);
      val32 = rtl8723au_read32(adapter, 2164);
      val32 = val32 & 4294950911U;
      val32 = val32 | 32768U;
      rtl8723au_write32(adapter, 2164, val32);
      val32 = rtl8723au_read32(adapter, 2676);
      val32 = val32 & 4294918143U;
      val32 = val32 | 12288U;
      rtl8723au_write32(adapter, 2676, val32);
      val32 = rtl8723au_read32(adapter, 2072);
      val32 = val32 & 4026531839U;
      rtl8723au_write32(adapter, 2072, val32);
      val32 = rtl8723au_read32(adapter, 2072);
      val32 = val32 | 268435456U;
      rtl8723au_write32(adapter, 2072, val32);
    } else {
      val32 = rtl8723au_read32(adapter, 2164);
      val32 = pDM_PSTable->Reg874 | val32;
      rtl8723au_write32(adapter, 2164, val32);
      val32 = rtl8723au_read32(adapter, 3184);
      val32 = pDM_PSTable->RegC70 | val32;
      rtl8723au_write32(adapter, 3184, val32);
      val32 = rtl8723au_read32(adapter, 2140);
      val32 = pDM_PSTable->Reg85C | val32;
      rtl8723au_write32(adapter, 2140, val32);
      val32 = rtl8723au_read32(adapter, 2676);
      val32 = pDM_PSTable->RegA74 | val32;
      rtl8723au_write32(adapter, 2676, val32);
      val32 = rtl8723au_read32(adapter, 2072);
      val32 = val32 & 4026531839U;
      rtl8723au_write32(adapter, 2072, val32);
      if (pDM_Odm->SupportICType == 8U) {
        val32 = rtl8723au_read32(adapter, 2164);
        val32 = val32 & 4294967263U;
        rtl8723au_write32(adapter, 2164, val32);
      } else {

      }
    }
    pDM_PSTable->PreRFState = pDM_PSTable->CurRFState;
  } else {

  }
  return;
}
}
void odm_RateAdaptiveMaskInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct odm_rate_adapt *pOdmRA ;

  {
  pOdmRA = & pDM_Odm->RateAdaptive;
  pOdmRA->Type = 1U;
  pOdmRA->RATRState = 0U;
  pOdmRA->HighRSSIThresh = 50U;
  pOdmRA->LowRSSIThresh = 20U;
  return;
}
}
u32 ODM_Get_Rate_Bitmap23a(struct hal_data_8723a *pHalData , u32 macid , u32 ra_mask ,
                           u8 rssi_level ) 
{ 
  struct dm_odm_t *pDM_Odm ;
  struct sta_info *pEntry ;
  u32 rate_bitmap ;
  u8 WirelessMode ;

  {
  pDM_Odm = & pHalData->odmpriv;
  rate_bitmap = 268435455U;
  pEntry = pDM_Odm->pODM_StaInfo[macid];
  if ((unsigned long )pEntry == (unsigned long )((struct sta_info *)0)) {
    return (ra_mask);
  } else {

  }
  WirelessMode = pEntry->wireless_mode;
  switch ((int )WirelessMode) {
  case 1: ;
  if ((ra_mask & 12U) != 0U) {
    rate_bitmap = 13U;
  } else {
    rate_bitmap = 15U;
  }
  goto ldv_55955;
  case 6: ;
  if ((unsigned int )rssi_level == 1U) {
    rate_bitmap = 3840U;
  } else {
    rate_bitmap = 4080U;
  }
  goto ldv_55955;
  case 3: ;
  if ((unsigned int )rssi_level == 1U) {
    rate_bitmap = 3840U;
  } else
  if ((unsigned int )rssi_level == 2U) {
    rate_bitmap = 4080U;
  } else {
    rate_bitmap = 4085U;
  }
  goto ldv_55955;
  case 11: ;
  case 15: ;
  if ((unsigned int )pHalData->rf_type == 0U || (unsigned int )pHalData->rf_type == 3U) {
    if ((unsigned int )rssi_level == 1U) {
      rate_bitmap = 983040U;
    } else
    if ((unsigned int )rssi_level == 2U) {
      rate_bitmap = 1044480U;
    } else
    if ((unsigned int )pHalData->CurrentChannelBW == 1U) {
      rate_bitmap = 1044501U;
    } else {
      rate_bitmap = 1044485U;
    }
  } else
  if ((unsigned int )rssi_level == 1U) {
    rate_bitmap = 261029888U;
  } else
  if ((unsigned int )rssi_level == 2U) {
    rate_bitmap = 261091328U;
  } else
  if ((unsigned int )pHalData->CurrentChannelBW == 1U) {
    rate_bitmap = 261091349U;
  } else {
    rate_bitmap = 261091333U;
  }
  goto ldv_55955;
  default: ;
  if ((unsigned int )pHalData->rf_type == 0U) {
    rate_bitmap = 1048575U;
  } else {
    rate_bitmap = 268435455U;
  }
  goto ldv_55955;
  }
  ldv_55955: ;
  if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s():  ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",
           "ODM_Get_Rate_Bitmap23a", (int )rssi_level, (int )WirelessMode, rate_bitmap);
  } else {

  }
  return (rate_bitmap);
}
}
static void odm_RefreshRateAdaptiveMask(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *pAdapter ;
  u32 smoothed ;
  u8 i ;
  struct sta_info *pstat ;
  bool tmp ;

  {
  pAdapter = pDM_Odm->Adapter;
  if (pAdapter->bDriverStopped != 0) {
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 4U) {
      printk("[ODM-8723A] ");
      printk("%s(): <---- %s: driver is going to unload\n", "odm_RefreshRateAdaptiveMask",
             "odm_RefreshRateAdaptiveMask");
    } else {

    }
    return;
  } else {

  }
  i = 0U;
  goto ldv_55971;
  ldv_55970: 
  pstat = pDM_Odm->pODM_StaInfo[(int )i];
  if ((unsigned long )pstat != (unsigned long )((struct sta_info *)0)) {
    smoothed = (u32 )pstat->rssi_stat.UndecoratedSmoothedPWDB;
    tmp = ODM_RAStateCheck23a(pDM_Odm, (s32 )smoothed, 0, & pstat->rssi_level);
    if ((int )tmp) {
      if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): RSSI:%d, RSSI_LEVEL:%d\n", "odm_RefreshRateAdaptiveMask", smoothed,
               (int )pstat->rssi_level);
      } else {

      }
      rtw_hal_update_ra_mask23a(pstat, (int )pstat->rssi_level);
    } else {

    }
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_55971: ;
  if ((unsigned int )i <= 31U) {
    goto ldv_55970;
  } else {

  }

  return;
}
}
bool ODM_RAStateCheck23a(struct dm_odm_t *pDM_Odm , s32 RSSI , bool bForceUpdate ,
                         u8 *pRATRState ) 
{ 
  struct odm_rate_adapt *pRA ;
  u8 GoUpGap ;
  u8 HighRSSIThreshForRA ;
  u8 LowRSSIThreshForRA ;
  u8 RATRState ;

  {
  pRA = & pDM_Odm->RateAdaptive;
  GoUpGap = 5U;
  HighRSSIThreshForRA = pRA->HighRSSIThresh;
  LowRSSIThreshForRA = pRA->LowRSSIThresh;
  switch ((int )*pRATRState) {
  case 0: ;
  case 1: ;
  goto ldv_55986;
  case 2: 
  HighRSSIThreshForRA = (int )HighRSSIThreshForRA + (int )GoUpGap;
  goto ldv_55986;
  case 3: 
  HighRSSIThreshForRA = (int )HighRSSIThreshForRA + (int )GoUpGap;
  LowRSSIThreshForRA = (int )LowRSSIThreshForRA + (int )GoUpGap;
  goto ldv_55986;
  default: 
  printk("Assertion failed! %s at ......\n", (char *)"false");
  printk("      ......%s,%s,line=%d\n", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6803/dscv_tempdir/dscv/ri/08_1a/drivers/staging/rtl8723au/hal/odm.c",
         "ODM_RAStateCheck23a", 1189);
  printk("%s(): wrong rssi level setting %d !", "ODM_RAStateCheck23a", (int )*pRATRState);
  goto ldv_55986;
  }
  ldv_55986: ;
  if ((int )HighRSSIThreshForRA < RSSI) {
    RATRState = 1U;
  } else
  if ((int )LowRSSIThreshForRA < RSSI) {
    RATRState = 2U;
  } else {
    RATRState = 3U;
  }
  if ((int )*pRATRState != (int )RATRState || (int )bForceUpdate) {
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): RSSI Level %d -> %d\n", "ODM_RAStateCheck23a", (int )*pRATRState,
             (int )RATRState);
    } else {

    }
    *pRATRState = RATRState;
    return (1);
  } else {

  }
  return (0);
}
}
void odm_DynamicTxPower23aInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
  Adapter = pDM_Odm->Adapter;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pdmpriv->DynamicTxHighPowerLvl = 0U;
  return;
}
}
static void FindMinimumRSSI(struct rtw_adapter *pAdapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;

  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pDM_Odm = & pHalData->odmpriv;
  if (! pDM_Odm->bLinked && pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0) {
    pdmpriv->MinUndecoratedPWDBForDM = 0;
  } else {
    pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
  }
  return;
}
}
static void odm_RSSIMonitorCheck(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  int i ;
  int MaxDB ;
  int MinDB ;
  u8 sta_cnt ;
  u32 tmpdb ;
  u32 PWDB_rssi[32U] ;
  unsigned int tmp ;
  struct sta_info *psta ;
  u8 tmp___0 ;

  {
  Adapter = pDM_Odm->Adapter;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  MaxDB = 0;
  MinDB = 255;
  sta_cnt = 0U;
  PWDB_rssi[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 32U) {
      break;
    } else {

    }
    PWDB_rssi[tmp] = 0U;
    tmp = tmp + 1U;
  }
  if (! pDM_Odm->bLinked) {
    return;
  } else {

  }
  i = 0;
  goto ldv_56017;
  ldv_56016: 
  psta = pDM_Odm->pODM_StaInfo[i];
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    if (psta->rssi_stat.UndecoratedSmoothedPWDB < MinDB) {
      MinDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
    } else {

    }
    if (psta->rssi_stat.UndecoratedSmoothedPWDB > MaxDB) {
      MaxDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
    } else {

    }
    if (psta->rssi_stat.UndecoratedSmoothedPWDB != -1) {
      tmpdb = (u32 )psta->rssi_stat.UndecoratedSmoothedPWDB;
      tmp___0 = sta_cnt;
      sta_cnt = (u8 )((int )sta_cnt + 1);
      PWDB_rssi[(int )tmp___0] = psta->mac_id | (tmpdb << 16);
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_56017: ;
  if (i <= 31) {
    goto ldv_56016;
  } else {

  }
  i = 0;
  goto ldv_56020;
  ldv_56019: ;
  if (PWDB_rssi[i] != 0U) {
    rtl8723a_set_rssi_cmd(Adapter, (u8 *)(& PWDB_rssi) + (unsigned long )i);
  } else {

  }
  i = i + 1;
  ldv_56020: ;
  if ((int )sta_cnt > i) {
    goto ldv_56019;
  } else {

  }
  pdmpriv->EntryMaxUndecoratedSmoothedPWDB = MaxDB;
  if (MinDB != 255) {
    pdmpriv->EntryMinUndecoratedSmoothedPWDB = MinDB;
  } else {
    pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
  }
  FindMinimumRSSI(Adapter);
  ODM_CmnInfoUpdate23a(& pHalData->odmpriv, 17U, (u64 )pdmpriv->MinUndecoratedPWDBForDM);
  return;
}
}
static void odm_TXPowerTrackingInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
  Adapter = pDM_Odm->Adapter;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pdmpriv->bTXPowerTracking = 1U;
  pdmpriv->TXPowercount = 0U;
  pdmpriv->bTXPowerTrackingInit = 0U;
  pdmpriv->TxPowerTrackControl = 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: pdmpriv->TxPowerTrackControl = %d\n", (int )pdmpriv->TxPowerTrackControl);
  } else {

  }
  pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = 1U;
  return;
}
}
static void ODM_EdcaTurboInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
  Adapter = pDM_Odm->Adapter;
  pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 0;
  Adapter->recvpriv.bIsAnyNonBEPkts = 0U;
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    tmp = rtl8723au_read32(Adapter, 1280);
    printk("%s(): Orginial VO PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    tmp___0 = rtl8723au_read32(Adapter, 1284);
    printk("%s(): Orginial VI PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___0);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    tmp___1 = rtl8723au_read32(Adapter, 1288);
    printk("%s(): Orginial BE PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___1);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    tmp___2 = rtl8723au_read32(Adapter, 1292);
    printk("%s(): Orginial BK PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___2);
  } else {

  }
  return;
}
}
static void odm_EdcaTurboCheck23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct xmit_priv *pxmitpriv ;
  struct recv_priv *precvpriv ;
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 trafficIndex ;
  u32 edca_param ;
  u64 cur_tx_bytes ;
  u64 cur_rx_bytes ;
  bool tmp ;

  {
  Adapter = pDM_Odm->Adapter;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pxmitpriv = & Adapter->xmitpriv;
  precvpriv = & Adapter->recvpriv;
  pregpriv = & Adapter->registrypriv;
  pmlmeext = & Adapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor > 16U) {
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
  tmp = rtl8723a_BT_disable_EDCA_turbo(Adapter);
  if ((int )tmp) {
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
  if (precvpriv->bIsAnyNonBEPkts == 0U) {
    cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
    cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
    if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 4U || (unsigned int )pmlmeinfo->assoc_AP_vendor == 5U) {
      if (cur_rx_bytes << 2 < cur_tx_bytes) {
        trafficIndex = 0U;
      } else {
        trafficIndex = 1U;
      }
    } else
    if (cur_tx_bytes << 2 < cur_rx_bytes) {
      trafficIndex = 1U;
    } else {
      trafficIndex = 0U;
    }
    if (pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex || ! pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 6U && ((int )pmlmeext->cur_wireless_mode & 8) != 0) {
        edca_param = EDCAParam[(int )pmlmeinfo->assoc_AP_vendor][trafficIndex];
      } else {
        edca_param = EDCAParam[0][trafficIndex];
      }
      rtl8723au_write32(Adapter, 1288, edca_param);
      pDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;
    } else {

    }
    pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 1;
  } else
  if ((int )pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {
    rtl8723au_write32(Adapter, 1288, pHalData->AcParam_BE);
    pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 0;
  } else {

  }
  dm_CheckEdcaTurbo_EXIT: 
  precvpriv->bIsAnyNonBEPkts = 0U;
  pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
  precvpriv->last_rx_bytes = precvpriv->rx_bytes;
  return;
}
}
u32 GetPSDData(struct dm_odm_t *pDM_Odm , unsigned int point , u8 initial_gain_psd ) 
{ 
  struct rtw_adapter *adapter ;
  u32 psd_report ;
  u32 val32 ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  adapter = pDM_Odm->Adapter;
  val32 = rtl8723au_read32(adapter, 2056);
  val32 = val32 & 4294966272U;
  val32 = (point & 1023U) | val32;
  rtl8723au_write32(adapter, 2056, val32);
  val32 = rtl8723au_read32(adapter, 2056);
  val32 = val32 | 4194304U;
  rtl8723au_write32(adapter, 2056, val32);
  __const_udelay(128850UL);
  val32 = rtl8723au_read32(adapter, 2056);
  val32 = val32 & 4290772991U;
  rtl8723au_write32(adapter, 2056, val32);
  tmp = rtl8723au_read32(adapter, 2228);
  psd_report = tmp & 65535U;
  tmp___0 = ConvertTo_dB23a(psd_report);
  psd_report = (tmp___0 + (u32 )initial_gain_psd) + 4294967268U;
  return (psd_report);
}
}
u32 ConvertTo_dB23a(u32 Value ) 
{ 
  u8 i ;
  u8 j ;
  u32 dB ;

  {
  Value = Value & 65535U;
  i = 0U;
  goto ldv_56064;
  ldv_56063: ;
  if ((u32 )dB_Invert_Table[(int )i][11] >= Value) {
    goto ldv_56062;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56064: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_56063;
  } else {

  }
  ldv_56062: ;
  if ((unsigned int )i > 7U) {
    return (96U);
  } else {

  }
  j = 0U;
  goto ldv_56067;
  ldv_56066: ;
  if ((u32 )dB_Invert_Table[(int )i][(int )j] >= Value) {
    goto ldv_56065;
  } else {

  }
  j = (u8 )((int )j + 1);
  ldv_56067: ;
  if ((unsigned int )j <= 11U) {
    goto ldv_56066;
  } else {

  }
  ldv_56065: 
  dB = (u32 )(((int )i * 12 + (int )j) + 1);
  return (dB);
}
}
void ODM_SingleDualAntennaDefaultSetting(struct dm_odm_t *pDM_Odm ) 
{ 
  struct sw_ant_sw *pDM_SWAT_Table ;

  {
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
  pDM_SWAT_Table->ANTA_ON = 1;
  pDM_SWAT_Table->ANTB_ON = 1;
  return;
}
}
static void odm_PHY_SaveAFERegisters(struct dm_odm_t *pDM_Odm , u32 *AFEReg , u32 *AFEBackup ,
                                     u32 RegisterNum ) 
{ 
  u32 i ;

  {
  i = 0U;
  goto ldv_56080;
  ldv_56079: 
  *(AFEBackup + (unsigned long )i) = rtl8723au_read32(pDM_Odm->Adapter, (int )((u16 )*(AFEReg + (unsigned long )i)));
  i = i + 1U;
  ldv_56080: ;
  if (i < RegisterNum) {
    goto ldv_56079;
  } else {

  }

  return;
}
}
static void odm_PHY_ReloadAFERegisters(struct dm_odm_t *pDM_Odm , u32 *AFEReg , u32 *AFEBackup ,
                                       u32 RegiesterNum ) 
{ 
  u32 i ;

  {
  i = 0U;
  goto ldv_56090;
  ldv_56089: 
  rtl8723au_write32(pDM_Odm->Adapter, (int )((u16 )*(AFEReg + (unsigned long )i)),
                    *(AFEBackup + (unsigned long )i));
  i = i + 1U;
  ldv_56090: ;
  if (i < RegiesterNum) {
    goto ldv_56089;
  } else {

  }

  return;
}
}
bool ODM_SingleDualAntennaDetection(struct dm_odm_t *pDM_Odm , u8 mode ) 
{ 
  struct sw_ant_sw *pDM_SWAT_Table ;
  struct rtw_adapter *adapter ;
  u32 CurrentChannel ;
  u32 RfLoopReg ;
  u8 n ;
  u32 Reg88c ;
  u32 Regc08 ;
  u32 Reg874 ;
  u32 Regc50 ;
  u32 val32 ;
  u8 initial_gain ;
  u32 PSD_report_tmp ;
  u32 AntA_report ;
  u32 AntB_report ;
  u32 AntO_report ;
  bool bResult ;
  u32 AFE_Backup[16U] ;
  u32 AFE_REG_8723A[16U] ;

  {
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
  adapter = pDM_Odm->Adapter;
  initial_gain = 90U;
  AntA_report = 0U;
  AntB_report = 0U;
  AntO_report = 0U;
  bResult = 1;
  AFE_REG_8723A[0] = 3696U;
  AFE_REG_8723A[1] = 3700U;
  AFE_REG_8723A[2] = 3704U;
  AFE_REG_8723A[3] = 3708U;
  AFE_REG_8723A[4] = 3712U;
  AFE_REG_8723A[5] = 3716U;
  AFE_REG_8723A[6] = 3720U;
  AFE_REG_8723A[7] = 3724U;
  AFE_REG_8723A[8] = 3792U;
  AFE_REG_8723A[9] = 3796U;
  AFE_REG_8723A[10] = 3800U;
  AFE_REG_8723A[11] = 3804U;
  AFE_REG_8723A[12] = 3808U;
  AFE_REG_8723A[13] = 3820U;
  AFE_REG_8723A[14] = 2140U;
  AFE_REG_8723A[15] = 3692U;
  if ((pDM_Odm->SupportICType & 8U) == 0U) {
    return (bResult);
  } else {

  }
  if ((pDM_Odm->SupportAbility & 64U) == 0U) {
    return (bResult);
  } else {

  }
  CurrentChannel = ODM_GetRFReg(pDM_Odm, 0, 24U, 1048575U);
  RfLoopReg = ODM_GetRFReg(pDM_Odm, 0, 0U, 1048575U);
  val32 = rtl8723au_read32(adapter, 2144);
  val32 = val32 & 4294966527U;
  val32 = val32 | 256U;
  rtl8723au_write32(adapter, 2144, val32);
  __const_udelay(42950UL);
  Reg88c = rtl8723au_read32(adapter, 2188);
  Regc08 = rtl8723au_read32(adapter, 3080);
  Reg874 = rtl8723au_read32(adapter, 2164);
  Regc50 = rtl8723au_read32(adapter, 3152);
  odm_PHY_SaveAFERegisters(pDM_Odm, (u32 *)(& AFE_REG_8723A), (u32 *)(& AFE_Backup),
                           16U);
  val32 = rtl8723au_read32(adapter, 2056);
  val32 = val32 & 4294918143U;
  rtl8723au_write32(adapter, 2056, val32);
  ODM_SetRFReg(pDM_Odm, 0, 24U, 1048575U, 1U);
  rtl8723au_write32(adapter, 3696, 1876632996U);
  rtl8723au_write32(adapter, 3700, 1876632996U);
  rtl8723au_write32(adapter, 3704, 1876632996U);
  rtl8723au_write32(adapter, 3708, 1876632996U);
  rtl8723au_write32(adapter, 3712, 1876632996U);
  rtl8723au_write32(adapter, 3716, 1876632996U);
  rtl8723au_write32(adapter, 3720, 1876632996U);
  rtl8723au_write32(adapter, 3724, 1876632996U);
  rtl8723au_write32(adapter, 3792, 1876632996U);
  rtl8723au_write32(adapter, 3796, 1876632996U);
  rtl8723au_write32(adapter, 3800, 1876632996U);
  rtl8723au_write32(adapter, 3804, 1876632996U);
  rtl8723au_write32(adapter, 3808, 1876632996U);
  rtl8723au_write32(adapter, 3820, 1876632996U);
  rtl8723au_write32(adapter, 2140, 1876632996U);
  rtl8723au_write32(adapter, 3692, 1876632996U);
  rtl8723au_write32(adapter, 2188, 3438280896U);
  rtl8723au_write32(adapter, 3080, 524516U);
  rtl8723au_write32(adapter, 2164, 572555264U);
  rtl8723au_write32(adapter, 3632, 268471324U);
  rtl8723au_write32(adapter, 3648, 16808960U);
  rtl8723au_write32(adapter, 2920, 524288U);
  rtl8723au_write32(adapter, 2920, 257949696U);
  rtl8723au_write32(adapter, 3652, 16795648U);
  rtl8723au_write32(adapter, 3636, 268471327U);
  rtl8723au_write32(adapter, 3640, 2182414344U);
  rtl8723au_write32(adapter, 3644, 672464904U);
  rtl8723au_write32(adapter, 3660, 1059024U);
  ODM_SetRFReg(pDM_Odm, 0, 0U, 1048575U, 327688U);
  rtl8723au_write32(adapter, 3624, 2155872256U);
  rtl8723au_write32(adapter, 3656, 4160749568U);
  __const_udelay(4295000UL);
  PSD_report_tmp = 0U;
  n = 0U;
  goto ldv_56115;
  ldv_56114: 
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
  if (PSD_report_tmp > AntA_report) {
    AntA_report = PSD_report_tmp;
  } else {

  }
  n = (u8 )((int )n + 1);
  ldv_56115: ;
  if ((unsigned int )n <= 1U) {
    goto ldv_56114;
  } else {

  }
  PSD_report_tmp = 0U;
  val32 = rtl8723au_read32(adapter, 2144);
  val32 = val32 & 4294966527U;
  val32 = val32 | 512U;
  rtl8723au_write32(adapter, 2144, val32);
  __const_udelay(42950UL);
  n = 0U;
  goto ldv_56118;
  ldv_56117: 
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
  if (PSD_report_tmp > AntB_report) {
    AntB_report = PSD_report_tmp;
  } else {

  }
  n = (u8 )((int )n + 1);
  ldv_56118: ;
  if ((unsigned int )n <= 1U) {
    goto ldv_56117;
  } else {

  }
  val32 = rtl8723au_read32(adapter, 2144);
  val32 = val32 & 4294966527U;
  rtl8723au_write32(adapter, 2144, val32);
  __const_udelay(42950UL);
  n = 0U;
  goto ldv_56121;
  ldv_56120: 
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
  if (PSD_report_tmp > AntO_report) {
    AntO_report = PSD_report_tmp;
  } else {

  }
  n = (u8 )((int )n + 1);
  ldv_56121: ;
  if ((unsigned int )n <= 1U) {
    goto ldv_56120;
  } else {

  }
  rtl8723au_write32(adapter, 3624, 0U);
  PSD_report_tmp = 0U;
  val32 = rtl8723au_read32(adapter, 2144);
  val32 = val32 & 4294966527U;
  val32 = val32 | 256U;
  rtl8723au_write32(adapter, 2144, val32);
  rtl8723au_write32(adapter, 2188, Reg88c);
  rtl8723au_write32(adapter, 3080, Regc08);
  rtl8723au_write32(adapter, 2164, Reg874);
  val32 = rtl8723au_read32(adapter, 3152);
  val32 = val32 & 4294967168U;
  val32 = val32 | 64U;
  rtl8723au_write32(adapter, 3152, val32);
  rtl8723au_write32(adapter, 3152, Regc50);
  ODM_SetRFReg(pDM_Odm, 0, 24U, 1048575U, CurrentChannel);
  ODM_SetRFReg(pDM_Odm, 0, 0U, 1048575U, RfLoopReg);
  odm_PHY_ReloadAFERegisters(pDM_Odm, (u32 *)(& AFE_REG_8723A), (u32 *)(& AFE_Backup),
                             16U);
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): psd_report_A[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntA_report);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): psd_report_B[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntB_report);
  } else {

  }
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): psd_report_O[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntO_report);
  } else {

  }
  if ((unsigned int )mode == 2U) {
    if (AntA_report > 99U) {
      if (AntA_report + 1U < AntB_report) {
        pDM_SWAT_Table->ANTB_ON = 0;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): ODM_SingleDualAntennaDetection(): Single Antenna A\n", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
        pDM_SWAT_Table->ANTB_ON = 1;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n",
                 "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
    } else {
      if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): ODM_SingleDualAntennaDetection(): Need to check again\n", "ODM_SingleDualAntennaDetection");
      } else {

      }
      pDM_SWAT_Table->ANTB_ON = 0;
      bResult = 0;
    }
  } else
  if ((unsigned int )mode == 0U) {
    if (AntO_report > 99U && AntO_report <= 117U) {
      if (AntO_report + 1U < AntA_report) {
        pDM_SWAT_Table->ANTA_ON = 0;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): Ant A is OFF", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
        pDM_SWAT_Table->ANTA_ON = 1;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): Ant A is ON", "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
      if (AntO_report + 2U < AntB_report) {
        pDM_SWAT_Table->ANTB_ON = 0;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): Ant B is OFF", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
        pDM_SWAT_Table->ANTB_ON = 1;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): Ant B is ON", "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
    } else {

    }
  } else {
    if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): ODM_SingleDualAntennaDetection(): Need to check again\n", "ODM_SingleDualAntennaDetection");
    } else {

    }
    pDM_SWAT_Table->ANTA_ON = 1;
    pDM_SWAT_Table->ANTB_ON = 0;
    bResult = 0;
  }
  return (bResult);
}
}
bool ldv_queue_work_on_453(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_454(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_455(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_456(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_457(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_467(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_469(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_468(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_471(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_470(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static void put_unaligned_le64(u64 val , void *p ) 
{ 


  {
  *((__le64 *)p) = val;
  return;
}
}
void rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter , u8 *pDesc , u32 BufferLen ,
                               u8 IsPsPoll , u8 IsBTQosNull ) ;
void rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter ) ;
int rtl8723a_set_raid_cmd(struct rtw_adapter *padapter , u32 mask , u8 arg ) ;
void rtl8723a_add_rateatid(struct rtw_adapter *pAdapter , u32 bitmap , u8 arg , u8 rssi_level ) ;
int FillH2CCmd(struct rtw_adapter *padapter , u8 ElementID , u32 CmdLen , u8 *pCmdBuffer ) ;
static u8 _is_fw_read_cmd_down(struct rtw_adapter *padapter , u8 msgbox_num ) 
{ 
  u8 read_down ;
  int retry_cnts ;
  u8 valid ;
  u8 tmp ;
  int tmp___0 ;

  {
  read_down = 0U;
  retry_cnts = 100;
  ldv_55774: 
  tmp = rtl8723au_read8(padapter, 460);
  valid = (int )tmp & (int )((u8 )(1UL << (int )msgbox_num));
  if ((unsigned int )valid == 0U) {
    read_down = 1U;
  } else {

  }
  if ((unsigned int )read_down == 0U) {
    tmp___0 = retry_cnts;
    retry_cnts = retry_cnts - 1;
    if (tmp___0 != 0) {
      goto ldv_55774;
    } else {
      goto ldv_55775;
    }
  } else {

  }
  ldv_55775: ;
  return (read_down);
}
}
int FillH2CCmd(struct rtw_adapter *padapter , u8 ElementID , u32 CmdLen , u8 *pCmdBuffer ) 
{ 
  u8 bcmd_down ;
  s32 retry_cnts ;
  u8 h2c_box_num ;
  u32 msgbox_addr ;
  u32 msgbox_ex_addr ;
  struct hal_data_8723a *pHalData ;
  u32 h2c_cmd ;
  u16 h2c_cmd_ex ;
  int ret ;
  u8 tmp ;
  s32 tmp___0 ;

  {
  bcmd_down = 0U;
  retry_cnts = 100;
  h2c_cmd = 0U;
  h2c_cmd_ex = 0U;
  ret = 0;
  padapter = (padapter->dvobj)->if1;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  mutex_lock_nested(& (padapter->dvobj)->h2c_fwcmd_mutex, 0U);
  if ((unsigned long )pCmdBuffer == (unsigned long )((u8 *)0U)) {
    goto exit;
  } else {

  }
  if (CmdLen > 5U) {
    goto exit;
  } else {

  }
  if (padapter->bSurpriseRemoved == 1) {
    goto exit;
  } else {

  }
  ldv_55792: 
  h2c_box_num = pHalData->LastHMEBoxNum;
  tmp = _is_fw_read_cmd_down(padapter, (int )h2c_box_num);
  if ((unsigned int )tmp == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU:  fw read cmd failed...\n");
    } else {

    }
    goto exit;
  } else {

  }
  if (CmdLen <= 3U) {
    memcpy((void *)(& h2c_cmd) + 1U, (void const   *)pCmdBuffer, (size_t )CmdLen);
  } else {
    memcpy((void *)(& h2c_cmd_ex), (void const   *)pCmdBuffer, 2UL);
    memcpy((void *)(& h2c_cmd) + 1U, (void const   *)pCmdBuffer + 2U, (size_t )(CmdLen - 2U));
    *((u8 *)(& h2c_cmd)) = (u8 )((unsigned int )*((u8 *)(& h2c_cmd)) | 128U);
  }
  *((u8 *)(& h2c_cmd)) = (u8 )((int )*((u8 *)(& h2c_cmd)) | (int )ElementID);
  if (((unsigned long )h2c_cmd & 128UL) != 0UL) {
    msgbox_ex_addr = (u32 )(((int )h2c_box_num + 68) * 2);
    h2c_cmd_ex = h2c_cmd_ex;
    rtl8723au_write16(padapter, (int )((u16 )msgbox_ex_addr), (int )h2c_cmd_ex);
  } else {

  }
  msgbox_addr = (u32 )(((int )h2c_box_num + 116) * 4);
  h2c_cmd = h2c_cmd;
  rtl8723au_write32(padapter, (int )((u16 )msgbox_addr), h2c_cmd);
  bcmd_down = 1U;
  pHalData->LastHMEBoxNum = (u8 )(((int )h2c_box_num + 1) % 4);
  if ((unsigned int )bcmd_down == 0U) {
    tmp___0 = retry_cnts;
    retry_cnts = retry_cnts - 1;
    if (tmp___0 != 0) {
      goto ldv_55792;
    } else {
      goto ldv_55793;
    }
  } else {

  }
  ldv_55793: 
  ret = 1;
  exit: 
  mutex_unlock(& (padapter->dvobj)->h2c_fwcmd_mutex);
  return (ret);
}
}
int rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter , u8 *param ) 
{ 


  {
  *((u32 *)param) = *((u32 *)param);
  FillH2CCmd(padapter, 5, 3U, param);
  return (1);
}
}
int rtl8723a_set_raid_cmd(struct rtw_adapter *padapter , u32 mask , u8 arg ) 
{ 
  u8 buf[5U] ;

  {
  memset((void *)(& buf), 0, 5UL);
  mask = mask;
  memcpy((void *)(& buf), (void const   *)(& mask), 4UL);
  buf[4] = arg;
  FillH2CCmd(padapter, 6, 5U, (u8 *)(& buf));
  return (1);
}
}
void rtl8723a_add_rateatid(struct rtw_adapter *pAdapter , u32 bitmap , u8 arg , u8 rssi_level ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 macid ;
  u32 raid ;

  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  macid = (unsigned int )arg & 31U;
  raid = bitmap & 4026531840U;
  bitmap = bitmap & 268435455U;
  if ((unsigned int )rssi_level != 0U) {
    bitmap = ODM_Get_Rate_Bitmap23a(pHalData, (u32 )macid, bitmap, (int )rssi_level);
  } else {

  }
  bitmap = bitmap | raid;
  rtl8723a_set_raid_cmd(pAdapter, bitmap, (int )arg);
  return;
}
}
void rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter , u8 Mode ) 
{ 
  struct setpwrmode_parm H2CSetPwrMode ;
  struct pwrctrl_priv *pwrpriv ;
  struct hal_data_8723a *pHalData ;

  {
  pwrpriv = & padapter->pwrctrlpriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: Mode =%d SmartPS =%d UAPSD =%d BcnMode = 0x%02x\n",
           "rtl8723a_set_FwPwrMode_cmd", (int )Mode, (int )pwrpriv->smart_ps, (int )padapter->registrypriv.uapsd_enable,
           (int )pwrpriv->bcn_ant_mode);
  } else {

  }
  if ((unsigned int )Mode != 0U && (unsigned int )pHalData->rf_type != 2U) {
    ODM_RF_Saving23a(& pHalData->odmpriv, 1);
  } else {

  }
  H2CSetPwrMode.Mode = Mode;
  H2CSetPwrMode.SmartPS = pwrpriv->smart_ps;
  H2CSetPwrMode.AwakeInterval = 1U;
  H2CSetPwrMode.bAllQueueUAPSD = padapter->registrypriv.uapsd_enable;
  H2CSetPwrMode.BcnAntMode = pwrpriv->bcn_ant_mode;
  FillH2CCmd(padapter, 1, 5U, (u8 *)(& H2CSetPwrMode));
  return;
}
}
static void ConstructBeacon(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ) 
{ 
  struct ieee80211_mgmt *mgmt ;
  u32 rate_len ;
  u32 pktlen ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 bc_addr___0[6U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u32 ATIMWindow ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  bc_addr___0[0] = 255U;
  bc_addr___0[1] = 255U;
  bc_addr___0[2] = 255U;
  bc_addr___0[3] = 255U;
  bc_addr___0[4] = 255U;
  bc_addr___0[5] = 255U;
  mgmt = (struct ieee80211_mgmt *)pframe;
  mgmt->frame_control = 128U;
  ether_addr_copy((u8 *)(& mgmt->da), (u8 const   *)(& bc_addr___0));
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& mgmt->sa), (u8 const   *)tmp);
  tmp___0 = get_my_bssid23a(cur_network);
  ether_addr_copy((u8 *)(& mgmt->bssid), (u8 const   *)tmp___0);
  mgmt->seq_ctrl = 0U;
  put_unaligned_le16((int )cur_network->beacon_interval, (void *)(& mgmt->u.beacon.beacon_int));
  put_unaligned_le16((int )cur_network->capability, (void *)(& mgmt->u.beacon.capab_info));
  pframe = (u8 *)(& mgmt->u.beacon.variable);
  pktlen = 36U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    pktlen = cur_network->IELength + pktlen;
    memcpy((void *)pframe, (void const   *)(& cur_network->IEs), (size_t )pktlen);
    goto _ConstructBeacon;
  } else {

  }
  pframe = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                         & pktlen);
  rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  pframe = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                         & pktlen);
  pframe = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig), & pktlen);
  if ((pmlmeinfo->state & 3U) == 1U) {
    ATIMWindow = 0U;
    pframe = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pktlen);
  } else {

  }
  if (rate_len > 8U) {
    pframe = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                           & pktlen);
  } else {

  }
  _ConstructBeacon: ;
  if (pktlen + 32U > 512U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: beacon frame too large\n");
    } else {

    }
    return;
  } else {

  }
  *pLength = pktlen;
  return;
}
}
static void ConstructPSPoll(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 164U;
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  pwlanhdr->duration_id = (unsigned int )pmlmeinfo->aid | 49152U;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  memcpy((void *)(& pwlanhdr->addr1), (void const   *)tmp, 6UL);
  tmp___0 = myid(& padapter->eeprompriv);
  memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___0, 6UL);
  *pLength = 16U;
  return;
}
}
static void ConstructNullFunctionData(struct rtw_adapter *padapter , u8 *pframe ,
                                      u32 *pLength , u8 *StaAddr , u8 bQoS , u8 AC ,
                                      u8 bEosp , u8 bForcePowerSave ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  u32 pktlen ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  struct ieee80211_qos_hdr *qoshdr ;

  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 0U;
  pwlanhdr->seq_ctrl = 0U;
  if ((unsigned int )bForcePowerSave != 0U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  } else {

  }
  switch ((unsigned int )cur_network->network.ifmode) {
  case 8U: ;
  case 2U: 
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  memcpy((void *)(& pwlanhdr->addr1), (void const   *)tmp, 6UL);
  tmp___0 = myid(& padapter->eeprompriv);
  memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___0, 6UL);
  memcpy((void *)(& pwlanhdr->addr3), (void const   *)StaAddr, 6UL);
  goto ldv_55861;
  case 9U: ;
  case 3U: 
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr, 6UL);
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
  memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___1, 6UL);
  tmp___2 = myid(& padapter->eeprompriv);
  memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___2, 6UL);
  goto ldv_55861;
  case 1U: ;
  default: 
  memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr, 6UL);
  tmp___3 = myid(& padapter->eeprompriv);
  memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___3, 6UL);
  tmp___4 = get_my_bssid23a(& pmlmeinfo->network);
  memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___4, 6UL);
  goto ldv_55861;
  }
  ldv_55861: ;
  if ((unsigned int )bQoS == 1U) {
    qoshdr = (struct ieee80211_qos_hdr *)pframe;
    qoshdr->frame_control = (__le16 )((unsigned int )qoshdr->frame_control | 200U);
    qoshdr->qos_ctrl = (unsigned int )((unsigned short )AC) & 15U;
    if ((unsigned int )bEosp != 0U) {
      qoshdr->qos_ctrl = (__le16 )((unsigned int )qoshdr->qos_ctrl | 16U);
    } else {

    }
    pktlen = 26U;
  } else {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 72U);
    pktlen = 24U;
  }
  *pLength = pktlen;
  return;
}
}
static void ConstructProbeRsp(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ,
                              u8 *StaAddr , bool bHideSSID ) 
{ 
  struct ieee80211_mgmt *mgmt ;
  u8 *mac ;
  u8 *bssid ;
  u32 pktlen ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  mgmt = (struct ieee80211_mgmt *)pframe;
  mac = myid(& padapter->eeprompriv);
  bssid = (u8 *)(& cur_network->MacAddress);
  mgmt->frame_control = 80U;
  mgmt->seq_ctrl = 0U;
  memcpy((void *)(& mgmt->da), (void const   *)StaAddr, 6UL);
  memcpy((void *)(& mgmt->sa), (void const   *)mac, 6UL);
  memcpy((void *)(& mgmt->bssid), (void const   *)bssid, 6UL);
  put_unaligned_le64(cur_network->tsf, (void *)(& mgmt->u.probe_resp.timestamp));
  put_unaligned_le16((int )cur_network->beacon_interval, (void *)(& mgmt->u.probe_resp.beacon_int));
  put_unaligned_le16((int )cur_network->capability, (void *)(& mgmt->u.probe_resp.capab_info));
  pktlen = 36U;
  if (cur_network->IELength > 768U) {
    return;
  } else {

  }
  memcpy((void *)(& mgmt->u.probe_resp.variable), (void const   *)(& cur_network->IEs),
           (size_t )cur_network->IELength);
  pktlen = cur_network->IELength + pktlen;
  *pLength = pktlen;
  return;
}
}
static void SetFwRsvdPagePkt(struct rtw_adapter *padapter , bool bDLFinished ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 BeaconLength ;
  u32 ProbeRspLength ;
  u32 PSPollLength ;
  u32 NullDataLength ;
  u32 QosNullLength ;
  u32 BTQosNullLength ;
  u8 *ReservedPagePacket ;
  u8 PageNum ;
  u8 PageNeed ;
  u8 TxDescLen ;
  u16 BufIndex ;
  u32 TotalPacketLen ;
  struct rsvdpage_loc RsvdPageLoc ;
  void *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u32 tmp___4 ;

  {
  BeaconLength = 0U;
  ProbeRspLength = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "SetFwRsvdPagePkt");
  } else {

  }
  tmp = kzalloc(1000UL, 208U);
  ReservedPagePacket = (u8 *)tmp;
  if ((unsigned long )ReservedPagePacket == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: alloc ReservedPagePacket fail!\n", "SetFwRsvdPagePkt");
    } else {

    }
    return;
  } else {

  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  TxDescLen = 32U;
  PageNum = 0U;
  BufIndex = 40U;
  ConstructBeacon(padapter, ReservedPagePacket + (unsigned long )BufIndex, & BeaconLength);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + BeaconLength) >> 7)) + ((((u32 )TxDescLen + BeaconLength) & 127U) != 0U ? 1U : 0U);
  if ((unsigned int )PageNeed == 1U) {
    PageNeed = (unsigned int )PageNeed + 1U;
  } else {

  }
  PageNum = (int )PageNum + (int )PageNeed;
  pHalData->FwRsvdPageStartOffset = PageNum;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocPsPoll = PageNum;
  ConstructPSPoll(padapter, ReservedPagePacket + (unsigned long )BufIndex, & PSPollLength);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            PSPollLength, 1, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + PSPollLength) >> 7)) + ((((u32 )TxDescLen + PSPollLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocNullData = PageNum;
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & NullDataLength, tmp___0, 0, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            NullDataLength, 0, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + NullDataLength) >> 7)) + ((((u32 )TxDescLen + NullDataLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocProbeRsp = PageNum;
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
  ConstructProbeRsp(padapter, ReservedPagePacket + (unsigned long )BufIndex, & ProbeRspLength,
                    tmp___1, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            ProbeRspLength, 0, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + ProbeRspLength) >> 7)) + ((((u32 )TxDescLen + ProbeRspLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocQosNull = PageNum;
  tmp___2 = get_my_bssid23a(& pmlmeinfo->network);
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & QosNullLength, tmp___2, 1, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            QosNullLength, 0, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + QosNullLength) >> 7)) + ((((u32 )TxDescLen + QosNullLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocBTQosNull = PageNum;
  tmp___3 = get_my_bssid23a(& pmlmeinfo->network);
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & BTQosNullLength, tmp___3, 1, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            BTQosNullLength, 0, 1);
  TotalPacketLen = (u32 )BufIndex + BTQosNullLength;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->qsel = 16U;
  tmp___4 = TotalPacketLen - 40U;
  pattrib->last_txcmdsz = tmp___4;
  pattrib->pktlen = tmp___4;
  memcpy((void *)pmgntframe->buf_addr, (void const   *)ReservedPagePacket, (size_t )TotalPacketLen);
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: Set RSVD page location to Fw\n", "SetFwRsvdPagePkt");
  } else {

  }
  FillH2CCmd(padapter, 3, 5U, (u8 *)(& RsvdPageLoc));
  exit: 
  kfree((void const   *)ReservedPagePacket);
  return;
}
}
void rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter , u8 mstatus ) 
{ 
  struct joinbssrpt_parm JoinBssRptParm ;
  struct hal_data_8723a *pHalData ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool bRecover ;
  u8 v8 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s mstatus(%x)\n", "rtl8723a_set_FwJoinBssReport_cmd",
           (int )mstatus);
  } else {

  }
  if ((unsigned int )mstatus == 1U) {
    bRecover = 0;
    rtl8723au_write16(padapter, 1704, (int )((unsigned int )pmlmeinfo->aid | 49152U));
    v8 = rtl8723au_read8(padapter, 257);
    v8 = (u8 )((unsigned int )v8 | 1U);
    rtl8723au_write8(padapter, 257, (int )v8);
    SetBcnCtrlReg23a(padapter, 16, 8);
    if (((unsigned long )pHalData->RegFwHwTxQCtrl & 64UL) != 0UL) {
      bRecover = 1;
    } else {

    }
    rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl & 191);
    pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
    SetFwRsvdPagePkt(padapter, 0);
    SetBcnCtrlReg23a(padapter, 8, 16);
    if ((int )bRecover) {
      rtl8723au_write8(padapter, 1058, (int )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U));
      pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
    } else {

    }
    v8 = rtl8723au_read8(padapter, 257);
    v8 = (unsigned int )v8 & 254U;
    rtl8723au_write8(padapter, 257, (int )v8);
  } else {

  }
  JoinBssRptParm.OpMode = mstatus;
  FillH2CCmd(padapter, 2, 1U, (u8 *)(& JoinBssRptParm));
  return;
}
}
static void SetFwRsvdPagePkt_BTCoex(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 fakemac[6U] ;
  u32 NullDataLength ;
  u32 BTQosNullLength ;
  u8 *ReservedPagePacket ;
  u8 PageNum ;
  u8 PageNeed ;
  u8 TxDescLen ;
  u16 BufIndex ;
  u32 TotalPacketLen ;
  struct rsvdpage_loc RsvdPageLoc ;
  void *tmp ;
  u32 tmp___0 ;

  {
  fakemac[0] = 0U;
  fakemac[1] = 224U;
  fakemac[2] = 76U;
  fakemac[3] = 0U;
  fakemac[4] = 0U;
  fakemac[5] = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +%s\n", "SetFwRsvdPagePkt_BTCoex");
  } else {

  }
  tmp = kzalloc(1024UL, 208U);
  ReservedPagePacket = (u8 *)tmp;
  if ((unsigned long )ReservedPagePacket == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: alloc ReservedPagePacket fail!\n", "SetFwRsvdPagePkt_BTCoex");
    } else {

    }
    return;
  } else {

  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  TxDescLen = 32U;
  PageNum = 0U;
  BufIndex = 40U;
  PageNeed = 3U;
  PageNum = (int )PageNum + (int )PageNeed;
  pHalData->FwRsvdPageStartOffset = PageNum;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocNullData = PageNum;
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & NullDataLength, (u8 *)(& fakemac), 0, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            NullDataLength, 0, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + NullDataLength) >> 7)) + ((((u32 )TxDescLen + NullDataLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocBTQosNull = PageNum;
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & BTQosNullLength, (u8 *)(& fakemac), 1, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            BTQosNullLength, 0, 1);
  TotalPacketLen = (u32 )BufIndex + BTQosNullLength;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->qsel = 16U;
  tmp___0 = TotalPacketLen - 40U;
  pattrib->last_txcmdsz = tmp___0;
  pattrib->pktlen = tmp___0;
  memcpy((void *)pmgntframe->buf_addr, (void const   *)ReservedPagePacket, (size_t )TotalPacketLen);
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: Set RSVD page location to Fw\n", "SetFwRsvdPagePkt_BTCoex");
  } else {

  }
  FillH2CCmd(padapter, 3, 5U, (u8 *)(& RsvdPageLoc));
  exit: 
  kfree((void const   *)ReservedPagePacket);
  return;
}
}
void rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 bRecover ;

  {
  bRecover = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +%s\n", "rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd");
  } else {

  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (((unsigned long )pHalData->RegFwHwTxQCtrl & 64UL) != 0UL) {
    bRecover = 1U;
  } else {

  }
  pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
  rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl);
  SetFwRsvdPagePkt_BTCoex(padapter);
  if ((unsigned int )bRecover != 0U) {
    pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
    rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_467(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_468(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_469(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_470(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_471(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_481(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_483(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_482(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_485(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_484(struct workqueue_struct *ldv_func_arg1 ) ;
void rtl8723a_init_dm_priv(struct rtw_adapter *Adapter ) ;
void rtl8723a_InitHalDm(struct rtw_adapter *Adapter ) ;
static void dm_CheckPbcGPIO(struct rtw_adapter *padapter ) 
{ 
  u8 tmp1byte ;
  u8 bPbcPressed ;
  struct pid *tmp ;

  {
  bPbcPressed = 0U;
  if ((unsigned int )padapter->registrypriv.hw_wps_pbc == 0U) {
    return;
  } else {

  }
  tmp1byte = rtl8723au_read8(padapter, 70);
  tmp1byte = (u8 )((unsigned int )tmp1byte | 4U);
  rtl8723au_write8(padapter, 70, (int )tmp1byte);
  tmp1byte = (unsigned int )tmp1byte & 251U;
  rtl8723au_write8(padapter, 68, (int )tmp1byte);
  tmp1byte = rtl8723au_read8(padapter, 70);
  tmp1byte = (unsigned int )tmp1byte & 251U;
  rtl8723au_write8(padapter, 70, (int )tmp1byte);
  tmp1byte = rtl8723au_read8(padapter, 68);
  if ((unsigned int )tmp1byte == 255U) {
    return;
  } else {

  }
  if (((unsigned long )tmp1byte & 4UL) != 0UL) {
    bPbcPressed = 1U;
  } else {

  }
  if ((unsigned int )bPbcPressed != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: CheckPbcGPIO - PBC is pressed\n");
    } else {

    }
    if (padapter->pid[0] == 0) {
      return;
    } else {

    }
    tmp = find_vpid(padapter->pid[0]);
    kill_pid(tmp, 10, 1);
  } else {

  }
  return;
}
}
void rtl8723a_init_dm_priv(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;
  u8 cut_ver ;
  u8 fab_ver ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pDM_Odm = & pHalData->odmpriv;
  memset((void *)pdmpriv, 0, 352UL);
  memset((void *)pDM_Odm, 0, 2632UL);
  pDM_Odm->Adapter = Adapter;
  ODM_CmnInfoInit23a(pDM_Odm, 3, 8U);
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 0U) {
    fab_ver = 1U;
    cut_ver = 1U;
  } else
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) {
    fab_ver = 1U;
    cut_ver = 2U;
  } else {
    fab_ver = 0U;
    cut_ver = 1U;
  }
  ODM_CmnInfoInit23a(pDM_Odm, 5, (u32 )fab_ver);
  ODM_CmnInfoInit23a(pDM_Odm, 4, (u32 )cut_ver);
  ODM_CmnInfoInit23a(pDM_Odm, 2, (unsigned int )pHalData->VersionID.ChipType == 1U);
  ODM_CmnInfoInit23a(pDM_Odm, 6, (u32 )pHalData->BoardType);
  if ((unsigned int )pHalData->BoardType == 1U) {
    ODM_CmnInfoInit23a(pDM_Odm, 7, 1U);
    ODM_CmnInfoInit23a(pDM_Odm, 8, 1U);
  } else {

  }
  ODM_CmnInfoInit23a(pDM_Odm, 11, (u32 )Adapter->registrypriv.wifi_spec);
  return;
}
}
static void Update_ODM_ComInfo_8723a(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct dm_priv *pdmpriv ;
  int i ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pDM_Odm = & pHalData->odmpriv;
  pdmpriv = & pHalData->dmpriv;
  pdmpriv->InitODMFlag = 0U;
  rtl8723a_odm_support_ability_set(Adapter, 268435455U);
  i = 0;
  goto ldv_55765;
  ldv_55764: 
  ODM_CmnInfoPtrArrayHook23a(pDM_Odm, 28, (int )((u16 )i), (void *)0);
  i = i + 1;
  ldv_55765: ;
  if (i <= 31) {
    goto ldv_55764;
  } else {

  }

  return;
}
}
void rtl8723a_InitHalDm(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;
  u8 i ;
  u8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pDM_Odm = & pHalData->odmpriv;
  Update_ODM_ComInfo_8723a(Adapter);
  ODM23a_DMInit(pDM_Odm);
  i = 0U;
  goto ldv_55775;
  ldv_55774: 
  tmp = rtl8723au_read8(Adapter, (int )((unsigned int )((u16 )i) + 1156U));
  pdmpriv->INIDATA_RATE[(int )i] = (unsigned int )tmp & 63U;
  i = (u8 )((int )i + 1);
  ldv_55775: ;
  if ((unsigned int )i <= 31U) {
    goto ldv_55774;
  } else {

  }

  return;
}
}
void rtl8723a_HalDmWatchDog(struct rtw_adapter *Adapter ) 
{ 
  bool bFwCurrentInPSMode ;
  bool bFwPSAwake ;
  u8 bLinked ;
  u8 hw_init_completed ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 tmp ;
  u8 i ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  bFwCurrentInPSMode = 0;
  bFwPSAwake = 1;
  bLinked = 0U;
  hw_init_completed = 0U;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  hw_init_completed = Adapter->hw_init_completed;
  if ((unsigned int )hw_init_completed == 0U) {
    goto skip_dm;
  } else {

  }
  bFwCurrentInPSMode = (unsigned int )Adapter->pwrctrlpriv.bFwCurrentInPSMode != 0U;
  bFwPSAwake = rtl8723a_get_fwlps_rf_on(Adapter);
  if (! bFwCurrentInPSMode && (int )bFwPSAwake) {
    tmp___1 = check_fwstate(& Adapter->mlmepriv, 8);
    if ((int )tmp___1) {
      tmp = rtl8723au_read8(Adapter, 1156);
      pdmpriv->INIDATA_RATE[0] = (unsigned int )tmp & 63U;
    } else {
      i = 1U;
      goto ldv_55789;
      ldv_55788: 
      tmp___0 = rtl8723au_read8(Adapter, (int )((unsigned int )((u16 )i) + 1156U));
      pdmpriv->INIDATA_RATE[(int )i] = (unsigned int )tmp___0 & 63U;
      i = (u8 )((int )i + 1);
      ldv_55789: ;
      if ((int )i < Adapter->stapriv.asoc_sta_count + 1) {
        goto ldv_55788;
      } else {

      }

    }
  } else {

  }
  tmp___2 = rtw_linked_check(Adapter);
  if (tmp___2 != 0) {
    bLinked = 1U;
  } else {

  }
  ODM_CmnInfoUpdate23a(& pHalData->odmpriv, 16U, (u64 )bLinked);
  ODM_DMWatchdog23a(Adapter);
  skip_dm: 
  dm_CheckPbcGPIO(Adapter);
  return;
}
}
bool ldv_queue_work_on_481(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_482(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_483(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_484(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_485(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
bool ldv_queue_work_on_495(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_497(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_496(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_499(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_498(struct workqueue_struct *ldv_func_arg1 ) ;
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
extern void release_firmware(struct firmware  const  * ) ;
void hw_var_set_macaddr(struct rtw_adapter *padapter , u8 *val ) ;
__inline static struct device *dvobj_to_dev(struct dvobj_priv *dvobj ) 
{ 


  {
  return (& (dvobj->pusbintf)->dev);
}
}
void rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter , u8 action ) ;
void rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter ) ;
void rtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter , u8 *tmpBuf , u8 length ) ;
void handle_txrpt_ccx_8723a(struct rtw_adapter *adapter , void *buf ) ;
s32 rtl8723a_FirmwareDownload(struct rtw_adapter *padapter ) ;
void rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter ) ;
void rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter ) ;
void rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter ) ;
void rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter ) ;
void rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter ) ;
void rtl8723a_init_default_value(struct rtw_adapter *padapter ) ;
s32 InitLLTTable23a(struct rtw_adapter *padapter , u32 boundary ) ;
s32 CardDisableHWSM(struct rtw_adapter *padapter , u8 resetMCU ) ;
s32 CardDisableWithoutHWSM(struct rtw_adapter *padapter ) ;
u8 GetEEPROMSize8723A(struct rtw_adapter *padapter ) ;
void Hal_InitPGData(struct rtw_adapter *padapter , u8 *PROMContent ) ;
void Hal_EfuseParseIDCode(struct rtw_adapter *padapter , u8 *hwinfo ) ;
void Hal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                     bool AutoLoadFail ) ;
void Hal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter , u8 *hwinfo ,
                                       bool AutoLoadFail ) ;
void Hal_EfuseParseEEPROMVer(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
void rtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
void Hal_EfuseParseCustomerID(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
void Hal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
void Hal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter , u8 *hwinfo ,
                                        bool AutoLoadFail ) ;
void Hal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter , u8 *hwinfo , u8 AutoLoadFail ) ;
void Hal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                      bool AutoloadFail ) ;
void rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter ) ;
void rtl8723a_read_chip_version(struct rtw_adapter *padapter ) ;
void rtl8723a_notch_filter(struct rtw_adapter *adapter , bool enable ) ;
int rtl8723au_writeN(struct rtw_adapter *padapter , u16 addr , u16 len , u8 *buf ) ;
static void _FWDownloadEnable(struct rtw_adapter *padapter , bool enable ) 
{ 
  u8 tmp ;

  {
  if ((int )enable) {
    tmp = rtl8723au_read8(padapter, 3);
    rtl8723au_write8(padapter, 3, (int )((unsigned int )tmp | 4U));
    tmp = rtl8723au_read8(padapter, 128);
    rtl8723au_write8(padapter, 128, (int )((unsigned int )tmp | 1U));
    tmp = rtl8723au_read8(padapter, 130);
    rtl8723au_write8(padapter, 130, (int )tmp & 247);
  } else {
    tmp = rtl8723au_read8(padapter, 128);
    rtl8723au_write8(padapter, 128, (int )tmp & 254);
    rtl8723au_write8(padapter, 129, 0);
  }
  return;
}
}
static int _PageWrite(struct rtw_adapter *padapter , u32 page , void *buffer , u32 size ) 
{ 
  u8 value8 ;
  u8 u8Page ;
  u8 tmp ;
  int tmp___0 ;

  {
  u8Page = (unsigned int )((unsigned char )page) & 7U;
  if (size > 4096U) {
    return (0);
  } else {

  }
  tmp = rtl8723au_read8(padapter, 130);
  value8 = (u8 )(((int )((signed char )tmp) & -8) | (int )((signed char )u8Page));
  rtl8723au_write8(padapter, 130, (int )value8);
  tmp___0 = rtl8723au_writeN(padapter, 4096, (int )((u16 )size), (u8 *)buffer);
  return (tmp___0);
}
}
static int _WriteFW(struct rtw_adapter *padapter , void *buffer , u32 size ) 
{ 
  int ret ;
  u32 pageNums ;
  u32 remainSize ;
  u32 page ;
  u32 offset ;
  u8 *bufferPtr ;

  {
  ret = 1;
  bufferPtr = (u8 *)buffer;
  pageNums = size / 4096U;
  remainSize = size & 4095U;
  page = 0U;
  goto ldv_55799;
  ldv_55798: 
  offset = page * 4096U;
  ret = _PageWrite(padapter, page, (void *)bufferPtr + (unsigned long )offset, 4096U);
  if (ret == 0) {
    goto exit;
  } else {

  }
  page = page + 1U;
  ldv_55799: ;
  if (page < pageNums) {
    goto ldv_55798;
  } else {

  }

  if (remainSize != 0U) {
    offset = pageNums * 4096U;
    page = pageNums;
    ret = _PageWrite(padapter, page, (void *)bufferPtr + (unsigned long )offset, remainSize);
    if (ret == 0) {
      goto exit;
    } else {

    }
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "_WriteFW Done- for Normal chip.\n");
  } else {

  }
  exit: ;
  return (ret);
}
}
static int _FWFreeToGo(struct rtw_adapter *padapter ) 
{ 
  u32 counter ;
  u32 value32 ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  counter = 0U;
  ldv_55807: 
  value32 = rtl8723au_read32(padapter, 128);
  if (((unsigned long )value32 & 4UL) != 0UL) {
    goto ldv_55806;
  } else {

  }
  tmp = counter;
  counter = counter + 1U;
  if (tmp <= 999U) {
    goto ldv_55807;
  } else {

  }
  ldv_55806: ;
  if (counter > 999U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16384, 4, "%s: chksum report fail! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
               value32);
    } else {

    }
    return (0);
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "%s: Checksum report OK! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
             value32);
  } else {

  }
  value32 = rtl8723au_read32(padapter, 128);
  value32 = value32 | 2U;
  value32 = value32 & 4294967231U;
  rtl8723au_write32(padapter, 128, value32);
  counter = 0U;
  ldv_55809: 
  value32 = rtl8723au_read32(padapter, 128);
  if (((unsigned long )value32 & 64UL) != 0UL) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "%s: Polling FW ready success!! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
               value32);
    } else {

    }
    return (1);
  } else {

  }
  __const_udelay(21475UL);
  tmp___0 = counter;
  counter = counter + 1U;
  if (tmp___0 <= 999U) {
    goto ldv_55809;
  } else {

  }

  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16384, 4, "%s: Polling FW ready fail!! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
             value32);
  } else {

  }
  return (0);
}
}
void rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 u1bTmp ;
  u8 Delay ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  Delay = 100U;
  if (((int )((struct hal_data_8723a *)padapter->HalData)->FirmwareSignature & 65520) != 35008 || ((unsigned int )pHalData->FirmwareVersion > 32U && ((unsigned int )pHalData->FirmwareVersion != 33U || (unsigned int )pHalData->FirmwareSubVersion != 0U))) {
    rtl8723au_write8(padapter, 463, 32);
    u1bTmp = rtl8723au_read8(padapter, 3);
    goto ldv_55819;
    ldv_55818: 
    Delay = (u8 )((int )Delay - 1);
    if ((unsigned int )Delay == 0U) {
      goto ldv_55817;
    } else {

    }
    __const_udelay(214750UL);
    u1bTmp = rtl8723au_read8(padapter, 3);
    ldv_55819: ;
    if (((unsigned long )u1bTmp & 4UL) != 0UL) {
      goto ldv_55818;
    } else {

    }
    ldv_55817: ;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "-%s: 8051 reset success (%d)\n", "rtl8723a_FirmwareSelfReset",
               (int )Delay);
    } else {

    }
    if ((unsigned int )Delay == 0U) {
      u1bTmp = rtl8723au_read8(padapter, 3);
      rtl8723au_write8(padapter, 3, (int )u1bTmp & 251);
    } else {

    }
  } else {

  }
  return;
}
}
s32 rtl8723a_FirmwareDownload(struct rtw_adapter *padapter ) 
{ 
  int rtStatus ;
  u8 writeFW_retry ;
  unsigned long fwdl_start_time ;
  struct hal_data_8723a *pHalData ;
  struct dvobj_priv *dvobj ;
  struct device *device ;
  struct device *tmp ;
  struct rt_8723a_firmware_hdr *pFwHdr ;
  struct firmware  const  *fw ;
  char *fw_name ;
  u8 *firmware_buf ;
  u8 *buf ;
  int fw_size ;
  int log_version ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  unsigned int tmp___6 ;
  u8 tmp___7 ;
  unsigned int tmp___8 ;

  {
  rtStatus = 1;
  writeFW_retry = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  dvobj = padapter->dvobj;
  tmp = dvobj_to_dev(dvobj);
  device = tmp;
  pFwHdr = (struct rt_8723a_firmware_hdr *)0;
  firmware_buf = (u8 *)0U;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "+%s\n", "rtl8723a_FirmwareDownload");
  } else {

  }
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 0U) {
    fw_name = (char *)"rtlwifi/rtl8723aufw_A.bin";
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "rtl8723a_FirmwareDownload: R8723FwImageArray_UMC for RTL8723A A CUT\n");
    } else {

    }
  } else
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) {
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
      fw_name = (char *)"rtlwifi/rtl8723aufw_B_NoBT.bin";
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithoutBT for RTL8723A B CUT\n");
      } else {

      }
    } else {
      tmp___0 = rtl8723a_BT_coexist(padapter);
      if ((int )tmp___0) {
        fw_name = (char *)"rtlwifi/rtl8723aufw_B.bin";
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithBT for RTL8723A B CUT\n");
        } else {

        }
      } else {
        fw_name = (char *)"rtlwifi/rtl8723aufw_B_NoBT.bin";
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithout BT for RTL8723A B CUT\n");
        } else {

        }
      }
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16384, 4, "%s: unknown version!\n", "rtl8723a_FirmwareDownload");
    } else {

    }
    rtStatus = 0;
    goto Exit;
  }
  printk("\016rtl8723au: Loading firmware %s\n", fw_name);
  tmp___1 = request_firmware(& fw, (char const   *)fw_name, device);
  if (tmp___1 != 0) {
    printk("\vrtl8723au: request_firmware load failed\n");
    rtStatus = 0;
    goto Exit;
  } else {

  }
  if ((unsigned long )fw == (unsigned long )((struct firmware  const  *)0)) {
    printk("\vrtl8723au: Firmware %s not available\n", fw_name);
    rtStatus = 0;
    goto Exit;
  } else {

  }
  tmp___2 = kmemdup((void const   *)fw->data, fw->size, 208U);
  firmware_buf = (u8 *)tmp___2;
  if ((unsigned long )firmware_buf == (unsigned long )((u8 *)0U)) {
    rtStatus = 0;
    goto Exit;
  } else {

  }
  buf = firmware_buf;
  fw_size = (int )fw->size;
  release_firmware(fw);
  pFwHdr = (struct rt_8723a_firmware_hdr *)firmware_buf;
  pHalData->FirmwareVersion = pFwHdr->Version;
  pHalData->FirmwareSubVersion = (u16 )pFwHdr->Subversion;
  pHalData->FirmwareSignature = pFwHdr->Signature;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: fw_ver =%d fw_subver =%d sig = 0x%x\n", "rtl8723a_FirmwareDownload",
           (int )pHalData->FirmwareVersion, (int )pHalData->FirmwareSubVersion, (int )pHalData->FirmwareSignature);
  } else {

  }
  tmp___3 = log_version;
  log_version = log_version + 1;
  if (tmp___3 == 0) {
    printk("\016%sFirmware Version %d, SubVersion %d, Signature 0x%x\n", (char *)"RTL8723AU: ",
           (int )pHalData->FirmwareVersion, (int )pHalData->FirmwareSubVersion, (int )pHalData->FirmwareSignature);
  } else {

  }
  if ((((int )pFwHdr->Signature & 65520) == 37568 || ((int )pFwHdr->Signature & 65520) == 35008) || ((int )pFwHdr->Signature & 65520) == 8960) {
    buf = buf + 32UL;
    fw_size = fw_size + -32;
  } else {

  }
  tmp___4 = rtl8723au_read8(padapter, 128);
  if ((int )((signed char )tmp___4) < 0) {
    rtl8723a_FirmwareSelfReset(padapter);
    rtl8723au_write8(padapter, 128, 0);
  } else {

  }
  _FWDownloadEnable(padapter, 1);
  fwdl_start_time = jiffies;
  ldv_55840: 
  tmp___5 = rtl8723au_read8(padapter, 128);
  rtl8723au_write8(padapter, 128, (int )((unsigned int )tmp___5 | 4U));
  rtStatus = _WriteFW(padapter, (void *)buf, (u32 )fw_size);
  if (rtStatus == 1) {
    goto ldv_55839;
  } else {
    tmp___6 = jiffies_to_msecs((unsigned long )jiffies - fwdl_start_time);
    if (tmp___6 > 500U) {
      tmp___7 = writeFW_retry;
      writeFW_retry = (u8 )((int )writeFW_retry + 1);
      if ((unsigned int )tmp___7 > 2U) {
        goto ldv_55839;
      } else {

      }
    } else {

    }
  }
  if (GlobalDebugLevel23A > 3U) {
    tmp___8 = jiffies_to_msecs((unsigned long )jiffies - fwdl_start_time);
    printk("\016RTL8723AU: %s writeFW_retry:%u, time after fwdl_start_time:%ums\n",
           "rtl8723a_FirmwareDownload", (int )writeFW_retry, tmp___8);
  } else {

  }
  goto ldv_55840;
  ldv_55839: 
  _FWDownloadEnable(padapter, 0);
  if (rtStatus != 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: DL Firmware failed!\n");
    } else {

    }
    goto Exit;
  } else {

  }
  rtStatus = _FWFreeToGo(padapter);
  if (rtStatus != 1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16384, 4, "DL Firmware failed!\n");
    } else {

    }
    goto Exit;
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "Firmware is ready to run!\n");
  } else {

  }
  Exit: 
  kfree((void const   *)firmware_buf);
  return (rtStatus);
}
}
void rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  padapter->pwrctrlpriv.bFwCurrentInPSMode = 0U;
  pHalData->LastHMEBoxNum = 0U;
  return;
}
}
static u8 hal_EfuseSwitchToBank(struct rtw_adapter *padapter , u8 bank ) 
{ 
  u8 bRet ;
  u32 value32 ;

  {
  bRet = 0U;
  value32 = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: Efuse switch bank to %d\n", "hal_EfuseSwitchToBank",
           (int )bank);
  } else {

  }
  value32 = rtl8723au_read32(padapter, 52);
  bRet = 1U;
  switch ((int )bank) {
  case 0: 
  value32 = value32 & 4294966527U;
  goto ldv_55853;
  case 1: 
  value32 = (value32 & 4294966527U) | 256U;
  goto ldv_55853;
  case 2: 
  value32 = (value32 & 4294966527U) | 512U;
  goto ldv_55853;
  case 3: 
  value32 = value32 | 768U;
  goto ldv_55853;
  default: 
  value32 = value32 & 4294966527U;
  bRet = 0U;
  goto ldv_55853;
  }
  ldv_55853: 
  rtl8723au_write32(padapter, 52, value32);
  return (bRet);
}
}
static void hal_ReadEFuse_WiFi(struct rtw_adapter *padapter , u16 _offset , u16 _size_byte ,
                               u8 *pbuf ) 
{ 
  u8 *efuseTbl ;
  u16 eFuse_Addr ;
  u8 offset ;
  u8 wden ;
  u8 efuseHeader ;
  u8 efuseExtHdr ;
  u8 efuseData ;
  u16 i ;
  u16 total ;
  u16 used ;
  struct hal_data_8723a *pHalData ;
  void *tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 addr ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  u8 tmp___4 ;

  {
  efuseTbl = (u8 *)0U;
  eFuse_Addr = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((int )_offset + (int )_size_byte > 256) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: Invalid offset(%#x) with read bytes(%#x)!!\n", "hal_ReadEFuse_WiFi",
             (int )_offset, (int )_size_byte);
    } else {

    }
    return;
  } else {

  }
  tmp = kmalloc(256UL, 208U);
  efuseTbl = (u8 *)tmp;
  if ((unsigned long )efuseTbl == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: alloc efuseTbl fail!\n", "hal_ReadEFuse_WiFi");
    } else {

    }
    return;
  } else {

  }
  memset((void *)efuseTbl, 255, 256UL);
  hal_EfuseSwitchToBank(padapter, 0);
  goto ldv_55877;
  ldv_55882: 
  tmp___0 = eFuse_Addr;
  eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
  ReadEFuseByte23a(padapter, (int )tmp___0, & efuseHeader);
  if ((unsigned int )efuseHeader == 255U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: data end at address =%#x\n", "hal_ReadEFuse_WiFi",
             (int )eFuse_Addr);
    } else {

    }
    goto ldv_55876;
  } else {

  }
  if (((int )efuseHeader & 31) == 15) {
    offset = (int )efuseHeader >> 5;
    tmp___1 = eFuse_Addr;
    eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
    ReadEFuseByte23a(padapter, (int )tmp___1, & efuseExtHdr);
    if (((int )efuseExtHdr & 15) == 15) {
      goto ldv_55877;
    } else {

    }
    offset = (u8 )((int )((signed char )(((int )efuseExtHdr & 240) >> 1)) | (int )((signed char )offset));
    wden = (unsigned int )efuseExtHdr & 15U;
  } else {
    offset = (u8 )((int )efuseHeader >> 4);
    wden = (unsigned int )efuseHeader & 15U;
  }
  if ((unsigned int )offset <= 31U) {
    addr = (unsigned int )((u16 )offset) * 8U;
    i = 0U;
    goto ldv_55880;
    ldv_55879: ;
    if ((((int )wden >> (int )i) & 1) == 0) {
      tmp___2 = eFuse_Addr;
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___2, & efuseData);
      *(efuseTbl + (unsigned long )addr) = efuseData;
      tmp___3 = eFuse_Addr;
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuseData);
      *(efuseTbl + ((unsigned long )addr + 1UL)) = efuseData;
    } else {

    }
    addr = (unsigned int )addr + 2U;
    i = (u16 )((int )i + 1);
    ldv_55880: ;
    if ((unsigned int )i <= 3U) {
      goto ldv_55879;
    } else {

    }

  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: offset(%d) is illegal!!\n", "hal_ReadEFuse_WiFi",
             (int )offset);
    } else {

    }
    tmp___4 = Efuse_CalculateWordCnts23a((int )wden);
    eFuse_Addr = (unsigned int )((u16 )tmp___4) * 2U + (unsigned int )eFuse_Addr;
  }
  ldv_55877: ;
  if ((unsigned int )eFuse_Addr <= 511U) {
    goto ldv_55882;
  } else {

  }
  ldv_55876: 
  i = 0U;
  goto ldv_55884;
  ldv_55883: 
  *(pbuf + (unsigned long )i) = *(efuseTbl + (unsigned long )((int )_offset + (int )i));
  i = (u16 )((int )i + 1);
  ldv_55884: ;
  if ((int )i < (int )_size_byte) {
    goto ldv_55883;
  } else {

  }
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& total));
  used = (unsigned int )eFuse_Addr + 65535U;
  pHalData->EfuseUsedBytes = used;
  kfree((void const   *)efuseTbl);
  return;
}
}
static void hal_ReadEFuse_BT(struct rtw_adapter *padapter , u16 _offset , u16 _size_byte ,
                             u8 *pbuf ) 
{ 
  u8 *efuseTbl ;
  u8 bank ;
  u16 eFuse_Addr ;
  u8 efuseHeader ;
  u8 efuseExtHdr ;
  u8 efuseData ;
  u8 offset ;
  u8 wden ;
  u16 i ;
  u16 total ;
  u16 used ;
  struct hal_data_8723a *pHalData ;
  void *tmp ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 addr ;
  u16 tmp___3 ;
  u16 tmp___4 ;
  u8 tmp___5 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((int )_offset + (int )_size_byte > 1024) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: Invalid offset(%#x) with read bytes(%#x)!!\n", "hal_ReadEFuse_BT",
             (int )_offset, (int )_size_byte);
    } else {

    }
    return;
  } else {

  }
  tmp = kmalloc(1024UL, 208U);
  efuseTbl = (u8 *)tmp;
  if ((unsigned long )efuseTbl == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: efuseTbl malloc fail!\n", "hal_ReadEFuse_BT");
    } else {

    }
    return;
  } else {

  }
  memset((void *)efuseTbl, 255, 1024UL);
  EFUSE_GetEfuseDefinition23a(padapter, 1, 2, (void *)(& total));
  bank = 1U;
  goto ldv_55915;
  ldv_55914: 
  tmp___0 = hal_EfuseSwitchToBank(padapter, (int )bank);
  if ((unsigned int )tmp___0 == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: hal_EfuseSwitchToBank Fail!!\n", "hal_ReadEFuse_BT");
    } else {

    }
    goto exit;
  } else {

  }
  eFuse_Addr = 0U;
  goto ldv_55907;
  ldv_55912: 
  tmp___1 = eFuse_Addr;
  eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
  ReadEFuseByte23a(padapter, (int )tmp___1, & efuseHeader);
  if ((unsigned int )efuseHeader == 255U) {
    goto ldv_55906;
  } else {

  }
  if (((int )efuseHeader & 31) == 15) {
    offset = (int )efuseHeader >> 5;
    tmp___2 = eFuse_Addr;
    eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
    ReadEFuseByte23a(padapter, (int )tmp___2, & efuseExtHdr);
    if (((int )efuseExtHdr & 15) == 15) {
      goto ldv_55907;
    } else {

    }
    offset = (u8 )((int )((signed char )(((int )efuseExtHdr & 240) >> 1)) | (int )((signed char )offset));
    wden = (unsigned int )efuseExtHdr & 15U;
  } else {
    offset = (u8 )((int )efuseHeader >> 4);
    wden = (unsigned int )efuseHeader & 15U;
  }
  if ((int )((signed char )offset) >= 0) {
    addr = (unsigned int )((u16 )offset) * 8U;
    i = 0U;
    goto ldv_55910;
    ldv_55909: ;
    if ((((int )wden >> (int )i) & 1) == 0) {
      tmp___3 = eFuse_Addr;
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuseData);
      *(efuseTbl + (unsigned long )addr) = efuseData;
      tmp___4 = eFuse_Addr;
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___4, & efuseData);
      *(efuseTbl + ((unsigned long )addr + 1UL)) = efuseData;
    } else {

    }
    addr = (unsigned int )addr + 2U;
    i = (u16 )((int )i + 1);
    ldv_55910: ;
    if ((unsigned int )i <= 3U) {
      goto ldv_55909;
    } else {

    }

  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: offset(%d) is illegal!!\n", "hal_ReadEFuse_BT",
             (int )offset);
    } else {

    }
    tmp___5 = Efuse_CalculateWordCnts23a((int )wden);
    eFuse_Addr = (unsigned int )((u16 )tmp___5) * 2U + (unsigned int )eFuse_Addr;
  }
  ldv_55907: ;
  if ((unsigned int )eFuse_Addr <= 511U) {
    goto ldv_55912;
  } else {

  }
  ldv_55906: ;
  if ((int )eFuse_Addr + -1 < (int )total) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: bank(%d) data end at %#x\n", "hal_ReadEFuse_BT",
             (int )bank, (int )eFuse_Addr + -1);
    } else {

    }
    goto ldv_55913;
  } else {

  }
  bank = (u8 )((int )bank + 1);
  ldv_55915: ;
  if ((unsigned int )bank <= 3U) {
    goto ldv_55914;
  } else {

  }
  ldv_55913: 
  hal_EfuseSwitchToBank(padapter, 0);
  i = 0U;
  goto ldv_55917;
  ldv_55916: 
  *(pbuf + (unsigned long )i) = *(efuseTbl + (unsigned long )((int )_offset + (int )i));
  i = (u16 )((int )i + 1);
  ldv_55917: ;
  if ((int )i < (int )_size_byte) {
    goto ldv_55916;
  } else {

  }
  EFUSE_GetEfuseDefinition23a(padapter, 1, 3, (void *)(& total));
  used = ((unsigned int )((u16 )((int )bank + -1)) * 512U + (unsigned int )eFuse_Addr) + 65535U;
  pHalData->BTEfuseUsedBytes = used;
  exit: 
  kfree((void const   *)efuseTbl);
  return;
}
}
void rtl8723a_readefuse(struct rtw_adapter *padapter , u8 efuseType , u16 _offset ,
                        u16 _size_byte , u8 *pbuf ) 
{ 


  {
  if ((unsigned int )efuseType == 0U) {
    hal_ReadEFuse_WiFi(padapter, (int )_offset, (int )_size_byte, pbuf);
  } else {
    hal_ReadEFuse_BT(padapter, (int )_offset, (int )_size_byte, pbuf);
  }
  return;
}
}
u16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter ) 
{ 
  u16 efuse_addr ;
  u8 hoffset ;
  u8 hworden ;
  u8 efuse_data ;
  u8 word_cnts ;
  struct hal_data_8723a *pHalData ;
  int tmp ;

  {
  efuse_addr = 0U;
  hoffset = 0U;
  hworden = 0U;
  word_cnts = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  efuse_addr = pHalData->EfuseUsedBytes;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: start_efuse_addr = 0x%X\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
           (int )efuse_addr);
  } else {

  }
  hal_EfuseSwitchToBank(padapter, 0);
  goto ldv_55937;
  ldv_55938: 
  tmp = efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: efuse_OneByteRead23a Fail! addr = 0x%X !!\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
             (int )efuse_addr);
    } else {

    }
    goto ldv_55936;
  } else {

  }
  if ((unsigned int )efuse_data == 255U) {
    goto ldv_55936;
  } else {

  }
  if (((int )efuse_data & 31) == 15) {
    hoffset = (int )efuse_data >> 5;
    efuse_addr = (u16 )((int )efuse_addr + 1);
    efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
    if (((int )efuse_data & 15) == 15) {
      goto ldv_55937;
    } else {

    }
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
    hworden = (unsigned int )efuse_data & 15U;
  } else {
    hoffset = (u8 )((int )efuse_data >> 4);
    hworden = (unsigned int )efuse_data & 15U;
  }
  word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
  efuse_addr = ((unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr) + 1U;
  ldv_55937: ;
  if ((unsigned int )efuse_addr <= 511U) {
    goto ldv_55938;
  } else {

  }
  ldv_55936: 
  pHalData->EfuseUsedBytes = efuse_addr;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: CurrentSize =%d\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
           (int )efuse_addr);
  } else {

  }
  return (efuse_addr);
}
}
u16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter ) 
{ 
  u16 btusedbytes ;
  u16 efuse_addr ;
  u8 bank ;
  u8 startBank ;
  u8 hoffset ;
  u8 hworden ;
  u8 efuse_data ;
  u8 word_cnts ;
  u16 retU2 ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  int tmp___0 ;

  {
  hoffset = 0U;
  hworden = 0U;
  word_cnts = 0U;
  retU2 = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btusedbytes = pHalData->BTEfuseUsedBytes;
  efuse_addr = (unsigned int )btusedbytes & 511U;
  startBank = (unsigned int )((unsigned char )((unsigned int )btusedbytes / 512U)) + 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: start from bank =%d addr = 0x%X\n", "rtl8723a_EfuseGetCurrentSize_BT",
           (int )startBank, (int )efuse_addr);
  } else {

  }
  EFUSE_GetEfuseDefinition23a(padapter, 1, 2, (void *)(& retU2));
  bank = startBank;
  goto ldv_55958;
  ldv_55957: 
  tmp = hal_EfuseSwitchToBank(padapter, (int )bank);
  if ((unsigned int )tmp == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: switch bank(%d) Fail!!\n", "rtl8723a_EfuseGetCurrentSize_BT",
             (int )bank);
    } else {

    }
    bank = 4U;
    goto ldv_55953;
  } else {

  }
  if ((int )bank != (int )startBank) {
    efuse_addr = 0U;
  } else {

  }
  goto ldv_55955;
  ldv_55956: 
  tmp___0 = efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
  if (tmp___0 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: efuse_OneByteRead23a Fail! addr = 0x%X !!\n", "rtl8723a_EfuseGetCurrentSize_BT",
             (int )efuse_addr);
    } else {

    }
    bank = 4U;
    goto ldv_55954;
  } else {

  }
  if ((unsigned int )efuse_data == 255U) {
    goto ldv_55954;
  } else {

  }
  if (((int )efuse_data & 31) == 15) {
    hoffset = (int )efuse_data >> 5;
    efuse_addr = (u16 )((int )efuse_addr + 1);
    efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
    if (((int )efuse_data & 15) == 15) {
      efuse_addr = (u16 )((int )efuse_addr + 1);
      goto ldv_55955;
    } else {

    }
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
    hworden = (unsigned int )efuse_data & 15U;
  } else {
    hoffset = (u8 )((int )efuse_data >> 4);
    hworden = (unsigned int )efuse_data & 15U;
  }
  word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
  efuse_addr = ((unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr) + 1U;
  ldv_55955: ;
  if ((unsigned int )efuse_addr <= 511U) {
    goto ldv_55956;
  } else {

  }
  ldv_55954: ;
  if ((int )efuse_addr < (int )retU2) {
    goto ldv_55953;
  } else {

  }
  bank = (u8 )((int )bank + 1);
  ldv_55958: ;
  if ((unsigned int )bank <= 3U) {
    goto ldv_55957;
  } else {

  }
  ldv_55953: 
  retU2 = (unsigned int )((u16 )((int )bank + -1)) * 512U + (unsigned int )efuse_addr;
  pHalData->BTEfuseUsedBytes = retU2;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: CurrentSize =%d\n", "rtl8723a_EfuseGetCurrentSize_BT",
           (int )retU2);
  } else {

  }
  return (retU2);
}
}
void rtl8723a_read_chip_version(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  struct hal_version ChipVersion ;
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  value32 = rtl8723au_read32(padapter, 240);
  ChipVersion.ICType = 4;
  ChipVersion.ChipType = ((unsigned long )value32 & 8388608UL) == 0UL;
  pHalData->rf_type = 3U;
  ChipVersion.VendorType = ((unsigned long )value32 & 524288UL) != 0UL;
  ChipVersion.CUTVersion = (enum hal_cut_version )((value32 & 61440U) >> 12);
  pHalData->RegulatorMode = ((unsigned long )value32 & 16777216UL) != 0UL;
  value32 = rtl8723au_read32(padapter, 244);
  ChipVersion.ROMVer = (u8 )(((unsigned long )value32 & 4026531840UL) >> 20);
  pHalData->MultiFunc = 0;
  value32 = rtl8723au_read32(padapter, 104);
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 4UL) != 0UL ? 1U : 0U));
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 262144UL) != 0UL ? 2U : 0U));
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 4194304UL) != 0UL ? 4U : 0U));
  pHalData->PolarityCtl = ((unsigned long )value32 & 2UL) != 0UL;
  pHalData->VersionID = ChipVersion;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: RF_Type is %x!!\n", (int )pHalData->rf_type);
  } else {

  }
  return;
}
}
void SetBcnCtrlReg23a(struct rtw_adapter *padapter , u8 SetBits , u8 ClearBits ) 
{ 
  u8 val8 ;

  {
  val8 = rtl8723au_read8(padapter, 1360);
  val8 = (u8 )((int )val8 | (int )SetBits);
  val8 = (u8 )(~ ((int )((signed char )ClearBits)) & (int )((signed char )val8));
  rtl8723au_write8(padapter, 1360, (int )val8);
  return;
}
}
void rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  rtl8723au_write16(padapter, 1360, 4112);
  rtl8723au_write16(padapter, 1344, 25604);
  tmp = check_fwstate(& padapter->mlmepriv, 8);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    rtl8723au_write8(padapter, 1368, 5);
  } else {

  }
  rtl8723au_write8(padapter, 1369, 2);
  rtl8723au_write16(padapter, 1296, 26127);
  return;
}
}
static void ResumeTxBeacon(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "+ResumeTxBeacon\n");
  } else {

  }
  pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
  rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl);
  rtl8723au_write8(padapter, 1345, 255);
  pHalData->RegReg542 = (u8 )((unsigned int )pHalData->RegReg542 | 1U);
  rtl8723au_write8(padapter, 1346, (int )pHalData->RegReg542);
  return;
}
}
static void StopTxBeacon(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "+StopTxBeacon\n");
  } else {

  }
  pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
  rtl8723au_write8(padapter, 1058, (int )pHalData->RegFwHwTxQCtrl);
  rtl8723au_write8(padapter, 1345, 100);
  pHalData->RegReg542 = (unsigned int )pHalData->RegReg542 & 254U;
  rtl8723au_write8(padapter, 1346, (int )pHalData->RegReg542);
  return;
}
}
static void _BeaconFunctionEnable(struct rtw_adapter *padapter , u8 Enable , u8 Linked ) 
{ 


  {
  SetBcnCtrlReg23a(padapter, 26, 0);
  rtl8723au_write8(padapter, 1317, 111);
  return;
}
}
void rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  rtl8723au_write16(padapter, 1370, 2);
  rtl8723au_write16(padapter, 1364, (int )pmlmeinfo->bcn_interval);
  rtl8723a_InitBeaconParameters(padapter);
  rtl8723au_write8(padapter, 1307, 9);
  value32 = rtl8723au_read32(padapter, 1540);
  value32 = value32 & 4294967294U;
  rtl8723au_write32(padapter, 1540, value32);
  value32 = value32 | 1U;
  rtl8723au_write32(padapter, 1540, value32);
  tmp = check_fwstate(& padapter->mlmepriv, 112);
  if ((int )tmp) {
    rtl8723au_write8(padapter, 1374, 80);
    rtl8723au_write8(padapter, 1375, 80);
  } else {

  }
  _BeaconFunctionEnable(padapter, 1, 1);
  ResumeTxBeacon(padapter);
  SetBcnCtrlReg23a(padapter, 2, 0);
  return;
}
}
void rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter , enum hal_odm_variable eVariable ,
                           void *pValue1 , bool bSet ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *podmpriv ;
  struct sta_info *psta ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  podmpriv = & pHalData->odmpriv;
  switch ((unsigned int )eVariable) {
  case 0U: 
  psta = (struct sta_info *)pValue1;
  if ((int )bSet) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Set STA_(%d) info\n", psta->mac_id);
    } else {

    }
    ODM_CmnInfoPtrArrayHook23a(podmpriv, 28, (int )((u16 )psta->mac_id), (void *)psta);
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Clean STA_(%d) info\n", psta->mac_id);
    } else {

    }
    ODM_CmnInfoPtrArrayHook23a(podmpriv, 28, (int )((u16 )psta->mac_id), (void *)0);
  }
  goto ldv_56003;
  case 1U: 
  ODM_CmnInfoUpdate23a(podmpriv, 14U, (u64 )bSet);
  goto ldv_56003;
  case 2U: 
  ODM_CmnInfoUpdate23a(podmpriv, 15U, (u64 )bSet);
  goto ldv_56003;
  default: ;
  goto ldv_56003;
  }
  ldv_56003: ;
  return;
}
}
void rtl8723a_notch_filter(struct rtw_adapter *adapter , bool enable ) 
{ 
  u8 tmp ;
  u8 tmp___0 ;

  {
  if ((int )enable) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Enable notch filter\n");
    } else {

    }
    tmp = rtl8723au_read8(adapter, 3137);
    rtl8723au_write8(adapter, 3137, (int )((unsigned int )tmp | 2U));
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Disable notch filter\n");
    } else {

    }
    tmp___0 = rtl8723au_read8(adapter, 3137);
    rtl8723au_write8(adapter, 3137, (int )tmp___0 & 253);
  }
  return;
}
}
bool c2h_id_filter_ccx_8723a(u8 id ) 
{ 
  bool ret ;

  {
  ret = 0;
  if ((unsigned int )id == 3U) {
    ret = 1;
  } else {

  }
  return (ret);
}
}
int c2h_handler_8723a(struct rtw_adapter *padapter , struct c2h_evt_hdr *c2h_evt ) 
{ 
  int ret ;
  u8 i ;

  {
  ret = 1;
  i = 0U;
  if ((unsigned long )c2h_evt == (unsigned long )((struct c2h_evt_hdr *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s c2h_evt is NULL\n", "c2h_handler_8723a");
    } else {

    }
    ret = 0;
    goto exit;
  } else {

  }
  switch ((int )c2h_evt->id) {
  case 0: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "C2HCommandHandler: %s\n", (u8 *)(& c2h_evt->payload));
  } else {

  }
  goto ldv_56024;
  case 3: 
  handle_txrpt_ccx_8723a(padapter, (void *)(& c2h_evt->payload));
  goto ldv_56024;
  case 6: ;
  goto ldv_56024;
  case 10: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "[BT], C2H_HW_INFO_EXCH\n");
  } else {

  }
  i = 0U;
  goto ldv_56029;
  ldv_56028: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "[BT], tmpBuf[%d]= 0x%x\n", (int )i, (int )c2h_evt->payload[(int )i]);
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56029: ;
  if ((int )i < (int )c2h_evt->plen) {
    goto ldv_56028;
  } else {

  }

  goto ldv_56024;
  case 11: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "[BT], C2H_H2C_TEST\n");
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "[BT], tmpBuf[0]/[1]/[2]/[3]/[4]= 0x%x/ 0x%x/ 0x%x/ 0x%x/ 0x%x\n",
             (int )c2h_evt->payload[0], (int )c2h_evt->payload[1], (int )c2h_evt->payload[2],
             (int )c2h_evt->payload[3], (int )c2h_evt->payload[4]);
  } else {

  }
  goto ldv_56024;
  case 12: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s ,  Got  C2H_BT_INFO \n", "c2h_handler_8723a");
  } else {

  }
  rtl8723a_fw_c2h_BT_info(padapter, (u8 *)(& c2h_evt->payload), (int )c2h_evt->plen);
  goto ldv_56024;
  default: 
  ret = 0;
  goto ldv_56024;
  }
  ldv_56024: ;
  exit: ;
  return (ret);
}
}
void handle_txrpt_ccx_8723a(struct rtw_adapter *adapter , void *buf ) 
{ 
  struct txrpt_ccx_8723a *txrpt_ccx ;
  struct submit_ctx *pack_tx_ops ;

  {
  txrpt_ccx = (struct txrpt_ccx_8723a *)buf;
  pack_tx_ops = & adapter->xmitpriv.ack_tx_ops;
  if ((unsigned int )*((unsigned char *)txrpt_ccx + 0UL) != 0U && adapter->xmitpriv.ack_tx != 0) {
    if ((unsigned int )*((unsigned char *)txrpt_ccx + 1UL) != 0U) {
      rtw23a_sctx_done_err(& pack_tx_ops, 0);
    } else {
      rtw23a_sctx_done_err(& pack_tx_ops, 8);
    }
  } else {

  }
  return;
}
}
void rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
  val = rtl8723au_read8(padapter, 78);
  val = (u8 )((unsigned int )val | 128U);
  rtl8723au_write8(padapter, 78, (int )val);
  return;
}
}
void rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
  val = rtl8723au_read8(padapter, 78);
  if ((int )((signed char )val) >= 0) {
    val = (u8 )((unsigned int )val | 128U);
    rtl8723au_write8(padapter, 78, (int )val);
  } else {

  }
  return;
}
}
void rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
  val = rtl8723au_read8(padapter, 78);
  val = (unsigned int )val & 127U;
  rtl8723au_write8(padapter, 78, (int )val);
  return;
}
}
void rtl8723a_init_default_value(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 i ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pHalData->bIQKInitialized = 0U;
  if ((unsigned int )padapter->pwrctrlpriv.bkeepfwalive == 0U) {
    pHalData->LastHMEBoxNum = 0U;
  } else {

  }
  pHalData->bIQKInitialized = 0U;
  pdmpriv->TM_Trigger = 0U;
  pdmpriv->ThermalValue_HP_index = 0U;
  i = 0U;
  goto ldv_56059;
  ldv_56058: 
  pdmpriv->ThermalValue_HP[(int )i] = 0U;
  i = (u8 )((int )i + 1);
  ldv_56059: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_56058;
  } else {

  }
  pHalData->EfuseUsedBytes = 0U;
  pHalData->BTEfuseUsedBytes = 0U;
  return;
}
}
u8 GetEEPROMSize8723A(struct rtw_adapter *padapter ) 
{ 
  u8 size ;
  u32 cr ;
  u16 tmp ;

  {
  size = 0U;
  tmp = rtl8723au_read16(padapter, 10);
  cr = (u32 )tmp;
  size = ((unsigned long )cr & 16UL) != 0UL ? 6U : 4U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: EEPROM type is %s\n", (unsigned int )size == 4U ? (char *)"E-FUSE" : (char *)"93C46");
  } else {

  }
  return (size);
}
}
static int _LLTWrite(struct rtw_adapter *padapter , u32 address , u32 data ) 
{ 
  int status ;
  s32 count ;
  u32 value ;
  u16 LLTReg ;
  s32 tmp ;

  {
  status = 1;
  count = 0;
  value = (((address << 8) & 65535U) | (data & 255U)) | 1073741824U;
  LLTReg = 480U;
  rtl8723au_write32(padapter, (int )LLTReg, value);
  ldv_56076: 
  value = rtl8723au_read32(padapter, (int )LLTReg);
  if (value >> 30 == 0U) {
    goto ldv_56075;
  } else {

  }
  if (count > 20) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16384, 4, "Failed to polling write LLT done at address %d!\n", address);
    } else {

    }
    status = 0;
    goto ldv_56075;
  } else {

  }
  tmp = count;
  count = count + 1;
  if (tmp != 0) {
    goto ldv_56076;
  } else {

  }
  ldv_56075: ;
  return (status);
}
}
s32 InitLLTTable23a(struct rtw_adapter *padapter , u32 boundary ) 
{ 
  int status ;
  u32 i ;
  u32 txpktbuf_bndy ;
  u32 Last_Entry_Of_TxPktBuf ;

  {
  status = 1;
  txpktbuf_bndy = boundary;
  Last_Entry_Of_TxPktBuf = 255U;
  i = 0U;
  goto ldv_56086;
  ldv_56085: 
  status = _LLTWrite(padapter, i, i + 1U);
  if (status != 1) {
    return (status);
  } else {

  }
  i = i + 1U;
  ldv_56086: ;
  if (txpktbuf_bndy - 1U > i) {
    goto ldv_56085;
  } else {

  }
  status = _LLTWrite(padapter, txpktbuf_bndy - 1U, 255U);
  if (status != 1) {
    return (status);
  } else {

  }
  i = txpktbuf_bndy;
  goto ldv_56089;
  ldv_56088: 
  status = _LLTWrite(padapter, i, i + 1U);
  if (status != 1) {
    return (status);
  } else {

  }
  i = i + 1U;
  ldv_56089: ;
  if (i < Last_Entry_Of_TxPktBuf) {
    goto ldv_56088;
  } else {

  }
  status = _LLTWrite(padapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
  if (status != 1) {
    return (status);
  } else {

  }
  return (status);
}
}
static void _DisableGPIO(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  u32 u4bTmp ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  rtl8723au_write16(padapter, 70, 0);
  tmp = rtl8723au_read32(padapter, 68);
  value32 = tmp & 4294902015U;
  u4bTmp = value32 & 255U;
  value32 = ((u4bTmp << 8) | value32) | 16711680U;
  rtl8723au_write32(padapter, 68, value32);
  rtl8723au_write16(padapter, 98, 0);
  tmp___0 = rtl8723au_read32(padapter, 96);
  value32 = tmp___0 & 4294901791U;
  u4bTmp = value32 & 31U;
  value32 = ((u4bTmp << 8) | value32) | 1900544U;
  rtl8723au_write32(padapter, 96, value32);
  rtl8723au_write16(padapter, 76, 32896);
  return;
}
}
static void _DisableRFAFEAndResetBB8192C(struct rtw_adapter *padapter ) 
{ 
  u8 value8 ;

  {
  rtl8723au_write8(padapter, 1314, 255);
  PHY_SetRFReg(padapter, 0, 0U, 255U, 0U);
  value8 = 64U;
  rtl8723au_write8(padapter, 1536, (int )value8);
  value8 = 22U;
  rtl8723au_write8(padapter, 2, (int )value8);
  value8 = (unsigned int )value8 & 253U;
  rtl8723au_write8(padapter, 2, (int )value8);
  return;
}
}
static void _ResetDigitalProcedure1_92C(struct rtw_adapter *padapter , bool bWithoutHWSM ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 valu16 ;
  u16 tmp ;
  u8 retry_cnts ;
  u8 val8 ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  unsigned long __ms ;
  unsigned long tmp___2 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (((int )((struct hal_data_8723a *)padapter->HalData)->FirmwareSignature & 65520) == 35008 && (unsigned int )pHalData->FirmwareVersion <= 32U) {
    rtl8723au_write8(padapter, 128, 0);
    valu16 = rtl8723au_read16(padapter, 2);
    rtl8723au_write16(padapter, 2, (int )valu16 & 64511);
    tmp = rtl8723au_read16(padapter, 2);
    valu16 = (unsigned int )tmp & 4095U;
    rtl8723au_write16(padapter, 2, (int )((unsigned int )valu16 | 20480U));
    valu16 = rtl8723au_read16(padapter, 2);
    rtl8723au_write16(padapter, 2, (int )((unsigned int )valu16 | 1024U));
  } else {
    retry_cnts = 0U;
    val8 = rtl8723au_read8(padapter, 128);
    if (((unsigned long )val8 & 2UL) != 0UL && (unsigned int )padapter->bFWReady != 0U) {
      rtl8723au_write8(padapter, 304, 32);
      rtl8723au_write8(padapter, 312, 0);
      rtl8723au_write8(padapter, 80, 0);
      rtl8723au_write8(padapter, 463, 32);
      goto ldv_56109;
      ldv_56108: 
      __const_udelay(214750UL);
      ldv_56109: 
      tmp___0 = retry_cnts;
      retry_cnts = (u8 )((int )retry_cnts + 1);
      if ((unsigned int )tmp___0 <= 99U) {
        tmp___1 = rtl8723au_read16(padapter, 2);
        if (((unsigned long )tmp___1 & 1024UL) != 0UL) {
          goto ldv_56108;
        } else {
          goto ldv_56110;
        }
      } else {

      }
      ldv_56110: ;
      if ((unsigned int )retry_cnts > 99U) {
        rtl8723au_write8(padapter, 3, 80);
        __ms = 10UL;
        goto ldv_56113;
        ldv_56112: 
        __const_udelay(4295000UL);
        ldv_56113: 
        tmp___2 = __ms;
        __ms = __ms - 1UL;
        if (tmp___2 != 0UL) {
          goto ldv_56112;
        } else {

        }

      } else {

      }
    } else {

    }
    rtl8723au_write8(padapter, 3, 84);
    rtl8723au_write8(padapter, 128, 0);
  }
  if ((int )bWithoutHWSM) {
    rtl8723au_write16(padapter, 8, 28835);
    rtl8723au_write8(padapter, 40, 128);
    rtl8723au_write16(padapter, 36, 34831);
    rtl8723au_write8(padapter, 0, 249);
  } else {
    rtl8723au_write8(padapter, 31, 0);
  }
  return;
}
}
static void _ResetDigitalProcedure2(struct rtw_adapter *padapter ) 
{ 


  {
  rtl8723au_write16(padapter, 8, 28835);
  rtl8723au_write8(padapter, 1, 130);
  return;
}
}
static void _DisableAnalog(struct rtw_adapter *padapter , bool bWithoutHWSM ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 value16 ;
  u8 value8 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((int )bWithoutHWSM) {
    rtl8723au_write8(padapter, 32, 4);
    value8 = rtl8723au_read8(padapter, 33);
    value8 = (unsigned int )value8 & 254U;
    rtl8723au_write8(padapter, 33, (int )value8);
  } else {

  }
  value8 = 35U;
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U)) {
    value8 = (u8 )((unsigned int )value8 | 8U);
  } else {

  }
  rtl8723au_write8(padapter, 17, (int )value8);
  if ((int )bWithoutHWSM) {
    value16 = 18434U;
  } else {
    value16 = 18434U;
  }
  rtl8723au_write16(padapter, 4, (int )value16);
  rtl8723au_write8(padapter, 28, 14);
  return;
}
}
s32 CardDisableHWSM(struct rtw_adapter *padapter , u8 resetMCU ) 
{ 


  {
  if (padapter->bSurpriseRemoved != 0) {
    return (1);
  } else {

  }
  _DisableRFAFEAndResetBB8192C(padapter);
  _ResetDigitalProcedure1_92C(padapter, 0);
  _DisableGPIO(padapter);
  _DisableAnalog(padapter, 0);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "======> Card disable finished.\n");
  } else {

  }
  return (1);
}
}
s32 CardDisableWithoutHWSM(struct rtw_adapter *padapter ) 
{ 


  {
  if (padapter->bSurpriseRemoved != 0) {
    return (1);
  } else {

  }
  _DisableRFAFEAndResetBB8192C(padapter);
  _ResetDigitalProcedure1_92C(padapter, 1);
  _DisableGPIO(padapter);
  _ResetDigitalProcedure2(padapter);
  _DisableAnalog(padapter, 1);
  return (1);
}
}
void Hal_InitPGData(struct rtw_adapter *padapter , u8 *PROMContent ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
  pEEPROM = & padapter->eeprompriv;
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 0U) {
    if ((unsigned int )pEEPROM->EepromOrEfuse == 0U) {
      EFUSE_ShadowMapUpdate23a(padapter, 0);
      memcpy((void *)PROMContent, (void const   *)(& pEEPROM->efuse_eeprom_data),
               256UL);
    } else {

    }
  } else {
    if (GlobalDebugLevel23A > 5U) {
      rt_trace(32768, 6, "AutoLoad Fail reported from CR9346!!\n");
    } else {

    }
    if ((unsigned int )pEEPROM->EepromOrEfuse == 0U) {
      EFUSE_ShadowMapUpdate23a(padapter, 0);
    } else {

    }
    memcpy((void *)PROMContent, (void const   *)(& pEEPROM->efuse_eeprom_data),
             256UL);
  }
  return;
}
}
void Hal_EfuseParseIDCode(struct rtw_adapter *padapter , u8 *hwinfo ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u16 EEPROMId ;

  {
  pEEPROM = & padapter->eeprompriv;
  EEPROMId = *((__le16 *)hwinfo);
  if ((unsigned int )EEPROMId != 33065U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: EEPROM ID(%#x) is invalid!!\n", (int )EEPROMId);
    } else {

    }
    pEEPROM->bautoload_fail_flag = 1U;
  } else {
    pEEPROM->bautoload_fail_flag = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16384, 7, "EEPROM ID = 0x%04x\n", (int )EEPROMId);
  } else {

  }
  return;
}
}
static void Hal_EEValueCheck(u8 EEType , void *pInValue , void *pOutValue ) 
{ 
  u8 *pIn ;
  u8 *pOut ;

  {
  switch ((int )EEType) {
  case 0: 
  pIn = (u8 *)pInValue;
  pOut = (u8 *)pOutValue;
  if ((unsigned int )*pIn <= 63U) {
    *pOut = *pIn;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(32768, 4, "EETYPE_TX_PWR, value =%d is invalid, set to default = 0x%x\n",
               (int )*pIn, 34);
    } else {

    }
    *pOut = 34U;
  }
  goto ldv_56151;
  default: ;
  goto ldv_56151;
  }
  ldv_56151: ;
  return;
}
}
static void Hal_ReadPowerValueFromPROM_8723A(struct txpowerinfo *pwrInfo , u8 *PROMContent ,
                                             bool AutoLoadFail ) 
{ 
  u32 rfPath ;
  u32 eeAddr ;
  u32 group ;
  u32 rfPathMax ;

  {
  rfPathMax = 1U;
  memset((void *)pwrInfo, 0, 180UL);
  if ((int )AutoLoadFail) {
    group = 0U;
    goto ldv_56166;
    ldv_56165: 
    rfPath = 0U;
    goto ldv_56163;
    ldv_56162: 
    pwrInfo->CCKIndex[rfPath][group] = 34U;
    pwrInfo->HT40_1SIndex[rfPath][group] = 34U;
    pwrInfo->HT40_2SIndexDiff[rfPath][group] = 0U;
    pwrInfo->HT20IndexDiff[rfPath][group] = 2U;
    pwrInfo->OFDMIndexDiff[rfPath][group] = 3U;
    pwrInfo->HT40MaxOffset[rfPath][group] = 0U;
    pwrInfo->HT20MaxOffset[rfPath][group] = 0U;
    rfPath = rfPath + 1U;
    ldv_56163: ;
    if (rfPath < rfPathMax) {
      goto ldv_56162;
    } else {

    }
    group = group + 1U;
    ldv_56166: ;
    if (group <= 11U) {
      goto ldv_56165;
    } else {

    }
    pwrInfo->TSSI_A[0] = 0U;
    return;
  } else {

  }
  rfPath = 0U;
  goto ldv_56172;
  ldv_56171: 
  group = 0U;
  goto ldv_56169;
  ldv_56168: 
  eeAddr = (rfPath * 3U + group) + 16U;
  Hal_EEValueCheck(0, (void *)PROMContent + (unsigned long )eeAddr, (void *)(& pwrInfo->CCKIndex) + ((unsigned long )rfPath + (unsigned long )group));
  eeAddr = (rfPath * 3U + group) + 22U;
  Hal_EEValueCheck(0, (void *)PROMContent + (unsigned long )eeAddr, (void *)(& pwrInfo->HT40_1SIndex) + ((unsigned long )rfPath + (unsigned long )group));
  group = group + 1U;
  ldv_56169: ;
  if (group <= 11U) {
    goto ldv_56168;
  } else {

  }
  rfPath = rfPath + 1U;
  ldv_56172: ;
  if (rfPath < rfPathMax) {
    goto ldv_56171;
  } else {

  }
  group = 0U;
  goto ldv_56178;
  ldv_56177: 
  rfPath = 0U;
  goto ldv_56175;
  ldv_56174: 
  pwrInfo->HT40_2SIndexDiff[rfPath][group] = 0U;
  pwrInfo->HT20IndexDiff[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 28U)) >> (int )(rfPath * 4U))) & 15U;
  if (((unsigned long )pwrInfo->HT20IndexDiff[rfPath][group] & 8UL) != 0UL) {
    pwrInfo->HT20IndexDiff[rfPath][group] = (u8 )((unsigned int )pwrInfo->HT20IndexDiff[rfPath][group] | 240U);
  } else {

  }
  pwrInfo->OFDMIndexDiff[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 31U)) >> (int )(rfPath * 4U))) & 15U;
  pwrInfo->HT40MaxOffset[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 34U)) >> (int )(rfPath * 4U))) & 15U;
  pwrInfo->HT20MaxOffset[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 37U)) >> (int )(rfPath * 4U))) & 15U;
  rfPath = rfPath + 1U;
  ldv_56175: ;
  if (rfPath < rfPathMax) {
    goto ldv_56174;
  } else {

  }
  group = group + 1U;
  ldv_56178: ;
  if (group <= 11U) {
    goto ldv_56177;
  } else {

  }
  pwrInfo->TSSI_A[0] = *(PROMContent + 41UL);
  return;
}
}
static u8 Hal_GetChnlGroup(u8 chnl ) 
{ 
  u8 group ;

  {
  group = 0U;
  if ((unsigned int )chnl <= 2U) {
    group = 0U;
  } else
  if ((unsigned int )chnl <= 8U) {
    group = 1U;
  } else {
    group = 2U;
  }
  return (group);
}
}
void Hal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                     bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct txpowerinfo pwrInfo ;
  u8 rfPath ;
  u8 ch ;
  u8 group ;
  u8 rfPathMax ;
  u8 pwr ;
  u8 diff ;
  struct registry_priv *registry_par ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  rfPathMax = 1U;
  Hal_ReadPowerValueFromPROM_8723A(& pwrInfo, PROMContent, (int )AutoLoadFail);
  rfPath = 0U;
  goto ldv_56201;
  ldv_56200: 
  ch = 0U;
  goto ldv_56198;
  ldv_56197: 
  group = Hal_GetChnlGroup((int )ch);
  pHalData->TxPwrLevelCck[(int )rfPath][(int )ch] = pwrInfo.CCKIndex[(int )rfPath][(int )group];
  pHalData->TxPwrLevelHT40_1S[(int )rfPath][(int )ch] = pwrInfo.HT40_1SIndex[(int )rfPath][(int )group];
  pHalData->TxPwrHt20Diff[(int )rfPath][(int )ch] = pwrInfo.HT20IndexDiff[(int )rfPath][(int )group];
  pHalData->TxPwrLegacyHtDiff[(int )rfPath][(int )ch] = pwrInfo.OFDMIndexDiff[(int )rfPath][(int )group];
  pHalData->PwrGroupHT20[(int )rfPath][(int )ch] = pwrInfo.HT20MaxOffset[(int )rfPath][(int )group];
  pHalData->PwrGroupHT40[(int )rfPath][(int )ch] = pwrInfo.HT40MaxOffset[(int )rfPath][(int )group];
  pwr = pwrInfo.HT40_1SIndex[(int )rfPath][(int )group];
  diff = pwrInfo.HT40_2SIndexDiff[(int )rfPath][(int )group];
  pHalData->TxPwrLevelHT40_2S[(int )rfPath][(int )ch] = (int )pwr > (int )diff ? (int )pwr - (int )diff : 0U;
  ch = (u8 )((int )ch + 1);
  ldv_56198: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_56197;
  } else {

  }
  rfPath = (u8 )((int )rfPath + 1);
  ldv_56201: ;
  if ((int )rfPath < (int )rfPathMax) {
    goto ldv_56200;
  } else {

  }
  rfPath = 0U;
  goto ldv_56207;
  ldv_56206: 
  ch = 0U;
  goto ldv_56204;
  ldv_56203: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "RF(%u)-Ch(%u) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",
             (int )rfPath, (int )ch, (int )pHalData->TxPwrLevelCck[(int )rfPath][(int )ch],
             (int )pHalData->TxPwrLevelHT40_1S[(int )rfPath][(int )ch], (int )pHalData->TxPwrLevelHT40_2S[(int )rfPath][(int )ch]);
  } else {

  }
  ch = (u8 )((int )ch + 1);
  ldv_56204: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_56203;
  } else {

  }
  rfPath = (u8 )((int )rfPath + 1);
  ldv_56207: ;
  if ((unsigned int )rfPath <= 1U) {
    goto ldv_56206;
  } else {

  }
  ch = 0U;
  goto ldv_56210;
  ldv_56209: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "RF-A Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", (int )ch, (int )pHalData->TxPwrHt20Diff[0][(int )ch],
             (int )pHalData->TxPwrHt20Diff[0][(int )ch]);
  } else {

  }
  ch = (u8 )((int )ch + 1);
  ldv_56210: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_56209;
  } else {

  }
  ch = 0U;
  goto ldv_56213;
  ldv_56212: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "RF-A Legacy to Ht40 Diff[%u] = 0x%x\n", (int )ch, (int )pHalData->TxPwrLegacyHtDiff[0][(int )ch]);
  } else {

  }
  ch = (u8 )((int )ch + 1);
  ldv_56213: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_56212;
  } else {

  }
  ch = 0U;
  goto ldv_56216;
  ldv_56215: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "RF-B Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", (int )ch, (int )pHalData->TxPwrHt20Diff[1][(int )ch],
             (int )pHalData->TxPwrHt20Diff[1][(int )ch]);
  } else {

  }
  ch = (u8 )((int )ch + 1);
  ldv_56216: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_56215;
  } else {

  }
  ch = 0U;
  goto ldv_56219;
  ldv_56218: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "RF-B Legacy to HT40 Diff[%u] = 0x%x\n", (int )ch, (int )pHalData->TxPwrLegacyHtDiff[1][(int )ch]);
  } else {

  }
  ch = (u8 )((int )ch + 1);
  ldv_56219: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_56218;
  } else {

  }

  if (! AutoLoadFail) {
    registry_par = & padapter->registrypriv;
    if ((unsigned int )registry_par->regulatory_tid == 255U) {
      if ((unsigned int )*(PROMContent + 43UL) == 255U) {
        pHalData->EEPROMRegulatory = 0U;
      } else {
        pHalData->EEPROMRegulatory = (unsigned int )*(PROMContent + 43UL) & 7U;
      }
    } else {
      pHalData->EEPROMRegulatory = registry_par->regulatory_tid;
    }
  } else {
    pHalData->EEPROMRegulatory = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "EEPROMRegulatory = 0x%x\n", (int )pHalData->EEPROMRegulatory);
  } else {

  }
  if (! AutoLoadFail) {
    pHalData->bTXPowerDataReadFromEEPORM = 1U;
  } else {

  }
  return;
}
}
void Hal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter , u8 *hwinfo ,
                                       bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tempval ;
  u32 tmpu4 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (! AutoLoadFail) {
    tmpu4 = rtl8723au_read32(padapter, 104);
    if (((unsigned long )tmpu4 & 262144UL) != 0UL) {
      pHalData->EEPROMBluetoothCoexist = 1U;
    } else {
      pHalData->EEPROMBluetoothCoexist = 0U;
    }
    pHalData->EEPROMBluetoothType = 6U;
    tempval = *(hwinfo + 46UL);
    pHalData->EEPROMBluetoothAntNum = (unsigned int )tempval & 1U;
    pHalData->EEPROMBluetoothAntIsolation = (u8 )(((int )tempval & 16) >> 4);
    pHalData->EEPROMBluetoothRadioShared = (u8 )(((int )tempval & 32) >> 5);
  } else {
    pHalData->EEPROMBluetoothCoexist = 0U;
    pHalData->EEPROMBluetoothType = 6U;
    pHalData->EEPROMBluetoothAntNum = 0U;
    pHalData->EEPROMBluetoothAntIsolation = 0U;
    pHalData->EEPROMBluetoothRadioShared = 0U;
  }
  rtl8723a_BT_init_hal_vars(padapter);
  return;
}
}
void Hal_EfuseParseEEPROMVer(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (! AutoLoadFail) {
    pHalData->EEPROMVersion = *(hwinfo + 48UL);
  } else {
    pHalData->EEPROMVersion = 1U;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "Hal_EfuseParseEEPROMVer(), EEVer = %d\n", (int )pHalData->EEPROMVersion);
  } else {

  }
  return;
}
}
void rtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 


  {
  padapter->mlmepriv.ChannelPlan = hal_com_get_channel_plan23a(padapter, (unsigned long )hwinfo != (unsigned long )((u8 *)0U) ? (int )*(hwinfo + 40UL) : 255,
                                                               (int )padapter->registrypriv.channel_plan,
                                                               10, (int )AutoLoadFail);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: mlmepriv.ChannelPlan = 0x%02x\n", (int )padapter->mlmepriv.ChannelPlan);
  } else {

  }
  return;
}
}
void Hal_EfuseParseCustomerID(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (! AutoLoadFail) {
    pHalData->EEPROMCustomerID = *(hwinfo + 49UL);
    pHalData->EEPROMSubCustomerID = *(hwinfo + 50UL);
  } else {
    pHalData->EEPROMCustomerID = 0U;
    pHalData->EEPROMSubCustomerID = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "EEPROM Customer ID: 0x%2x\n", (int )pHalData->EEPROMCustomerID);
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "EEPROM SubCustomer ID: 0x%02x\n", (int )pHalData->EEPROMSubCustomerID);
  } else {

  }
  return;
}
}
void Hal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 


  {
  return;
}
}
void Hal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter , u8 *hwinfo ,
                                        bool AutoLoadFail ) 
{ 


  {
  return;
}
}
void Hal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter , u8 *hwinfo , u8 AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  if ((unsigned int )AutoLoadFail == 0U) {
    pHalData->CrystalCap = *(hwinfo + 51UL);
    if ((unsigned int )pHalData->CrystalCap == 255U) {
      pHalData->CrystalCap = 32U;
    } else {

    }
  } else {
    pHalData->CrystalCap = 32U;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "%s: CrystalCap = 0x%2x\n", "Hal_EfuseParseXtal_8723A", (int )pHalData->CrystalCap);
  } else {

  }
  return;
}
}
void Hal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                      bool AutoloadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (! AutoloadFail) {
    pHalData->EEPROMThermalMeter = *(PROMContent + 42UL);
  } else {
    pHalData->EEPROMThermalMeter = 18U;
  }
  if ((unsigned int )pHalData->EEPROMThermalMeter == 255U || (int )AutoloadFail) {
    pHalData->bAPKThermalMeterIgnore = 1U;
    pHalData->EEPROMThermalMeter = 18U;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: ThermalMeter = 0x%x\n", "Hal_EfuseParseThermalMeter_8723A",
           (int )pHalData->EEPROMThermalMeter);
  } else {

  }
  return;
}
}
static void rtl8723a_cal_txdesc_chksum(struct tx_desc *ptxdesc ) 
{ 
  u16 *usPtr ;
  u32 count ;
  u32 index ;
  u16 checksum ;

  {
  usPtr = (u16 *)ptxdesc;
  count = 16U;
  checksum = 0U;
  ptxdesc->txdw7 = ptxdesc->txdw7 & 4294901760U;
  index = 0U;
  goto ldv_56279;
  ldv_56278: 
  checksum = (u16 )((int )*(usPtr + (unsigned long )index) ^ (int )checksum);
  index = index + 1U;
  ldv_56279: ;
  if (index < count) {
    goto ldv_56278;
  } else {

  }
  ptxdesc->txdw7 = ptxdesc->txdw7 | (__le32 )checksum;
  return;
}
}
void rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter , u8 *pDesc , u32 BufferLen ,
                               u8 IsPsPoll , u8 IsBTQosNull ) 
{ 
  struct tx_desc *ptxdesc ;

  {
  ptxdesc = (struct tx_desc *)pDesc;
  memset((void *)pDesc, 0, 32UL);
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2348810240U;
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2097152U;
  ptxdesc->txdw0 = ptxdesc->txdw0 | (BufferLen & 65535U);
  ptxdesc->txdw1 = ptxdesc->txdw1 | 4608U;
  if ((unsigned int )IsPsPoll != 0U) {
    ptxdesc->txdw1 = ptxdesc->txdw1 | 1048576U;
  } else {
    ptxdesc->txdw4 = ptxdesc->txdw4 | 128U;
    ptxdesc->txdw3 = ptxdesc->txdw3 | 2147483648U;
  }
  if ((unsigned int )IsBTQosNull == 1U) {
    ptxdesc->txdw2 = ptxdesc->txdw2 | 8388608U;
  } else {

  }
  ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
  rtl8723a_cal_txdesc_chksum(ptxdesc);
  return;
}
}
void hw_var_set_opmode(struct rtw_adapter *padapter , u8 mode ) 
{ 
  u8 val8 ;

  {
  if ((unsigned int )mode == 2U || (unsigned int )mode == 0U) {
    StopTxBeacon(padapter);
    val8 = 25U;
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else
  if ((unsigned int )mode == 1U) {
    ResumeTxBeacon(padapter);
    val8 = 26U;
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else
  if ((unsigned int )mode == 3U) {
    rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(padapter);
    ResumeTxBeacon(padapter);
    val8 = 18U;
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
    rtl8723au_write32(padapter, 1544, 1879057038U);
    rtl8723au_write16(padapter, 1700, 65535);
    rtl8723au_write16(padapter, 1698, 1024);
    rtl8723au_write8(padapter, 1369, 2);
    rtl8723au_write8(padapter, 1368, 5);
    rtl8723au_write8(padapter, 1370, 10);
    rtl8723au_write16(padapter, 1296, 0);
    rtl8723au_write16(padapter, 1344, 65284);
    rtl8723au_write16(padapter, 1304, 32767);
    rtl8723au_write8(padapter, 1363, 1);
    val8 = 30U;
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else {

  }
  val8 = rtl8723au_read8(padapter, 258);
  val8 = (u8 )(((int )((signed char )val8) & 12) | (int )((signed char )mode));
  rtl8723au_write8(padapter, 258, (int )val8);
  return;
}
}
void hw_var_set_macaddr(struct rtw_adapter *padapter , u8 *val ) 
{ 
  u8 idx ;
  u32 reg_macid ;

  {
  idx = 0U;
  reg_macid = 1552U;
  idx = 0U;
  goto ldv_56301;
  ldv_56300: 
  rtl8723au_write8(padapter, (int )((u16 )idx) + (int )((u16 )reg_macid), (int )*(val + (unsigned long )idx));
  idx = (u8 )((int )idx + 1);
  ldv_56301: ;
  if ((unsigned int )idx <= 5U) {
    goto ldv_56300;
  } else {

  }

  return;
}
}
void hw_var_set_bssid(struct rtw_adapter *padapter , u8 *val ) 
{ 
  u8 idx ;
  u32 reg_bssid ;

  {
  idx = 0U;
  reg_bssid = 1560U;
  idx = 0U;
  goto ldv_56310;
  ldv_56309: 
  rtl8723au_write8(padapter, (int )((u16 )idx) + (int )((u16 )reg_bssid), (int )*(val + (unsigned long )idx));
  idx = (u8 )((int )idx + 1);
  ldv_56310: ;
  if ((unsigned int )idx <= 5U) {
    goto ldv_56309;
  } else {

  }

  return;
}
}
void hw_var_set_correct_tsf(struct rtw_adapter *padapter ) 
{ 
  u64 tsf ;
  u32 reg_tsftr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  uint32_t __base ;
  uint32_t __rem ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  __base = (uint32_t )((int )pmlmeinfo->bcn_interval * 1024);
  __rem = (uint32_t )(pmlmeext->TSFValue % (u64 )__base);
  pmlmeext->TSFValue = pmlmeext->TSFValue / (u64 )__base;
  tsf = (pmlmeext->TSFValue - (u64 )__rem) - 1024ULL;
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
    StopTxBeacon(padapter);
  } else {

  }
  reg_tsftr = 1376U;
  SetBcnCtrlReg23a(padapter, 0, 8);
  rtl8723au_write32(padapter, (int )((u16 )reg_tsftr), (u32 )tsf);
  rtl8723au_write32(padapter, (int )((unsigned int )((u16 )reg_tsftr) + 4U), (u32 )(tsf >> 32));
  SetBcnCtrlReg23a(padapter, 8, 0);
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
    ResumeTxBeacon(padapter);
  } else {

  }
  return;
}
}
void hw_var_set_mlme_disconnect(struct rtw_adapter *padapter ) 
{ 


  {
  rtl8723au_write16(padapter, 1700, 0);
  rtl8723au_write8(padapter, 1363, 1);
  SetBcnCtrlReg23a(padapter, 16, 0);
  return;
}
}
void hw_var_set_mlme_join(struct rtw_adapter *padapter , u8 type ) 
{ 
  u8 RetryLimit ;
  struct hal_data_8723a *pHalData ;
  struct mlme_priv *pmlmepriv ;
  u32 v32 ;
  bool tmp ;
  bool tmp___0 ;

  {
  RetryLimit = 48U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pmlmepriv = & padapter->mlmepriv;
  if ((unsigned int )type == 0U) {
    rtl8723au_write16(padapter, 1700, 65535);
    v32 = rtl8723au_read32(padapter, 1544);
    v32 = v32 | 192U;
    rtl8723au_write32(padapter, 1544, v32);
    tmp = check_fwstate(pmlmepriv, 8);
    if ((int )tmp) {
      RetryLimit = (unsigned int )pHalData->CustomerID == 18U ? 7U : 48U;
    } else {
      RetryLimit = 7U;
    }
  } else
  if ((unsigned int )type == 1U) {
    rtl8723au_write16(padapter, 1700, 0);
  } else
  if ((unsigned int )type == 2U) {
    SetBcnCtrlReg23a(padapter, 0, 16);
    tmp___0 = check_fwstate(pmlmepriv, 96);
    if ((int )tmp___0) {
      rtl8723au_write8(padapter, 1346, 2);
      RetryLimit = 7U;
    } else {

    }
  } else {

  }
  rtl8723au_write16(padapter, 1066, (int )((u16 )((int )((short )((int )RetryLimit << 8)) | (int )((short )RetryLimit))));
  switch ((int )type) {
  case 0: 
  rtl8723a_BT_wifiassociate_notify(padapter, 1);
  goto ldv_56334;
  case 1: 
  rtl8723a_BT_wifiassociate_notify(padapter, 0);
  goto ldv_56334;
  case 2: ;
  goto ldv_56334;
  }
  ldv_56334: ;
  return;
}
}
bool ldv_queue_work_on_495(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_496(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_497(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_498(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_499(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_509(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_511(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_510(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_513(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_512(struct workqueue_struct *ldv_func_arg1 ) ;
void PHY_SetTxPowerLevel8723A(struct rtw_adapter *Adapter , u8 channel ) ;
int PHY_BBConfig8723A(struct rtw_adapter *Adapter ) ;
s32 PHY_MACConfig8723A(struct rtw_adapter *Adapter ) ;
void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ) ;
void rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter , u8 *pPowerlevel ) ;
void rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter , u8 *pPowerLevel ,
                                       u8 Channel ) ;
static u32 phy_CalculateBitShift(u32 BitMask ) 
{ 
  u32 i ;

  {
  i = 0U;
  goto ldv_55750;
  ldv_55749: ;
  if ((int )(BitMask >> (int )i) & 1) {
    goto ldv_55748;
  } else {

  }
  i = i + 1U;
  ldv_55750: ;
  if (i <= 31U) {
    goto ldv_55749;
  } else {

  }
  ldv_55748: ;
  return (i);
}
}
u32 PHY_QueryBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask ) 
{ 
  u32 ReturnValue ;
  u32 OriginalValue ;
  u32 BitShift ;

  {
  ReturnValue = 0U;
  OriginalValue = rtl8723au_read32(Adapter, (int )((u16 )RegAddr));
  BitShift = phy_CalculateBitShift(BitMask);
  ReturnValue = (OriginalValue & BitMask) >> (int )BitShift;
  return (ReturnValue);
}
}
void PHY_SetBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask , u32 Data ) 
{ 
  u32 OriginalValue ;
  u32 BitShift ;

  {
  if (BitMask != 4294967295U) {
    OriginalValue = rtl8723au_read32(Adapter, (int )((u16 )RegAddr));
    BitShift = phy_CalculateBitShift(BitMask);
    Data = (~ BitMask & OriginalValue) | (Data << (int )BitShift);
  } else {

  }
  rtl8723au_write32(Adapter, (int )((u16 )RegAddr), Data);
  return;
}
}
static u32 phy_RFSerialRead(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath ,
                            u32 Offset ) 
{ 
  u32 retValue ;
  struct hal_data_8723a *pHalData ;
  struct bb_reg_define *pPhyReg ;
  u32 NewOffset ;
  u32 tmplong ;
  u32 tmplong2 ;
  u8 RfPiEnable ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  retValue = 0U;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
  RfPiEnable = 0U;
  Offset = Offset & 63U;
  NewOffset = Offset;
  tmplong = rtl8723au_read32(Adapter, 2084);
  if ((unsigned int )eRFPath == 0U) {
    tmplong2 = tmplong;
  } else {
    tmplong2 = rtl8723au_read32(Adapter, (int )((u16 )pPhyReg->rfHSSIPara2));
  }
  tmplong2 = ((tmplong2 & 2155872255U) | (NewOffset << 23)) | 2147483648U;
  rtl8723au_write32(Adapter, 2084, tmplong & 2147483647U);
  __const_udelay(42950UL);
  rtl8723au_write32(Adapter, (int )((u16 )pPhyReg->rfHSSIPara2), tmplong2);
  __const_udelay(429500UL);
  rtl8723au_write32(Adapter, 2084, tmplong | 2147483648U);
  __const_udelay(42950UL);
  if ((unsigned int )eRFPath == 0U) {
    tmp = PHY_QueryBBReg(Adapter, 2080U, 256U);
    RfPiEnable = (unsigned char )tmp;
  } else
  if ((unsigned int )eRFPath == 1U) {
    tmp___0 = PHY_QueryBBReg(Adapter, 2088U, 256U);
    RfPiEnable = (unsigned char )tmp___0;
  } else {

  }
  if ((unsigned int )RfPiEnable != 0U) {
    retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi, 1048575U);
  } else {
    retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBack, 1048575U);
  }
  return (retValue);
}
}
static void phy_RFSerialWrite(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath ,
                              u32 Offset , u32 Data ) 
{ 
  u32 DataAndAddr ;
  struct hal_data_8723a *pHalData ;
  struct bb_reg_define *pPhyReg ;
  u32 NewOffset ;

  {
  DataAndAddr = 0U;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
  Offset = Offset & 63U;
  NewOffset = Offset;
  DataAndAddr = ((NewOffset << 20) | (Data & 1048575U)) & 268435455U;
  rtl8723au_write32(Adapter, (int )((u16 )pPhyReg->rf3wireOffset), DataAndAddr);
  return;
}
}
u32 PHY_QueryRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                   u32 BitMask ) 
{ 
  u32 Original_Value ;
  u32 Readback_Value ;
  u32 BitShift ;

  {
  Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
  BitShift = phy_CalculateBitShift(BitMask);
  Readback_Value = (Original_Value & BitMask) >> (int )BitShift;
  return (Readback_Value);
}
}
void PHY_SetRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) 
{ 
  u32 Original_Value ;
  u32 BitShift ;

  {
  if (BitMask != 1048575U) {
    Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
    BitShift = phy_CalculateBitShift(BitMask);
    Data = (~ BitMask & Original_Value) | (Data << (int )BitShift);
  } else {

  }
  phy_RFSerialWrite(Adapter, eRFPath, RegAddr, Data);
  return;
}
}
s32 PHY_MACConfig8723A(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  ODM_ReadAndConfig_MAC_REG_8723A(& pHalData->odmpriv);
  rtl8723au_write8(Adapter, 1226, 10);
  if ((unsigned int )pHalData->rf_type == 2U && (unsigned int )pHalData->BoardType == 0U) {
    rtl8723au_write8(Adapter, 64, 4);
  } else {

  }
  return (1);
}
}
static void phy_InitBBRFRegisterDefinition(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pHalData->PHYRegDef[0].rfintfs = 2160U;
  pHalData->PHYRegDef[1].rfintfs = 2160U;
  pHalData->PHYRegDef[0].rfintfi = 2272U;
  pHalData->PHYRegDef[1].rfintfi = 2272U;
  pHalData->PHYRegDef[0].rfintfo = 2144U;
  pHalData->PHYRegDef[1].rfintfo = 2148U;
  pHalData->PHYRegDef[0].rfintfe = 2144U;
  pHalData->PHYRegDef[1].rfintfe = 2148U;
  pHalData->PHYRegDef[0].rf3wireOffset = 2112U;
  pHalData->PHYRegDef[1].rf3wireOffset = 2116U;
  pHalData->PHYRegDef[0].rfLSSI_Select = 2168U;
  pHalData->PHYRegDef[1].rfLSSI_Select = 2168U;
  pHalData->PHYRegDef[0].rfTxGainStage = 2060U;
  pHalData->PHYRegDef[1].rfTxGainStage = 2060U;
  pHalData->PHYRegDef[0].rfHSSIPara1 = 2080U;
  pHalData->PHYRegDef[1].rfHSSIPara1 = 2088U;
  pHalData->PHYRegDef[0].rfHSSIPara2 = 2084U;
  pHalData->PHYRegDef[1].rfHSSIPara2 = 2092U;
  pHalData->PHYRegDef[0].rfSwitchControl = 2136U;
  pHalData->PHYRegDef[1].rfSwitchControl = 2136U;
  pHalData->PHYRegDef[0].rfAGCControl1 = 3152U;
  pHalData->PHYRegDef[1].rfAGCControl1 = 3160U;
  pHalData->PHYRegDef[0].rfAGCControl2 = 3156U;
  pHalData->PHYRegDef[1].rfAGCControl2 = 3164U;
  pHalData->PHYRegDef[0].rfRxIQImbalance = 3092U;
  pHalData->PHYRegDef[1].rfRxIQImbalance = 3100U;
  pHalData->PHYRegDef[0].rfRxAFE = 3088U;
  pHalData->PHYRegDef[1].rfRxAFE = 3096U;
  pHalData->PHYRegDef[0].rfTxIQImbalance = 3200U;
  pHalData->PHYRegDef[1].rfTxIQImbalance = 3208U;
  pHalData->PHYRegDef[0].rfTxAFE = 3204U;
  pHalData->PHYRegDef[1].rfTxAFE = 3212U;
  pHalData->PHYRegDef[0].rfLSSIReadBack = 2208U;
  pHalData->PHYRegDef[1].rfLSSIReadBack = 2212U;
  pHalData->PHYRegDef[0].rfLSSIReadBackPi = 2232U;
  pHalData->PHYRegDef[1].rfLSSIReadBackPi = 2236U;
  return;
}
}
static void storePwrIndexDiffRateOffset(struct rtw_adapter *Adapter , u32 RegAddr ,
                                        u32 BitMask , u32 Data ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if (RegAddr == 3584U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][0] = Data;
  } else {

  }
  if (RegAddr == 3588U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][1] = Data;
  } else {

  }
  if (RegAddr == 3592U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][6] = Data;
  } else {

  }
  if (RegAddr == 2156U && BitMask == 4294967040U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][7] = Data;
  } else {

  }
  if (RegAddr == 3600U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][2] = Data;
  } else {

  }
  if (RegAddr == 3604U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][3] = Data;
  } else {

  }
  if (RegAddr == 3608U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][4] = Data;
  } else {

  }
  if (RegAddr == 3612U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][5] = Data;
  } else {

  }
  if (RegAddr == 2096U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][8] = Data;
  } else {

  }
  if (RegAddr == 2100U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][9] = Data;
  } else {

  }
  if (RegAddr == 2104U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][14] = Data;
  } else {

  }
  if (RegAddr == 2156U && BitMask == 255U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][15] = Data;
  } else {

  }
  if (RegAddr == 2108U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][10] = Data;
  } else {

  }
  if (RegAddr == 2120U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][11] = Data;
  } else {

  }
  if (RegAddr == 2124U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][12] = Data;
  } else {

  }
  if (RegAddr == 2152U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][13] = Data;
    pHalData->pwrGroupCnt = (u8 )((int )pHalData->pwrGroupCnt + 1);
  } else {

  }
  return;
}
}
static int phy_ConfigBBWithPgHeaderFile(struct rtw_adapter *Adapter ) 
{ 
  int i ;
  u32 *Rtl819XPHY_REGArray_Table_PG ;
  u16 PHY_REGArrayPGLen ;

  {
  PHY_REGArrayPGLen = 336U;
  Rtl819XPHY_REGArray_Table_PG = (u32 *)(& Rtl8723UPHY_REG_Array_PG);
  i = 0;
  goto ldv_55829;
  ldv_55828: 
  storePwrIndexDiffRateOffset(Adapter, *(Rtl819XPHY_REGArray_Table_PG + (unsigned long )i),
                              *(Rtl819XPHY_REGArray_Table_PG + ((unsigned long )i + 1UL)),
                              *(Rtl819XPHY_REGArray_Table_PG + ((unsigned long )i + 2UL)));
  i = i + 3;
  ldv_55829: ;
  if ((int )PHY_REGArrayPGLen > i) {
    goto ldv_55828;
  } else {

  }

  return (1);
}
}
static void phy_BB8192C_Config_1T(struct rtw_adapter *Adapter ) 
{ 


  {
  PHY_SetBBReg(Adapter, 2052U, 3U, 2U);
  PHY_SetBBReg(Adapter, 2316U, 3145779U, 2097186U);
  PHY_SetBBReg(Adapter, 2564U, 4278190080U, 69U);
  PHY_SetBBReg(Adapter, 3076U, 255U, 35U);
  PHY_SetBBReg(Adapter, 3184U, 48U, 1U);
  PHY_SetBBReg(Adapter, 3700U, 201326592U, 2U);
  PHY_SetBBReg(Adapter, 3704U, 201326592U, 2U);
  PHY_SetBBReg(Adapter, 3708U, 201326592U, 2U);
  PHY_SetBBReg(Adapter, 3712U, 201326592U, 2U);
  PHY_SetBBReg(Adapter, 3720U, 201326592U, 2U);
  return;
}
}
static int phy_BB8723a_Config_ParaFile(struct rtw_adapter *Adapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  struct hal_data_8723a *pHalData ;
  int rtStatus ;

  {
  pEEPROM = & Adapter->eeprompriv;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  rtStatus = 1;
  ODM_ReadAndConfig_PHY_REG_1T_8723A(& pHalData->odmpriv);
  if ((unsigned int )pHalData->rf_type == 0U) {
    phy_BB8192C_Config_1T(Adapter);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: phy_BB8723a_Config_ParaFile():Config to 1T!!\n");
    } else {

    }
  } else {

  }
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 0U) {
    pHalData->pwrGroupCnt = 0U;
    rtStatus = phy_ConfigBBWithPgHeaderFile(Adapter);
  } else {

  }
  if (rtStatus != 1) {
    goto phy_BB8190_Config_ParaFile_Fail;
  } else {

  }
  ODM_ReadAndConfig_AGC_TAB_1T_8723A(& pHalData->odmpriv);
  phy_BB8190_Config_ParaFile_Fail: ;
  return (rtStatus);
}
}
int PHY_BBConfig8723A(struct rtw_adapter *Adapter ) 
{ 
  int rtStatus ;
  struct hal_data_8723a *pHalData ;
  u8 TmpU1B ;
  u8 CrystalCap ;

  {
  rtStatus = 1;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  TmpU1B = 0U;
  phy_InitBBRFRegisterDefinition(Adapter);
  TmpU1B = rtl8723au_read8(Adapter, 40);
  __const_udelay(8590UL);
  rtl8723au_write8(Adapter, 40, (int )((unsigned int )TmpU1B | 2U));
  __const_udelay(8590UL);
  rtl8723au_write8(Adapter, 41, 255);
  __const_udelay(8590UL);
  TmpU1B = rtl8723au_read8(Adapter, 2);
  rtl8723au_write8(Adapter, 2, (int )((unsigned int )TmpU1B | 3U));
  TmpU1B = rtl8723au_read8(Adapter, 37);
  rtl8723au_write8(Adapter, 37, (int )TmpU1B & 191);
  TmpU1B = rtl8723au_read8(Adapter, 38);
  rtl8723au_write8(Adapter, 38, (int )TmpU1B & 239);
  rtl8723au_write8(Adapter, 31, 7);
  rtStatus = phy_BB8723a_Config_ParaFile(Adapter);
  if ((unsigned int )pHalData->EEPROMVersion != 0U) {
    CrystalCap = (unsigned int )pHalData->CrystalCap & 63U;
    PHY_SetBBReg(Adapter, 44U, 16773120U, (u32 )((int )CrystalCap | ((int )CrystalCap << 6)));
  } else {

  }
  rtl8723au_write32(Adapter, 32, 22488325U);
  return (rtStatus);
}
}
static void getTxPowerIndex(struct rtw_adapter *Adapter , u8 channel , u8 *cckPowerLevel ,
                            u8 *ofdmPowerLevel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 index ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  index = (unsigned int )channel + 255U;
  *cckPowerLevel = pHalData->TxPwrLevelCck[0][(int )index];
  *(cckPowerLevel + 1UL) = pHalData->TxPwrLevelCck[1][(int )index];
  if ((unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 0U || (unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 3U) {
    *ofdmPowerLevel = pHalData->TxPwrLevelHT40_1S[0][(int )index];
    *(ofdmPowerLevel + 1UL) = pHalData->TxPwrLevelHT40_1S[1][(int )index];
  } else
  if ((unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 2U) {
    *ofdmPowerLevel = pHalData->TxPwrLevelHT40_2S[0][(int )index];
    *(ofdmPowerLevel + 1UL) = pHalData->TxPwrLevelHT40_2S[1][(int )index];
  } else {

  }
  return;
}
}
static void ccxPowerIndexCheck(struct rtw_adapter *Adapter , u8 channel , u8 *cckPowerLevel ,
                               u8 *ofdmPowerLevel ) 
{ 


  {
  return;
}
}
void PHY_SetTxPowerLevel8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 cckPowerLevel[2U] ;
  u8 ofdmPowerLevel[2U] ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if ((unsigned int )pHalData->bTXPowerDataReadFromEEPORM == 0U) {
    return;
  } else {

  }
  getTxPowerIndex(Adapter, (int )channel, (u8 *)(& cckPowerLevel), (u8 *)(& ofdmPowerLevel));
  ccxPowerIndexCheck(Adapter, (int )channel, (u8 *)(& cckPowerLevel), (u8 *)(& ofdmPowerLevel));
  rtl823a_phy_rf6052setccktxpower(Adapter, (u8 *)(& cckPowerLevel));
  rtl8723a_PHY_RF6052SetOFDMTxPower(Adapter, (u8 *)(& ofdmPowerLevel), (int )channel);
  return;
}
}
static void _PHY_SetBWMode23a92C(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 regBwOpMode ;
  u8 regRRSR_RSC ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if (Adapter->bDriverStopped != 0) {
    return;
  } else {

  }
  regBwOpMode = rtl8723au_read8(Adapter, 1539);
  regRRSR_RSC = rtl8723au_read8(Adapter, 1090);
  switch ((unsigned int )pHalData->CurrentChannelBW) {
  case 0U: 
  regBwOpMode = (u8 )((unsigned int )regBwOpMode | 4U);
  rtl8723au_write8(Adapter, 1539, (int )regBwOpMode);
  goto ldv_55876;
  case 1U: 
  regBwOpMode = (unsigned int )regBwOpMode & 251U;
  rtl8723au_write8(Adapter, 1539, (int )regBwOpMode);
  regRRSR_RSC = (u8 )(((int )((signed char )regRRSR_RSC) & -112) | (int )((signed char )((int )pHalData->nCur40MhzPrimeSC << 5)));
  rtl8723au_write8(Adapter, 1090, (int )regRRSR_RSC);
  goto ldv_55876;
  default: ;
  goto ldv_55876;
  }
  ldv_55876: ;
  switch ((unsigned int )pHalData->CurrentChannelBW) {
  case 0U: 
  PHY_SetBBReg(Adapter, 2048U, 1U, 0U);
  PHY_SetBBReg(Adapter, 2304U, 1U, 0U);
  PHY_SetBBReg(Adapter, 2180U, 1024U, 1U);
  goto ldv_55880;
  case 1U: 
  PHY_SetBBReg(Adapter, 2048U, 1U, 1U);
  PHY_SetBBReg(Adapter, 2304U, 1U, 1U);
  PHY_SetBBReg(Adapter, 2560U, 16U, (u32 )((int )pHalData->nCur40MhzPrimeSC >> 1));
  PHY_SetBBReg(Adapter, 3328U, 3072U, (u32 )pHalData->nCur40MhzPrimeSC);
  PHY_SetBBReg(Adapter, 2180U, 1024U, 0U);
  PHY_SetBBReg(Adapter, 2072U, 201326592U, (unsigned int )pHalData->nCur40MhzPrimeSC == 1U ? 2U : 1U);
  goto ldv_55880;
  default: ;
  goto ldv_55880;
  }
  ldv_55880: 
  rtl8723a_phy_rf6052set_bw(Adapter, pHalData->CurrentChannelBW);
  return;
}
}
void PHY_SetBWMode23a8723A(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ,
                           unsigned char Offset ) 
{ 
  struct hal_data_8723a *pHalData ;
  enum ht_channel_width tmpBW ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  tmpBW = pHalData->CurrentChannelBW;
  pHalData->CurrentChannelBW = Bandwidth;
  pHalData->nCur40MhzPrimeSC = Offset;
  if (Adapter->bDriverStopped == 0 && Adapter->bSurpriseRemoved == 0) {
    _PHY_SetBWMode23a92C(Adapter);
  } else {
    pHalData->CurrentChannelBW = tmpBW;
  }
  return;
}
}
static void _PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  enum RF_RADIO_PATH eRFPath ;
  u32 param1 ;
  u32 param2 ;
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  PHY_SetTxPowerLevel8723A(Adapter, (int )channel);
  param1 = 24U;
  param2 = (u32 )channel;
  eRFPath = 0;
  goto ldv_55899;
  ldv_55898: 
  pHalData->RfRegChnlVal[(unsigned int )eRFPath] = (pHalData->RfRegChnlVal[(unsigned int )eRFPath] & 4294966272U) | param2;
  PHY_SetRFReg(Adapter, eRFPath, param1, 1048575U, pHalData->RfRegChnlVal[(unsigned int )eRFPath]);
  eRFPath = (enum RF_RADIO_PATH )((unsigned int )eRFPath + 1U);
  ldv_55899: ;
  if ((unsigned int )pHalData->NumTotalRFPath > (unsigned int )eRFPath) {
    goto ldv_55898;
  } else {

  }

  return;
}
}
void PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmpchannel ;
  bool result ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  tmpchannel = pHalData->CurrentChannel;
  result = 1;
  if ((unsigned int )channel == 0U) {
    channel = 1U;
  } else {

  }
  pHalData->CurrentChannel = channel;
  if (Adapter->bDriverStopped == 0 && Adapter->bSurpriseRemoved == 0) {
    _PHY_SwChnl8723A(Adapter, (int )channel);
    if (! result) {
      pHalData->CurrentChannel = tmpchannel;
    } else {

    }
  } else {
    pHalData->CurrentChannel = tmpchannel;
  }
  return;
}
}
bool ldv_queue_work_on_509(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_510(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_511(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_512(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_513(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_523(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_525(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_524(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_527(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_526(struct workqueue_struct *ldv_func_arg1 ) ;
int PHY_RF6052_Config8723A(struct rtw_adapter *Adapter ) ;
void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  switch ((unsigned int )Bandwidth) {
  case 0U: 
  pHalData->RfRegChnlVal[0] = (pHalData->RfRegChnlVal[0] & 4294964223U) | 1024U;
  PHY_SetRFReg(Adapter, 0, 24U, 1048575U, pHalData->RfRegChnlVal[0]);
  goto ldv_55750;
  case 1U: 
  pHalData->RfRegChnlVal[0] = pHalData->RfRegChnlVal[0] & 4294964223U;
  PHY_SetRFReg(Adapter, 0, 24U, 1048575U, pHalData->RfRegChnlVal[0]);
  goto ldv_55750;
  default: ;
  goto ldv_55750;
  }
  ldv_55750: ;
  return;
}
}
void rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter , u8 *pPowerlevel ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u32 TxAGC[2U] ;
  u32 tmpval ;
  bool TurboScanOff ;
  u8 idx1 ;
  u8 idx2 ;
  u8 *ptr ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pmlmeext = & Adapter->mlmeextpriv;
  TxAGC[0] = 0U;
  TxAGC[1] = 0U;
  tmpval = 0U;
  TurboScanOff = 0;
  if ((unsigned int )pHalData->EEPROMRegulatory != 0U || (unsigned int )pHalData->ExternalPA != 0U) {
    TurboScanOff = 1;
  } else {

  }
  if (pmlmeext->sitesurvey_res.state == 3) {
    TxAGC[0] = 1061109567U;
    TxAGC[1] = 1061109567U;
    TurboScanOff = 1;
    if ((int )TurboScanOff) {
      idx1 = 0U;
      goto ldv_55767;
      ldv_55766: 
      TxAGC[(int )idx1] = (u32 )((((int )*(pPowerlevel + (unsigned long )idx1) | ((int )*(pPowerlevel + (unsigned long )idx1) << 8)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 16)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 24));
      if (TxAGC[(int )idx1] > 32U && (unsigned int )pHalData->ExternalPA != 0U) {
        TxAGC[(int )idx1] = 32U;
      } else {

      }
      idx1 = (u8 )((int )idx1 + 1);
      ldv_55767: ;
      if ((unsigned int )idx1 <= 1U) {
        goto ldv_55766;
      } else {

      }

    } else {

    }
  } else
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 1U) {
    TxAGC[0] = 269488144U;
    TxAGC[1] = 269488144U;
  } else
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 2U) {
    TxAGC[0] = 0U;
    TxAGC[1] = 0U;
  } else {
    idx1 = 0U;
    goto ldv_55770;
    ldv_55769: 
    TxAGC[(int )idx1] = (u32 )((((int )*(pPowerlevel + (unsigned long )idx1) | ((int )*(pPowerlevel + (unsigned long )idx1) << 8)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 16)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 24));
    idx1 = (u8 )((int )idx1 + 1);
    ldv_55770: ;
    if ((unsigned int )idx1 <= 1U) {
      goto ldv_55769;
    } else {

    }

    if ((unsigned int )pHalData->EEPROMRegulatory == 0U) {
      tmpval = pHalData->MCSTxPowerLevelOriginalOffset[0][6] + (pHalData->MCSTxPowerLevelOriginalOffset[0][7] << 8);
      TxAGC[0] = TxAGC[0] + tmpval;
      tmpval = pHalData->MCSTxPowerLevelOriginalOffset[0][14] + (pHalData->MCSTxPowerLevelOriginalOffset[0][15] << 24);
      TxAGC[1] = TxAGC[1] + tmpval;
    } else {

    }
  }
  idx1 = 0U;
  goto ldv_55776;
  ldv_55775: 
  ptr = (u8 *)(& TxAGC) + (unsigned long )idx1;
  idx2 = 0U;
  goto ldv_55773;
  ldv_55772: ;
  if ((unsigned int )*ptr > 63U) {
    *ptr = 63U;
  } else {

  }
  ptr = ptr + 1;
  idx2 = (u8 )((int )idx2 + 1);
  ldv_55773: ;
  if ((unsigned int )idx2 <= 3U) {
    goto ldv_55772;
  } else {

  }
  idx1 = (u8 )((int )idx1 + 1);
  ldv_55776: ;
  if ((unsigned int )idx1 <= 1U) {
    goto ldv_55775;
  } else {

  }
  tmpval = TxAGC[0] & 255U;
  PHY_SetBBReg(Adapter, 3592U, 65280U, tmpval);
  tmpval = TxAGC[0] >> 8;
  PHY_SetBBReg(Adapter, 2156U, 4294967040U, tmpval);
  tmpval = TxAGC[1] >> 24;
  PHY_SetBBReg(Adapter, 2156U, 255U, tmpval);
  tmpval = TxAGC[1] & 16777215U;
  PHY_SetBBReg(Adapter, 2104U, 4294967040U, tmpval);
  return;
}
}
static void getPowerBase(struct rtw_adapter *Adapter , u8 *pPowerLevel , u8 Channel ,
                         u32 *OfdmBase , u32 *MCSBase ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 powerBase0 ;
  u32 powerBase1 ;
  u8 Legacy_pwrdiff ;
  s8 HT20_pwrdiff ;
  u8 i ;
  u8 powerlevel[2U] ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  Legacy_pwrdiff = 0U;
  HT20_pwrdiff = 0;
  i = 0U;
  goto ldv_55793;
  ldv_55792: 
  powerlevel[(int )i] = *(pPowerLevel + (unsigned long )i);
  Legacy_pwrdiff = pHalData->TxPwrLegacyHtDiff[(int )i][(int )Channel + -1];
  powerBase0 = (u32 )((int )powerlevel[(int )i] + (int )Legacy_pwrdiff);
  powerBase0 = (((powerBase0 << 24) | (powerBase0 << 16)) | (powerBase0 << 8)) | powerBase0;
  *(OfdmBase + (unsigned long )i) = powerBase0;
  i = (u8 )((int )i + 1);
  ldv_55793: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55792;
  } else {

  }
  i = 0U;
  goto ldv_55796;
  ldv_55795: ;
  if ((unsigned int )pHalData->CurrentChannelBW == 0U) {
    HT20_pwrdiff = (s8 )pHalData->TxPwrHt20Diff[(int )i][(int )Channel + -1];
    powerlevel[(int )i] = (int )powerlevel[(int )i] + (int )((u8 )HT20_pwrdiff);
  } else {

  }
  powerBase1 = (u32 )powerlevel[(int )i];
  powerBase1 = (((powerBase1 << 24) | (powerBase1 << 16)) | (powerBase1 << 8)) | powerBase1;
  *(MCSBase + (unsigned long )i) = powerBase1;
  i = (u8 )((int )i + 1);
  ldv_55796: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55795;
  } else {

  }

  return;
}
}
static void getTxPowerWriteValByRegulatory(struct rtw_adapter *Adapter , u8 Channel ,
                                           u8 index , u32 *powerBase0 , u32 *powerBase1 ,
                                           u32 *pOutWriteVal ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 i ;
  u8 chnlGroup ;
  u8 pwr_diff_limit[4U] ;
  u32 writeVal ;
  u32 customer_limit ;
  u32 rf ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  chnlGroup = 0U;
  rf = 0U;
  goto ldv_55824;
  ldv_55823: ;
  switch ((int )pHalData->EEPROMRegulatory) {
  case 0: 
  chnlGroup = 0U;
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
  goto ldv_55815;
  case 1: ;
  if ((unsigned int )pHalData->pwrGroupCnt == 1U) {
    chnlGroup = 0U;
  } else {

  }
  if ((unsigned int )pHalData->pwrGroupCnt > 2U) {
    if ((unsigned int )Channel <= 3U) {
      chnlGroup = 0U;
    } else
    if ((unsigned int )Channel > 3U && (unsigned int )Channel <= 9U) {
      chnlGroup = 1U;
    } else
    if ((unsigned int )Channel > 9U) {
      chnlGroup = 2U;
    } else {

    }
    if ((unsigned int )pHalData->CurrentChannelBW == 0U) {
      chnlGroup = (u8 )((int )chnlGroup + 1);
    } else {
      chnlGroup = (unsigned int )chnlGroup + 4U;
    }
  } else {

  }
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
  goto ldv_55815;
  case 2: 
  writeVal = (unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf);
  goto ldv_55815;
  case 3: 
  chnlGroup = 0U;
  i = 0U;
  goto ldv_55820;
  ldv_55819: 
  pwr_diff_limit[(int )i] = (unsigned char )((pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] & (u32 )(127 << (int )i * 8)) >> (int )i * 8);
  if ((unsigned int )pHalData->CurrentChannelBW == 1U) {
    if ((int )pwr_diff_limit[(int )i] > (int )pHalData->PwrGroupHT40[rf][(int )Channel + -1]) {
      pwr_diff_limit[(int )i] = pHalData->PwrGroupHT40[rf][(int )Channel + -1];
    } else {

    }
  } else
  if ((int )pwr_diff_limit[(int )i] > (int )pHalData->PwrGroupHT20[rf][(int )Channel + -1]) {
    pwr_diff_limit[(int )i] = pHalData->PwrGroupHT20[rf][(int )Channel + -1];
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_55820: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_55819;
  } else {

  }
  customer_limit = (u32 )(((((int )pwr_diff_limit[3] << 24) | ((int )pwr_diff_limit[2] << 16)) | ((int )pwr_diff_limit[1] << 8)) | (int )pwr_diff_limit[0]);
  writeVal = ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf)) + customer_limit;
  goto ldv_55815;
  default: 
  chnlGroup = 0U;
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
  goto ldv_55815;
  }
  ldv_55815: ;
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 1U) {
    writeVal = 336860180U;
  } else
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 2U) {
    writeVal = 0U;
  } else {

  }
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 3U) {
    writeVal = writeVal - 101058054U;
  } else
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 4U) {
    writeVal = writeVal;
  } else {

  }
  *(pOutWriteVal + (unsigned long )rf) = writeVal;
  rf = rf + 1U;
  ldv_55824: ;
  if (rf <= 1U) {
    goto ldv_55823;
  } else {

  }

  return;
}
}
static void writeOFDMPowerReg(struct rtw_adapter *Adapter , u8 index , u32 *pValue ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 RegOffset_A[6U] ;
  u16 RegOffset_B[6U] ;
  u8 i ;
  u8 rf ;
  u8 pwr_val[4U] ;
  u32 writeVal ;
  u16 RegOffset ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  RegOffset_A[0] = 3584U;
  RegOffset_A[1] = 3588U;
  RegOffset_A[2] = 3600U;
  RegOffset_A[3] = 3604U;
  RegOffset_A[4] = 3608U;
  RegOffset_A[5] = 3612U;
  RegOffset_B[0] = 2096U;
  RegOffset_B[1] = 2100U;
  RegOffset_B[2] = 2108U;
  RegOffset_B[3] = 2120U;
  RegOffset_B[4] = 2124U;
  RegOffset_B[5] = 2152U;
  rf = 0U;
  goto ldv_55846;
  ldv_55845: 
  writeVal = *(pValue + (unsigned long )rf);
  i = 0U;
  goto ldv_55840;
  ldv_55839: 
  pwr_val[(int )i] = (unsigned char )(((u32 )(127 << (int )i * 8) & writeVal) >> (int )i * 8);
  if ((unsigned int )pwr_val[(int )i] > 63U) {
    pwr_val[(int )i] = 63U;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_55840: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_55839;
  } else {

  }
  writeVal = (u32 )(((((int )pwr_val[3] << 24) | ((int )pwr_val[2] << 16)) | ((int )pwr_val[1] << 8)) | (int )pwr_val[0]);
  if ((unsigned int )rf == 0U) {
    RegOffset = RegOffset_A[(int )index];
  } else {
    RegOffset = RegOffset_B[(int )index];
  }
  rtl8723au_write32(Adapter, (int )RegOffset, writeVal);
  if (((unsigned int )pHalData->rf_type == 2U && ((unsigned int )RegOffset == 3612U || (unsigned int )RegOffset == 2152U)) || ((unsigned int )pHalData->rf_type != 2U && ((unsigned int )RegOffset == 3604U || (unsigned int )RegOffset == 2120U))) {
    writeVal = (u32 )pwr_val[3];
    if ((unsigned int )RegOffset == 3612U || (unsigned int )RegOffset == 3604U) {
      RegOffset = 3216U;
    } else {

    }
    if ((unsigned int )RegOffset == 2152U || (unsigned int )RegOffset == 2120U) {
      RegOffset = 3224U;
    } else {

    }
    i = 0U;
    goto ldv_55843;
    ldv_55842: ;
    if ((unsigned int )i != 2U) {
      writeVal = writeVal > 8U ? writeVal - 8U : 0U;
    } else {
      writeVal = writeVal > 6U ? writeVal - 6U : 0U;
    }
    rtl8723au_write8(Adapter, (int )((u16 )i) + (int )RegOffset, (int )((unsigned char )writeVal));
    i = (u8 )((int )i + 1);
    ldv_55843: ;
    if ((unsigned int )i <= 2U) {
      goto ldv_55842;
    } else {

    }

  } else {

  }
  rf = (u8 )((int )rf + 1);
  ldv_55846: ;
  if ((unsigned int )rf <= 1U) {
    goto ldv_55845;
  } else {

  }

  return;
}
}
void rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter , u8 *pPowerLevel ,
                                       u8 Channel ) 
{ 
  u32 writeVal[2U] ;
  u32 powerBase0[2U] ;
  u32 powerBase1[2U] ;
  u8 index ;

  {
  index = 0U;
  getPowerBase(Adapter, pPowerLevel, (int )Channel, (u32 *)(& powerBase0), (u32 *)(& powerBase1));
  index = 0U;
  goto ldv_55858;
  ldv_55857: 
  getTxPowerWriteValByRegulatory(Adapter, (int )Channel, (int )index, (u32 *)(& powerBase0),
                                 (u32 *)(& powerBase1), (u32 *)(& writeVal));
  writeOFDMPowerReg(Adapter, (int )index, (u32 *)(& writeVal));
  index = (u8 )((int )index + 1);
  ldv_55858: ;
  if ((unsigned int )index <= 5U) {
    goto ldv_55857;
  } else {

  }

  return;
}
}
static int phy_RF6052_Config_ParaFile(struct rtw_adapter *Adapter ) 
{ 
  u32 u4RegValue ;
  u8 eRFPath ;
  struct bb_reg_define *pPhyReg ;
  int rtStatus ;
  struct hal_data_8723a *pHalData ;

  {
  u4RegValue = 0U;
  rtStatus = 1;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  eRFPath = 0U;
  goto ldv_55879;
  ldv_55878: 
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
  switch ((int )eRFPath) {
  case 0: 
  u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, 16U);
  goto ldv_55869;
  case 1: 
  u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, 1048576U);
  goto ldv_55869;
  }
  ldv_55869: 
  PHY_SetBBReg(Adapter, pPhyReg->rfintfe, 1048576U, 1U);
  __const_udelay(4295UL);
  PHY_SetBBReg(Adapter, pPhyReg->rfintfo, 16U, 1U);
  __const_udelay(4295UL);
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 1024U, 0U);
  __const_udelay(4295UL);
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 2048U, 0U);
  __const_udelay(4295UL);
  switch ((int )eRFPath) {
  case 0: 
  ODM_ReadAndConfig_RadioA_1T_8723A(& pHalData->odmpriv);
  goto ldv_55872;
  case 1: ;
  goto ldv_55872;
  }
  ldv_55872: ;
  switch ((int )eRFPath) {
  case 0: 
  PHY_SetBBReg(Adapter, pPhyReg->rfintfs, 16U, u4RegValue);
  goto ldv_55875;
  case 1: 
  PHY_SetBBReg(Adapter, pPhyReg->rfintfs, 1048576U, u4RegValue);
  goto ldv_55875;
  }
  ldv_55875: ;
  if (rtStatus != 1) {
    goto phy_RF6052_Config_ParaFile_Fail;
  } else {

  }
  eRFPath = (u8 )((int )eRFPath + 1);
  ldv_55879: ;
  if ((int )pHalData->NumTotalRFPath > (int )eRFPath) {
    goto ldv_55878;
  } else {

  }

  phy_RF6052_Config_ParaFile_Fail: ;
  return (rtStatus);
}
}
int PHY_RF6052_Config8723A(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  int tmp ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if ((unsigned int )pHalData->rf_type == 3U) {
    pHalData->NumTotalRFPath = 1U;
  } else {
    pHalData->NumTotalRFPath = 2U;
  }
  tmp = phy_RF6052_Config_ParaFile(Adapter);
  return (tmp);
}
}
bool ldv_queue_work_on_523(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_524(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_525(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_526(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_527(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_537(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_539(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_538(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_540(struct workqueue_struct *ldv_func_arg1 ) ;
void rtl8723a_process_phy_info(struct rtw_adapter *padapter , void *prframe ) ;
static void process_rssi(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct signal_stat *signal_stat ;

  {
  pattrib = & prframe->attrib;
  signal_stat = & padapter->recvpriv.signal_strength_data;
  if ((unsigned int )signal_stat->update_req != 0U) {
    signal_stat->total_num = 0U;
    signal_stat->total_val = 0U;
    signal_stat->update_req = 0U;
  } else {

  }
  signal_stat->total_num = signal_stat->total_num + 1U;
  signal_stat->total_val = signal_stat->total_val + (u32 )pattrib->phy_info.SignalStrength;
  signal_stat->avg_val = (u8 )(signal_stat->total_val / signal_stat->total_num);
  return;
}
}
static void process_link_qual(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct signal_stat *signal_stat ;

  {
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0) || (unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {

  }
  pattrib = & prframe->attrib;
  signal_stat = & padapter->recvpriv.signal_qual_data;
  if ((unsigned int )signal_stat->update_req != 0U) {
    signal_stat->total_num = 0U;
    signal_stat->total_val = 0U;
    signal_stat->update_req = 0U;
  } else {

  }
  signal_stat->total_num = signal_stat->total_num + 1U;
  signal_stat->total_val = signal_stat->total_val + (u32 )pattrib->phy_info.SignalQuality;
  signal_stat->avg_val = (u8 )(signal_stat->total_val / signal_stat->total_num);
  return;
}
}
void rtl8723a_process_phy_info(struct rtw_adapter *padapter , void *prframe ) 
{ 
  struct recv_frame *precvframe ;

  {
  precvframe = (struct recv_frame *)prframe;
  process_rssi(padapter, precvframe);
  process_link_qual(padapter, precvframe);
  return;
}
}
bool ldv_queue_work_on_537(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_538(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_539(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_540(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_551(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_553(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_552(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_555(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_554(struct workqueue_struct *ldv_func_arg1 ) ;
void rtl8723a_sreset_xmit_status_check(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  unsigned long current_time ;
  struct xmit_priv *pxmitpriv ;
  unsigned int diff_time ;
  u32 txdma_status ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  pxmitpriv = & padapter->xmitpriv;
  txdma_status = rtl8723au_read32(padapter, 528);
  if (txdma_status != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s REG_TXDMA_STATUS:0x%08x\n", "rtl8723a_sreset_xmit_status_check",
             txdma_status);
    } else {

    }
    rtw_sreset_reset(padapter);
  } else {

  }
  current_time = jiffies;
  if (pxmitpriv->free_xmitbuf_cnt == 0U || pxmitpriv->free_xmit_extbuf_cnt == 0U) {
    diff_time = jiffies_to_msecs((unsigned long )jiffies - psrtpriv->last_tx_time);
    if (diff_time > 2000U) {
      if (psrtpriv->last_tx_complete_time == 0UL) {
        psrtpriv->last_tx_complete_time = current_time;
      } else {
        diff_time = jiffies_to_msecs((unsigned long )jiffies - psrtpriv->last_tx_complete_time);
        if (diff_time > 4000U) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: %s tx hang\n", "rtl8723a_sreset_xmit_status_check");
          } else {

          }
          rtw_sreset_reset(padapter);
        } else {

        }
      }
    } else {

    }
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_551(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_552(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_553(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_554(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_555(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_565(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_567(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_566(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_569(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_568(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static __u32 skb_queue_len(struct sk_buff_head  const  *list_ ) 
{ 


  {
  return ((__u32 )list_->qlen);
}
}
__inline static void skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct lock_class_key __key ;

  {
  spinlock_check(& list->lock);
  __raw_spin_lock_init(& list->lock.__annonCompField18.rlock, "&(&list->lock)->rlock",
                       & __key);
  __skb_queue_head_init(list);
  return;
}
}
extern void skb_queue_tail(struct sk_buff_head * , struct sk_buff * ) ;
__inline static void skb_reserve(struct sk_buff *skb , int len ) 
{ 


  {
  skb->data = skb->data + (unsigned long )len;
  skb->tail = skb->tail + (sk_buff_data_t )len;
  return;
}
}
extern void skb_queue_purge(struct sk_buff_head * ) ;
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
extern struct urb *usb_alloc_urb(int  , gfp_t  ) ;
extern void usb_free_urb(struct urb * ) ;
void rtl8723au_recv_tasklet(void *priv ) ;
void update_recvframe_attrib(struct recv_frame *precvframe , struct recv_stat *prxstat ) ;
void update_recvframe_phyinfo(struct recv_frame *precvframe , struct phy_stat *pphy_status ) ;
int rtl8723au_init_recv_priv(struct rtw_adapter *padapter ) 
{ 
  struct recv_priv *precvpriv ;
  int i ;
  int size ;
  int res ;
  struct recv_buf *precvbuf ;
  unsigned long tmpaddr ;
  unsigned long alignment ;
  struct sk_buff *pskb ;
  void *tmp ;
  void *tmp___0 ;

  {
  precvpriv = & padapter->recvpriv;
  res = 1;
  tasklet_init(& precvpriv->recv_tasklet, (void (*)(unsigned long  ))(& rtl8723au_recv_tasklet),
               (unsigned long )padapter);
  precvpriv->int_in_urb = usb_alloc_urb(0, 208U);
  if ((unsigned long )precvpriv->int_in_urb == (unsigned long )((struct urb *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: alloc_urb for interrupt in endpoint fail !!!!\n");
    } else {

    }
  } else {

  }
  tmp = kzalloc(56UL, 208U);
  precvpriv->int_in_buf = (u8 *)tmp;
  if ((unsigned long )precvpriv->int_in_buf == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: alloc_mem for interrupt in endpoint fail !!!!\n");
    } else {

    }
  } else {

  }
  size = 160;
  tmp___0 = kzalloc((size_t )size, 208U);
  precvpriv->precv_buf = (u8 *)tmp___0;
  if ((unsigned long )precvpriv->precv_buf == (unsigned long )((u8 *)0U)) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "alloc recv_buf fail!\n");
    } else {

    }
    goto exit;
  } else {

  }
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
  i = 0;
  goto ldv_55801;
  ldv_55800: 
  INIT_LIST_HEAD(& precvbuf->list);
  precvbuf->purb = usb_alloc_urb(0, 208U);
  if ((unsigned long )precvbuf->purb == (unsigned long )((struct urb *)0)) {
    goto ldv_55799;
  } else {

  }
  precvbuf->adapter = padapter;
  precvbuf = precvbuf + 1;
  i = i + 1;
  ldv_55801: ;
  if (i <= 3) {
    goto ldv_55800;
  } else {

  }
  ldv_55799: 
  skb_queue_head_init(& precvpriv->rx_skb_queue);
  skb_queue_head_init(& precvpriv->free_recv_skb_queue);
  i = 0;
  goto ldv_55803;
  ldv_55802: 
  size = 15368;
  pskb = __netdev_alloc_skb(padapter->pnetdev, (unsigned int )size, 208U);
  if ((unsigned long )pskb != (unsigned long )((struct sk_buff *)0)) {
    pskb->dev = padapter->pnetdev;
    tmpaddr = (unsigned long )pskb->data;
    alignment = tmpaddr & 7UL;
    skb_reserve(pskb, (int )(8U - (unsigned int )alignment));
    skb_queue_tail(& precvpriv->free_recv_skb_queue, pskb);
  } else {

  }
  pskb = (struct sk_buff *)0;
  i = i + 1;
  ldv_55803: ;
  if (i <= 7) {
    goto ldv_55802;
  } else {

  }

  exit: ;
  return (res);
}
}
void rtl8723au_free_recv_priv(struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct recv_buf *precvbuf ;
  struct recv_priv *precvpriv ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
  precvpriv = & padapter->recvpriv;
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
  i = 0;
  goto ldv_55812;
  ldv_55811: 
  usb_free_urb(precvbuf->purb);
  if ((unsigned long )precvbuf->pskb != (unsigned long )((struct sk_buff *)0)) {
    dev_kfree_skb_any(precvbuf->pskb);
  } else {

  }
  precvbuf = precvbuf + 1;
  i = i + 1;
  ldv_55812: ;
  if (i <= 3) {
    goto ldv_55811;
  } else {

  }
  kfree((void const   *)precvpriv->precv_buf);
  usb_free_urb(precvpriv->int_in_urb);
  kfree((void const   *)precvpriv->int_in_buf);
  tmp = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->rx_skb_queue));
  if (tmp != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \frx_skb_queue not empty\n");
    } else {

    }
  } else {

  }
  skb_queue_purge(& precvpriv->rx_skb_queue);
  tmp___1 = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->free_recv_skb_queue));
  if (tmp___1 != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      tmp___0 = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->free_recv_skb_queue));
      printk("\016RTL8723AU: \ffree_recv_skb_queue not empty, %d\n", tmp___0);
    } else {

    }
  } else {

  }
  skb_queue_purge(& precvpriv->free_recv_skb_queue);
  return;
}
}
void update_recvframe_attrib(struct recv_frame *precvframe , struct recv_stat *prxstat ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct recv_stat_cpu report ;
  struct rxreport_8723a *prxreport ;

  {
  report.rxdw0 = prxstat->rxdw0;
  report.rxdw1 = prxstat->rxdw1;
  report.rxdw2 = prxstat->rxdw2;
  report.rxdw3 = prxstat->rxdw3;
  report.rxdw4 = prxstat->rxdw4;
  report.rxdw5 = prxstat->rxdw5;
  prxreport = (struct rxreport_8723a *)(& report);
  pattrib = & precvframe->attrib;
  memset((void *)pattrib, 0, 96UL);
  pattrib->pkt_len = prxreport->pktlen;
  pattrib->drvinfo_sz = (int )prxreport->drvinfosize << 3U;
  pattrib->physt = prxreport->physt;
  pattrib->crc_err = prxreport->crc32;
  pattrib->icv_err = prxreport->icverr;
  pattrib->bdecrypted = (unsigned int )*((unsigned char *)prxreport + 3UL) == 0U;
  pattrib->encrypt = (u32 )prxreport->security;
  pattrib->qos = prxreport->qos;
  pattrib->priority = prxreport->tid;
  pattrib->amsdu = prxreport->amsdu;
  pattrib->seq_num = prxreport->seq;
  pattrib->frag_num = prxreport->frag;
  pattrib->mfrag = prxreport->mf;
  pattrib->mdata = prxreport->md;
  pattrib->mcs_rate = prxreport->rxmcs;
  pattrib->rxht = prxreport->rxht;
  return;
}
}
void update_recvframe_phyinfo(struct recv_frame *precvframe , struct phy_stat *pphy_status ) 
{ 
  struct rtw_adapter *padapter ;
  struct rx_pkt_attrib *pattrib ;
  struct hal_data_8723a *pHalData ;
  struct phy_info *pPHYInfo ;
  struct odm_packet_info pkt_info ;
  u8 *sa ;
  u8 *da ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  bool matchbssid ;
  u8 *bssid ;
  int tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;

  {
  padapter = precvframe->adapter;
  pattrib = & precvframe->attrib;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pPHYInfo = & pattrib->phy_info;
  sa = (u8 *)0U;
  skb = precvframe->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  matchbssid = 0;
  tmp = ieee80211_is_ctl((int )hdr->frame_control);
  matchbssid = (bool )((tmp == 0 && (unsigned int )pattrib->icv_err == 0U) && (unsigned int )pattrib->crc_err == 0U);
  if ((int )matchbssid) {
    switch ((int )hdr->frame_control & 768) {
    case 256: 
    bssid = (u8 *)(& hdr->addr1);
    goto ldv_55846;
    case 512: 
    bssid = (u8 *)(& hdr->addr2);
    goto ldv_55846;
    case 0: 
    bssid = (u8 *)(& hdr->addr3);
    goto ldv_55846;
    default: 
    bssid = (u8 *)0U;
    matchbssid = 0;
    }
    ldv_55846: ;
    if ((unsigned long )bssid != (unsigned long )((u8 *)0U)) {
      tmp___0 = get_bssid(& padapter->mlmepriv);
      matchbssid = ether_addr_equal((u8 const   *)tmp___0, (u8 const   *)bssid);
    } else {

    }
  } else {

  }
  pkt_info.bPacketMatchBSSID = matchbssid;
  da = ieee80211_get_DA(hdr);
  if ((int )pkt_info.bPacketMatchBSSID) {
    tmp___1 = myid(& padapter->eeprompriv);
    tmp___2 = memcmp((void const   *)da, (void const   *)tmp___1, 6UL);
    if (tmp___2 == 0) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  pkt_info.bPacketToSelf = (bool )tmp___3;
  if ((int )pkt_info.bPacketMatchBSSID) {
    tmp___4 = ieee80211_is_beacon((int )hdr->frame_control);
    if (tmp___4 != 0) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  pkt_info.bPacketBeacon = (bool )tmp___5;
  pkt_info.StationID = 255U;
  if ((int )pkt_info.bPacketBeacon) {
    tmp___6 = check_fwstate(& padapter->mlmepriv, 8);
    if ((int )tmp___6) {
      sa = (u8 *)(& padapter->mlmepriv.cur_network.network.MacAddress);
    } else {

    }
  } else {
    sa = ieee80211_get_SA(hdr);
  }
  pstapriv = & padapter->stapriv;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)sa);
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    pkt_info.StationID = (u8 )psta->mac_id;
  } else {

  }
  pkt_info.Rate = pattrib->mcs_rate;
  ODM_PhyStatusQuery23a(& pHalData->odmpriv, pPHYInfo, (u8 *)pphy_status, & pkt_info);
  precvframe->psta = (struct sta_info *)0;
  if ((int )pkt_info.bPacketMatchBSSID) {
    tmp___8 = check_fwstate(& padapter->mlmepriv, 16);
    if ((int )tmp___8) {
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
        precvframe->psta = psta;
        rtl8723a_process_phy_info(padapter, (void *)precvframe);
      } else {

      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int )pkt_info.bPacketToSelf || (int )pkt_info.bPacketBeacon) {
    tmp___7 = check_fwstate(& padapter->mlmepriv, 96);
    if ((int )tmp___7) {
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
        precvframe->psta = psta;
      } else {

      }
    } else {

    }
    rtl8723a_process_phy_info(padapter, (void *)precvframe);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_565(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_566(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_567(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_568(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_569(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_579(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_581(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_580(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_583(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_582(struct workqueue_struct *ldv_func_arg1 ) ;
int rtl8723au_write_port(struct rtw_adapter *padapter , u32 addr , u32 cnt , struct xmit_buf *pxmitbuf ) ;
bool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter , struct xmit_priv *pxmitpriv ,
                                  struct xmit_buf *pxmitbuf ) ;
static int urb_zero_packet_chk(struct rtw_adapter *padapter , int sz ) 
{ 
  int blnSetTxDescOffset ;
  struct dvobj_priv *pdvobj ;

  {
  pdvobj = padapter->dvobj;
  if ((unsigned int )pdvobj->ishighspeed != 0U) {
    if (((unsigned int )(sz + 32) & 511U) == 0U) {
      blnSetTxDescOffset = 1;
    } else {
      blnSetTxDescOffset = 0;
    }
  } else
  if (((unsigned int )(sz + 32) & 63U) == 0U) {
    blnSetTxDescOffset = 1;
  } else {
    blnSetTxDescOffset = 0;
  }
  return (blnSetTxDescOffset);
}
}
static void rtl8192cu_cal_txdesc_chksum(struct tx_desc *ptxdesc ) 
{ 
  __le16 *usPtr ;
  u32 count ;
  u32 index ;
  u16 checksum ;

  {
  usPtr = (__le16 *)ptxdesc;
  count = 16U;
  checksum = 0U;
  ptxdesc->txdw7 = ptxdesc->txdw7 & 4294901760U;
  index = 0U;
  goto ldv_55777;
  ldv_55776: 
  checksum = (u16 )((int )*(usPtr + (unsigned long )index) ^ (int )checksum);
  index = index + 1U;
  ldv_55777: ;
  if (index < count) {
    goto ldv_55776;
  } else {

  }
  ptxdesc->txdw7 = ptxdesc->txdw7 | (__le32 )checksum;
  return;
}
}
static void fill_txdesc_sectype(struct pkt_attrib *pattrib , struct tx_desc *ptxdesc ) 
{ 


  {
  if (pattrib->encrypt != 0U && (unsigned int )pattrib->bswenc == 0U) {
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4194304U;
    goto ldv_55785;
    case 1027074U: 
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4194304U;
    goto ldv_55785;
    case 1027076U: 
    ptxdesc->txdw1 = ptxdesc->txdw1 | 12582912U;
    goto ldv_55785;
    case 0U: ;
    default: ;
    goto ldv_55785;
    }
    ldv_55785: ;
  } else {

  }
  return;
}
}
static void fill_txdesc_vcs(struct pkt_attrib *pattrib , __le32 *pdw ) 
{ 


  {
  switch ((int )pattrib->vcs_mode) {
  case 1: 
  *pdw = *pdw | 4096U;
  goto ldv_55795;
  case 2: 
  *pdw = *pdw | 2048U;
  goto ldv_55795;
  case 0: ;
  default: ;
  goto ldv_55795;
  }
  ldv_55795: ;
  if ((unsigned int )pattrib->vcs_mode != 0U) {
    *pdw = *pdw | 8192U;
    if ((unsigned int )pattrib->ht_en != 0U) {
      *pdw = *pdw | ((int )pattrib->bwmode & 1 ? 134217728U : 0U);
      if ((unsigned int )pattrib->ch_offset == 1U) {
        *pdw = *pdw | 268435456U;
      } else
      if ((unsigned int )pattrib->ch_offset == 2U) {
        *pdw = *pdw | 536870912U;
      } else
      if ((unsigned int )pattrib->ch_offset == 0U) {
        *pdw = *pdw;
      } else {
        *pdw = *pdw | 805306368U;
      }
    } else {

    }
  } else {

  }
  return;
}
}
static void fill_txdesc_phy(struct pkt_attrib *pattrib , __le32 *pdw ) 
{ 


  {
  if ((unsigned int )pattrib->ht_en != 0U) {
    *pdw = *pdw | ((int )pattrib->bwmode & 1 ? 33554432U : 0U);
    if ((unsigned int )pattrib->ch_offset == 1U) {
      *pdw = *pdw | 1048576U;
    } else
    if ((unsigned int )pattrib->ch_offset == 2U) {
      *pdw = *pdw | 2097152U;
    } else
    if ((unsigned int )pattrib->ch_offset == 0U) {
      *pdw = *pdw;
    } else {
      *pdw = *pdw | 3145728U;
    }
  } else {

  }
  return;
}
}
static s32 update_txdesc(struct xmit_frame *pxmitframe , u8 *pmem , s32 sz ) 
{ 
  int pull ;
  uint qsel ;
  struct rtw_adapter *padapter ;
  struct pkt_attrib *pattrib ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct tx_desc *ptxdesc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bmcst ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;

  {
  pull = 0;
  padapter = pxmitframe->padapter;
  pattrib = & pxmitframe->attrib;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  ptxdesc = (struct tx_desc *)pmem;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
  bmcst = (int )tmp;
  tmp___0 = urb_zero_packet_chk(padapter, sz);
  if (tmp___0 == 0) {
    ptxdesc = (struct tx_desc *)pmem + 8U;
    pull = 1;
    pxmitframe->pkt_offset = (s8 )((int )pxmitframe->pkt_offset - 1);
  } else {

  }
  memset((void *)ptxdesc, 0, 32UL);
  if (pxmitframe->frame_tag == 1) {
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )pattrib->mac_id & 31U);
    qsel = (unsigned int )pattrib->qsel & 31U;
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((qsel << 8) & 7936U);
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pattrib->raid << 16) & 983040U);
    fill_txdesc_sectype(pattrib, ptxdesc);
    if ((unsigned int )pattrib->ampdu_en != 0U) {
      ptxdesc->txdw1 = ptxdesc->txdw1 | 32U;
    } else {
      ptxdesc->txdw1 = ptxdesc->txdw1 | 64U;
    }
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
    if ((unsigned int )pattrib->qos_en != 0U) {
      ptxdesc->txdw4 = ptxdesc->txdw4 | 64U;
    } else {

    }
    if (((unsigned int )pattrib->ether_type != 34958U && (unsigned int )pattrib->ether_type != 2054U) && (unsigned int )pattrib->dhcp_pkt != 1U) {
      fill_txdesc_vcs(pattrib, & ptxdesc->txdw4);
      fill_txdesc_phy(pattrib, & ptxdesc->txdw4);
      ptxdesc->txdw4 = ptxdesc->txdw4 | 8U;
      ptxdesc->txdw5 = ptxdesc->txdw5 | 130816U;
      ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )pdmpriv->INIDATA_RATE[(int )pattrib->mac_id];
    } else {
      ptxdesc->txdw1 = ptxdesc->txdw1 | 64U;
      ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
      if ((unsigned int )pmlmeinfo->preamble_mode == 3U) {
        ptxdesc->txdw4 = ptxdesc->txdw4 | 16777216U;
      } else {

      }
      tmp___1 = MRateToHwRate23a((int )pmlmeext->tx_rate);
      ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___1;
    }
  } else
  if (pxmitframe->frame_tag == 3) {
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )pattrib->mac_id & 31U);
    qsel = (unsigned int )pattrib->qsel & 31U;
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((qsel << 8) & 7936U);
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pattrib->raid << 16) & 983040U);
    if ((unsigned int )pxmitframe->ack_report != 0U) {
      ptxdesc->txdw2 = ptxdesc->txdw2 | 524288U;
    } else {

    }
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
    ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
    ptxdesc->txdw5 = ptxdesc->txdw5 | 131072U;
    ptxdesc->txdw5 = ptxdesc->txdw5 | 1572864U;
    tmp___2 = MRateToHwRate23a((int )pmlmeext->tx_rate);
    ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___2;
  } else
  if (pxmitframe->frame_tag == 8) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
    } else {

    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
    } else {

    }
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4U;
    ptxdesc->txdw1 = ptxdesc->txdw1 | 393216U;
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
    ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
    tmp___3 = MRateToHwRate23a((int )pmlmeext->tx_rate);
    ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___3;
  }
  if ((unsigned int )pattrib->qos_en == 0U) {
    ptxdesc->txdw4 = ptxdesc->txdw4 | 128U;
    ptxdesc->txdw3 = ptxdesc->txdw3 | 2147483648U;
  } else {

  }
  ptxdesc->txdw0 = ptxdesc->txdw0 | ((__le32 )sz & 65535U);
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2348810240U;
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2097152U;
  if (bmcst != 0) {
    ptxdesc->txdw0 = ptxdesc->txdw0 | 16777216U;
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "offset0-txdesc = 0x%x\n", ptxdesc->txdw0);
  } else {

  }
  if ((int )pxmitframe->pkt_offset > 0) {
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pxmitframe->pkt_offset << 26) & 2080374784U);
  } else {

  }
  rtl8192cu_cal_txdesc_chksum(ptxdesc);
  return (pull);
}
}
static int rtw_dump_xframe(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int ret ;
  int inner_ret ;
  int t ;
  int sz ;
  int w_sz ;
  int pull ;
  u8 *mem_addr ;
  u32 ff_hwaddr ;
  struct xmit_buf *pxmitbuf ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;

  {
  ret = 1;
  inner_ret = 1;
  pull = 0;
  pxmitbuf = pxmitframe->pxmitbuf;
  pattrib = & pxmitframe->attrib;
  pxmitpriv = & padapter->xmitpriv;
  if (((pxmitframe->frame_tag == 1 && (unsigned int )pxmitframe->attrib.ether_type != 2054U) && (unsigned int )pxmitframe->attrib.ether_type != 34958U) && (unsigned int )pxmitframe->attrib.dhcp_pkt != 1U) {
    rtw_issue_addbareq_cmd23a(padapter, pxmitframe);
  } else {

  }
  mem_addr = pxmitframe->buf_addr;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "rtw_dump_xframe()\n");
  } else {

  }
  t = 0;
  goto ldv_55834;
  ldv_55833: ;
  if (inner_ret != 1 && ret == 1) {
    ret = 0;
  } else {

  }
  if ((int )pattrib->nr_frags + -1 != t) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1, 4, "pattrib->nr_frags =%d\n", (int )pattrib->nr_frags);
    } else {

    }
    sz = (int )pxmitpriv->frag_len;
    sz = (sz + -4) - (int )pattrib->icv_len;
  } else {
    sz = (int )pattrib->last_txcmdsz;
  }
  pull = update_txdesc(pxmitframe, mem_addr, sz);
  if (pull != 0) {
    mem_addr = mem_addr + 8UL;
    pxmitframe->buf_addr = mem_addr;
    w_sz = sz + 32;
  } else {
    w_sz = sz + 40;
  }
  ff_hwaddr = rtw_get_ff_hwaddr23a(pxmitframe);
  inner_ret = rtl8723au_write_port(padapter, ff_hwaddr, (u32 )w_sz, pxmitbuf);
  rtw_count_tx_stats23a(padapter, pxmitframe, sz);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "rtw_write_port, w_sz =%d\n", w_sz);
  } else {

  }
  mem_addr = mem_addr + (unsigned long )w_sz;
  mem_addr = (u8 *)(((unsigned long )mem_addr + 3UL) & 0xfffffffffffffffcUL);
  t = t + 1;
  ldv_55834: ;
  if ((int )pattrib->nr_frags > t) {
    goto ldv_55833;
  } else {

  }
  rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
  if (ret != 1) {
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 1);
  } else {

  }
  return (ret);
}
}
bool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter , struct xmit_priv *pxmitpriv ,
                                  struct xmit_buf *pxmitbuf ) 
{ 
  struct hw_xmit *phwxmits ;
  struct xmit_frame *pxmitframe ;
  int hwentry ;
  int res ;
  int xcnt ;

  {
  res = 1;
  xcnt = 0;
  phwxmits = pxmitpriv->hwxmits;
  hwentry = (int )pxmitpriv->hwxmit_entry;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(1, 7, "xmitframe_complete()\n");
  } else {

  }
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    pxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);
    if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
      return (0);
    } else {

    }
  } else {

  }
  pxmitframe = rtw_dequeue_xframe23a(pxmitpriv, phwxmits, hwentry);
  if ((unsigned long )pxmitframe != (unsigned long )((struct xmit_frame *)0)) {
    pxmitframe->pxmitbuf = pxmitbuf;
    pxmitframe->buf_addr = pxmitbuf->pbuf;
    pxmitbuf->priv_data = (void *)pxmitframe;
    if (pxmitframe->frame_tag == 1) {
      if ((unsigned int )pxmitframe->attrib.priority <= 15U) {
        res = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);
      } else {

      }
      rtw_os_xmit_complete23a(padapter, pxmitframe);
    } else {

    }
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(1, 7, "xmitframe_complete(): rtw_dump_xframe\n");
    } else {

    }
    if (res == 1) {
      rtw_dump_xframe(padapter, pxmitframe);
    } else {
      rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
      rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    }
    xcnt = xcnt + 1;
  } else {
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
    return (0);
  }
  return (1);
}
}
static int xmitframe_direct(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int res ;

  {
  res = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);
  if (res == 1) {
    rtw_dump_xframe(padapter, pxmitframe);
  } else {

  }
  return (res);
}
}
bool rtl8723au_hal_xmit(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int res ;
  struct xmit_buf *pxmitbuf ;
  struct xmit_priv *pxmitpriv ;
  struct pkt_attrib *pattrib ;
  struct mlme_priv *pmlmepriv ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  int tmp ;
  s32 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  pxmitbuf = (struct xmit_buf *)0;
  pxmitpriv = & padapter->xmitpriv;
  pattrib = & pxmitframe->attrib;
  pmlmepriv = & padapter->mlmepriv;
  pattrib->qsel = pattrib->priority;
  spin_lock_bh(& pxmitpriv->lock);
  tmp = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
  if (tmp != 0) {
    pstapriv = & padapter->stapriv;
    spin_unlock_bh(& pxmitpriv->lock);
    if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
      psta = pattrib->psta;
    } else {
      psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
    }
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      if (psta->sleepq_len > 32U) {
        wakeup_sta_to_xmit23a(padapter, psta);
      } else {

      }
    } else {

    }
    return (0);
  } else {

  }
  tmp___0 = rtw_txframes_sta_ac_pending23a(padapter, pattrib);
  if (tmp___0 > 0) {
    goto enqueue;
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 2176);
  if ((int )tmp___1) {
    goto enqueue;
  } else {

  }
  pxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    goto enqueue;
  } else {

  }
  spin_unlock_bh(& pxmitpriv->lock);
  pxmitframe->pxmitbuf = pxmitbuf;
  pxmitframe->buf_addr = pxmitbuf->pbuf;
  pxmitbuf->priv_data = (void *)pxmitframe;
  tmp___2 = xmitframe_direct(padapter, pxmitframe);
  if (tmp___2 != 1) {
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
  } else {

  }
  return (1);
  enqueue: 
  res = rtw_xmitframe_enqueue23a(padapter, pxmitframe);
  spin_unlock_bh(& pxmitpriv->lock);
  if (res != 1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2, 4, "pre_xmitframe: enqueue xmitframe fail\n");
    } else {

    }
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    pxmitpriv->tx_pkts = pxmitpriv->tx_pkts - 1ULL;
    pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
    return (1);
  } else {

  }
  return (0);
}
}
int rtl8723au_mgnt_xmit(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 
  int tmp ;

  {
  tmp = rtw_dump_xframe(padapter, pmgntframe);
  return (tmp);
}
}
int rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct xmit_priv *pxmitpriv ;
  int err ;

  {
  pxmitpriv = & padapter->xmitpriv;
  err = rtw_xmitframe_enqueue23a(padapter, pxmitframe);
  if (err != 1) {
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    pxmitpriv->tx_pkts = pxmitpriv->tx_pkts - 1ULL;
    pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
  } else {
    tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  }
  return (err);
}
}
bool ldv_queue_work_on_579(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_580(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_581(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_582(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_583(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_593(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_595(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_594(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_597(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_596(struct workqueue_struct *ldv_func_arg1 ) ;
int rtl8723au_hal_init(struct rtw_adapter *Adapter ) ;
int rtl8723au_hal_deinit(struct rtw_adapter *padapter ) ;
enum rt_rf_power_state RfOnOffDetect23a(struct rtw_adapter *pAdapter ) ;
int rtl8723au_inirp_init(struct rtw_adapter *Adapter ) ;
int rtl8723au_inirp_deinit(struct rtw_adapter *Adapter ) ;
void rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter ) ;
void rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter ) ;
void BT_HaltProcess(struct rtw_adapter *padapter ) ;
void rtl8723a_read_adapter_info(struct rtw_adapter *Adapter ) ;
int rtl8723au_read_port(struct rtw_adapter *adapter , u32 cnt , struct recv_buf *precvbuf ) ;
void rtl8723au_read_port_cancel(struct rtw_adapter *padapter ) ;
int rtl8723au_read_interrupt(struct rtw_adapter *adapter ) ;
bool rtl8723au_chip_configure(struct rtw_adapter *padapter ) ;
static void phy_SsPwrSwitch92CU(struct rtw_adapter *Adapter , enum rt_rf_power_state eRFPowerState ) ;
static void _ConfigChipOutEP(struct rtw_adapter *pAdapter , u8 NumOutPipe ) 
{ 
  u8 value8 ;
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pHalData->OutEpQueueSel = 0U;
  pHalData->OutEpNumber = 0U;
  value8 = rtl8723au_read8(pAdapter, 65126);
  if (((int )value8 & 15) != 0) {
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 1U);
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
  if ((((int )value8 >> 4) & 15) != 0) {
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 4U);
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
  value8 = rtl8723au_read8(pAdapter, 65127);
  if (((int )value8 & 15) != 0) {
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 2U);
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
  return;
}
}
bool rtl8723au_chip_configure(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dvobj_priv *pdvobjpriv ;
  u8 NumInPipe ;
  u8 NumOutPipe ;
  bool tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdvobjpriv = padapter->dvobj;
  NumInPipe = pdvobjpriv->RtNumInPipes;
  NumOutPipe = pdvobjpriv->RtNumOutPipes;
  _ConfigChipOutEP(padapter, (int )NumOutPipe);
  if ((unsigned int )pHalData->OutEpNumber == 1U) {
    if ((unsigned int )NumInPipe != 1U) {
      return (0);
    } else {

    }
  } else {

  }
  tmp = Hal_MappingOutPipe23a(padapter, (int )NumOutPipe);
  return (tmp);
}
}
static int _InitPowerOn(struct rtw_adapter *padapter ) 
{ 
  u16 value16 ;
  u8 value8 ;
  u8 tmp ;

  {
  rtl8723au_write8(padapter, 28, 0);
  tmp = HalPwrSeqCmdParsing23a(padapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_card_enable_flow));
  if ((unsigned int )tmp == 0U) {
    return (0);
  } else {

  }
  value8 = rtl8723au_read8(padapter, 6);
  rtl8723au_write8(padapter, 6, (int )((unsigned int )value8 | 8U));
  value16 = rtl8723au_read16(padapter, 256);
  value16 = (u16 )((unsigned int )value16 | 1791U);
  rtl8723au_write16(padapter, 256, (int )value16);
  PHY_SetBBReg(padapter, 48U, 1879048192U, 6U);
  return (1);
}
}
static void _InitInterrupt(struct rtw_adapter *Adapter ) 
{ 
  u32 value32 ;

  {
  value32 = 4294967295U;
  rtl8723au_write32(Adapter, 292, value32);
  rtl8723au_write32(Adapter, 288, value32);
  return;
}
}
static void _InitQueueReservedPage(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct registry_priv *pregistrypriv ;
  u32 numHQ ;
  u32 numLQ ;
  u32 numNQ ;
  u32 numPubQ ;
  u32 value32 ;
  u8 value8 ;
  bool bWiFiConfig ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pregistrypriv = & Adapter->registrypriv;
  numHQ = 0U;
  numLQ = 0U;
  numNQ = 0U;
  bWiFiConfig = (unsigned int )pregistrypriv->wifi_spec != 0U;
  numPubQ = (int )bWiFiConfig ? 176U : 231U;
  if ((int )pHalData->OutEpQueueSel & 1) {
    numHQ = (int )bWiFiConfig ? 41U : 12U;
  } else {

  }
  if (((unsigned long )pHalData->OutEpQueueSel & 2UL) != 0UL) {
    numLQ = (int )bWiFiConfig ? 28U : 2U;
  } else {

  }
  if (((unsigned long )pHalData->OutEpQueueSel & 4UL) != 0UL) {
    numNQ = (int )bWiFiConfig ? 28U : 2U;
  } else {

  }
  value8 = (unsigned char )numNQ;
  rtl8723au_write8(Adapter, 532, (int )value8);
  value32 = (((numHQ & 255U) | ((numLQ << 8) & 65535U)) | ((numPubQ & 255U) << 16)) | 2147483648U;
  rtl8723au_write32(Adapter, 512, value32);
  return;
}
}
static void _InitTxBufferBoundary(struct rtw_adapter *Adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  u8 txpktbuf_bndy ;

  {
  pregistrypriv = & Adapter->registrypriv;
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
    txpktbuf_bndy = 249U;
  } else {
    txpktbuf_bndy = 246U;
  }
  rtl8723au_write8(Adapter, 1060, (int )txpktbuf_bndy);
  rtl8723au_write8(Adapter, 1061, (int )txpktbuf_bndy);
  rtl8723au_write8(Adapter, 1117, (int )txpktbuf_bndy);
  rtl8723au_write8(Adapter, 276, (int )txpktbuf_bndy);
  rtl8723au_write8(Adapter, 521, (int )txpktbuf_bndy);
  return;
}
}
static void _InitPageBoundary(struct rtw_adapter *Adapter ) 
{ 
  u16 rxff_bndy ;

  {
  rxff_bndy = 10239U;
  rtl8723au_write16(Adapter, 278, (int )rxff_bndy);
  return;
}
}
static void _InitNormalChipRegPriority(struct rtw_adapter *Adapter , u16 beQ , u16 bkQ ,
                                       u16 viQ , u16 voQ , u16 mgtQ , u16 hiQ ) 
{ 
  u16 value16 ;
  u16 tmp ;

  {
  tmp = rtl8723au_read16(Adapter, 268);
  value16 = (unsigned int )tmp & 7U;
  value16 = (u16 )(((((((int )((short )(((int )beQ & 3) << 8)) | (int )((short )(((int )bkQ & 3) << 10))) | ((int )((short )((int )viQ << 6)) & 255)) | (int )((short )(((int )voQ & 3) << 4))) | (int )((short )(((int )mgtQ & 3) << 12))) | (int )((short )((int )hiQ << 14))) | (int )((short )value16));
  rtl8723au_write16(Adapter, 268, (int )value16);
  return;
}
}
static void _InitNormalChipOneOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 value ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  value = 0U;
  switch ((int )pHalData->OutEpQueueSel) {
  case 1: 
  value = 3U;
  goto ldv_55852;
  case 2: 
  value = 1U;
  goto ldv_55852;
  case 4: 
  value = 2U;
  goto ldv_55852;
  default: ;
  goto ldv_55852;
  }
  ldv_55852: 
  _InitNormalChipRegPriority(Adapter, (int )value, (int )value, (int )value, (int )value,
                             (int )value, (int )value);
  return;
}
}
static void _InitNormalChipTwoOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct registry_priv *pregistrypriv ;
  u16 beQ ;
  u16 bkQ ;
  u16 viQ ;
  u16 voQ ;
  u16 mgtQ ;
  u16 hiQ ;
  u16 valueHi ;
  u16 valueLow ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pregistrypriv = & Adapter->registrypriv;
  valueHi = 0U;
  valueLow = 0U;
  switch ((int )pHalData->OutEpQueueSel) {
  case 3: 
  valueHi = 3U;
  valueLow = 1U;
  goto ldv_55870;
  case 6: 
  valueHi = 2U;
  valueLow = 1U;
  goto ldv_55870;
  case 5: 
  valueHi = 3U;
  valueLow = 2U;
  goto ldv_55870;
  default: ;
  goto ldv_55870;
  }
  ldv_55870: ;
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
    beQ = valueLow;
    bkQ = valueLow;
    viQ = valueHi;
    voQ = valueHi;
    mgtQ = valueHi;
    hiQ = valueHi;
  } else {
    beQ = valueLow;
    bkQ = valueHi;
    viQ = valueHi;
    voQ = valueLow;
    mgtQ = valueHi;
    hiQ = valueHi;
  }
  _InitNormalChipRegPriority(Adapter, (int )beQ, (int )bkQ, (int )viQ, (int )voQ,
                             (int )mgtQ, (int )hiQ);
  return;
}
}
static void _InitNormalChipThreeOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  u16 beQ ;
  u16 bkQ ;
  u16 viQ ;
  u16 voQ ;
  u16 mgtQ ;
  u16 hiQ ;

  {
  pregistrypriv = & Adapter->registrypriv;
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
    beQ = 1U;
    bkQ = 1U;
    viQ = 2U;
    voQ = 3U;
    mgtQ = 3U;
    hiQ = 3U;
  } else {
    beQ = 1U;
    bkQ = 2U;
    viQ = 2U;
    voQ = 3U;
    mgtQ = 3U;
    hiQ = 3U;
  }
  _InitNormalChipRegPriority(Adapter, (int )beQ, (int )bkQ, (int )viQ, (int )voQ,
                             (int )mgtQ, (int )hiQ);
  return;
}
}
static void _InitQueuePriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  switch ((int )pHalData->OutEpNumber) {
  case 1: 
  _InitNormalChipOneOutEpPriority(Adapter);
  goto ldv_55889;
  case 2: 
  _InitNormalChipTwoOutEpPriority(Adapter);
  goto ldv_55889;
  case 3: 
  _InitNormalChipThreeOutEpPriority(Adapter);
  goto ldv_55889;
  default: ;
  goto ldv_55889;
  }
  ldv_55889: ;
  return;
}
}
static void _InitTransferPageSize(struct rtw_adapter *Adapter ) 
{ 
  u8 value8 ;

  {
  value8 = 17U;
  rtl8723au_write8(Adapter, 260, (int )value8);
  return;
}
}
static void _InitDriverInfoSize(struct rtw_adapter *Adapter , u8 drvInfoSize ) 
{ 


  {
  rtl8723au_write8(Adapter, 1551, (int )drvInfoSize);
  return;
}
}
static void _InitWMACSetting(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pHalData->ReceiveConfig = 1879072974U;
  rtl8723au_write32(Adapter, 1544, pHalData->ReceiveConfig);
  rtl8723au_write32(Adapter, 1568, 4294967295U);
  rtl8723au_write32(Adapter, 1572, 4294967295U);
  return;
}
}
static void _InitAdaptiveCtrl(struct rtw_adapter *Adapter ) 
{ 
  u16 value16 ;
  u32 value32 ;

  {
  value32 = rtl8723au_read32(Adapter, 1088);
  value32 = value32 & 4293918720U;
  value32 = value32 | 1048561U;
  rtl8723au_write32(Adapter, 1088, value32);
  value16 = 4112U;
  rtl8723au_write16(Adapter, 1064, (int )value16);
  value16 = 12336U;
  rtl8723au_write16(Adapter, 1066, (int )value16);
  return;
}
}
static void _InitRateFallback(struct rtw_adapter *Adapter ) 
{ 


  {
  rtl8723au_write32(Adapter, 1072, 0U);
  rtl8723au_write32(Adapter, 1076, 268960772U);
  rtl8723au_write32(Adapter, 1080, 67305985U);
  rtl8723au_write32(Adapter, 1084, 134678021U);
  return;
}
}
static void _InitEDCA(struct rtw_adapter *Adapter ) 
{ 


  {
  rtl8723au_write16(Adapter, 1064, 4106);
  rtl8723au_write16(Adapter, 1594, 4106);
  rtl8723au_write16(Adapter, 1300, 4106);
  rtl8723au_write16(Adapter, 1302, 4106);
  rtl8723au_write32(Adapter, 1288, 6202411U);
  rtl8723au_write32(Adapter, 1292, 42063U);
  rtl8723au_write32(Adapter, 1284, 6202148U);
  rtl8723au_write32(Adapter, 1280, 3121702U);
  return;
}
}
static void _InitRDGSetting(struct rtw_adapter *Adapter ) 
{ 


  {
  rtl8723au_write8(Adapter, 1316, 255);
  rtl8723au_write16(Adapter, 1348, 512);
  rtl8723au_write8(Adapter, 1123, 5);
  return;
}
}
static void _InitRetryFunction(struct rtw_adapter *Adapter ) 
{ 
  u8 value8 ;

  {
  value8 = rtl8723au_read8(Adapter, 1056);
  value8 = (u8 )((unsigned int )value8 | 128U);
  rtl8723au_write8(Adapter, 1056, (int )value8);
  rtl8723au_write8(Adapter, 1600, 64);
  return;
}
}
static void _InitRFType(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pHalData->rf_type = 3U;
  return;
}
}
static void _BBTurnOnBlock(struct rtw_adapter *Adapter ) 
{ 


  {
  PHY_SetBBReg(Adapter, 2048U, 16777216U, 1U);
  PHY_SetBBReg(Adapter, 2048U, 33554432U, 1U);
  return;
}
}
static void _RfPowerSave(struct rtw_adapter *padapter ) 
{ 


  {
  return;
}
}
enum rt_rf_power_state RfOnOffDetect23a(struct rtw_adapter *pAdapter ) 
{ 
  u8 val8 ;
  enum rt_rf_power_state rfpowerstate ;
  u8 tmp ;

  {
  rfpowerstate = 2;
  tmp = rtl8723au_read8(pAdapter, 67);
  rtl8723au_write8(pAdapter, 67, (int )tmp & 247);
  val8 = rtl8723au_read8(pAdapter, 66);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: GPIO_IN =%02x\n", (int )val8);
  } else {

  }
  rfpowerstate = ((unsigned long )val8 & 8UL) != 0UL ? 0 : 2;
  return (rfpowerstate);
}
}
int rtl8723au_hal_init(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct pwrctrl_priv *pwrctrlpriv ;
  struct registry_priv *pregistrypriv ;
  u8 val8 ;
  u32 boundary ;
  int status ;
  bool mac_on ;
  unsigned long init_start_time ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  unsigned int tmp___2 ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pwrctrlpriv = & Adapter->pwrctrlpriv;
  pregistrypriv = & Adapter->registrypriv;
  val8 = 0U;
  status = 1;
  init_start_time = jiffies;
  Adapter->hw_init_completed = 0U;
  if ((unsigned int )Adapter->pwrctrlpriv.bkeepfwalive != 0U) {
    phy_SsPwrSwitch92CU(Adapter, 0);
    if ((unsigned int )pHalData->bIQKInitialized != 0U) {
      rtl8723a_phy_iq_calibrate(Adapter, 1);
    } else {
      rtl8723a_phy_iq_calibrate(Adapter, 0);
      pHalData->bIQKInitialized = 1U;
    }
    rtl8723a_odm_check_tx_power_tracking(Adapter);
    rtl8723a_phy_lc_calibrate(Adapter);
    goto exit;
  } else {

  }
  val8 = rtl8723au_read8(Adapter, 256);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "%s: REG_CR 0x100 = 0x%02x\n", "rtl8723au_hal_init", (int )val8);
  } else {

  }
  if ((unsigned int )val8 == 234U) {
    mac_on = 0;
  } else {
    mac_on = 1;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(32768, 7, "%s: MAC has already power on\n", "rtl8723au_hal_init");
    } else {

    }
  }
  status = _InitPowerOn(Adapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(32768, 4, "Failed to init power on!\n");
    } else {

    }
    goto exit;
  } else {

  }
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
    boundary = 249U;
  } else {
    boundary = 246U;
  }
  if (! mac_on) {
    status = InitLLTTable23a(Adapter, boundary);
    if (status == 0) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(32768, 4, "Failed to init LLT table\n");
      } else {

      }
      goto exit;
    } else {

    }
  } else {

  }
  if ((int )pHalData->bRDGEnable) {
    _InitRDGSetting(Adapter);
  } else {

  }
  status = rtl8723a_FirmwareDownload(Adapter);
  if (status != 1) {
    Adapter->bFWReady = 0U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: fw download fail!\n");
    } else {

    }
    goto exit;
  } else {
    Adapter->bFWReady = 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: fw download ok!\n");
    } else {

    }
  }
  rtl8723a_InitializeFirmwareVars(Adapter);
  if ((unsigned int )pwrctrlpriv->reg_rfoff == 1U) {
    pwrctrlpriv->rf_pwrstate = 2;
  } else {

  }
  _InitRFType(Adapter);
  pHalData->CurrentChannel = 6U;
  status = PHY_MACConfig8723A(Adapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: PHY_MACConfig8723A fault !!\n");
    } else {

    }
    goto exit;
  } else {

  }
  status = PHY_BBConfig8723A(Adapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: PHY_BBConfig8723A fault !!\n");
    } else {

    }
    goto exit;
  } else {

  }
  status = PHY_RF6052_Config8723A(Adapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: PHY_RF6052_Config8723A failed!!\n");
    } else {

    }
    goto exit;
  } else {

  }
  rtl8723au_write32(Adapter, 36, 58818701U);
  rtl8723au_write32(Adapter, 40, 4043308931U);
  rtl8723au_write32(Adapter, 40, 4043308930U);
  rtl8723au_write32(Adapter, 40, 4043308931U);
  rtl8723au_write32(Adapter, 2052, 3U);
  rtl8723au_write32(Adapter, 2160, 117442400U);
  rtl8723au_write32(Adapter, 2144, 1727398416U);
  if (GlobalDebugLevel23A > 6U) {
    tmp = rtl8723au_read32(Adapter, 2160);
    rt_trace(32768, 7, "%s: 0x870 = value 0x%x\n", "rtl8723au_hal_init", tmp);
  } else {

  }
  pHalData->RfRegChnlVal[0] = PHY_QueryRFReg(Adapter, 0, 24U, 1048575U);
  pHalData->RfRegChnlVal[1] = PHY_QueryRFReg(Adapter, 1, 24U, 1048575U);
  if (! mac_on) {
    _InitQueueReservedPage(Adapter);
    _InitTxBufferBoundary(Adapter);
  } else {

  }
  _InitQueuePriority(Adapter);
  _InitPageBoundary(Adapter);
  _InitTransferPageSize(Adapter);
  _InitDriverInfoSize(Adapter, 4);
  _InitInterrupt(Adapter);
  hw_var_set_macaddr(Adapter, (u8 *)(& Adapter->eeprompriv.mac_addr));
  rtl8723a_set_media_status(Adapter, 2);
  _InitWMACSetting(Adapter);
  _InitAdaptiveCtrl(Adapter);
  _InitEDCA(Adapter);
  _InitRateFallback(Adapter);
  _InitRetryFunction(Adapter);
  rtl8723a_InitBeaconParameters(Adapter);
  _BBTurnOnBlock(Adapter);
  rtl8723a_cam_invalidate_all(Adapter);
  PHY_SetTxPowerLevel8723A(Adapter, (int )pHalData->CurrentChannel);
  rtl8723a_InitAntenna_Selection(Adapter);
  rtl8723au_write8(Adapter, 1059, 255);
  rtl8723au_write32(Adapter, 1228, 33685503U);
  if ((unsigned int )pregistrypriv->wifi_spec != 0U) {
    rtl8723au_write16(Adapter, 1120, 0);
  } else {

  }
  _RfPowerSave(Adapter);
  if ((unsigned int )pwrctrlpriv->rf_pwrstate == 0U) {
    if ((unsigned int )pHalData->bIQKInitialized != 0U) {
      rtl8723a_phy_iq_calibrate(Adapter, 1);
    } else {
      rtl8723a_phy_iq_calibrate(Adapter, 0);
      pHalData->bIQKInitialized = 1U;
    }
    rtl8723a_odm_check_tx_power_tracking(Adapter);
    rtl8723a_phy_lc_calibrate(Adapter);
    rtl8723a_dual_antenna_detection(Adapter);
  } else {

  }
  rtl8723au_write8(Adapter, 65088, 224);
  rtl8723au_write8(Adapter, 65089, 141);
  rtl8723au_write8(Adapter, 65090, 128);
  rtl8723au_write32(Adapter, 524, 16581408U);
  if (((unsigned int )pHalData->VersionID.ICType != 2U && (unsigned int )pHalData->VersionID.ICType != 1U) || ((unsigned int )pHalData->VersionID.VendorType != 1U || (unsigned int )pHalData->VersionID.CUTVersion != 0U)) {
    rtl8723au_write8(Adapter, 65088, 230);
    rtl8723au_write8(Adapter, 65089, 148);
    rtl8723au_write8(Adapter, 65090, 128);
    rtl8723au_write8(Adapter, 65088, 224);
    rtl8723au_write8(Adapter, 65089, 25);
    rtl8723au_write8(Adapter, 65090, 128);
    rtl8723au_write8(Adapter, 65088, 229);
    rtl8723au_write8(Adapter, 65089, 145);
    rtl8723au_write8(Adapter, 65090, 128);
    rtl8723au_write8(Adapter, 65088, 226);
    rtl8723au_write8(Adapter, 65089, 129);
    rtl8723au_write8(Adapter, 65090, 128);
  } else {

  }
  rtl8723a_BT_init_hwconfig(Adapter);
  rtl8723a_InitHalDm(Adapter);
  val8 = 235U;
  rtl8723au_write8(Adapter, 1618, (int )val8);
  tmp___0 = rtl8723au_read32(Adapter, 2048);
  if ((tmp___0 & 4278190080U) != 2197815296U) {
    PHY_SetBBReg(Adapter, 2048U, 16777216U, 1U);
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(32768, 4, "%s: IQK fail recover\n", "rtl8723au_hal_init");
    } else {

    }
  } else {

  }
  tmp___1 = rtl8723au_read32(Adapter, 1056);
  rtl8723au_write32(Adapter, 1056, tmp___1 | 4096U);
  exit: ;
  if (status == 1) {
    Adapter->hw_init_completed = 1U;
    if ((unsigned int )Adapter->registrypriv.notch_filter == 1U) {
      rtl8723a_notch_filter(Adapter, 1);
    } else {

    }
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    tmp___2 = jiffies_to_msecs((unsigned long )jiffies - init_start_time);
    printk("\016RTL8723AU: %s in %dms\n", "rtl8723au_hal_init", tmp___2);
  } else {

  }
  return (status);
}
}
static void phy_SsPwrSwitch92CU(struct rtw_adapter *Adapter , enum rt_rf_power_state eRFPowerState ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 sps0 ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  sps0 = rtl8723au_read8(Adapter, 17);
  switch ((unsigned int )eRFPowerState) {
  case 0U: 
  rtl8723au_write8(Adapter, 17, (int )((unsigned int )sps0 | 9U));
  if ((unsigned int )pHalData->rf_type == 2U) {
    PHY_SetBBReg(Adapter, 2168U, 3670072U, 1U);
  } else {
    PHY_SetBBReg(Adapter, 2168U, 56U, 1U);
  }
  PHY_SetBBReg(Adapter, 3076U, 240U, 1U);
  PHY_SetBBReg(Adapter, 2048U, 2U, 0U);
  if ((unsigned int )pHalData->rf_type == 2U) {
    rtl8723au_write32(Adapter, 3696, 1675306400U);
  } else
  if ((unsigned int )pHalData->rf_type == 3U) {
    rtl8723au_write32(Adapter, 3696, 1662723488U);
  } else {

  }
  PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 208277U);
  if ((unsigned int )pHalData->rf_type == 2U) {
    PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 208277U);
  } else {

  }
  goto ldv_55961;
  case 1U: ;
  case 2U: ;
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U)) {
    sps0 = (unsigned int )sps0 & 254U;
  } else {
    sps0 = (unsigned int )sps0 & 246U;
  }
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16384, 4, "SS LVL1\n");
  } else {

  }
  tmp = rtl8723au_read32(Adapter, 2168);
  Adapter->pwrctrlpriv.PS_BBRegBackup[0] = (unsigned long )tmp;
  tmp___0 = rtl8723au_read32(Adapter, 3076);
  Adapter->pwrctrlpriv.PS_BBRegBackup[1] = (unsigned long )tmp___0;
  tmp___1 = rtl8723au_read32(Adapter, 2048);
  Adapter->pwrctrlpriv.PS_BBRegBackup[2] = (unsigned long )tmp___1;
  if ((unsigned int )pHalData->rf_type == 2U) {
    PHY_SetBBReg(Adapter, 2168U, 3670072U, 0U);
  } else
  if ((unsigned int )pHalData->rf_type == 3U) {
    PHY_SetBBReg(Adapter, 2168U, 56U, 0U);
  } else {

  }
  PHY_SetBBReg(Adapter, 3076U, 240U, 0U);
  PHY_SetBBReg(Adapter, 2048U, 2U, 1U);
  tmp___2 = rtl8723au_read32(Adapter, 3696);
  Adapter->pwrctrlpriv.PS_BBRegBackup[3] = (unsigned long )tmp___2;
  if ((unsigned int )pHalData->rf_type == 2U) {
    rtl8723au_write32(Adapter, 3696, 14362016U);
  } else
  if ((unsigned int )pHalData->rf_type == 3U) {
    rtl8723au_write32(Adapter, 3696, 1779104U);
  } else {

  }
  PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 0U);
  if ((unsigned int )pHalData->rf_type == 2U) {
    PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 0U);
  } else {

  }
  rtl8723au_write8(Adapter, 17, (int )sps0);
  goto ldv_55961;
  default: ;
  goto ldv_55961;
  }
  ldv_55961: ;
  return;
}
}
static void CardDisableRTL8723U(struct rtw_adapter *Adapter ) 
{ 
  u8 u1bTmp ;
  u8 tmp ;

  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: CardDisableRTL8723U\n");
  } else {

  }
  HalPwrSeqCmdParsing23a(Adapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_enter_lps_flow));
  rtl8723au_write8(Adapter, 31, 0);
  tmp = rtl8723au_read8(Adapter, 128);
  if ((int )((signed char )tmp) < 0 && (unsigned int )Adapter->bFWReady != 0U) {
    rtl8723a_FirmwareSelfReset(Adapter);
  } else {

  }
  u1bTmp = rtl8723au_read8(Adapter, 3);
  rtl8723au_write8(Adapter, 3, (int )u1bTmp & 251);
  rtl8723au_write8(Adapter, 128, 0);
  HalPwrSeqCmdParsing23a(Adapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_card_disable_flow));
  u1bTmp = rtl8723au_read8(Adapter, 29);
  rtl8723au_write8(Adapter, 29, (int )u1bTmp & 254);
  u1bTmp = rtl8723au_read8(Adapter, 29);
  rtl8723au_write8(Adapter, 29, (int )((unsigned int )u1bTmp | 1U));
  rtl8723au_write8(Adapter, 28, 14);
  return;
}
}
int rtl8723au_hal_deinit(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ==> %s\n", "rtl8723au_hal_deinit");
  } else {

  }
  BT_HaltProcess(padapter);
  CardDisableRTL8723U(padapter);
  padapter->hw_init_completed = 0U;
  return (1);
}
}
int rtl8723au_inirp_init(struct rtw_adapter *Adapter ) 
{ 
  u8 i ;
  struct recv_buf *precvbuf ;
  int status ;
  struct recv_priv *precvpriv ;
  struct hal_data_8723a *pHalData ;
  int tmp ;
  int tmp___0 ;

  {
  precvpriv = & Adapter->recvpriv;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  status = 1;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "===> usb_inirp_init\n");
  } else {

  }
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
  i = 0U;
  goto ldv_55983;
  ldv_55982: 
  tmp = rtl8723au_read_port(Adapter, 0U, precvbuf);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(32768, 4, "usb_rx_init: usb_read_port error\n");
    } else {

    }
    status = 0;
    goto exit;
  } else {

  }
  precvbuf = precvbuf + 1;
  i = (u8 )((int )i + 1);
  ldv_55983: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_55982;
  } else {

  }
  tmp___0 = rtl8723au_read_interrupt(Adapter);
  if (tmp___0 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(32768, 4, "%s: usb_read_interrupt error\n", "rtl8723au_inirp_init");
    } else {

    }
    status = 0;
  } else {

  }
  pHalData->IntrMask[0] = rtl8723au_read32(Adapter, 65080);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: pHalData->IntrMask = 0x%04x\n", pHalData->IntrMask[0]);
  } else {

  }
  pHalData->IntrMask[0] = pHalData->IntrMask[0] | 1280U;
  rtl8723au_write32(Adapter, 65080, pHalData->IntrMask[0]);
  exit: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "<=== usb_inirp_init\n");
  } else {

  }
  return (status);
}
}
int rtl8723au_inirp_deinit(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "===> usb_rx_deinit\n");
  } else {

  }
  rtl8723au_read_port_cancel(Adapter);
  pHalData->IntrMask[0] = rtl8723au_read32(Adapter, 65080);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s pHalData->IntrMask = 0x%04x\n", "rtl8723au_inirp_deinit",
           pHalData->IntrMask[0]);
  } else {

  }
  pHalData->IntrMask[0] = 0U;
  rtl8723au_write32(Adapter, 65080, pHalData->IntrMask[0]);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(32768, 7, "<=== usb_rx_deinit\n");
  } else {

  }
  return (1);
}
}
static void _ReadBoardType(struct rtw_adapter *Adapter , u8 *PROMContent , bool AutoloadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 boardType ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  boardType = 0U;
  if ((int )AutoloadFail) {
    if ((unsigned int )pHalData->VersionID.ICType == 4U) {
      pHalData->rf_type = 3U;
    } else {
      pHalData->rf_type = 2U;
    }
    pHalData->BoardType = boardType;
    return;
  } else {

  }
  boardType = *(PROMContent + 121UL);
  boardType = (unsigned int )boardType & 224U;
  boardType = (u8 )((int )boardType >> 5);
  pHalData->BoardType = boardType;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: _ReadBoardType(%x)\n", (int )pHalData->BoardType);
  } else {

  }
  if ((unsigned int )boardType == 1U) {
    pHalData->ExternalPA = 1U;
  } else {

  }
  return;
}
}
static void Hal_EfuseParseMACAddr_8723AU(struct rtw_adapter *padapter , u8 *hwinfo ,
                                         bool AutoLoadFail ) 
{ 
  u16 i ;
  u8 sMacAddr[6U] ;
  struct eeprom_priv *pEEPROM ;

  {
  sMacAddr[0] = 0U;
  sMacAddr[1] = 224U;
  sMacAddr[2] = 76U;
  sMacAddr[3] = 135U;
  sMacAddr[4] = 35U;
  sMacAddr[5] = 0U;
  pEEPROM = & padapter->eeprompriv;
  if ((int )AutoLoadFail) {
    i = 0U;
    goto ldv_56007;
    ldv_56006: 
    pEEPROM->mac_addr[(int )i] = sMacAddr[(int )i];
    i = (u16 )((int )i + 1);
    ldv_56007: ;
    if ((unsigned int )i <= 5U) {
      goto ldv_56006;
    } else {

    }

  } else {
    memcpy((void *)(& pEEPROM->mac_addr), (void const   *)hwinfo + 198U, 6UL);
  }
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(32768, 6, "Hal_EfuseParseMACAddr_8723AU: Permanent Address =%02x:%02x:%02x:%02x:%02x:%02x\n",
             (int )pEEPROM->mac_addr[0], (int )pEEPROM->mac_addr[1], (int )pEEPROM->mac_addr[2],
             (int )pEEPROM->mac_addr[3], (int )pEEPROM->mac_addr[4], (int )pEEPROM->mac_addr[5]);
  } else {

  }
  return;
}
}
static void readAdapterInfo(struct rtw_adapter *padapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u8 hwinfo[256U] ;

  {
  pEEPROM = & padapter->eeprompriv;
  Hal_InitPGData(padapter, (u8 *)(& hwinfo));
  Hal_EfuseParseIDCode(padapter, (u8 *)(& hwinfo));
  Hal_EfuseParseEEPROMVer(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseMACAddr_8723AU(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParsetxpowerinfo_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  _ReadBoardType(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseBTCoexistInfo_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  rtl8723a_EfuseParseChnlPlan(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseThermalMeter_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseAntennaDiversity(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseEEPROMVer(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseCustomerID(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseRateIndicationOption(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseXtal_8723A(padapter, (u8 *)(& hwinfo), (int )pEEPROM->bautoload_fail_flag);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(): REPLACEMENT = %x\n", "readAdapterInfo", padapter->bDongle);
  } else {

  }
  return;
}
}
static void _ReadPROMContent(struct rtw_adapter *Adapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u8 eeValue ;

  {
  pEEPROM = & Adapter->eeprompriv;
  eeValue = rtl8723au_read8(Adapter, 10);
  pEEPROM->EepromOrEfuse = ((unsigned long )eeValue & 16UL) != 0UL;
  pEEPROM->bautoload_fail_flag = ((unsigned long )eeValue & 32UL) == 0UL;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Boot from %s, Autoload %s !\n", (unsigned int )pEEPROM->EepromOrEfuse != 0U ? (char *)"EEPROM" : (char *)"EFUSE",
           (unsigned int )pEEPROM->bautoload_fail_flag != 0U ? (char *)"Fail" : (char *)"OK");
  } else {

  }
  readAdapterInfo(Adapter);
  return;
}
}
static void hal_EfuseCellSel(struct rtw_adapter *Adapter ) 
{ 
  u32 value32 ;

  {
  value32 = rtl8723au_read32(Adapter, 52);
  value32 = value32 & 4294966527U;
  rtl8723au_write32(Adapter, 52, value32);
  return;
}
}
void rtl8723a_read_adapter_info(struct rtw_adapter *Adapter ) 
{ 
  unsigned long start ;
  unsigned int tmp ;

  {
  start = jiffies;
  Adapter->EepromAddressSize = GetEEPROMSize8723A(Adapter);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ====> _ReadAdapterInfo8723AU\n");
  } else {

  }
  hal_EfuseCellSel(Adapter);
  _ReadPROMContent(Adapter);
  if (GlobalDebugLevel23A > 3U) {
    tmp = jiffies_to_msecs((unsigned long )jiffies - start);
    printk("\016RTL8723AU: <==== _ReadAdapterInfo8723AU in %d ms\n", tmp);
  } else {

  }
  return;
}
}
int GetHalDefVar8192CUsb(struct rtw_adapter *Adapter , enum hal_def_variable eVariable ,
                         void *pValue ) 
{ 
  struct hal_data_8723a *pHalData ;
  int bResult ;
  struct dm_odm_t *pDM_Odm ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  bResult = 1;
  switch ((unsigned int )eVariable) {
  case 0U: 
  *((int *)pValue) = pHalData->dmpriv.UndecoratedSmoothedPWDB;
  goto ldv_56036;
  case 1U: ;
  goto ldv_56036;
  case 2U: ;
  goto ldv_56036;
  case 3U: 
  *((u32 *)pValue) = 4U;
  goto ldv_56036;
  case 4U: 
  *((u32 *)pValue) = 15360U;
  goto ldv_56036;
  case 5U: 
  *((u32 *)pValue) = 28U;
  goto ldv_56036;
  case 6U: 
  *((u8 *)pValue) = pHalData->bDumpRxPkt;
  goto ldv_56036;
  case 7U: 
  *((u32 *)pValue) = pHalData->odmpriv.SupportAbility;
  goto ldv_56036;
  case 11U: 
  *((u32 *)pValue) = 3U;
  goto ldv_56036;
  case 15U: 
  pDM_Odm = & pHalData->odmpriv;
  printk("pDM_Odm->DebugComponents = 0x%llx\n", pDM_Odm->DebugComponents);
  goto ldv_56036;
  default: 
  bResult = 0;
  goto ldv_56036;
  }
  ldv_56036: ;
  return (bResult);
}
}
void rtl8723a_update_ramask(struct rtw_adapter *padapter , u32 mac_id , u8 rssi_level ) 
{ 
  struct sta_info *psta ;
  struct FW_Sta_Info *fw_sta ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 init_rate ;
  u8 networkType ;
  u8 raid ;
  u8 arg ;
  u32 mask ;
  u32 rate_bitmap ;
  u8 shortGIrate ;
  int supportRateNum ;
  uint tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  uint tmp___4 ;
  uint tmp___5 ;
  u8 tmp___6 ;
  unsigned char tmp___7 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  shortGIrate = 0U;
  if (mac_id > 31U) {
    return;
  } else {

  }
  psta = pmlmeinfo->FW_sta_info[mac_id].psta;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {

  }
  switch (mac_id) {
  case 0U: 
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  supportRateNum = (int )tmp;
  tmp___0 = judge_network_type23a(padapter, (unsigned char *)(& cur_network->SupportedRates),
                                  supportRateNum);
  networkType = (unsigned int )tmp___0 & 15U;
  raid = networktype_to_raid23a((int )networkType);
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
  if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
    tmp___1 = update_MSC_rate23a(& pmlmeinfo->ht_cap);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = 0U;
  }
  mask = tmp___2 | mask;
  tmp___3 = support_short_GI23a(padapter, & pmlmeinfo->ht_cap);
  if (tmp___3 != 0) {
    shortGIrate = 1U;
  } else {

  }
  goto ldv_56069;
  case 1U: 
  fw_sta = (struct FW_Sta_Info *)(& pmlmeinfo->FW_sta_info) + (unsigned long )mac_id;
  tmp___4 = rtw_get_rateset_len23a((u8 *)(& fw_sta->SupportedRates));
  supportRateNum = (int )tmp___4;
  if ((int )pmlmeext->cur_wireless_mode & 1) {
    networkType = 1U;
  } else {
    networkType = 2U;
  }
  raid = networktype_to_raid23a((int )networkType);
  mask = update_basic_rate23a((unsigned char *)(& cur_network->SupportedRates), (unsigned int )supportRateNum);
  goto ldv_56069;
  default: 
  fw_sta = (struct FW_Sta_Info *)(& pmlmeinfo->FW_sta_info) + (unsigned long )mac_id;
  tmp___5 = rtw_get_rateset_len23a((u8 *)(& fw_sta->SupportedRates));
  supportRateNum = (int )tmp___5;
  tmp___6 = judge_network_type23a(padapter, (unsigned char *)(& fw_sta->SupportedRates),
                                  supportRateNum);
  networkType = (unsigned int )tmp___6 & 15U;
  raid = networktype_to_raid23a((int )networkType);
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
  goto ldv_56069;
  }
  ldv_56069: 
  rate_bitmap = ODM_Get_Rate_Bitmap23a(pHalData, mac_id, mask, (int )rssi_level);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s => mac_id:%d, networkType:0x%02x, mask:0x%08x\n\t ==> rssi_level:%d, rate_bitmap:0x%08x\n",
           "rtl8723a_update_ramask", mac_id, (int )networkType, mask, (int )rssi_level,
           rate_bitmap);
  } else {

  }
  mask = mask & rate_bitmap;
  mask = (u32 )((int )raid << 28) | mask;
  tmp___7 = get_highest_rate_idx23a(mask);
  init_rate = (unsigned int )tmp___7 & 63U;
  arg = (unsigned int )((u8 )mac_id) & 31U;
  arg = (u8 )((unsigned int )arg | 128U);
  if ((unsigned int )shortGIrate == 1U) {
    arg = (u8 )((unsigned int )arg | 32U);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: update raid entry, mask = 0x%x, arg = 0x%x\n", mask, (int )arg);
  } else {

  }
  rtl8723a_set_raid_cmd(padapter, mask, (int )arg);
  psta->raid = raid;
  psta->init_rate = init_rate;
  pdmpriv->INIDATA_RATE[mac_id] = init_rate;
  return;
}
}
bool ldv_queue_work_on_593(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_594(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_595(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_596(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_597(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
extern struct workqueue_struct *system_wq ;
bool ldv_queue_work_on_607(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_609(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_608(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_611(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_610(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_607(8192, wq, work);
  return (tmp);
}
}
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = queue_work___0(system_wq, work);
  return (tmp);
}
}
struct work_struct *ldv_work_struct_3_1 ;
int ldv_work_3_3 ;
struct work_struct *ldv_work_struct_3_3 ;
struct work_struct *ldv_work_struct_3_2 ;
int ldv_work_3_2 ;
int ldv_work_3_0 ;
int ldv_work_3_1 ;
struct work_struct *ldv_work_struct_3_0 ;
void work_init_3(void) ;
void activate_work_3(struct work_struct *work , int state ) ;
void call_and_disable_work_3(struct work_struct *work ) ;
void disable_work_3(struct work_struct *work ) ;
void invoke_work_3(void) ;
void call_and_disable_all_3(int state ) ;
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
extern struct sk_buff *skb_dequeue(struct sk_buff_head * ) ;
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
  return;
}
}
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev , unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
  tmp = __netdev_alloc_skb(dev, length, 32U);
  return (tmp);
}
}
extern void __tasklet_schedule(struct tasklet_struct * ) ;
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
  if (tmp == 0) {
    __tasklet_schedule(t);
  } else {

  }
  return;
}
}
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context ) 
{ 


  {
  urb->dev = dev;
  urb->pipe = pipe;
  urb->transfer_buffer = transfer_buffer;
  urb->transfer_buffer_length = (u32 )buffer_length;
  urb->complete = complete_fn;
  urb->context = context;
  return;
}
}
__inline static void usb_fill_int_urb(struct urb *urb , struct usb_device *dev , unsigned int pipe ,
                                      void *transfer_buffer , int buffer_length ,
                                      void (*complete_fn)(struct urb * ) , void *context ,
                                      int interval ) 
{ 
  int _min1 ;
  int _max1 ;
  int _max2 ;
  int _min2 ;

  {
  urb->dev = dev;
  urb->pipe = pipe;
  urb->transfer_buffer = transfer_buffer;
  urb->transfer_buffer_length = (u32 )buffer_length;
  urb->complete = complete_fn;
  urb->context = context;
  if ((unsigned int )dev->speed == 3U || (unsigned int )dev->speed == 5U) {
    _max1 = interval;
    _max2 = 1;
    _min1 = _max1 > _max2 ? _max1 : _max2;
    _min2 = 16;
    interval = _min1 < _min2 ? _min1 : _min2;
    urb->interval = 1 << (interval + -1);
  } else {
    urb->interval = interval;
  }
  urb->start_frame = -1;
  return;
}
}
extern int usb_submit_urb(struct urb * , gfp_t  ) ;
extern int usb_control_msg(struct usb_device * , unsigned int  , __u8  , __u8  , __u16  ,
                           __u16  , void * , __u16  , int  ) ;
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
void rtl8723au_set_hw_type(struct rtw_adapter *padapter ) ;
__inline static int rtw_inc_and_chk_continual_urb_error(struct dvobj_priv *dvobj ) 
{ 
  int ret ;
  int value ;

  {
  ret = 0;
  value = atomic_add_return(1, & dvobj->continual_urb_error);
  if (value > 4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: [dvobj:%p][OLD_ERROR] continual_urb_error:%d > %d\n", dvobj,
             value, 4);
    } else {

    }
    ret = 1;
  } else {

  }
  return (ret);
}
}
__inline static void rtw_reset_continual_urb_error(struct dvobj_priv *dvobj ) 
{ 


  {
  atomic_set(& dvobj->continual_urb_error, 0);
  return;
}
}
u8 rtl8723au_read8(struct rtw_adapter *padapter , u16 addr ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int len ;
  u8 data ;
  unsigned int tmp ;

  {
  pdvobjpriv = padapter->dvobj;
  udev = pdvobjpriv->pusbdev;
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
  tmp = __create_pipe(udev, 0U);
  len = usb_control_msg(udev, tmp | 2147483776U, 5, 192, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val8),
                        1, 500);
  data = pdvobjpriv->usb_buf.val8;
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
  return (data);
}
}
u16 rtl8723au_read16(struct rtw_adapter *padapter , u16 addr ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int len ;
  u16 data ;
  unsigned int tmp ;

  {
  pdvobjpriv = padapter->dvobj;
  udev = pdvobjpriv->pusbdev;
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
  tmp = __create_pipe(udev, 0U);
  len = usb_control_msg(udev, tmp | 2147483776U, 5, 192, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val16),
                        2, 500);
  data = pdvobjpriv->usb_buf.val16;
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
  return (data);
}
}
u32 rtl8723au_read32(struct rtw_adapter *padapter , u16 addr ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int len ;
  u32 data ;
  unsigned int tmp ;

  {
  pdvobjpriv = padapter->dvobj;
  udev = pdvobjpriv->pusbdev;
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
  tmp = __create_pipe(udev, 0U);
  len = usb_control_msg(udev, tmp | 2147483776U, 5, 192, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val32),
                        4, 500);
  data = pdvobjpriv->usb_buf.val32;
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
  return (data);
}
}
int rtl8723au_write8(struct rtw_adapter *padapter , u16 addr , u8 val ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int ret ;
  unsigned int tmp ;

  {
  pdvobjpriv = padapter->dvobj;
  udev = pdvobjpriv->pusbdev;
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
  pdvobjpriv->usb_buf.val8 = val;
  tmp = __create_pipe(udev, 0U);
  ret = usb_control_msg(udev, tmp | 2147483648U, 5, 64, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val8),
                        1, 500);
  if (ret != 1) {
    ret = 0;
  } else {
    ret = 1;
  }
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
  return (ret);
}
}
int rtl8723au_write16(struct rtw_adapter *padapter , u16 addr , u16 val ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int ret ;
  unsigned int tmp ;

  {
  pdvobjpriv = padapter->dvobj;
  udev = pdvobjpriv->pusbdev;
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
  pdvobjpriv->usb_buf.val16 = val;
  tmp = __create_pipe(udev, 0U);
  ret = usb_control_msg(udev, tmp | 2147483648U, 5, 64, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val16),
                        2, 500);
  if (ret != 2) {
    ret = 0;
  } else {
    ret = 1;
  }
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
  return (ret);
}
}
int rtl8723au_write32(struct rtw_adapter *padapter , u16 addr , u32 val ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int ret ;
  unsigned int tmp ;

  {
  pdvobjpriv = padapter->dvobj;
  udev = pdvobjpriv->pusbdev;
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
  pdvobjpriv->usb_buf.val32 = val;
  tmp = __create_pipe(udev, 0U);
  ret = usb_control_msg(udev, tmp | 2147483648U, 5, 64, (int )addr, 0, (void *)(& pdvobjpriv->usb_buf.val32),
                        4, 500);
  if (ret != 4) {
    ret = 0;
  } else {
    ret = 1;
  }
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
  return (ret);
}
}
int rtl8723au_writeN(struct rtw_adapter *padapter , u16 addr , u16 len , u8 *buf ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  int ret ;
  unsigned int tmp ;

  {
  pdvobjpriv = padapter->dvobj;
  udev = pdvobjpriv->pusbdev;
  tmp = __create_pipe(udev, 0U);
  ret = usb_control_msg(udev, tmp | 2147483648U, 5, 64, (int )addr, 0, (void *)buf,
                        (int )len, 500);
  if ((int )len != ret) {
    return (0);
  } else {

  }
  return (1);
}
}
static bool InterruptRecognized8723AU(struct rtw_adapter *Adapter , void *pContent ,
                                      u32 ContentLen ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 *buffer ;
  struct reportpwrstate_parm report ;

  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  buffer = (u8 *)pContent;
  memcpy((void *)(& pHalData->IntArray), (void const   *)buffer + 48U, 4UL);
  pHalData->IntArray[0] = pHalData->IntArray[0] & pHalData->IntrMask[0];
  memcpy((void *)(& pHalData->IntArray) + 1U, (void const   *)buffer + 52U, 4UL);
  pHalData->IntArray[1] = pHalData->IntArray[1] & pHalData->IntrMask[1];
  memcpy((void *)(& report.state), (void const   *)buffer + 16U, 1UL);
  return ((bool )((pHalData->IntArray[0] & pHalData->IntrMask[0]) != 0U || (pHalData->IntArray[1] & pHalData->IntrMask[1]) != 0U));
}
}
static void usb_read_interrupt_complete(struct urb *purb ) 
{ 
  int err ;
  struct rtw_adapter *padapter ;
  struct c2h_evt_hdr *c2h_evt ;
  struct evt_work *c2w ;
  int res ;
  void *tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  padapter = (struct rtw_adapter *)purb->context;
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bReadPortCancel != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s() RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
             "usb_read_interrupt_complete", padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel);
    } else {

    }
    return;
  } else {

  }
  if (purb->status == 0) {
    c2h_evt = (struct c2h_evt_hdr *)purb->transfer_buffer;
    if (purb->actual_length > 56U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: usb_read_interrupt_complete: purb->actual_length > USB_INTR_CONTENT_LENGTH\n");
      } else {

      }
      goto urb_submit;
    } else {

    }
    InterruptRecognized8723AU(padapter, purb->transfer_buffer, purb->actual_length);
    if ((unsigned int )*((unsigned char *)c2h_evt + 0UL) != 0U || (unsigned int )*((unsigned char *)c2h_evt + 0UL) != 0U) {
      tmp___1 = c2h_id_filter_ccx_8723a((int )c2h_evt->id);
      if ((int )tmp___1) {
        handle_txrpt_ccx_8723a(padapter, (void *)(& c2h_evt->payload));
        schedule_work(& padapter->evtpriv.irq_wk);
      } else {
        tmp = kmalloc(104UL, 32U);
        c2w = (struct evt_work *)tmp;
        if ((unsigned long )c2w == (unsigned long )((struct evt_work *)0)) {
          printk("\f%s: unable to allocate work buffer\n", "usb_read_interrupt_complete");
          goto urb_submit;
        } else {

        }
        c2w->adapter = padapter;
        __init_work(& c2w->work, 0);
        __constr_expr_0.counter = 137438953408L;
        c2w->work.data = __constr_expr_0;
        lockdep_init_map(& c2w->work.lockdep_map, "(&c2w->work)", & __key, 0);
        INIT_LIST_HEAD(& c2w->work.entry);
        c2w->work.func = & rtw_evt_work;
        memcpy((void *)(& c2w->u.buf), (void const   *)purb->transfer_buffer, 16UL);
        tmp___0 = queue_work___0(padapter->evtpriv.wq, & c2w->work);
        res = (int )tmp___0;
        if (res == 0) {
          printk("\v%s: Call to queue_work() failed\n", "usb_read_interrupt_complete");
          kfree((void const   *)c2w);
          goto urb_submit;
        } else {

        }
      }
    } else {

    }
    urb_submit: 
    err = usb_submit_urb(purb, 32U);
    if (err != 0 && err != -1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: cannot submit interrupt in-token(err = 0x%08x), urb_status = %d\n",
               err, purb->status);
      } else {

      }
    } else {

    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ###=> usb_read_interrupt_complete => urb status(%d)\n",
             purb->status);
    } else {

    }
    switch (purb->status) {
    case -22: ;
    case -32: ;
    case -19: ;
    case -108: ;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_read_port_complete:bSurpriseRemoved =true\n");
    } else {

    }
    case -2: 
    padapter->bDriverStopped = 1;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_read_port_complete:bDriverStopped =true\n");
    } else {

    }
    goto ldv_55868;
    case -71: ;
    goto ldv_55868;
    case -115: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: OLD_ERROR: URB IS IN PROGRESS!\n");
    } else {

    }
    goto ldv_55868;
    default: ;
    goto ldv_55868;
    }
    ldv_55868: ;
  }
  return;
}
}
int rtl8723au_read_interrupt(struct rtw_adapter *adapter ) 
{ 
  int err ;
  unsigned int pipe ;
  int ret ;
  struct dvobj_priv *pdvobj ;
  struct recv_priv *precvpriv ;
  struct usb_device *pusbd ;
  unsigned int tmp ;

  {
  ret = 1;
  pdvobj = adapter->dvobj;
  precvpriv = & adapter->recvpriv;
  pusbd = pdvobj->pusbdev;
  tmp = __create_pipe(pusbd, (unsigned int )pdvobj->RtInPipe[1]);
  pipe = tmp | 1073741952U;
  usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe, (void *)precvpriv->int_in_buf,
                   56, & usb_read_interrupt_complete, (void *)adapter, 1);
  err = usb_submit_urb(precvpriv->int_in_urb, 32U);
  if (err != 0 && err != -1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",
             err, (precvpriv->int_in_urb)->status);
    } else {

    }
    ret = 0;
  } else {

  }
  return (ret);
}
}
static int recvbuf2recvframe(struct rtw_adapter *padapter , struct sk_buff *pskb ) 
{ 
  u8 *pbuf ;
  u8 shift_sz ;
  u16 pkt_cnt ;
  u32 pkt_offset ;
  u32 skb_len ;
  u32 alloc_sz ;
  int transfer_len ;
  struct recv_stat *prxstat ;
  struct phy_stat *pphy_info ;
  struct sk_buff *pkt_copy ;
  struct recv_frame *precvframe ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *pfree_recv_queue ;
  int tmp ;

  {
  shift_sz = 0U;
  precvpriv = & padapter->recvpriv;
  pfree_recv_queue = & precvpriv->free_recv_queue;
  transfer_len = (int )pskb->len;
  pbuf = pskb->data;
  prxstat = (struct recv_stat *)pbuf;
  pkt_cnt = (unsigned int )((u16 )(prxstat->rxdw2 >> 16)) & 255U;
  ldv_55901: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(4, 7, "recvbuf2recvframe: rxdesc = offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
             prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4);
  } else {

  }
  prxstat = (struct recv_stat *)pbuf;
  precvframe = rtw_alloc_recvframe23a(pfree_recv_queue);
  if ((unsigned long )precvframe == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "recvbuf2recvframe: precvframe == NULL\n");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: rtw_alloc_recvframe23a() failed! RX Drop!\n",
             "recvbuf2recvframe", 379);
    } else {

    }
    goto _exit_recvbuf2recvframe;
  } else {

  }
  INIT_LIST_HEAD(& precvframe->list);
  update_recvframe_attrib(precvframe, prxstat);
  pattrib = & precvframe->attrib;
  if ((unsigned int )pattrib->crc_err != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: RX Warning! rx CRC OLD_ERROR !!\n", "recvbuf2recvframe",
             391);
    } else {

    }
    rtw_free_recvframe23a(precvframe);
    goto _exit_recvbuf2recvframe;
  } else {

  }
  pkt_offset = (u32 )((((int )pattrib->drvinfo_sz + 24) + (int )pattrib->shift_sz) + (int )pattrib->pkt_len);
  if ((unsigned int )pattrib->pkt_len == 0U || (u32 )transfer_len < pkt_offset) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(4, 7, "recvbuf2recvframe: pkt_len<= 0\n");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: RX Warning!\n", "recvbuf2recvframe", 403);
    } else {

    }
    rtw_free_recvframe23a(precvframe);
    goto _exit_recvbuf2recvframe;
  } else {

  }
  if ((unsigned int )pattrib->qos != 0U) {
    shift_sz = 6U;
  } else {
    shift_sz = 0U;
  }
  skb_len = (u32 )pattrib->pkt_len;
  if ((unsigned int )pattrib->mfrag == 1U && (unsigned int )pattrib->frag_num == 0U) {
    if (skb_len <= 1650U) {
      alloc_sz = 1664U;
    } else {
      alloc_sz = skb_len + 14U;
    }
  } else {
    alloc_sz = skb_len;
    alloc_sz = alloc_sz + 14U;
  }
  pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
  if ((unsigned long )pkt_copy != (unsigned long )((struct sk_buff *)0)) {
    pkt_copy->dev = padapter->pnetdev;
    precvframe->pkt = pkt_copy;
    skb_reserve(pkt_copy, (int )(8U - ((unsigned int )((long )pkt_copy->data) & 7U)));
    skb_reserve(pkt_copy, (int )shift_sz);
    memcpy((void *)pkt_copy->data, (void const   *)(pbuf + (((unsigned long )pattrib->shift_sz + (unsigned long )pattrib->drvinfo_sz) + 24UL)),
             (size_t )skb_len);
    skb_put(pkt_copy, skb_len);
  } else {
    if ((unsigned int )pattrib->mfrag == 1U && (unsigned int )pattrib->frag_num == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: recvbuf2recvframe: alloc_skb fail, drop frag frame \n");
      } else {

      }
      rtw_free_recvframe23a(precvframe);
      goto _exit_recvbuf2recvframe;
    } else {

    }
    precvframe->pkt = skb_clone(pskb, 32U);
    if ((unsigned long )precvframe->pkt == (unsigned long )((struct sk_buff *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: recvbuf2recvframe: skb_clone fail\n");
      } else {

      }
      rtw_free_recvframe23a(precvframe);
      goto _exit_recvbuf2recvframe;
    } else {

    }
  }
  if ((unsigned int )pattrib->physt != 0U) {
    pphy_info = (struct phy_stat *)pbuf + 24U;
    update_recvframe_phyinfo(precvframe, pphy_info);
  } else {

  }
  tmp = rtw_recv_entry23a(precvframe);
  if (tmp != 1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(4, 4, "recvbuf2recvframe: rtw_recv_entry23a(precvframe) != _SUCCESS\n");
    } else {

    }
  } else {

  }
  pkt_cnt = (u16 )((int )pkt_cnt - 1);
  transfer_len = (int )((u32 )transfer_len - pkt_offset);
  pbuf = pbuf + (unsigned long )pkt_offset;
  precvframe = (struct recv_frame *)0;
  pkt_copy = (struct sk_buff *)0;
  if (transfer_len > 0 && (unsigned int )pkt_cnt == 0U) {
    pkt_cnt = (unsigned int )((u16 )(prxstat->rxdw2 >> 16)) & 255U;
  } else {

  }
  if (transfer_len > 0 && (unsigned int )pkt_cnt != 0U) {
    goto ldv_55901;
  } else {

  }

  _exit_recvbuf2recvframe: ;
  return (1);
}
}
void rtl8723au_recv_tasklet(void *priv ) 
{ 
  struct sk_buff *pskb ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;

  {
  padapter = (struct rtw_adapter *)priv;
  precvpriv = & padapter->recvpriv;
  goto ldv_55911;
  ldv_55910: ;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
    } else {

    }
    dev_kfree_skb_any(pskb);
    goto ldv_55909;
  } else {

  }
  recvbuf2recvframe(padapter, pskb);
  skb_reset_tail_pointer(pskb);
  pskb->len = 0U;
  skb_queue_tail(& precvpriv->free_recv_skb_queue, pskb);
  ldv_55911: 
  pskb = skb_dequeue(& precvpriv->rx_skb_queue);
  if ((unsigned long )pskb != (unsigned long )((struct sk_buff *)0)) {
    goto ldv_55910;
  } else {

  }
  ldv_55909: ;
  return;
}
}
static void usb_read_port_complete(struct urb *purb ) 
{ 
  struct recv_buf *precvbuf ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  __u32 tmp ;
  int tmp___0 ;

  {
  precvbuf = (struct recv_buf *)purb->context;
  padapter = precvbuf->adapter;
  precvpriv = & padapter->recvpriv;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16777216, 4, "usb_read_port_complete!!!\n");
  } else {

  }
  precvpriv->rx_pending_cnt = (u8 )((int )precvpriv->rx_pending_cnt - 1);
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bReadPortCancel != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",
               padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
             "usb_read_port_complete", 533, padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel);
    } else {

    }
    return;
  } else {

  }
  if (purb->status == 0) {
    if (purb->actual_length > 15360U || purb->actual_length <= 23U) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16777216, 4, "usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n");
      } else {

      }
      rtl8723au_read_port(padapter, 0U, precvbuf);
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s()-%d: RX Warning!\n", "usb_read_port_complete",
               544);
      } else {

      }
    } else {
      rtw_reset_continual_urb_error(padapter->dvobj);
      skb_put(precvbuf->pskb, purb->actual_length);
      skb_queue_tail(& precvpriv->rx_skb_queue, precvbuf->pskb);
      tmp = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->rx_skb_queue));
      if (tmp <= 1U) {
        tasklet_schedule(& precvpriv->recv_tasklet);
      } else {

      }
      precvbuf->pskb = (struct sk_buff *)0;
      rtl8723au_read_port(padapter, 0U, precvbuf);
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_read_port_complete : purb->status(%d) != 0\n", purb->status);
    } else {

    }
    skb_put(precvbuf->pskb, purb->actual_length);
    precvbuf->pskb = (struct sk_buff *)0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ###=> usb_read_port_complete => urb status(%d)\n", purb->status);
    } else {

    }
    tmp___0 = rtw_inc_and_chk_continual_urb_error(padapter->dvobj);
    if (tmp___0 != 0) {
      padapter->bSurpriseRemoved = 1;
    } else {

    }
    switch (purb->status) {
    case -22: ;
    case -32: ;
    case -19: ;
    case -108: ;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_read_port_complete:bSurpriseRemoved = true\n");
    } else {

    }
    case -2: 
    padapter->bDriverStopped = 1;
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_read_port_complete:bDriverStopped = true\n");
    } else {

    }
    goto ldv_55924;
    case -71: ;
    case -75: 
    rtl8723au_read_port(padapter, 0U, precvbuf);
    goto ldv_55924;
    case -115: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: OLD_ERROR: URB IS IN PROGRESS!\n");
    } else {

    }
    goto ldv_55924;
    default: ;
    goto ldv_55924;
    }
    ldv_55924: ;
  }
  return;
}
}
int rtl8723au_read_port(struct rtw_adapter *adapter , u32 cnt , struct recv_buf *precvbuf ) 
{ 
  struct urb *purb ;
  struct dvobj_priv *pdvobj ;
  struct recv_priv *precvpriv ;
  struct usb_device *pusbd ;
  int err ;
  unsigned int pipe ;
  unsigned long tmpaddr ;
  unsigned long alignment ;
  int ret ;
  unsigned int tmp ;

  {
  pdvobj = adapter->dvobj;
  precvpriv = & adapter->recvpriv;
  pusbd = pdvobj->pusbdev;
  ret = 1;
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved)!!!\n");
    } else {

    }
    return (0);
  } else {

  }
  if ((unsigned long )precvbuf == (unsigned long )((struct recv_buf *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_read_port:precvbuf == NULL\n");
    } else {

    }
    return (0);
  } else {

  }
  if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
    precvbuf->pskb = skb_dequeue(& precvpriv->free_recv_skb_queue);
  } else {

  }
  if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
    precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, 15368U);
    if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16777216, 4, "init_recvbuf(): alloc_skb fail!\n");
      } else {

      }
      return (0);
    } else {

    }
    tmpaddr = (unsigned long )(precvbuf->pskb)->data;
    alignment = tmpaddr & 7UL;
    skb_reserve(precvbuf->pskb, (int )(8U - (unsigned int )alignment));
  } else {

  }
  precvpriv->rx_pending_cnt = (u8 )((int )precvpriv->rx_pending_cnt + 1);
  purb = precvbuf->purb;
  tmp = __create_pipe(pusbd, (unsigned int )pdvobj->RtInPipe[0]);
  pipe = tmp | 3221225600U;
  usb_fill_bulk_urb(purb, pusbd, pipe, (void *)(precvbuf->pskb)->data, 15360, & usb_read_port_complete,
                    (void *)precvbuf);
  err = usb_submit_urb(purb, 32U);
  if (err != 0 && err != -1) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "cannot submit rx in-token(err = 0x%.8x), URB_STATUS = 0x%.8x\n",
               err, purb->status);
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: cannot submit rx in-token(err = 0x%08x), urb_status = %d\n",
             err, purb->status);
    } else {

    }
    ret = 0;
  } else {

  }
  return (ret);
}
}
void rtl8723au_xmit_tasklet(void *priv ) 
{ 
  int ret ;
  struct rtw_adapter *padapter ;
  struct xmit_priv *pxmitpriv ;
  bool tmp ;
  bool tmp___0 ;

  {
  padapter = (struct rtw_adapter *)priv;
  pxmitpriv = & padapter->xmitpriv;
  tmp = check_fwstate(& padapter->mlmepriv, 2048);
  if ((int )tmp) {
    return;
  } else {

  }
  ldv_55950: ;
  if ((padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) || (unsigned int )padapter->bWritePortCancel != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: xmit_tasklet => bDriverStopped or bSurpriseRemoved or bWritePortCancel\n");
    } else {

    }
    goto ldv_55949;
  } else {

  }
  tmp___0 = rtl8723au_xmitframe_complete(padapter, pxmitpriv, (struct xmit_buf *)0);
  ret = (int )tmp___0;
  if (ret == 0) {
    goto ldv_55949;
  } else {

  }
  goto ldv_55950;
  ldv_55949: ;
  return;
}
}
void rtl8723au_set_hw_type(struct rtw_adapter *padapter ) 
{ 


  {
  padapter->chip_type = 4U;
  padapter->HardwareType = 14U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: CHIP TYPE: RTL8723A\n");
  } else {

  }
  return;
}
}
void work_init_3(void) 
{ 


  {
  ldv_work_3_0 = 0;
  ldv_work_3_1 = 0;
  ldv_work_3_2 = 0;
  ldv_work_3_3 = 0;
  return;
}
}
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_3_0 == 0) {
    ldv_work_struct_3_0 = work;
    ldv_work_3_0 = state;
    return;
  } else {

  }
  if (ldv_work_3_1 == 0) {
    ldv_work_struct_3_1 = work;
    ldv_work_3_1 = state;
    return;
  } else {

  }
  if (ldv_work_3_2 == 0) {
    ldv_work_struct_3_2 = work;
    ldv_work_3_2 = state;
    return;
  } else {

  }
  if (ldv_work_3_3 == 0) {
    ldv_work_struct_3_3 = work;
    ldv_work_3_3 = state;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
    rtw_evt_work(work);
    ldv_work_3_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
    rtw_evt_work(work);
    ldv_work_3_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
    rtw_evt_work(work);
    ldv_work_3_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
    rtw_evt_work(work);
    ldv_work_3_3 = 1;
    return;
  } else {

  }
  return;
}
}
void disable_work_3(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
    ldv_work_3_0 = 1;
  } else {

  }
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
    ldv_work_3_1 = 1;
  } else {

  }
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
    ldv_work_3_2 = 1;
  } else {

  }
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
    ldv_work_3_3 = 1;
  } else {

  }
  return;
}
}
void invoke_work_3(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
    ldv_work_3_0 = 4;
    rtw_evt_work(ldv_work_struct_3_0);
    ldv_work_3_0 = 1;
  } else {

  }
  goto ldv_55975;
  case 1: ;
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
    ldv_work_3_1 = 4;
    rtw_evt_work(ldv_work_struct_3_0);
    ldv_work_3_1 = 1;
  } else {

  }
  goto ldv_55975;
  case 2: ;
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
    ldv_work_3_2 = 4;
    rtw_evt_work(ldv_work_struct_3_0);
    ldv_work_3_2 = 1;
  } else {

  }
  goto ldv_55975;
  case 3: ;
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
    ldv_work_3_3 = 4;
    rtw_evt_work(ldv_work_struct_3_0);
    ldv_work_3_3 = 1;
  } else {

  }
  goto ldv_55975;
  default: 
  ldv_stop();
  }
  ldv_55975: ;
  return;
}
}
void call_and_disable_all_3(int state ) 
{ 


  {
  if (ldv_work_3_0 == state) {
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
  if (ldv_work_3_1 == state) {
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
  if (ldv_work_3_2 == state) {
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
  if (ldv_work_3_3 == state) {
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_607(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_608(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_609(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_610(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_611(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
void *ldv_err_ptr(long error ) ;
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
__inline static void *ERR_PTR(long error ) ;
bool ldv_queue_work_on_621(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_623(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_622(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_625(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_624(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
  return ((char const   *)kobj->name);
}
}
struct station_info *rtw_cfg80211_ops_group1 ;
int ldv_state_variable_17 ;
int ref_cnt ;
struct cfg80211_pmksa *rtw_cfg80211_ops_group2 ;
struct wiphy *rtw_cfg80211_ops_group3 ;
int usb_counter ;
struct vif_params *rtw_cfg80211_ops_group5 ;
struct net_device *rtw_cfg80211_ops_group6 ;
struct wireless_dev *rtw_cfg80211_ops_group0 ;
struct net_device *rtw_cfg80211_monitor_if_ops_group1 ;
int ldv_state_variable_16 ;
struct station_parameters *rtw_cfg80211_ops_group4 ;
void ldv_net_device_ops_17(void) ;
void ldv_initialize_cfg80211_ops_16(void) ;
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
    return ((char const   *)dev->init_name);
  } else {

  }
  tmp = kobject_name(& dev->kobj);
  return (tmp);
}
}
extern void consume_skb(struct sk_buff * ) ;
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
  return ((void *)dev + 3008U);
}
}
extern int register_netdevice(struct net_device * ) ;
extern void unregister_netdevice_queue(struct net_device * , struct list_head * ) ;
__inline static void unregister_netdevice(struct net_device *dev ) 
{ 


  {
  unregister_netdevice_queue(dev, (struct list_head *)0);
  return;
}
}
extern void free_netdev(struct net_device * ) ;
void ldv_free_netdev_626(struct net_device *dev ) ;
extern void unregister_netdev(struct net_device * ) ;
void ldv_unregister_netdev_627(struct net_device *dev ) ;
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
__inline static void eth_broadcast_addr(u8 *addr ) 
{ 


  {
  memset((void *)addr, 255, 6UL);
  return;
}
}
__inline static void eth_zero_addr(u8 *addr ) 
{ 


  {
  memset((void *)addr, 0, 6UL);
  return;
}
}
__inline static int ieee80211_get_radiotap_len(unsigned char *data ) 
{ 
  struct ieee80211_radiotap_header *hdr ;
  u16 tmp ;

  {
  hdr = (struct ieee80211_radiotap_header *)data;
  tmp = get_unaligned_le16((void const   *)(& hdr->it_len));
  return ((int )tmp);
}
}
__inline static int ieee80211_is_action(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 208);
}
}
__inline static void *wiphy_priv___1(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3259), "i" (12UL));
    ldv_48184: ;
    goto ldv_48184;
  } else {

  }
  return ((void *)(& wiphy->priv));
}
}
__inline static void set_wiphy_dev(struct wiphy *wiphy , struct device *dev ) 
{ 


  {
  wiphy->dev.parent = dev;
  return;
}
}
__inline static char const   *wiphy_name(struct wiphy  const  *wiphy ) 
{ 
  char const   *tmp ;

  {
  tmp = dev_name(& wiphy->dev);
  return (tmp);
}
}
extern struct wiphy *wiphy_new_nm(struct cfg80211_ops  const  * , int  , char const   * ) ;
__inline static struct wiphy *wiphy_new(struct cfg80211_ops  const  *ops , int sizeof_priv ) 
{ 
  struct wiphy *tmp ;

  {
  tmp = wiphy_new_nm(ops, sizeof_priv, (char const   *)0);
  return (tmp);
}
}
extern int wiphy_register(struct wiphy * ) ;
extern void wiphy_unregister(struct wiphy * ) ;
extern void wiphy_free(struct wiphy * ) ;
__inline static void *wdev_priv___1(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3512), "i" (12UL));
    ldv_48269: ;
    goto ldv_48269;
  } else {

  }
  tmp___0 = wiphy_priv___1(wdev->wiphy);
  return (tmp___0);
}
}
extern int ieee80211_frequency_to_channel(int  ) ;
extern struct ieee80211_channel *__ieee80211_get_channel(struct wiphy * , int  ) ;
__inline static struct ieee80211_channel *ieee80211_get_channel(struct wiphy *wiphy ,
                                                                int freq ) 
{ 
  struct ieee80211_channel *tmp ;

  {
  tmp = __ieee80211_get_channel(wiphy, freq);
  return (tmp);
}
}
extern void cfg80211_scan_done(struct cfg80211_scan_request * , bool  ) ;
extern struct cfg80211_bss *cfg80211_inform_bss_width(struct wiphy * , struct ieee80211_channel * ,
                                                      enum nl80211_bss_scan_width  ,
                                                      enum cfg80211_bss_frame_type  ,
                                                      u8 const   * , u64  , u16  ,
                                                      u16  , u8 const   * , size_t  ,
                                                      s32  , gfp_t  ) ;
__inline static struct cfg80211_bss *cfg80211_inform_bss(struct wiphy *wiphy , struct ieee80211_channel *rx_channel ,
                                                         enum cfg80211_bss_frame_type ftype ,
                                                         u8 const   *bssid , u64 tsf ,
                                                         u16 capability , u16 beacon_interval ,
                                                         u8 const   *ie , size_t ielen ,
                                                         s32 signal , gfp_t gfp ) 
{ 
  struct cfg80211_bss *tmp ;

  {
  tmp = cfg80211_inform_bss_width(wiphy, rx_channel, 0, ftype, bssid, tsf, (int )capability,
                                  (int )beacon_interval, ie, ielen, signal, gfp);
  return (tmp);
}
}
extern void cfg80211_put_bss(struct wiphy * , struct cfg80211_bss * ) ;
extern void cfg80211_connect_result(struct net_device * , u8 const   * , u8 const   * ,
                                    size_t  , u8 const   * , size_t  , u16  , gfp_t  ) ;
extern void cfg80211_roamed(struct net_device * , struct ieee80211_channel * , u8 const   * ,
                            u8 const   * , size_t  , u8 const   * , size_t  , gfp_t  ) ;
extern void cfg80211_disconnected(struct net_device * , u16  , u8 const   * , size_t  ,
                                  bool  , gfp_t  ) ;
extern void cfg80211_mgmt_tx_status(struct wireless_dev * , u64  , u8 const   * ,
                                    size_t  , bool  , gfp_t  ) ;
int rtw_xmit23a_entry23a(struct sk_buff *skb , struct net_device *pnetdev ) ;
__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex ) 
{ 
  s32 SignalPower ;

  {
  SignalPower = (int )((SignalStrengthIndex + 1U) >> 1);
  SignalPower = SignalPower + -95;
  return (SignalPower);
}
}
void rtw_ndev_destructor(struct net_device *ndev ) ;
extern bool rtw_is_scan_deny(struct rtw_adapter * ) ;
int rtw_check_beacon_data23a(struct rtw_adapter *padapter , struct ieee80211_mgmt *mgmt ,
                             unsigned int len ) ;
int rtw_sta_flush23a(struct rtw_adapter *padapter ) ;
void start_ap_mode23a(struct rtw_adapter *padapter ) ;
void stop_ap_mode23a(struct rtw_adapter *padapter ) ;
int rtw_wdev_alloc(struct rtw_adapter *padapter , struct device *dev ) ;
void rtw_wdev_free(struct wireless_dev *wdev ) ;
void rtw_wdev_unregister(struct wireless_dev *wdev ) ;
void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter ) ;
void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter , unsigned char *da ,
                                        unsigned short reason ) ;
static u32 const   rtw_cipher_suites[4U]  = {      1027073U,      1027077U,      1027074U,      1027076U};
static struct ieee80211_rate rtw_rates[12U]  = 
  {      {0U, 10U, 1U, (unsigned short)0}, 
        {0U, 20U, 2U, (unsigned short)0}, 
        {0U, 55U, 4U, (unsigned short)0}, 
        {0U, 110U, 8U, (unsigned short)0}, 
        {0U, 60U, 16U, (unsigned short)0}, 
        {0U, 90U, 32U, (unsigned short)0}, 
        {0U, 120U, 64U, (unsigned short)0}, 
        {0U, 180U, 128U, (unsigned short)0}, 
        {0U, 240U, 256U, (unsigned short)0}, 
        {0U, 360U, 512U, (unsigned short)0}, 
        {0U, 480U, 1024U, (unsigned short)0}, 
        {0U, 540U, 2048U, (unsigned short)0}};
static struct ieee80211_channel rtw_2ghz_channels[14U]  = 
  {      {0, 2412U, 1U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2417U, 2U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2422U, 3U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2427U, 4U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2432U, 5U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2437U, 6U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2442U, 7U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2447U, 8U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2452U, 9U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2457U, 10U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2462U, 11U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2467U, 12U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2472U, 13U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2484U, 14U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}};
static struct ieee80211_channel rtw_5ghz_a_channels[37U]  = 
  {      {1, 5170U, 34U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5180U, 36U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5190U, 38U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5200U, 40U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5210U, 42U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5220U, 44U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5230U, 46U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5240U, 48U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5260U, 52U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5280U, 56U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5300U, 60U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5320U, 64U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5500U, 100U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5520U, 104U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5540U, 108U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5560U, 112U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5580U, 116U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5600U, 120U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5620U, 124U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5640U, 128U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5660U, 132U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5680U, 136U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5700U, 140U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5745U, 149U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5765U, 153U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5785U, 157U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5805U, 161U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5825U, 165U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5920U, 184U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5940U, 188U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5960U, 192U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5980U, 196U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6000U, 200U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6020U, 204U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6040U, 208U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6060U, 212U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6080U, 216U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}};
static void rtw_2g_channels_init(struct ieee80211_channel *channels ) 
{ 


  {
  memcpy((void *)channels, (void const   *)(& rtw_2ghz_channels), 896UL);
  return;
}
}
static void rtw_5g_channels_init(struct ieee80211_channel *channels ) 
{ 


  {
  memcpy((void *)channels, (void const   *)(& rtw_5ghz_a_channels), 2368UL);
  return;
}
}
static void rtw_2g_rates_init(struct ieee80211_rate *rates ) 
{ 


  {
  memcpy((void *)rates, (void const   *)(& rtw_rates), 144UL);
  return;
}
}
static void rtw_5g_rates_init(struct ieee80211_rate *rates ) 
{ 


  {
  memcpy((void *)rates, (void const   *)(& rtw_rates) + 4U, 96UL);
  return;
}
}
static struct ieee80211_supported_band *rtw_spt_band_alloc(enum ieee80211_band band ) 
{ 
  struct ieee80211_supported_band *spt_band ;
  int n_channels ;
  int n_bitrates ;
  void *tmp ;

  {
  spt_band = (struct ieee80211_supported_band *)0;
  if ((unsigned int )band == 0U) {
    n_channels = 14;
    n_bitrates = 12;
  } else
  if ((unsigned int )band == 1U) {
    n_channels = 37;
    n_bitrates = 8;
  } else {
    goto exit;
  }
  tmp = kzalloc(((unsigned long )n_channels * 64UL + (unsigned long )n_bitrates * 12UL) + 72UL,
                208U);
  spt_band = (struct ieee80211_supported_band *)tmp;
  if ((unsigned long )spt_band == (unsigned long )((struct ieee80211_supported_band *)0)) {
    goto exit;
  } else {

  }
  spt_band->channels = (struct ieee80211_channel *)spt_band + 72U;
  spt_band->bitrates = (struct ieee80211_rate *)spt_band->channels + (unsigned long )n_channels * 64UL;
  spt_band->band = band;
  spt_band->n_channels = n_channels;
  spt_band->n_bitrates = n_bitrates;
  if ((unsigned int )band == 0U) {
    rtw_2g_channels_init(spt_band->channels);
    rtw_2g_rates_init(spt_band->bitrates);
  } else
  if ((unsigned int )band == 1U) {
    rtw_5g_channels_init(spt_band->channels);
    rtw_5g_rates_init(spt_band->bitrates);
  } else {

  }
  exit: ;
  return (spt_band);
}
}
static struct ieee80211_txrx_stypes  const  rtw_cfg80211_default_mgmt_stypes[12U]  = 
  {      {(unsigned short)0, (unsigned short)0}, 
        {65535U, 8192U}, 
        {65535U, 8208U}, 
        {65535U, 15381U}, 
        {65535U, 15381U}, 
        {(unsigned short)0, (unsigned short)0}, 
        {(unsigned short)0, (unsigned short)0}, 
        {(unsigned short)0, (unsigned short)0}, 
        {65535U, 8208U}, 
        {65535U, 15381U}};
static int rtw_cfg80211_inform_bss(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) 
{ 
  int ret ;
  struct ieee80211_channel *notify_channel ;
  struct cfg80211_bss *bss ;
  u16 channel ;
  u32 freq ;
  u8 *notify_ie ;
  size_t notify_ielen ;
  s32 notify_signal ;
  struct wireless_dev *wdev ;
  struct wiphy *wiphy ;
  struct mlme_priv *pmlmepriv ;
  int tmp ;
  int tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  ret = 0;
  wdev = padapter->rtw_wdev;
  wiphy = wdev->wiphy;
  pmlmepriv = & padapter->mlmepriv;
  channel = (u16 )pnetwork->network.DSConfig;
  if ((unsigned int )channel <= 14U) {
    tmp = ieee80211_channel_to_frequency((int )channel, 0);
    freq = (u32 )tmp;
  } else {
    tmp___0 = ieee80211_channel_to_frequency((int )channel, 1);
    freq = (u32 )tmp___0;
  }
  notify_channel = ieee80211_get_channel(wiphy, (int )freq);
  notify_ie = (u8 *)(& pnetwork->network.IEs);
  notify_ielen = (size_t )pnetwork->network.IELength;
  tmp___3 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___3) {
    tmp___4 = is_same_network23a(& pmlmepriv->cur_network.network, & pnetwork->network);
    if (tmp___4 != 0) {
      tmp___1 = translate_percentage_to_dbm((u32 )padapter->recvpriv.signal_strength);
      notify_signal = tmp___1 * 100;
    } else {
      tmp___2 = translate_percentage_to_dbm((u32 )pnetwork->network.SignalStrength);
      notify_signal = tmp___2 * 100;
    }
  } else {
    tmp___2 = translate_percentage_to_dbm((u32 )pnetwork->network.SignalStrength);
    notify_signal = tmp___2 * 100;
  }
  bss = cfg80211_inform_bss(wiphy, notify_channel, 0, (u8 const   *)(& pnetwork->network.MacAddress),
                            pnetwork->network.tsf, (int )pnetwork->network.capability,
                            (int )pnetwork->network.beacon_interval, (u8 const   *)notify_ie,
                            notify_ielen, notify_signal, 32U);
  tmp___5 = ldv__builtin_expect((unsigned long )bss == (unsigned long )((struct cfg80211_bss *)0),
                             0L);
  if (tmp___5 != 0L) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_cfg80211_inform_bss error\n");
    } else {

    }
    return (-22);
  } else {

  }
  cfg80211_put_bss(wiphy, bss);
  return (ret);
}
}
void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  struct wireless_dev *pwdev ;
  bool tmp ;
  struct wiphy *wiphy ;
  struct ieee80211_channel *notify_channel ;
  u32 freq ;
  u16 channel ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network;
  pwdev = padapter->rtw_wdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_cfg80211_indicate_connect", padapter);
  } else {

  }
  if ((unsigned int )pwdev->iftype != 2U && (unsigned int )pwdev->iftype != 8U) {
    return;
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    return;
  } else {

  }
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
    wiphy = pwdev->wiphy;
    channel = (u16 )cur_network->network.DSConfig;
    if ((unsigned int )channel <= 14U) {
      tmp___0 = ieee80211_channel_to_frequency((int )channel, 0);
      freq = (u32 )tmp___0;
    } else {
      tmp___1 = ieee80211_channel_to_frequency((int )channel, 1);
      freq = (u32 )tmp___1;
    }
    notify_channel = ieee80211_get_channel(wiphy, (int )freq);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s call cfg80211_roamed\n", "rtw_cfg80211_indicate_connect");
    } else {

    }
    cfg80211_roamed(padapter->pnetdev, notify_channel, (u8 const   *)(& cur_network->network.MacAddress),
                    (u8 const   *)pmlmepriv->assoc_req + 26U, (unsigned long )pmlmepriv->assoc_req_len - 26UL,
                    (u8 const   *)pmlmepriv->assoc_rsp + 30U, (unsigned long )pmlmepriv->assoc_rsp_len - 30UL,
                    32U);
  } else {
    cfg80211_connect_result(padapter->pnetdev, (u8 const   *)(& cur_network->network.MacAddress),
                            (u8 const   *)pmlmepriv->assoc_req + 26U, (unsigned long )pmlmepriv->assoc_req_len - 26UL,
                            (u8 const   *)pmlmepriv->assoc_rsp + 30U, (unsigned long )pmlmepriv->assoc_rsp_len - 30UL,
                            0, 32U);
  }
  return;
}
}
void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wireless_dev *pwdev ;
  bool tmp ;
  bool tmp___0 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pwdev = padapter->rtw_wdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_cfg80211_indicate_disconnect",
           padapter);
  } else {

  }
  if ((unsigned int )pwdev->iftype != 2U && (unsigned int )pwdev->iftype != 8U) {
    return;
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    return;
  } else {

  }
  if ((unsigned int )padapter->mlmepriv.not_indic_disco == 0U) {
    tmp___0 = check_fwstate(& padapter->mlmepriv, 128);
    if ((int )tmp___0) {
      cfg80211_connect_result(padapter->pnetdev, (u8 const   *)0U, (u8 const   *)0U,
                              0UL, (u8 const   *)0U, 0UL, 1, 32U);
    } else {
      cfg80211_disconnected(padapter->pnetdev, 0, (u8 const   *)0U, 0UL, 0, 32U);
    }
  } else {

  }
  return;
}
}
static int set_pairwise_key(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 208U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(28UL, 208U);
  psetstakey_para = (struct set_stakey_parm *)tmp___0;
  if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
    kfree((void const   *)ph2c);
    res = 0;
    goto exit;
  } else {

  }
  ph2c->cmdcode = 21U;
  ph2c->parmbuf = (u8 *)psetstakey_para;
  ph2c->cmdsz = 28U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  psetstakey_para->algorithm = psta->dot118021XPrivacy;
  ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& psta->hwaddr));
  memcpy((void *)(& psetstakey_para->key), (void const   *)(& psta->dot118021x_UncstKey),
           16UL);
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
static int set_group_key(struct rtw_adapter *padapter , struct key_params *parms ,
                         u32 alg , u8 keyid ) 
{ 
  struct cmd_obj *pcmd ;
  struct setkey_parm *psetkeyparm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "set_group_key");
  } else {

  }
  if ((unsigned int )keyid > 3U) {
    res = 0;
    goto exit;
  } else {

  }
  tmp = kzalloc(128UL, 208U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {

  }
  tmp___0 = kzalloc(24UL, 208U);
  psetkeyparm = (struct setkey_parm *)tmp___0;
  if ((unsigned long )psetkeyparm == (unsigned long )((struct setkey_parm *)0)) {
    kfree((void const   *)pcmd);
    res = 0;
    goto exit;
  } else {

  }
  psetkeyparm->keyid = keyid;
  if (alg == 1027073U || alg == 1027077U) {
    padapter->mlmepriv.key_mask = (int )padapter->mlmepriv.key_mask | (int )((u8 )(1UL << (int )psetkeyparm->keyid));
  } else {

  }
  psetkeyparm->algorithm = alg;
  psetkeyparm->set_tx = 1U;
  memcpy((void *)(& psetkeyparm->key), (void const   *)parms->key, (size_t )parms->key_len);
  pcmd->cmdcode = 20U;
  pcmd->parmbuf = (u8 *)psetkeyparm;
  pcmd->cmdsz = 24U;
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
  return (res);
}
}
static int rtw_cfg80211_ap_set_encryption(struct net_device *dev , u8 key_index ,
                                          int set_tx , u8 const   *sta_addr , struct key_params *keyparms ) 
{ 
  int key_len ;
  struct sta_info *psta ;
  struct sta_info *pbcmc_sta ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  struct sta_priv *pstapriv ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  psta = (struct sta_info *)0;
  pbcmc_sta = (struct sta_info *)0;
  tmp = netdev_priv((struct net_device  const  *)dev);
  padapter = (struct rtw_adapter *)tmp;
  psecuritypriv = & padapter->securitypriv;
  pstapriv = & padapter->stapriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_ap_set_encryption");
  } else {

  }
  tmp___0 = is_broadcast_ether_addr(sta_addr);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    psta = rtw_get_stainfo23a(pstapriv, sta_addr);
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: rtw_set_encryption(), sta has already been removed or never been added\n");
      } else {

      }
      goto exit;
    } else {

    }
  } else {

  }
  key_len = keyparms->key_len;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0) && (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: r871x_set_encryption, crypt.alg = WEP\n");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: r871x_set_encryption, wep_key_idx =%d, len =%d\n", (int )key_index,
             key_len);
    } else {

    }
    if ((unsigned int )psecuritypriv->bWepDefaultKeyIdxSet == 0U) {
      psecuritypriv->ndisencryptstatus = 0U;
      psecuritypriv->dot11PrivacyAlgrthm = keyparms->cipher;
      psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
      psecuritypriv->dot11PrivacyKeyIndex = (u32 )key_index;
    } else {

    }
    memcpy((void *)(& psecuritypriv->wep_key[(int )key_index].key), (void const   *)keyparms->key,
             (size_t )key_len);
    psecuritypriv->wep_key[(int )key_index].keylen = (u16 )key_len;
    set_group_key(padapter, keyparms, keyparms->cipher, (int )key_index);
    goto exit;
  } else {

  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (set_tx == 0) {
      if (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, set group_key, WEP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )key_len);
        psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
      } else
      if (keyparms->cipher == 1027074U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, set group_key, TKIP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
        psecuritypriv->dot118021XGrpPrivacy = 1027074U;
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
        memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )key_index].skey),
                 (void const   *)keyparms->key + 16U, 8UL);
        memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )key_index].skey),
                 (void const   *)keyparms->key + 24U, 8UL);
        psecuritypriv->busetkipkey = 1U;
      } else
      if (keyparms->cipher == 1027076U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, set group_key, CCMP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
        psecuritypriv->dot118021XGrpPrivacy = 1027076U;
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
      } else {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, set group_key, none\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
        psecuritypriv->dot118021XGrpPrivacy = 0U;
      }
      psecuritypriv->dot118021XGrpKeyid = (u32 )key_index;
      psecuritypriv->binstallGrpkey = 1U;
      psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;
      set_group_key(padapter, keyparms, psecuritypriv->dot118021XGrpPrivacy, (int )key_index);
      pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
      if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
        pbcmc_sta->ieee8021x_blocked = 0U;
        pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;
      } else {

      }
    } else {

    }
    goto exit;
  } else {

  }
  if (psecuritypriv->dot11AuthAlgrthm == 2U && (unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    if (set_tx == 1) {
      memcpy((void *)(& psta->dot118021x_UncstKey.skey), (void const   *)keyparms->key,
               (size_t )(16 < key_len ? 16 : key_len));
      if (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, set pairwise key, WEP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
        psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
      } else
      if (keyparms->cipher == 1027074U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, set pairwise key, TKIP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
        psta->dot118021XPrivacy = 1027074U;
        memcpy((void *)(& psta->dot11tkiptxmickey.skey), (void const   *)keyparms->key + 16U,
                 8UL);
        memcpy((void *)(& psta->dot11tkiprxmickey.skey), (void const   *)keyparms->key + 24U,
                 8UL);
        psecuritypriv->busetkipkey = 1U;
      } else
      if (keyparms->cipher == 1027076U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, set pairwise key, CCMP\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
        psta->dot118021XPrivacy = 1027076U;
      } else {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, set pairwise key, none\n", "rtw_cfg80211_ap_set_encryption");
        } else {

        }
        psta->dot118021XPrivacy = 0U;
      }
      set_pairwise_key(padapter, psta);
      psta->ieee8021x_blocked = 0U;
      psta->bpairwise_key_installed = 1U;
    } else {
      if (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U) {
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )key_len);
        psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
      } else
      if (keyparms->cipher == 1027074U) {
        psecuritypriv->dot118021XGrpPrivacy = 1027074U;
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
        memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )key_index].skey),
                 (void const   *)keyparms->key + 16U, 8UL);
        memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )key_index].skey),
                 (void const   *)keyparms->key + 24U, 8UL);
        psecuritypriv->busetkipkey = 1U;
      } else
      if (keyparms->cipher == 1027076U) {
        psecuritypriv->dot118021XGrpPrivacy = 1027076U;
        memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )key_index].skey),
                 (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
      } else {
        psecuritypriv->dot118021XGrpPrivacy = 0U;
      }
      psecuritypriv->dot118021XGrpKeyid = (u32 )key_index;
      psecuritypriv->binstallGrpkey = 1U;
      psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;
      set_group_key(padapter, keyparms, psecuritypriv->dot118021XGrpPrivacy, (int )key_index);
      pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
      if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
        pbcmc_sta->ieee8021x_blocked = 0U;
        pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;
      } else {

      }
    }
  } else {

  }
  exit: ;
  return (0);
}
}
static int rtw_cfg80211_set_encryption(struct net_device *dev , u8 key_index , int set_tx ,
                                       u8 const   *sta_addr , struct key_params *keyparms ) 
{ 
  int ret ;
  int key_len ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct sta_info *psta ;
  struct sta_info *pbcmc_sta ;
  struct sta_priv *pstapriv ;
  u8 *tmp___0 ;
  bool tmp___1 ;

  {
  ret = 0;
  tmp = netdev_priv((struct net_device  const  *)dev);
  padapter = (struct rtw_adapter *)tmp;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_set_encryption");
  } else {

  }
  key_len = keyparms->key_len;
  if (keyparms->cipher == 1027073U || keyparms->cipher == 1027077U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(33554432, 4, "wpa_set_encryption, crypt.alg = WEP\n");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: wpa_set_encryption, crypt.alg = WEP\n");
    } else {

    }
    if ((unsigned int )psecuritypriv->bWepDefaultKeyIdxSet == 0U) {
      psecuritypriv->ndisencryptstatus = 0U;
      psecuritypriv->dot11PrivacyAlgrthm = keyparms->cipher;
      psecuritypriv->dot118021XGrpPrivacy = keyparms->cipher;
      psecuritypriv->dot11PrivacyKeyIndex = (u32 )key_index;
    } else {

    }
    memcpy((void *)(& psecuritypriv->wep_key[(int )key_index].key), (void const   *)keyparms->key,
             (size_t )key_len);
    psecuritypriv->wep_key[(int )key_index].keylen = (u16 )key_len;
    rtw_set_key23a(padapter, psecuritypriv, (int )key_index, 0);
    goto exit;
  } else {

  }
  if (padapter->securitypriv.dot11AuthAlgrthm == 2U) {
    pstapriv = & padapter->stapriv;
    tmp___1 = check_fwstate(pmlmepriv, 65544);
    if ((int )tmp___1) {
      tmp___0 = get_bssid(pmlmepriv);
      psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)tmp___0);
      if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, : Obtain Sta_info fail\n", "rtw_cfg80211_set_encryption");
        } else {

        }
      } else {
        if (keyparms->cipher != 1U && keyparms->cipher != 0U) {
          psta->ieee8021x_blocked = 0U;
        } else {

        }
        if (padapter->securitypriv.ndisencryptstatus == 4U || padapter->securitypriv.ndisencryptstatus == 6U) {
          psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
        } else {

        }
        if (set_tx == 1) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: %s, : set_tx == 1\n", "rtw_cfg80211_set_encryption");
          } else {

          }
          memcpy((void *)(& psta->dot118021x_UncstKey.skey), (void const   *)keyparms->key,
                   (size_t )(16 < key_len ? 16 : key_len));
          if (keyparms->cipher == 1027074U) {
            memcpy((void *)(& psta->dot11tkiptxmickey.skey), (void const   *)keyparms->key + 16U,
                     8UL);
            memcpy((void *)(& psta->dot11tkiprxmickey.skey), (void const   *)keyparms->key + 24U,
                     8UL);
            padapter->securitypriv.busetkipkey = 0U;
          } else {

          }
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU:  ~~~~set sta key:unicastkey\n");
          } else {

          }
          rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
        } else {
          memcpy((void *)(& padapter->securitypriv.dot118021XGrpKey[(int )key_index].skey),
                   (void const   *)keyparms->key, (size_t )(16 < key_len ? 16 : key_len));
          memcpy((void *)(& padapter->securitypriv.dot118021XGrptxmickey[(int )key_index].skey),
                   (void const   *)keyparms->key + 16U, 8UL);
          memcpy((void *)(& padapter->securitypriv.dot118021XGrprxmickey[(int )key_index].skey),
                   (void const   *)keyparms->key + 24U, 8UL);
          padapter->securitypriv.binstallGrpkey = 1U;
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU:  ~~~~set sta key:groupkey\n");
          } else {

          }
          padapter->securitypriv.dot118021XGrpKeyid = (u32 )key_index;
          rtw_set_key23a(padapter, & padapter->securitypriv, (int )key_index, 1);
        }
      }
      pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
      if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
        if (keyparms->cipher != 1U && keyparms->cipher != 0U) {
          pbcmc_sta->ieee8021x_blocked = 0U;
        } else {

        }
        if (padapter->securitypriv.ndisencryptstatus == 4U || padapter->securitypriv.ndisencryptstatus == 6U) {
          pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ret =%d\n", "rtw_cfg80211_set_encryption", ret);
  } else {

  }
  return (ret);
}
}
static int cfg80211_rtw_add_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr , struct key_params *params ) 
{ 
  int set_tx ;
  int ret ;
  struct wireless_dev *rtw_wdev ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  void *tmp___0 ;
  struct mlme_priv *pmlmepriv ;
  u8 sta_addr[6U] ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  rtw_wdev = ((struct rtw_wdev_priv *)tmp)->rtw_wdev;
  tmp___0 = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp___0)->padapter;
  pmlmepriv = & padapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): adding key for %pM\n", "cfg80211_rtw_add_key",
           (char *)(& ndev->name), mac_addr);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: cipher = 0x%x\n", params->cipher);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: key_len = 0x%x\n", params->key_len);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: seq_len = 0x%x\n", params->seq_len);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: key_index =%d\n", (int )key_index);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: pairwise =%d\n", (int )pairwise);
  } else {

  }
  switch (params->cipher) {
  case 1U: ;
  case 1027073U: ;
  if (params->key_len != 5) {
    ret = -22;
    goto exit;
  } else {

  }
  case 1027077U: ;
  if (params->key_len != 13) {
    ret = -22;
    goto exit;
  } else {

  }
  case 1027074U: ;
  case 1027076U: ;
  goto ldv_53312;
  default: 
  ret = -524;
  goto exit;
  }
  ldv_53312: ;
  if ((unsigned int )key_index > 3U || params->key_len < 0) {
    ret = -22;
    goto exit;
  } else {

  }
  eth_broadcast_addr((u8 *)(& sta_addr));
  if ((unsigned long )mac_addr == (unsigned long )((u8 const   *)0U)) {
    set_tx = 0;
  } else {
    tmp___1 = is_broadcast_ether_addr(mac_addr);
    if ((int )tmp___1) {
      set_tx = 0;
    } else {
      set_tx = 1;
    }
  }
  tmp___3 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___3) {
    ret = rtw_cfg80211_set_encryption(ndev, (int )key_index, set_tx, (u8 const   *)(& sta_addr),
                                      params);
  } else {
    tmp___2 = check_fwstate(pmlmepriv, 16);
    if ((int )tmp___2) {
      if ((unsigned long )mac_addr != (unsigned long )((u8 const   *)0U)) {
        ether_addr_copy((u8 *)(& sta_addr), mac_addr);
      } else {

      }
      ret = rtw_cfg80211_ap_set_encryption(ndev, (int )key_index, set_tx, (u8 const   *)(& sta_addr),
                                           params);
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: error! fw_state = 0x%x, iftype =%d\n", pmlmepriv->fw_state,
             (unsigned int )rtw_wdev->iftype);
    } else {

    }
  }
  exit: ;
  return (ret);
}
}
static int cfg80211_rtw_get_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr , void *cookie ,
                                void (*callback)(void * , struct key_params * ) ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_get_key", (char *)(& ndev->name));
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_del_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
  tmp = netdev_priv((struct net_device  const  *)ndev);
  padapter = (struct rtw_adapter *)tmp;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): key_index =%d\n", "cfg80211_rtw_del_key", (char *)(& ndev->name),
           (int )key_index);
  } else {

  }
  if ((u32 )key_index == psecuritypriv->dot11PrivacyKeyIndex) {
    psecuritypriv->bWepDefaultKeyIdxSet = 0U;
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_set_default_key(struct wiphy *wiphy , struct net_device *ndev ,
                                        u8 key_index , bool unicast , bool multicast ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
  tmp = netdev_priv((struct net_device  const  *)ndev);
  padapter = (struct rtw_adapter *)tmp;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): key_index =%d, unicast =%d, multicast =%d.\n",
           "cfg80211_rtw_set_default_key", (char *)(& ndev->name), (int )key_index,
           (int )unicast, (int )multicast);
  } else {

  }
  if ((unsigned int )key_index <= 3U && (psecuritypriv->dot11PrivacyAlgrthm == 1027073U || psecuritypriv->dot11PrivacyAlgrthm == 1027077U)) {
    psecuritypriv->ndisencryptstatus = 0U;
    psecuritypriv->dot11PrivacyKeyIndex = (u32 )key_index;
    psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
    psecuritypriv->dot118021XGrpPrivacy = 1027073U;
    if ((unsigned int )psecuritypriv->wep_key[(int )key_index].keylen == 13U) {
      psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
      psecuritypriv->dot118021XGrpPrivacy = 1027077U;
    } else {

    }
    psecuritypriv->bWepDefaultKeyIdxSet = 1U;
  } else {

  }
  return (0);
}
}
static u16 rtw_get_cur_max_rate(struct rtw_adapter *adapter ) 
{ 
  int i ;
  u8 const   *p ;
  u16 rate ;
  u16 max_rate ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct registry_priv *pregistrypriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_bss ;
  struct ieee80211_ht_cap *pht_capie ;
  u8 rf_type ;
  u8 bw_40MHz ;
  u8 short_GI_20 ;
  u8 short_GI_40 ;
  u16 mcs_rate ;

  {
  i = 0;
  rate = 0U;
  max_rate = 0U;
  pmlmeext = & adapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pregistrypriv = & adapter->registrypriv;
  pmlmepriv = & adapter->mlmepriv;
  pcur_bss = & pmlmepriv->cur_network.network;
  rf_type = 0U;
  bw_40MHz = 0U;
  short_GI_20 = 0U;
  short_GI_40 = 0U;
  mcs_rate = 0U;
  p = cfg80211_find_ie(45, (u8 const   *)(& pcur_bss->IEs), (int )pcur_bss->IELength);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_capie = (struct ieee80211_ht_cap *)p + 2U;
    memcpy((void *)(& mcs_rate), (void const   *)(& pht_capie->mcs), 2UL);
    bw_40MHz = (u8 )((unsigned int )pmlmeext->cur_bwmode != 0U && ((int )pmlmeinfo->HT_info.ht_param & 4) != 0);
    short_GI_20 = ((int )pmlmeinfo->ht_cap.cap_info & 32) != 0;
    short_GI_40 = ((int )pmlmeinfo->ht_cap.cap_info & 64) != 0;
    rf_type = rtl8723a_get_rf_type(adapter);
    max_rate = rtw_mcs_rate23a((int )rf_type, (int )pregistrypriv->cbw40_enable & (int )bw_40MHz,
                               (int )short_GI_20, (int )short_GI_40, & pmlmeinfo->ht_cap.mcs);
  } else {
    goto ldv_53365;
    ldv_53364: 
    rate = (unsigned int )((u16 )pcur_bss->SupportedRates[i]) & 127U;
    if ((int )rate > (int )max_rate) {
      max_rate = rate;
    } else {

    }
    i = i + 1;
    ldv_53365: ;
    if ((unsigned int )pcur_bss->SupportedRates[i] != 0U && (unsigned int )pcur_bss->SupportedRates[i] != 255U) {
      goto ldv_53364;
    } else {

    }
    max_rate = (u16 )(((int )max_rate * 10) / 2);
  }
  return (max_rate);
}
}
static int cfg80211_rtw_get_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const   *mac , struct station_info *sinfo ) 
{ 
  int ret ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct wlan_network *cur_network ;
  bool tmp___0 ;
  int tmp___1 ;
  s32 tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;

  {
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  pmlmepriv = & padapter->mlmepriv;
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  sinfo->filled = 0U;
  if ((unsigned long )mac == (unsigned long )((u8 const   *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): mac ==%p\n", "cfg80211_rtw_get_station", (char *)(& ndev->name),
             mac);
    } else {

    }
    ret = -2;
    goto exit;
  } else {

  }
  psta = rtw_get_stainfo23a(pstapriv, mac);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, sta_info is null\n", "cfg80211_rtw_get_station");
    } else {

    }
    ret = -2;
    goto exit;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): mac=%pM\n", "cfg80211_rtw_get_station", (char *)(& ndev->name),
           mac);
  } else {

  }
  tmp___3 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___3) {
    tmp___4 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___4) {
      cur_network = & pmlmepriv->cur_network;
      tmp___0 = ether_addr_equal(mac, (u8 const   *)(& cur_network->network.MacAddress));
      if (tmp___0) {
        tmp___1 = 0;
      } else {
        tmp___1 = 1;
      }
      if (tmp___1) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, mismatch bssid=%pM\n", "cfg80211_rtw_get_station",
                 (u8 *)(& cur_network->network.MacAddress));
        } else {

        }
        ret = -2;
        goto exit;
      } else {

      }
      sinfo->filled = sinfo->filled | 128U;
      tmp___2 = translate_percentage_to_dbm((u32 )padapter->recvpriv.signal_strength);
      sinfo->signal = (s8 )tmp___2;
      sinfo->filled = sinfo->filled | 256U;
      sinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);
      sinfo->filled = sinfo->filled | 512U;
      sinfo->rx_packets = (u32 )psta->sta_stats.rx_data_pkts;
      sinfo->filled = sinfo->filled | 1024U;
      sinfo->tx_packets = (u32 )psta->sta_stats.tx_pkts;
    } else {

    }
  } else {

  }
  tmp___5 = check_fwstate(pmlmepriv, 32);
  if ((int )tmp___5) {
    goto _L;
  } else {
    tmp___6 = check_fwstate(pmlmepriv, 64);
    if ((int )tmp___6) {
      goto _L;
    } else {
      tmp___7 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___7) {
        _L: /* CIL Label */ 
        tmp___8 = check_fwstate(pmlmepriv, 1);
        if ((int )tmp___8) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
    }
  }
  exit: ;
  return (ret);
}
}
static int cfg80211_infrastructure_mode(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  enum nl80211_iftype old_mode ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network;
  old_mode = cur_network->network.ifmode;
  if (GlobalDebugLevel23A > 5U) {
    tmp = get_fwstate(pmlmepriv);
    rt_trace(131072, 6, "+%s: old =%d new =%d fw_state = 0x%08x\n", "cfg80211_infrastructure_mode",
             (unsigned int )old_mode, (unsigned int )ifmode, tmp);
  } else {

  }
  if ((unsigned int )old_mode != (unsigned int )ifmode) {
    spin_lock_bh(& pmlmepriv->lock);
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(131072, 7, "change mode!\n");
    } else {

    }
    if ((unsigned int )old_mode == 3U || (unsigned int )old_mode == 9U) {
      cur_network->join_res = -1;
      stop_ap_mode23a(padapter);
    } else {

    }
    tmp___0 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___0 || (unsigned int )old_mode == 1U) {
      rtw_disassoc_cmd23a(padapter, 0U, 1);
    } else {

    }
    tmp___1 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___1) {
      rtw_free_assoc_resources23a(padapter, 1);
    } else {
      tmp___2 = check_fwstate(pmlmepriv, 64);
      if ((int )tmp___2) {
        rtw_free_assoc_resources23a(padapter, 1);
      } else {

      }
    }
    if (((unsigned int )old_mode == 2U || (unsigned int )old_mode == 8U) || (unsigned int )old_mode == 1U) {
      tmp___3 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___3) {
        rtw_indicate_disconnect23a(padapter);
      } else {

      }
    } else {

    }
    cur_network->network.ifmode = ifmode;
    _clr_fwstate_(pmlmepriv, -1);
    switch ((unsigned int )ifmode) {
    case 1U: 
    set_fwstate(pmlmepriv, 32);
    goto ldv_53390;
    case 8U: ;
    case 2U: 
    set_fwstate(pmlmepriv, 8);
    goto ldv_53390;
    case 9U: ;
    case 3U: 
    set_fwstate(pmlmepriv, 16);
    start_ap_mode23a(padapter);
    goto ldv_53390;
    default: ;
    goto ldv_53390;
    }
    ldv_53390: 
    spin_unlock_bh(& pmlmepriv->lock);
  } else {

  }
  return (1);
}
}
static int cfg80211_rtw_change_iface(struct wiphy *wiphy , struct net_device *ndev ,
                                     enum nl80211_iftype type , u32 *flags , struct vif_params *params ) 
{ 
  enum nl80211_iftype old_type ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_ext_priv *pmlmeext ;
  struct wireless_dev *rtw_wdev ;
  void *tmp___0 ;
  int ret ;
  int tmp___1 ;

  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  pmlmeext = & padapter->mlmeextpriv;
  tmp___0 = wiphy_priv___1(wiphy);
  rtw_wdev = ((struct rtw_wdev_priv *)tmp___0)->rtw_wdev;
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): call netdev_open23a\n", "cfg80211_rtw_change_iface",
           (char *)(& ndev->name));
  } else {

  }
  old_type = rtw_wdev->iftype;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): old_iftype =%d, new_iftype =%d\n", "cfg80211_rtw_change_iface",
           (char *)(& ndev->name), (unsigned int )old_type, (unsigned int )type);
  } else {

  }
  if ((unsigned int )old_type != (unsigned int )type) {
    pmlmeext->action_public_rxseq = 65535U;
    pmlmeext->action_public_dialog_token = 255U;
  } else {

  }
  switch ((unsigned int )type) {
  case 1U: ;
  case 8U: ;
  case 2U: ;
  case 9U: ;
  case 3U: ;
  case 0U: ;
  goto ldv_53415;
  default: ;
  return (-95);
  }
  ldv_53415: 
  rtw_wdev->iftype = type;
  tmp___1 = cfg80211_infrastructure_mode(padapter, type);
  if (tmp___1 != 1) {
    rtw_wdev->iftype = old_type;
    ret = -1;
    goto exit;
  } else {

  }
  rtw_setopmode_cmd23a(padapter, type);
  exit: ;
  return (ret);
}
}
void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv , bool aborted ) 
{ 


  {
  spin_lock_bh(& pwdev_priv->scan_req_lock);
  if ((unsigned long )pwdev_priv->scan_request != (unsigned long )((struct cfg80211_scan_request *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s with scan req\n", "rtw_cfg80211_indicate_scan_done");
    } else {

    }
    if ((unsigned long )(pwdev_priv->scan_request)->wiphy != (unsigned long )(pwdev_priv->rtw_wdev)->wiphy) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: error wiphy compare\n");
      } else {

      }
    } else {
      cfg80211_scan_done(pwdev_priv->scan_request, (int )aborted);
    }
    pwdev_priv->scan_request = (struct cfg80211_scan_request *)0;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s without scan req\n", "rtw_cfg80211_indicate_scan_done");
  } else {

  }
  spin_unlock_bh(& pwdev_priv->scan_req_lock);
  return;
}
}
void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *queue ;
  struct wlan_network *pnetwork ;
  struct list_head  const  *__mptr ;
  int tmp ;
  void *tmp___0 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  queue = & pmlmepriv->scanned_queue;
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  phead = get_list_head(queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53435;
  ldv_53434: 
  __mptr = (struct list_head  const  *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  tmp = rtw_ch_set_search_ch23a((struct rt_channel_info *)(& padapter->mlmeextpriv.channel_set),
                                pnetwork->network.DSConfig);
  if (tmp >= 0) {
    rtw_cfg80211_inform_bss(padapter, pnetwork);
  } else {

  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_53435: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53434;
  } else {

  }
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
  rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___0, 0);
  return;
}
}
static int rtw_cfg80211_set_probe_req_wpsp2pie(struct rtw_adapter *padapter , char *buf ,
                                               int len ) 
{ 
  int ret ;
  u8 const   *wps_ie ;
  struct mlme_priv *pmlmepriv ;
  void *tmp ;

  {
  ret = 0;
  pmlmepriv = & padapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ielen =%d\n", "rtw_cfg80211_set_probe_req_wpsp2pie",
           len);
  } else {

  }
  if (len > 0) {
    wps_ie = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)buf, len);
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: probe_req_wps_ielen =%d\n", (int )*(wps_ie + 1UL));
      } else {

      }
      if ((unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
        pmlmepriv->wps_probe_req_ie_len = 0U;
        kfree((void const   *)pmlmepriv->wps_probe_req_ie);
        pmlmepriv->wps_probe_req_ie = (u8 *)0U;
      } else {

      }
      tmp = kmemdup((void const   *)wps_ie, (size_t )*(wps_ie + 1UL), 208U);
      pmlmepriv->wps_probe_req_ie = (u8 *)tmp;
      if ((unsigned long )pmlmepriv->wps_probe_req_ie == (unsigned long )((u8 *)0U)) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s()-%d: kmalloc() OLD_ERROR!\n", "rtw_cfg80211_set_probe_req_wpsp2pie",
                 1326);
        } else {

        }
        return (-22);
      } else {

      }
      pmlmepriv->wps_probe_req_ie_len = (u32 )*(wps_ie + 1UL);
    } else {

    }
  } else {

  }
  return (ret);
}
}
static int cfg80211_rtw_scan(struct wiphy *wiphy , struct cfg80211_scan_request *request ) 
{ 
  int i ;
  u8 _status ;
  int ret ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct cfg80211_ssid ssid[9U] ;
  struct rtw_ieee80211_channel ch[51U] ;
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp___0 ;
  struct cfg80211_ssid *ssids ;
  bool need_indicate_scan_done ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  _status = 0U;
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  pmlmepriv = & padapter->mlmepriv;
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
  pwdev_priv = (struct rtw_wdev_priv *)tmp___0;
  ssids = request->ssids;
  need_indicate_scan_done = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_scan", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
  spin_lock_bh(& pwdev_priv->scan_req_lock);
  pwdev_priv->scan_request = request;
  spin_unlock_bh(& pwdev_priv->scan_req_lock);
  tmp___1 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s under WIFI_AP_STATE\n", "cfg80211_rtw_scan");
    } else {

    }
  } else {

  }
  tmp___2 = _rtw_pwr_wakeup23a(padapter, 2000U, "cfg80211_rtw_scan");
  if (tmp___2 == 0) {
    need_indicate_scan_done = 1;
    goto check_need_indicate_scan_done;
  } else {

  }
  if ((unsigned long )request->ie != (unsigned long )((u8 const   *)0U) && request->ie_len != 0UL) {
    rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (char *)request->ie, (int )request->ie_len);
  } else {

  }
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, bBusyTraffic == true\n", "cfg80211_rtw_scan");
    } else {

    }
    need_indicate_scan_done = 1;
    goto check_need_indicate_scan_done;
  } else {

  }
  tmp___3 = rtw_is_scan_deny(padapter);
  if ((int )tmp___3) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): scan deny\n", "cfg80211_rtw_scan", (char *)(& (padapter->pnetdev)->name));
    } else {

    }
    need_indicate_scan_done = 1;
    goto check_need_indicate_scan_done;
  } else {

  }
  tmp___4 = check_fwstate(pmlmepriv, 2176);
  if ((int )tmp___4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, fwstate = 0x%x\n", "cfg80211_rtw_scan", pmlmepriv->fw_state);
    } else {

    }
    need_indicate_scan_done = 1;
    goto check_need_indicate_scan_done;
  } else {

  }
  memset((void *)(& ssid), 0, 297UL);
  i = 0;
  goto ldv_53463;
  ldv_53462: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ssid =%s, len =%d\n", (u8 *)(& (ssids + (unsigned long )i)->ssid),
           (int )(ssids + (unsigned long )i)->ssid_len);
  } else {

  }
  memcpy((void *)(& ssid[i].ssid), (void const   *)(& (ssids + (unsigned long )i)->ssid),
           (size_t )(ssids + (unsigned long )i)->ssid_len);
  ssid[i].ssid_len = (ssids + (unsigned long )i)->ssid_len;
  i = i + 1;
  ldv_53463: ;
  if (request->n_ssids > i && i <= 8) {
    goto ldv_53462;
  } else {

  }
  memset((void *)(& ch), 0, 408UL);
  if (request->n_channels == 1U) {
    i = 0;
    goto ldv_53466;
    ldv_53465: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s:(%s):hw_value:%u, flags:0x%08x\n", "cfg80211_rtw_scan",
             (char *)(& (padapter->pnetdev)->name), (int )(request->channels[i])->hw_value,
             (request->channels[i])->flags);
    } else {

    }
    ch[i].hw_value = (request->channels[i])->hw_value;
    ch[i].flags = (request->channels[i])->flags;
    i = i + 1;
    ldv_53466: ;
    if ((u32 )i < request->n_channels && i <= 50) {
      goto ldv_53465;
    } else {

    }

  } else {

  }
  spin_lock_bh(& pmlmepriv->lock);
  if (request->n_channels == 1U) {
    memcpy((void *)(& ch) + 1U, (void const   *)(& ch), 8UL);
    memcpy((void *)(& ch) + 2U, (void const   *)(& ch), 8UL);
    tmp___5 = rtw_sitesurvey_cmd23a(padapter, (struct cfg80211_ssid *)(& ssid), 9,
                                    (struct rtw_ieee80211_channel *)(& ch), 3);
    _status = (u8 )tmp___5;
  } else {
    tmp___6 = rtw_sitesurvey_cmd23a(padapter, (struct cfg80211_ssid *)(& ssid), 9,
                                    (struct rtw_ieee80211_channel *)0, 0);
    _status = (u8 )tmp___6;
  }
  spin_unlock_bh(& pmlmepriv->lock);
  if ((unsigned int )_status == 0U) {
    ret = -1;
  } else {

  }
  check_need_indicate_scan_done: ;
  if ((int )need_indicate_scan_done) {
    rtw_cfg80211_surveydone_event_callback(padapter);
  } else {

  }
  return (ret);
}
}
static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy , u32 changed ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_set_wiphy_params");
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_join_ibss(struct wiphy *wiphy , struct net_device *ndev ,
                                  struct cfg80211_ibss_params *params ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_join_ibss", (char *)(& ndev->name));
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy , struct net_device *ndev ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_leave_ibss", (char *)(& ndev->name));
  } else {

  }
  return (0);
}
}
static int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv , u32 wpa_version ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, wpa_version =%d\n", "rtw_cfg80211_set_wpa_version",
           wpa_version);
  } else {

  }
  if (wpa_version == 0U) {
    psecuritypriv->ndisauthtype = 0U;
    return (0);
  } else {

  }
  if ((wpa_version & 3U) != 0U) {
    psecuritypriv->ndisauthtype = 4U;
  } else {

  }
  return (0);
}
}
static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv , enum nl80211_auth_type sme_auth_type ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, nl80211_auth_type =%d\n", "rtw_cfg80211_set_auth_type",
           (unsigned int )sme_auth_type);
  } else {

  }
  switch ((unsigned int )sme_auth_type) {
  case 5U: 
  psecuritypriv->dot11AuthAlgrthm = 3U;
  goto ldv_53495;
  case 0U: 
  psecuritypriv->dot11AuthAlgrthm = 0U;
  if (psecuritypriv->ndisauthtype > 3U) {
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else {

  }
  goto ldv_53495;
  case 1U: 
  psecuritypriv->dot11AuthAlgrthm = 1U;
  psecuritypriv->ndisencryptstatus = 0U;
  goto ldv_53495;
  default: 
  psecuritypriv->dot11AuthAlgrthm = 0U;
  }
  ldv_53495: ;
  return (0);
}
}
static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv , u32 cipher ,
                                   bool ucast ) 
{ 
  u32 ndisencryptstatus ;
  u32 *profile_cipher ;

  {
  ndisencryptstatus = 1U;
  profile_cipher = (int )ucast ? & psecuritypriv->dot11PrivacyAlgrthm : & psecuritypriv->dot118021XGrpPrivacy;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ucast =%d, cipher = 0x%x\n", "rtw_cfg80211_set_cipher",
           (int )ucast, cipher);
  } else {

  }
  if (cipher == 0U) {
    *profile_cipher = 0U;
    psecuritypriv->ndisencryptstatus = ndisencryptstatus;
    return (0);
  } else {

  }
  switch (cipher) {
  case 1U: 
  *profile_cipher = 0U;
  ndisencryptstatus = 1U;
  goto ldv_53508;
  case 1027073U: 
  *profile_cipher = 1027073U;
  ndisencryptstatus = 0U;
  goto ldv_53508;
  case 1027077U: 
  *profile_cipher = 1027077U;
  ndisencryptstatus = 0U;
  goto ldv_53508;
  case 1027074U: 
  *profile_cipher = 1027074U;
  ndisencryptstatus = 4U;
  goto ldv_53508;
  case 1027076U: 
  *profile_cipher = 1027076U;
  ndisencryptstatus = 6U;
  goto ldv_53508;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Unsupported cipher: 0x%x\n", cipher);
  } else {

  }
  return (-524);
  }
  ldv_53508: ;
  if ((int )ucast) {
    psecuritypriv->ndisencryptstatus = ndisencryptstatus;
  } else {

  }
  return (0);
}
}
static int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv , u32 key_mgt ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, key_mgt = 0x%x\n", "rtw_cfg80211_set_key_mgt", key_mgt);
  } else {

  }
  if (key_mgt == 1027073U) {
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else
  if (key_mgt == 1027074U) {
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Invalid key mgt: 0x%x\n", key_mgt);
  } else {

  }
  return (0);
}
}
static int rtw_cfg80211_set_wpa_ie(struct rtw_adapter *padapter , u8 const   *pie ,
                                   size_t ielen ) 
{ 
  u8 const   *wps_ie ;
  int group_cipher ;
  int pairwise_cipher ;
  int ret ;
  u8 const   *pwpa ;
  u8 const   *pwpa2 ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  group_cipher = 0;
  pairwise_cipher = 0;
  ret = 0;
  if ((unsigned long )pie == (unsigned long )((u8 const   *)0U) || ielen == 0UL) {
    _clr_fwstate_(& padapter->mlmepriv, 256);
    goto exit;
  } else {

  }
  if (ielen > 768UL) {
    ret = -22;
    goto exit;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: set wpa_ie(length:%zu):\n", ielen);
  } else {

  }
  i = 0;
  goto ldv_53533;
  ldv_53532: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
           (int )*(pie + (unsigned long )i), (int )*(pie + ((unsigned long )i + 1UL)),
           (int )*(pie + ((unsigned long )i + 2UL)), (int )*(pie + ((unsigned long )i + 3UL)),
           (int )*(pie + ((unsigned long )i + 4UL)), (int )*(pie + ((unsigned long )i + 5UL)),
           (int )*(pie + ((unsigned long )i + 6UL)), (int )*(pie + ((unsigned long )i + 7UL)));
  } else {

  }
  i = i + 8;
  ldv_53533: ;
  if ((size_t )i < ielen) {
    goto ldv_53532;
  } else {

  }

  if (ielen <= 3UL) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(33554432, 4, "Ie len too short %d\n", (int )ielen);
    } else {

    }
    ret = -1;
    goto exit;
  } else {

  }
  pwpa = cfg80211_find_vendor_ie(20722U, 1, pie, (int )ielen);
  if ((unsigned long )pwpa != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pwpa + 1UL)) != 0U) {
    tmp = rtw_parse_wpa_ie23a(pwpa, (int )*(pwpa + 1UL) + 2, & group_cipher, & pairwise_cipher,
                              (int *)0);
    if (tmp == 1) {
      padapter->securitypriv.dot11AuthAlgrthm = 2U;
      padapter->securitypriv.ndisauthtype = 4U;
      memcpy((void *)(& padapter->securitypriv.supplicant_ie), (void const   *)pwpa,
               (size_t )((int )*(pwpa + 1UL) + 2));
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: got wpa_ie, wpa_ielen:%u\n", (int )*(pwpa + 1UL));
      } else {

      }
    } else {

    }
  } else {

  }
  pwpa2 = cfg80211_find_ie(48, pie, (int )ielen);
  if ((unsigned long )pwpa2 != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pwpa2 + 1UL)) != 0U) {
    tmp___0 = rtw_parse_wpa2_ie23a(pwpa2, (int )*(pwpa2 + 1UL) + 2, & group_cipher,
                                   & pairwise_cipher, (int *)0);
    if (tmp___0 == 1) {
      padapter->securitypriv.dot11AuthAlgrthm = 2U;
      padapter->securitypriv.ndisauthtype = 7U;
      memcpy((void *)(& padapter->securitypriv.supplicant_ie), (void const   *)pwpa2,
               (size_t )((int )*(pwpa2 + 1UL) + 2));
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: got wpa2_ie, wpa2_ielen:%u\n", (int )*(pwpa2 + 1UL));
      } else {

      }
    } else {

    }
  } else {

  }
  if (group_cipher == 0) {
    group_cipher = 1;
  } else {

  }
  if (pairwise_cipher == 0) {
    pairwise_cipher = 1;
  } else {

  }
  switch (group_cipher) {
  case 1: 
  padapter->securitypriv.dot118021XGrpPrivacy = 0U;
  padapter->securitypriv.ndisencryptstatus = 1U;
  goto ldv_53536;
  case 2: 
  padapter->securitypriv.dot118021XGrpPrivacy = 1027073U;
  padapter->securitypriv.ndisencryptstatus = 0U;
  goto ldv_53536;
  case 8: 
  padapter->securitypriv.dot118021XGrpPrivacy = 1027074U;
  padapter->securitypriv.ndisencryptstatus = 4U;
  goto ldv_53536;
  case 16: 
  padapter->securitypriv.dot118021XGrpPrivacy = 1027076U;
  padapter->securitypriv.ndisencryptstatus = 6U;
  goto ldv_53536;
  case 4: 
  padapter->securitypriv.dot118021XGrpPrivacy = 1027077U;
  padapter->securitypriv.ndisencryptstatus = 0U;
  goto ldv_53536;
  }
  ldv_53536: ;
  switch (pairwise_cipher) {
  case 1: 
  padapter->securitypriv.dot11PrivacyAlgrthm = 0U;
  padapter->securitypriv.ndisencryptstatus = 1U;
  goto ldv_53542;
  case 2: 
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027073U;
  padapter->securitypriv.ndisencryptstatus = 0U;
  goto ldv_53542;
  case 8: 
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027074U;
  padapter->securitypriv.ndisencryptstatus = 4U;
  goto ldv_53542;
  case 16: 
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027076U;
  padapter->securitypriv.ndisencryptstatus = 6U;
  goto ldv_53542;
  case 4: 
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027077U;
  padapter->securitypriv.ndisencryptstatus = 0U;
  goto ldv_53542;
  }
  ldv_53542: 
  wps_ie = cfg80211_find_vendor_ie(20722U, 4, pie, (int )ielen);
  if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(wps_ie + 1UL)) != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: got wps_ie, wps_ielen:%u\n", (int )*(wps_ie + 1UL));
    } else {

    }
    padapter->securitypriv.wps_ie_len = (int )*(wps_ie + 1UL);
    memcpy((void *)(& padapter->securitypriv.wps_ie), (void const   *)wps_ie, (size_t )padapter->securitypriv.wps_ie_len);
    set_fwstate(& padapter->mlmepriv, 256);
  } else {
    _clr_fwstate_(& padapter->mlmepriv, 256);
  }
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
    rtl8723a_off_rcr_am(padapter);
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(33554432, 7, "rtw_set_wpa_ie: pairwise_cipher = 0x%08x padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype =%d\n",
             pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype);
  } else {

  }
  exit: ;
  if (ret != 0) {
    _clr_fwstate_(& padapter->mlmepriv, 256);
  } else {

  }
  return (ret);
}
}
static int rtw_cfg80211_add_wep(struct rtw_adapter *padapter , struct rtw_wep_key *wep ,
                                u8 keyid ) 
{ 
  int res ;
  struct security_priv *psecuritypriv ;

  {
  psecuritypriv = & padapter->securitypriv;
  if ((unsigned int )keyid > 3U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(131072, 4, "%s:keyid>4 =>fail\n", "rtw_cfg80211_add_wep");
    } else {

    }
    res = 0;
    goto exit;
  } else {

  }
  switch ((int )wep->keylen) {
  case 5: 
  psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(131072, 7, "%s:wep->KeyLength = 5\n", "rtw_cfg80211_add_wep");
  } else {

  }
  goto ldv_53557;
  case 13: 
  psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(131072, 7, "%s:wep->KeyLength = 13\n", "rtw_cfg80211_add_wep");
  } else {

  }
  goto ldv_53557;
  default: 
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(131072, 7, "%s:wep->KeyLength!= 5 or 13\n", "rtw_cfg80211_add_wep");
  } else {

  }
  res = 0;
  goto exit;
  }
  ldv_53557: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(131072, 7, "%s:before memcpy, wep->KeyLength = 0x%x keyid =%x\n", "rtw_cfg80211_add_wep",
             (int )wep->keylen, (int )keyid);
  } else {

  }
  memcpy((void *)(& psecuritypriv->wep_key) + (unsigned long )keyid, (void const   *)wep,
           16UL);
  psecuritypriv->dot11PrivacyKeyIndex = (u32 )keyid;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(131072, 7, "%s:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x\n",
             "rtw_cfg80211_add_wep", (int )psecuritypriv->wep_key[(int )keyid].key[0],
             (int )psecuritypriv->wep_key[(int )keyid].key[1], (int )psecuritypriv->wep_key[(int )keyid].key[2],
             (int )psecuritypriv->wep_key[(int )keyid].key[3], (int )psecuritypriv->wep_key[(int )keyid].key[4],
             (int )psecuritypriv->wep_key[(int )keyid].key[5], (int )psecuritypriv->wep_key[(int )keyid].key[6],
             (int )psecuritypriv->wep_key[(int )keyid].key[7], (int )psecuritypriv->wep_key[(int )keyid].key[8],
             (int )psecuritypriv->wep_key[(int )keyid].key[9], (int )psecuritypriv->wep_key[(int )keyid].key[10],
             (int )psecuritypriv->wep_key[(int )keyid].key[11], (int )psecuritypriv->wep_key[(int )keyid].key[12]);
  } else {

  }
  res = rtw_set_key23a(padapter, psecuritypriv, (int )keyid, 1);
  exit: ;
  return (res);
}
}
static int rtw_set_ssid(struct rtw_adapter *padapter , struct wlan_network *newnetwork ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  int status ;
  u32 cur_time ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pnetwork = & pmlmepriv->cur_network;
  status = 1;
  cur_time = 0U;
  if (GlobalDebugLevel23A != 0U) {
    tmp = get_fwstate(pmlmepriv);
    printk("\016RTL8723AU: set ssid [%s] fw_state = 0x%08x\n", (u8 *)(& newnetwork->network.Ssid.ssid),
           tmp);
  } else {

  }
  if ((unsigned int )padapter->hw_init_completed == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(131072, 4, "set_ssid: hw_init_completed == false =>exit!!!\n");
    } else {

    }
    status = 0;
    goto exit;
  } else {

  }
  spin_lock_bh(& pmlmepriv->lock);
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = get_fwstate(pmlmepriv);
    printk("\016RTL8723AU: Set SSID under fw_state = 0x%08x\n", tmp___0);
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___1) {
    goto handle_tkip_countermeasure;
  } else {

  }
  tmp___11 = check_fwstate(pmlmepriv, 65);
  if ((int )tmp___11) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(131072, 7, "set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n");
    } else {

    }
    if ((int )pmlmepriv->assoc_ssid.ssid_len == (int )newnetwork->network.Ssid.ssid_len) {
      tmp___10 = memcmp((void const   *)(& pmlmepriv->assoc_ssid.ssid), (void const   *)(& newnetwork->network.Ssid.ssid),
                        (size_t )newnetwork->network.Ssid.ssid_len);
      if (tmp___10 == 0) {
        tmp___6 = check_fwstate(pmlmepriv, 8);
        if (tmp___6) {
          tmp___7 = 0;
        } else {
          tmp___7 = 1;
        }
        if (tmp___7) {
          if (GlobalDebugLevel23A > 3U) {
            tmp___2 = get_fwstate(pmlmepriv);
            rt_trace(131072, 4, "New SSID is same SSID, fw_state = 0x%08x\n", tmp___2);
          } else {

          }
          tmp___3 = rtw_is_same_ibss23a(padapter, pnetwork);
          if ((int )tmp___3) {
            goto release_mlme_lock;
          } else {

          }
          rtw_disassoc_cmd23a(padapter, 0U, 1);
          tmp___4 = check_fwstate(pmlmepriv, 1);
          if ((int )tmp___4) {
            rtw_indicate_disconnect23a(padapter);
          } else {

          }
          rtw_free_assoc_resources23a(padapter, 1);
          tmp___5 = check_fwstate(pmlmepriv, 64);
          if ((int )tmp___5) {
            _clr_fwstate_(pmlmepriv, 64);
            set_fwstate(pmlmepriv, 32);
          } else {

          }
        } else {
          rtw_lps_ctrl_wk_cmd23a(padapter, 1, 1);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(131072, 7, "Set SSID not the same ssid\n");
      } else {

      }
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(131072, 7, "set_ssid =[%s] len = 0x%x\n", (u8 *)(& newnetwork->network.Ssid.ssid),
                 (int )newnetwork->network.Ssid.ssid_len);
      } else {

      }
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(131072, 7, "assoc_ssid =[%s] len = 0x%x\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid),
                 (int )pmlmepriv->assoc_ssid.ssid_len);
      } else {

      }
      rtw_disassoc_cmd23a(padapter, 0U, 1);
      tmp___8 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___8) {
        rtw_indicate_disconnect23a(padapter);
      } else {

      }
      rtw_free_assoc_resources23a(padapter, 1);
      tmp___9 = check_fwstate(pmlmepriv, 64);
      if ((int )tmp___9) {
        _clr_fwstate_(pmlmepriv, 64);
        set_fwstate(pmlmepriv, 32);
      } else {

      }
    }
  } else {

  }
  handle_tkip_countermeasure: ;
  if ((unsigned int )padapter->securitypriv.btkip_countermeasure == 1U) {
    cur_time = (u32 )jiffies;
    if ((unsigned long )cur_time - padapter->securitypriv.btkip_countermeasure_time > 15000UL) {
      padapter->securitypriv.btkip_countermeasure = 0U;
      padapter->securitypriv.btkip_countermeasure_time = 0UL;
    } else {
      status = 0;
      goto release_mlme_lock;
    }
  } else {

  }
  memcpy((void *)(& pmlmepriv->assoc_ssid), (void const   *)(& newnetwork->network.Ssid),
           33UL);
  pmlmepriv->assoc_by_bssid = 0U;
  pmlmepriv->to_join = 1U;
  tmp___13 = check_fwstate(pmlmepriv, 2048);
  if (tmp___13) {
    tmp___14 = 0;
  } else {
    tmp___14 = 1;
  }
  if (tmp___14) {
    pmlmepriv->cur_network.join_res = -2;
    status = rtw_do_join_network(padapter, newnetwork);
    if (status == 1) {
      pmlmepriv->to_join = 0U;
    } else {
      tmp___12 = check_fwstate(pmlmepriv, 32);
      if ((int )tmp___12) {
        status = rtw_do_join_adhoc(padapter);
        if (status != 1) {
          goto release_mlme_lock;
        } else {

        }
      } else {
        _clr_fwstate_(pmlmepriv, 128);
        status = 0;
        pmlmepriv->to_join = 0U;
      }
    }
  } else {

  }
  release_mlme_lock: 
  spin_unlock_bh(& pmlmepriv->lock);
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(131072, 4, "-%s: status =%d\n", "rtw_set_ssid", status);
  } else {

  }
  return (status);
}
}
static int cfg80211_rtw_connect(struct wiphy *wiphy , struct net_device *ndev , struct cfg80211_connect_params *sme ) 
{ 
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct wlan_network *pnetwork ;
  u8 matched ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct rtw_queue *queue ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  struct list_head  const  *__mptr ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct rtw_wep_key wep_key ;
  u8 wep_key_idx ;
  u8 wep_key_len ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  ret = 0;
  pnetwork = (struct wlan_network *)0;
  matched = 0U;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  queue = & pmlmepriv->scanned_queue;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: =>%s(%s)\n", "cfg80211_rtw_connect", (char *)(& ndev->name));
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: privacy =%d, key =%p, key_len =%d, key_idx =%d\n", (int )sme->privacy,
           sme->key, (int )sme->key_len, (int )sme->key_idx);
  } else {

  }
  tmp___0 = _rtw_pwr_wakeup23a(padapter, 2000U, "cfg80211_rtw_connect");
  if (tmp___0 == 0) {
    ret = -1;
    goto exit;
  } else {

  }
  tmp___1 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___1) {
    ret = -1;
    goto exit;
  } else {

  }
  if (((unsigned long )sme->ssid == (unsigned long )((u8 const   *)0U) || sme->ssid_len == 0UL) || sme->ssid_len > 32UL) {
    ret = -22;
    goto exit;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ssid =%s, len =%zu\n", sme->ssid, sme->ssid_len);
  } else {

  }
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: bssid=%pM\n", sme->bssid);
    } else {

    }
  } else {

  }
  tmp___2 = check_fwstate(pmlmepriv, 128);
  if ((int )tmp___2) {
    ret = -16;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, fw_state = 0x%x, goto exit\n", "cfg80211_rtw_connect",
             pmlmepriv->fw_state);
    } else {

    }
    goto exit;
  } else {

  }
  tmp___3 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___3) {
    rtw_scan_abort23a(padapter);
  } else {

  }
  spin_lock_bh(& queue->lock);
  phead = get_list_head(queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53594;
  ldv_53593: 
  __mptr = (struct list_head  const  *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
    tmp___4 = ether_addr_equal((u8 const   *)(& pnetwork->network.MacAddress), sme->bssid);
    if (tmp___4) {
      tmp___5 = 0;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      goto ldv_53591;
    } else {

    }
  } else {

  }
  if ((unsigned long )sme->ssid != (unsigned long )((u8 const   *)0U) && sme->ssid_len != 0UL) {
    if ((size_t )pnetwork->network.Ssid.ssid_len != sme->ssid_len) {
      goto ldv_53591;
    } else {
      tmp___6 = memcmp((void const   *)(& pnetwork->network.Ssid.ssid), (void const   *)sme->ssid,
                       sme->ssid_len);
      if (tmp___6 != 0) {
        goto ldv_53591;
      } else {

      }
    }
  } else {

  }
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
    tmp___7 = ether_addr_equal((u8 const   *)(& pnetwork->network.MacAddress), sme->bssid);
    if ((int )tmp___7) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: matched by bssid\n");
      } else {

      }
      matched = 1U;
      goto ldv_53592;
    } else {

    }
  } else
  if ((unsigned long )sme->ssid != (unsigned long )((u8 const   *)0U) && sme->ssid_len != 0UL) {
    tmp___8 = memcmp((void const   *)(& pnetwork->network.Ssid.ssid), (void const   *)sme->ssid,
                     sme->ssid_len);
    if (tmp___8 == 0 && (size_t )pnetwork->network.Ssid.ssid_len == sme->ssid_len) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: matched by ssid\n");
      } else {

      }
      matched = 1U;
      goto ldv_53592;
    } else {

    }
  } else {

  }
  ldv_53591: 
  plist = ptmp;
  ptmp = plist->next;
  ldv_53594: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53593;
  } else {

  }
  ldv_53592: 
  spin_unlock_bh(& queue->lock);
  if ((unsigned int )matched == 0U || (unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
    ret = -2;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: connect, matched == false, goto exit\n");
    } else {

    }
    goto exit;
  } else {

  }
  tmp___9 = cfg80211_infrastructure_mode(padapter, pnetwork->network.ifmode);
  if (tmp___9 != 1) {
    ret = -1;
    goto exit;
  } else {

  }
  psecuritypriv->ndisencryptstatus = 1U;
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
  psecuritypriv->dot118021XGrpPrivacy = 0U;
  psecuritypriv->dot11AuthAlgrthm = 0U;
  psecuritypriv->ndisauthtype = 0U;
  ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
  if (ret < 0) {
    goto exit;
  } else {

  }
  ret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);
  if (ret < 0) {
    goto exit;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ie_len =%zu\n", "cfg80211_rtw_connect", sme->ie_len);
  } else {

  }
  ret = rtw_cfg80211_set_wpa_ie(padapter, sme->ie, sme->ie_len);
  if (ret < 0) {
    goto exit;
  } else {

  }
  if (sme->crypto.n_ciphers_pairwise != 0) {
    ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0],
                                  1);
    if (ret < 0) {
      goto exit;
    } else {

    }
  } else {

  }
  if ((psecuritypriv->dot11AuthAlgrthm == 1U || psecuritypriv->dot11AuthAlgrthm == 3U) && (unsigned long )sme->key != (unsigned long )((u8 const   *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): Shared/Auto WEP\n", "cfg80211_rtw_connect");
    } else {

    }
    wep_key_idx = sme->key_idx;
    wep_key_len = sme->key_len;
    if (((unsigned int )wep_key_idx > 4U || (unsigned int )wep_key_len == 0U) || (unsigned int )wep_key_len > 13U) {
      ret = -22;
      goto exit;
    } else {

    }
    wep_key_len = (unsigned int )wep_key_len <= 5U ? 5U : 13U;
    memset((void *)(& wep_key), 0, 16UL);
    wep_key.keylen = (u16 )wep_key_len;
    if ((unsigned int )wep_key_len == 13U) {
      padapter->securitypriv.dot11PrivacyAlgrthm = 1027077U;
      padapter->securitypriv.dot118021XGrpPrivacy = 1027077U;
    } else {
      padapter->securitypriv.dot11PrivacyAlgrthm = 1027073U;
      padapter->securitypriv.dot118021XGrpPrivacy = 1027073U;
    }
    memcpy((void *)(& wep_key.key), (void const   *)sme->key, (size_t )wep_key.keylen);
    tmp___10 = rtw_cfg80211_add_wep(padapter, & wep_key, (int )wep_key_idx);
    if (tmp___10 != 1) {
      ret = -95;
    } else {

    }
    if (ret < 0) {
      goto exit;
    } else {

    }
  } else {

  }
  ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, 0);
  if (ret < 0) {
    goto exit;
  } else {

  }
  if (sme->crypto.n_akm_suites != 0) {
    ret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);
    if (ret < 0) {
      goto exit;
    } else {

    }
  } else {

  }
  if (psecuritypriv->ndisauthtype > 3U) {
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else {

  }
  tmp___11 = rtw_set_auth23a(padapter, psecuritypriv);
  if (tmp___11 != 1) {
    ret = -16;
    goto exit;
  } else {

  }
  tmp___12 = rtw_set_ssid(padapter, pnetwork);
  if (tmp___12 != 1) {
    ret = -16;
    goto exit;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: set ssid:dot11AuthAlgrthm =%d, dot11PrivacyAlgrthm =%d, dot118021XGrpPrivacy =%d\n",
           psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);
  } else {

  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: <=%s, ret %d\n", "cfg80211_rtw_connect", ret);
  } else {

  }
  return (ret);
}
}
static int cfg80211_rtw_disconnect(struct wiphy *wiphy , struct net_device *ndev ,
                                   u16 reason_code ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  bool tmp___0 ;

  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_disconnect", (char *)(& ndev->name));
  } else {

  }
  rtw_set_roaming(padapter, 0);
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp___0) {
    rtw_scan_abort23a(padapter);
    LeaveAllPowerSaveMode23a(padapter);
    rtw_disassoc_cmd23a(padapter, 500U, 0);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s...call rtw_indicate_disconnect23a\n", "cfg80211_rtw_disconnect");
    } else {

    }
    padapter->mlmepriv.not_indic_disco = 1U;
    rtw_indicate_disconnect23a(padapter);
    padapter->mlmepriv.not_indic_disco = 0U;
    rtw_free_assoc_resources23a(padapter, 1);
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_set_txpower(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                    enum nl80211_tx_power_setting type , int mbm ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_set_txpower");
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_get_txpower(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                    int *dbm ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_get_txpower");
  } else {

  }
  *dbm = 12;
  return (0);
}
}
static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy , struct net_device *ndev ,
                                       bool enabled , int timeout ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct rtw_wdev_priv *rtw_wdev_priv ;
  void *tmp___0 ;

  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
  rtw_wdev_priv = (struct rtw_wdev_priv *)tmp___0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): enabled:%u, timeout:%d\n", "cfg80211_rtw_set_power_mgmt",
           (char *)(& ndev->name), (int )enabled, timeout);
  } else {

  }
  rtw_wdev_priv->power_mgmt = enabled;
  if (! enabled) {
    LPS_Leave23a(padapter);
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy , struct net_device *netdev ,
                                  struct cfg80211_pmksa *pmksa ) 
{ 
  u8 index ;
  u8 blInserted ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  blInserted = 0U;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_set_pmksa", (char *)(& netdev->name));
  } else {

  }
  tmp___0 = is_zero_ether_addr(pmksa->bssid);
  if ((int )tmp___0) {
    return (-22);
  } else {

  }
  blInserted = 0U;
  index = 0U;
  goto ldv_53643;
  ldv_53642: 
  tmp___1 = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[(int )index].Bssid),
                             pmksa->bssid);
  if ((int )tmp___1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s):  BSSID exists in the PMKList.\n", "cfg80211_rtw_set_pmksa",
             (char *)(& netdev->name));
    } else {

    }
    memcpy((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID), (void const   *)pmksa->pmkid,
             16UL);
    psecuritypriv->PMKIDList[(int )index].bUsed = 1U;
    psecuritypriv->PMKIDIndex = (unsigned int )index + 1U;
    blInserted = 1U;
    goto ldv_53641;
  } else {

  }
  index = (u8 )((int )index + 1);
  ldv_53643: ;
  if ((unsigned int )index <= 15U) {
    goto ldv_53642;
  } else {

  }
  ldv_53641: ;
  if ((unsigned int )blInserted == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): Use new entry index = %d for this PMKID\n", "cfg80211_rtw_set_pmksa",
             (char *)(& netdev->name), (int )psecuritypriv->PMKIDIndex);
    } else {

    }
    ether_addr_copy((u8 *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].Bssid),
                    pmksa->bssid);
    memcpy((void *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].PMKID),
             (void const   *)pmksa->pmkid, 16UL);
    psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].bUsed = 1U;
    psecuritypriv->PMKIDIndex = (u8 )((int )psecuritypriv->PMKIDIndex + 1);
    if ((unsigned int )psecuritypriv->PMKIDIndex == 16U) {
      psecuritypriv->PMKIDIndex = 0U;
    } else {

    }
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy , struct net_device *netdev ,
                                  struct cfg80211_pmksa *pmksa ) 
{ 
  u8 index ;
  u8 bMatched ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;

  {
  bMatched = 0U;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_del_pmksa", (char *)(& netdev->name));
  } else {

  }
  index = 0U;
  goto ldv_53656;
  ldv_53655: 
  tmp___0 = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[(int )index].Bssid),
                             pmksa->bssid);
  if ((int )tmp___0) {
    eth_zero_addr((u8 *)(& psecuritypriv->PMKIDList[(int )index].Bssid));
    memset((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID), 0, 16UL);
    psecuritypriv->PMKIDList[(int )index].bUsed = 0U;
    bMatched = 1U;
    goto ldv_53654;
  } else {

  }
  index = (u8 )((int )index + 1);
  ldv_53656: ;
  if ((unsigned int )index <= 15U) {
    goto ldv_53655;
  } else {

  }
  ldv_53654: ;
  if ((unsigned int )bMatched == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): do not have matched BSSID\n", "cfg80211_rtw_del_pmksa",
             (char *)(& netdev->name));
    } else {

    }
    return (-22);
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy , struct net_device *netdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_flush_pmksa", (char *)(& netdev->name));
  } else {

  }
  memset((void *)(& psecuritypriv->PMKIDList), 0, 1152UL);
  psecuritypriv->PMKIDIndex = 0U;
  return (0);
}
}
void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter , u8 *pmgmt_frame ,
                                     uint frame_len ) 
{ 
  s32 freq ;
  int channel ;
  struct mlme_ext_priv *pmlmeext ;
  struct net_device *ndev ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  ndev = padapter->pnetdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p,%s)\n", "rtw_cfg80211_indicate_sta_assoc",
           padapter, (char *)(& ndev->name));
  } else {

  }
  channel = (int )pmlmeext->cur_channel;
  if (channel <= 14) {
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
  cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const   *)pmgmt_frame, (size_t )frame_len,
                   0U);
  return;
}
}
void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter , unsigned char *da ,
                                        unsigned short reason ) 
{ 
  s32 freq ;
  int channel ;
  uint frame_len ;
  struct ieee80211_mgmt mgmt ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct net_device *ndev ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ndev = padapter->pnetdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p,%s)\n", "rtw_cfg80211_indicate_sta_disassoc",
           padapter, (char *)(& ndev->name));
  } else {

  }
  memset((void *)(& mgmt), 0, 36UL);
  channel = (int )pmlmeext->cur_channel;
  if (channel <= 14) {
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
  mgmt.frame_control = 192U;
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& mgmt.da), (u8 const   *)tmp);
  ether_addr_copy((u8 *)(& mgmt.sa), (u8 const   *)da);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& mgmt.bssid), (u8 const   *)tmp___0);
  mgmt.seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  mgmt.u.disassoc.reason_code = reason;
  frame_len = 26U;
  cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const   *)(& mgmt), (size_t )frame_len,
                   0U);
  return;
}
}
static int rtw_cfg80211_monitor_if_open(struct net_device *ndev ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_open");
  } else {

  }
  return (0);
}
}
static int rtw_cfg80211_monitor_if_close(struct net_device *ndev ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_close");
  } else {

  }
  return (0);
}
}
static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb , struct net_device *ndev ) 
{ 
  int ret ;
  int rtap_len ;
  int qos_len ;
  int dot11_hdr_len ;
  int snap_len ;
  unsigned char *pdata ;
  unsigned char src_mac_addr[6U] ;
  unsigned char dst_mac_addr[6U] ;
  struct ieee80211_hdr *dot11_hdr ;
  struct ieee80211_radiotap_header *rtap_hdr ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u32 len ;
  u8 category ;
  u8 action ;
  int tmp___5 ;
  int tmp___6 ;

  {
  ret = 0;
  qos_len = 0;
  dot11_hdr_len = 24;
  snap_len = 6;
  tmp = netdev_priv((struct net_device  const  *)ndev);
  padapter = (struct rtw_adapter *)tmp;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "rtw_cfg80211_monitor_if_xmit_entry", (char *)(& ndev->name));
  } else {

  }
  tmp___0 = ldv__builtin_expect(skb->len <= 7U, 0L);
  if (tmp___0 != 0L) {
    goto fail;
  } else {

  }
  rtap_hdr = (struct ieee80211_radiotap_header *)skb->data;
  tmp___1 = ldv__builtin_expect((unsigned int )rtap_hdr->it_version != 0U, 0L);
  if (tmp___1 != 0L) {
    goto fail;
  } else {

  }
  rtap_len = ieee80211_get_radiotap_len(skb->data);
  tmp___2 = ldv__builtin_expect(skb->len < (unsigned int )rtap_len, 0L);
  if (tmp___2 != 0L) {
    goto fail;
  } else {

  }
  if (rtap_len != 14) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: radiotap len (should be 14): %d\n", rtap_len);
    } else {

    }
    goto fail;
  } else {

  }
  skb_pull(skb, (unsigned int )rtap_len);
  dot11_hdr = (struct ieee80211_hdr *)skb->data;
  tmp___6 = ieee80211_is_data((int )dot11_hdr->frame_control);
  if (tmp___6 != 0) {
    tmp___3 = ieee80211_is_data_qos((int )dot11_hdr->frame_control);
    if (tmp___3 != 0) {
      qos_len = 2;
    } else {

    }
    tmp___4 = ieee80211_has_a4((int )dot11_hdr->frame_control);
    if (tmp___4 != 0) {
      dot11_hdr_len = dot11_hdr_len + 6;
    } else {

    }
    memcpy((void *)(& dst_mac_addr), (void const   *)(& dot11_hdr->addr1), 6UL);
    memcpy((void *)(& src_mac_addr), (void const   *)(& dot11_hdr->addr2), 6UL);
    skb_pull(skb, (unsigned int )(((dot11_hdr_len + qos_len) + snap_len) + -12));
    pdata = skb->data;
    ether_addr_copy(pdata, (u8 const   *)(& dst_mac_addr));
    ether_addr_copy(pdata + 6U, (u8 const   *)(& src_mac_addr));
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: should be eapol packet\n");
    } else {

    }
    ret = rtw_xmit23a_entry23a(skb, padapter->pnetdev);
    return (ret);
  } else {
    tmp___5 = ieee80211_is_action((int )dot11_hdr->frame_control);
    if (tmp___5 != 0) {
      pxmitpriv = & padapter->xmitpriv;
      pmlmeext = & padapter->mlmeextpriv;
      len = skb->len;
      mgmt = (struct ieee80211_mgmt *)dot11_hdr;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: RTW_Tx:da=%pM via %s(%s)\n", (u8 *)(& mgmt->da), "rtw_cfg80211_monitor_if_xmit_entry",
               (char *)(& ndev->name));
      } else {

      }
      category = mgmt->u.action.category;
      action = mgmt->u.action.u.wme_action.action_code;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: RTW_Tx:category(%u), action(%u)\n", (int )category,
               (int )action);
      } else {

      }
      pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
      if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
        goto fail;
      } else {

      }
      pattrib = & pmgntframe->attrib;
      update_mgntframe_attrib23a(padapter, pattrib);
      pattrib->retry_ctrl = 0U;
      memset((void *)pmgntframe->buf_addr, 0, 104UL);
      pframe = pmgntframe->buf_addr + 40U;
      memcpy((void *)pframe, (void const   *)skb->data, (size_t )len);
      pattrib->pktlen = len;
      pmlmeext->mgnt_seq = (u16 )((int )dot11_hdr->seq_ctrl >> 4);
      pattrib->seqnum = pmlmeext->mgnt_seq;
      pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
      pattrib->last_txcmdsz = pattrib->pktlen;
      dump_mgntframe23a(padapter, pmgntframe);
    } else {

    }
  }
  fail: 
  consume_skb(skb);
  return (0);
}
}
static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev , void *addr ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_set_mac_address");
  } else {

  }
  return (0);
}
}
static struct net_device_ops  const  rtw_cfg80211_monitor_if_ops  = 
     {0, 0, & rtw_cfg80211_monitor_if_open, & rtw_cfg80211_monitor_if_close, (netdev_tx_t (*)(struct sk_buff * ,
                                                                                            struct net_device * ))(& rtw_cfg80211_monitor_if_xmit_entry),
    0, 0, 0, & rtw_cfg80211_monitor_if_set_mac_address, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static int rtw_cfg80211_add_monitor_if(struct rtw_adapter *padapter , char *name ,
                                       unsigned char name_assign_type , struct net_device **ndev ) 
{ 
  int ret ;
  struct net_device *mon_ndev ;
  struct wireless_dev *mon_wdev ;
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  void *tmp___0 ;
  struct net_device *tmp___1 ;

  {
  ret = 0;
  mon_ndev = (struct net_device *)0;
  mon_wdev = (struct wireless_dev *)0;
  tmp = wdev_priv___1(padapter->rtw_wdev);
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
  if ((unsigned long )name == (unsigned long )((char *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): without specific name\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
    ret = -22;
    goto out;
  } else {

  }
  if ((unsigned long )pwdev_priv->pmon_ndev != (unsigned long )((struct net_device *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): monitor interface exist: %s\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name), (char *)(& (pwdev_priv->pmon_ndev)->name));
    } else {

    }
    ret = -16;
    goto out;
  } else {

  }
  mon_ndev = alloc_etherdev_mqs(16776, 1U, 1U);
  if ((unsigned long )mon_ndev == (unsigned long )((struct net_device *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): allocate ndev fail\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
    ret = -12;
    goto out;
  } else {

  }
  mon_ndev->type = 803U;
  strncpy((char *)(& mon_ndev->name), (char const   *)name, 16UL);
  mon_ndev->name[15] = 0;
  mon_ndev->name_assign_type = name_assign_type;
  mon_ndev->destructor = & rtw_ndev_destructor;
  mon_ndev->netdev_ops = & rtw_cfg80211_monitor_if_ops;
  tmp___0 = kzalloc(976UL, 208U);
  mon_wdev = (struct wireless_dev *)tmp___0;
  if ((unsigned long )mon_wdev == (unsigned long )((struct wireless_dev *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): allocate mon_wdev fail\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
    ret = -12;
    goto out;
  } else {

  }
  mon_wdev->wiphy = (padapter->rtw_wdev)->wiphy;
  mon_wdev->netdev = mon_ndev;
  mon_wdev->iftype = 6;
  mon_ndev->ieee80211_ptr = mon_wdev;
  ret = register_netdevice(mon_ndev);
  if (ret != 0) {
    goto out;
  } else {

  }
  tmp___1 = mon_ndev;
  pwdev_priv->pmon_ndev = tmp___1;
  *ndev = tmp___1;
  memcpy((void *)(& pwdev_priv->ifname_mon), (void const   *)name, 17UL);
  out: ;
  if (ret != 0) {
    kfree((void const   *)mon_wdev);
    mon_wdev = (struct wireless_dev *)0;
  } else {

  }
  if (ret != 0 && (unsigned long )mon_ndev != (unsigned long )((struct net_device *)0)) {
    ldv_free_netdev_626(mon_ndev);
    mon_ndev = (struct net_device *)0;
    *ndev = mon_ndev;
  } else {

  }
  return (ret);
}
}
static struct wireless_dev *cfg80211_rtw_add_virtual_intf(struct wiphy *wiphy , char const   *name ,
                                                          unsigned char name_assign_type ,
                                                          enum nl80211_iftype type ,
                                                          u32 *flags , struct vif_params *params ) 
{ 
  int ret ;
  struct net_device *ndev ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  struct wireless_dev *tmp___2 ;

  {
  ret = 0;
  ndev = (struct net_device *)0;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = wiphy_name((struct wiphy  const  *)wiphy);
    printk("\016RTL8723AU: %s(%s): wiphy:%s, name:%s, type:%d\n", "cfg80211_rtw_add_virtual_intf",
           (char *)(& (padapter->pnetdev)->name), tmp___0, name, (unsigned int )type);
  } else {

  }
  switch ((unsigned int )type) {
  case 1U: ;
  case 4U: ;
  case 5U: ;
  case 7U: 
  ret = -19;
  goto ldv_53755;
  case 6U: 
  ret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, (int )name_assign_type,
                                    & ndev);
  goto ldv_53755;
  case 8U: ;
  case 2U: 
  ret = -19;
  goto ldv_53755;
  case 9U: ;
  case 3U: 
  ret = -19;
  goto ldv_53755;
  default: 
  ret = -19;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Unsupported interface type\n");
  } else {

  }
  goto ldv_53755;
  }
  ldv_53755: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): ndev:%p, ret:%d\n", "cfg80211_rtw_add_virtual_intf",
           (char *)(& (padapter->pnetdev)->name), ndev, ret);
  } else {

  }
  if ((unsigned long )ndev != (unsigned long )((struct net_device *)0)) {
    tmp___2 = ndev->ieee80211_ptr;
  } else {
    tmp___1 = ERR_PTR((long )ret);
    tmp___2 = (struct wireless_dev *)tmp___1;
  }
  return (tmp___2);
}
}
static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy , struct wireless_dev *wdev ) 
{ 
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  struct net_device *ndev ;

  {
  tmp = wiphy_priv___1(wiphy);
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
  ndev = (unsigned long )wdev != (unsigned long )((struct wireless_dev *)0) ? wdev->netdev : (struct net_device *)0;
  if ((unsigned long )ndev == (unsigned long )((struct net_device *)0)) {
    goto exit;
  } else {

  }
  unregister_netdevice(ndev);
  if ((unsigned long )pwdev_priv->pmon_ndev == (unsigned long )ndev) {
    pwdev_priv->pmon_ndev = (struct net_device *)0;
    pwdev_priv->ifname_mon[0] = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): remove monitor interface\n", "cfg80211_rtw_del_virtual_intf",
             (char *)(& ndev->name));
    } else {

    }
  } else {

  }
  exit: ;
  return (0);
}
}
static int rtw_add_beacon(struct rtw_adapter *adapter , u8 const   *head , size_t head_len ,
                          u8 const   *tail , size_t tail_len ) 
{ 
  int ret ;
  u8 *pbuf ;
  uint len ;
  uint ielen ;
  uint wps_ielen ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *bss ;
  struct ieee80211_mgmt  const  *mgmt ;
  struct ieee80211_mgmt *tmpmgmt ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u8 const   *tmp___2 ;
  int tmp___3 ;

  {
  ret = 0;
  wps_ielen = 0U;
  pmlmepriv = & adapter->mlmepriv;
  bss = & pmlmepriv->cur_network.network;
  mgmt = (struct ieee80211_mgmt  const  *)head;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s beacon_head_len =%zu, beacon_tail_len =%zu\n", "rtw_add_beacon",
           head_len, tail_len);
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 16);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (-22);
  } else {

  }
  if (head_len <= 35UL) {
    return (-22);
  } else {

  }
  tmp___1 = kzalloc(head_len + tail_len, 208U);
  pbuf = (u8 *)tmp___1;
  if ((unsigned long )pbuf == (unsigned long )((u8 *)0U)) {
    return (-12);
  } else {

  }
  tmpmgmt = (struct ieee80211_mgmt *)pbuf;
  bss->beacon_interval = get_unaligned_le16((void const   *)(& mgmt->u.beacon.beacon_int));
  bss->capability = get_unaligned_le16((void const   *)(& mgmt->u.beacon.capab_info));
  bss->tsf = get_unaligned_le64((void const   *)(& mgmt->u.beacon.timestamp));
  memcpy((void *)pbuf, (void const   *)head, head_len);
  memcpy((void *)(pbuf + head_len), (void const   *)tail, tail_len);
  len = (uint )head_len + (uint )tail_len;
  ielen = len - 36U;
  tmp___2 = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)(& tmpmgmt->u.beacon.variable),
                                    (int )ielen);
  if ((unsigned long )tmp___2 != (unsigned long )((u8 const   *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: add bcn, wps_ielen =%d\n", wps_ielen);
    } else {

    }
  } else {

  }
  rtw_ies_remove_ie23a((u8 *)(& tmpmgmt->u.beacon.variable), & ielen, 0U, 221, (u8 *)(& P2P_OUI23A),
                       4);
  rtw_ies_remove_ie23a((u8 *)(& tmpmgmt->u.beacon.variable), & ielen, 0U, 221, (u8 *)(& WFD_OUI23A),
                       4);
  len = ielen + 36U;
  tmp___3 = rtw_check_beacon_data23a(adapter, tmpmgmt, len);
  if (tmp___3 == 1) {
    ret = 0;
  } else {
    ret = -22;
  }
  kfree((void const   *)pbuf);
  return (ret);
}
}
static int cfg80211_rtw_start_ap(struct wiphy *wiphy , struct net_device *ndev , struct cfg80211_ap_settings *settings ) 
{ 
  int ret ;
  struct rtw_adapter *adapter ;
  void *tmp ;
  struct wlan_bssid_ex *pbss_network ;
  struct wlan_bssid_ex *pbss_network_ext ;

  {
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  adapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): hidden_ssid:%d, auth_type:%d\n", "cfg80211_rtw_start_ap",
           (char *)(& ndev->name), (unsigned int )settings->hidden_ssid, (unsigned int )settings->auth_type);
  } else {

  }
  ret = rtw_add_beacon(adapter, settings->beacon.head, settings->beacon.head_len,
                       settings->beacon.tail, settings->beacon.tail_len);
  adapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = (u8 )settings->hidden_ssid;
  if ((unsigned long )settings->ssid != (unsigned long )((u8 const   *)0U) && settings->ssid_len != 0UL) {
    pbss_network = & adapter->mlmepriv.cur_network.network;
    pbss_network_ext = & adapter->mlmeextpriv.mlmext_info.network;
    memcpy((void *)(& pbss_network->Ssid.ssid), (void const   *)settings->ssid,
             settings->ssid_len);
    pbss_network->Ssid.ssid_len = (u8 )settings->ssid_len;
    memcpy((void *)(& pbss_network_ext->Ssid.ssid), (void const   *)settings->ssid,
             settings->ssid_len);
    pbss_network_ext->Ssid.ssid_len = (u8 )settings->ssid_len;
  } else {

  }
  return (ret);
}
}
static int cfg80211_rtw_change_beacon(struct wiphy *wiphy , struct net_device *ndev ,
                                      struct cfg80211_beacon_data *info ) 
{ 
  int ret ;
  struct rtw_adapter *adapter ;
  void *tmp ;

  {
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  adapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_beacon", (char *)(& ndev->name));
  } else {

  }
  ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
  return (ret);
}
}
static int cfg80211_rtw_stop_ap(struct wiphy *wiphy , struct net_device *ndev ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_stop_ap", (char *)(& ndev->name));
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_add_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const   *mac , struct station_parameters *params ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_add_station", (char *)(& ndev->name));
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_del_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    struct station_del_parameters *params ) 
{ 
  u8 const   *mac ;
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 updated ;
  struct sta_info *psta ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  struct list_head  const  *__mptr ;
  bool tmp___3 ;

  {
  mac = params->mac;
  ret = 0;
  updated = 0U;
  tmp = netdev_priv((struct net_device  const  *)ndev);
  padapter = (struct rtw_adapter *)tmp;
  pmlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +%s(%s)\n", "cfg80211_rtw_del_station", (char *)(& ndev->name));
  } else {

  }
  tmp___0 = check_fwstate(pmlmepriv, 17);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, fw_state != FW_LINKED|WIFI_AP_STATE\n", "cfg80211_rtw_del_station");
    } else {

    }
    return (-22);
  } else {

  }
  if ((unsigned long )mac == (unsigned long )((u8 const   *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: flush all sta, and cam_entry\n");
    } else {

    }
    flush_all_cam_entry23a(padapter);
    ret = rtw_sta_flush23a(padapter);
    return (ret);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: free sta macaddr=%pM\n", mac);
  } else {

  }
  tmp___2 = is_broadcast_ether_addr(mac);
  if ((int )tmp___2) {
    return (-22);
  } else {

  }
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_53837;
  ldv_53836: 
  __mptr = (struct list_head  const  *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
  tmp___3 = ether_addr_equal(mac, (u8 const   *)(& psta->hwaddr));
  if ((int )tmp___3) {
    if (psta->dot8021xalg == 1 && (unsigned int )psta->bpairwise_key_installed == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s, sta\'s dot8021xalg = 1 and key_installed = false\n",
               "cfg80211_rtw_del_station");
      } else {

      }
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: free psta =%p, aid =%d\n", psta, psta->aid);
      } else {

      }
      list_del_init(& psta->asoc_list);
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
      updated = ap_free_sta23a(padapter, psta, 1, 3);
      psta = (struct sta_info *)0;
      goto ldv_53835;
    }
  } else {

  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_53837: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_53836;
  } else {

  }
  ldv_53835: 
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  associated_clients_update23a(padapter, (int )updated);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -%s(%s)\n", "cfg80211_rtw_del_station", (char *)(& ndev->name));
  } else {

  }
  return (ret);
}
}
static int cfg80211_rtw_change_station(struct wiphy *wiphy , struct net_device *ndev ,
                                       u8 const   *mac , struct station_parameters *params ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_station", (char *)(& ndev->name));
  } else {

  }
  return (0);
}
}
static int cfg80211_rtw_dump_station(struct wiphy *wiphy , struct net_device *ndev ,
                                     int idx , u8 *mac , struct station_info *sinfo ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_dump_station", (char *)(& ndev->name));
  } else {

  }
  return (-2);
}
}
static int cfg80211_rtw_change_bss(struct wiphy *wiphy , struct net_device *ndev ,
                                   struct bss_parameters *params ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_bss", (char *)(& ndev->name));
  } else {

  }
  return (0);
}
}
static int _cfg80211_rtw_mgmt_tx(struct rtw_adapter *padapter , u8 tx_ch , u8 const   *buf ,
                                 size_t len ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  int ret ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u8 tmp___2 ;

  {
  ret = 0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  tmp = _rtw_pwr_wakeup23a(padapter, 2000U, "_cfg80211_rtw_mgmt_tx");
  if (tmp == 0) {
    ret = -14;
    goto exit;
  } else {

  }
  rtw_set_scan_deny(padapter, 1000U);
  rtw_scan_abort23a(padapter);
  tmp___2 = rtw_get_oper_ch23a(padapter);
  if ((int )tmp___2 != (int )tx_ch) {
    tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      pmlmeext->cur_channel = tx_ch;
    } else {

    }
    set_channel_bwmode23a(padapter, (int )tx_ch, 0, 0);
  } else {

  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    ret = 0;
    goto exit;
  } else {

  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->retry_ctrl = 0U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  memcpy((void *)pframe, (void const   *)buf, len);
  pattrib->pktlen = (u32 )len;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pmlmeext->mgnt_seq = (u16 )((int )pwlanhdr->seq_ctrl >> 4);
  pattrib->seqnum = pmlmeext->mgnt_seq;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pattrib->last_txcmdsz = pattrib->pktlen;
  ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  if (ret != 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, ack == false\n", "_cfg80211_rtw_mgmt_tx");
    } else {

    }
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ack == true\n", "_cfg80211_rtw_mgmt_tx");
  } else {

  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ret =%d\n", "_cfg80211_rtw_mgmt_tx", ret);
  } else {

  }
  return (ret);
}
}
static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                struct cfg80211_mgmt_tx_params *params , u64 *cookie ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  int ret ;
  int tx_ret ;
  u32 dump_limit ;
  u32 dump_cnt ;
  bool ack ;
  u8 category ;
  u8 action ;
  unsigned long start ;
  size_t len ;
  struct ieee80211_channel *chan ;
  u8 const   *buf ;
  struct ieee80211_mgmt *hdr ;
  u8 tx_ch ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  ret = 0;
  dump_limit = 8U;
  dump_cnt = 0U;
  ack = 1;
  start = jiffies;
  len = params->len;
  chan = params->chan;
  buf = params->buf;
  hdr = (struct ieee80211_mgmt *)buf;
  tmp___0 = ieee80211_frequency_to_channel((int )chan->center_freq);
  tx_ch = (unsigned char )tmp___0;
  tmp___1 = ieee80211_is_action((int )hdr->frame_control);
  if (tmp___1 == 0) {
    return (-22);
  } else {

  }
  *cookie = (u64 )buf;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): len =%zu, ch =%d\n", "cfg80211_rtw_mgmt_tx", (char *)(& (padapter->pnetdev)->name),
           len, (int )tx_ch);
  } else {

  }
  cfg80211_mgmt_tx_status(padapter->rtw_wdev, *cookie, buf, len, (int )ack, 208U);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: RTW_Tx:tx_ch =%d, da =%pM\n", (int )tx_ch, (u8 *)(& hdr->da));
  } else {

  }
  category = hdr->u.action.category;
  action = hdr->u.action.u.wme_action.action_code;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: RTW_Tx:category(%u), action(%u)\n", (int )category, (int )action);
  } else {

  }
  ldv_53895: 
  dump_cnt = dump_cnt + 1U;
  tx_ret = _cfg80211_rtw_mgmt_tx(padapter, (int )tx_ch, buf, len);
  if (dump_cnt < dump_limit && tx_ret != 1) {
    goto ldv_53895;
  } else {

  }

  if (tx_ret != 1 || dump_cnt > 1U) {
    if (GlobalDebugLevel23A > 3U) {
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
      printk("\016RTL8723AU: %s(%s): %s (%d/%d) in %d ms\n", "cfg80211_rtw_mgmt_tx",
             (char *)(& (padapter->pnetdev)->name), tx_ret == 1 ? (char *)"OK" : (char *)"FAIL",
             dump_cnt, dump_limit, tmp___2);
    } else {

    }
  } else {

  }
  return (ret);
}
}
static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                             u16 frame_type , bool reg ) 
{ 


  {
  if ((unsigned int )frame_type != 64U) {
    return;
  } else {

  }
  return;
}
}
static struct cfg80211_ops rtw_cfg80211_ops  = 
     {0, 0, 0, & cfg80211_rtw_add_virtual_intf, & cfg80211_rtw_del_virtual_intf, & cfg80211_rtw_change_iface,
    & cfg80211_rtw_add_key, & cfg80211_rtw_get_key, & cfg80211_rtw_del_key, & cfg80211_rtw_set_default_key,
    0, & cfg80211_rtw_start_ap, & cfg80211_rtw_change_beacon, & cfg80211_rtw_stop_ap,
    & cfg80211_rtw_add_station, & cfg80211_rtw_del_station, & cfg80211_rtw_change_station,
    & cfg80211_rtw_get_station, & cfg80211_rtw_dump_station, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, & cfg80211_rtw_change_bss, 0, 0, 0, & cfg80211_rtw_scan, 0,
    0, 0, 0, & cfg80211_rtw_connect, & cfg80211_rtw_disconnect, & cfg80211_rtw_join_ibss,
    & cfg80211_rtw_leave_ibss, 0, & cfg80211_rtw_set_wiphy_params, & cfg80211_rtw_set_txpower,
    & cfg80211_rtw_get_txpower, 0, 0, 0, 0, 0, 0, & cfg80211_rtw_set_pmksa, & cfg80211_rtw_del_pmksa,
    & cfg80211_rtw_flush_pmksa, 0, 0, & cfg80211_rtw_mgmt_tx, 0, & cfg80211_rtw_set_power_mgmt,
    0, 0, & cfg80211_rtw_mgmt_frame_register, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap , enum ieee80211_band band ,
                                       u8 rf_type ) 
{ 


  {
  ht_cap->ht_supported = 1;
  ht_cap->cap = 6242U;
  ht_cap->ampdu_factor = 3U;
  ht_cap->ampdu_density = 7U;
  ht_cap->mcs.tx_params = 1U;
  if ((unsigned int )rf_type == 3U) {
    ht_cap->mcs.rx_mask[0] = 255U;
    ht_cap->mcs.rx_mask[1] = 0U;
    ht_cap->mcs.rx_mask[4] = 1U;
    ht_cap->mcs.rx_highest = 150U;
  } else
  if ((unsigned int )rf_type == 0U || (unsigned int )rf_type == 2U) {
    ht_cap->mcs.rx_mask[0] = 255U;
    ht_cap->mcs.rx_mask[1] = 255U;
    ht_cap->mcs.rx_mask[4] = 1U;
    ht_cap->mcs.rx_highest = 300U;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, error rf_type =%d\n", "rtw_cfg80211_init_ht_capab",
           (int )rf_type);
  } else {

  }
  return;
}
}
void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter ) 
{ 
  u8 rf_type ;
  struct ieee80211_supported_band *bands ;
  struct wireless_dev *pwdev ;
  struct wiphy *wiphy ;

  {
  pwdev = padapter->rtw_wdev;
  wiphy = pwdev->wiphy;
  rf_type = rtl8723a_get_rf_type(padapter);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s:rf_type =%d\n", "rtw_cfg80211_init_wiphy", (int )rf_type);
  } else {

  }
  bands = wiphy->bands[0];
  if ((unsigned long )bands != (unsigned long )((struct ieee80211_supported_band *)0)) {
    rtw_cfg80211_init_ht_capab(& bands->ht_cap, 0, (int )rf_type);
  } else {

  }
  bands = wiphy->bands[1];
  if ((unsigned long )bands != (unsigned long )((struct ieee80211_supported_band *)0)) {
    rtw_cfg80211_init_ht_capab(& bands->ht_cap, 1, (int )rf_type);
  } else {

  }
  return;
}
}
static void rtw_cfg80211_preinit_wiphy(struct rtw_adapter *padapter , struct wiphy *wiphy ) 
{ 


  {
  wiphy->signal_type = 1;
  wiphy->max_scan_ssids = 9U;
  wiphy->max_scan_ie_len = 2304U;
  wiphy->max_num_pmkids = 4U;
  wiphy->max_remain_on_channel_duration = 65535U;
  wiphy->interface_modes = 78U;
  wiphy->mgmt_stypes = (struct ieee80211_txrx_stypes  const  *)(& rtw_cfg80211_default_mgmt_stypes);
  wiphy->software_iftypes = (u16 )((unsigned int )wiphy->software_iftypes | 64U);
  wiphy->cipher_suites = (u32 const   *)(& rtw_cipher_suites);
  wiphy->n_cipher_suites = 4;
  wiphy->bands[0] = rtw_spt_band_alloc(0);
  wiphy->bands[1] = rtw_spt_band_alloc(1);
  wiphy->flags = wiphy->flags | 2097152U;
  wiphy->flags = wiphy->flags | 1179648U;
  if ((unsigned int )padapter->registrypriv.power_mgnt != 0U) {
    wiphy->flags = wiphy->flags | 16U;
  } else {
    wiphy->flags = wiphy->flags & 4294967279U;
  }
  return;
}
}
int rtw_wdev_alloc(struct rtw_adapter *padapter , struct device *dev ) 
{ 
  int ret ;
  struct wiphy *wiphy ;
  struct wireless_dev *wdev ;
  struct rtw_wdev_priv *pwdev_priv ;
  struct net_device *pnetdev ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;

  {
  ret = 0;
  pnetdev = padapter->pnetdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_wdev_alloc", padapter);
  } else {

  }
  wiphy = wiphy_new((struct cfg80211_ops  const  *)(& rtw_cfg80211_ops), 128);
  if ((unsigned long )wiphy == (unsigned long )((struct wiphy *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Couldn\'t allocate wiphy device\n");
    } else {

    }
    ret = -12;
    goto exit;
  } else {

  }
  tmp = kzalloc(976UL, 208U);
  wdev = (struct wireless_dev *)tmp;
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Couldn\'t allocate wireless device\n");
    } else {

    }
    ret = -12;
    goto free_wiphy;
  } else {

  }
  set_wiphy_dev(wiphy, dev);
  rtw_cfg80211_preinit_wiphy(padapter, wiphy);
  ret = wiphy_register(wiphy);
  if (ret < 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Couldn\'t register wiphy device\n");
    } else {

    }
    goto free_wdev;
  } else {

  }
  wdev->wiphy = wiphy;
  wdev->netdev = pnetdev;
  wdev->iftype = 6;
  padapter->rtw_wdev = wdev;
  pnetdev->ieee80211_ptr = wdev;
  tmp___0 = wdev_priv___1(wdev);
  pwdev_priv = (struct rtw_wdev_priv *)tmp___0;
  pwdev_priv->rtw_wdev = wdev;
  pwdev_priv->pmon_ndev = (struct net_device *)0;
  pwdev_priv->ifname_mon[0] = 0;
  pwdev_priv->padapter = padapter;
  pwdev_priv->scan_request = (struct cfg80211_scan_request *)0;
  spinlock_check(& pwdev_priv->scan_req_lock);
  __raw_spin_lock_init(& pwdev_priv->scan_req_lock.__annonCompField18.rlock, "&(&pwdev_priv->scan_req_lock)->rlock",
                       & __key);
  pwdev_priv->p2p_enabled = 0U;
  if ((unsigned int )padapter->registrypriv.power_mgnt != 0U) {
    pwdev_priv->power_mgmt = 1;
  } else {
    pwdev_priv->power_mgmt = 0;
  }
  return (ret);
  free_wdev: 
  kfree((void const   *)wdev);
  free_wiphy: 
  wiphy_free(wiphy);
  exit: ;
  return (ret);
}
}
void rtw_wdev_free(struct wireless_dev *wdev ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(wdev =%p)\n", "rtw_wdev_free", wdev);
  } else {

  }
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
    return;
  } else {

  }
  kfree((void const   *)(wdev->wiphy)->bands[0]);
  kfree((void const   *)(wdev->wiphy)->bands[1]);
  wiphy_free(wdev->wiphy);
  kfree((void const   *)wdev);
  return;
}
}
void rtw_wdev_unregister(struct wireless_dev *wdev ) 
{ 
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;

  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(wdev =%p)\n", "rtw_wdev_unregister", wdev);
  } else {

  }
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
    return;
  } else {

  }
  tmp = wdev_priv___1(wdev);
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
  rtw_cfg80211_indicate_scan_done(pwdev_priv, 1);
  if ((unsigned long )pwdev_priv->pmon_ndev != (unsigned long )((struct net_device *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, unregister monitor interface\n", "rtw_wdev_unregister");
    } else {

    }
    ldv_unregister_netdev_627(pwdev_priv->pmon_ndev);
  } else {

  }
  wiphy_unregister(wdev->wiphy);
  return;
}
}
int ldv_retval_0  ;
extern int ldv_release_16(void) ;
int ldv_retval_1  ;
extern int ldv_bind_16(void) ;
int ldv_retval_3  ;
extern int ldv_ndo_uninit_17(void) ;
extern int ldv_ndo_init_17(void) ;
void ldv_net_device_ops_17(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(3008UL);
  rtw_cfg80211_monitor_if_ops_group1 = (struct net_device *)tmp;
  return;
}
}
void ldv_initialize_cfg80211_ops_16(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  tmp = ldv_init_zalloc(976UL);
  rtw_cfg80211_ops_group0 = (struct wireless_dev *)tmp;
  tmp___0 = ldv_init_zalloc(16UL);
  rtw_cfg80211_ops_group2 = (struct cfg80211_pmksa *)tmp___0;
  tmp___1 = ldv_init_zalloc(3008UL);
  rtw_cfg80211_ops_group6 = (struct net_device *)tmp___1;
  tmp___2 = ldv_init_zalloc(1792UL);
  rtw_cfg80211_ops_group3 = (struct wiphy *)tmp___2;
  tmp___3 = ldv_init_zalloc(120UL);
  rtw_cfg80211_ops_group4 = (struct station_parameters *)tmp___3;
  tmp___4 = ldv_init_zalloc(12UL);
  rtw_cfg80211_ops_group5 = (struct vif_params *)tmp___4;
  tmp___5 = ldv_init_zalloc(840UL);
  rtw_cfg80211_ops_group1 = (struct station_info *)tmp___5;
  return;
}
}
void ldv_main_exported_16(void) 
{ 
  int ldvarg19 ;
  u8 *ldvarg22 ;
  void *tmp ;
  char *ldvarg25 ;
  void *tmp___0 ;
  u16 ldvarg17 ;
  u8 ldvarg21 ;
  u8 ldvarg30 ;
  struct cfg80211_ap_settings *ldvarg15 ;
  void *tmp___1 ;
  u8 *ldvarg27 ;
  void *tmp___2 ;
  u32 *ldvarg26 ;
  void *tmp___3 ;
  bool ldvarg45 ;
  u8 *ldvarg9 ;
  void *tmp___4 ;
  struct key_params *ldvarg40 ;
  void *tmp___5 ;
  int *ldvarg10 ;
  void *tmp___6 ;
  struct cfg80211_scan_request *ldvarg36 ;
  void *tmp___7 ;
  int ldvarg13 ;
  u8 *ldvarg8 ;
  void *tmp___8 ;
  struct cfg80211_ibss_params *ldvarg3 ;
  void *tmp___9 ;
  bool ldvarg41 ;
  void (*ldvarg31)(void * , struct key_params * ) ;
  bool ldvarg20 ;
  enum nl80211_iftype ldvarg39 ;
  struct bss_parameters *ldvarg2 ;
  void *tmp___10 ;
  void *ldvarg28 ;
  void *tmp___11 ;
  u8 ldvarg34 ;
  enum nl80211_tx_power_setting ldvarg14 ;
  u16 ldvarg4 ;
  bool ldvarg16 ;
  struct cfg80211_mgmt_tx_params *ldvarg6 ;
  void *tmp___12 ;
  bool ldvarg33 ;
  u64 *ldvarg5 ;
  void *tmp___13 ;
  u32 *ldvarg38 ;
  void *tmp___14 ;
  bool ldvarg35 ;
  unsigned char ldvarg24 ;
  int ldvarg44 ;
  bool ldvarg29 ;
  struct cfg80211_beacon_data *ldvarg37 ;
  void *tmp___15 ;
  struct cfg80211_connect_params *ldvarg12 ;
  void *tmp___16 ;
  u8 ldvarg42 ;
  u8 *ldvarg43 ;
  void *tmp___17 ;
  enum nl80211_iftype ldvarg23 ;
  u32 ldvarg7 ;
  u8 *ldvarg32 ;
  void *tmp___18 ;
  struct station_del_parameters *ldvarg11 ;
  void *tmp___19 ;
  u8 *ldvarg18 ;
  void *tmp___20 ;
  int tmp___21 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg22 = (u8 *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg25 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(232UL);
  ldvarg15 = (struct cfg80211_ap_settings *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg27 = (u8 *)tmp___2;
  tmp___3 = ldv_init_zalloc(4UL);
  ldvarg26 = (u32 *)tmp___3;
  tmp___4 = ldv_init_zalloc(1UL);
  ldvarg9 = (u8 *)tmp___4;
  tmp___5 = ldv_init_zalloc(32UL);
  ldvarg40 = (struct key_params *)tmp___5;
  tmp___6 = ldv_init_zalloc(4UL);
  ldvarg10 = (int *)tmp___6;
  tmp___7 = ldv_init_zalloc(104UL);
  ldvarg36 = (struct cfg80211_scan_request *)tmp___7;
  tmp___8 = ldv_init_zalloc(1UL);
  ldvarg8 = (u8 *)tmp___8;
  tmp___9 = ldv_init_zalloc(128UL);
  ldvarg3 = (struct cfg80211_ibss_params *)tmp___9;
  tmp___10 = ldv_init_zalloc(40UL);
  ldvarg2 = (struct bss_parameters *)tmp___10;
  tmp___11 = ldv_init_zalloc(1UL);
  ldvarg28 = tmp___11;
  tmp___12 = ldv_init_zalloc(48UL);
  ldvarg6 = (struct cfg80211_mgmt_tx_params *)tmp___12;
  tmp___13 = ldv_init_zalloc(8UL);
  ldvarg5 = (u64 *)tmp___13;
  tmp___14 = ldv_init_zalloc(4UL);
  ldvarg38 = (u32 *)tmp___14;
  tmp___15 = ldv_init_zalloc(96UL);
  ldvarg37 = (struct cfg80211_beacon_data *)tmp___15;
  tmp___16 = ldv_init_zalloc(232UL);
  ldvarg12 = (struct cfg80211_connect_params *)tmp___16;
  tmp___17 = ldv_init_zalloc(1UL);
  ldvarg43 = (u8 *)tmp___17;
  tmp___18 = ldv_init_zalloc(1UL);
  ldvarg32 = (u8 *)tmp___18;
  tmp___19 = ldv_init_zalloc(16UL);
  ldvarg11 = (struct station_del_parameters *)tmp___19;
  tmp___20 = ldv_init_zalloc(1UL);
  ldvarg18 = (u8 *)tmp___20;
  ldv_memset((void *)(& ldvarg19), 0, 4UL);
  ldv_memset((void *)(& ldvarg17), 0, 2UL);
  ldv_memset((void *)(& ldvarg21), 0, 1UL);
  ldv_memset((void *)(& ldvarg30), 0, 1UL);
  ldv_memset((void *)(& ldvarg45), 0, 1UL);
  ldv_memset((void *)(& ldvarg13), 0, 4UL);
  ldv_memset((void *)(& ldvarg41), 0, 1UL);
  ldv_memset((void *)(& ldvarg31), 0, 8UL);
  ldv_memset((void *)(& ldvarg20), 0, 1UL);
  ldv_memset((void *)(& ldvarg39), 0, 4UL);
  ldv_memset((void *)(& ldvarg34), 0, 1UL);
  ldv_memset((void *)(& ldvarg14), 0, 4UL);
  ldv_memset((void *)(& ldvarg4), 0, 2UL);
  ldv_memset((void *)(& ldvarg16), 0, 1UL);
  ldv_memset((void *)(& ldvarg33), 0, 1UL);
  ldv_memset((void *)(& ldvarg35), 0, 1UL);
  ldv_memset((void *)(& ldvarg24), 0, 1UL);
  ldv_memset((void *)(& ldvarg44), 0, 4UL);
  ldv_memset((void *)(& ldvarg29), 0, 1UL);
  ldv_memset((void *)(& ldvarg42), 0, 1UL);
  ldv_memset((void *)(& ldvarg23), 0, 4UL);
  ldv_memset((void *)(& ldvarg7), 0, 4UL);
  tmp___21 = __VERIFIER_nondet_int();
  switch (tmp___21) {
  case 0: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (int )ldvarg45, ldvarg44);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (int )ldvarg45, ldvarg44);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (int )ldvarg45, ldvarg44);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 1: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg42,
                         (int )ldvarg41, (u8 const   *)ldvarg43, ldvarg40);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg42,
                         (int )ldvarg41, (u8 const   *)ldvarg43, ldvarg40);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg42,
                         (int )ldvarg41, (u8 const   *)ldvarg43, ldvarg40);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 2: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg39,
                              ldvarg38, rtw_cfg80211_ops_group5);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg39,
                              ldvarg38, rtw_cfg80211_ops_group5);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg39,
                              ldvarg38, rtw_cfg80211_ops_group5);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 3: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg37);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg37);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg37);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 4: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_scan(rtw_cfg80211_ops_group3, ldvarg36);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_scan(rtw_cfg80211_ops_group3, ldvarg36);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_scan(rtw_cfg80211_ops_group3, ldvarg36);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 5: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                 (int )ldvarg34, (int )ldvarg33, (int )ldvarg35);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                 (int )ldvarg34, (int )ldvarg33, (int )ldvarg35);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                 (int )ldvarg34, (int )ldvarg33, (int )ldvarg35);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 6: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg30,
                         (int )ldvarg29, (u8 const   *)ldvarg32, ldvarg28, ldvarg31);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg30,
                         (int )ldvarg29, (u8 const   *)ldvarg32, ldvarg28, ldvarg31);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg30,
                         (int )ldvarg29, (u8 const   *)ldvarg32, ldvarg28, ldvarg31);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 7: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 8: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 9: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg27,
                             rtw_cfg80211_ops_group4);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg27,
                             rtw_cfg80211_ops_group4);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg27,
                             rtw_cfg80211_ops_group4);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 10: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group3, (char const   *)ldvarg25,
                                  (int )ldvarg24, ldvarg23, ldvarg26, rtw_cfg80211_ops_group5);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group3, (char const   *)ldvarg25,
                                  (int )ldvarg24, ldvarg23, ldvarg26, rtw_cfg80211_ops_group5);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group3, (char const   *)ldvarg25,
                                  (int )ldvarg24, ldvarg23, ldvarg26, rtw_cfg80211_ops_group5);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 11: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg21,
                         (int )ldvarg20, (u8 const   *)ldvarg22);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg21,
                         (int )ldvarg20, (u8 const   *)ldvarg22);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg21,
                         (int )ldvarg20, (u8 const   *)ldvarg22);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 12: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg19,
                              ldvarg18, rtw_cfg80211_ops_group1);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg19,
                              ldvarg18, rtw_cfg80211_ops_group1);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg19,
                              ldvarg18, rtw_cfg80211_ops_group1);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 13: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0,
                                     (int )ldvarg17, (int )ldvarg16);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0,
                                     (int )ldvarg17, (int )ldvarg16);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0,
                                     (int )ldvarg17, (int )ldvarg16);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 14: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg15);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg15);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg15);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 15: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg14,
                             ldvarg13);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg14,
                             ldvarg13);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg14,
                             ldvarg13);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 16: ;
  if (ldv_state_variable_16 == 2) {
    ldv_retval_3 = cfg80211_rtw_connect(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                        ldvarg12);
    if (ldv_retval_3 == 0) {
      ldv_state_variable_16 = 3;
    } else {

    }
  } else {

  }
  goto ldv_54016;
  case 17: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 18: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg11);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg11);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg11);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 19: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg10);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg10);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg10);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 20: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 21: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg9,
                             rtw_cfg80211_ops_group1);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg9,
                             rtw_cfg80211_ops_group1);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg9,
                             rtw_cfg80211_ops_group1);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 22: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg8, rtw_cfg80211_ops_group4);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg8, rtw_cfg80211_ops_group4);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg8, rtw_cfg80211_ops_group4);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 23: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group3, ldvarg7);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group3, ldvarg7);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group3, ldvarg7);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 24: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg6,
                         ldvarg5);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg6,
                         ldvarg5);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group0, ldvarg6,
                         ldvarg5);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 25: ;
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_disconnect(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, (int )ldvarg4);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 26: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group2);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 27: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg3);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg3);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg3);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 28: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg2);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg2);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6, ldvarg2);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 29: ;
  if (ldv_state_variable_16 == 1) {
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 3) {
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 3;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group3, rtw_cfg80211_ops_group6);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_54016;
  case 30: ;
  if (ldv_state_variable_16 == 2) {
    ldv_release_16();
    ldv_state_variable_16 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_54016;
  case 31: ;
  if (ldv_state_variable_16 == 1) {
    ldv_bind_16();
    ldv_state_variable_16 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_54016;
  default: 
  ldv_stop();
  }
  ldv_54016: ;
  return;
}
}
void ldv_main_exported_17(void) 
{ 
  void *ldvarg0 ;
  void *tmp ;
  struct sk_buff *ldvarg1 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg0 = tmp;
  tmp___0 = ldv_init_zalloc(232UL);
  ldvarg1 = (struct sk_buff *)tmp___0;
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_17 == 3) {
    rtw_cfg80211_monitor_if_close(rtw_cfg80211_monitor_if_ops_group1);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_54055;
  case 1: ;
  if (ldv_state_variable_17 == 2) {
    ldv_retval_1 = rtw_cfg80211_monitor_if_open(rtw_cfg80211_monitor_if_ops_group1);
    if (ldv_retval_1 == 0) {
      ldv_state_variable_17 = 3;
    } else {

    }
  } else {

  }
  goto ldv_54055;
  case 2: ;
  if (ldv_state_variable_17 == 3) {
    rtw_cfg80211_monitor_if_xmit_entry(ldvarg1, rtw_cfg80211_monitor_if_ops_group1);
    ldv_state_variable_17 = 3;
  } else {

  }
  goto ldv_54055;
  case 3: ;
  if (ldv_state_variable_17 == 1) {
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg0);
    ldv_state_variable_17 = 1;
  } else {

  }
  if (ldv_state_variable_17 == 3) {
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg0);
    ldv_state_variable_17 = 3;
  } else {

  }
  if (ldv_state_variable_17 == 2) {
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg0);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_54055;
  case 4: ;
  if (ldv_state_variable_17 == 1) {
    ldv_retval_0 = ldv_ndo_init_17();
    if (ldv_retval_0 == 0) {
      ldv_state_variable_17 = 2;
      usb_counter = usb_counter + 1;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_54055;
  case 5: ;
  if (ldv_state_variable_17 == 2) {
    ldv_ndo_uninit_17();
    ldv_state_variable_17 = 1;
    usb_counter = usb_counter - 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_54055;
  default: 
  ldv_stop();
  }
  ldv_54055: ;
  return;
}
}
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
  tmp = ldv_err_ptr(error);
  return (tmp);
}
}
bool ldv_queue_work_on_621(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_622(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_623(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_624(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_625(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_free_netdev_626(struct net_device *dev ) 
{ 


  {
  free_netdev(dev);
  ldv_state_variable_17 = 0;
  return;
}
}
void ldv_unregister_netdev_627(struct net_device *dev ) 
{ 


  {
  unregister_netdev(dev);
  ldv_state_variable_17 = 0;
  return;
}
}
bool ldv_queue_work_on_639(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_641(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_640(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_643(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_642(struct workqueue_struct *ldv_func_arg1 ) ;
extern void netif_carrier_off(struct net_device * ) ;
static struct rt_pmkid_list backupPMKIDList[16U]  ;
void rtw_reset_securitypriv23a(struct rtw_adapter *adapter ) 
{ 
  u8 backupPMKIDIndex ;
  u8 backupTKIPCountermeasure ;
  unsigned long backupTKIPcountermeasure_time ;
  struct security_priv *psec_priv ;

  {
  backupPMKIDIndex = 0U;
  backupTKIPCountermeasure = 0U;
  backupTKIPcountermeasure_time = 0UL;
  if (adapter->securitypriv.dot11AuthAlgrthm == 2U) {
    memcpy((void *)(& backupPMKIDList), (void const   *)(& adapter->securitypriv.PMKIDList),
             1152UL);
    backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
    backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
    backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
    memset((void *)(& adapter->securitypriv), 0, 4272UL);
    memcpy((void *)(& adapter->securitypriv.PMKIDList), (void const   *)(& backupPMKIDList),
             1152UL);
    adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
    adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
    adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
    adapter->securitypriv.ndisauthtype = 0U;
    adapter->securitypriv.ndisencryptstatus = 1U;
  } else {
    psec_priv = & adapter->securitypriv;
    psec_priv->dot11AuthAlgrthm = 0U;
    psec_priv->dot11PrivacyAlgrthm = 0U;
    psec_priv->dot11PrivacyKeyIndex = 0U;
    psec_priv->dot118021XGrpPrivacy = 0U;
    psec_priv->dot118021XGrpKeyid = 1U;
    psec_priv->ndisauthtype = 0U;
    psec_priv->ndisencryptstatus = 1U;
  }
  return;
}
}
void rtw_os_indicate_disconnect23a(struct rtw_adapter *adapter ) 
{ 


  {
  netif_carrier_off(adapter->pnetdev);
  rtw_cfg80211_indicate_disconnect(adapter);
  rtw_reset_securitypriv23a(adapter);
  return;
}
}
bool ldv_queue_work_on_639(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_640(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_641(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_642(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_643(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  return;
}
}
extern int snprintf(char * , size_t  , char const   *  , ...) ;
int ldv_mod_timer_658(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_667(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_668(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_669(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_670(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_659(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_660(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_661(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_662(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_663(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_664(struct timer_list *ldv_func_arg1 ) ;
bool ldv_queue_work_on_653(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_655(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_654(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_657(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_656(struct workqueue_struct *ldv_func_arg1 ) ;
struct net_device *rtw_netdev_ops_group1 ;
int ldv_state_variable_15 ;
void ldv_net_device_ops_15(void) ;
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
extern int dev_alloc_name(struct net_device * , char const   * ) ;
void ldv_free_netdev_666(struct net_device *dev ) ;
void ldv_free_netdev_671(struct net_device *dev ) ;
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
  return;
}
}
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
  i = 0U;
  goto ldv_42870;
  ldv_42869: 
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
  txq = tmp;
  netif_tx_start_queue(txq);
  i = i + 1U;
  ldv_42870: ;
  if (dev->num_tx_queues > i) {
    goto ldv_42869;
  } else {

  }

  return;
}
}
__inline static void netif_tx_wake_all_queues___0(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
  i = 0U;
  goto ldv_42883;
  ldv_42882: 
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
  txq = tmp;
  netif_tx_wake_queue(txq);
  i = i + 1U;
  ldv_42883: ;
  if (dev->num_tx_queues > i) {
    goto ldv_42882;
  } else {

  }

  return;
}
}
extern int register_netdev(struct net_device * ) ;
int ldv_register_netdev_665(struct net_device *dev ) ;
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  tmp = skb_network_header(skb);
  return ((struct iphdr *)tmp);
}
}
int netdev_open23a(struct net_device *pnetdev ) ;
int pm_netdev_open23a(struct net_device *pnetdev , u8 bnormal ) ;
int rtw_init_drv_sw23a(struct rtw_adapter *padapter ) ;
int rtw_free_drv_sw23a(struct rtw_adapter *padapter ) ;
int rtw_reset_drv_sw23a(struct rtw_adapter *padapter ) ;
int rtw_init_netdev23a_name23a(struct net_device *pnetdev , char const   *ifname___0 ) ;
struct net_device *rtw_init_netdev23a(struct rtw_adapter *old_padapter ) ;
u16 rtw_recv_select_queue23a(struct sk_buff *skb ) ;
void rtw_ips_dev_unload23a(struct rtw_adapter *padapter ) ;
int rtw_drv_register_netdev(struct rtw_adapter *if1 ) ;
void rtl8723a_usb_intf_stop(struct rtw_adapter *padapter ) ;
static int rtw_chip_version  ;
static int rtw_rfintfs  =    2;
static int rtw_debug  =    1;
static int rtw_channel  =    1;
static int rtw_wireless_mode  =    11;
static int rtw_vrtl_carrier_sense  =    2;
static int rtw_vcs_type  =    1;
static int rtw_rts_thresh  =    2347;
static int rtw_frag_thresh  =    2346;
static int rtw_preamble  =    1;
static int rtw_scan_mode  =    1;
static int rtw_adhoc_tx_pwr  =    1;
static int rtw_soft_ap  ;
static int rtw_power_mgnt  =    1;
static int rtw_ips_mode  =    1;
static int rtw_smart_ps  =    2;
static int rtw_long_retry_lmt  =    7;
static int rtw_short_retry_lmt  =    7;
static int rtw_busy_thresh  =    40;
static int rtw_ack_policy  =    0;
static int rtw_acm_method  ;
static int rtw_wmm_enable  =    1;
static int rtw_uapsd_enable  ;
static int rtw_ht_enable  =    1;
static int rtw_cbw40_enable  =    3;
static int rtw_ampdu_enable  =    1;
static int rtw_rx_stbc  =    1;
static int rtw_ampdu_amsdu  ;
static int rtw_lowrate_two_xmit  =    1;
static int rtw_rf_config  =    5;
static int rtw_low_power  ;
static int rtw_wifi_spec  ;
static int rtw_channel_plan  =    66;
static int rtw_btcoex_enable  =    1;
static int rtw_bt_iso  =    2;
static int rtw_bt_sco  =    3;
static int rtw_bt_ampdu  =    1;
static int rtw_AcceptAddbaReq  =    1;
static int rtw_antdiv_cfg  =    2;
static int rtw_antdiv_type  ;
static int rtw_hwpdn_mode  =    2;
static int rtw_hwpwrp_detect  ;
static int rtw_hw_wps_pbc  =    1;
static int rtw_80211d  ;
static int rtw_regulatory_id  =    255;
static char *ifname  =    (char *)"wlan%d";
static char *if2name  =    (char *)"wlan%d";
static uint rtw_max_roaming_times  =    2U;
static uint rtw_notch_filter  ;
static int netdev_close(struct net_device *pnetdev ) ;
static void loadparam(struct rtw_adapter *padapter , struct net_device *pnetdev ) 
{ 
  struct registry_priv *registry_par ;

  {
  registry_par = & padapter->registrypriv;
  GlobalDebugLevel23A = (u32 )rtw_debug;
  registry_par->chip_version = (unsigned char )rtw_chip_version;
  registry_par->rfintfs = (unsigned char )rtw_rfintfs;
  memcpy((void *)(& registry_par->ssid.ssid), (void const   *)"ANY", 3UL);
  registry_par->ssid.ssid_len = 3U;
  registry_par->channel = (unsigned char )rtw_channel;
  registry_par->wireless_mode = (unsigned char )rtw_wireless_mode;
  registry_par->vrtl_carrier_sense = (unsigned char )rtw_vrtl_carrier_sense;
  registry_par->vcs_type = (unsigned char )rtw_vcs_type;
  registry_par->rts_thresh = (unsigned short )rtw_rts_thresh;
  registry_par->frag_thresh = (unsigned short )rtw_frag_thresh;
  registry_par->preamble = (unsigned char )rtw_preamble;
  registry_par->scan_mode = (unsigned char )rtw_scan_mode;
  registry_par->adhoc_tx_pwr = (unsigned char )rtw_adhoc_tx_pwr;
  registry_par->soft_ap = (unsigned char )rtw_soft_ap;
  registry_par->smart_ps = (unsigned char )rtw_smart_ps;
  registry_par->power_mgnt = (unsigned char )rtw_power_mgnt;
  registry_par->ips_mode = (unsigned char )rtw_ips_mode;
  registry_par->long_retry_lmt = (unsigned char )rtw_long_retry_lmt;
  registry_par->short_retry_lmt = (unsigned char )rtw_short_retry_lmt;
  registry_par->busy_thresh = (unsigned short )rtw_busy_thresh;
  registry_par->ack_policy = (unsigned char )rtw_ack_policy;
  registry_par->acm_method = (unsigned char )rtw_acm_method;
  registry_par->wmm_enable = (unsigned char )rtw_wmm_enable;
  registry_par->uapsd_enable = (unsigned char )rtw_uapsd_enable;
  registry_par->ht_enable = (unsigned char )rtw_ht_enable;
  registry_par->cbw40_enable = (unsigned char )rtw_cbw40_enable;
  registry_par->ampdu_enable = (unsigned char )rtw_ampdu_enable;
  registry_par->rx_stbc = (unsigned char )rtw_rx_stbc;
  registry_par->ampdu_amsdu = (unsigned char )rtw_ampdu_amsdu;
  registry_par->lowrate_two_xmit = (unsigned char )rtw_lowrate_two_xmit;
  registry_par->rf_config = (unsigned char )rtw_rf_config;
  registry_par->low_power = (unsigned char )rtw_low_power;
  registry_par->wifi_spec = (unsigned char )rtw_wifi_spec;
  registry_par->channel_plan = (unsigned char )rtw_channel_plan;
  registry_par->btcoex = (unsigned char )rtw_btcoex_enable;
  registry_par->bt_iso = (unsigned char )rtw_bt_iso;
  registry_par->bt_sco = (unsigned char )rtw_bt_sco;
  registry_par->bt_ampdu = (unsigned char )rtw_bt_ampdu;
  registry_par->bAcceptAddbaReq = (unsigned int )((unsigned char )rtw_AcceptAddbaReq) != 0U;
  registry_par->antdiv_cfg = (unsigned char )rtw_antdiv_cfg;
  registry_par->antdiv_type = (unsigned char )rtw_antdiv_type;
  registry_par->hwpdn_mode = (unsigned char )rtw_hwpdn_mode;
  registry_par->hwpwrp_detect = (unsigned char )rtw_hwpwrp_detect;
  registry_par->hw_wps_pbc = (unsigned char )rtw_hw_wps_pbc;
  registry_par->max_roaming_times = (unsigned char )rtw_max_roaming_times;
  registry_par->enable80211d = (unsigned char )rtw_80211d;
  snprintf((char *)(& registry_par->ifname), 16UL, "%s", ifname);
  snprintf((char *)(& registry_par->if2name), 16UL, "%s", if2name);
  registry_par->notch_filter = (unsigned char )rtw_notch_filter;
  registry_par->regulatory_tid = (unsigned char )rtw_regulatory_id;
  return;
}
}
static int rtw_net_set_mac_address(struct net_device *pnetdev , void *p ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct sockaddr *addr ;

  {
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  addr = (struct sockaddr *)p;
  if (padapter->bup == 0) {
    ether_addr_copy((u8 *)(& padapter->eeprompriv.mac_addr), (u8 const   *)(& addr->sa_data));
  } else {

  }
  return (0);
}
}
static struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct xmit_priv *pxmitpriv ;
  struct recv_priv *precvpriv ;

  {
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  pxmitpriv = & padapter->xmitpriv;
  precvpriv = & padapter->recvpriv;
  padapter->stats.tx_packets = (unsigned long )pxmitpriv->tx_pkts;
  padapter->stats.rx_packets = (unsigned long )precvpriv->rx_pkts;
  padapter->stats.tx_dropped = (unsigned long )pxmitpriv->tx_drop;
  padapter->stats.rx_dropped = (unsigned long )precvpriv->rx_drop;
  padapter->stats.tx_bytes = (unsigned long )pxmitpriv->tx_bytes;
  padapter->stats.rx_bytes = (unsigned long )precvpriv->rx_bytes;
  return (& padapter->stats);
}
}
static u16 const   rtw_1d_to_queue[8U]  = 
  {      2U,      3U,      3U,      2U, 
        1U,      1U,      0U,      0U};
static u32 rtw_classify8021d(struct sk_buff *skb ) 
{ 
  u32 dscp ;
  struct iphdr *tmp ;

  {
  if (skb->priority > 255U && skb->priority <= 263U) {
    return (skb->priority - 256U);
  } else {

  }
  switch ((int )skb->protocol) {
  case 8: 
  tmp = ip_hdr((struct sk_buff  const  *)skb);
  dscp = (u32 )tmp->tos & 252U;
  goto ldv_56478;
  default: ;
  return (0U);
  }
  ldv_56478: ;
  return (dscp >> 5);
}
}
static u16 rtw_select_queue(struct net_device *dev , struct sk_buff *skb , void *accel_priv ,
                            u16 (*fallback)(struct net_device * , struct sk_buff * ) ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  u8 tmp___0 ;

  {
  tmp = netdev_priv((struct net_device  const  *)dev);
  padapter = (struct rtw_adapter *)tmp;
  pmlmepriv = & padapter->mlmepriv;
  skb->priority = rtw_classify8021d(skb);
  if ((unsigned int )pmlmepriv->acm_mask != 0U) {
    tmp___0 = qos_acm23a((int )pmlmepriv->acm_mask, (int )((u8 )skb->priority));
    skb->priority = (__u32 )tmp___0;
  } else {

  }
  return ((u16 )rtw_1d_to_queue[skb->priority]);
}
}
u16 rtw_recv_select_queue23a(struct sk_buff *skb ) 
{ 
  struct iphdr *piphdr ;
  struct ethhdr *eth ;
  unsigned int dscp ;
  u16 eth_type ;
  u16 tmp ;
  u32 priority ;
  u8 *pdata ;

  {
  eth = (struct ethhdr *)skb->data;
  tmp = get_unaligned_be16((void const   *)(& eth->h_proto));
  eth_type = tmp;
  pdata = skb->data;
  switch ((int )eth_type) {
  case 2048: 
  piphdr = (struct iphdr *)pdata + 14U;
  dscp = (unsigned int )piphdr->tos & 252U;
  priority = dscp >> 5;
  goto ldv_56498;
  default: 
  priority = 0U;
  }
  ldv_56498: ;
  return ((u16 )rtw_1d_to_queue[priority]);
}
}
static struct net_device_ops  const  rtw_netdev_ops  = 
     {0, 0, & netdev_open23a, & netdev_close, (netdev_tx_t (*)(struct sk_buff * , struct net_device * ))(& rtw_xmit23a_entry23a),
    & rtw_select_queue, 0, 0, & rtw_net_set_mac_address, 0, 0, 0, 0, 0, 0, 0, & rtw_net_get_stats,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int rtw_init_netdev23a_name23a(struct net_device *pnetdev , char const   *ifname___0 ) 
{ 
  int tmp ;

  {
  tmp = dev_alloc_name(pnetdev, ifname___0);
  if (tmp < 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2048, 4, "dev_alloc_name, fail!\n");
    } else {

    }
  } else {

  }
  netif_carrier_off(pnetdev);
  return (0);
}
}
static struct device_type  const  wlan_type  =    {"wlan", 0, 0, 0, 0, 0};
struct net_device *rtw_init_netdev23a(struct rtw_adapter *old_padapter ) 
{ 
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  void *tmp ;

  {
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "+init_net_dev\n");
  } else {

  }
  pnetdev = alloc_etherdev_mqs(16776, 4U, 4U);
  if ((unsigned long )pnetdev == (unsigned long )((struct net_device *)0)) {
    return ((struct net_device *)0);
  } else {

  }
  pnetdev->dev.type = & wlan_type;
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  padapter->pnetdev = pnetdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: register rtw_netdev_ops to netdev_ops\n");
  } else {

  }
  pnetdev->netdev_ops = & rtw_netdev_ops;
  pnetdev->watchdog_timeo = 750;
  loadparam(padapter, pnetdev);
  return (pnetdev);
}
}
static int rtw_init_default_value(struct rtw_adapter *padapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;

  {
  pregistrypriv = & padapter->registrypriv;
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv->vcs = pregistrypriv->vcs_type;
  pxmitpriv->frag_len = (uint )pregistrypriv->frag_thresh;
  pmlmepriv->scan_interval = 30U;
  pmlmepriv->scan_mode = 1;
  pmlmepriv->htpriv.ampdu_enable = 0;
  psecuritypriv->binstallGrpkey = 0U;
  psecuritypriv->dot11AuthAlgrthm = 0U;
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
  psecuritypriv->dot11PrivacyKeyIndex = 0U;
  psecuritypriv->dot118021XGrpPrivacy = 0U;
  psecuritypriv->dot118021XGrpKeyid = 1U;
  psecuritypriv->ndisauthtype = 0U;
  psecuritypriv->ndisencryptstatus = 1U;
  rtw_init_registrypriv_dev_network23a(padapter);
  rtw_update_registrypriv_dev_network23a(padapter);
  rtl8723a_init_default_value(padapter);
  padapter->bReadPortCancel = 0U;
  padapter->bWritePortCancel = 0U;
  return (1);
}
}
int rtw_reset_drv_sw23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrctrlpriv ;
  unsigned long tmp ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pwrctrlpriv = & padapter->pwrctrlpriv;
  rtl8723a_init_default_value(padapter);
  padapter->bReadPortCancel = 0U;
  padapter->bWritePortCancel = 0U;
  pmlmepriv->scan_interval = 30U;
  padapter->xmitpriv.tx_pkts = 0ULL;
  padapter->recvpriv.rx_pkts = 0ULL;
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
  _clr_fwstate_(pmlmepriv, 2176);
  rtw_sreset_reset_value(padapter);
  pwrctrlpriv->pwr_state_check_cnts = 0U;
  padapter->mlmeextpriv.sitesurvey_res.state = 0;
  tmp = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
  ldv_mod_timer_658(& padapter->recvpriv.signal_stat_timer, tmp + (unsigned long )jiffies);
  return (1);
}
}
int rtw_init_drv_sw23a(struct rtw_adapter *padapter ) 
{ 
  int ret8 ;
  int tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  ret8 = 1;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "+rtw_init_drv_sw23a\n");
  } else {

  }
  tmp = rtw_init_cmd_priv23a(& padapter->cmdpriv);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2048, 4, "Can\'t init cmd_priv\n");
    } else {

    }
    ret8 = 0;
    goto exit;
  } else {

  }
  padapter->cmdpriv.padapter = padapter;
  tmp___0 = rtw_init_evt_priv23a(& padapter->evtpriv);
  if (tmp___0 == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2048, 4, "Can\'t init evt_priv\n");
    } else {

    }
    ret8 = 0;
    goto exit;
  } else {

  }
  tmp___1 = rtw_init_mlme_priv23a(padapter);
  if (tmp___1 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2048, 4, "Can\'t init mlme_priv\n");
    } else {

    }
    ret8 = 0;
    goto exit;
  } else {

  }
  tmp___2 = init_mlme_ext_priv23a(padapter);
  if (tmp___2 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2048, 4, "Can\'t init mlme_ext_priv\n");
    } else {

    }
    ret8 = 0;
    goto exit;
  } else {

  }
  tmp___3 = _rtw_init_xmit_priv23a(& padapter->xmitpriv, padapter);
  if (tmp___3 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Can\'t _rtw_init_xmit_priv23a\n");
    } else {

    }
    ret8 = 0;
    goto exit;
  } else {

  }
  tmp___4 = _rtw_init_recv_priv23a(& padapter->recvpriv, padapter);
  if (tmp___4 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Can\'t _rtw_init_recv_priv23a\n");
    } else {

    }
    ret8 = 0;
    goto exit;
  } else {

  }
  tmp___5 = _rtw_init_sta_priv23a(& padapter->stapriv);
  if (tmp___5 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Can\'t _rtw_init_sta_priv23a\n");
    } else {

    }
    ret8 = 0;
    goto exit;
  } else {

  }
  padapter->stapriv.padapter = padapter;
  padapter->setband = 0U;
  rtw_init_bcmc_stainfo23a(padapter);
  rtw_init_pwrctrl_priv23a(padapter);
  ret8 = rtw_init_default_value(padapter);
  rtl8723a_init_dm_priv(padapter);
  rtw_sreset_init(padapter);
  exit: ;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "-rtw_init_drv_sw23a\n");
  } else {

  }
  return (ret8);
}
}
void rtw_cancel_all_timer23a(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "+rtw_cancel_all_timer23a\n");
  } else {

  }
  ldv_del_timer_sync_659(& padapter->mlmepriv.assoc_timer);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "%s:cancel association timer complete!\n", "rtw_cancel_all_timer23a");
  } else {

  }
  ldv_del_timer_sync_660(& padapter->mlmepriv.scan_to_timer);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "%s:cancel scan_to_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
  ldv_del_timer_sync_661(& padapter->mlmepriv.dynamic_chk_timer);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "%s:cancel dynamic_chk_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
  ldv_del_timer_sync_662(& padapter->pwrctrlpriv.pwr_state_check_timer);
  ldv_del_timer_sync_663(& padapter->mlmepriv.set_scan_deny_timer);
  rtw_clear_scan_deny(padapter);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "%s:cancel set_scan_deny_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
  ldv_del_timer_sync_664(& padapter->recvpriv.signal_stat_timer);
  return;
}
}
int rtw_free_drv_sw23a(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "==>rtw_free_drv_sw23a\n");
  } else {

  }
  free_mlme_ext_priv23a(& padapter->mlmeextpriv);
  rtw_free_evt_priv23a(& padapter->evtpriv);
  rtw_free_mlme_priv23a(& padapter->mlmepriv);
  _rtw_free_xmit_priv23a(& padapter->xmitpriv);
  _rtw_free_sta_priv23a(& padapter->stapriv);
  _rtw_free_recv_priv23a(& padapter->recvpriv);
  rtw_free_pwrctrl_priv(padapter);
  kfree((void const   *)padapter->HalData);
  padapter->HalData = (void *)0;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "-rtw_free_drv_sw23a\n");
  } else {

  }
  return (1);
}
}
static int _rtw_drv_register_netdev(struct rtw_adapter *padapter , char *name ) 
{ 
  struct net_device *pnetdev ;
  int ret ;
  int tmp ;

  {
  pnetdev = padapter->pnetdev;
  ret = 1;
  rtw_init_netdev23a_name23a(pnetdev, (char const   *)name);
  ether_addr_copy(pnetdev->dev_addr, (u8 const   *)(& padapter->eeprompriv.mac_addr));
  tmp = ldv_register_netdev_665(pnetdev);
  if (tmp != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): Failed!\n", "_rtw_drv_register_netdev", (char *)(& pnetdev->name));
    } else {

    }
    ret = 0;
    goto error_register_netdev;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, MAC Address (if%d) = %pM\n", "_rtw_drv_register_netdev",
           (int )padapter->iface_id + 1, pnetdev->dev_addr);
  } else {

  }
  return (ret);
  error_register_netdev: ;
  if ((unsigned int )padapter->iface_id != 0U) {
    rtw_free_drv_sw23a(padapter);
    ldv_free_netdev_666(pnetdev);
  } else {

  }
  return (ret);
}
}
int rtw_drv_register_netdev(struct rtw_adapter *if1 ) 
{ 
  struct dvobj_priv *dvobj ;
  int i ;
  int status ;
  struct rtw_adapter *padapter ;
  char *name ;

  {
  dvobj = if1->dvobj;
  status = 1;
  if ((unsigned int )dvobj->iface_nums > 3U) {
    status = 0;
    goto exit;
  } else {

  }
  i = 0;
  goto ldv_56554;
  ldv_56553: 
  padapter = dvobj->padapters[i];
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
    if ((unsigned int )padapter->iface_id == 0U) {
      name = (char *)(& if1->registrypriv.ifname);
    } else
    if ((unsigned int )padapter->iface_id == 1U) {
      name = (char *)(& if1->registrypriv.if2name);
    } else {
      name = (char *)"wlan%d";
    }
    status = _rtw_drv_register_netdev(padapter, name);
    if (status != 1) {
      goto ldv_56552;
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_56554: ;
  if ((int )dvobj->iface_nums > i) {
    goto ldv_56553;
  } else {

  }
  ldv_56552: ;
  exit: ;
  return (status);
}
}
int netdev_open23a(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct pwrctrl_priv *pwrctrlpriv ;
  int ret ;
  int status ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  ret = 0;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "+871x_drv - dev_open\n");
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +871x_drv - drv_open, bup =%d\n", padapter->bup);
  } else {

  }
  mutex_lock_nested(& (padapter->dvobj)->hw_init_mutex, 0U);
  pwrctrlpriv = & padapter->pwrctrlpriv;
  if (padapter->bup == 0) {
    padapter->bDriverStopped = 0;
    padapter->bSurpriseRemoved = 0;
    padapter->bCardDisableWOHSM = 0;
    status = rtl8723au_hal_init(padapter);
    if (status == 0) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(2048, 4, "rtl871x_hal_init(): Can\'t init h/w!\n");
      } else {

      }
      goto netdev_open23a_error;
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: MAC Address = %pM\n", pnetdev->dev_addr);
    } else {

    }
    tmp___0 = init_hw_mlme_ext23a(padapter);
    if (tmp___0 == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: can\'t init mlme_ext_priv\n");
      } else {

      }
      goto netdev_open23a_error;
    } else {

    }
    rtl8723au_inirp_init(padapter);
    rtw_cfg80211_init_wiphy(padapter);
    padapter->bup = 1;
  } else {

  }
  padapter->net_closed = 0;
  tmp___1 = msecs_to_jiffies(2000U);
  ldv_mod_timer_667(& padapter->mlmepriv.dynamic_chk_timer, tmp___1 + (unsigned long )jiffies);
  padapter->pwrctrlpriv.bips_processing = 0U;
  tmp___2 = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
  ldv_mod_timer_668(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp___2 + (unsigned long )jiffies);
  tmp___3 = rtw_netif_queue_stopped(pnetdev);
  if (tmp___3 == 0) {
    netif_tx_start_all_queues(pnetdev);
  } else {
    netif_tx_wake_all_queues___0(pnetdev);
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "-871x_drv - dev_open\n");
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -871x_drv - drv_open, bup =%d\n", padapter->bup);
  } else {

  }
  exit: 
  mutex_unlock(& (padapter->dvobj)->hw_init_mutex);
  return (ret);
  netdev_open23a_error: 
  padapter->bup = 0;
  netif_carrier_off(pnetdev);
  netif_tx_stop_all_queues(pnetdev);
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(2048, 4, "-871x_drv - dev_open, fail!\n");
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -871x_drv - drv_open fail, bup =%d\n", padapter->bup);
  } else {

  }
  ret = -1;
  goto exit;
}
}
static int ips_netdrv_open(struct rtw_adapter *padapter ) 
{ 
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  status = 1;
  padapter->net_closed = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ===> %s.........\n", "ips_netdrv_open");
  } else {

  }
  padapter->bDriverStopped = 0;
  padapter->bSurpriseRemoved = 0;
  padapter->bCardDisableWOHSM = 0;
  status = rtl8723au_hal_init(padapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2048, 4, "ips_netdrv_open(): Can\'t init h/w!\n");
    } else {

    }
    goto netdev_open23a_error;
  } else {

  }
  rtl8723au_inirp_init(padapter);
  tmp = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
  ldv_mod_timer_669(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp + (unsigned long )jiffies);
  tmp___0 = msecs_to_jiffies(5000U);
  ldv_mod_timer_670(& padapter->mlmepriv.dynamic_chk_timer, tmp___0 + (unsigned long )jiffies);
  return (1);
  netdev_open23a_error: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -ips_netdrv_open - drv_open failure, bup =%d\n", padapter->bup);
  } else {

  }
  return (0);
}
}
int rtw_ips_pwr_up23a(struct rtw_adapter *padapter ) 
{ 
  int result ;
  unsigned long start_time ;
  unsigned int tmp ;

  {
  start_time = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ===>  rtw_ips_pwr_up23a..............\n");
  } else {

  }
  rtw_reset_drv_sw23a(padapter);
  result = ips_netdrv_open(padapter);
  if (GlobalDebugLevel23A > 3U) {
    tmp = jiffies_to_msecs((unsigned long )jiffies - start_time);
    printk("\016RTL8723AU: <===  rtw_ips_pwr_up23a.............. in %dms\n", tmp);
  } else {

  }
  return (result);
}
}
void rtw_ips_pwr_down23a(struct rtw_adapter *padapter ) 
{ 
  unsigned long start_time ;
  unsigned int tmp ;

  {
  start_time = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ===> rtw_ips_pwr_down23a...................\n");
  } else {

  }
  padapter->bCardDisableWOHSM = 1;
  padapter->net_closed = 1;
  rtw_ips_dev_unload23a(padapter);
  padapter->bCardDisableWOHSM = 0;
  if (GlobalDebugLevel23A > 3U) {
    tmp = jiffies_to_msecs((unsigned long )jiffies - start_time);
    printk("\016RTL8723AU: <=== rtw_ips_pwr_down23a..................... in %dms\n",
           tmp);
  } else {

  }
  return;
}
}
void rtw_ips_dev_unload23a(struct rtw_adapter *padapter ) 
{ 


  {
  rtl8723a_fifo_cleanup(padapter);
  rtl8723a_usb_intf_stop(padapter);
  if (padapter->bSurpriseRemoved == 0) {
    rtl8723au_hal_deinit(padapter);
  } else {

  }
  return;
}
}
int pm_netdev_open23a(struct net_device *pnetdev , u8 bnormal ) 
{ 
  int status ;
  void *tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )bnormal != 0U) {
    status = netdev_open23a(pnetdev);
  } else {
    tmp = netdev_priv((struct net_device  const  *)pnetdev);
    tmp___0 = ips_netdrv_open((struct rtw_adapter *)tmp);
    status = tmp___0 == 1 ? 0 : -1;
  }
  return (status);
}
}
static int netdev_close(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "+871x_drv - drv_close\n");
  } else {

  }
  padapter->net_closed = 1;
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: (2)871x_drv - drv_close, bup =%d, hw_init_completed =%d\n",
             padapter->bup, (int )padapter->hw_init_completed);
    } else {

    }
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
      tmp___0 = rtw_netif_queue_stopped(pnetdev);
      if (tmp___0 == 0) {
        netif_tx_stop_all_queues(pnetdev);
      } else {

      }
    } else {

    }
    LeaveAllPowerSaveMode23a(padapter);
    rtw_disassoc_cmd23a(padapter, 500U, 0);
    rtw_indicate_disconnect23a(padapter);
    rtw_free_assoc_resources23a(padapter, 1);
    rtw_free_network_queue23a(padapter);
  } else {

  }
  rtw_scan_abort23a(padapter);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2048, 7, "-871x_drv - drv_close\n");
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -871x_drv - drv_close, bup =%d\n", padapter->bup);
  } else {

  }
  return (0);
}
}
void rtw_ndev_destructor(struct net_device *ndev ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "rtw_ndev_destructor", (char *)(& ndev->name));
  } else {

  }
  kfree((void const   *)ndev->ieee80211_ptr);
  ldv_free_netdev_671(ndev);
  return;
}
}
void _rtw_init_queue23a(struct rtw_queue *pqueue ) 
{ 
  struct lock_class_key __key ;

  {
  INIT_LIST_HEAD(& pqueue->queue);
  spinlock_check(& pqueue->lock);
  __raw_spin_lock_init(& pqueue->lock.__annonCompField18.rlock, "&(&pqueue->lock)->rlock",
                       & __key);
  return;
}
}
extern int ldv_ndo_init_15(void) ;
int ldv_retval_8  ;
int ldv_retval_7  ;
extern int ldv_ndo_uninit_15(void) ;
void ldv_net_device_ops_15(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(3008UL);
  rtw_netdev_ops_group1 = (struct net_device *)tmp;
  return;
}
}
void ldv_main_exported_15(void) 
{ 
  void *ldvarg50 ;
  void *tmp ;
  u16 (*ldvarg49)(struct net_device * , struct sk_buff * ) ;
  struct sk_buff *ldvarg52 ;
  void *tmp___0 ;
  struct sk_buff *ldvarg51 ;
  void *tmp___1 ;
  void *ldvarg48 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg50 = tmp;
  tmp___0 = ldv_init_zalloc(232UL);
  ldvarg52 = (struct sk_buff *)tmp___0;
  tmp___1 = ldv_init_zalloc(232UL);
  ldvarg51 = (struct sk_buff *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg48 = tmp___2;
  ldv_memset((void *)(& ldvarg49), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_15 == 1) {
    rtw_net_get_stats(rtw_netdev_ops_group1);
    ldv_state_variable_15 = 1;
  } else {

  }
  if (ldv_state_variable_15 == 3) {
    rtw_net_get_stats(rtw_netdev_ops_group1);
    ldv_state_variable_15 = 3;
  } else {

  }
  if (ldv_state_variable_15 == 2) {
    rtw_net_get_stats(rtw_netdev_ops_group1);
    ldv_state_variable_15 = 2;
  } else {

  }
  goto ldv_56621;
  case 1: ;
  if (ldv_state_variable_15 == 2) {
    ldv_retval_8 = netdev_open23a(rtw_netdev_ops_group1);
    if (ldv_retval_8 == 0) {
      ldv_state_variable_15 = 3;
    } else {

    }
  } else {

  }
  goto ldv_56621;
  case 2: ;
  if (ldv_state_variable_15 == 3) {
    rtw_xmit23a_entry23a(ldvarg52, rtw_netdev_ops_group1);
    ldv_state_variable_15 = 3;
  } else {

  }
  goto ldv_56621;
  case 3: ;
  if (ldv_state_variable_15 == 3) {
    netdev_close(rtw_netdev_ops_group1);
    ldv_state_variable_15 = 2;
  } else {

  }
  goto ldv_56621;
  case 4: ;
  if (ldv_state_variable_15 == 1) {
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg51, ldvarg50, ldvarg49);
    ldv_state_variable_15 = 1;
  } else {

  }
  if (ldv_state_variable_15 == 3) {
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg51, ldvarg50, ldvarg49);
    ldv_state_variable_15 = 3;
  } else {

  }
  if (ldv_state_variable_15 == 2) {
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg51, ldvarg50, ldvarg49);
    ldv_state_variable_15 = 2;
  } else {

  }
  goto ldv_56621;
  case 5: ;
  if (ldv_state_variable_15 == 1) {
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg48);
    ldv_state_variable_15 = 1;
  } else {

  }
  if (ldv_state_variable_15 == 3) {
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg48);
    ldv_state_variable_15 = 3;
  } else {

  }
  if (ldv_state_variable_15 == 2) {
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg48);
    ldv_state_variable_15 = 2;
  } else {

  }
  goto ldv_56621;
  case 6: ;
  if (ldv_state_variable_15 == 1) {
    ldv_retval_7 = ldv_ndo_init_15();
    if (ldv_retval_7 == 0) {
      ldv_state_variable_15 = 2;
      usb_counter = usb_counter + 1;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56621;
  case 7: ;
  if (ldv_state_variable_15 == 2) {
    ldv_ndo_uninit_15();
    ldv_state_variable_15 = 1;
    usb_counter = usb_counter - 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56621;
  default: 
  ldv_stop();
  }
  ldv_56621: ;
  return;
}
}
bool ldv_queue_work_on_653(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_654(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_655(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_656(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_657(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_658(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_659(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_660(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_661(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_662(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_663(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_664(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_register_netdev_665(struct net_device *dev ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
  tmp = register_netdev(dev);
  ldv_func_res = tmp;
  ldv_state_variable_17 = 1;
  ldv_net_device_ops_17();
  return (ldv_func_res);
}
}
void ldv_free_netdev_666(struct net_device *dev ) 
{ 


  {
  free_netdev(dev);
  ldv_state_variable_17 = 0;
  return;
}
}
int ldv_mod_timer_667(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_668(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_669(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_670(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
void ldv_free_netdev_671(struct net_device *dev ) 
{ 


  {
  free_netdev(dev);
  ldv_state_variable_17 = 0;
  return;
}
}
bool ldv_queue_work_on_695(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_697(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_696(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_699(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_698(struct workqueue_struct *ldv_func_arg1 ) ;
struct timer_list *ldv_timer_list_13_3 ;
int ldv_timer_13_3 ;
struct timer_list *ldv_timer_list_13_1 ;
int ldv_timer_13_0 ;
int ldv_timer_13_2 ;
struct timer_list *ldv_timer_list_13_0 ;
struct timer_list *ldv_timer_list_13_2 ;
int ldv_timer_13_1 ;
void activate_suitable_timer_13(struct timer_list *timer , unsigned long data ) ;
void choose_timer_13(void) ;
void ldv_timer_13(int state , struct timer_list *timer ) ;
void disable_suitable_timer_13(struct timer_list *timer ) ;
void timer_init_13(void) ;
void activate_pending_timer_13(struct timer_list *timer , unsigned long data , int pending_flag ) ;
int reg_timer_13(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
__inline static void skb_set_queue_mapping(struct sk_buff *skb , u16 queue_mapping ) 
{ 


  {
  skb->queue_mapping = queue_mapping;
  return;
}
}
extern void cfg80211_michael_mic_failure(struct net_device * , u8 const   * , enum nl80211_key_type  ,
                                         int  , u8 const   * , gfp_t  ) ;
void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter , u8 bgroup ) 
{ 
  enum nl80211_key_type key_type ;
  union iwreq_data wrqu ;
  struct iw_michaelmicfailure ev ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  unsigned long cur_time ;

  {
  key_type = 0;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  if (psecuritypriv->last_mic_err_time == 0UL) {
    psecuritypriv->last_mic_err_time = jiffies;
  } else {
    cur_time = jiffies;
    if (cur_time - psecuritypriv->last_mic_err_time <= 14999UL) {
      psecuritypriv->btkip_countermeasure = 1U;
      psecuritypriv->last_mic_err_time = 0UL;
      psecuritypriv->btkip_countermeasure_time = cur_time;
    } else {
      psecuritypriv->last_mic_err_time = jiffies;
    }
  }
  if ((unsigned int )bgroup != 0U) {
    key_type = key_type;
  } else {
    key_type = (enum nl80211_key_type )((unsigned int )key_type | 1U);
  }
  cfg80211_michael_mic_failure(padapter->pnetdev, (u8 const   *)(& pmlmepriv->assoc_bssid),
                               key_type, -1, (u8 const   *)0U, 32U);
  memset((void *)(& ev), 0, 28UL);
  if ((unsigned int )bgroup != 0U) {
    ev.flags = ev.flags | 4U;
  } else {
    ev.flags = ev.flags | 8U;
  }
  ev.src_addr.sa_family = 1U;
  ether_addr_copy((u8 *)(& ev.src_addr.sa_data), (u8 const   *)(& pmlmepriv->assoc_bssid));
  memset((void *)(& wrqu), 0, 16UL);
  wrqu.data.length = 28U;
  return;
}
}
int rtw_recv_indicatepkt23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct recv_priv *precvpriv ;
  struct sk_buff *skb ;
  struct mlme_priv *pmlmepriv ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  struct sk_buff *pskb2 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct rx_pkt_attrib *pattrib ;
  int bmcast ;
  bool tmp___1 ;
  struct net_device *pnetdev ;
  u16 tmp___2 ;
  u8 *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  precvpriv = & padapter->recvpriv;
  skb = precv_frame->pkt;
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(8, 4, "rtw_recv_indicatepkt23a():skb == NULL!!!!\n");
    } else {

    }
    goto _recv_indicatepkt_drop;
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(8, 7, "rtw_recv_indicatepkt23a():skb != NULL !!!\n");
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(8, 7, "rtw_recv_indicatepkt23a():precv_frame->hdr.rx_data =%p\n", (precv_frame->pkt)->data);
  } else {

  }
  if (GlobalDebugLevel23A > 6U) {
    tmp = skb_end_pointer((struct sk_buff  const  *)skb);
    tmp___0 = skb_tail_pointer((struct sk_buff  const  *)skb);
    rt_trace(8, 7, "skb->head =%p skb->data =%p skb->tail =%p skb->end =%p skb->len =%d\n",
             skb->head, skb->data, tmp___0, tmp, skb->len);
  } else {

  }
  tmp___6 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___6) {
    pskb2 = (struct sk_buff *)0;
    psta = (struct sta_info *)0;
    pstapriv = & padapter->stapriv;
    pattrib = & precv_frame->attrib;
    tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
    bmcast = (int )tmp___1;
    tmp___3 = myid(& padapter->eeprompriv);
    tmp___4 = ether_addr_equal((u8 const   *)(& pattrib->dst), (u8 const   *)tmp___3);
    if (tmp___4) {
      tmp___5 = 0;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (bmcast != 0) {
        psta = rtw_get_bcmc_stainfo23a(padapter);
        pskb2 = skb_clone(skb, 32U);
      } else {
        psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->dst));
      }
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
        pnetdev = padapter->pnetdev;
        skb->dev = pnetdev;
        tmp___2 = rtw_recv_select_queue23a(skb);
        skb_set_queue_mapping(skb, (int )tmp___2);
        rtw_xmit23a_entry23a(skb, pnetdev);
        if (bmcast != 0) {
          skb = pskb2;
        } else {
          goto _recv_indicatepkt_end;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  skb->ip_summed = 0U;
  skb->dev = padapter->pnetdev;
  skb->protocol = eth_type_trans(skb, padapter->pnetdev);
  netif_rx(skb);
  _recv_indicatepkt_end: 
  precv_frame->pkt = (struct sk_buff *)0;
  rtw_free_recvframe23a(precv_frame);
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(8, 7, "rtw_recv_indicatepkt23a :after netif_rx!!!!\n");
  } else {

  }
  return (1);
  _recv_indicatepkt_drop: 
  rtw_free_recvframe23a(precv_frame);
  return (0);
}
}
void rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl ) 
{ 


  {
  reg_timer_11(& preorder_ctrl->reordering_ctrl_timer, & rtw_reordering_ctrl_timeout_handler23a,
               (unsigned long )preorder_ctrl);
  return;
}
}
void activate_suitable_timer_13(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_13_0 == 0 || ldv_timer_13_0 == 2) {
    ldv_timer_list_13_0 = timer;
    ldv_timer_list_13_0->data = data;
    ldv_timer_13_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_13_1 == 0 || ldv_timer_13_1 == 2) {
    ldv_timer_list_13_1 = timer;
    ldv_timer_list_13_1->data = data;
    ldv_timer_13_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_13_2 == 0 || ldv_timer_13_2 == 2) {
    ldv_timer_list_13_2 = timer;
    ldv_timer_list_13_2->data = data;
    ldv_timer_13_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_13_3 == 0 || ldv_timer_13_3 == 2) {
    ldv_timer_list_13_3 = timer;
    ldv_timer_list_13_3->data = data;
    ldv_timer_13_3 = 1;
    return;
  } else {

  }
  return;
}
}
void choose_timer_13(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_13_0 == 1) {
    ldv_timer_13_0 = 2;
    ldv_timer_13(ldv_timer_13_0, ldv_timer_list_13_0);
  } else {

  }
  goto ldv_53293;
  case 1: ;
  if (ldv_timer_13_1 == 1) {
    ldv_timer_13_1 = 2;
    ldv_timer_13(ldv_timer_13_1, ldv_timer_list_13_1);
  } else {

  }
  goto ldv_53293;
  case 2: ;
  if (ldv_timer_13_2 == 1) {
    ldv_timer_13_2 = 2;
    ldv_timer_13(ldv_timer_13_2, ldv_timer_list_13_2);
  } else {

  }
  goto ldv_53293;
  case 3: ;
  if (ldv_timer_13_3 == 1) {
    ldv_timer_13_3 = 2;
    ldv_timer_13(ldv_timer_13_3, ldv_timer_list_13_3);
  } else {

  }
  goto ldv_53293;
  default: 
  ldv_stop();
  }
  ldv_53293: ;
  return;
}
}
void ldv_timer_13(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  rtw_reordering_ctrl_timeout_handler23a(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void disable_suitable_timer_13(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_13_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_13_0) {
    ldv_timer_13_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_13_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_13_1) {
    ldv_timer_13_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_13_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_13_2) {
    ldv_timer_13_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_13_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_13_3) {
    ldv_timer_13_3 = 0;
    return;
  } else {

  }
  return;
}
}
void timer_init_13(void) 
{ 


  {
  ldv_timer_13_0 = 0;
  ldv_timer_13_1 = 0;
  ldv_timer_13_2 = 0;
  ldv_timer_13_3 = 0;
  return;
}
}
void activate_pending_timer_13(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_13_0 == (unsigned long )timer) {
    if (ldv_timer_13_0 == 2 || pending_flag != 0) {
      ldv_timer_list_13_0 = timer;
      ldv_timer_list_13_0->data = data;
      ldv_timer_13_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_13_1 == (unsigned long )timer) {
    if (ldv_timer_13_1 == 2 || pending_flag != 0) {
      ldv_timer_list_13_1 = timer;
      ldv_timer_list_13_1->data = data;
      ldv_timer_13_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_13_2 == (unsigned long )timer) {
    if (ldv_timer_13_2 == 2 || pending_flag != 0) {
      ldv_timer_list_13_2 = timer;
      ldv_timer_list_13_2->data = data;
      ldv_timer_13_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_13_3 == (unsigned long )timer) {
    if (ldv_timer_13_3 == 2 || pending_flag != 0) {
      ldv_timer_list_13_3 = timer;
      ldv_timer_list_13_3->data = data;
      ldv_timer_13_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_13(timer, data);
  return;
}
}
int reg_timer_13(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& rtw_reordering_ctrl_timeout_handler23a)) {
    activate_suitable_timer_13(timer, data);
  } else {

  }
  return (0);
}
}
bool ldv_queue_work_on_695(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_696(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_697(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_698(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_699(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern struct module __this_module ;
extern void __bad_percpu_size(void) ;
extern struct task_struct *current_task ;
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  switch (8UL) {
  case 1UL: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
  goto ldv_3129;
  case 2UL: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_3129;
  case 4UL: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_3129;
  case 8UL: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_3129;
  default: 
  __bad_percpu_size();
  }
  ldv_3129: ;
  return (pfo_ret__);
}
}
bool ldv_queue_work_on_709(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_711(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_710(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_713(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_712(struct workqueue_struct *ldv_func_arg1 ) ;
void ldv_flush_workqueue_714(struct workqueue_struct *ldv_func_arg1 ) ;
struct timer_list *ldv_timer_list_7_1  ;
int ldv_timer_11_0  ;
struct work_struct *ldv_work_struct_3_1  ;
int ldv_state_variable_0  ;
struct timer_list *ldv_timer_list_9_3  ;
struct timer_list *ldv_timer_list_10_2  ;
struct timer_list *ldv_timer_list_8_1  ;
int ldv_timer_5_2  ;
int ldv_work_1_1  ;
int ldv_state_variable_12  ;
struct timer_list *ldv_timer_list_5_0  ;
struct timer_list *ldv_timer_list_12_1  ;
struct station_info *rtw_cfg80211_ops_group1  ;
int ldv_state_variable_14  ;
int ldv_timer_9_1  ;
int ldv_timer_6_2  ;
int ldv_timer_9_0  ;
struct timer_list *ldv_timer_list_5_3  ;
int ldv_state_variable_17  ;
int ldv_timer_9_3  ;
struct work_struct *ldv_work_struct_2_0  ;
int ldv_timer_4_3  ;
int ldv_state_variable_9  ;
int ldv_timer_6_0  ;
struct work_struct *ldv_work_struct_2_2  ;
struct timer_list *ldv_timer_list_5_1  ;
struct timer_list *ldv_timer_list_11_1  ;
int ref_cnt  ;
int ldv_work_3_3  ;
int ldv_state_variable_7  ;
struct work_struct *ldv_work_struct_3_3  ;
struct timer_list *ldv_timer_list_10_0  ;
struct timer_list *ldv_timer_list_6_3  ;
int ldv_timer_12_3  ;
struct cfg80211_pmksa *rtw_cfg80211_ops_group2  ;
int ldv_timer_8_2  ;
struct timer_list *ldv_timer_list_6_2  ;
struct timer_list *ldv_timer_list_9_2  ;
struct work_struct *ldv_work_struct_1_1  ;
int ldv_timer_9_2  ;
struct timer_list *ldv_timer_list_4_0  ;
struct timer_list *ldv_timer_list_7_3  ;
int ldv_work_1_3  ;
struct work_struct *ldv_work_struct_2_1  ;
int ldv_timer_11_2  ;
struct work_struct *ldv_work_struct_3_2  ;
int ldv_state_variable_6  ;
struct wiphy *rtw_cfg80211_ops_group3  ;
struct timer_list *ldv_timer_list_6_0  ;
int usb_counter  ;
struct timer_list *ldv_timer_list_13_3  ;
struct timer_list *ldv_timer_list_8_3  ;
int ldv_timer_7_1  ;
int ldv_timer_10_2  ;
struct timer_list *ldv_timer_list_4_3  ;
struct vif_params *rtw_cfg80211_ops_group5  ;
int ldv_timer_5_3  ;
struct timer_list *ldv_timer_list_7_0  ;
struct timer_list *ldv_timer_list_10_1  ;
int ldv_state_variable_3  ;
int ldv_timer_4_1  ;
int ldv_work_1_0  ;
struct timer_list *ldv_timer_list_4_1  ;
struct net_device *rtw_netdev_ops_group1  ;
struct timer_list *ldv_timer_list_9_0  ;
int ldv_timer_8_3  ;
int ldv_state_variable_4  ;
int ldv_work_2_1  ;
int ldv_timer_13_3  ;
int ldv_timer_7_3  ;
int ldv_state_variable_8  ;
int ldv_state_variable_15  ;
int ldv_timer_4_0  ;
struct work_struct *ldv_work_struct_1_3  ;
struct timer_list *ldv_timer_list_5_2  ;
int ldv_state_variable_5  ;
struct timer_list *ldv_timer_list_12_0  ;
int ldv_timer_11_1  ;
int ldv_state_variable_13  ;
int ldv_timer_12_0  ;
struct timer_list *ldv_timer_list_11_2  ;
int ldv_timer_12_2  ;
int ldv_work_3_2  ;
int ldv_timer_5_1  ;
struct timer_list *ldv_timer_list_7_2  ;
int ldv_work_3_0  ;
struct work_struct *ldv_work_struct_2_3  ;
struct timer_list *ldv_timer_list_6_1  ;
int ldv_timer_7_0  ;
struct timer_list *ldv_timer_list_12_3  ;
struct timer_list *ldv_timer_list_11_0  ;
struct net_device *rtw_cfg80211_ops_group6  ;
struct timer_list *ldv_timer_list_13_1  ;
int ldv_timer_13_0  ;
int ldv_state_variable_1  ;
int ldv_timer_6_3  ;
int ldv_timer_8_0  ;
int ldv_timer_10_0  ;
int ldv_timer_12_1  ;
int ldv_timer_4_2  ;
struct work_struct *ldv_work_struct_1_0  ;
struct wireless_dev *rtw_cfg80211_ops_group0  ;
int ldv_state_variable_10  ;
int ldv_timer_11_3  ;
int ldv_timer_8_1  ;
struct net_device *rtw_cfg80211_monitor_if_ops_group1  ;
int ldv_state_variable_16  ;
int ldv_work_3_1  ;
int ldv_timer_13_2  ;
int ldv_state_variable_2  ;
int ldv_timer_10_1  ;
int ldv_work_2_0  ;
struct timer_list *ldv_timer_list_13_0  ;
int ldv_timer_5_0  ;
struct timer_list *ldv_timer_list_12_2  ;
struct usb_interface *rtl8723a_usb_drv_group1  ;
struct work_struct *ldv_work_struct_3_0  ;
int ldv_state_variable_11  ;
int ldv_timer_7_2  ;
int ldv_work_1_2  ;
struct timer_list *ldv_timer_list_4_2  ;
struct timer_list *ldv_timer_list_8_0  ;
struct timer_list *ldv_timer_list_10_3  ;
struct work_struct *ldv_work_struct_1_2  ;
struct station_parameters *rtw_cfg80211_ops_group4  ;
int ldv_timer_6_1  ;
struct timer_list *ldv_timer_list_11_3  ;
int ldv_work_2_2  ;
struct timer_list *ldv_timer_list_13_2  ;
int ldv_timer_10_3  ;
int ldv_work_2_3  ;
struct timer_list *ldv_timer_list_8_2  ;
int ldv_timer_13_1  ;
struct timer_list *ldv_timer_list_9_1  ;
void ldv_usb_driver_14(void) ;
__inline static bool device_may_wakeup(struct device *dev ) 
{ 


  {
  return ((bool )((unsigned int )*((unsigned char *)dev + 524UL) != 0U && (unsigned long )dev->power.wakeup != (unsigned long )((struct wakeup_source *)0)));
}
}
extern int device_init_wakeup(struct device * , bool  ) ;
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
  return ((void *)dev->driver_data);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
  dev->driver_data = data;
  return;
}
}
extern void get_random_bytes(void * , int  ) ;
void ldv_free_netdev_715(struct net_device *dev ) ;
void ldv_free_netdev_717(struct net_device *dev ) ;
extern void netif_device_attach(struct net_device * ) ;
void ldv_unregister_netdev_716(struct net_device *dev ) ;
__inline static void eth_random_addr(u8 *addr ) 
{ 


  {
  get_random_bytes((void *)addr, 6);
  *addr = (unsigned int )*addr & 254U;
  *addr = (u8 )((unsigned int )*addr | 2U);
  return;
}
}
__inline static void *wiphy_priv___2(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3259), "i" (12UL));
    ldv_48194: ;
    goto ldv_48194;
  } else {

  }
  return ((void *)(& wiphy->priv));
}
}
__inline static void *wdev_priv___2(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3512), "i" (12UL));
    ldv_48279: ;
    goto ldv_48279;
  } else {

  }
  tmp___0 = wiphy_priv___2(wdev->wiphy);
  return (tmp___0);
}
}
__inline static int usb_endpoint_num(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  return ((int )epd->bEndpointAddress & 15);
}
}
__inline static int usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  return ((int )((signed char )epd->bEndpointAddress) < 0);
}
}
__inline static int usb_endpoint_dir_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  return ((int )((signed char )epd->bEndpointAddress) >= 0);
}
}
__inline static int usb_endpoint_xfer_bulk(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  return (((int )epd->bmAttributes & 3) == 2);
}
}
__inline static int usb_endpoint_xfer_int(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  return (((int )epd->bmAttributes & 3) == 3);
}
}
__inline static int usb_endpoint_is_bulk_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = usb_endpoint_xfer_bulk(epd);
  if (tmp != 0) {
    tmp___0 = usb_endpoint_dir_in(epd);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
__inline static int usb_endpoint_is_bulk_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = usb_endpoint_xfer_bulk(epd);
  if (tmp != 0) {
    tmp___0 = usb_endpoint_dir_out(epd);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
__inline static int usb_endpoint_is_int_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = usb_endpoint_xfer_int(epd);
  if (tmp != 0) {
    tmp___0 = usb_endpoint_dir_in(epd);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
  return (tmp);
}
}
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 


  {
  dev_set_drvdata(& intf->dev, data);
  return;
}
}
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct device  const  *__mptr ;

  {
  __mptr = (struct device  const  *)intf->dev.parent;
  return ((struct usb_device *)__mptr + 0xffffffffffffff70UL);
}
}
extern struct usb_device *usb_get_dev(struct usb_device * ) ;
extern void usb_put_dev(struct usb_device * ) ;
extern int usb_reset_device(struct usb_device * ) ;
extern int usb_autopm_get_interface(struct usb_interface * ) ;
extern void usb_autopm_put_interface(struct usb_interface * ) ;
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
int ldv_usb_register_driver_718(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                char const   *ldv_func_arg3 ) ;
extern void usb_deregister(struct usb_driver * ) ;
void ldv_usb_deregister_719(struct usb_driver *arg ) ;
void free_mlme_ap_info23a(struct rtw_adapter *padapter ) ;
void rtl8723au_write_port_cancel(struct rtw_adapter *padapter ) ;
static int rtw_suspend(struct usb_interface *pusb_intf , pm_message_t message ) ;
static int rtw_resume(struct usb_interface *pusb_intf ) ;
static int rtw_drv_init(struct usb_interface *pusb_intf , struct usb_device_id  const  *pdid ) ;
static void rtw_disconnect(struct usb_interface *pusb_intf ) ;
static struct usb_device_id rtl8723a_usb_id_tbl[4U]  = {      {899U, 3034U, 34596U, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}, 
        {899U,
      3034U, 5924U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}, 
        {899U, 3034U, 1828U, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}};
struct usb_device_id  const  __mod_usb__rtl8723a_usb_id_tbl_device_table[4U]  ;
static struct usb_driver rtl8723a_usb_drv  = 
     {"rtl8723au", & rtw_drv_init, & rtw_disconnect, 0, & rtw_suspend, & rtw_resume,
    & rtw_resume, 0, 0, (struct usb_device_id  const  *)(& rtl8723a_usb_id_tbl), {{{{{{0}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0}},
    {{0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0};
static struct usb_driver *usb_drv  =    & rtl8723a_usb_drv;
static int rtw_init_intf_priv(struct dvobj_priv *dvobj ) 
{ 
  struct lock_class_key __key ;

  {
  __mutex_init(& dvobj->usb_vendor_req_mutex, "&dvobj->usb_vendor_req_mutex", & __key);
  return (1);
}
}
static int rtw_deinit_intf_priv(struct dvobj_priv *dvobj ) 
{ 


  {
  mutex_destroy(& dvobj->usb_vendor_req_mutex);
  return (1);
}
}
static struct dvobj_priv *usb_dvobj_init(struct usb_interface *usb_intf ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_host_config *phost_conf ;
  struct usb_config_descriptor *pconf_desc ;
  struct usb_host_interface *phost_iface ;
  struct usb_interface_descriptor *piface_desc ;
  struct usb_endpoint_descriptor *pendp_desc ;
  struct usb_device *pusbd ;
  int i ;
  int status ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  status = 0;
  tmp = kzalloc(944UL, 208U);
  pdvobjpriv = (struct dvobj_priv *)tmp;
  if ((unsigned long )pdvobjpriv == (unsigned long )((struct dvobj_priv *)0)) {
    goto exit;
  } else {

  }
  __mutex_init(& pdvobjpriv->hw_init_mutex, "&pdvobjpriv->hw_init_mutex", & __key);
  __mutex_init(& pdvobjpriv->h2c_fwcmd_mutex, "&pdvobjpriv->h2c_fwcmd_mutex", & __key___0);
  __mutex_init(& pdvobjpriv->setch_mutex, "&pdvobjpriv->setch_mutex", & __key___1);
  __mutex_init(& pdvobjpriv->setbw_mutex, "&pdvobjpriv->setbw_mutex", & __key___2);
  pdvobjpriv->pusbintf = usb_intf;
  pusbd = interface_to_usbdev(usb_intf);
  pdvobjpriv->pusbdev = pusbd;
  usb_set_intfdata(usb_intf, (void *)pdvobjpriv);
  pdvobjpriv->RtNumInPipes = 0U;
  pdvobjpriv->RtNumOutPipes = 0U;
  phost_conf = pusbd->actconfig;
  pconf_desc = & phost_conf->desc;
  phost_iface = usb_intf->altsetting;
  piface_desc = & phost_iface->desc;
  pdvobjpriv->NumInterfaces = pconf_desc->bNumInterfaces;
  pdvobjpriv->InterfaceNumber = piface_desc->bInterfaceNumber;
  pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
  i = 0;
  goto ldv_55855;
  ldv_55854: 
  pendp_desc = & (phost_iface->endpoint + (unsigned long )i)->desc;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: \nusb_endpoint_descriptor(%d):\n", i);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bLength =%x\n", (int )pendp_desc->bLength);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bDescriptorType =%x\n", (int )pendp_desc->bDescriptorType);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bEndpointAddress =%x\n", (int )pendp_desc->bEndpointAddress);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: wMaxPacketSize =%d\n", (int )pendp_desc->wMaxPacketSize);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bInterval =%x\n", (int )pendp_desc->bInterval);
  } else {

  }
  tmp___5 = usb_endpoint_is_bulk_in((struct usb_endpoint_descriptor  const  *)pendp_desc);
  if (tmp___5 != 0) {
    if (GlobalDebugLevel23A > 3U) {
      tmp___0 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
      printk("\016RTL8723AU: usb_endpoint_is_bulk_in = %x\n", tmp___0);
    } else {

    }
    pdvobjpriv->RtInPipe[(int )pdvobjpriv->RtNumInPipes] = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
    pdvobjpriv->RtNumInPipes = (u8 )((int )pdvobjpriv->RtNumInPipes + 1);
  } else {
    tmp___4 = usb_endpoint_is_int_in((struct usb_endpoint_descriptor  const  *)pendp_desc);
    if (tmp___4 != 0) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___1 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
        printk("\016RTL8723AU: usb_endpoint_is_int_in = %x, Interval = %x\n", tmp___1,
               (int )pendp_desc->bInterval);
      } else {

      }
      pdvobjpriv->RtInPipe[(int )pdvobjpriv->RtNumInPipes] = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
      pdvobjpriv->RtNumInPipes = (u8 )((int )pdvobjpriv->RtNumInPipes + 1);
    } else {
      tmp___3 = usb_endpoint_is_bulk_out((struct usb_endpoint_descriptor  const  *)pendp_desc);
      if (tmp___3 != 0) {
        if (GlobalDebugLevel23A > 3U) {
          tmp___2 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
          printk("\016RTL8723AU: usb_endpoint_is_bulk_out = %x\n", tmp___2);
        } else {

        }
        pdvobjpriv->RtOutPipe[(int )pdvobjpriv->RtNumOutPipes] = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
        pdvobjpriv->RtNumOutPipes = (u8 )((int )pdvobjpriv->RtNumOutPipes + 1);
      } else {

      }
    }
  }
  pdvobjpriv->ep_num[i] = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
  i = i + 1;
  ldv_55855: ;
  if ((int )pdvobjpriv->nr_endpoint > i) {
    goto ldv_55854;
  } else {

  }

  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: nr_endpoint =%d, in_num =%d, out_num =%d\n\n", (int )pdvobjpriv->nr_endpoint,
           (int )pdvobjpriv->RtNumInPipes, (int )pdvobjpriv->RtNumOutPipes);
  } else {

  }
  if ((unsigned int )pusbd->speed == 3U) {
    pdvobjpriv->ishighspeed = 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: USB_SPEED_HIGH\n");
    } else {

    }
  } else {
    pdvobjpriv->ishighspeed = 0U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: NON USB_SPEED_HIGH\n");
    } else {

    }
  }
  tmp___6 = rtw_init_intf_priv(pdvobjpriv);
  if (tmp___6 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2048, 4, "Can\'t INIT rtw_init_intf_priv\n");
    } else {

    }
    goto free_dvobj;
  } else {

  }
  rtw_reset_continual_urb_error(pdvobjpriv);
  usb_get_dev(pusbd);
  status = 1;
  free_dvobj: ;
  if (status != 1 && (unsigned long )pdvobjpriv != (unsigned long )((struct dvobj_priv *)0)) {
    usb_set_intfdata(usb_intf, (void *)0);
    mutex_destroy(& pdvobjpriv->hw_init_mutex);
    mutex_destroy(& pdvobjpriv->h2c_fwcmd_mutex);
    mutex_destroy(& pdvobjpriv->setch_mutex);
    mutex_destroy(& pdvobjpriv->setbw_mutex);
    kfree((void const   *)pdvobjpriv);
    pdvobjpriv = (struct dvobj_priv *)0;
  } else {

  }
  exit: ;
  return (pdvobjpriv);
}
}
static void usb_dvobj_deinit(struct usb_interface *usb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct usb_device *tmp___0 ;
  struct usb_device *tmp___1 ;
  struct usb_device *tmp___2 ;

  {
  tmp = usb_get_intfdata(usb_intf);
  dvobj = (struct dvobj_priv *)tmp;
  usb_set_intfdata(usb_intf, (void *)0);
  if ((unsigned long )dvobj != (unsigned long )((struct dvobj_priv *)0)) {
    if (((unsigned int )dvobj->NumInterfaces != 2U && (unsigned int )dvobj->NumInterfaces != 3U) || (unsigned int )dvobj->InterfaceNumber == 1U) {
      tmp___1 = interface_to_usbdev(usb_intf);
      if ((unsigned int )tmp___1->state != 0U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: usb attached..., try to reset usb device\n");
        } else {

        }
        tmp___0 = interface_to_usbdev(usb_intf);
        usb_reset_device(tmp___0);
      } else {

      }
    } else {

    }
    rtw_deinit_intf_priv(dvobj);
    mutex_destroy(& dvobj->hw_init_mutex);
    mutex_destroy(& dvobj->h2c_fwcmd_mutex);
    mutex_destroy(& dvobj->setch_mutex);
    mutex_destroy(& dvobj->setbw_mutex);
    kfree((void const   *)dvobj);
  } else {

  }
  tmp___2 = interface_to_usbdev(usb_intf);
  usb_put_dev(tmp___2);
  return;
}
}
void rtl8723a_usb_intf_stop(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "+usb_intf_stop\n");
  } else {

  }
  if (padapter->bSurpriseRemoved == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1048576, 4, "SurpriseRemoved == false\n");
    } else {

    }
  } else {

  }
  rtl8723au_inirp_deinit(padapter);
  rtl8723au_write_port_cancel(padapter);
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "-usb_intf_stop\n");
  } else {

  }
  return;
}
}
static void rtw_dev_unload(struct rtw_adapter *padapter ) 
{ 
  struct submit_ctx *pack_tx_ops ;

  {
  pack_tx_ops = & padapter->xmitpriv.ack_tx_ops;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "+rtw_dev_unload\n");
  } else {

  }
  if (padapter->bup != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ===> rtw_dev_unload\n");
    } else {

    }
    padapter->bDriverStopped = 1;
    if (padapter->xmitpriv.ack_tx != 0) {
      rtw23a_sctx_done_err(& pack_tx_ops, 9);
    } else {

    }
    rtl8723a_usb_intf_stop(padapter);
    ldv_flush_workqueue_714(padapter->cmdpriv.wq);
    if (padapter->bSurpriseRemoved == 0) {
      rtl8723au_hal_deinit(padapter);
      padapter->bSurpriseRemoved = 1;
    } else {

    }
    padapter->bup = 0;
  } else
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "r871x_dev_unload():padapter->bup == false\n");
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: <=== rtw_dev_unload\n");
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "-rtw_dev_unload\n");
  } else {

  }
  return;
}
}
static int rtw_suspend(struct usb_interface *pusb_intf , pm_message_t message ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrpriv ;
  int ret ;
  unsigned long start_time ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  unsigned int tmp___7 ;

  {
  tmp = usb_get_intfdata(pusb_intf);
  dvobj = (struct dvobj_priv *)tmp;
  padapter = dvobj->if1;
  pnetdev = padapter->pnetdev;
  pmlmepriv = & padapter->mlmepriv;
  pwrpriv = & padapter->pwrctrlpriv;
  ret = 0;
  start_time = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = get_current();
    tmp___1 = get_current();
    printk("\016RTL8723AU: ==> %s (%s:%d)\n", "rtw_suspend", (char *)(& tmp___1->comm),
           tmp___0->pid);
  } else {

  }
  if ((padapter->bup == 0 || padapter->bDriverStopped != 0) || padapter->bSurpriseRemoved != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: padapter->bup =%d bDriverStopped =%d bSurpriseRemoved = %d\n",
             padapter->bup, padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
    goto exit;
  } else {

  }
  pwrpriv->bInSuspend = 1U;
  rtw_cancel_all_timer23a(padapter);
  LeaveAllPowerSaveMode23a(padapter);
  down(& pwrpriv->lock);
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
    netif_carrier_off(pnetdev);
    netif_tx_stop_all_queues(pnetdev);
  } else {

  }
  rtw_disassoc_cmd23a(padapter, 0U, 0);
  tmp___2 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___2) {
    tmp___3 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___3) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s:%d %s(%pM), length:%d assoc_ssid.length:%d\n", "rtw_suspend",
               312, (u8 *)(& pmlmepriv->cur_network.network.Ssid.ssid), (u8 *)(& pmlmepriv->cur_network.network.MacAddress),
               (int )pmlmepriv->cur_network.network.Ssid.ssid_len, (int )pmlmepriv->assoc_ssid.ssid_len);
      } else {

      }
      rtw_set_roaming(padapter, 1);
    } else {

    }
  } else {

  }
  rtw_indicate_disconnect23a(padapter);
  rtw_free_assoc_resources23a(padapter, 1);
  rtw_free_network_queue23a(padapter);
  rtw_dev_unload(padapter);
  up(& pwrpriv->lock);
  tmp___5 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___5) {
    tmp___4 = wdev_priv___2(padapter->rtw_wdev);
    rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___4, 1);
  } else {

  }
  tmp___6 = check_fwstate(pmlmepriv, 128);
  if ((int )tmp___6) {
    rtw_indicate_disconnect23a(padapter);
  } else {

  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    tmp___7 = jiffies_to_msecs((unsigned long )jiffies - start_time);
    printk("\016RTL8723AU: <===  %s return %d.............. in %dms\n", "rtw_suspend",
           ret, tmp___7);
  } else {

  }
  return (ret);
}
}
static int rtw_resume(struct usb_interface *pusb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct pwrctrl_priv *pwrpriv ;
  int ret ;
  unsigned long start_time ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  struct pid *tmp___3 ;
  unsigned int tmp___4 ;

  {
  tmp = usb_get_intfdata(pusb_intf);
  dvobj = (struct dvobj_priv *)tmp;
  padapter = dvobj->if1;
  pwrpriv = (struct pwrctrl_priv *)0;
  ret = -1;
  start_time = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = get_current();
    tmp___1 = get_current();
    printk("\016RTL8723AU: ==> %s (%s:%d)\n", "rtw_resume", (char *)(& tmp___1->comm),
           tmp___0->pid);
  } else {

  }
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    goto exit;
  } else {

  }
  pnetdev = padapter->pnetdev;
  pwrpriv = & padapter->pwrctrlpriv;
  down(& pwrpriv->lock);
  rtw_reset_drv_sw23a(padapter);
  pwrpriv->bkeepfwalive = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bkeepfwalive(%x)\n", (int )pwrpriv->bkeepfwalive);
  } else {

  }
  tmp___2 = pm_netdev_open23a(pnetdev, 1);
  if (tmp___2 != 0) {
    up(& pwrpriv->lock);
    goto exit;
  } else {

  }
  netif_device_attach(pnetdev);
  netif_carrier_on(pnetdev);
  up(& pwrpriv->lock);
  if (padapter->pid[1] != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pid[1]:%d\n", padapter->pid[1]);
    } else {

    }
    tmp___3 = find_vpid(padapter->pid[1]);
    kill_pid(tmp___3, 12, 1);
  } else {

  }
  rtw23a_roaming(padapter, (struct wlan_network *)0);
  ret = 0;
  exit: ;
  if ((unsigned long )pwrpriv != (unsigned long )((struct pwrctrl_priv *)0)) {
    pwrpriv->bInSuspend = 0U;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    tmp___4 = jiffies_to_msecs((unsigned long )jiffies - start_time);
    printk("\016RTL8723AU: <===  %s return %d.............. in %dms\n", "rtw_resume",
           ret, tmp___4);
  } else {

  }
  return (ret);
}
}
static struct rtw_adapter *rtw_usb_if1_init(struct dvobj_priv *dvobj , struct usb_interface *pusb_intf ,
                                            struct usb_device_id  const  *pdid ) 
{ 
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  int status ;
  void *tmp ;
  u8 tmp___0 ;
  struct device *tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;

  {
  padapter = (struct rtw_adapter *)0;
  pnetdev = (struct net_device *)0;
  status = 0;
  pnetdev = rtw_init_netdev23a(padapter);
  if ((unsigned long )pnetdev == (unsigned long )((struct net_device *)0)) {
    goto free_adapter;
  } else {

  }
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  padapter->dvobj = dvobj;
  padapter->bDriverStopped = 1;
  dvobj->if1 = padapter;
  tmp___0 = dvobj->iface_nums;
  dvobj->iface_nums = (u8 )((int )dvobj->iface_nums + 1);
  dvobj->padapters[(int )tmp___0] = padapter;
  padapter->iface_id = 0U;
  rtl8723au_set_hw_type(padapter);
  pnetdev->dev.parent = dvobj_to_dev(dvobj);
  tmp___1 = dvobj_to_dev(dvobj);
  tmp___2 = rtw_wdev_alloc(padapter, tmp___1);
  if (tmp___2 != 0) {
    goto free_adapter;
  } else {

  }
  padapter->HalData = kzalloc(8032UL, 208U);
  if ((unsigned long )padapter->HalData == (unsigned long )((void *)0)) {
    goto free_wdev;
  } else {

  }
  rtl8723a_read_chip_version(padapter);
  tmp___3 = rtl8723au_chip_configure(padapter);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    goto free_hal_data;
  } else {

  }
  rtl8723a_read_adapter_info(padapter);
  tmp___5 = rtw_init_drv_sw23a(padapter);
  if (tmp___5 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1048576, 4, "Initialize driver software resource Failed!\n");
    } else {

    }
    goto free_hal_data;
  } else {

  }
  if ((unsigned int )padapter->pwrctrlpriv.bSupportRemoteWakeup != 0U) {
    (dvobj->pusbdev)->do_remote_wakeup = 1U;
    pusb_intf->needs_remote_wakeup = 1U;
    device_init_wakeup(& pusb_intf->dev, 1);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~~~~\n");
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      tmp___6 = device_may_wakeup(& pusb_intf->dev);
      printk("\016RTL8723AU: \n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~[%d]~~~\n",
             (int )tmp___6);
    } else {

    }
  } else {

  }
  tmp___7 = usb_autopm_get_interface(pusb_intf);
  if (tmp___7 < 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: can\'t get autopm:\n");
    } else {

    }
  } else {

  }
  padapter->pwrctrlpriv.autopm_cnt = 1U;
  tmp___8 = is_broadcast_ether_addr((u8 const   *)(& padapter->eeprompriv.mac_addr));
  if ((int )tmp___8) {
    eth_random_addr((u8 *)(& padapter->eeprompriv.mac_addr));
  } else {
    tmp___9 = is_zero_ether_addr((u8 const   *)(& padapter->eeprompriv.mac_addr));
    if ((int )tmp___9) {
      eth_random_addr((u8 *)(& padapter->eeprompriv.mac_addr));
    } else {

    }
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bDriverStopped:%d, bSurpriseRemoved:%d, bup:%d, hw_init_completed:%d\n",
           padapter->bDriverStopped, padapter->bSurpriseRemoved, padapter->bup, (int )padapter->hw_init_completed);
  } else {

  }
  status = 1;
  free_hal_data: ;
  if (status != 1) {
    kfree((void const   *)padapter->HalData);
  } else {

  }
  free_wdev: ;
  if (status != 1) {
    rtw_wdev_unregister(padapter->rtw_wdev);
    rtw_wdev_free(padapter->rtw_wdev);
  } else {

  }
  free_adapter: ;
  if (status != 1) {
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
      ldv_free_netdev_715(pnetdev);
    } else {

    }
    padapter = (struct rtw_adapter *)0;
  } else {

  }
  return (padapter);
}
}
static void rtw_usb_if1_deinit(struct rtw_adapter *if1 ) 
{ 
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
  pnetdev = if1->pnetdev;
  pmlmepriv = & if1->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    rtw_disassoc_cmd23a(if1, 0U, 0);
  } else {

  }
  free_mlme_ap_info23a(if1);
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
    ldv_unregister_netdev_716(pnetdev);
  } else {

  }
  rtw_cancel_all_timer23a(if1);
  rtw_dev_unload(if1);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +r871xu_dev_remove, hw_init_completed =%d\n", (int )if1->hw_init_completed);
  } else {

  }
  if ((unsigned long )if1->rtw_wdev != (unsigned long )((struct wireless_dev *)0)) {
    rtw_wdev_unregister(if1->rtw_wdev);
    rtw_wdev_free(if1->rtw_wdev);
  } else {

  }
  if ((unsigned int )if1->pwrctrlpriv.autopm_cnt == 1U) {
    usb_autopm_put_interface((if1->dvobj)->pusbintf);
    if1->pwrctrlpriv.autopm_cnt = (u8 )((int )if1->pwrctrlpriv.autopm_cnt - 1);
  } else {

  }
  rtw_free_drv_sw23a(if1);
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
    ldv_free_netdev_717(pnetdev);
  } else {

  }
  return;
}
}
static int rtw_drv_init(struct usb_interface *pusb_intf , struct usb_device_id  const  *pdid ) 
{ 
  struct rtw_adapter *if1 ;
  struct dvobj_priv *dvobj ;
  int status ;

  {
  if1 = (struct rtw_adapter *)0;
  status = 0;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "+rtw_drv_init\n");
  } else {

  }
  dvobj = usb_dvobj_init(pusb_intf);
  if ((unsigned long )dvobj == (unsigned long )((struct dvobj_priv *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(1048576, 4, "initialize device object priv Failed!\n");
    } else {

    }
    goto exit;
  } else {

  }
  if1 = rtw_usb_if1_init(dvobj, pusb_intf, pdid);
  if ((unsigned long )if1 == (unsigned long )((struct rtw_adapter *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_init_primary_adapter Failed!\n");
    } else {

    }
    goto free_dvobj;
  } else {

  }
  status = rtw_drv_register_netdev(if1);
  if (status != 1) {
    goto free_if1;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "-871x_drv - drv_init, success!\n");
  } else {

  }
  status = 1;
  free_if1: ;
  if (status != 1 && (unsigned long )if1 != (unsigned long )((struct rtw_adapter *)0)) {
    rtw_usb_if1_deinit(if1);
  } else {

  }
  free_dvobj: ;
  if (status != 1) {
    usb_dvobj_deinit(pusb_intf);
  } else {

  }
  exit: ;
  return (status == 1 ? 0 : -19);
}
}
static void rtw_disconnect(struct usb_interface *pusb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  void *tmp ;

  {
  tmp = usb_get_intfdata(pusb_intf);
  dvobj = (struct dvobj_priv *)tmp;
  if ((unsigned long )dvobj == (unsigned long )((struct dvobj_priv *)0)) {
    return;
  } else {

  }
  padapter = dvobj->if1;
  pnetdev = padapter->pnetdev;
  pmlmepriv = & padapter->mlmepriv;
  usb_set_intfdata(pusb_intf, (void *)0);
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "+dev_remove()\n");
  } else {

  }
  rtw_pm_set_ips23a(padapter, 0);
  rtw_pm_set_lps23a(padapter, 0);
  LeaveAllPowerSaveMode23a(padapter);
  rtw_usb_if1_deinit(padapter);
  usb_dvobj_deinit(pusb_intf);
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "-dev_remove()\n");
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -r871xu_dev_remove, done\n");
  } else {

  }
  return;
}
}
static int rtw_drv_entry(void) 
{ 
  int tmp ;

  {
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "+rtw_drv_entry\n");
  } else {

  }
  tmp = ldv_usb_register_driver_718(usb_drv, & __this_module, "r8723au");
  return (tmp);
}
}
static void rtw_drv_halt(void) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(1048576, 4, "+rtw_drv_halt\n");
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +rtw_drv_halt\n");
  } else {

  }
  ldv_usb_deregister_719(usb_drv);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -rtw_drv_halt\n");
  } else {

  }
  return;
}
}
int ldv_retval_5  ;
int ldv_retval_4  ;
int ldv_retval_6  ;
extern void ldv_initialize(void) ;
void ldv_check_final_state(void) ;
int ldv_retval_2  ;
void ldv_usb_driver_14(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(1560UL);
  rtl8723a_usb_drv_group1 = (struct usb_interface *)tmp;
  return;
}
}
int main(void) 
{ 
  struct usb_device_id *ldvarg47 ;
  void *tmp ;
  pm_message_t ldvarg46 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(32UL);
  ldvarg47 = (struct usb_device_id *)tmp;
  ldv_initialize();
  ldv_memset((void *)(& ldvarg46), 0, 4UL);
  timer_init_11();
  ldv_state_variable_11 = 1;
  timer_init_7();
  ldv_state_variable_7 = 1;
  ldv_state_variable_17 = 0;
  work_init_2();
  ldv_state_variable_2 = 1;
  work_init_1();
  ldv_state_variable_1 = 1;
  ref_cnt = 0;
  ldv_state_variable_0 = 1;
  ldv_state_variable_16 = 0;
  timer_init_13();
  ldv_state_variable_13 = 1;
  timer_init_6();
  ldv_state_variable_6 = 1;
  work_init_3();
  ldv_state_variable_3 = 1;
  timer_init_9();
  ldv_state_variable_9 = 1;
  timer_init_12();
  ldv_state_variable_12 = 1;
  ldv_state_variable_14 = 0;
  ldv_state_variable_15 = 0;
  timer_init_8();
  ldv_state_variable_8 = 1;
  timer_init_4();
  ldv_state_variable_4 = 1;
  timer_init_10();
  ldv_state_variable_10 = 1;
  timer_init_5();
  ldv_state_variable_5 = 1;
  ldv_56002: 
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  goto ldv_55971;
  case 1: ;
  goto ldv_55971;
  case 2: ;
  if (ldv_state_variable_17 != 0) {
    ldv_main_exported_17();
  } else {

  }
  goto ldv_55971;
  case 3: ;
  goto ldv_55971;
  case 4: ;
  goto ldv_55971;
  case 5: ;
  if (ldv_state_variable_0 != 0) {
    tmp___1 = __VERIFIER_nondet_int();
    switch (tmp___1) {
    case 0: ;
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
      rtw_drv_halt();
      ldv_state_variable_0 = 3;
      goto ldv_final;
    } else {

    }
    goto ldv_55979;
    case 1: ;
    if (ldv_state_variable_0 == 1) {
      ldv_retval_2 = rtw_drv_entry();
      if (ldv_retval_2 != 0) {
        ldv_state_variable_0 = 3;
        goto ldv_final;
      } else {

      }
      if (ldv_retval_2 == 0) {
        ldv_state_variable_0 = 2;
        ldv_state_variable_16 = 1;
        ldv_initialize_cfg80211_ops_16();
      } else {

      }
    } else {

    }
    goto ldv_55979;
    default: 
    ldv_stop();
    }
    ldv_55979: ;
  } else {

  }
  goto ldv_55971;
  case 6: ;
  if (ldv_state_variable_16 != 0) {
    ldv_main_exported_16();
  } else {

  }
  goto ldv_55971;
  case 7: ;
  goto ldv_55971;
  case 8: ;
  goto ldv_55971;
  case 9: ;
  goto ldv_55971;
  case 10: ;
  goto ldv_55971;
  case 11: ;
  goto ldv_55971;
  case 12: ;
  if (ldv_state_variable_14 != 0) {
    tmp___2 = __VERIFIER_nondet_int();
    switch (tmp___2) {
    case 0: ;
    if (ldv_state_variable_14 == 1) {
      ldv_retval_6 = rtw_drv_init(rtl8723a_usb_drv_group1, (struct usb_device_id  const  *)ldvarg47);
      if (ldv_retval_6 == 0) {
        ldv_state_variable_14 = 2;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_55990;
    case 1: ;
    if (ldv_state_variable_14 == 2) {
      rtw_suspend(rtl8723a_usb_drv_group1, ldvarg46);
      ldv_state_variable_14 = 3;
    } else {

    }
    goto ldv_55990;
    case 2: ;
    if (ldv_state_variable_14 == 3) {
      ldv_retval_5 = rtw_resume(rtl8723a_usb_drv_group1);
      if (ldv_retval_5 == 0) {
        ldv_state_variable_14 = 2;
      } else {

      }
    } else {

    }
    goto ldv_55990;
    case 3: ;
    if (ldv_state_variable_14 == 3) {
      ldv_retval_4 = rtw_resume(rtl8723a_usb_drv_group1);
      if (ldv_retval_4 == 0) {
        ldv_state_variable_14 = 2;
      } else {

      }
    } else {

    }
    goto ldv_55990;
    case 4: ;
    if (ldv_state_variable_14 == 3 && usb_counter == 0) {
      rtw_disconnect(rtl8723a_usb_drv_group1);
      ldv_state_variable_14 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    if (ldv_state_variable_14 == 2 && usb_counter == 0) {
      rtw_disconnect(rtl8723a_usb_drv_group1);
      ldv_state_variable_14 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    goto ldv_55990;
    default: 
    ldv_stop();
    }
    ldv_55990: ;
  } else {

  }
  goto ldv_55971;
  case 13: ;
  if (ldv_state_variable_15 != 0) {
    ldv_main_exported_15();
  } else {

  }
  goto ldv_55971;
  case 14: ;
  goto ldv_55971;
  case 15: ;
  goto ldv_55971;
  case 16: ;
  goto ldv_55971;
  case 17: ;
  goto ldv_55971;
  default: 
  ldv_stop();
  }
  ldv_55971: ;
  goto ldv_56002;
  ldv_final: 
  ldv_check_final_state();
  return 0;
}
}
bool ldv_queue_work_on_709(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_710(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_711(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_712(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_713(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_714(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
void ldv_free_netdev_715(struct net_device *dev ) 
{ 


  {
  free_netdev(dev);
  ldv_state_variable_17 = 0;
  return;
}
}
void ldv_unregister_netdev_716(struct net_device *dev ) 
{ 


  {
  unregister_netdev(dev);
  ldv_state_variable_17 = 0;
  return;
}
}
void ldv_free_netdev_717(struct net_device *dev ) 
{ 


  {
  free_netdev(dev);
  ldv_state_variable_17 = 0;
  return;
}
}
int ldv_usb_register_driver_718(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  ldv_state_variable_14 = 1;
  usb_counter = 0;
  ldv_usb_driver_14();
  return (ldv_func_res);
}
}
void ldv_usb_deregister_719(struct usb_driver *arg ) 
{ 


  {
  usb_deregister(arg);
  ldv_state_variable_14 = 0;
  return;
}
}
bool ldv_queue_work_on_735(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_737(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_736(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_739(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_738(struct workqueue_struct *ldv_func_arg1 ) ;
extern void usb_kill_urb(struct urb * ) ;
void rtl8723au_read_port_cancel(struct rtw_adapter *padapter ) 
{ 
  struct recv_buf *precvbuf ;
  int i ;

  {
  precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtl8723au_read_port_cancel");
  } else {

  }
  padapter->bReadPortCancel = 1U;
  i = 0;
  goto ldv_55751;
  ldv_55750: ;
  if ((unsigned long )precvbuf->purb != (unsigned long )((struct urb *)0)) {
    usb_kill_urb(precvbuf->purb);
  } else {

  }
  precvbuf = precvbuf + 1;
  i = i + 1;
  ldv_55751: ;
  if (i <= 3) {
    goto ldv_55750;
  } else {

  }
  usb_kill_urb(padapter->recvpriv.int_in_urb);
  return;
}
}
static void usb_write_port23a_complete(struct urb *purb ) 
{ 
  struct xmit_buf *pxmitbuf ;
  struct rtw_adapter *padapter ;
  struct xmit_priv *pxmitpriv ;
  struct hal_data_8723a *phaldata ;
  unsigned long irqL ;
  raw_spinlock_t *tmp ;

  {
  pxmitbuf = (struct xmit_buf *)purb->context;
  padapter = pxmitbuf->padapter;
  pxmitpriv = & padapter->xmitpriv;
  switch ((int )pxmitbuf->flags) {
  case 6: 
  rtw_chk_hi_queue_cmd23a(padapter);
  goto ldv_55762;
  default: ;
  goto ldv_55762;
  }
  ldv_55762: ;
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bWritePortCancel != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_write_port23a_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",
               padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->ext_tag(%x)\n",
             "usb_write_port23a_complete", padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel, (int )pxmitbuf->ext_tag);
    } else {

    }
    goto check_completion;
  } else {

  }
  if (purb->status != 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_write_port23a_complete : purb->status(%d) != 0\n",
               purb->status);
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ###=> urb_write_port_complete status(%d)\n", purb->status);
    } else {

    }
    if (purb->status == -32 || purb->status == -71) {

    } else
    if (purb->status == -115) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16777216, 4, "usb_write_port23a_complete: EINPROGESS\n");
      } else {

      }
      goto check_completion;
    } else
    if (purb->status == -2) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s: -ENOENT\n", "usb_write_port23a_complete");
      } else {

      }
      goto check_completion;
    } else
    if (purb->status == -104) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s: -ECONNRESET\n", "usb_write_port23a_complete");
      } else {

      }
      goto check_completion;
    } else
    if (purb->status == -108) {
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16777216, 4, "usb_write_port23a_complete: ESHUTDOWN\n");
      } else {

      }
      padapter->bDriverStopped = 1;
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16777216, 4, "usb_write_port23a_complete:bDriverStopped = true\n");
      } else {

      }
      goto check_completion;
    } else {
      padapter->bSurpriseRemoved = 1;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: bSurpriseRemoved = true\n");
      } else {

      }
      if (GlobalDebugLevel23A > 3U) {
        rt_trace(16777216, 4, "usb_write_port23a_complete:bSurpriseRemoved = true\n");
      } else {

      }
      goto check_completion;
    }
  } else {

  }
  phaldata = (struct hal_data_8723a *)padapter->HalData;
  phaldata->srestpriv.last_tx_complete_time = jiffies;
  check_completion: 
  tmp = spinlock_check(& pxmitpriv->lock_sctx);
  irqL = _raw_spin_lock_irqsave(tmp);
  rtw23a_sctx_done_err(& pxmitbuf->sctx, purb->status != 0 ? 5 : 0);
  spin_unlock_irqrestore(& pxmitpriv->lock_sctx, irqL);
  rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
  tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  return;
}
}
int rtl8723au_write_port(struct rtw_adapter *padapter , u32 addr , u32 cnt , struct xmit_buf *pxmitbuf ) 
{ 
  struct urb *purb ;
  struct dvobj_priv *pdvobj ;
  struct xmit_priv *pxmitpriv ;
  struct xmit_frame *pxmitframe ;
  struct usb_device *pusbd ;
  unsigned long irqL ;
  unsigned int pipe ;
  unsigned int ep_num ;
  int status ;
  int ret ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  struct hal_data_8723a *phaldata ;

  {
  purb = (struct urb *)0;
  pdvobj = padapter->dvobj;
  pxmitpriv = & padapter->xmitpriv;
  pusbd = pdvobj->pusbdev;
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16777216, 4, "+usb_write_port23a\n");
  } else {

  }
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "%s:(padapter->bDriverStopped || padapter->bSurpriseRemoved)!!!\n",
               "rtl8723au_write_port");
    } else {

    }
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 7);
    goto exit;
  } else {

  }
  pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
  tmp = spinlock_check(& pxmitpriv->lock);
  irqL = _raw_spin_lock_irqsave(tmp);
  switch (addr) {
  case 0U: 
  pxmitbuf->flags = 0U;
  goto ldv_55791;
  case 1U: 
  pxmitbuf->flags = 1U;
  goto ldv_55791;
  case 2U: 
  pxmitbuf->flags = 2U;
  goto ldv_55791;
  case 3U: 
  pxmitbuf->flags = 3U;
  goto ldv_55791;
  case 6U: 
  pxmitbuf->flags = 6U;
  goto ldv_55791;
  default: 
  pxmitbuf->flags = 5U;
  goto ldv_55791;
  }
  ldv_55791: 
  spin_unlock_irqrestore(& pxmitpriv->lock, irqL);
  purb = pxmitbuf->pxmit_urb[0];
  ep_num = (unsigned int )pdvobj->Queue2Pipe[addr];
  tmp___0 = __create_pipe(pusbd, ep_num);
  pipe = tmp___0 | 3221225472U;
  usb_fill_bulk_urb(purb, pusbd, pipe, (void *)pxmitframe->buf_addr, (int )cnt, & usb_write_port23a_complete,
                    (void *)pxmitbuf);
  status = usb_submit_urb(purb, 32U);
  if (status == 0) {
    phaldata = (struct hal_data_8723a *)padapter->HalData;
    phaldata->srestpriv.last_tx_time = jiffies;
  } else {
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 5);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: usb_write_port23a, status =%d\n", status);
    } else {

    }
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(16777216, 4, "usb_write_port23a(): usb_submit_urb, status =%x\n", status);
    } else {

    }
    switch (status) {
    case -19: 
    padapter->bDriverStopped = 1;
    goto ldv_55799;
    default: ;
    goto ldv_55799;
    }
    ldv_55799: ;
    goto exit;
  }
  ret = 1;
  if (GlobalDebugLevel23A > 3U) {
    rt_trace(16777216, 4, "-usb_write_port23a\n");
  } else {

  }
  exit: ;
  if (ret != 1) {
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
  } else {

  }
  return (ret);
}
}
void rtl8723au_write_port_cancel(struct rtw_adapter *padapter ) 
{ 
  struct xmit_buf *pxmitbuf ;
  struct list_head *plist ;
  int j ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtl8723au_write_port_cancel");
  } else {

  }
  padapter->bWritePortCancel = 1U;
  plist = padapter->xmitpriv.xmitbuf_list.next;
  goto ldv_55814;
  ldv_55813: 
  __mptr = (struct list_head  const  *)plist;
  pxmitbuf = (struct xmit_buf *)__mptr + 0xfffffffffffffff0UL;
  j = 0;
  goto ldv_55811;
  ldv_55810: ;
  if ((unsigned long )pxmitbuf->pxmit_urb[j] != (unsigned long )((struct urb *)0)) {
    usb_kill_urb(pxmitbuf->pxmit_urb[j]);
  } else {

  }
  j = j + 1;
  ldv_55811: ;
  if (j <= 7) {
    goto ldv_55810;
  } else {

  }
  plist = plist->next;
  ldv_55814: ;
  if ((unsigned long )(& padapter->xmitpriv.xmitbuf_list) != (unsigned long )plist) {
    goto ldv_55813;
  } else {

  }
  plist = padapter->xmitpriv.xmitextbuf_list.next;
  goto ldv_55822;
  ldv_55821: 
  __mptr___0 = (struct list_head  const  *)plist;
  pxmitbuf = (struct xmit_buf *)__mptr___0 + 0xfffffffffffffff0UL;
  j = 0;
  goto ldv_55819;
  ldv_55818: ;
  if ((unsigned long )pxmitbuf->pxmit_urb[j] != (unsigned long )((struct urb *)0)) {
    usb_kill_urb(pxmitbuf->pxmit_urb[j]);
  } else {

  }
  j = j + 1;
  ldv_55819: ;
  if (j <= 7) {
    goto ldv_55818;
  } else {

  }
  plist = plist->next;
  ldv_55822: ;
  if ((unsigned long )(& padapter->xmitpriv.xmitextbuf_list) != (unsigned long )plist) {
    goto ldv_55821;
  } else {

  }

  return;
}
}
bool ldv_queue_work_on_735(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_736(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_737(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_738(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_739(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  return;
}
}
bool ldv_queue_work_on_749(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_751(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_750(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_753(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_752(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static u16 skb_get_queue_mapping(struct sk_buff  const  *skb ) 
{ 


  {
  return ((u16 )skb->queue_mapping);
}
}
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 


  {
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
  return;
}
}
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
  txq = tmp;
  netif_tx_stop_queue(txq);
  return;
}
}
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
  txq = tmp;
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
  return (tmp___0);
}
}
extern void netif_wake_subqueue(struct net_device * , u16  ) ;
int rtw_os_xmit_resource_alloc23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ,
                                  u32 alloc_sz ) 
{ 
  int i ;
  void *tmp ;

  {
  tmp = kzalloc((size_t )alloc_sz, 208U);
  pxmitbuf->pallocated_buf = (u8 *)tmp;
  if ((unsigned long )pxmitbuf->pallocated_buf == (unsigned long )((u8 *)0U)) {
    return (0);
  } else {

  }
  pxmitbuf->pbuf = (u8 *)(((unsigned long )pxmitbuf->pallocated_buf + 511UL) & 0xfffffffffffffe00UL);
  i = 0;
  goto ldv_53181;
  ldv_53180: 
  pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, 208U);
  if ((unsigned long )pxmitbuf->pxmit_urb[i] == (unsigned long )((struct urb *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pxmitbuf->pxmit_urb[i]==NULL");
    } else {

    }
    return (0);
  } else {

  }
  i = i + 1;
  ldv_53181: ;
  if (i <= 7) {
    goto ldv_53180;
  } else {

  }

  return (1);
}
}
void rtw_os_xmit_resource_free23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_53189;
  ldv_53188: 
  usb_free_urb(pxmitbuf->pxmit_urb[i]);
  i = i + 1;
  ldv_53189: ;
  if (i <= 7) {
    goto ldv_53188;
  } else {

  }
  kfree((void const   *)pxmitbuf->pallocated_buf);
  return;
}
}
void rtw_os_pkt_complete23a(struct rtw_adapter *padapter , struct sk_buff *pkt ) 
{ 
  struct xmit_priv *pxmitpriv ;
  u16 queue ;
  bool tmp ;
  bool tmp___0 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  queue = skb_get_queue_mapping((struct sk_buff  const  *)pkt);
  if ((unsigned int )padapter->registrypriv.wifi_spec != 0U) {
    tmp = __netif_subqueue_stopped((struct net_device  const  *)padapter->pnetdev,
                                   (int )queue);
    if ((int )tmp && (pxmitpriv->hwxmits + (unsigned long )queue)->accnt <= 101) {
      netif_wake_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else {
    tmp___0 = __netif_subqueue_stopped((struct net_device  const  *)padapter->pnetdev,
                                       (int )queue);
    if ((int )tmp___0) {
      netif_wake_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  }
  dev_kfree_skb_any(pkt);
  return;
}
}
void rtw_os_xmit_complete23a(struct rtw_adapter *padapter , struct xmit_frame *pxframe ) 
{ 


  {
  if ((unsigned long )pxframe->pkt != (unsigned long )((struct sk_buff *)0)) {
    rtw_os_pkt_complete23a(padapter, pxframe->pkt);
  } else {

  }
  pxframe->pkt = (struct sk_buff *)0;
  return;
}
}
void rtw_os_xmit_schedule23a(struct rtw_adapter *padapter ) 
{ 
  struct xmit_priv *pxmitpriv ;
  s32 tmp ;

  {
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {

  }
  pxmitpriv = & padapter->xmitpriv;
  spin_lock_bh(& pxmitpriv->lock);
  tmp = rtw_txframes_pending23a(padapter);
  if (tmp != 0) {
    tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  } else {

  }
  spin_unlock_bh(& pxmitpriv->lock);
  return;
}
}
static void rtw_check_xmit_resource(struct rtw_adapter *padapter , struct sk_buff *pkt ) 
{ 
  struct xmit_priv *pxmitpriv ;
  u16 queue ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  pxmitpriv = & padapter->xmitpriv;
  queue = skb_get_queue_mapping((struct sk_buff  const  *)pkt);
  if ((unsigned int )padapter->registrypriv.wifi_spec != 0U) {
    if ((pxmitpriv->hwxmits + (unsigned long )queue)->accnt > 102) {
      netif_stop_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else
  if (pxmitpriv->free_xmitframe_cnt <= 4) {
    tmp = netdev_get_tx_queue((struct net_device  const  *)padapter->pnetdev, (unsigned int )queue);
    tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      netif_stop_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else {

  }
  return;
}
}
int rtw_xmit23a_entry23a(struct sk_buff *skb , struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  int tmp___0 ;

  {
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  pxmitpriv = & padapter->xmitpriv;
  res = 0;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(16, 7, "+xmit_enry\n");
  } else {

  }
  tmp___0 = rtw_if_up23a(padapter);
  if (tmp___0 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      rt_trace(2, 4, "rtw_xmit23a_entry23a: rtw_if_up23a fail\n");
    } else {

    }
    goto drop_packet;
  } else {

  }
  rtw_check_xmit_resource(padapter, skb);
  res = rtw_xmit23a(padapter, skb);
  if (res < 0) {
    goto drop_packet;
  } else {

  }
  pxmitpriv->tx_pkts = pxmitpriv->tx_pkts + 1ULL;
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(2, 7, "rtw_xmit23a_entry23a: tx_pkts=%d\n", (unsigned int )pxmitpriv->tx_pkts);
  } else {

  }
  goto exit;
  drop_packet: 
  pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
  dev_kfree_skb_any(skb);
  if (GlobalDebugLevel23A > 5U) {
    rt_trace(2, 6, "rtw_xmit23a_entry23a: drop, tx_drop=%d\n", (unsigned int )pxmitpriv->tx_drop);
  } else {

  }
  exit: ;
  return (0);
}
}
bool ldv_queue_work_on_749(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_750(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_751(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_752(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_753(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_768(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_773(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_775(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_783(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_769(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_770(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_771(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_772(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_774(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_776(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_777(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_778(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_779(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_780(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_781(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_782(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_784(struct timer_list *ldv_func_arg1 ) ;
bool ldv_queue_work_on_763(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_765(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_764(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_767(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_766(struct workqueue_struct *ldv_func_arg1 ) ;
void BT_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
void BTHCI_EventParse(struct rtw_adapter *padapter , void *pEvntData , u32 dataLen ) ;
u8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter ) ;
void BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter ) ;
void BTHCI_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) ;
void BTHCI_StateMachine(struct rtw_adapter *padapter , u8 StateToEnter , enum hci_state_with_cmd StateCmd ,
                        u8 EntryNum ) ;
void BTHCI_DisconnectPeer(struct rtw_adapter *padapter , u8 EntryNum ) ;
void BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter ) ;
void BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter , u8 AMP_Status ) ;
void BTHCI_DisconnectAll(struct rtw_adapter *padapter ) ;
enum hci_status BTHCI_HandleHCICMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) ;
void BTDM_1AntSignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
void BTDM_1AntForDhcp(struct rtw_adapter *padapter ) ;
void BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter ) ;
void BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter ) ;
void BTDM_SetFwChnlInfo(struct rtw_adapter *padapter , enum rt_media_status mstatus ) ;
u8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter ) ;
void BTDM_SetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 , u8 byte3 ,
                  u8 byte4 , u8 byte5 ) ;
void BTDM_QueryBtInformation(struct rtw_adapter *padapter ) ;
void BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter , u8 type ) ;
void BTDM_SetSwPenaltyTxRateAdaptive(struct rtw_adapter *padapter , u8 raType ) ;
void BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) ;
u8 BTDM_BtProfileSupport(struct rtw_adapter *padapter ) ;
void BTDM_SingleAnt(struct rtw_adapter *padapter , u8 bSingleAntOn , u8 bInterruptOn ,
                    u8 bMultiNAVOn ) ;
void BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter ) ;
void BTDM_DiminishWiFi(struct rtw_adapter *padapter , u8 bDACOn , u8 bInterruptOn ,
                       u8 DACSwingLevel , u8 bNAVOn ) ;
void BTDM_CheckAntSelMode(struct rtw_adapter *padapter ) ;
void BTDM_FwC2hBtRssi(struct rtw_adapter *padapter , u8 *tmpBuf ) ;
void BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter ) ;
void BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter , u8 bReject ) ;
u8 BTDM_IsHT40(struct rtw_adapter *padapter ) ;
u8 BTDM_Legacy(struct rtw_adapter *padapter ) ;
void BTDM_CheckWiFiState(struct rtw_adapter *padapter ) ;
s32 BTDM_GetRxSS(struct rtw_adapter *padapter ) ;
u8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                              u8 RssiThresh1 ) ;
u8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                            u8 RssiThresh1 ) ;
u8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                           u8 RssiThresh1 ) ;
void BTDM_Balance(struct rtw_adapter *padapter , u8 bBalanceOn , u8 ms0 , u8 ms1 ) ;
void BTDM_AGCTable(struct rtw_adapter *padapter , u8 type ) ;
void BTDM_BBBackOffLevel(struct rtw_adapter *padapter , u8 type ) ;
void BTDM_FWCoexAllOff(struct rtw_adapter *padapter ) ;
void BTDM_SWCoexAllOff(struct rtw_adapter *padapter ) ;
void BTDM_HWCoexAllOff(struct rtw_adapter *padapter ) ;
void BTDM_CoexAllOff(struct rtw_adapter *padapter ) ;
void BTDM_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
void BTDM_UpdateCoexState(struct rtw_adapter *padapter ) ;
u8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter ) ;
void BTDM_PWDBMonitor(struct rtw_adapter *padapter ) ;
u8 BTDM_IsBTBusy(struct rtw_adapter *padapter ) ;
u8 BTDM_IsWifiBusy(struct rtw_adapter *padapter ) ;
u8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter ) ;
u8 BTDM_IsWifiUplink(struct rtw_adapter *padapter ) ;
u8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter ) ;
u8 BTDM_IsBTHSMode(struct rtw_adapter *padapter ) ;
u8 BTDM_IsBTUplink(struct rtw_adapter *padapter ) ;
u8 BTDM_IsBTDownlink(struct rtw_adapter *padapter ) ;
void BTDM_AdjustForBtOperation(struct rtw_adapter *padapter ) ;
void BTDM_ForHalt(struct rtw_adapter *padapter ) ;
void BTDM_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) ;
void BTDM_WifiAssociateNotify(struct rtw_adapter *padapter , u8 action ) ;
void BTDM_ResetActionProfileState(struct rtw_adapter *padapter ) ;
void BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) ;
u8 BTDM_IsActionSCO(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionHID(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionA2DP(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionPAN(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter ) ;
u32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter ) ;
u32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter ) ;
u8 HALBT_GetPGAntNum(struct rtw_adapter *padapter ) ;
void HALBT_SetKey(struct rtw_adapter *padapter , u8 EntryNum ) ;
void HALBT_RemoveKey(struct rtw_adapter *padapter , u8 EntryNum ) ;
u8 HALBT_BTChipType(struct rtw_adapter *padapter ) ;
void HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter ) ;
u32 BTCoexDbgLevel ;
u32 BTCoexDbgLevel  =    0U;
static u8 BT_Operation(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
static u8 BT_IsLegalChannel(struct rtw_adapter *padapter , u8 channel ) 
{ 
  struct rt_channel_info *pChanneList ;
  u8 channelLen ;
  u8 i ;

  {
  pChanneList = (struct rt_channel_info *)0;
  pChanneList = (struct rt_channel_info *)(& padapter->mlmeextpriv.channel_set);
  channelLen = padapter->mlmeextpriv.max_chan_nums;
  i = 0U;
  goto ldv_55839;
  ldv_55838: ;
  if (BTCoexDbgLevel == 1U) {
    printk("Check if chnl(%d) in channel plan contains bt target chnl(%d) for BT connection\n",
           (int )(pChanneList + (unsigned long )i)->ChannelNum, (int )channel);
  } else {

  }
  if ((int )(pChanneList + (unsigned long )i)->ChannelNum == (int )channel || (int )channel == (int )(pChanneList + (unsigned long )i)->ChannelNum + 2) {
    return (channel);
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_55839: ;
  if ((int )i < (int )channelLen) {
    goto ldv_55838;
  } else {

  }

  return (0U);
}
}
void BT_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 


  {
  BTDM_SignalCompensation(padapter, rssi_wifi, rssi_bt);
  return;
}
}
void rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter , u8 scanType ) 
{ 


  {
  BTHCI_WifiScanNotify(padapter, (int )scanType);
  BTDM_CheckAntSelMode(padapter);
  BTDM_WifiScanNotify(padapter, (int )scanType);
  return;
}
}
void rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter , u8 action ) 
{ 


  {
  if ((unsigned int )action != 0U) {
    BTDM_CheckAntSelMode(padapter);
  } else {

  }
  BTDM_WifiAssociateNotify(padapter, (int )action);
  return;
}
}
void BT_HaltProcess(struct rtw_adapter *padapter ) 
{ 


  {
  BTDM_ForHalt(padapter);
  return;
}
}
static enum rt_status PlatformIndicateBTEvent(struct rtw_adapter *padapter , void *pEvntData ,
                                              u32 dataLen ) 
{ 
  enum rt_status rt_status ;
  u32 __i ;
  u8 *ptr ;

  {
  rt_status = 1;
  if (BTCoexDbgLevel == 1U) {
    printk("BT event start, %d bytes data to Transferred!!\n", dataLen);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pEvntData;
    printk("To transfer Hex Data :\n");
    __i = 0U;
    goto ldv_55866;
    ldv_55865: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_55866: ;
    if (__i < dataLen) {
      goto ldv_55865;
    } else {

    }
    printk("\n");
  } else {

  }
  BTHCI_EventParse(padapter, pEvntData, dataLen);
  printk("\f%s: Linux has no way to report BT event!!\n", "PlatformIndicateBTEvent");
  if (BTCoexDbgLevel == 1U) {
    printk("BT event end, %s\n", (unsigned int )rt_status == 0U ? (char *)"SUCCESS" : (char *)"FAIL");
  } else {

  }
  return (rt_status);
}
}
static u8 bthci_GetLocalChannel(struct rtw_adapter *padapter ) 
{ 


  {
  return (padapter->mlmeextpriv.cur_channel);
}
}
static u8 bthci_GetCurrentEntryNum(struct rtw_adapter *padapter , u8 PhyHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  u8 i ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  i = 0U;
  goto ldv_55879;
  ldv_55878: ;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U && (int )pBTInfo->BtAsocEntry[(int )i].PhyLinkCmdData.BtPhyLinkhandle == (int )PhyHandle) {
    return (i);
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_55879: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55878;
  } else {

  }

  return (255U);
}
}
static void bthci_DecideBTChannel(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct chnl_txpower_triple *pTriple_subband ;
  struct common_triple *pTriple ;
  u8 i ;
  u8 j ;
  u8 localchnl ;
  u8 firstRemoteLegalChnlInTriplet ;
  u8 regulatory_skipLen ;
  u8 subbandTripletCnt ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;

  {
  pTriple_subband = (struct chnl_txpower_triple *)0;
  firstRemoteLegalChnlInTriplet = 0U;
  regulatory_skipLen = 0U;
  subbandTripletCnt = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtMgnt->CheckChnlIsSuit = 1U;
  localchnl = bthci_GetLocalChannel(padapter);
  pTriple = (struct common_triple *)(& pBtHciInfo->BTPreChnllist) + 3U;
  i = 0U;
  goto ldv_55902;
  ldv_55901: ;
  if ((unsigned int )pTriple->byte_1st == 201U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Find Regulatory ID, regulatory class = %d\n", (int )pTriple->byte_2nd);
    } else {

    }
    regulatory_skipLen = (unsigned int )regulatory_skipLen + 3U;
    pTriple_subband = (struct chnl_txpower_triple *)0;
    goto ldv_55897;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("Find Sub-band triplet \n");
    } else {

    }
    subbandTripletCnt = (u8 )((int )subbandTripletCnt + 1);
    pTriple_subband = (struct chnl_txpower_triple *)pTriple;
    j = pTriple_subband->FirstChnl;
    goto ldv_55900;
    ldv_55899: ;
    if (BTCoexDbgLevel == 1U) {
      printk(" Check if chnl(%d) is legal\n", (int )j);
    } else {

    }
    tmp___2 = BT_IsLegalChannel(padapter, (int )j);
    if ((unsigned int )tmp___2 != 0U) {
      firstRemoteLegalChnlInTriplet = j;
      if (BTCoexDbgLevel == 1U) {
        printk("Find first remote legal channel : %d\n", (int )firstRemoteLegalChnlInTriplet);
      } else {

      }
      tmp = check_fwstate(pmlmepriv, 49);
      if (tmp) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      if (tmp___0) {
        tmp___1 = BTHCI_HsConnectionEstablished(padapter);
        if ((unsigned int )tmp___1 == 0U) {
          pBtMgnt->BTChannel = firstRemoteLegalChnlInTriplet;
          if (BTCoexDbgLevel == 1U) {
            printk("Remote legal channel (%d) is selected, Local not connect to any!!\n",
                   (int )pBtMgnt->BTChannel);
          } else {

          }
          return;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if ((int )localchnl >= (int )firstRemoteLegalChnlInTriplet && (int )localchnl < (int )pTriple_subband->FirstChnl + (int )pTriple_subband->NumChnls) {
        pBtMgnt->BTChannel = localchnl;
        if (BTCoexDbgLevel == 1U) {
          printk("Local channel (%d) is selected, wifi or BT connection exists\n",
                 (int )pBtMgnt->BTChannel);
        } else {

        }
        return;
      } else {

      }
      goto ldv_55898;
    } else {

    }
    j = (u8 )((int )j + 1);
    ldv_55900: ;
    if ((int )j < (int )pTriple_subband->FirstChnl + (int )pTriple_subband->NumChnls) {
      goto ldv_55899;
    } else {

    }
    ldv_55898: ;
  }
  ldv_55897: 
  i = (unsigned int )i + 3U;
  pTriple = pTriple + 1;
  ldv_55902: ;
  if ((int )i < (int )pBtHciInfo->BtPreChnlListLen + -3) {
    goto ldv_55901;
  } else {

  }

  if ((unsigned int )subbandTripletCnt != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("There are %d sub band triplet exists, ", (int )subbandTripletCnt);
    } else {

    }
    if ((unsigned int )firstRemoteLegalChnlInTriplet == 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("no legal channel is found!!\n");
      } else {

      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("Remote Legal channel is found but not match to local(wifi connection exists)!!\n");
    } else {

    }
    pBtMgnt->CheckChnlIsSuit = 0U;
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("No sub band triplet exists!!\n");
  } else {

  }
  pBtMgnt->BTChannel = localchnl;
  if (BTCoexDbgLevel == 1U) {
    printk("Local channel (%d) is selected!!\n", (int )pBtMgnt->BTChannel);
  } else {

  }
  return;
}
}
static u8 bthci_GetAssocInfo(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 tempBuf[256U] ;
  u8 i ;
  u8 BaseMemoryShift ;
  u16 TotalLen ;
  struct amp_assoc_structure *pAmpAsoc ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  u32 __i___1 ;
  u8 *ptr___1 ;
  u32 __i___2 ;
  u8 *ptr___2 ;

  {
  i = 0U;
  BaseMemoryShift = 0U;
  TotalLen = 0U;
  if (BTCoexDbgLevel == 1U) {
    printk("GetAssocInfo start\n");
  } else {

  }
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar == 0U) {
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen <= 247U) {
      TotalLen = pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen;
    } else
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen == 248U) {
      TotalLen = 248U;
    } else {

    }
  } else
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar != 0U) {
    TotalLen = pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar;
  } else {

  }
  goto ldv_55943;
  ldv_55942: ;
  if (BTCoexDbgLevel == 1U) {
    printk("GetAssocInfo, TotalLen =%d, BaseMemoryShift =%d\n", (int )TotalLen, (int )BaseMemoryShift);
  } else {

  }
  memcpy((void *)(& tempBuf), (void const   *)pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )BaseMemoryShift,
           (size_t )((int )TotalLen - (int )BaseMemoryShift));
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& tempBuf);
    printk("GetAssocInfo :\n");
    __i = 0U;
    goto ldv_55918;
    ldv_55917: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_55918: ;
    if ((unsigned int )TotalLen - (unsigned int )BaseMemoryShift > __i) {
      goto ldv_55917;
    } else {

    }
    printk("\n");
  } else {

  }
  pAmpAsoc = (struct amp_assoc_structure *)(& tempBuf);
  BaseMemoryShift = (unsigned int )((int )((u8 )pAmpAsoc->Length) + (int )BaseMemoryShift) + 3U;
  if (BTCoexDbgLevel == 1U) {
    printk("TypeID = 0x%x, ", (int )pAmpAsoc->TypeID);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    ptr___0 = (u8 *)(& pAmpAsoc->Data);
    printk("Hex Data: \n");
    __i___0 = 0U;
    goto ldv_55923;
    ldv_55922: 
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i___0 + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i___0 = __i___0 + 1U;
    ldv_55923: ;
    if ((u32 )pAmpAsoc->Length > __i___0) {
      goto ldv_55922;
    } else {

    }
    printk("\n");
  } else {

  }
  switch ((int )pAmpAsoc->TypeID) {
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_MAC_ADDR\n");
  } else {

  }
  if ((unsigned int )pAmpAsoc->Length > 6U) {
    return (0U);
  } else {

  }
  memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr), (void const   *)(& pAmpAsoc->Data),
           6UL);
  if (BTCoexDbgLevel == 1U) {
    ptr___1 = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr);
    printk("Remote Mac address \n");
    printk(" ");
    __i___1 = 0U;
    goto ldv_55929;
    ldv_55928: 
    printk("%02X%s", (int )*(ptr___1 + (unsigned long )__i___1), __i___1 == 5U ? (char *)"" : (char *)"-");
    __i___1 = __i___1 + 1U;
    ldv_55929: ;
    if (__i___1 <= 5U) {
      goto ldv_55928;
    } else {

    }
    printk("\n");
  } else {

  }
  goto ldv_55931;
  case 2: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_PREFERRED_CHANNEL_LIST\n");
  } else {

  }
  pBtHciInfo->BtPreChnlListLen = pAmpAsoc->Length;
  memcpy((void *)(& pBtHciInfo->BTPreChnllist), (void const   *)(& pAmpAsoc->Data),
           (size_t )pBtHciInfo->BtPreChnlListLen);
  if (BTCoexDbgLevel == 1U) {
    ptr___2 = (u8 *)(& pBtHciInfo->BTPreChnllist);
    printk("Preferred channel list : \n");
    __i___2 = 0U;
    goto ldv_55936;
    ldv_55935: 
    printk("%02X%s", (int )*(ptr___2 + (unsigned long )__i___2), ((__i___2 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i___2 + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i___2 = __i___2 + 1U;
    ldv_55936: ;
    if ((u32 )pBtHciInfo->BtPreChnlListLen > __i___2) {
      goto ldv_55935;
    } else {

    }
    printk("\n");
  } else {

  }
  bthci_DecideBTChannel(padapter, (int )EntryNum);
  goto ldv_55931;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_CONNECTED_CHANNEL\n");
  } else {

  }
  pBtHciInfo->BTConnectChnlListLen = pAmpAsoc->Length;
  memcpy((void *)(& pBtHciInfo->BTConnectChnllist), (void const   *)(& pAmpAsoc->Data),
           (size_t )pBtHciInfo->BTConnectChnlListLen);
  goto ldv_55931;
  case 4: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_80211_PAL_CAP_LIST\n");
  } else {

  }
  pBTInfo->BtAsocEntry[(int )EntryNum].BTCapability = *((u32 *)(& pAmpAsoc->Data));
  goto ldv_55931;
  case 5: 
  pBtHciInfo->BTPalVersion = *((u8 *)(& pAmpAsoc->Data));
  pBtHciInfo->BTPalCompanyID = *((u16 *)(& pAmpAsoc->Data) + 1U);
  pBtHciInfo->BTPalsubversion = *((u16 *)(& pAmpAsoc->Data) + 3U);
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_80211_PAL_VISION PalVersion  0x%x, PalCompanyID  0x%x, Palsubversion 0x%x\n",
           (int )pBtHciInfo->BTPalVersion, (int )pBtHciInfo->BTPalCompanyID, (int )pBtHciInfo->BTPalsubversion);
  } else {

  }
  goto ldv_55931;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> Unsupport TypeID !!\n");
  } else {

  }
  goto ldv_55931;
  }
  ldv_55931: 
  i = (u8 )((int )i + 1);
  ldv_55943: ;
  if ((int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar >= (int )((unsigned short )BaseMemoryShift) || (int )((unsigned short )BaseMemoryShift) < (int )TotalLen) {
    goto ldv_55942;
  } else {

  }

  if (BTCoexDbgLevel == 1U) {
    printk("GetAssocInfo end\n");
  } else {

  }
  return (1U);
}
}
static u8 bthci_AddEntry(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  i = 0U;
  goto ldv_55953;
  ldv_55952: ;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed == 0U) {
    pBTInfo->BtAsocEntry[(int )i].bUsed = 1U;
    pBtMgnt->CurrentConnectEntryNum = i;
    goto ldv_55951;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_55953: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55952;
  } else {

  }
  ldv_55951: ;
  if ((unsigned int )i == 2U) {
    if (BTCoexDbgLevel == 1U) {
      printk("bthci_AddEntry(), Add entry fail!!\n");
    } else {

    }
    return (0U);
  } else {

  }
  return (1U);
}
}
static u8 bthci_DiscardTxPackets(struct rtw_adapter *padapter , u16 LLH ) 
{ 


  {
  return (0U);
}
}
static u8 bthci_CheckLogLinkBehavior(struct rtw_adapter *padapter , struct hci_flow_spec TxFlowSpec ) 
{ 
  u8 ID ;
  u8 ServiceType ;
  u16 MaxSDUSize ;
  u32 SDUInterArrivatime ;
  u8 match ;

  {
  ID = TxFlowSpec.Identifier;
  ServiceType = TxFlowSpec.ServiceType;
  MaxSDUSize = TxFlowSpec.MaximumSDUSize;
  SDUInterArrivatime = TxFlowSpec.SDUInterArrivalTime;
  match = 0U;
  switch ((int )ID) {
  case 1: ;
  if ((unsigned int )ServiceType == 1U) {
    match = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  TX best effort flowspec\n");
    } else {

    }
  } else
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 65535U) {
    match = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  RX guaranteed latency flowspec\n");
    } else {

    }
  } else
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 2500U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  RX guaranteed Large latency flowspec\n");
    } else {

    }
  } else {

  }
  goto ldv_55968;
  case 2: ;
  if ((unsigned int )ServiceType == 1U) {
    match = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  RX best effort flowspec\n");
    } else {

    }
  } else {

  }
  goto ldv_55968;
  case 3: ;
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 1492U) {
    match = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  TX guaranteed latency flowspec\n");
    } else {

    }
  } else
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 2500U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  TX guaranteed Large latency flowspec\n");
    } else {

    }
  } else {

  }
  goto ldv_55968;
  case 4: ;
  if ((unsigned int )ServiceType == 1U) {
    if ((SDUInterArrivatime == 4294967295U && (unsigned int )ServiceType == 1U) && (unsigned int )MaxSDUSize == 1492U) {
      match = 1U;
      if (BTCoexDbgLevel == 1U) {
        printk("Logical Link Type =  TX/RX aggregated best effort flowspec\n");
      } else {

      }
    } else {

    }
  } else
  if ((unsigned int )ServiceType == 2U) {
    if (SDUInterArrivatime == 100U) {
      match = 1U;
      if (BTCoexDbgLevel == 1U) {
        printk("Logical Link Type =  TX/RX guaranteed bandwidth flowspec\n");
      } else {

      }
    } else {

    }
  } else {

  }
  goto ldv_55968;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("Logical Link Type =  Unknow Type !!!!!!!!\n");
  } else {

  }
  goto ldv_55968;
  }
  ldv_55968: ;
  if (BTCoexDbgLevel == 1U) {
    printk("ID = 0x%x, ServiceType = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, AccessLatency = 0x%x, FlushTimeout = 0x%x\n",
           (int )TxFlowSpec.Identifier, (int )TxFlowSpec.ServiceType, (int )MaxSDUSize,
           SDUInterArrivatime, TxFlowSpec.AccessLatency, TxFlowSpec.FlushTimeout);
  } else {

  }
  return (match);
}
}
static u16 bthci_AssocMACAddr(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  u32 __i ;
  u8 *ptr ;

  {
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
  pAssoStrc->TypeID = 1U;
  pAssoStrc->Length = 6U;
  memcpy((void *)(& pAssoStrc->Data), (void const   *)(& padapter->eeprompriv.mac_addr),
           6UL);
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pAssoStrc;
    printk("AssocMACAddr : \n");
    __i = 0U;
    goto ldv_55981;
    ldv_55980: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_55981: ;
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
      goto ldv_55980;
    } else {

    }
    printk("\n");
  } else {

  }
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
static u16 bthci_PALCapabilities(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  u32 __i ;
  u8 *ptr ;

  {
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
  pAssoStrc->TypeID = 4U;
  pAssoStrc->Length = 4U;
  pAssoStrc->Data[0] = 0U;
  pAssoStrc->Data[1] = 0U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pAssoStrc;
    printk("PALCapabilities:\n");
    __i = 0U;
    goto ldv_55991;
    ldv_55990: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_55991: ;
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
      goto ldv_55990;
    } else {

    }
    printk("\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("PALCapabilities \n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk(" TypeID = 0x%x,\n Length = 0x%x,\n Content = 0x0000\n", (int )pAssoStrc->TypeID,
           (int )pAssoStrc->Length);
  } else {

  }
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
static u16 bthci_AssocPreferredChannelList(struct rtw_adapter *padapter , void *pbuf ,
                                           u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct amp_assoc_structure *pAssoStrc ;
  struct amp_pref_chnl_regulatory *pReg ;
  struct chnl_txpower_triple *pTriple ;
  char ctrString[3U] ;
  u32 len ;
  u8 preferredChnl ;
  bool tmp ;
  u8 tmp___0 ;
  u32 __i ;
  u8 *ptr ;

  {
  ctrString[0] = 88;
  ctrString[1] = 88;
  ctrString[2] = 88;
  len = 0U;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
  pReg = (struct amp_pref_chnl_regulatory *)(& pAssoStrc->Data) + 3U;
  preferredChnl = bthci_GetLocalChannel(padapter);
  pAssoStrc->TypeID = 2U;
  memcpy((void *)(& pAssoStrc->Data), (void const   *)(& ctrString), 3UL);
  pReg->reXId = 201U;
  pReg->regulatoryClass = 254U;
  pReg->coverageClass = 0U;
  len = len + 6U;
  if (BTCoexDbgLevel == 1U) {
    printk("PREFERRED_CHNL_LIST\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("XXX, 201, 254, 0\n");
  } else {

  }
  pTriple = (struct chnl_txpower_triple *)(& pAssoStrc->Data) + (unsigned long )len;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 1U) {
    goto _L;
  } else {
    tmp = check_fwstate(& padapter->mlmepriv, 113);
    if ((int )tmp) {
      goto _L;
    } else {
      tmp___0 = BTHCI_HsConnectionEstablished(padapter);
      if ((unsigned int )tmp___0 != 0U) {
        _L: /* CIL Label */ 
        pTriple->FirstChnl = preferredChnl;
        pTriple->NumChnls = 1U;
        pTriple->MaxTxPowerInDbm = 20;
        len = len + 3U;
        if (BTCoexDbgLevel == 1U) {
          printk("First Channel = %d, Channel Num = %d, MaxDbm = %d\n", (int )pTriple->FirstChnl,
                 (int )pTriple->NumChnls, (int )pTriple->MaxTxPowerInDbm);
        } else {

        }
      } else {

      }
    }
  }
  pAssoStrc->Length = (unsigned short )len;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pAssoStrc;
    printk("AssocPreferredChannelList : \n");
    __i = 0U;
    goto ldv_56008;
    ldv_56007: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56008: ;
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
      goto ldv_56007;
    } else {

    }
    printk("\n");
  } else {

  }
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
static u16 bthci_AssocPALVer(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  u8 *pu1Tmp ;
  u16 *pu2Tmp ;
  u32 __i ;
  u8 *ptr ;

  {
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
  pAssoStrc->TypeID = 5U;
  pAssoStrc->Length = 5U;
  pu1Tmp = (u8 *)(& pAssoStrc->Data);
  *pu1Tmp = 1U;
  pu2Tmp = (u16 *)(& pAssoStrc->Data) + 1U;
  *pu2Tmp = 93U;
  pu2Tmp = (u16 *)(& pAssoStrc->Data) + 3U;
  *pu2Tmp = 1U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pAssoStrc;
    printk("AssocPALVer : \n");
    __i = 0U;
    goto ldv_56020;
    ldv_56019: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56020: ;
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
      goto ldv_56019;
    } else {

    }
    printk("\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("AssocPALVer \n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk(" TypeID = 0x%x,\n Length = 0x%x,\n PAL Version = 0x01,\n PAL vendor = 0x01,\n PAL Sub-version specifier = 0x01\n",
           (int )pAssoStrc->TypeID, (int )pAssoStrc->Length);
  } else {

  }
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
static u8 bthci_CheckRfStateBeforeConnect(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  enum rt_rf_power_state RfState ;
  unsigned long tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  RfState = padapter->pwrctrlpriv.rf_pwrstate;
  if ((unsigned int )RfState != 0U) {
    tmp = msecs_to_jiffies(50U);
    ldv_mod_timer_768(& pBTInfo->BTPsDisableTimer, tmp + (unsigned long )jiffies);
    return (0U);
  } else {

  }
  return (1U);
}
}
static void bthci_ResponderStartToScan(struct rtw_adapter *padapter ) 
{ 


  {
  return;
}
}
static u8 bthci_PhyLinkConnectionInProgress(struct rtw_adapter *padapter , u8 PhyLinkHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->bPhyLinkInProgress != 0U && (int )pBtMgnt->BtCurrentPhyLinkhandle == (int )PhyLinkHandle) {
    return (1U);
  } else {

  }
  return (0U);
}
}
static void bthci_ResetFlowSpec(struct rtw_adapter *padapter , u8 EntryNum , u8 index ) 
{ 
  struct bt_30info *pBTinfo ;

  {
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtLogLinkhandle = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtPhyLinkhandle = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].bLLCompleteEventIsSet = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].bLLCancelCMDIsSetandComplete = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtTxFlowSpecID = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].TxPacketCount = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.Identifier = 1U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.ServiceType = 1U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.MaximumSDUSize = 65535U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.SDUInterArrivalTime = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.AccessLatency = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.FlushTimeout = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.Identifier = 1U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.ServiceType = 1U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.MaximumSDUSize = 65535U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.SDUInterArrivalTime = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.AccessLatency = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.FlushTimeout = 4294967295U;
  return;
}
}
static void bthci_ResetEntry(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 j ;

  {
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTinfo->BtMgnt;
  pBTinfo->BtAsocEntry[(int )EntryNum].bUsed = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].BtCurrentState = 32U;
  pBTinfo->BtAsocEntry[(int )EntryNum].BtNextState = 32U;
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.BtPhyLinkhandle = 0U;
  if ((unsigned long )pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment != (unsigned long )((void *)0)) {
    memset(pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment,
             0, 1000UL);
  } else {

  }
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle = 0U;
  memset((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
           0, (size_t )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen);
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = 16000U;
  pBTinfo->BtAsocEntry[(int )EntryNum].AMPRole = 0;
  pBTinfo->BtAsocEntry[(int )EntryNum].mAssoc = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].b4waySuccess = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].KeyReplayCounter = 0ULL;
  pBTinfo->BtAsocEntry[(int )EntryNum].BTWPAAuthState = 0;
  pBTinfo->BtAsocEntry[(int )EntryNum].bSendSupervisionPacket = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].NoRxPktCnt = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].ShortRangeMode = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].rxSuvpPktCnt = 0U;
  j = 0U;
  goto ldv_56050;
  ldv_56049: 
  bthci_ResetFlowSpec(padapter, (int )EntryNum, (int )j);
  j = (u8 )((int )j + 1);
  ldv_56050: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_56049;
  } else {

  }
  pBtMgnt->BTAuthCount = 0U;
  pBtMgnt->BTAsocCount = 0U;
  pBtMgnt->BTCurrentConnectType = 4;
  pBtMgnt->BTReceiveConnectPkt = 4;
  HALBT_RemoveKey(padapter, (int )EntryNum);
  return;
}
}
static void bthci_RemoveEntryByEntryNum(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  bthci_ResetEntry(padapter, (int )EntryNum);
  if ((unsigned int )pBtMgnt->CurrentBTConnectionCnt != 0U) {
    pBtMgnt->CurrentBTConnectionCnt = (u8 )((int )pBtMgnt->CurrentBTConnectionCnt - 1);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT Flag], CurrentBTConnectionCnt = %d!!\n", (int )pBtMgnt->CurrentBTConnectionCnt);
  } else {

  }
  if ((unsigned int )pBtMgnt->CurrentBTConnectionCnt != 0U) {
    pBtMgnt->BtOperationOn = 1U;
  } else {
    pBtMgnt->BtOperationOn = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], Bt Operation OFF!!\n");
    } else {

    }
  }
  if ((unsigned int )pBtMgnt->BtOperationOn == 0U) {
    ldv_del_timer_sync_769(& pBTInfo->BTHCIDiscardAclDataTimer);
    ldv_del_timer_sync_770(& pBTInfo->BTBeaconTimer);
    pBtMgnt->bStartSendSupervisionPkt = 0U;
  } else {

  }
  return;
}
}
static u8 bthci_CommandCompleteHeader(u8 *pbuf , u16 OGF , u16 OCF , enum hci_status status ) 
{ 
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 NumHCI_Comm ;

  {
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;
  NumHCI_Comm = 1U;
  PPacketIrpEvent->EventCode = 14U;
  PPacketIrpEvent->Data[0] = NumHCI_Comm;
  PPacketIrpEvent->Data[1] = (unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF));
  PPacketIrpEvent->Data[2] = (unsigned char )((((int )OGF << 10) | (int )OCF) >> 8);
  if ((unsigned int )OGF == 63U) {
    if ((unsigned int )OCF == 64U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
               (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
               (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
               (unsigned int )status, (int )OGF, (int )OCF);
      } else {

      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
             (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
             (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
             (unsigned int )status, (int )OGF, (int )OCF);
    } else {

    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
           (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
           (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
           (unsigned int )status, (int )OGF, (int )OCF);
  } else {

  }
  return (3U);
}
}
static u8 bthci_ExtensionEventHeaderRtk(u8 *pbuf , u8 extensionEvent ) 
{ 
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;
  PPacketIrpEvent->EventCode = 254U;
  PPacketIrpEvent->Data[0] = extensionEvent;
  return (1U);
}
}
static enum rt_status bthci_IndicateEvent(struct rtw_adapter *padapter , void *pEvntData ,
                                          u32 dataLen ) 
{ 
  enum rt_status rt_status ;

  {
  rt_status = PlatformIndicateBTEvent(padapter, pEvntData, dataLen);
  return (rt_status);
}
}
static void bthci_EventWriteRemoteAmpAssoc(struct rtw_adapter *padapter , enum hci_status status ,
                                           u8 PLHandle ) 
{ 
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 11, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk("PhyLinkHandle = 0x%x, status = %d\n", (int )PLHandle, (unsigned int )status);
  } else {

  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = PLHandle;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return;
}
}
static void bthci_EventEnhancedFlushComplete(struct rtw_adapter *padapter , u16 LLH ) 
{ 
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 4U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("EventEnhancedFlushComplete, LLH = 0x%x\n", (int )LLH);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 57U;
  PPacketIrpEvent->Length = 2U;
  PPacketIrpEvent->Data[0] = (unsigned char )LLH;
  PPacketIrpEvent->Data[1] = (unsigned char )((int )LLH >> 8);
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
  return;
}
}
static void bthci_EventShortRangeModeChangeComplete(struct rtw_adapter *padapter ,
                                                    enum hci_status HciStatus , u8 ShortRangeState ,
                                                    u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((pBtHciInfo->BTEventMaskPage2 & 4096ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Short Range Mode Change Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Short Range Mode Change Complete, Status = %d\n , PLH = 0x%x\n, Short_Range_Mode_State = 0x%x\n",
           (unsigned int )HciStatus, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (int )ShortRangeState);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 76U;
  PPacketIrpEvent->Length = 3U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  PPacketIrpEvent->Data[2] = ShortRangeState;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
  return;
}
}
static void bthci_EventSendFlowSpecModifyComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                                  u16 logicHandle ) 
{ 
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;

  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((pBtHciInfo->BTEventMaskPage2 & 128ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Flow Spec Modify Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Flow Spec Modify Complete, status = 0x%x, LLH = 0x%x\n", (unsigned int )HciStatus,
           (int )logicHandle);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 71U;
  PPacketIrpEvent->Length = 3U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = (unsigned char )logicHandle;
  PPacketIrpEvent->Data[2] = (unsigned char )((int )logicHandle >> 8);
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
  return;
}
}
static void bthci_EventExtWifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 len ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pu1Temp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  enum rt_status tmp___1 ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  len = 0U;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 7U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )pBtMgnt->BtOperationOn == 0U) {
    return;
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_ExtensionEventHeaderRtk((u8 *)(& localBuf), 1);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  pu1Temp = pRetPar;
  *pu1Temp = scanType;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  tmp___1 = bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  if ((unsigned int )tmp___1 == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Wifi scan notify, scan type = %d\n", (int )scanType);
    } else {

    }
  } else {

  }
  return;
}
}
static void bthci_EventAMPReceiverReport(struct rtw_adapter *padapter , u8 Reason ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[20U] ;
  unsigned int tmp ;
  u32 *pu4Temp ;
  u16 *pu2Temp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBtHciInfo->bTestNeedReport != 0U) {
    localBuf[0] = '\000';
    tmp = 1U;
    while (1) {
      if (tmp >= 20U) {
        break;
      } else {

      }
      localBuf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    if (BTCoexDbgLevel == 1U) {
      printk(" HCI_EVENT_AMP_RECEIVER_REPORT\n");
    } else {

    }
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
    PPacketIrpEvent->EventCode = 75U;
    PPacketIrpEvent->Length = 2U;
    PPacketIrpEvent->Data[0] = pBtHciInfo->TestCtrType;
    PPacketIrpEvent->Data[1] = Reason;
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 2U;
    *pu4Temp = pBtHciInfo->TestEventType;
    pu2Temp = (u16 *)(& PPacketIrpEvent->Data) + 6U;
    *pu2Temp = pBtHciInfo->TestNumOfFrame;
    pu2Temp = (u16 *)(& PPacketIrpEvent->Data) + 8U;
    *pu2Temp = pBtHciInfo->TestNumOfErrFrame;
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 10U;
    *pu4Temp = (u32 )pBtHciInfo->TestNumOfBits;
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 14U;
    *pu4Temp = (u32 )pBtHciInfo->TestNumOfErrBits;
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 20U);
  } else {

  }
  pBtHciInfo->TestNumOfFrame = 0U;
  return;
}
}
static void bthci_EventChannelSelected(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[3U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((pBtHciInfo->BTEventMaskPage2 & 2ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Channel Selected, Ignore to send this event due to event mask page 2\n");
    } else {

    }
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Channel Selected, PhyLinkHandle %d\n", (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 65U;
  PPacketIrpEvent->Length = 1U;
  PPacketIrpEvent->Data[0] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 3U);
  return;
}
}
static void bthci_EventDisconnectPhyLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                                 enum hci_status Reason , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((pBtHciInfo->BTEventMaskPage2 & 4ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Disconnect Physical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Disconnect Physical Link Complete, Status = 0x%x, PLH = 0x%x Reason = 0x%x\n",
           (unsigned int )HciStatus, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (unsigned int )Reason);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 66U;
  PPacketIrpEvent->Length = 3U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  PPacketIrpEvent->Data[2] = (u8 )Reason;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
  return;
}
}
static void bthci_EventPhysicalLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                            u8 EntryNum , u8 PLHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_dgb *pBtDbg ;
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 PL_handle ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtDbg = & pBTInfo->BtDbg;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 4U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  pBtMgnt->bPhyLinkInProgress = 0U;
  pBtDbg->dbgHciInfo.hciCmdPhyLinkStatus = (u32 )HciStatus;
  if ((pBtHciInfo->BTEventMaskPage2 & 1ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Physical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
    return;
  } else {

  }
  if ((unsigned int )EntryNum == 255U) {
    PL_handle = PLHandle;
  } else {
    PL_handle = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
    pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent = 0U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Physical Link Complete, Status = 0x%x PhyLinkHandle = 0x%x\n",
           (unsigned int )HciStatus, (int )PL_handle);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 64U;
  PPacketIrpEvent->Length = 2U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = PL_handle;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
  return;
}
}
static void bthci_EventCommandStatus(struct rtw_adapter *padapter , u8 OGF , u16 OCF ,
                                     enum hci_status HciStatus ) 
{ 
  u8 localBuf[6U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 Num_Hci_Comm ;

  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  Num_Hci_Comm = 1U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], CommandStatus, Opcode = 0x%02x%02x, OGF = 0x%x,  OCF = 0x%x, Status = 0x%x, Num_HCI_COMM = 0x%x\n",
           (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)), (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
           (int )OGF, (int )OCF, (unsigned int )HciStatus, (int )Num_Hci_Comm);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 15U;
  PPacketIrpEvent->Length = 4U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = Num_Hci_Comm;
  PPacketIrpEvent->Data[2] = (unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF));
  PPacketIrpEvent->Data[3] = (unsigned char )((((int )OGF << 10) | (int )OCF) >> 8);
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 6U);
  return;
}
}
static void bthci_EventLogicalLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                           u8 PhyLinkHandle , u16 LogLinkHandle ,
                                           u8 LogLinkIndex , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 7U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((pBtHciInfo->BTEventMaskPage2 & 32ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Logical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Logical Link Complete, PhyLinkHandle = 0x%x,  LogLinkHandle = 0x%x, Status = 0x%x\n",
           (int )PhyLinkHandle, (int )LogLinkHandle, (unsigned int )HciStatus);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 69U;
  PPacketIrpEvent->Length = 5U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = (unsigned char )LogLinkHandle;
  PPacketIrpEvent->Data[2] = (unsigned char )((int )LogLinkHandle >> 8);
  PPacketIrpEvent->Data[3] = PhyLinkHandle;
  if ((unsigned int )HciStatus == 0U) {
    PPacketIrpEvent->Data[4] = pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )LogLinkIndex].Tx_Flow_Spec.Identifier;
  } else {
    PPacketIrpEvent->Data[4] = 0U;
  }
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 7U);
  return;
}
}
static void bthci_EventDisconnectLogicalLinkComplete(struct rtw_adapter *padapter ,
                                                     enum hci_status HciStatus , u16 LogLinkHandle ,
                                                     enum hci_status Reason ) 
{ 
  u8 localBuf[6U] ;
  unsigned int tmp ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((pBtHciInfo->BTEventMaskPage2 & 64ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Disconnect Logical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Disconnect Logical Link Complete, Status = 0x%x, LLH = 0x%x Reason = 0x%x\n",
           (unsigned int )HciStatus, (int )LogLinkHandle, (unsigned int )Reason);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 70U;
  PPacketIrpEvent->Length = 4U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = (unsigned char )LogLinkHandle;
  PPacketIrpEvent->Data[2] = (unsigned char )((int )LogLinkHandle >> 8);
  PPacketIrpEvent->Data[3] = (u8 )Reason;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 6U);
  return;
}
}
static void bthci_EventFlushOccurred(struct rtw_adapter *padapter , u16 LogLinkHandle ) 
{ 
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 4U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_EventFlushOccurred(), LLH = 0x%x\n", (int )LogLinkHandle);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 17U;
  PPacketIrpEvent->Length = 2U;
  PPacketIrpEvent->Data[0] = (unsigned char )LogLinkHandle;
  PPacketIrpEvent->Data[1] = (unsigned char )((int )LogLinkHandle >> 8);
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
  return;
}
}
static enum hci_status bthci_BuildPhysicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                               u16 OCF ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 EntryNum ;
  u8 PLH ;
  u8 tmp ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  bthci_EventCommandStatus(padapter, 1, (int )OCF, 0);
  PLH = *((u8 *)(& pHciCmd->Data));
  tmp = bthci_AddEntry(padapter);
  if ((unsigned int )tmp == 0U) {
    status = 13;
    bthci_EventPhysicalLinkComplete(padapter, status, 255, (int )PLH);
    return (status);
  } else {

  }
  EntryNum = pBtMgnt->CurrentConnectEntryNum;
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle = PLH;
  pBtMgnt->BtCurrentPhyLinkhandle = PLH;
  if ((unsigned long )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment == (unsigned long )((void *)0)) {
    if (BTCoexDbgLevel == 1U) {
      printk("Create/Accept PhysicalLink, AMP controller is busy\n");
    } else {

    }
    status = 58;
    bthci_EventPhysicalLinkComplete(padapter, status, 255, (int )PLH);
    return (status);
  } else {

  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen = *((u8 *)(& pHciCmd->Data) + 1UL);
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType = *((u8 *)(& pHciCmd->Data) + 2UL);
  memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
           (void const   *)(& pHciCmd->Data) + 3U, (size_t )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen);
  memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK), (void const   *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
           32UL);
  if (BTCoexDbgLevel == 1U) {
    printk("BuildPhysicalLink, EntryNum = %d, PLH = 0x%x  KeyLen = 0x%x, KeyType = 0x%x\n",
           (int )EntryNum, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey);
    printk("BtAMPKey\n");
    __i = 0U;
    goto ldv_56213;
    ldv_56212: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56213: ;
    if ((u32 )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen > __i) {
      goto ldv_56212;
    } else {

    }
    printk("\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    ptr___0 = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK);
    printk("PMK\n");
    __i___0 = 0U;
    goto ldv_56218;
    ldv_56217: 
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i___0 + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i___0 = __i___0 + 1U;
    ldv_56218: ;
    if (__i___0 <= 31U) {
      goto ldv_56217;
    } else {

    }
    printk("\n");
  } else {

  }
  if ((unsigned int )OCF == 53U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_BuildPhysicalLink",
             1286);
    } else {

    }
    BTHCI_StateMachine(padapter, 32, 0, (int )EntryNum);
  } else
  if ((unsigned int )OCF == 54U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_BuildPhysicalLink",
             1288);
    } else {

    }
    BTHCI_StateMachine(padapter, 32, 1, (int )EntryNum);
  } else {

  }
  return (status);
}
}
static void bthci_BuildLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                   u16 OCF ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  u16 AssignLogHandle ;
  struct hci_flow_spec TxFlowSpec ;
  struct hci_flow_spec RxFlowSpec ;
  u32 MaxSDUSize ;
  u32 ArriveTime ;
  u32 Bandwidth ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 i ;
  u8 find ;
  enum hci_status LogCompEventstatus ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTinfo->BtMgnt;
  AssignLogHandle = 1U;
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
  memcpy((void *)(& TxFlowSpec), (void const   *)(& pHciCmd->Data) + 1U, 16UL);
  memcpy((void *)(& RxFlowSpec), (void const   *)(& pHciCmd->Data) + 17U, 16UL);
  MaxSDUSize = (u32 )TxFlowSpec.MaximumSDUSize;
  ArriveTime = TxFlowSpec.SDUInterArrivalTime;
  tmp = bthci_CheckLogLinkBehavior(padapter, TxFlowSpec);
  if ((unsigned int )tmp != 0U) {
    tmp___0 = bthci_CheckLogLinkBehavior(padapter, RxFlowSpec);
    if ((unsigned int )tmp___0 != 0U) {
      Bandwidth = 30000U;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (MaxSDUSize == 65535U && ArriveTime == 4294967295U) {
    Bandwidth = 30000U;
  } else {
    Bandwidth = (MaxSDUSize * 8000U) / (ArriveTime + 244U);
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BuildLogicalLink, PhyLinkHandle = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, Bandwidth = 0x%x\n",
           (int )PhyLinkHandle, MaxSDUSize, ArriveTime, Bandwidth);
  } else {

  }
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Invalid Physical Link handle = 0x%x, status = HCI_STATUS_UNKNOW_CONNECT_ID, return\n",
             (int )PhyLinkHandle);
    } else {

    }
    status = 2;
    bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    return;
  } else {

  }
  if ((unsigned int )pBtMgnt->bLogLinkInProgress == 0U) {
    tmp___1 = bthci_PhyLinkConnectionInProgress(padapter, (int )PhyLinkHandle);
    if ((unsigned int )tmp___1 != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Physical link connection in progress, status = HCI_STATUS_CMD_DISALLOW, return\n");
      } else {

      }
      status = 12;
      pBtMgnt->bPhyLinkInProgressStartLL = 1U;
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
      return;
    } else {

    }
    if (Bandwidth > 30000U) {
      if (BTCoexDbgLevel == 1U) {
        printk("status = HCI_STATUS_QOS_REJECT, Bandwidth = 0x%x, return\n", Bandwidth);
      } else {

      }
      status = 45;
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("status = HCI_STATUS_SUCCESS\n");
      } else {

      }
      status = 0;
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    }
    if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].BtCurrentState != 8U) {
      bthci_EventLogicalLinkComplete(padapter, 12, 0, 0, 0, (int )EntryNum);
    } else {
      find = 0U;
      pBtMgnt->bLogLinkInProgress = 1U;
      i = 0U;
      goto ldv_56242;
      ldv_56241: ;
      if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle == 0U) {
        LogCompEventstatus = 0;
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle = *((u8 *)(& pHciCmd->Data));
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle = AssignLogHandle;
        if (BTCoexDbgLevel == 1U) {
          printk("BuildLogicalLink, EntryNum = %d, physical link handle = 0x%x, logical link handle = 0x%x\n",
                 (int )EntryNum, (int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
                 (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle);
        } else {

        }
        memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                 (void const   *)(& TxFlowSpec), 16UL);
        memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                 (void const   *)(& RxFlowSpec), 16UL);
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCompleteEventIsSet = 0U;
        if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCancelCMDIsSetandComplete != 0U) {
          LogCompEventstatus = 2;
        } else {

        }
        bthci_EventLogicalLinkComplete(padapter, LogCompEventstatus, (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle,
                                       (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle,
                                       (int )i, (int )EntryNum);
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCompleteEventIsSet = 1U;
        find = 1U;
        pBtMgnt->BtCurrentLogLinkhandle = AssignLogHandle;
        AssignLogHandle = (u16 )((int )AssignLogHandle + 1);
        goto ldv_56240;
      } else {

      }
      i = (u8 )((int )i + 1);
      ldv_56242: ;
      if ((unsigned int )i <= 1U) {
        goto ldv_56241;
      } else {

      }
      ldv_56240: ;
      if ((unsigned int )find == 0U) {
        bthci_EventLogicalLinkComplete(padapter, 13, 0, 0, 0, (int )EntryNum);
      } else {

      }
      pBtMgnt->bLogLinkInProgress = 0U;
    }
  } else {
    bthci_EventLogicalLinkComplete(padapter, 58, 0, 0, 0, (int )EntryNum);
  }
  return;
}
}
static void bthci_StartBeaconAndConnect(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                        u8 CurrentAssocNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  u32 __i ;
  u8 buffer[64U] ;
  u32 length ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("StartBeaconAndConnect, CurrentAssocNum =%d, AMPRole =%d\n", (int )CurrentAssocNum,
           (unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole);
  } else {

  }
  if ((unsigned int )pBtMgnt->CheckChnlIsSuit == 0U) {
    bthci_EventPhysicalLinkComplete(padapter, 57, (int )CurrentAssocNum, 255);
    bthci_RemoveEntryByEntryNum(padapter, (int )CurrentAssocNum);
    return;
  } else {

  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 1U) {
    snprintf((char *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf), 32UL,
             "AMP-%02x-%02x-%02x-%02x-%02x-%02x", (int )padapter->eeprompriv.mac_addr[0],
             (int )padapter->eeprompriv.mac_addr[1], (int )padapter->eeprompriv.mac_addr[2],
             (int )padapter->eeprompriv.mac_addr[3], (int )padapter->eeprompriv.mac_addr[4],
             (int )padapter->eeprompriv.mac_addr[5]);
  } else
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 2U) {
    snprintf((char *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf), 32UL,
             "AMP-%02x-%02x-%02x-%02x-%02x-%02x", (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[0],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[1],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[2],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[3],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[4],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[5]);
  } else {

  }
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Octet = (u8 *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf);
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Length = 21U;
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Length = 21U;
  if ((unsigned int )pBtMgnt->bBTConnectInProgress == 0U) {
    pBtMgnt->bBTConnectInProgress = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress ON!!\n");
    } else {

    }
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_StartBeaconAndConnect",
             1482);
    } else {

    }
    BTHCI_StateMachine(padapter, 1, 4, (int )CurrentAssocNum);
    tmp = bthci_CheckRfStateBeforeConnect(padapter);
    if ((unsigned int )tmp == 0U) {
      return;
    } else {

    }
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 1U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT state change] caused by %s, line =%d\n", "bthci_StartBeaconAndConnect",
               1491);
      } else {

      }
      BTHCI_StateMachine(padapter, 2, 6, (int )CurrentAssocNum);
    } else
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 2U) {
      bthci_ResponderStartToScan(padapter);
    } else {

    }
  } else {

  }
  length = (unsigned int )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length <= 63U ? (u32 )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length : 63U;
  memset((void *)(& buffer), 0, 64UL);
  memcpy((void *)(& buffer), (void const   *)pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Octet,
           (size_t )length);
  __i = 0U;
  goto ldv_56255;
  ldv_56254: ;
  if ((unsigned int )buffer[__i] <= 31U || (unsigned int )buffer[__i] > 126U) {
    buffer[__i] = 63U;
  } else {

  }
  __i = __i + 1U;
  ldv_56255: ;
  if (__i < length) {
    goto ldv_56254;
  } else {

  }
  buffer[length] = 0U;
  printk("StartBeaconAndConnect, SSID:\n");
  printk(": %d, <%s>\n", (int )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length,
         (u8 *)(& buffer));
  return;
}
}
static void bthci_ResetBtMgnt(struct bt_mgnt *pBtMgnt ) 
{ 


  {
  pBtMgnt->BtOperationOn = 0U;
  pBtMgnt->bBTConnectInProgress = 0U;
  pBtMgnt->bLogLinkInProgress = 0U;
  pBtMgnt->bPhyLinkInProgress = 0U;
  pBtMgnt->bPhyLinkInProgressStartLL = 0U;
  pBtMgnt->DisconnectEntryNum = 255U;
  pBtMgnt->bStartSendSupervisionPkt = 0U;
  pBtMgnt->JoinerNeedSendAuth = 0U;
  pBtMgnt->CurrentBTConnectionCnt = 0U;
  pBtMgnt->BTCurrentConnectType = 4;
  pBtMgnt->BTReceiveConnectPkt = 4;
  pBtMgnt->BTAuthCount = 0U;
  pBtMgnt->btLogoTest = 0U;
  return;
}
}
static void bthci_ResetBtHciInfo(struct bt_hci_info *pBtHciInfo ) 
{ 


  {
  pBtHciInfo->BTEventMask = 0ULL;
  pBtHciInfo->BTEventMaskPage2 = 0ULL;
  pBtHciInfo->ConnAcceptTimeout = 10000U;
  pBtHciInfo->PageTimeout = 48U;
  pBtHciInfo->LocationDomainAware = 0U;
  pBtHciInfo->LocationDomain = 22616U;
  pBtHciInfo->LocationDomainOptions = 88U;
  pBtHciInfo->LocationOptions = 0U;
  pBtHciInfo->FlowControlMode = 1U;
  pBtHciInfo->enFlush_LLH = 0U;
  pBtHciInfo->FLTO_LLH = 0U;
  pBtHciInfo->bTestIsEnd = 1U;
  pBtHciInfo->bInTestMode = 0U;
  pBtHciInfo->bTestNeedReport = 0U;
  pBtHciInfo->TestScenario = 255U;
  pBtHciInfo->TestReportInterval = 1U;
  pBtHciInfo->TestCtrType = 93U;
  pBtHciInfo->TestEventType = 0U;
  pBtHciInfo->TestNumOfFrame = 0U;
  pBtHciInfo->TestNumOfErrFrame = 0U;
  pBtHciInfo->TestNumOfBits = 0U;
  pBtHciInfo->TestNumOfErrBits = 0U;
  return;
}
}
static void bthci_ResetBtSec(struct rtw_adapter *padapter , struct bt_security *pBtSec ) 
{ 


  {
  if ((unsigned int )((struct hal_data_8723a *)padapter->HalData)->bBTMode != 0U) {
    pBtSec->bUsedHwEncrypt = 1U;
  } else {
    pBtSec->bUsedHwEncrypt = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    rt_trace(4096, 7, "%s: bUsedHwEncrypt =%d\n", "bthci_ResetBtSec", (int )pBtSec->bUsedHwEncrypt);
  } else {

  }
  pBtSec->RSNIE.Octet = (u8 *)(& pBtSec->RSNIEBuf);
  return;
}
}
static void bthci_ResetBtExtInfo(struct bt_mgnt *pBtMgnt ) 
{ 
  u8 i ;

  {
  i = 0U;
  goto ldv_56273;
  ldv_56272: 
  pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = 4U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI = 0;
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole = 0U;
  i = (u8 )((int )i + 1);
  ldv_56273: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_56272;
  } else {

  }
  pBtMgnt->ExtConfig.CurrentConnectHandle = 0U;
  pBtMgnt->ExtConfig.CurrentIncomingTrafficMode = 0U;
  pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = 0U;
  pBtMgnt->ExtConfig.MIN_BT_RSSI = 0;
  pBtMgnt->ExtConfig.NumberOfHandle = 0U;
  pBtMgnt->ExtConfig.NumberOfSCO = 0U;
  pBtMgnt->ExtConfig.CurrentBTStatus = 0U;
  pBtMgnt->ExtConfig.HCIExtensionVer = 0U;
  pBtMgnt->ExtConfig.bManualControl = 0U;
  pBtMgnt->ExtConfig.bBTBusy = 0U;
  pBtMgnt->ExtConfig.bBTA2DPBusy = 0U;
  return;
}
}
static enum hci_status bthci_CmdReset(struct rtw_adapter *_padapter , u8 bNeedSendEvent ) 
{ 
  enum hci_status status ;
  struct rtw_adapter *padapter ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_security *pBtSec ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_CmdReset()\n");
  } else {

  }
  padapter = _padapter;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtSec = & pBTInfo->BtSec;
  pBtDbg = & pBTInfo->BtDbg;
  pBTInfo->padapter = padapter;
  i = 0U;
  goto ldv_56288;
  ldv_56287: 
  bthci_ResetEntry(padapter, (int )i);
  i = (u8 )((int )i + 1);
  ldv_56288: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_56287;
  } else {

  }
  bthci_ResetBtMgnt(pBtMgnt);
  bthci_ResetBtHciInfo(pBtHciInfo);
  bthci_ResetBtSec(padapter, pBtSec);
  pBtMgnt->BTChannel = 10U;
  pBtMgnt->CheckChnlIsSuit = 1U;
  pBTInfo->BTBeaconTmrOn = 0U;
  pBtMgnt->bCreateSpportQos = 1U;
  ldv_del_timer_sync_771(& pBTInfo->BTHCIDiscardAclDataTimer);
  ldv_del_timer_sync_772(& pBTInfo->BTBeaconTimer);
  HALBT_SetRtsCtsNoLenLimit(padapter);
  bthci_ResetBtExtInfo(pBtMgnt);
  if ((unsigned int )bNeedSendEvent != 0U) {
    localBuf[0] = '\000';
    tmp = 1U;
    while (1) {
      if (tmp >= 6U) {
        break;
      } else {

      }
      localBuf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    len = 0U;
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
    tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 3, status);
    len = (int )tmp___0 + (int )len;
    pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
    *pRetPar = (u8 )status;
    len = (unsigned int )len + 1U;
    PPacketIrpEvent->Length = len;
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  } else {

  }
  return (status);
}
}
static enum hci_status bthci_CmdWriteRemoteAMPAssoc(struct rtw_adapter *padapter ,
                                                    struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 CurrentAssocNum ;
  u8 PhyLinkHandle ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  u8 tmp ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc = pBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc + 1U;
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
  CurrentAssocNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
  if ((unsigned int )CurrentAssocNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("WriteRemoteAMPAssoc, No such Handle in the Entry\n");
    } else {

    }
    status = 2;
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
    return (status);
  } else {

  }
  if ((unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment == (unsigned long )((void *)0)) {
    if (BTCoexDbgLevel == 1U) {
      printk("WriteRemoteAMPAssoc, AMP controller is busy\n");
    } else {

    }
    status = 58;
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
    return (status);
  } else {

  }
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.BtPhyLinkhandle = PhyLinkHandle;
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar = *((u16 *)(& pHciCmd->Data) + 1U);
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen = *((u16 *)(& pHciCmd->Data) + 3U);
  if (BTCoexDbgLevel == 1U) {
    printk("WriteRemoteAMPAssoc, LenSoFar = 0x%x, AssocRemLen = 0x%x\n", (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
           (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("WriteRemoteAMPAssoc fragment \n");
    __i = 0U;
    goto ldv_56306;
    ldv_56305: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56306: ;
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen + 5U > __i) {
      goto ldv_56305;
    } else {

    }
    printk("\n");
  } else {

  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen > 248U) {
    memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
             (void const   *)(& pHciCmd->Data) + 5U, 248UL);
  } else {
    memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
             (void const   *)(& pHciCmd->Data) + 5U, (size_t )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen);
    if (BTCoexDbgLevel == 1U) {
      ptr___0 = (u8 *)(& pHciCmd->Data) + 5UL;
      printk("WriteRemoteAMPAssoc :\n");
      __i___0 = 0U;
      goto ldv_56311;
      ldv_56310: 
      printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
      if (((__i___0 + 1U) & 15U) == 0U) {
        printk("\n");
      } else {

      }
      __i___0 = __i___0 + 1U;
      ldv_56311: ;
      if ((u32 )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen > __i___0) {
        goto ldv_56310;
      } else {

      }
      printk("\n");
    } else {

    }
    tmp = bthci_GetAssocInfo(padapter, (int )CurrentAssocNum);
    if ((unsigned int )tmp == 0U) {
      status = 18;
    } else {

    }
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
    bthci_StartBeaconAndConnect(padapter, pHciCmd, (int )CurrentAssocNum);
  }
  return (status);
}
}
static enum hci_status bthci_CmdReadConnectionAcceptTimeout(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 21, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = pBtHciInfo->ConnAcceptTimeout;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteConnectionAcceptTimeout(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pu2Temp = (u16 *)(& pHciCmd->Data);
  pBtHciInfo->ConnAcceptTimeout = *pu2Temp;
  if (BTCoexDbgLevel == 1U) {
    printk("ConnAcceptTimeout = 0x%x", (int )pBtHciInfo->ConnAcceptTimeout);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 22, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadPageTimeout(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 23, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk("Read PageTimeout = 0x%x\n", (int )pBtHciInfo->PageTimeout);
  } else {

  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = pBtHciInfo->PageTimeout;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWritePageTimeout(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pu2Temp = (u16 *)(& pHciCmd->Data);
  pBtHciInfo->PageTimeout = *pu2Temp;
  if (BTCoexDbgLevel == 1U) {
    printk("Write PageTimeout = 0x%x\n", (int )pBtHciInfo->PageTimeout);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 24, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLinkSupervisionTimeout(struct rtw_adapter *padapter ,
                                                           struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 physicalLinkHandle ;
  u8 EntryNum ;
  u8 localBuf[10U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )physicalLinkHandle);
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("ReadLinkSupervisionTimeout, No such Handle in the Entry\n");
    } else {

    }
    status = 2;
    return (status);
  } else {

  }
  if ((int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle != (int )physicalLinkHandle) {
    status = 2;
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 10U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 54, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  *(pRetPar + 2UL) = 0U;
  pu2Temp = (u16 *)pRetPar + 3U;
  *pu2Temp = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout;
  len = (unsigned int )len + 5U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteLinkSupervisionTimeout(struct rtw_adapter *padapter ,
                                                            struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 physicalLinkHandle ;
  u8 EntryNum ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )physicalLinkHandle);
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("WriteLinkSupervisionTimeout, No such Handle in the Entry\n");
    } else {

    }
    status = 2;
  } else
  if ((int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle != (int )physicalLinkHandle) {
    status = 2;
  } else {
    pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = *((u16 *)(& pHciCmd->Data) + 2U);
    if (BTCoexDbgLevel == 1U) {
      printk("BT Write LinkSuperversionTimeout[%d] = 0x%x\n", (int )EntryNum, (int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout);
    } else {

    }
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 55, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  *(pRetPar + 2UL) = 0U;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdEnhancedFlush(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 logicHandle ;
  u8 Packet_Type ;
  u8 tmp ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTinfo->BtHciInfo;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  Packet_Type = pHciCmd->Data[2];
  if ((unsigned int )Packet_Type != 0U) {
    status = 18;
  } else {
    pBtHciInfo->enFlush_LLH = logicHandle;
  }
  tmp = bthci_DiscardTxPackets(padapter, (int )pBtHciInfo->enFlush_LLH);
  if ((unsigned int )tmp != 0U) {
    bthci_EventFlushOccurred(padapter, (int )pBtHciInfo->enFlush_LLH);
  } else {

  }
  bthci_EventCommandStatus(padapter, 3, 95, status);
  if ((unsigned int )pBtHciInfo->enFlush_LLH != 0U) {
    bthci_EventEnhancedFlushComplete(padapter, (int )pBtHciInfo->enFlush_LLH);
    pBtHciInfo->enFlush_LLH = 0U;
  } else {

  }
  return (status);
}
}
static enum hci_status bthci_CmdReadLogicalLinkAcceptTimeout(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 97, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = pBtHciInfo->LogicalAcceptTimeout;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteLogicalLinkAcceptTimeout(struct rtw_adapter *padapter ,
                                                              struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBtHciInfo->LogicalAcceptTimeout = *((u16 *)(& pHciCmd->Data));
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 98, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetEventMask(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 *pu8Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pu8Temp = (u8 *)(& pHciCmd->Data);
  pBtHciInfo->BTEventMask = (u64 )*pu8Temp;
  if (BTCoexDbgLevel == 1U) {
    printk("BTEventMask = 0x%llx\n", pBtHciInfo->BTEventMask);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 1, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetEventMaskPage2(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 *pu8Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pu8Temp = (u8 *)(& pHciCmd->Data);
  pBtHciInfo->BTEventMaskPage2 = (u64 )*pu8Temp;
  if (BTCoexDbgLevel == 1U) {
    printk("BTEventMaskPage2 = 0x%llx\n", pBtHciInfo->BTEventMaskPage2);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 99, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocationData(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[12U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 12U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 100, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk("DomainAware = 0x%x\n", (int )pBtHciInfo->LocationDomainAware);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Domain = 0x%x\n", (int )pBtHciInfo->LocationDomain);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("DomainOptions = 0x%x\n", (int )pBtHciInfo->LocationDomainOptions);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Options = 0x%x\n", (int )pBtHciInfo->LocationOptions);
  } else {

  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBtHciInfo->LocationDomainAware;
  pu2Temp = (u16 *)pRetPar + 2U;
  *pu2Temp = pBtHciInfo->LocationDomain;
  *(pRetPar + 4UL) = pBtHciInfo->LocationDomainOptions;
  *(pRetPar + 5UL) = pBtHciInfo->LocationOptions;
  len = (unsigned int )len + 6U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteLocationData(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBtHciInfo->LocationDomainAware = pHciCmd->Data[0];
  pu2Temp = (u16 *)(& pHciCmd->Data) + 1U;
  pBtHciInfo->LocationDomain = *pu2Temp;
  pBtHciInfo->LocationDomainOptions = pHciCmd->Data[3];
  pBtHciInfo->LocationOptions = pHciCmd->Data[4];
  if (BTCoexDbgLevel == 1U) {
    printk("DomainAware = 0x%x\n", (int )pBtHciInfo->LocationDomainAware);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Domain = 0x%x\n", (int )pBtHciInfo->LocationDomain);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("DomainOptions = 0x%x\n", (int )pBtHciInfo->LocationDomainOptions);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Options = 0x%x\n", (int )pBtHciInfo->LocationOptions);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 101, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadFlowControlMode(struct rtw_adapter *padapter ,
                                                    struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 7U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 102, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBtHciInfo->FlowControlMode;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteFlowControlMode(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBtHciInfo->FlowControlMode = pHciCmd->Data[0];
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 103, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadBestEffortFlushTimeout(struct rtw_adapter *padapter ,
                                                           struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u16 i ;
  u16 j ;
  u16 logicHandle ;
  u32 BestEffortFlushTimeout ;
  u8 find ;
  u8 localBuf[10U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u32 *pu4Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  BestEffortFlushTimeout = 4294967295U;
  find = 0U;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  j = 0U;
  goto ldv_56502;
  ldv_56501: 
  i = 0U;
  goto ldv_56500;
  ldv_56499: ;
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
    BestEffortFlushTimeout = pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BestEffortFlushTimeout;
    find = 1U;
    goto ldv_56498;
  } else {

  }
  i = (u16 )((int )i + 1);
  ldv_56500: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_56499;
  } else {

  }
  ldv_56498: 
  j = (u16 )((int )j + 1);
  ldv_56502: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_56501;
  } else {

  }

  if ((unsigned int )find == 0U) {
    status = 2;
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 10U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 105, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu4Temp = (u32 *)pRetPar + 1U;
  *pu4Temp = BestEffortFlushTimeout;
  len = (unsigned int )len + 5U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteBestEffortFlushTimeout(struct rtw_adapter *padapter ,
                                                            struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u16 i ;
  u16 j ;
  u16 logicHandle ;
  u32 BestEffortFlushTimeout ;
  u8 find ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  BestEffortFlushTimeout = 4294967295U;
  find = 0U;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  BestEffortFlushTimeout = *((u32 *)(& pHciCmd->Data) + 1U);
  j = 0U;
  goto ldv_56524;
  ldv_56523: 
  i = 0U;
  goto ldv_56522;
  ldv_56521: ;
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
    pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BestEffortFlushTimeout = BestEffortFlushTimeout;
    find = 1U;
    goto ldv_56520;
  } else {

  }
  i = (u16 )((int )i + 1);
  ldv_56522: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_56521;
  } else {

  }
  ldv_56520: 
  j = (u16 )((int )j + 1);
  ldv_56524: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_56523;
  } else {

  }

  if ((unsigned int )find == 0U) {
    status = 2;
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 106, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdShortRangeMode(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  u8 ShortRangeMode ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  PhyLinkHandle = pHciCmd->Data[0];
  ShortRangeMode = pHciCmd->Data[1];
  if (BTCoexDbgLevel == 1U) {
    printk("PLH = 0x%x, Short_Range_Mode = 0x%x\n", (int )PhyLinkHandle, (int )ShortRangeMode);
  } else {

  }
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
  if ((unsigned int )EntryNum != 255U) {
    pBTInfo->BtAsocEntry[(int )EntryNum].ShortRangeMode = ShortRangeMode;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("No such PLH(0x%x)\n", (int )PhyLinkHandle);
    } else {

    }
    status = 2;
  }
  bthci_EventCommandStatus(padapter, 3, 107, status);
  bthci_EventShortRangeModeChangeComplete(padapter, status, (int )ShortRangeMode,
                                          (int )EntryNum);
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalSupportedCommands(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pSupportedCmds ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 2, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  pSupportedCmds = pRetPar + 1UL;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[5]= 0xc0\nBit [6]= Set Event Mask, [7]= Reset\n");
  } else {

  }
  *(pSupportedCmds + 5UL) = 192U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[6]= 0x01\nBit [0]= Set Event Filter\n");
  } else {

  }
  *(pSupportedCmds + 6UL) = 1U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[7]= 0x0c\nBit [2]= Read Connection Accept Timeout, [3]= Write Connection Accept Timeout\n");
  } else {

  }
  *(pSupportedCmds + 7UL) = 12U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[10]= 0x80\nBit [7]= Host Number Of Completed Packets\n");
  } else {

  }
  *(pSupportedCmds + 10UL) = 128U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[11]= 0x03\nBit [0]= Read Link Supervision Timeout, [1]= Write Link Supervision Timeout\n");
  } else {

  }
  *(pSupportedCmds + 11UL) = 3U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[14]= 0xa8\nBit [3]= Read Local Version Information, [5]= Read Local Supported Features, [7]= Read Buffer Size\n");
  } else {

  }
  *(pSupportedCmds + 14UL) = 168U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[15]= 0x1c\nBit [2]= Read Failed Contact Count, [3]= Reset Failed Contact Count, [4]= Get Link Quality\n");
  } else {

  }
  *(pSupportedCmds + 15UL) = 28U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[19]= 0x40\nBit [6]= Enhanced Flush\n");
  } else {

  }
  *(pSupportedCmds + 19UL) = 64U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[21]= 0xff\nBit [0]= Create Physical Link, [1]= Accept Physical Link, [2]= Disconnect Physical Link, [3]= Create Logical Link\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("\t[4]= Accept Logical Link, [5]= Disconnect Logical Link, [6]= Logical Link Cancel, [7]= Flow Spec Modify\n");
  } else {

  }
  *(pSupportedCmds + 21UL) = 255U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[22]= 0xff\nBit [0]= Read Logical Link Accept Timeout, [1]= Write Logical Link Accept Timeout, [2]= Set Event Mask Page 2, [3]= Read Location Data\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("\t[4]= Write Location Data, [5]= Read Local AMP Info, [6]= Read Local AMP_ASSOC, [7]= Write Remote AMP_ASSOC\n");
  } else {

  }
  *(pSupportedCmds + 22UL) = 255U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[23]= 0x07\nBit [0]= Read Flow Control Mode, [1]= Write Flow Control Mode, [2]= Read Data Block Size\n");
  } else {

  }
  *(pSupportedCmds + 23UL) = 7U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[24]= 0x1c\nBit [2]= Read Best Effort Flush Timeout, [3]= Write Best Effort Flush Timeout, [4]= Short Range Mode\n");
  } else {

  }
  *(pSupportedCmds + 24UL) = 28U;
  len = (unsigned int )len + 64U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalSupportedFeatures(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 3, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 9U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalAMPAssoc(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u16 *pRemainLen ;
  u32 totalLen ;
  u16 typeLen ;
  u16 remainLen ;
  u16 ret_index ;
  u8 *pRetPar ;
  u8 tmp___0 ;
  u32 __i ;
  u8 *ptr ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc = pBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc + 1U;
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
  if ((unsigned int )EntryNum == 255U && (unsigned int )PhyLinkHandle != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("ReadLocalAMPAssoc, EntryNum = %d  !!!!!, physical link handle = 0x%x\n",
             (int )EntryNum, (int )PhyLinkHandle);
    } else {

    }
    status = 2;
  } else
  if ((unsigned int )pBtMgnt->bPhyLinkInProgressStartLL != 0U) {
    status = 2;
    pBtMgnt->bPhyLinkInProgressStartLL = 0U;
  } else {
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.BtPhyLinkhandle = *((u8 *)(& pHciCmd->Data));
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar = *((u16 *)(& pHciCmd->Data) + 1U);
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen = *((u16 *)(& pHciCmd->Data) + 3U);
    if (BTCoexDbgLevel == 1U) {
      printk("ReadLocalAMPAssoc, LenSoFar =%d, MaxRemoteASSOCLen =%d\n", (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar,
             (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen);
    } else {

    }
  }
  if (BTCoexDbgLevel == 1U) {
    printk("ReadLocalAMPAssoc, EntryNum = %d  !!!!!, physical link handle = 0x%x, LengthSoFar = %x  \n",
           (int )EntryNum, (int )PhyLinkHandle, (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  totalLen = 0U;
  typeLen = 0U;
  remainLen = 0U;
  ret_index = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 10, status);
  totalLen = (u32 )tmp___0 + totalLen;
  if (BTCoexDbgLevel == 1U) {
    printk("ReadLocalAMPAssoc, Remaining_Len =%d  \n", (int )remainLen);
  } else {

  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )totalLen;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = *((u8 *)(& pHciCmd->Data));
  pRemainLen = (u16 *)pRetPar + 2U;
  totalLen = totalLen + 4U;
  ret_index = 4U;
  typeLen = bthci_AssocMACAddr(padapter, (void *)pRetPar + (unsigned long )ret_index);
  totalLen = (u32 )typeLen + totalLen;
  remainLen = (int )remainLen + (int )typeLen;
  ret_index = (int )ret_index + (int )typeLen;
  typeLen = bthci_AssocPreferredChannelList(padapter, (void *)pRetPar + (unsigned long )ret_index,
                                            (int )EntryNum);
  totalLen = (u32 )typeLen + totalLen;
  remainLen = (int )remainLen + (int )typeLen;
  ret_index = (int )ret_index + (int )typeLen;
  typeLen = bthci_PALCapabilities(padapter, (void *)pRetPar + (unsigned long )ret_index);
  totalLen = (u32 )typeLen + totalLen;
  remainLen = (int )remainLen + (int )typeLen;
  ret_index = (int )ret_index + (int )typeLen;
  typeLen = bthci_AssocPALVer(padapter, (void *)pRetPar + (unsigned long )ret_index);
  totalLen = (u32 )typeLen + totalLen;
  remainLen = (int )remainLen + (int )typeLen;
  PPacketIrpEvent->Length = (unsigned char )totalLen;
  *pRemainLen = remainLen;
  if (BTCoexDbgLevel == 1U) {
    printk("ReadLocalAMPAssoc, Remaining_Len =%d  \n", (int )remainLen);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& PPacketIrpEvent->Data);
    printk("AMP_ASSOC_fragment : \n");
    __i = 0U;
    goto ldv_56577;
    ldv_56576: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56577: ;
    if (__i < totalLen) {
      goto ldv_56576;
    } else {

    }
    printk("\n");
  } else {

  }
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, totalLen + 2U);
  return (status);
}
}
static enum hci_status bthci_CmdReadFailedContactCounter(struct rtw_adapter *padapter ,
                                                         struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 handle ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  handle = *((u16 *)(& pHciCmd->Data));
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 1, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = (unsigned char )handle;
  *(pRetPar + 2UL) = (unsigned char )((int )handle >> 8);
  *(pRetPar + 3UL) = (unsigned char )pBtHciInfo->FailContactCount;
  *(pRetPar + 4UL) = (unsigned char )((int )pBtHciInfo->FailContactCount >> 8);
  len = (unsigned int )len + 5U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdResetFailedContactCounter(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 handle ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  handle = *((u16 *)(& pHciCmd->Data));
  pBtHciInfo->FailContactCount = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 2, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = (unsigned char )handle;
  *(pRetPar + 2UL) = (unsigned char )((int )handle >> 8);
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalVersionInformation(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 1, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = 5U;
  pu2Temp = (u16 *)pRetPar + 2U;
  *pu2Temp = 1U;
  *(pRetPar + 4UL) = 5U;
  pu2Temp = (u16 *)pRetPar + 5U;
  *pu2Temp = 93U;
  pu2Temp = (u16 *)pRetPar + 7U;
  *pu2Temp = 1U;
  len = (unsigned int )len + 9U;
  PPacketIrpEvent->Length = len;
  if (BTCoexDbgLevel == 1U) {
    printk("LOCAL_VERSION_INFORMATION\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Status  %x\n", (unsigned int )status);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_Version = 0x05\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_Revision = 0x0001\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("LMP/PAL_Version = 0x05\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Manufacturer_Name = 0x0001\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("LMP/PAL_Subversion = 0x0001\n");
  } else {

  }
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadDataBlockSize(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 10, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = 0U;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = 1492U;
  pu2Temp = (u16 *)pRetPar + 3U;
  *pu2Temp = 1492U;
  pu2Temp = (u16 *)pRetPar + 5U;
  *pu2Temp = 256U;
  len = (unsigned int )len + 7U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadBufferSize(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 5, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk("Synchronous_Data_Packet_Length = 0x%x\n", 255);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Total_Num_ACL_Data_Packets = 0x%x\n", 256);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Total_Num_Synchronous_Data_Packets = 0x%x\n", 256);
  } else {

  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = 1492U;
  *(pRetPar + 3UL) = 255U;
  pu2Temp = (u16 *)pRetPar + 4U;
  *pu2Temp = 256U;
  pu2Temp = (u16 *)pRetPar + 6U;
  *pu2Temp = 256U;
  len = (unsigned int )len + 8U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalAMPInfo(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  struct pwrctrl_priv *ppwrctrl ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u32 *pu4Temp ;
  u32 TotalBandwidth ;
  u32 MaxBandGUBandwidth ;
  u8 ControlType ;
  u8 AmpStatus ;
  u32 MaxFlushTimeout ;
  u32 BestEffortFlushTimeout ;
  u16 MaxPDUSize ;
  u16 PalCap ;
  u16 AmpAssocLen ;
  u16 MinLatency ;
  u8 tmp___0 ;

  {
  status = 0;
  ppwrctrl = & padapter->pwrctrlpriv;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  TotalBandwidth = 30000U;
  MaxBandGUBandwidth = 20000U;
  ControlType = 1U;
  AmpStatus = 1U;
  MaxFlushTimeout = 10000U;
  BestEffortFlushTimeout = 5000U;
  MaxPDUSize = 1492U;
  PalCap = 1U;
  AmpAssocLen = 672U;
  MinLatency = 20U;
  if (((unsigned long )ppwrctrl->rfoff_reason & 1073741824UL) != 0UL || (int )ppwrctrl->rfoff_reason < 0) {
    AmpStatus = 2U;
  } else {

  }
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 9, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = AmpStatus;
  pu4Temp = (u32 *)pRetPar + 2U;
  *pu4Temp = TotalBandwidth;
  pu4Temp = (u32 *)pRetPar + 6U;
  *pu4Temp = MaxBandGUBandwidth;
  pu4Temp = (u32 *)pRetPar + 10U;
  *pu4Temp = (u32 )MinLatency;
  pu4Temp = (u32 *)pRetPar + 14U;
  *pu4Temp = (u32 )MaxPDUSize;
  *(pRetPar + 18UL) = ControlType;
  pu2Temp = (u16 *)pRetPar + 19U;
  *pu2Temp = PalCap;
  pu2Temp = (u16 *)pRetPar + 21U;
  *pu2Temp = AmpAssocLen;
  pu4Temp = (u32 *)pRetPar + 23U;
  *pu4Temp = MaxFlushTimeout;
  pu4Temp = (u32 *)pRetPar + 27U;
  *pu4Temp = BestEffortFlushTimeout;
  len = (unsigned int )len + 31U;
  PPacketIrpEvent->Length = len;
  if (BTCoexDbgLevel == 1U) {
    printk("AmpStatus = 0x%x\n", (int )AmpStatus);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("TotalBandwidth = 0x%x, MaxBandGUBandwidth = 0x%x, MinLatency = 0x%x, \n MaxPDUSize = 0x%x, ControlType = 0x%x\n",
           TotalBandwidth, MaxBandGUBandwidth, (int )MinLatency, (int )MaxPDUSize,
           (int )ControlType);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("PalCap = 0x%x, AmpAssocLen = 0x%x, MaxFlushTimeout = 0x%x, BestEffortFlushTimeout = 0x%x\n",
           (int )PalCap, (int )AmpAssocLen, MaxFlushTimeout, BestEffortFlushTimeout);
  } else {

  }
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdCreatePhysicalLink(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink = pBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink + 1U;
  status = bthci_BuildPhysicalLink(padapter, pHciCmd, 53);
  return (status);
}
}
static enum hci_status bthci_CmdReadLinkQuality(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  u16 PLH ;
  u8 EntryNum ;
  u8 LinkQuality ;
  u8 localBuf[11U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  LinkQuality = 85U;
  PLH = *((u16 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("PLH = 0x%x\n", (int )PLH);
  } else {

  }
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )((unsigned char )PLH));
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("No such PLH(0x%x)\n", (int )PLH);
    } else {

    }
    status = 2;
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 11U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 3, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk(" PLH = 0x%x\n Link Quality = 0x%x\n", (int )PLH, (int )LinkQuality);
  } else {

  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *((u16 *)pRetPar + 1U) = (u16 )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  *(pRetPar + 3UL) = 85U;
  len = (unsigned int )len + 4U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdCreateLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntCreateLogLink = pBtDbg->dbgHciInfo.hciCmdCntCreateLogLink + 1U;
  bthci_BuildLogicalLink(padapter, pHciCmd, 56);
  return (0);
}
}
static enum hci_status bthci_CmdAcceptLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink = pBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink + 1U;
  bthci_BuildLogicalLink(padapter, pHciCmd, 57);
  return (0);
}
}
static enum hci_status bthci_CmdDisconnectLogicalLink(struct rtw_adapter *padapter ,
                                                      struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u16 logicHandle ;
  u8 i ;
  u8 j ;
  u8 find ;
  u8 LogLinkCount ;
  unsigned long tmp ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTinfo->BtMgnt;
  pBtDbg = & pBTinfo->BtDbg;
  find = 0U;
  LogLinkCount = 0U;
  pBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink = pBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink + 1U;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("DisconnectLogicalLink, logicHandle = 0x%x\n", (int )logicHandle);
  } else {

  }
  j = 0U;
  goto ldv_56700;
  ldv_56699: 
  i = 0U;
  goto ldv_56698;
  ldv_56697: ;
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
    if (BTCoexDbgLevel == 1U) {
      printk("DisconnectLogicalLink, logicHandle is matched  0x%x\n", (int )logicHandle);
    } else {

    }
    bthci_ResetFlowSpec(padapter, (int )j, (int )i);
    find = 1U;
    pBtMgnt->DisconnectEntryNum = j;
    goto ldv_56696;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56698: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_56697;
  } else {

  }
  ldv_56696: 
  j = (u8 )((int )j + 1);
  ldv_56700: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_56699;
  } else {

  }

  if ((unsigned int )find == 0U) {
    status = 2;
  } else {

  }
  i = 0U;
  goto ldv_56703;
  ldv_56702: ;
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )pBtMgnt->DisconnectEntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle != 0U) {
    LogLinkCount = (u8 )((int )LogLinkCount + 1);
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56703: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_56702;
  } else {

  }
  bthci_EventCommandStatus(padapter, 1, 58, status);
  if ((unsigned int )status == 0U) {
    bthci_EventDisconnectLogicalLinkComplete(padapter, status, (int )logicHandle,
                                             22);
  } else {

  }
  if ((unsigned int )LogLinkCount == 0U) {
    tmp = msecs_to_jiffies(100U);
    ldv_mod_timer_773(& pBTinfo->BTDisconnectPhyLinkTimer, tmp + (unsigned long )jiffies);
  } else {

  }
  return (status);
}
}
static enum hci_status bthci_CmdLogicalLinkCancel(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 CurrentEntryNum ;
  u8 CurrentLogEntryNum ;
  u8 physicalLinkHandle ;
  u8 TxFlowSpecID ;
  u8 i ;
  u16 CurrentLogicalHandle ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTinfo->BtMgnt;
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
  TxFlowSpecID = *((u8 *)(& pHciCmd->Data) + 1UL);
  if (BTCoexDbgLevel == 1U) {
    printk("LogicalLinkCancel, physicalLinkHandle = 0x%x, TxFlowSpecID = 0x%x\n",
           (int )physicalLinkHandle, (int )TxFlowSpecID);
  } else {

  }
  CurrentEntryNum = pBtMgnt->CurrentConnectEntryNum;
  CurrentLogicalHandle = pBtMgnt->BtCurrentLogLinkhandle;
  if (BTCoexDbgLevel == 1U) {
    printk("CurrentEntryNum = 0x%x, CurrentLogicalHandle = 0x%x\n", (int )CurrentEntryNum,
           (int )CurrentLogicalHandle);
  } else {

  }
  CurrentLogEntryNum = 255U;
  i = 0U;
  goto ldv_56720;
  ldv_56719: ;
  if ((int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )CurrentLogicalHandle && (int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle == (int )physicalLinkHandle) {
    CurrentLogEntryNum = i;
    goto ldv_56718;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56720: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_56719;
  } else {

  }
  ldv_56718: ;
  if ((unsigned int )CurrentLogEntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("LogicalLinkCancel, CurrentLogEntryNum == 0xff !!!!\n");
    } else {

    }
    status = 2;
    return (status);
  } else
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].bLLCompleteEventIsSet != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("LogicalLinkCancel, LLCompleteEventIsSet!!!!\n");
    } else {

    }
    status = 11;
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 1, 59, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].BtPhyLinkhandle;
  *(pRetPar + 2UL) = pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].BtTxFlowSpecID;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].bLLCancelCMDIsSetandComplete = 1U;
  return (status);
}
}
static enum hci_status bthci_CmdFlowSpecModify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 i ;
  u8 j ;
  u8 find ;
  u16 logicHandle ;

  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  find = 0U;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  j = 0U;
  goto ldv_56739;
  ldv_56738: 
  i = 0U;
  goto ldv_56737;
  ldv_56736: ;
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
    memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec),
             (void const   *)(& pHciCmd->Data) + 2U, 16UL);
    memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Rx_Flow_Spec),
             (void const   *)(& pHciCmd->Data) + 18U, 16UL);
    bthci_CheckLogLinkBehavior(padapter, pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec);
    find = 1U;
    goto ldv_56735;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56737: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_56736;
  } else {

  }
  ldv_56735: 
  j = (u8 )((int )j + 1);
  ldv_56739: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_56738;
  } else {

  }

  if (BTCoexDbgLevel == 1U) {
    printk("FlowSpecModify, LLH = 0x%x, \n", (int )logicHandle);
  } else {

  }
  bthci_EventCommandStatus(padapter, 1, 60, 0);
  if ((unsigned int )find == 0U) {
    status = 2;
  } else {

  }
  bthci_EventSendFlowSpecModifyComplete(padapter, status, (int )logicHandle);
  return (status);
}
}
static enum hci_status bthci_CmdAcceptPhysicalLink(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink = pBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink + 1U;
  status = bthci_BuildPhysicalLink(padapter, pHciCmd, 54);
  return (status);
}
}
static enum hci_status bthci_CmdDisconnectPhysicalLink(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 PLH ;
  u8 CurrentEntryNum ;
  u8 PhysLinkDisconnectReason ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink = pBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink + 1U;
  PLH = *((u8 *)(& pHciCmd->Data));
  PhysLinkDisconnectReason = *((u8 *)(& pHciCmd->Data) + 1UL);
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_DISCONNECT_PHYSICAL_LINK  PhyHandle = 0x%x, Reason = 0x%x\n", (int )PLH,
           (int )PhysLinkDisconnectReason);
  } else {

  }
  CurrentEntryNum = bthci_GetCurrentEntryNum(padapter, (int )PLH);
  if ((unsigned int )CurrentEntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("DisconnectPhysicalLink, No such Handle in the Entry\n");
    } else {

    }
    status = 2;
  } else {
    pBTInfo->BtAsocEntry[(int )CurrentEntryNum].PhyLinkDisconnectReason = (enum hci_status )PhysLinkDisconnectReason;
  }
  bthci_EventCommandStatus(padapter, 1, 55, status);
  if ((unsigned int )status != 0U) {
    return (status);
  } else {

  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentEntryNum].BtCurrentState == 32U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_CmdDisconnectPhysicalLink",
             3235);
    } else {

    }
    BTHCI_StateMachine(padapter, 32, 2, (int )CurrentEntryNum);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_CmdDisconnectPhysicalLink",
             3237);
    } else {

    }
    BTHCI_StateMachine(padapter, 16, 2, (int )CurrentEntryNum);
  }
  return (status);
}
}
static enum hci_status bthci_CmdSetACLLinkDataFlowMode(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBtMgnt->ExtConfig.CurrentConnectHandle = *((u16 *)(& pHciCmd->Data));
  pBtMgnt->ExtConfig.CurrentIncomingTrafficMode = (unsigned int )*((u8 *)(& pHciCmd->Data)) + 2U;
  pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = (unsigned int )*((u8 *)(& pHciCmd->Data)) + 3U;
  if (BTCoexDbgLevel == 1U) {
    printk("Connection Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic mode = 0x%x",
           (int )pBtMgnt->ExtConfig.CurrentConnectHandle, (int )pBtMgnt->ExtConfig.CurrentIncomingTrafficMode,
           (int )pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode);
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 16, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = pBtMgnt->ExtConfig.CurrentConnectHandle;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetACLLinkStatus(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 *pTriple ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus = pBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus + 1U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("SetACLLinkStatus, Hex Data :\n");
    __i = 0U;
    goto ldv_56784;
    ldv_56783: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56784: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_56783;
    } else {

    }
    printk("\n");
  } else {

  }
  pBtMgnt->bSupportProfile = 1U;
  pBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("NumberOfHandle = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
  } else {

  }
  pTriple = (u8 *)(& pHciCmd->Data) + 1UL;
  i = 0U;
  goto ldv_56787;
  ldv_56786: 
  pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = *(pTriple + 2UL);
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = *(pTriple + 3UL);
  if (BTCoexDbgLevel == 1U) {
    printk("Connection_Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic Mode = 0x%x\n",
           (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode,
           (int )pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode);
  } else {

  }
  pTriple = pTriple + 4UL;
  i = (u8 )((int )i + 1);
  ldv_56787: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_56786;
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 32, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetSCOLinkStatus(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus = pBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus + 1U;
  pBtMgnt->ExtConfig.NumberOfSCO = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("NumberOfSCO = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfSCO);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 48, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetRSSIValue(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  s8 min_bt_rssi ;
  u8 i ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  min_bt_rssi = 0;
  i = 0U;
  goto ldv_56815;
  ldv_56814: ;
  if ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle == (int )*((u16 *)(& pHciCmd->Data))) {
    pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI = (signed char )pHciCmd->Data[2];
    if (BTCoexDbgLevel == 1U) {
      printk("Connection_Handle = 0x%x, RSSI = %d \n", (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI);
    } else {

    }
  } else {

  }
  if ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI <= (int )min_bt_rssi) {
    min_bt_rssi = pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56815: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_56814;
  } else {

  }
  pBtMgnt->ExtConfig.MIN_BT_RSSI = min_bt_rssi;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt rssi], the min rssi is %d\n", (int )min_bt_rssi);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 64, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetCurrentBluetoothStatus(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtMgnt->ExtConfig.CurrentBTStatus = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("SetCurrentBluetoothStatus, CurrentBTStatus = 0x%x\n", (int )pBtMgnt->ExtConfig.CurrentBTStatus);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 65, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdExtensionVersionNotify(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify = pBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify + 1U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("ExtensionVersionNotify, Hex Data :\n");
    __i = 0U;
    goto ldv_56843;
    ldv_56842: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56843: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_56842;
    } else {

    }
    printk("\n");
  } else {

  }
  pBtMgnt->ExtConfig.HCIExtensionVer = *((u16 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("HCIExtensionVer = 0x%x\n", (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 256, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdLinkStatusNotify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 *pTriple ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify = pBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify + 1U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("LinkStatusNotify, Hex Data :\n");
    __i = 0U;
    goto ldv_56862;
    ldv_56861: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56862: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_56861;
    } else {

    }
    printk("\n");
  } else {

  }
  pBtMgnt->bSupportProfile = 1U;
  pBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("NumberOfHandle = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCIExtensionVer = %d\n", (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  } else {

  }
  pTriple = (u8 *)(& pHciCmd->Data) + 1UL;
  i = 0U;
  goto ldv_56865;
  ldv_56864: ;
  if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer == 0U) {
    pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = *(pTriple + 2UL);
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = *(pTriple + 3UL);
    if (BTCoexDbgLevel == 1U) {
      printk("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d\n", (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec);
    } else {

    }
    pTriple = pTriple + 4UL;
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer != 0U) {
    pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = *(pTriple + 2UL);
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = *(pTriple + 3UL);
    pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole = *(pTriple + 4UL);
    if (BTCoexDbgLevel == 1U) {
      printk("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d, LinkRole =%d\n",
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole);
    } else {

    }
    pTriple = pTriple + 5UL;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_56865: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_56864;
  } else {

  }
  BTHCI_UpdateBTProfileRTKToMoto(padapter);
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 257, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdBtOperationNotify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("Bt Operation notify, Hex Data :\n");
    __i = 0U;
    goto ldv_56881;
    ldv_56880: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56881: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_56880;
    } else {

    }
    printk("\n");
  } else {

  }
  pBtMgnt->ExtConfig.btOperationCode = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("btOperationCode = 0x%x\n", (int )pBtMgnt->ExtConfig.btOperationCode);
  } else {

  }
  switch ((int )pBtMgnt->ExtConfig.btOperationCode) {
  case 0: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Operation None!!\n");
  } else {

  }
  goto ldv_56884;
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Inquire start!!\n");
  } else {

  }
  goto ldv_56884;
  case 2: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Inquire finished!!\n");
  } else {

  }
  goto ldv_56884;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Paging is started!!\n");
  } else {

  }
  goto ldv_56884;
  case 4: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Paging complete successfully!!\n");
  } else {

  }
  goto ldv_56884;
  case 5: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Paging complete unsuccessfully!!\n");
  } else {

  }
  goto ldv_56884;
  case 6: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Pairing start!!\n");
  } else {

  }
  goto ldv_56884;
  case 7: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Pairing finished!!\n");
  } else {

  }
  goto ldv_56884;
  case 8: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : BT Device is enabled!!\n");
  } else {

  }
  goto ldv_56884;
  case 9: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : BT Device is disabled!!\n");
  } else {

  }
  goto ldv_56884;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Unknown, error!!\n");
  } else {

  }
  goto ldv_56884;
  }
  ldv_56884: 
  BTDM_AdjustForBtOperation(padapter);
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 258, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdEnableWifiScanNotify(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("Enable Wifi scan notify, Hex Data :\n");
    __i = 0U;
    goto ldv_56909;
    ldv_56908: 
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {

    }
    __i = __i + 1U;
    ldv_56909: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_56908;
    } else {

    }
    printk("\n");
  } else {

  }
  pBtMgnt->ExtConfig.bEnableWifiScanNotify = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("bEnableWifiScanNotify = %d\n", (int )pBtMgnt->ExtConfig.bEnableWifiScanNotify);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 259, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWIFICurrentChannel(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct mlme_ext_priv *pmlmeext ;
  u8 chnl ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pmlmeext = & padapter->mlmeextpriv;
  chnl = pmlmeext->cur_channel;
  if ((unsigned int )pmlmeext->cur_bwmode == 1U) {
    if ((unsigned int )pmlmeext->cur_ch_offset == 2U) {
      chnl = (unsigned int )chnl + 2U;
    } else
    if ((unsigned int )pmlmeext->cur_ch_offset == 1U) {
      chnl = (unsigned int )chnl + 254U;
    } else {

    }
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Current Channel  = 0x%x\n", (int )chnl);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 768, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = chnl;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWIFICurrentBandwidth(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  enum ht_channel_width bw ;
  u8 CurrentBW ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  CurrentBW = 0U;
  bw = (enum ht_channel_width )padapter->mlmeextpriv.cur_bwmode;
  if ((unsigned int )bw == 0U) {
    CurrentBW = 0U;
  } else
  if ((unsigned int )bw == 1U) {
    CurrentBW = 1U;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Current BW = 0x%x\n", (int )CurrentBW);
  } else {

  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 769, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = CurrentBW;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWIFIConnectionStatus(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  u8 connectStatus ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  u8 localBuf[8U] ;
  unsigned int tmp___2 ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___3 ;

  {
  status = 0;
  connectStatus = 0U;
  tmp___1 = check_fwstate(& padapter->mlmepriv, 16);
  if ((int )tmp___1) {
    if (padapter->stapriv.asoc_sta_count > 2) {
      connectStatus = 1U;
    } else {
      connectStatus = 0U;
    }
  } else {
    tmp___0 = check_fwstate(& padapter->mlmepriv, 97);
    if ((int )tmp___0) {
      connectStatus = 1U;
    } else {
      tmp = check_fwstate(& padapter->mlmepriv, 128);
      if ((int )tmp) {
        connectStatus = 2U;
      } else {
        connectStatus = 0U;
      }
    }
  }
  localBuf[0] = '\000';
  tmp___2 = 1U;
  while (1) {
    if (tmp___2 >= 8U) {
      break;
    } else {

    }
    localBuf[tmp___2] = (unsigned char)0;
    tmp___2 = tmp___2 + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___3 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 770, status);
  len = (int )tmp___3 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = connectStatus;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdEnableDeviceUnderTestMode(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtHciInfo->bInTestMode = 1U;
  pBtHciInfo->bTestIsEnd = 0U;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 6, 3, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdAMPTestEnd(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n");
    } else {

    }
    status = 12;
    return (status);
  } else {

  }
  pBtHciInfo->bTestIsEnd = 1U;
  ldv_del_timer_sync_774(& pBTInfo->BTTestSendPacketTimer);
  rtl8723a_check_bssid(padapter, 1);
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 4U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("AMP Test End Event \n");
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 74U;
  PPacketIrpEvent->Length = 2U;
  PPacketIrpEvent->Data[0] = (u8 )status;
  PPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
  bthci_EventAMPReceiverReport(padapter, 1);
  return (status);
}
}
static enum hci_status bthci_CmdAMPTestCommand(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 localBuf___0[5U] ;
  unsigned int tmp___0 ;
  struct packet_irp_hcievent_data *PPacketIrpEvent___0 ;
  unsigned long tmp___1 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n");
    } else {

    }
    status = 12;
    return (status);
  } else {

  }
  pBtHciInfo->TestScenario = *((u8 *)(& pHciCmd->Data));
  if ((unsigned int )pBtHciInfo->TestScenario == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("TX Single Test \n");
    } else {

    }
  } else
  if ((unsigned int )pBtHciInfo->TestScenario == 2U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Receive Frame Test \n");
    } else {

    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("No Such Test !!!!!!!!!!!!!!!!!! \n");
  } else {

  }
  if ((unsigned int )pBtHciInfo->bTestIsEnd != 0U) {
    localBuf[0] = '\000';
    tmp = 1U;
    while (1) {
      if (tmp >= 5U) {
        break;
      } else {

      }
      localBuf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    if (BTCoexDbgLevel == 1U) {
      printk("AMP Test End Event \n");
    } else {

    }
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
    PPacketIrpEvent->EventCode = 74U;
    PPacketIrpEvent->Length = 2U;
    PPacketIrpEvent->Data[0] = (u8 )status;
    PPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
    return (status);
  } else {

  }
  bthci_EventCommandStatus(padapter, 6, 9, status);
  localBuf___0[0] = '\000';
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 5U) {
      break;
    } else {

    }
    localBuf___0[tmp___0] = (unsigned char)0;
    tmp___0 = tmp___0 + 1U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk(" HCI_AMP_Start Test Event \n");
  } else {

  }
  PPacketIrpEvent___0 = (struct packet_irp_hcievent_data *)(& localBuf___0);
  PPacketIrpEvent___0->EventCode = 73U;
  PPacketIrpEvent___0->Length = 2U;
  PPacketIrpEvent___0->Data[0] = (u8 )status;
  PPacketIrpEvent___0->Data[1] = pBtHciInfo->TestScenario;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent___0, 4U);
  if ((unsigned int )pBtHciInfo->TestScenario == 1U) {
    tmp___1 = msecs_to_jiffies(50U);
    ldv_mod_timer_775(& pBTInfo->BTTestSendPacketTimer, tmp___1 + (unsigned long )jiffies);
    if (BTCoexDbgLevel == 1U) {
      printk("TX Single Test \n");
    } else {

    }
  } else
  if ((unsigned int )pBtHciInfo->TestScenario == 2U) {
    rtl8723a_check_bssid(padapter, 0);
    if (BTCoexDbgLevel == 1U) {
      printk("Receive Frame Test \n");
    } else {

    }
  } else {

  }
  return (status);
}
}
static enum hci_status bthci_CmdEnableAMPReceiverReports(struct rtw_adapter *padapter ,
                                                         struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  u8 localBuf___0[6U] ;
  unsigned int tmp___1 ;
  u8 *pRetPar___0 ;
  u8 len___0 ;
  struct packet_irp_hcievent_data *PPacketIrpEvent___0 ;
  u8 tmp___2 ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
    status = 12;
    localBuf[0] = '\000';
    tmp = 1U;
    while (1) {
      if (tmp >= 6U) {
        break;
      } else {

      }
      localBuf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    len = 0U;
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
    tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 6, 7, status);
    len = (int )tmp___0 + (int )len;
    pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
    *pRetPar = (u8 )status;
    len = (unsigned int )len + 1U;
    PPacketIrpEvent->Length = len;
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
    return (status);
  } else {

  }
  pBtHciInfo->bTestNeedReport = *((u8 *)(& pHciCmd->Data));
  pBtHciInfo->TestReportInterval = *((u8 *)(& pHciCmd->Data) + 2UL);
  bthci_EventAMPReceiverReport(padapter, 0);
  localBuf___0[0] = '\000';
  tmp___1 = 1U;
  while (1) {
    if (tmp___1 >= 6U) {
      break;
    } else {

    }
    localBuf___0[tmp___1] = (unsigned char)0;
    tmp___1 = tmp___1 + 1U;
  }
  len___0 = 0U;
  PPacketIrpEvent___0 = (struct packet_irp_hcievent_data *)(& localBuf___0);
  tmp___2 = bthci_CommandCompleteHeader((u8 *)(& localBuf___0), 6, 7, status);
  len___0 = (int )tmp___2 + (int )len___0;
  pRetPar___0 = (u8 *)(& PPacketIrpEvent___0->Data) + (unsigned long )len___0;
  *pRetPar___0 = (u8 )status;
  len___0 = (unsigned int )len___0 + 1U;
  PPacketIrpEvent___0->Length = len___0;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent___0, (u32 )((int )len___0 + 2));
  return (status);
}
}
static enum hci_status bthci_CmdHostBufferSize(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  enum hci_status status ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  u8 tmp___0 ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].ACLPacketsData.ACLDataPacketLen = *((u16 *)(& pHciCmd->Data));
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].SyncDataPacketLen = *((u8 *)(& pHciCmd->Data) + 2UL);
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].TotalNumACLDataPackets = *((u16 *)(& pHciCmd->Data) + 3U);
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].TotalSyncNumDataPackets = *((u16 *)(& pHciCmd->Data) + 5U);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 51, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_UnknownCMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
  status = 1;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntUnknown = pBtDbg->dbgHciInfo.hciCmdCntUnknown + 1U;
  bthci_EventCommandStatus(padapter, (int )pHciCmd->OGF, (int )pHciCmd->OCF, status);
  return (status);
}
}
static enum hci_status bthci_HandleOGFInformationalParameters(struct rtw_adapter *padapter ,
                                                              struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_VERSION_INFORMATION\n");
  } else {

  }
  status = bthci_CmdReadLocalVersionInformation(padapter);
  goto ldv_57017;
  case 2: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_SUPPORTED_COMMANDS\n");
  } else {

  }
  status = bthci_CmdReadLocalSupportedCommands(padapter);
  goto ldv_57017;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_SUPPORTED_FEATURES\n");
  } else {

  }
  status = bthci_CmdReadLocalSupportedFeatures(padapter);
  goto ldv_57017;
  case 5: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_BUFFER_SIZE\n");
  } else {

  }
  status = bthci_CmdReadBufferSize(padapter);
  goto ldv_57017;
  case 10: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_DATA_BLOCK_SIZE\n");
  } else {

  }
  status = bthci_CmdReadDataBlockSize(padapter);
  goto ldv_57017;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_HandleOGFInformationalParameters(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_57017;
  }
  ldv_57017: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFSetEventMaskCMD(struct rtw_adapter *padapter ,
                                                      struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_EVENT_MASK\n");
  } else {

  }
  status = bthci_CmdSetEventMask(padapter, pHciCmd);
  goto ldv_57029;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_RESET\n");
  } else {

  }
  status = bthci_CmdReset(padapter, 1);
  goto ldv_57029;
  case 21: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_CONNECTION_ACCEPT_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdReadConnectionAcceptTimeout(padapter);
  goto ldv_57029;
  case 5: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_EVENT_FILTER\n");
  } else {

  }
  goto ldv_57029;
  case 22: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdWriteConnectionAcceptTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 23: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_PAGE_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdReadPageTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 24: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_PAGE_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdWritePageTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 53: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_HOST_NUMBER_OF_COMPLETED_PACKETS\n");
  } else {

  }
  goto ldv_57029;
  case 54: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LINK_SUPERVISION_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdReadLinkSupervisionTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 55: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_LINK_SUPERVISION_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdWriteLinkSupervisionTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 95: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ENHANCED_FLUSH\n");
  } else {

  }
  status = bthci_CmdEnhancedFlush(padapter, pHciCmd);
  goto ldv_57029;
  case 97: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdReadLogicalLinkAcceptTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 98: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdWriteLogicalLinkAcceptTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 99: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_EVENT_MASK_PAGE_2\n");
  } else {

  }
  status = bthci_CmdSetEventMaskPage2(padapter, pHciCmd);
  goto ldv_57029;
  case 100: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCATION_DATA\n");
  } else {

  }
  status = bthci_CmdReadLocationData(padapter, pHciCmd);
  goto ldv_57029;
  case 101: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_LOCATION_DATA\n");
  } else {

  }
  status = bthci_CmdWriteLocationData(padapter, pHciCmd);
  goto ldv_57029;
  case 102: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_FLOW_CONTROL_MODE\n");
  } else {

  }
  status = bthci_CmdReadFlowControlMode(padapter, pHciCmd);
  goto ldv_57029;
  case 103: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_FLOW_CONTROL_MODE\n");
  } else {

  }
  status = bthci_CmdWriteFlowControlMode(padapter, pHciCmd);
  goto ldv_57029;
  case 105: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_BEST_EFFORT_FLUSH_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdReadBestEffortFlushTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 106: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_BEST_EFFORT_FLUSH_TIMEOUT\n");
  } else {

  }
  status = bthci_CmdWriteBestEffortFlushTimeout(padapter, pHciCmd);
  goto ldv_57029;
  case 107: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SHORT_RANGE_MODE\n");
  } else {

  }
  status = bthci_CmdShortRangeMode(padapter, pHciCmd);
  goto ldv_57029;
  case 51: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_HOST_BUFFER_SIZE\n");
  } else {

  }
  status = bthci_CmdHostBufferSize(padapter, pHciCmd);
  goto ldv_57029;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_HandleOGFSetEventMaskCMD(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_57029;
  }
  ldv_57029: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFStatusParameters(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_FAILED_CONTACT_COUNTER\n");
  } else {

  }
  status = bthci_CmdReadFailedContactCounter(padapter, pHciCmd);
  goto ldv_57058;
  case 2: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_RESET_FAILED_CONTACT_COUNTER\n");
  } else {

  }
  status = bthci_CmdResetFailedContactCounter(padapter, pHciCmd);
  goto ldv_57058;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LINK_QUALITY\n");
  } else {

  }
  status = bthci_CmdReadLinkQuality(padapter, pHciCmd);
  goto ldv_57058;
  case 5: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_RSSI\n");
  } else {

  }
  goto ldv_57058;
  case 9: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_AMP_INFO\n");
  } else {

  }
  status = bthci_CmdReadLocalAMPInfo(padapter);
  goto ldv_57058;
  case 10: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_AMP_ASSOC\n");
  } else {

  }
  status = bthci_CmdReadLocalAMPAssoc(padapter, pHciCmd);
  goto ldv_57058;
  case 11: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_REMOTE_AMP_ASSOC\n");
  } else {

  }
  status = bthci_CmdWriteRemoteAMPAssoc(padapter, pHciCmd);
  goto ldv_57058;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_HandleOGFStatusParameters(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_57058;
  }
  ldv_57058: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFLinkControlCMD(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 53: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_CREATE_PHYSICAL_LINK\n");
  } else {

  }
  status = bthci_CmdCreatePhysicalLink(padapter, pHciCmd);
  goto ldv_57072;
  case 54: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ACCEPT_PHYSICAL_LINK\n");
  } else {

  }
  status = bthci_CmdAcceptPhysicalLink(padapter, pHciCmd);
  goto ldv_57072;
  case 55: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_DISCONNECT_PHYSICAL_LINK\n");
  } else {

  }
  status = bthci_CmdDisconnectPhysicalLink(padapter, pHciCmd);
  goto ldv_57072;
  case 56: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_CREATE_LOGICAL_LINK\n");
  } else {

  }
  status = bthci_CmdCreateLogicalLink(padapter, pHciCmd);
  goto ldv_57072;
  case 57: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ACCEPT_LOGICAL_LINK\n");
  } else {

  }
  status = bthci_CmdAcceptLogicalLink(padapter, pHciCmd);
  goto ldv_57072;
  case 58: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_DISCONNECT_LOGICAL_LINK\n");
  } else {

  }
  status = bthci_CmdDisconnectLogicalLink(padapter, pHciCmd);
  goto ldv_57072;
  case 59: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_LOGICAL_LINK_CANCEL\n");
  } else {

  }
  status = bthci_CmdLogicalLinkCancel(padapter, pHciCmd);
  goto ldv_57072;
  case 60: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_FLOW_SPEC_MODIFY\n");
  } else {

  }
  status = bthci_CmdFlowSpecModify(padapter, pHciCmd);
  goto ldv_57072;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_HandleOGFLinkControlCMD(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_57072;
  }
  ldv_57072: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFTestingCMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ENABLE_DEVICE_UNDER_TEST_MODE\n");
  } else {

  }
  bthci_CmdEnableDeviceUnderTestMode(padapter, pHciCmd);
  goto ldv_57087;
  case 8: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_AMP_TEST_END\n");
  } else {

  }
  bthci_CmdAMPTestEnd(padapter, pHciCmd);
  goto ldv_57087;
  case 9: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_AMP_TEST_COMMAND\n");
  } else {

  }
  bthci_CmdAMPTestCommand(padapter, pHciCmd);
  goto ldv_57087;
  case 7: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ENABLE_AMP_RECEIVER_REPORTS\n");
  } else {

  }
  bthci_CmdEnableAMPReceiverReports(padapter, pHciCmd);
  goto ldv_57087;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_57087;
  }
  ldv_57087: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFExtension(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 16: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_ACL_LINK_DATA_FLOW_MODE\n");
  } else {

  }
  status = bthci_CmdSetACLLinkDataFlowMode(padapter, pHciCmd);
  goto ldv_57098;
  case 32: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_ACL_LINK_STATUS\n");
  } else {

  }
  status = bthci_CmdSetACLLinkStatus(padapter, pHciCmd);
  goto ldv_57098;
  case 48: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_SCO_LINK_STATUS\n");
  } else {

  }
  status = bthci_CmdSetSCOLinkStatus(padapter, pHciCmd);
  goto ldv_57098;
  case 64: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_RSSI_VALUE\n");
  } else {

  }
  status = bthci_CmdSetRSSIValue(padapter, pHciCmd);
  goto ldv_57098;
  case 65: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_CURRENT_BLUETOOTH_STATUS\n");
  } else {

  }
  status = bthci_CmdSetCurrentBluetoothStatus(padapter, pHciCmd);
  goto ldv_57098;
  case 256: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_EXTENSION_VERSION_NOTIFY\n");
  } else {

  }
  status = bthci_CmdExtensionVersionNotify(padapter, pHciCmd);
  goto ldv_57098;
  case 257: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_LINK_STATUS_NOTIFY\n");
  } else {

  }
  status = bthci_CmdLinkStatusNotify(padapter, pHciCmd);
  goto ldv_57098;
  case 258: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_BT_OPERATION_NOTIFY\n");
  } else {

  }
  status = bthci_CmdBtOperationNotify(padapter, pHciCmd);
  goto ldv_57098;
  case 259: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ENABLE_WIFI_SCAN_NOTIFY\n");
  } else {

  }
  status = bthci_CmdEnableWifiScanNotify(padapter, pHciCmd);
  goto ldv_57098;
  case 768: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WIFI_CURRENT_CHANNEL\n");
  } else {

  }
  status = bthci_CmdWIFICurrentChannel(padapter, pHciCmd);
  goto ldv_57098;
  case 769: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WIFI_CURRENT_BANDWIDTH\n");
  } else {

  }
  status = bthci_CmdWIFICurrentBandwidth(padapter, pHciCmd);
  goto ldv_57098;
  case 770: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WIFI_CONNECTION_STATUS\n");
  } else {

  }
  status = bthci_CmdWIFIConnectionStatus(padapter, pHciCmd);
  goto ldv_57098;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_57098;
  }
  ldv_57098: ;
  return (status);
}
}
static void bthci_StateStarting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Starting], ");
  } else {

  }
  switch ((unsigned int )StateCmd) {
  case 3U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57119;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  ldv_del_timer_sync_776(& pBTInfo->BTHCIJoinTimeoutTimer);
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57119;
  case 4U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_START_COMPLETE\n");
  } else {

  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 1U) {
    bthci_EventChannelSelected(padapter, (int )EntryNum);
  } else {

  }
  goto ldv_57119;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
  goto ldv_57119;
  }
  ldv_57119: ;
  return;
}
}
static void bthci_StateConnecting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                  u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Connecting], ");
  } else {

  }
  switch ((unsigned int )StateCmd) {
  case 3U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57131;
  case 6U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_CONNECT_COMPLETE\n");
  } else {

  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 2U) {
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(4096, 7, "StateConnecting\n");
    } else {

    }
  } else {

  }
  goto ldv_57131;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
  ldv_del_timer_sync_777(& pBTInfo->BTHCIJoinTimeoutTimer);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57131;
  case 9U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n");
  } else {

  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 58;
  pBtMgnt->bNeedNotifyAMPNoCap = 0U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57131;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
  goto ldv_57131;
  }
  ldv_57131: ;
  return;
}
}
static void bthci_StateConnected(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                 u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;
  u16 logicHandle ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  logicHandle = 0U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Connected], ");
  } else {

  }
  switch ((unsigned int )StateCmd) {
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
  i = 0U;
  goto ldv_57147;
  ldv_57146: ;
  if ((unsigned int )((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle != 0U) {
    logicHandle = ((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle;
    bthci_EventDisconnectLogicalLinkComplete(padapter, 0, (int )logicHandle, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason);
    ((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle = 0U;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_57147: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_57146;
  } else {

  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  ldv_del_timer_sync_778(& pBTInfo->BTHCIJoinTimeoutTimer);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57149;
  case 8U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_DISCONNECT_INDICATE\n");
  } else {

  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, 22, (int )EntryNum);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57149;
  case 12U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_ENTER_STATE\n");
  } else {

  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    pBtMgnt->bBTConnectInProgress = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
  pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState = 8U;
  pBTInfo->BtAsocEntry[(int )EntryNum].b4waySuccess = 1U;
  pBtMgnt->bStartSendSupervisionPkt = 1U;
  rtl8723a_update_ramask(padapter, (u32 )(63 - (int )EntryNum), 0);
  HalSetBrateCfg23a(padapter, (u8 *)(& padapter->mlmepriv.cur_network.network.SupportedRates));
  BTDM_SetFwChnlInfo(padapter, 1);
  goto ldv_57149;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
  goto ldv_57149;
  }
  ldv_57149: ;
  return;
}
}
static void bthci_StateAuth(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                            u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Authenticating], ");
  } else {

  }
  switch ((unsigned int )StateCmd) {
  case 3U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57161;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
  ldv_del_timer_sync_779(& pBTInfo->BTHCIJoinTimeoutTimer);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57161;
  case 10U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_4WAY_FAILED\n");
  } else {

  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 5;
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  ldv_del_timer_sync_780(& pBTInfo->BTHCIJoinTimeoutTimer);
  goto ldv_57161;
  case 11U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_4WAY_SUCCESSED\n");
  } else {

  }
  bthci_EventPhysicalLinkComplete(padapter, 0, (int )EntryNum, 255);
  ldv_del_timer_sync_781(& pBTInfo->BTHCIJoinTimeoutTimer);
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateAuth", 4673);
  } else {

  }
  BTHCI_StateMachine(padapter, 8, 12, (int )EntryNum);
  goto ldv_57161;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
  goto ldv_57161;
  }
  ldv_57161: ;
  return;
}
}
static void bthci_StateDisconnecting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                     u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Disconnecting], ");
  } else {

  }
  switch ((unsigned int )StateCmd) {
  case 9U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n");
  } else {

  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent != 0U) {
    bthci_EventPhysicalLinkComplete(padapter, pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus,
                                    (int )EntryNum, 255);
  } else {

  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    pBtMgnt->bBTConnectInProgress = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateDisconnecting",
           4703);
  } else {

  }
  BTHCI_StateMachine(padapter, 32, 12, (int )EntryNum);
  goto ldv_57176;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  ldv_del_timer_sync_782(& pBTInfo->BTHCIJoinTimeoutTimer);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_57176;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
  goto ldv_57176;
  }
  ldv_57176: ;
  return;
}
}
static void bthci_StateDisconnected(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                    u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_mgnt *pBtMgnt ;
  unsigned long __ms ;
  unsigned long tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Disconnected], ");
  } else {

  }
  switch ((unsigned int )StateCmd) {
  case 0U: ;
  case 1U: ;
  if ((unsigned int )StateCmd == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("STATE_CMD_CREATE_PHY_LINK\n");
    } else {

    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_ACCEPT_PHY_LINK\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT PS], Disable IPS and LPS\n");
  } else {

  }
  ips_leave23a(padapter);
  LPS_Leave23a(padapter);
  pBtMgnt->bPhyLinkInProgress = 1U;
  pBtMgnt->BTCurrentConnectType = 4;
  pBtMgnt->CurrentBTConnectionCnt = (u8 )((int )pBtMgnt->CurrentBTConnectionCnt + 1);
  if (BTCoexDbgLevel == 1U) {
    printk("[BT Flag], CurrentBTConnectionCnt = %d\n", (int )pBtMgnt->CurrentBTConnectionCnt);
  } else {

  }
  pBtMgnt->BtOperationOn = 1U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT Flag], Bt Operation ON!! CurrentConnectEntryNum = %d\n", (int )pBtMgnt->CurrentConnectEntryNum);
  } else {

  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    bthci_EventPhysicalLinkComplete(padapter, 58, 255, (int )pBtMgnt->BtCurrentPhyLinkhandle);
    bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
    return;
  } else {

  }
  if ((unsigned int )StateCmd == 0U) {
    pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole = 1;
  } else {
    pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole = 2;
  }
  goto ldv_57194;
  ldv_57193: ;
  if (BTCoexDbgLevel == 1U) {
    printk("Scan/Roaming/Wifi Link is in Progress, wait 200 ms\n");
  } else {

  }
  __ms = 200UL;
  goto ldv_57191;
  ldv_57190: 
  __const_udelay(4295000UL);
  ldv_57191: 
  tmp = __ms;
  __ms = __ms - 1UL;
  if (tmp != 0UL) {
    goto ldv_57190;
  } else {

  }

  ldv_57194: 
  tmp___0 = check_fwstate(& padapter->mlmepriv, 2049);
  if ((int )tmp___0) {
    goto ldv_57193;
  } else {

  }

  if (BTCoexDbgLevel == 1U) {
    printk("Channel is Ready\n");
  } else {

  }
  tmp___1 = msecs_to_jiffies((unsigned int const   )pBtHciInfo->ConnAcceptTimeout);
  ldv_mod_timer_783(& pBTInfo->BTHCIJoinTimeoutTimer, tmp___1 + (unsigned long )jiffies);
  pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent = 1U;
  goto ldv_57196;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
  ldv_del_timer_sync_784(& pBTInfo->BTHCIJoinTimeoutTimer);
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent != 0U) {
    bthci_EventPhysicalLinkComplete(padapter, 2, (int )EntryNum, 255);
  } else {

  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    pBtMgnt->bBTConnectInProgress = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateDisconnected",
           4797);
  } else {

  }
  BTHCI_StateMachine(padapter, 32, 12, (int )EntryNum);
  bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
  goto ldv_57196;
  case 12U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_ENTER_STATE\n");
  } else {

  }
  goto ldv_57196;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
  goto ldv_57196;
  }
  ldv_57196: ;
  return;
}
}
void BTHCI_EventParse(struct rtw_adapter *padapter , void *pEvntData , u32 dataLen ) 
{ 


  {
  return;
}
}
u8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter ) 
{ 
  u8 bBtConnectionExist ;
  struct bt_30info *pBtinfo ;
  u8 i ;

  {
  bBtConnectionExist = 0U;
  pBtinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  i = 0U;
  goto ldv_57214;
  ldv_57213: ;
  if ((unsigned int )pBtinfo->BtAsocEntry[(int )i].b4waySuccess != 0U) {
    bBtConnectionExist = 1U;
    goto ldv_57212;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_57214: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_57213;
  } else {

  }
  ldv_57212: ;
  return (bBtConnectionExist);
}
}
static u8 BTHCI_CheckProfileExist(struct rtw_adapter *padapter , enum bt_traffic_mode_profile Profile ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 IsPRofile ;
  u8 i ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  IsPRofile = 0U;
  i = 0U;
  i = 0U;
  goto ldv_57225;
  ldv_57224: ;
  if ((unsigned int )pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile == (unsigned int )Profile) {
    IsPRofile = 1U;
    goto ldv_57223;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_57225: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_57224;
  } else {

  }
  ldv_57223: ;
  return (IsPRofile);
}
}
void BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  i = 0U;
  pBtMgnt->ExtConfig.NumberOfSCO = 0U;
  i = 0U;
  goto ldv_57239;
  ldv_57238: 
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = 0U;
  if ((unsigned int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile == 4U) {
    pBtMgnt->ExtConfig.NumberOfSCO = (u8 )((int )pBtMgnt->ExtConfig.NumberOfSCO + 1);
  } else {

  }
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile;
  switch ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile) {
  case 4: ;
  goto ldv_57233;
  case 2: 
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
  goto ldv_57233;
  case 1: 
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 3U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 3U;
  goto ldv_57233;
  case 3: 
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 1U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
  goto ldv_57233;
  default: ;
  goto ldv_57233;
  }
  ldv_57233: 
  i = (u8 )((int )i + 1);
  ldv_57239: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_57238;
  } else {

  }

  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], RTK, NumberOfHandle = %d, NumberOfSCO = %d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle,
           (int )pBtMgnt->ExtConfig.NumberOfSCO);
  } else {

  }
  return;
}
}
void BTHCI_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bEnableWifiScanNotify != 0U) {
    bthci_EventExtWifiScanNotify(padapter, (int )scanType);
  } else {

  }
  return;
}
}
void BTHCI_StateMachine(struct rtw_adapter *padapter , u8 StateToEnter , enum hci_state_with_cmd StateCmd ,
                        u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk(" StateMachine, error EntryNum = 0x%x \n", (int )EntryNum);
    } else {

    }
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk(" StateMachine, EntryNum = 0x%x, CurrentState = 0x%x, BtNextState = 0x%x,  StateCmd = 0x%x , StateToEnter = 0x%x\n",
           (int )EntryNum, (int )pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState, (unsigned int )StateCmd,
           (int )StateToEnter);
  } else {

  }
  if ((unsigned int )((int )pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState & (int )StateToEnter) != 0U) {
    pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState = StateToEnter;
    switch ((int )StateToEnter) {
    case 1: 
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 18U;
    bthci_StateStarting(padapter, StateCmd, (int )EntryNum);
    goto ldv_57256;
    case 2: 
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 22U;
    bthci_StateConnecting(padapter, StateCmd, (int )EntryNum);
    goto ldv_57256;
    case 4: 
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 24U;
    bthci_StateAuth(padapter, StateCmd, (int )EntryNum);
    goto ldv_57256;
    case 8: 
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 24U;
    bthci_StateConnected(padapter, StateCmd, (int )EntryNum);
    goto ldv_57256;
    case 16: 
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 48U;
    bthci_StateDisconnecting(padapter, StateCmd, (int )EntryNum);
    goto ldv_57256;
    case 32: 
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 35U;
    bthci_StateDisconnected(padapter, StateCmd, (int )EntryNum);
    goto ldv_57256;
    default: ;
    if (BTCoexDbgLevel == 1U) {
      printk(" StateMachine, Unknown state to enter!!!\n");
    } else {

    }
    goto ldv_57256;
    }
    ldv_57256: ;
  } else
  if (BTCoexDbgLevel == 1U) {
    printk(" StateMachine, Wrong state to enter\n");
  } else {

  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress == 0U && (unsigned int )pBtMgnt->BtOperationOn == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT PS], ips_enter23a()\n");
    } else {

    }
    ips_enter23a(padapter);
  } else {

  }
  return;
}
}
void BTHCI_DisconnectPeer(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk(" BTHCI_DisconnectPeer()\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectPeer", 4966);
  } else {

  }
  BTHCI_StateMachine(padapter, 16, 9, (int )EntryNum);
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    pBtMgnt->bBTConnectInProgress = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
  bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
  if ((unsigned int )pBtMgnt->bNeedNotifyAMPNoCap != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT AMPStatus], set to invalid in BTHCI_DisconnectPeer()\n");
    } else {

    }
    BTHCI_EventAMPStatusChange(padapter, 2);
  } else {

  }
  return;
}
}
void BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pTriple ;
  u8 len ;
  u8 i ;
  u8 j ;
  u8 handleNum ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u16 *pPackets ;
  u16 *pHandle ;
  u16 *pDblocks ;
  u8 sent ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  handleNum = 0U;
  sent = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  if ((pBtHciInfo->BTEventMaskPage2 & 256ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Num Of Completed DataBlocks, Ignore to send NumOfCompletedDataBlocksEvent due to event mask page 2\n");
    } else {

    }
    return;
  } else {

  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data);
  pTriple = pRetPar + 3UL;
  j = 0U;
  goto ldv_57292;
  ldv_57291: 
  i = 0U;
  goto ldv_57289;
  ldv_57288: ;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle != 0U) {
    handleNum = (u8 )((int )handleNum + 1);
    pHandle = (u16 *)pTriple;
    pPackets = (u16 *)pTriple + 2U;
    pDblocks = (u16 *)pTriple + 4U;
    *pHandle = pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle;
    *pPackets = (unsigned short )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount;
    *pDblocks = (unsigned short )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount;
    if (pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount != 0U) {
      sent = 1U;
      if (BTCoexDbgLevel == 1U) {
        printk("[BT event], Num Of Completed DataBlocks, Handle = 0x%x, Num_Of_Completed_Packets = 0x%x, Num_Of_Completed_Blocks = 0x%x\n",
               (int )*pHandle, (int )*pPackets, (int )*pDblocks);
      } else {

      }
    } else {

    }
    pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount = 0U;
    len = (unsigned int )len + 6U;
    pTriple = pTriple + (unsigned long )len;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_57289: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_57288;
  } else {

  }
  j = (u8 )((int )j + 1);
  ldv_57292: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_57291;
  } else {

  }
  *(pRetPar + 2UL) = handleNum;
  len = (unsigned int )len + 1U;
  pu2Temp = (u16 *)pRetPar;
  *pu2Temp = 256U;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->EventCode = 72U;
  PPacketIrpEvent->Length = len;
  if ((unsigned int )handleNum != 0U && (unsigned int )sent != 0U) {
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  } else {

  }
  return;
}
}
void BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter , u8 AMP_Status ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 len ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  enum rt_status tmp___0 ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  len = 0U;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 7U) {
      break;
    } else {

    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )AMP_Status == 2U) {
    pBtMgnt->BTNeedAMPStatusChg = 1U;
    pBtMgnt->bNeedNotifyAMPNoCap = 0U;
    BTHCI_DisconnectAll(padapter);
  } else
  if ((unsigned int )AMP_Status == 6U) {
    pBtMgnt->BTNeedAMPStatusChg = 0U;
  } else {

  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  pRetPar = (u8 *)(& PPacketIrpEvent->Data);
  *pRetPar = 0U;
  len = (unsigned int )len + 1U;
  *(pRetPar + 1UL) = AMP_Status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->EventCode = 77U;
  PPacketIrpEvent->Length = len;
  tmp___0 = bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  if ((unsigned int )tmp___0 == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], AMP Status Change, AMP_Status = %d\n", (int )AMP_Status);
    } else {

    }
  } else {

  }
  return;
}
}
void BTHCI_DisconnectAll(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  u8 i ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  if (BTCoexDbgLevel == 1U) {
    printk(" DisconnectALL()\n");
  } else {

  }
  i = 0U;
  goto ldv_57311;
  ldv_57310: ;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].b4waySuccess != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
             5085);
    } else {

    }
    BTHCI_StateMachine(padapter, 8, 2, (int )i);
  } else
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U) {
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].BtCurrentState == 2U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
               5088);
      } else {

      }
      BTHCI_StateMachine(padapter, 2, 9, (int )i);
    } else
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].BtCurrentState == 16U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
               5090);
      } else {

      }
      BTHCI_StateMachine(padapter, 16, 9, (int )i);
    } else {

    }
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_57311: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_57310;
  } else {

  }

  return;
}
}
enum hci_status BTHCI_HandleHCICMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u32 __i ;
  u8 *ptr ;

  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  if (BTCoexDbgLevel == 1U) {
    printk("\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI Command start, OGF = 0x%x, OCF = 0x%x, Length = 0x%x\n", (int )pHciCmd->OGF,
           (int )pHciCmd->OCF, (int )pHciCmd->Length);
  } else {

  }
  if ((unsigned int )pHciCmd->Length != 0U) {
    if (BTCoexDbgLevel == 1U) {
      ptr = (u8 *)(& pHciCmd->Data);
      printk("HCI Command, Hex Data :\n");
      __i = 0U;
      goto ldv_57323;
      ldv_57322: 
      printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
      if (((__i + 1U) & 15U) == 0U) {
        printk("\n");
      } else {

      }
      __i = __i + 1U;
      ldv_57323: ;
      if ((u32 )pHciCmd->Length > __i) {
        goto ldv_57322;
      } else {

      }
      printk("\n");
    } else {

    }
  } else {

  }
  if ((unsigned int )*((unsigned char *)pHciCmd + 1UL) == 252U) {
    if ((unsigned int )*((unsigned short *)pHciCmd + 0UL) == 64U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT cmd], ");
      } else {

      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[BT cmd], ");
    } else {

    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("[BT cmd], ");
  } else {

  }
  pBtDbg->dbgHciInfo.hciCmdCnt = pBtDbg->dbgHciInfo.hciCmdCnt + 1U;
  switch ((int )pHciCmd->OGF) {
  case 1: 
  status = bthci_HandleOGFLinkControlCMD(padapter, pHciCmd);
  goto ldv_57326;
  case 2: ;
  goto ldv_57326;
  case 3: 
  status = bthci_HandleOGFSetEventMaskCMD(padapter, pHciCmd);
  goto ldv_57326;
  case 4: 
  status = bthci_HandleOGFInformationalParameters(padapter, pHciCmd);
  goto ldv_57326;
  case 5: 
  status = bthci_HandleOGFStatusParameters(padapter, pHciCmd);
  goto ldv_57326;
  case 6: 
  status = bthci_HandleOGFTestingCMD(padapter, pHciCmd);
  goto ldv_57326;
  case 63: 
  status = bthci_HandleOGFExtension(padapter, pHciCmd);
  goto ldv_57326;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI Command(), Unknown OGF = 0x%x\n", (int )pHciCmd->OGF);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_57326;
  }
  ldv_57326: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI Command execution end!!\n");
  } else {

  }
  return (status);
}
}
static char const   * const  BtStateString[9U]  = 
  {      "BT_DISABLED",      "BT_NO_CONNECTION",      "BT_CONNECT_IDLE",      "BT_INQ_OR_PAG", 
        "BT_ACL_ONLY_BUSY",      "BT_SCO_ONLY_BUSY",      "BT_ACL_SCO_BUSY",      "BT_ACL_INQ_OR_PAG", 
        "BT_STATE_NOT_DEFINED"};
static void btdm_SetFwIgnoreWlanAct(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[1U] ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  if ((unsigned int )bEnable != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], BT Ignore Wlan_Act !!\n");
    } else {

    }
    H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 1U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT don\'t ignore Wlan_Act !!\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], set FW for BT Ignore Wlan_Act, write 0x25 = 0x%02x\n", (int )H2C_Parameter[0]);
  } else {

  }
  FillH2CCmd(padapter, 37, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
static void btdm_NotifyFwScan(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  u8 H2C_Parameter[1U] ;

  {
  H2C_Parameter[0] = 0U;
  if ((unsigned int )scanType == 1U) {
    H2C_Parameter[0] = 1U;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Notify FW for wifi scan, write 0x3b = 0x%02x\n", (int )H2C_Parameter[0]);
  } else {

  }
  FillH2CCmd(padapter, 59, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
static void btdm_1AntSetPSMode(struct rtw_adapter *padapter , u8 enable , u8 smartps ,
                               u8 mode ) 
{ 
  struct pwrctrl_priv *pwrctrl ;

  {
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Current LPS(%s, %d), smartps =%d\n", (unsigned int )enable == 1U ? (char *)"ON" : (char *)"OFF",
           (int )mode, (int )smartps);
  } else {

  }
  pwrctrl = & padapter->pwrctrlpriv;
  if ((unsigned int )enable == 1U) {
    rtw_set_ps_mode23a(padapter, 1, (int )smartps, (int )mode);
  } else {
    rtw_set_ps_mode23a(padapter, 0, 0, 0);
    LPS_RF_ON_check23a(padapter, 100U);
  }
  return;
}
}
static void btdm_1AntTSFSwitch(struct rtw_adapter *padapter , u8 enable ) 
{ 
  u8 oldVal ;
  u8 newVal ;

  {
  oldVal = rtl8723au_read8(padapter, 1360);
  if ((unsigned int )enable != 0U) {
    newVal = (u8 )((unsigned int )oldVal | 8U);
  } else {
    newVal = (unsigned int )oldVal & 247U;
  }
  if ((int )oldVal != (int )newVal) {
    rtl8723au_write8(padapter, 1360, (int )newVal);
  } else {

  }
  return;
}
}
static u8 btdm_Is1AntPsTdmaStateChange(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  if ((int )pBtdm8723->bPrePsTdmaOn != (int )pBtdm8723->bCurPsTdmaOn || (int )pBtdm8723->prePsTdma != (int )pBtdm8723->curPsTdma) {
    return (1U);
  } else {
    return (0U);
  }
}
}
static void btdm_1AntPsTdma(struct rtw_adapter *padapter , u8 bTurnOn , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  u8 tmp___15 ;
  u8 tmp___16 ;
  u8 tmp___17 ;
  u8 tmp___18 ;
  u8 tmp___19 ;
  u8 tmp___20 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  pBtdm8723->bCurPsTdmaOn = bTurnOn;
  pBtdm8723->curPsTdma = type;
  if ((unsigned int )bTurnOn != 0U) {
    switch ((int )type) {
    case 1: ;
    default: 
    tmp = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp != 0U) {
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 88);
    } else {

    }
    goto ldv_57373;
    case 2: 
    tmp___0 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      BTDM_SetFw3a(padapter, 211, 18, 18, 0, 88);
    } else {

    }
    goto ldv_57373;
    case 3: 
    tmp___1 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___1 != 0U) {
      BTDM_SetFw3a(padapter, 211, 48, 3, 16, 88);
    } else {

    }
    goto ldv_57373;
    case 4: 
    tmp___2 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___2 != 0U) {
      BTDM_SetFw3a(padapter, 147, 21, 3, 20, 0);
    } else {

    }
    goto ldv_57373;
    case 5: 
    tmp___3 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___3 != 0U) {
      BTDM_SetFw3a(padapter, 97, 21, 3, 49, 0);
    } else {

    }
    goto ldv_57373;
    case 9: 
    tmp___4 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___4 != 0U) {
      BTDM_SetFw3a(padapter, 211, 10, 10, 0, 88);
    } else {

    }
    goto ldv_57373;
    case 10: 
    tmp___5 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___5 != 0U) {
      BTDM_SetFw3a(padapter, 19, 10, 10, 0, 64);
    } else {

    }
    goto ldv_57373;
    case 11: 
    tmp___6 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___6 != 0U) {
      BTDM_SetFw3a(padapter, 211, 5, 5, 0, 88);
    } else {

    }
    goto ldv_57373;
    case 12: 
    tmp___7 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___7 != 0U) {
      BTDM_SetFw3a(padapter, 235, 10, 3, 49, 24);
    } else {

    }
    goto ldv_57373;
    case 20: 
    tmp___8 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___8 != 0U) {
      BTDM_SetFw3a(padapter, 19, 37, 37, 0, 0);
    } else {

    }
    goto ldv_57373;
    case 27: 
    tmp___9 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___9 != 0U) {
      BTDM_SetFw3a(padapter, 163, 37, 3, 49, 152);
    } else {

    }
    goto ldv_57373;
    case 28: 
    tmp___10 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___10 != 0U) {
      BTDM_SetFw3a(padapter, 105, 37, 3, 49, 0);
    } else {

    }
    goto ldv_57373;
    case 29: 
    tmp___11 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___11 != 0U) {
      BTDM_SetFw3a(padapter, 235, 26, 26, 1, 24);
      rtl8723au_write32(padapter, 1728, 1526356730U);
      rtl8723au_write32(padapter, 1732, 1526356730U);
    } else {

    }
    goto ldv_57373;
    case 30: 
    tmp___12 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___12 != 0U) {
      BTDM_SetFw3a(padapter, 147, 21, 3, 20, 0);
    } else {

    }
    goto ldv_57373;
    case 31: 
    tmp___13 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___13 != 0U) {
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 88);
    } else {

    }
    goto ldv_57373;
    case 32: 
    tmp___14 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___14 != 0U) {
      BTDM_SetFw3a(padapter, 171, 10, 3, 17, 152);
    } else {

    }
    goto ldv_57373;
    case 33: 
    tmp___15 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___15 != 0U) {
      BTDM_SetFw3a(padapter, 163, 37, 3, 48, 152);
    } else {

    }
    goto ldv_57373;
    case 34: 
    tmp___16 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___16 != 0U) {
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 24);
    } else {

    }
    goto ldv_57373;
    case 35: 
    tmp___17 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___17 != 0U) {
      BTDM_SetFw3a(padapter, 227, 26, 26, 0, 24);
    } else {

    }
    goto ldv_57373;
    }
    ldv_57373: ;
  } else {
    switch ((int )type) {
    case 8: 
    tmp___18 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___18 != 0U) {
      BTDM_SetFw3a(padapter, 8, 0, 0, 0, 0);
    } else {

    }
    goto ldv_57393;
    case 0: ;
    default: 
    tmp___19 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___19 != 0U) {
      BTDM_SetFw3a(padapter, 0, 0, 0, 8, 0);
    } else {

    }
    rtl8723au_write16(padapter, 2144, 528);
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 0x860 = 0x210, Switch Antenna to BT\n");
    } else {

    }
    goto ldv_57393;
    case 9: 
    tmp___20 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___20 != 0U) {
      BTDM_SetFw3a(padapter, 0, 0, 0, 8, 0);
    } else {

    }
    rtl8723au_write16(padapter, 2144, 272);
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 0x860 = 0x110, Switch Antenna to WiFi\n");
    } else {

    }
    goto ldv_57393;
    }
    ldv_57393: ;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Current TDMA(%s, %d)\n", (unsigned int )pBtdm8723->bCurPsTdmaOn != 0U ? (char *)"ON" : (char *)"OFF",
           (int )pBtdm8723->curPsTdma);
  } else {

  }
  pBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;
  pBtdm8723->prePsTdma = pBtdm8723->curPsTdma;
  return;
}
}
static void _btdm_1AntSetPSTDMA(struct rtw_adapter *padapter , u8 bPSEn , u8 smartps ,
                                u8 psOption , u8 bTDMAOn , u8 tdmaType ) 
{ 
  struct pwrctrl_priv *pwrctrl ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 psMode ;
  u8 bSwitchPS ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
  tmp = check_fwstate(& padapter->mlmepriv, 8);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    tmp___1 = get_fwstate(& padapter->mlmepriv);
    if (tmp___1 != 0) {
      btdm_1AntPsTdma(padapter, (int )bTDMAOn, (int )tdmaType);
      return;
    } else {

    }
  } else {

  }
  psOption = (unsigned int )psOption & 254U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Set LPS(%s, %d) TDMA(%s, %d)\n", (unsigned int )bPSEn == 1U ? (char *)"ON" : (char *)"OFF",
           (int )psOption, (unsigned int )bTDMAOn == 1U ? (char *)"ON" : (char *)"OFF",
           (int )tdmaType);
  } else {

  }
  pwrctrl = & padapter->pwrctrlpriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  if ((unsigned int )bPSEn != 0U) {
    if ((unsigned int )pBtdm8723->bWiFiHalt != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Enable PS Fail, WiFi in Halt!!\n");
      } else {

      }
      return;
    } else {

    }
    if ((unsigned int )pwrctrl->bInSuspend != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Enable PS Fail, WiFi in Suspend!!\n");
      } else {

      }
      return;
    } else {

    }
    if (padapter->bDriverStopped != 0) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Enable PS Fail, WiFi driver stopped!!\n");
      } else {

      }
      return;
    } else {

    }
    if (padapter->bSurpriseRemoved != 0) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Enable PS Fail, WiFi Surprise Removed!!\n");
      } else {

      }
      return;
    } else {

    }
    psMode = 1U;
  } else {
    psMode = 0U;
    psOption = 0U;
  }
  if ((int )pwrctrl->pwr_mode != (int )psMode) {
    bSwitchPS = 1U;
  } else
  if ((unsigned int )psMode != 0U) {
    if ((int )pwrctrl->bcn_ant_mode != (int )psOption) {
      bSwitchPS = 1U;
    } else
    if ((int )pwrctrl->smart_ps != (int )smartps) {
      bSwitchPS = 1U;
    } else {
      bSwitchPS = 0U;
    }
  } else {
    bSwitchPS = 0U;
  }
  if ((unsigned int )bSwitchPS != 0U) {
    if ((unsigned int )pBtdm8723->bCurPsTdmaOn != 0U) {
      if ((unsigned int )bTDMAOn == 0U) {
        btdm_1AntPsTdma(padapter, 0, (int )tdmaType);
      } else {
        tmp___2 = rtl8723a_BT_enabled(padapter);
        if (tmp___2) {
          tmp___3 = 0;
        } else {
          tmp___3 = 1;
        }
        if (((tmp___3 || (unsigned int )pHalData->bt_coexist.halCoex8723.c2hBtInfo == 1U) || (unsigned int )pHalData->bt_coexist.halCoex8723.c2hBtInfo == 2U) || (unsigned int )tdmaType == 29U) {
          btdm_1AntPsTdma(padapter, 0, 9);
        } else {
          btdm_1AntPsTdma(padapter, 0, 0);
        }
      }
    } else {

    }
    btdm_1AntSetPSMode(padapter, (int )bPSEn, (int )smartps, (int )psOption);
  } else {

  }
  btdm_1AntPsTdma(padapter, (int )bTDMAOn, (int )tdmaType);
  return;
}
}
static void btdm_1AntSetPSTDMA(struct rtw_adapter *padapter , u8 bPSEn , u8 psOption ,
                               u8 bTDMAOn , u8 tdmaType ) 
{ 


  {
  _btdm_1AntSetPSTDMA(padapter, (int )bPSEn, 0, (int )psOption, (int )bTDMAOn, (int )tdmaType);
  return;
}
}
static void btdm_1AntWifiParaAdjust(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  if ((unsigned int )bEnable != 0U) {
    pBtdm8723->curWifiPara = 1U;
    if ((int )pBtdm8723->preWifiPara != (int )pBtdm8723->curWifiPara) {
      BTDM_SetSwPenaltyTxRateAdaptive(padapter, 1);
    } else {

    }
  } else {
    pBtdm8723->curWifiPara = 2U;
    if ((int )pBtdm8723->preWifiPara != (int )pBtdm8723->curWifiPara) {
      BTDM_SetSwPenaltyTxRateAdaptive(padapter, 0);
    } else {

    }
  }
  return;
}
}
static void btdm_1AntPtaParaReload(struct rtw_adapter *padapter ) 
{ 


  {
  rtl8723au_write8(padapter, 1740, 0);
  rtl8723au_write32(padapter, 1736, 65535U);
  rtl8723au_write32(padapter, 1732, 1431655765U);
  rtl8723au_write32(padapter, 2136, 2863311530U);
  if ((unsigned int )((struct hal_data_8723a *)padapter->HalData)->VersionID.ICType == 4U && (unsigned int )((struct hal_data_8723a *)padapter->HalData)->VersionID.CUTVersion == 0U) {
    rtl8723au_write32(padapter, 2160, 0U);
    rtl8723au_write8(padapter, 64, 36);
  } else {
    rtl8723au_write8(padapter, 64, 32);
    rtl8723au_write16(padapter, 2144, 528);
    rtl8723au_write32(padapter, 2160, 768U);
    rtl8723au_write32(padapter, 2164, 578830336U);
  }
  rtl8723au_write8(padapter, 1912, 1);
  btdm_SetFwIgnoreWlanAct(padapter, 0);
  return;
}
}
static s8 btdm_1AntTdmaJudgement(struct rtw_adapter *padapter , u8 retry ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  s8 up___0 ;
  s8 dn ;
  s8 m ;
  s8 n ;
  s8 WaitCount ;
  s8 ret ;

  {
  m = 1;
  n = 3;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  ret = 0;
  if (pBtdm8723->psTdmaMonitorCnt == 0U) {
    up___0 = 0;
    dn = 0;
    m = 1;
    n = 3;
    WaitCount = 0;
  } else {
    WaitCount = (s8 )((int )WaitCount + 1);
  }
  if ((unsigned int )retry == 0U) {
    up___0 = (s8 )((int )up___0 + 1);
    dn = (s8 )((int )dn - 1);
    if ((int )dn < 0) {
      dn = 0;
    } else {

    }
    if ((int )up___0 >= (int )m * 3) {
      ret = 1;
      n = 3;
      up___0 = 0;
      dn = 0;
      WaitCount = 0;
    } else {

    }
  } else
  if ((unsigned int )retry <= 3U) {
    up___0 = (s8 )((int )up___0 - 1);
    dn = (s8 )((int )dn + 1);
    if ((int )up___0 < 0) {
      up___0 = 0;
    } else {

    }
    if ((int )dn == 2) {
      ret = -1;
      if ((int )WaitCount <= 2) {
        m = (s8 )((int )m + 1);
      } else {
        m = 1;
      }
      if ((int )m > 19) {
        m = 20;
      } else {

      }
      up___0 = 0;
      dn = 0;
      WaitCount = 0;
    } else {

    }
  } else {
    ret = -1;
    if ((int )WaitCount == 1) {
      m = (s8 )((int )m + 1);
    } else {
      m = 1;
    }
    if ((int )m > 19) {
      m = 20;
    } else {

    }
    up___0 = 0;
    dn = 0;
    WaitCount = 0;
  }
  return (ret);
}
}
static void btdm_1AntTdmaDurationAdjustForACL(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  s32 judge ;
  s8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  if (pBtdm8723->psTdmaGlobalCnt != pBtdm8723->psTdmaMonitorCnt) {
    pBtdm8723->psTdmaMonitorCnt = 0U;
    pBtdm8723->psTdmaGlobalCnt = 0U;
  } else {

  }
  if (pBtdm8723->psTdmaMonitorCnt == 0U) {
    btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 2);
    pBtdm8723->psTdmaDuAdjType = 2U;
  } else {
    if ((((unsigned int )pBtdm8723->curPsTdma != 1U && (unsigned int )pBtdm8723->curPsTdma != 2U) && (unsigned int )pBtdm8723->curPsTdma != 9U) && (unsigned int )pBtdm8723->curPsTdma != 11U) {
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
    } else {
      judge = 0;
      tmp = btdm_1AntTdmaJudgement(padapter, (int )pHalData->bt_coexist.halCoex8723.btRetryCnt);
      judge = (s32 )tmp;
      if (judge == -1) {
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
            pBtdm8723->psTdmaDuAdjType = 2U;
          }
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 9);
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else {

        }
      } else
      if (judge == 1) {
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 9);
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
            pBtdm8723->psTdmaDuAdjType = 2U;
          }
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
            pBtdm8723->psTdmaDuAdjType = 1U;
          }
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else {

        }
      } else {

      }
    }
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], ACL current TDMA(%s, %d)\n", (unsigned int )pBtdm8723->bCurPsTdmaOn != 0U ? (char *)"ON" : (char *)"OFF",
             (int )pBtdm8723->curPsTdma);
    } else {

    }
  }
  pBtdm8723->psTdmaMonitorCnt = pBtdm8723->psTdmaMonitorCnt + 1U;
  return;
}
}
static void btdm_1AntCoexProcessForWifiConnect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 BtState ;
  u8 tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBtdm8723 = & pBtCoex->btdm1Ant;
  BtState = pBtCoex->c2hBtInfo;
  if (BTCoexDbgLevel == 1U) {
    tmp = BTDM_IsWifiBusy(padapter);
    printk("[BTCoex], WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT is %s\n", BtStateString[(int )BtState]);
  } else {

  }
  padapter->pwrctrlpriv.btcoex_rfon = 0U;
  tmp___0 = BTDM_IsWifiBusy(padapter);
  if ((unsigned int )tmp___0 == 0U) {
    tmp___1 = check_fwstate(& padapter->mlmepriv, 16);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      if ((unsigned int )BtState == 1U || (unsigned int )BtState == 2U) {
        switch ((int )BtState) {
        case 1: 
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 38, 0, 9);
        goto ldv_57453;
        case 2: 
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 38, 0, 0);
        goto ldv_57453;
        }
        ldv_57453: ;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    switch ((int )BtState) {
    case 1: ;
    case 2: 
    btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 5);
    rtl8723au_write32(padapter, 1728, 1515870810U);
    rtl8723au_write32(padapter, 1732, 1515870810U);
    goto ldv_57457;
    case 7: ;
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], BT PROFILE is BT_INFO_STATE_ACL_INQ_OR_PAG\n");
    } else {

    }
    case 3: 
    padapter->pwrctrlpriv.btcoex_rfon = 1U;
    btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 30);
    goto ldv_57457;
    case 5: ;
    case 6: ;
    if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
      btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 32);
    } else {
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
      rtl8723au_write32(padapter, 1728, 1515870810U);
      rtl8723au_write32(padapter, 1732, 1515870810U);
    }
    goto ldv_57457;
    case 4: 
    padapter->pwrctrlpriv.btcoex_rfon = 1U;
    if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT PROFILE is HID\n");
      } else {

      }
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 31);
    } else
    if ((unsigned int )pBtCoex->c2hBtProfile == 128U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT PROFILE is FTP/OPP\n");
      } else {

      }
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 3);
    } else
    if ((unsigned int )pBtCoex->c2hBtProfile == 192U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT PROFILE is A2DP_FTP\n");
      } else {

      }
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 11);
    } else {
      if ((unsigned int )pBtCoex->c2hBtProfile == 64U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], BT PROFILE is A2DP\n");
        } else {

        }
      } else
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT PROFILE is UNKNOWN(0x%02X)! Use A2DP Profile\n", (int )pBtCoex->c2hBtProfile);
      } else {

      }
      btdm_1AntTdmaDurationAdjustForACL(padapter);
    }
    goto ldv_57457;
    }
    ldv_57457: ;
  }
  pBtdm8723->psTdmaGlobalCnt = pBtdm8723->psTdmaGlobalCnt + 1U;
  return;
}
}
static void btdm_1AntUpdateHalRAMask(struct rtw_adapter *padapter , u32 mac_id , u32 filter ) 
{ 
  u8 init_rate ;
  u8 raid ;
  u8 arg ;
  u32 mask ;
  u8 shortGIrate ;
  int supportRateNum ;
  struct sta_info *psta ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  uint tmp ;
  unsigned int tmp___0 ;
  u32 tmp___1 ;
  int tmp___2 ;
  uint tmp___3 ;
  uint tmp___4 ;
  unsigned char tmp___5 ;

  {
  init_rate = 0U;
  shortGIrate = 0U;
  supportRateNum = 0;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], %s, MACID =%d, filter = 0x%08x!!\n", "btdm_1AntUpdateHalRAMask",
           mac_id, filter);
  } else {

  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  if (mac_id > 31U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], %s, MACID =%d illegal!!\n", "btdm_1AntUpdateHalRAMask", mac_id);
    } else {

    }
    return;
  } else {

  }
  psta = pmlmeinfo->FW_sta_info[mac_id].psta;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], %s, Can\'t find station!!\n", "btdm_1AntUpdateHalRAMask");
    } else {

    }
    return;
  } else {

  }
  raid = psta->raid;
  switch (mac_id) {
  case 0U: 
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  supportRateNum = (int )tmp;
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
  if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
    tmp___0 = update_MSC_rate23a(& pmlmeinfo->ht_cap);
    tmp___1 = tmp___0;
  } else {
    tmp___1 = 0U;
  }
  mask = tmp___1 | mask;
  tmp___2 = support_short_GI23a(padapter, & pmlmeinfo->ht_cap);
  if (tmp___2 != 0) {
    shortGIrate = 1U;
  } else {

  }
  goto ldv_57482;
  case 1U: 
  tmp___3 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
  supportRateNum = (int )tmp___3;
  mask = update_basic_rate23a((unsigned char *)(& cur_network->SupportedRates), (unsigned int )supportRateNum);
  goto ldv_57482;
  default: 
  tmp___4 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
  supportRateNum = (int )tmp___4;
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
  goto ldv_57482;
  }
  ldv_57482: 
  mask = (u32 )((int )raid << 28) | mask;
  mask = mask;
  mask = ~ filter & mask;
  tmp___5 = get_highest_rate_idx23a(mask);
  init_rate = (unsigned int )tmp___5 & 63U;
  arg = (unsigned int )((u8 )mac_id) & 31U;
  arg = (u8 )((unsigned int )arg | 128U);
  if ((unsigned int )shortGIrate == 1U) {
    arg = (u8 )((unsigned int )arg | 32U);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Update FW RAID entry, MASK = 0x%08x, arg = 0x%02x\n", mask,
           (int )arg);
  } else {

  }
  rtl8723a_set_raid_cmd(padapter, mask, (int )arg);
  psta->init_rate = init_rate;
  pdmpriv->INIDATA_RATE[mac_id] = init_rate;
  return;
}
}
static void btdm_1AntUpdateHalRAMaskForSCO(struct rtw_adapter *padapter , u8 forceUpdate ) 
{ 
  struct btdm_8723a_1ant *pBtdm8723 ;
  struct sta_priv *pstapriv ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_info *psta ;
  u32 macid ;
  u32 filter ;

  {
  filter = 0U;
  pBtdm8723 = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant;
  if ((unsigned int )pBtdm8723->bRAChanged == 1U && (unsigned int )forceUpdate == 0U) {
    return;
  } else {

  }
  pstapriv = & padapter->stapriv;
  cur_network = & padapter->mlmeextpriv.mlmext_info.network;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
  macid = psta->mac_id;
  filter = filter | 1U;
  filter = filter | 2U;
  filter = filter | 4U;
  filter = filter | 8U;
  filter = filter | 16U;
  filter = filter | 32U;
  btdm_1AntUpdateHalRAMask(padapter, macid, filter);
  pBtdm8723->bRAChanged = 1U;
  return;
}
}
static void btdm_1AntRecoverHalRAMask(struct rtw_adapter *padapter ) 
{ 
  struct btdm_8723a_1ant *pBtdm8723 ;
  struct sta_priv *pstapriv ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_info *psta ;

  {
  pBtdm8723 = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant;
  if ((unsigned int )pBtdm8723->bRAChanged == 0U) {
    return;
  } else {

  }
  pstapriv = & padapter->stapriv;
  cur_network = & padapter->mlmeextpriv.mlmext_info.network;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
  Update_RA_Entry23a(padapter, psta);
  pBtdm8723->bRAChanged = 0U;
  return;
}
}
static void btdm_1AntBTStateChangeHandler(struct rtw_adapter *padapter , enum bt_state_1ant oldState ,
                                          enum bt_state_1ant newState ) 
{ 
  struct hal_data_8723a *phaldata ;
  bool tmp ;
  u8 tmp___0 ;
  struct hal_data_8723a *Hal ;
  struct hal_data_8723a *Hal___0 ;

  {
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT state change, %s => %s\n", BtStateString[(unsigned int )oldState],
           BtStateString[(unsigned int )newState]);
  } else {

  }
  if ((unsigned int )newState != 0U) {
    btdm_SetFwIgnoreWlanAct(padapter, 0);
  } else {

  }
  tmp = check_fwstate(& padapter->mlmepriv, 8);
  if ((int )tmp) {
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      if ((unsigned int )newState == 5U || (unsigned int )newState == 6U) {
        btdm_1AntUpdateHalRAMaskForSCO(padapter, 0);
      } else {
        btdm_1AntRecoverHalRAMask(padapter);
      }
    } else {
      phaldata = (struct hal_data_8723a *)padapter->HalData;
      phaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = 0U;
    }
  } else {
    phaldata = (struct hal_data_8723a *)padapter->HalData;
    phaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = 0U;
  }
  if ((unsigned int )oldState == (unsigned int )newState) {
    return;
  } else {

  }
  if ((unsigned int )oldState == 4U) {
    Hal = (struct hal_data_8723a *)padapter->HalData;
    Hal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCnt = 0U;
    Hal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0U;
  } else {

  }
  if ((unsigned int )oldState == 5U || (unsigned int )oldState == 6U) {
    Hal___0 = (struct hal_data_8723a *)padapter->HalData;
    Hal___0->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0U;
  } else {

  }
  if ((unsigned int )oldState == 0U || (unsigned int )oldState == 1U) {
    if ((unsigned int )newState != 0U && (unsigned int )newState != 1U) {
      BTDM_SetSwRfRxLpfCorner(padapter, 1);
      BTDM_AGCTable(padapter, 1);
      BTDM_BBBackOffLevel(padapter, 1);
    } else {

    }
  } else
  if ((unsigned int )newState == 0U || (unsigned int )newState == 1U) {
    BTDM_SetSwRfRxLpfCorner(padapter, 0);
    BTDM_AGCTable(padapter, 0);
    BTDM_BBBackOffLevel(padapter, 0);
  } else {

  }
  return;
}
}
static void btdm_1AntBtCoexistHandler(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex8723 ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex8723 = & pHalData->bt_coexist.halCoex8723;
  pBtdm8723 = & pBtCoex8723->btdm1Ant;
  padapter->pwrctrlpriv.btcoex_rfon = 0U;
  tmp___2 = rtl8723a_BT_enabled(padapter);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], BT is disabled\n");
    } else {

    }
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], wifi is connected\n");
      } else {

      }
      tmp = BTDM_IsWifiBusy(padapter);
      if ((unsigned int )tmp != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Wifi is busy\n");
        } else {

        }
        btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Wifi is idle\n");
        } else {

        }
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 1, 0, 9);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], wifi is disconnected\n");
      } else {

      }
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    }
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], BT is enabled\n");
    } else {

    }
    tmp___1 = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp___1 != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], wifi is connected\n");
      } else {

      }
      btdm_1AntWifiParaAdjust(padapter, 1);
      btdm_1AntCoexProcessForWifiConnect(padapter);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], wifi is disconnected\n");
      } else {

      }
      btdm_1AntWifiParaAdjust(padapter, 0);
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 0);
    }
  }
  btdm_1AntBTStateChangeHandler(padapter, (enum bt_state_1ant )pBtCoex8723->prec2hBtInfo,
                                (enum bt_state_1ant )pBtCoex8723->c2hBtInfo);
  pBtCoex8723->prec2hBtInfo = pBtCoex8723->c2hBtInfo;
  return;
}
}
void BTDM_1AntSignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 RSSI_WiFi_Cmpnstn ;
  u8 RSSI_BT_Cmpnstn ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  RSSI_WiFi_Cmpnstn = 0U;
  RSSI_BT_Cmpnstn = 0U;
  switch ((int )pBtdm8723->curPsTdma) {
  case 1: 
  RSSI_WiFi_Cmpnstn = 11U;
  goto ldv_57526;
  case 2: 
  RSSI_WiFi_Cmpnstn = 14U;
  goto ldv_57526;
  case 9: 
  RSSI_WiFi_Cmpnstn = 18U;
  goto ldv_57526;
  case 11: 
  RSSI_WiFi_Cmpnstn = 20U;
  goto ldv_57526;
  case 4: 
  RSSI_WiFi_Cmpnstn = 17U;
  goto ldv_57526;
  case 16: 
  RSSI_WiFi_Cmpnstn = 18U;
  goto ldv_57526;
  case 18: 
  RSSI_WiFi_Cmpnstn = 14U;
  goto ldv_57526;
  case 23: ;
  case 24: ;
  case 25: ;
  case 26: ;
  case 27: ;
  case 33: 
  RSSI_WiFi_Cmpnstn = 22U;
  goto ldv_57526;
  default: ;
  goto ldv_57526;
  }
  ldv_57526: ;
  if ((unsigned long )rssi_wifi != (unsigned long )((u8 *)0U) && (unsigned int )RSSI_WiFi_Cmpnstn != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 1AntSgnlCmpnstn, case %d, WiFiCmpnstn =%d(%d => %d)\n", (int )pBtdm8723->curPsTdma,
             (int )RSSI_WiFi_Cmpnstn, (int )*rssi_wifi, (int )*rssi_wifi + (int )RSSI_WiFi_Cmpnstn);
    } else {

    }
    *rssi_wifi = (int )*rssi_wifi + (int )RSSI_WiFi_Cmpnstn;
  } else {

  }
  if ((unsigned long )rssi_bt != (unsigned long )((u8 *)0U) && (unsigned int )RSSI_BT_Cmpnstn != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 1AntSgnlCmpnstn, case %d, BTCmpnstn =%d(%d => %d)\n", (int )pBtdm8723->curPsTdma,
             (int )RSSI_BT_Cmpnstn, (int )*rssi_bt, (int )*rssi_bt + (int )RSSI_BT_Cmpnstn);
    } else {

    }
    *rssi_bt = (int )*rssi_bt + (int )RSSI_BT_Cmpnstn;
  } else {

  }
  return;
}
}
static void BTDM_1AntParaInit(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBtdm8723 = & pBtCoex->btdm1Ant;
  rtl8723au_write8(padapter, 1902, 4);
  btdm_1AntPtaParaReload(padapter);
  pBtdm8723->wifiRssiThresh = 48U;
  pBtdm8723->bWiFiHalt = 0U;
  pBtdm8723->bRAChanged = 0U;
  if ((unsigned int )pBtCoex->c2hBtInfo != 0U && (unsigned int )pBtCoex->c2hBtInfo != 1U) {
    BTDM_SetSwRfRxLpfCorner(padapter, 1);
    BTDM_AGCTable(padapter, 1);
    BTDM_BBBackOffLevel(padapter, 1);
  } else {

  }
  return;
}
}
static void BTDM_1AntForHalt(struct rtw_adapter *padapter ) 
{ 


  {
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for halt\n");
  } else {

  }
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt = 1U;
  btdm_1AntWifiParaAdjust(padapter, 0);
  btdm_1AntPsTdma(padapter, 0, 0);
  btdm_SetFwIgnoreWlanAct(padapter, 1);
  return;
}
}
static void BTDM_1AntLpsLeave(struct rtw_adapter *padapter ) 
{ 


  {
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for LPS Leave\n");
  } else {

  }
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt = 1U;
  btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
  return;
}
}
static void BTDM_1AntWifiAssociateNotify(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 BtState ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for associate, type =%d\n", (int )type);
  } else {

  }
  if ((unsigned int )type != 0U) {
    rtl8723a_CheckAntenna_Selection(padapter);
    tmp = rtl8723a_BT_enabled(padapter);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    } else {
      pBtCoex = & pHalData->bt_coexist.halCoex8723;
      BtState = pBtCoex->c2hBtInfo;
      btdm_1AntTSFSwitch(padapter, 1);
      if ((unsigned int )BtState == 1U || (unsigned int )BtState == 2U) {
        btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 28);
      } else
      if ((unsigned int )BtState == 5U || (unsigned int )BtState == 6U) {
        btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
        rtl8723au_write32(padapter, 1728, 1515870810U);
        rtl8723au_write32(padapter, 1732, 1515870810U);
      } else
      if ((unsigned int )BtState == 4U || (unsigned int )BtState == 7U) {
        if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 35);
        } else {
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 29);
        }
      } else {

      }
    }
  } else {
    tmp___2 = rtl8723a_BT_enabled(padapter);
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      tmp___1 = BTDM_IsWifiConnectionExist(padapter);
      if ((unsigned int )tmp___1 == 0U) {
        btdm_1AntPsTdma(padapter, 0, 0);
        btdm_1AntTSFSwitch(padapter, 0);
      } else {

      }
    } else {

    }
    btdm_1AntBtCoexistHandler(padapter);
  }
  return;
}
}
static void BTDM_1AntMediaStatusNotify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;

  {
  pBtCoex = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723;
  if (BTCoexDbgLevel == 1U) {
    printk("\n\n[BTCoex]******************************\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], MediaStatus, WiFi %s !!\n", (unsigned int )mstatus == 1U ? (char *)"CONNECT" : (char *)"DISCONNECT");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex]******************************\n");
  } else {

  }
  if ((unsigned int )mstatus == 1U) {
    tmp = check_fwstate(& padapter->mlmepriv, 8);
    if ((int )tmp) {
      if ((unsigned int )pBtCoex->c2hBtInfo == 5U || (unsigned int )pBtCoex->c2hBtInfo == 6U) {
        btdm_1AntUpdateHalRAMaskForSCO(padapter, 1);
      } else {

      }
    } else {

    }
    padapter->pwrctrlpriv.DelayLPSLastTimeStamp = jiffies;
    BTDM_1AntForDhcp(padapter);
  } else {
    rtl8723a_DeinitAntenna_Selection(padapter);
    btdm_1AntBtCoexistHandler(padapter);
    pBtCoex->btdm1Ant.bRAChanged = 0U;
  }
  return;
}
}
void BTDM_1AntForDhcp(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 BtState ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  BtState = pBtCoex->c2hBtInfo;
  pBtdm8723 = & pBtCoex->btdm1Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for DHCP\n");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    tmp = BTDM_IsWifiBusy(padapter);
    printk("[BTCoex], 1Ant for DHCP, WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], 1Ant for DHCP, %s\n", BtStateString[(int )BtState]);
  } else {

  }
  BTDM_1AntWifiAssociateNotify(padapter, 1);
  return;
}
}
static void BTDM_1AntWifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 BtState ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  BtState = pHalData->bt_coexist.halCoex8723.c2hBtInfo;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBtdm8723 = & pBtCoex->btdm1Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for wifi scan =%d!!\n", (int )scanType);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    tmp = BTDM_IsWifiBusy(padapter);
    printk("[BTCoex], 1Ant for wifi scan, WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], 1Ant for wifi scan, %s\n", BtStateString[(int )BtState]);
  } else {

  }
  if ((unsigned int )scanType != 0U) {
    rtl8723a_CheckAntenna_Selection(padapter);
    tmp___1 = rtl8723a_BT_enabled(padapter);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    } else {
      tmp___0 = BTDM_IsWifiConnectionExist(padapter);
      if ((unsigned int )tmp___0 == 0U) {
        BTDM_1AntWifiAssociateNotify(padapter, 1);
      } else
      if ((unsigned int )BtState == 5U || (unsigned int )BtState == 6U) {
        if ((unsigned int )pBtCoex->bC2hBtInquiryPage != 0U) {
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 32);
        } else {
          padapter->pwrctrlpriv.btcoex_rfon = 1U;
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 33);
        }
      } else
      if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
        btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 30);
      } else
      if ((unsigned int )BtState == 4U) {
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
        if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 34);
        } else {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 4);
        }
      } else {
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
        btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 5);
      }
    }
    btdm_NotifyFwScan(padapter, 1);
  } else {
    btdm_NotifyFwScan(padapter, 0);
    btdm_1AntBtCoexistHandler(padapter);
  }
  return;
}
}
static void BTDM_1AntFwC2hBtInfo8723A(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 u1tmp ;
  u8 btState ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  u1tmp = pBtCoex->c2hBtInfoOriginal;
  btState = (unsigned int )u1tmp & 15U;
  pBtCoex->c2hBtProfile = (unsigned int )u1tmp & 224U;
  pBtMgnt->ExtConfig.bBTBusy = 0U;
  pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  if (((unsigned long )btState & 4UL) != 0UL) {
    pBtCoex->bC2hBtInquiryPage = 1U;
  } else {
    pBtCoex->bC2hBtInquiryPage = 0U;
  }
  btState = (unsigned int )btState & 251U;
  if (((unsigned long )btState & 1UL) == 0UL) {
    pBtCoex->c2hBtInfo = 1U;
  } else {
    if ((unsigned int )btState == 1U) {
      pBtCoex->c2hBtInfo = 2U;
    } else
    if ((unsigned int )btState == 9U) {
      if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
        pBtCoex->c2hBtInfo = 7U;
      } else {
        pBtCoex->c2hBtInfo = 4U;
      }
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else
    if ((unsigned int )btState == 3U) {
      pBtCoex->c2hBtInfo = 5U;
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else
    if ((unsigned int )btState == 11U) {
      pBtCoex->c2hBtInfo = 6U;
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else {
      pBtCoex->c2hBtInfo = 8U;
    }
    if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy != 0U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffefffULL;
    } else {

    }
  }
  if ((unsigned int )pBtCoex->c2hBtInfo == 1U || (unsigned int )pBtCoex->c2hBtInfo == 2U) {
    if ((unsigned int )pBtCoex->bC2hBtInquiryPage != 0U) {
      pBtCoex->c2hBtInfo = 3U;
    } else {

    }
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H], %s(%d)\n", BtStateString[(int )pBtCoex->c2hBtInfo], (int )pBtCoex->c2hBtInfo);
  } else {

  }
  if ((unsigned int )pBtCoex->c2hBtProfile != 32U) {
    pBtCoex->c2hBtProfile = (unsigned int )pBtCoex->c2hBtProfile & 223U;
  } else {

  }
  return;
}
}
void BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  unsigned long delta_time ;
  bool tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], wifi is under scan progress!!\n");
    } else {

    }
    return;
  } else {

  }
  tmp___0 = check_fwstate(pmlmepriv, 128);
  if ((int )tmp___0) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], wifi is under link progress!!\n");
    } else {

    }
    return;
  } else {

  }
  delta_time = (unsigned long )jiffies - padapter->pwrctrlpriv.DelayLPSLastTimeStamp;
  tmp___1 = jiffies_to_msecs(delta_time);
  delta_time = (unsigned long )tmp___1;
  if (delta_time <= 499UL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], wifi is under DHCP progress(%li ms)!!\n", delta_time);
    } else {

    }
    return;
  } else {

  }
  BTDM_CheckWiFiState(padapter);
  btdm_1AntBtCoexistHandler(padapter);
  return;
}
}
static u8 btdm_ActionAlgorithm(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 bScoExist ;
  u8 bBtLinkExist ;
  u8 bBtHsModeExist ;
  u8 algorithm ;
  u32 tmp ;
  u8 tmp___0 ;
  u32 tmp___1 ;
  u8 tmp___2 ;
  u32 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  u8 tmp___15 ;
  u8 tmp___16 ;
  u8 tmp___17 ;
  u8 tmp___18 ;
  u8 tmp___19 ;
  u8 tmp___20 ;
  u8 tmp___21 ;
  u8 tmp___22 ;
  u8 tmp___23 ;
  u8 tmp___24 ;
  u8 tmp___25 ;
  u8 tmp___26 ;
  u8 tmp___27 ;
  u8 tmp___28 ;
  u8 tmp___29 ;
  u8 tmp___30 ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  bScoExist = 0U;
  bBtLinkExist = 0U;
  bBtHsModeExist = 0U;
  algorithm = 0U;
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle != 0U) {
    bBtLinkExist = 1U;
  } else {

  }
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfSCO != 0U) {
    bScoExist = 1U;
  } else {

  }
  pBtdm8723->btStatus = 0U;
  if ((unsigned int )bScoExist != 0U || (unsigned int )bBtHsModeExist != 0U) {
    goto _L;
  } else {
    tmp___6 = BTHCI_CheckProfileExist(padapter, 3);
    if ((unsigned int )tmp___6 != 0U) {
      _L: /* CIL Label */ 
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], SCO or HID or HS exists, set BT non-idle !!!\n");
      } else {

      }
      pBtdm8723->btStatus = 2U;
    } else {
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
        tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___0 != 0U) {
          tmp = BTDM_BtTxRxCounterL(padapter);
          if (tmp <= 99U) {
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], A2DP, low priority tx+rx < 100, set BT connected-idle!!!\n");
            } else {

            }
            pBtdm8723->btStatus = 1U;
          } else {
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], A2DP, low priority tx+rx >= 100, set BT non-idle!!!\n");
            } else {

            }
            pBtdm8723->btStatus = 2U;
          }
        } else {

        }
      } else {

      }
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
        tmp___2 = BTHCI_CheckProfileExist(padapter, 2);
        if ((unsigned int )tmp___2 != 0U) {
          tmp___1 = BTDM_BtTxRxCounterL(padapter);
          if (tmp___1 <= 599U) {
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], PAN, low priority tx+rx < 600, set BT connected-idle!!!\n");
            } else {

            }
            pBtdm8723->btStatus = 1U;
          } else
          if (pHalData->bt_coexist.halCoex8723.lowPriorityTx != 0U) {
            if (pHalData->bt_coexist.halCoex8723.lowPriorityRx / pHalData->bt_coexist.halCoex8723.lowPriorityTx > 9U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN, low priority rx/tx > 9, set BT connected-idle!!!\n");
              } else {

              }
              pBtdm8723->btStatus = 1U;
            } else {

            }
          } else {

          }
          if ((unsigned int )pBtdm8723->btStatus != 1U) {
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], PAN, set BT non-idle!!!\n");
            } else {

            }
            pBtdm8723->btStatus = 2U;
          } else {

          }
        } else {

        }
      } else {

      }
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 2U) {
        tmp___4 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___4 != 0U) {
          tmp___5 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___5 != 0U) {
            tmp___3 = BTDM_BtTxRxCounterL(padapter);
            if (tmp___3 <= 599U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN+A2DP, low priority tx+rx < 600, set BT connected-idle!!!\n");
              } else {

              }
              pBtdm8723->btStatus = 1U;
            } else
            if (pHalData->bt_coexist.halCoex8723.lowPriorityTx != 0U) {
              if (pHalData->bt_coexist.halCoex8723.lowPriorityRx / pHalData->bt_coexist.halCoex8723.lowPriorityTx > 9U) {
                if (BTCoexDbgLevel == 1U) {
                  printk("[BTCoex], PAN+A2DP, low priority rx/tx > 9, set BT connected-idle!!!\n");
                } else {

                }
                pBtdm8723->btStatus = 1U;
              } else {

              }
            } else {

            }
            if ((unsigned int )pBtdm8723->btStatus != 1U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN+A2DP, set BT non-idle!!!\n");
              } else {

              }
              pBtdm8723->btStatus = 2U;
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
  if ((unsigned int )pBtdm8723->btStatus != 0U) {
    pBtMgnt->ExtConfig.bBTBusy = 1U;
  } else {
    pBtMgnt->ExtConfig.bBTBusy = 0U;
  }
  if ((unsigned int )bBtLinkExist == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], No profile exists!!!\n");
    } else {

    }
    return (algorithm);
  } else {

  }
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
    if ((unsigned int )bScoExist != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], SCO only\n");
      } else {

      }
      algorithm = 1U;
    } else {
      tmp___9 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___9 != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID only\n");
        } else {

        }
        algorithm = 2U;
      } else {
        tmp___8 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___8 != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], A2DP only\n");
          } else {

          }
          algorithm = 3U;
        } else {
          tmp___7 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___7 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN(HS) only\n");
              } else {

              }
              algorithm = 5U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN(EDR) only\n");
              } else {

              }
              algorithm = 4U;
            }
          } else
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d \n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    }
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 2U) {
    if ((unsigned int )bScoExist != 0U) {
      tmp___12 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___12 != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], SCO + HID\n");
        } else {

        }
        algorithm = 2U;
      } else {
        tmp___11 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___11 != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! SCO + A2DP\n");
          } else {

          }
        } else {
          tmp___10 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___10 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], SCO + PAN(HS)\n");
              } else {

              }
              algorithm = 1U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], SCO + PAN(EDR)\n");
              } else {

              }
              algorithm = 7U;
            }
          } else
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! SCO exists but why NO matched ACL profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    } else {
      tmp___17 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___17 != 0U) {
        tmp___18 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___18 != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + A2DP\n");
          } else {

          }
          algorithm = 9U;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        tmp___15 = BTHCI_CheckProfileExist(padapter, 3);
        if ((unsigned int )tmp___15 != 0U) {
          tmp___16 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___16 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], HID + PAN(HS)\n");
              } else {

              }
              algorithm = 9U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], HID + PAN(EDR)\n");
              } else {

              }
              algorithm = 7U;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          tmp___13 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___13 != 0U) {
            tmp___14 = BTHCI_CheckProfileExist(padapter, 1);
            if ((unsigned int )tmp___14 != 0U) {
              if ((unsigned int )bBtHsModeExist != 0U) {
                if (BTCoexDbgLevel == 1U) {
                  printk("[BTCoex], A2DP + PAN(HS)\n");
                } else {

                }
                algorithm = 3U;
              } else {
                if (BTCoexDbgLevel == 1U) {
                  printk("[BTCoex], A2DP + PAN(EDR)\n");
                } else {

                }
                algorithm = 6U;
              }
            } else {
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    }
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 3U) {
    if ((unsigned int )bScoExist != 0U) {
      tmp___23 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___23 != 0U) {
        tmp___24 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___24 != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! SCO + HID + A2DP\n");
          } else {

          }
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        tmp___21 = BTHCI_CheckProfileExist(padapter, 3);
        if ((unsigned int )tmp___21 != 0U) {
          tmp___22 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___22 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], SCO + HID + PAN(HS)\n");
              } else {

              }
              algorithm = 9U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], SCO + HID + PAN(EDR)\n");
              } else {

              }
              algorithm = 7U;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          tmp___19 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___19 != 0U) {
            tmp___20 = BTHCI_CheckProfileExist(padapter, 1);
            if ((unsigned int )tmp___20 != 0U) {
              if ((unsigned int )bBtHsModeExist != 0U) {
                if (BTCoexDbgLevel == 1U) {
                  printk("[BTCoex], Error!!! SCO + A2DP + PAN(HS)\n");
                } else {

                }
                algorithm = 1U;
              } else
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], Error!!! SCO + A2DP + PAN(EDR)\n");
              } else {

              }
            } else {
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    } else {
      tmp___25 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___25 != 0U) {
        tmp___26 = BTHCI_CheckProfileExist(padapter, 2);
        if ((unsigned int )tmp___26 != 0U) {
          tmp___27 = BTHCI_CheckProfileExist(padapter, 1);
          if ((unsigned int )tmp___27 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], HID + A2DP + PAN(HS)\n");
              } else {

              }
              algorithm = 10U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
              } else {

              }
              algorithm = 8U;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
      } else {

      }
    }
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle > 2U) {
    if ((unsigned int )bScoExist != 0U) {
      tmp___28 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___28 != 0U) {
        tmp___29 = BTHCI_CheckProfileExist(padapter, 2);
        if ((unsigned int )tmp___29 != 0U) {
          tmp___30 = BTHCI_CheckProfileExist(padapter, 1);
          if ((unsigned int )tmp___30 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
              } else {

              }
            } else
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], Error!!! SCO + HID + A2DP + PAN(EDR)\n");
            } else {

            }
          } else {
            goto _L___9;
          }
        } else {
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",
               (int )pBtMgnt->ExtConfig.NumberOfHandle);
      } else {

      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
    } else {

    }
  } else {

  }
  return (algorithm);
}
}
static u8 btdm_NeedToDecBtPwr(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  bRet = 0U;
  tmp___0 = BT_Operation(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB > 47) {
      if (BTCoexDbgLevel == 1U) {
        printk("Need to decrease bt power for HS mode!!\n");
      } else {

      }
      bRet = 1U;
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("NO Need to decrease bt power for HS mode!!\n");
    } else {

    }
  } else {
    tmp = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Need to decrease bt power for Wifi is connected!!\n");
      } else {

      }
      bRet = 1U;
    } else {

    }
  }
  return (bRet);
}
}
static void btdm_SetCoexTable(struct rtw_adapter *padapter , u32 val0x6c0 , u32 val0x6c8 ,
                              u8 val0x6cc ) 
{ 


  {
  if (BTCoexDbgLevel == 1U) {
    printk("set coex table, set 0x6c0 = 0x%x\n", val0x6c0);
  } else {

  }
  rtl8723au_write32(padapter, 1728, val0x6c0);
  if (BTCoexDbgLevel == 1U) {
    printk("set coex table, set 0x6c8 = 0x%x\n", val0x6c8);
  } else {

  }
  rtl8723au_write32(padapter, 1736, val0x6c8);
  if (BTCoexDbgLevel == 1U) {
    printk("set coex table, set 0x6cc = 0x%x\n", (int )val0x6cc);
  } else {

  }
  rtl8723au_write8(padapter, 1740, (int )val0x6cc);
  return;
}
}
static void btdm_SetSwFullTimeDacSwing(struct rtw_adapter *padapter , u8 bSwDacSwingOn ,
                                       u32 swDacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )bSwDacSwingOn != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], SwDacSwing = 0x%x\n", swDacSwingLvl);
    } else {

    }
    PHY_SetBBReg(padapter, 2176U, 4278190080U, swDacSwingLvl);
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], SwDacSwing Off!\n");
    } else {

    }
    PHY_SetBBReg(padapter, 2176U, 4278190080U, 192U);
  }
  return;
}
}
static void btdm_SetFwDacSwingLevel(struct rtw_adapter *padapter , u8 dacSwingLvl ) 
{ 
  u8 H2C_Parameter[1U] ;

  {
  H2C_Parameter[0] = 0U;
  H2C_Parameter[0] = dacSwingLvl;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Set Dac Swing Level = 0x%x\n", (int )dacSwingLvl);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], write 0x29 = 0x%x\n", (int )H2C_Parameter[0]);
  } else {

  }
  FillH2CCmd(padapter, 41, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
static void btdm_2AntDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Dec BT power = %s\n", (unsigned int )bDecBtPwr != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
  pBtdm8723->bCurDecBtPwr = bDecBtPwr;
  if ((int )pBtdm8723->bPreDecBtPwr == (int )pBtdm8723->bCurDecBtPwr) {
    return;
  } else {

  }
  BTDM_SetFwDecBtPwr(padapter, (int )pBtdm8723->bCurDecBtPwr);
  pBtdm8723->bPreDecBtPwr = pBtdm8723->bCurDecBtPwr;
  return;
}
}
static void btdm_2AntFwDacSwingLvl(struct rtw_adapter *padapter , u8 fwDacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], set FW Dac Swing level = %d\n", (int )fwDacSwingLvl);
  } else {

  }
  pBtdm8723->curFwDacSwingLvl = fwDacSwingLvl;
  if ((int )pBtdm8723->preFwDacSwingLvl == (int )pBtdm8723->curFwDacSwingLvl) {
    return;
  } else {

  }
  btdm_SetFwDacSwingLevel(padapter, (int )pBtdm8723->curFwDacSwingLvl);
  pBtdm8723->preFwDacSwingLvl = pBtdm8723->curFwDacSwingLvl;
  return;
}
}
static void btdm_2AntRfShrink(struct rtw_adapter *padapter , u8 bRxRfShrinkOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn Rx RF Shrink = %s\n", (unsigned int )bRxRfShrinkOn != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
  pBtdm8723->bCurRfRxLpfShrink = bRxRfShrinkOn;
  if ((int )pBtdm8723->bPreRfRxLpfShrink == (int )pBtdm8723->bCurRfRxLpfShrink) {
    return;
  } else {

  }
  BTDM_SetSwRfRxLpfCorner(padapter, (int )pBtdm8723->bCurRfRxLpfShrink);
  pBtdm8723->bPreRfRxLpfShrink = pBtdm8723->bCurRfRxLpfShrink;
  return;
}
}
static void btdm_2AntLowPenaltyRa(struct rtw_adapter *padapter , u8 bLowPenaltyRa ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn LowPenaltyRA = %s\n", (unsigned int )bLowPenaltyRa != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
  pBtdm8723->bCurLowPenaltyRa = bLowPenaltyRa;
  if ((int )pBtdm8723->bPreLowPenaltyRa == (int )pBtdm8723->bCurLowPenaltyRa) {
    return;
  } else {

  }
  BTDM_SetSwPenaltyTxRateAdaptive(padapter, (int )pBtdm8723->bCurLowPenaltyRa);
  pBtdm8723->bPreLowPenaltyRa = pBtdm8723->bCurLowPenaltyRa;
  return;
}
}
static void btdm_2AntDacSwing(struct rtw_adapter *padapter , u8 bDacSwingOn , u32 dacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  unsigned long __ms ;
  unsigned long tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn DacSwing =%s, dacSwingLvl = 0x%x\n", (unsigned int )bDacSwingOn != 0U ? (char *)"ON" : (char *)"OFF",
           dacSwingLvl);
  } else {

  }
  pBtdm8723->bCurDacSwingOn = bDacSwingOn;
  pBtdm8723->curDacSwingLvl = dacSwingLvl;
  if ((int )pBtdm8723->bPreDacSwingOn == (int )pBtdm8723->bCurDacSwingOn && pBtdm8723->preDacSwingLvl == pBtdm8723->curDacSwingLvl) {
    return;
  } else {

  }
  __ms = 30UL;
  goto ldv_57660;
  ldv_57659: 
  __const_udelay(4295000UL);
  ldv_57660: 
  tmp = __ms;
  __ms = __ms - 1UL;
  if (tmp != 0UL) {
    goto ldv_57659;
  } else {

  }
  btdm_SetSwFullTimeDacSwing(padapter, (int )bDacSwingOn, dacSwingLvl);
  pBtdm8723->bPreDacSwingOn = pBtdm8723->bCurDacSwingOn;
  pBtdm8723->preDacSwingLvl = pBtdm8723->curDacSwingLvl;
  return;
}
}
static void btdm_2AntAdcBackOff(struct rtw_adapter *padapter , u8 bAdcBackOff ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn AdcBackOff = %s\n", (unsigned int )bAdcBackOff != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
  pBtdm8723->bCurAdcBackOff = bAdcBackOff;
  if ((int )pBtdm8723->bPreAdcBackOff == (int )pBtdm8723->bCurAdcBackOff) {
    return;
  } else {

  }
  BTDM_BBBackOffLevel(padapter, (int )pBtdm8723->bCurAdcBackOff);
  pBtdm8723->bPreAdcBackOff = pBtdm8723->bCurAdcBackOff;
  return;
}
}
static void btdm_2AntAgcTable(struct rtw_adapter *padapter , u8 bAgcTableEn ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], %s Agc Table\n", (unsigned int )bAgcTableEn != 0U ? (char *)"Enable" : (char *)"Disable");
  } else {

  }
  pBtdm8723->bCurAgcTableEn = bAgcTableEn;
  if ((int )pBtdm8723->bPreAgcTableEn == (int )pBtdm8723->bCurAgcTableEn) {
    return;
  } else {

  }
  BTDM_AGCTable(padapter, (int )bAgcTableEn);
  pBtdm8723->bPreAgcTableEn = pBtdm8723->bCurAgcTableEn;
  return;
}
}
static void btdm_2AntCoexTable(struct rtw_adapter *padapter , u32 val0x6c0 , u32 val0x6c8 ,
                               u8 val0x6cc ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], write Coex Table 0x6c0 = 0x%x, 0x6c8 = 0x%x, 0x6cc = 0x%x\n",
           val0x6c0, val0x6c8, (int )val0x6cc);
  } else {

  }
  pBtdm8723->curVal0x6c0 = val0x6c0;
  pBtdm8723->curVal0x6c8 = val0x6c8;
  pBtdm8723->curVal0x6cc = val0x6cc;
  if ((pBtdm8723->preVal0x6c0 == pBtdm8723->curVal0x6c0 && pBtdm8723->preVal0x6c8 == pBtdm8723->curVal0x6c8) && (int )pBtdm8723->preVal0x6cc == (int )pBtdm8723->curVal0x6cc) {
    return;
  } else {

  }
  btdm_SetCoexTable(padapter, val0x6c0, val0x6c8, (int )val0x6cc);
  pBtdm8723->preVal0x6c0 = pBtdm8723->curVal0x6c0;
  pBtdm8723->preVal0x6c8 = pBtdm8723->curVal0x6c8;
  pBtdm8723->preVal0x6cc = pBtdm8723->curVal0x6cc;
  return;
}
}
static void btdm_2AntIgnoreWlanAct(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn Ignore WlanAct %s\n", (unsigned int )bEnable != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
  pBtdm8723->bCurIgnoreWlanAct = bEnable;
  if ((int )pBtdm8723->bPreIgnoreWlanAct == (int )pBtdm8723->bCurIgnoreWlanAct) {
    return;
  } else {

  }
  btdm_SetFwIgnoreWlanAct(padapter, (int )bEnable);
  pBtdm8723->bPreIgnoreWlanAct = pBtdm8723->bCurIgnoreWlanAct;
  return;
}
}
static void btdm_2AntSetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 ,
                             u8 byte3 , u8 byte4 , u8 byte5 ) 
{ 
  u8 H2C_Parameter[5U] ;
  unsigned int tmp ;
  struct hal_data_8723a *pHalData ;

  {
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {

    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )byte1 != 0U) {
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
  H2C_Parameter[0] = byte1;
  H2C_Parameter[1] = byte2;
  H2C_Parameter[2] = byte3;
  H2C_Parameter[3] = byte4;
  H2C_Parameter[4] = byte5;
  pHalData->bt_coexist.fw3aVal[0] = byte1;
  pHalData->bt_coexist.fw3aVal[1] = byte2;
  pHalData->bt_coexist.fw3aVal[2] = byte3;
  pHalData->bt_coexist.fw3aVal[3] = byte4;
  pHalData->bt_coexist.fw3aVal[4] = byte5;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], FW write 0x3a(5bytes) = 0x%x%08x\n", (int )H2C_Parameter[0],
           ((((int )H2C_Parameter[1] << 24) | ((int )H2C_Parameter[2] << 16)) | ((int )H2C_Parameter[3] << 8)) | (int )H2C_Parameter[4]);
  } else {

  }
  FillH2CCmd(padapter, 58, 5U, (u8 *)(& H2C_Parameter));
  return;
}
}
static void btdm_2AntPsTdma(struct rtw_adapter *padapter , u8 bTurnOn , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u32 btTxRxCnt ;
  u8 bTurnOnByCnt ;
  u8 psTdmaTypeByCnt ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  btTxRxCnt = 0U;
  bTurnOnByCnt = 0U;
  psTdmaTypeByCnt = 0U;
  tmp = BTDM_BtTxRxCounterH(padapter);
  tmp___0 = BTDM_BtTxRxCounterL(padapter);
  btTxRxCnt = tmp + tmp___0;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT TxRx Counters = %d\n", btTxRxCnt);
  } else {

  }
  if (btTxRxCnt > 3000U) {
    bTurnOnByCnt = 1U;
    psTdmaTypeByCnt = 8U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], For BTTxRxCounters, turn %s PS TDMA, type =%d\n", (unsigned int )bTurnOnByCnt != 0U ? (char *)"ON" : (char *)"OFF",
             (int )psTdmaTypeByCnt);
    } else {

    }
    pBtdm8723->bCurPsTdmaOn = bTurnOnByCnt;
    pBtdm8723->curPsTdma = psTdmaTypeByCnt;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], turn %s PS TDMA, type =%d\n", (unsigned int )bTurnOn != 0U ? (char *)"ON" : (char *)"OFF",
             (int )type);
    } else {

    }
    pBtdm8723->bCurPsTdmaOn = bTurnOn;
    pBtdm8723->curPsTdma = type;
  }
  if ((int )pBtdm8723->bPrePsTdmaOn == (int )pBtdm8723->bCurPsTdmaOn && (int )pBtdm8723->prePsTdma == (int )pBtdm8723->curPsTdma) {
    return;
  } else {

  }
  if ((unsigned int )bTurnOn != 0U) {
    switch ((int )type) {
    case 1: ;
    default: 
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 161, 152);
    goto ldv_57710;
    case 2: 
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 161, 152);
    goto ldv_57710;
    case 3: 
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 161, 152);
    goto ldv_57710;
    case 4: 
    btdm_2AntSetFw3a(padapter, 163, 5, 5, 161, 128);
    goto ldv_57710;
    case 5: 
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 32, 152);
    goto ldv_57710;
    case 6: 
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 32, 152);
    goto ldv_57710;
    case 7: 
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 32, 152);
    goto ldv_57710;
    case 8: 
    btdm_2AntSetFw3a(padapter, 163, 5, 5, 32, 128);
    goto ldv_57710;
    case 9: 
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 161, 152);
    goto ldv_57710;
    case 10: 
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 161, 152);
    goto ldv_57710;
    case 11: 
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 161, 152);
    goto ldv_57710;
    case 12: 
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 161, 152);
    goto ldv_57710;
    case 13: 
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 32, 152);
    goto ldv_57710;
    case 14: 
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 32, 152);
    goto ldv_57710;
    case 15: 
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 32, 152);
    goto ldv_57710;
    case 16: 
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 32, 152);
    goto ldv_57710;
    case 17: 
    btdm_2AntSetFw3a(padapter, 163, 47, 47, 32, 128);
    goto ldv_57710;
    case 18: 
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 161, 152);
    goto ldv_57710;
    case 19: 
    btdm_2AntSetFw3a(padapter, 227, 37, 37, 161, 152);
    goto ldv_57710;
    case 20: 
    btdm_2AntSetFw3a(padapter, 227, 37, 37, 32, 152);
    goto ldv_57710;
    }
    ldv_57710: ;
  } else {
    switch ((int )type) {
    case 0: 
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 8, 0);
    goto ldv_57731;
    case 1: 
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 0, 0);
    goto ldv_57731;
    default: 
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 8, 0);
    goto ldv_57731;
    }
    ldv_57731: ;
  }
  pBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;
  pBtdm8723->prePsTdma = pBtdm8723->curPsTdma;
  return;
}
}
static void btdm_2AntBtInquiryPage(struct rtw_adapter *padapter ) 
{ 


  {
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
  btdm_2AntIgnoreWlanAct(padapter, 0);
  btdm_2AntPsTdma(padapter, 1, 8);
  return;
}
}
static u8 btdm_HoldForBtInqPage(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 curTime ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  curTime = (u32 )jiffies;
  if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage != 0U) {
    if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime == 0UL) {
      pHalData->bt_coexist.halCoex8723.btInqPageStartTime = (unsigned long )curTime;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT Inquiry/page is started at time : 0x%lx \n", pHalData->bt_coexist.halCoex8723.btInqPageStartTime);
      } else {

      }
    } else {

    }
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT Inquiry/page started time : 0x%lx, curTime : 0x%x \n", pHalData->bt_coexist.halCoex8723.btInqPageStartTime,
           curTime);
  } else {

  }
  if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime != 0UL) {
    if ((unsigned long )curTime - pHalData->bt_coexist.halCoex8723.btInqPageStartTime > 9999999UL) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT Inquiry/page >= 10sec!!!");
      } else {

      }
      pHalData->bt_coexist.halCoex8723.btInqPageStartTime = 0UL;
    } else {

    }
  } else {

  }
  if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime != 0UL) {
    btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
    btdm_2AntIgnoreWlanAct(padapter, 0);
    btdm_2AntPsTdma(padapter, 1, 8);
    return (1U);
  } else {
    return (0U);
  }
}
}
static u8 btdm_Is2Ant8723ACommonAction(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 bCommon ;
  bool tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  bool tmp___5 ;
  u8 tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  u8 tmp___9 ;
  bool tmp___10 ;
  u8 tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  bCommon = 0U;
  if (BTCoexDbgLevel == 1U) {
    tmp = check_fwstate(& padapter->mlmepriv, 2176);
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
    printk("%s :BTDM_IsWifiConnectionExist =%x check_fwstate =%x pmlmepriv->fw_state = 0x%x\n",
           "btdm_Is2Ant8723ACommonAction", (int )tmp___0, (int )tmp, padapter->mlmepriv.fw_state);
  } else {

  }
  tmp___11 = BTDM_IsWifiConnectionExist(padapter);
  if ((unsigned int )tmp___11 == 0U) {
    tmp___12 = check_fwstate(& padapter->mlmepriv, 2176);
    if (tmp___12) {
      tmp___13 = 0;
    } else {
      tmp___13 = 1;
    }
    if (tmp___13) {
      if ((unsigned int )pBtdm8723->btStatus == 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("Wifi idle + Bt idle!!\n");
        } else {

        }
        btdm_2AntLowPenaltyRa(padapter, 0);
        btdm_2AntRfShrink(padapter, 0);
        btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
        btdm_2AntIgnoreWlanAct(padapter, 0);
        btdm_2AntPsTdma(padapter, 0, 0);
        btdm_2AntFwDacSwingLvl(padapter, 32);
        btdm_2AntDecBtPwr(padapter, 0);
        btdm_2AntAgcTable(padapter, 0);
        btdm_2AntAdcBackOff(padapter, 0);
        btdm_2AntDacSwing(padapter, 0, 192U);
        bCommon = 1U;
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    tmp___9 = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp___9 != 0U) {
      goto _L___6;
    } else {
      tmp___10 = check_fwstate(& padapter->mlmepriv, 2176);
      if ((int )tmp___10) {
        _L___6: /* CIL Label */ 
        if ((unsigned int )pBtdm8723->btStatus == 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("Wifi non-idle + BT idle!!\n");
          } else {

          }
          btdm_2AntLowPenaltyRa(padapter, 1);
          btdm_2AntRfShrink(padapter, 0);
          btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
          btdm_2AntIgnoreWlanAct(padapter, 0);
          btdm_2AntPsTdma(padapter, 0, 0);
          btdm_2AntFwDacSwingLvl(padapter, 32);
          btdm_2AntDecBtPwr(padapter, 1);
          btdm_2AntAgcTable(padapter, 0);
          btdm_2AntAdcBackOff(padapter, 0);
          btdm_2AntDacSwing(padapter, 0, 192U);
          bCommon = 1U;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        tmp___6 = BTDM_IsWifiConnectionExist(padapter);
        if ((unsigned int )tmp___6 == 0U) {
          tmp___7 = check_fwstate(& padapter->mlmepriv, 2176);
          if (tmp___7) {
            tmp___8 = 0;
          } else {
            tmp___8 = 1;
          }
          if (tmp___8) {
            if ((unsigned int )pBtdm8723->btStatus == 1U) {
              if (BTCoexDbgLevel == 1U) {
                printk("Wifi idle + Bt connected idle!!\n");
              } else {

              }
              btdm_2AntLowPenaltyRa(padapter, 1);
              btdm_2AntRfShrink(padapter, 1);
              btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
              btdm_2AntIgnoreWlanAct(padapter, 0);
              btdm_2AntPsTdma(padapter, 0, 0);
              btdm_2AntFwDacSwingLvl(padapter, 32);
              btdm_2AntDecBtPwr(padapter, 0);
              btdm_2AntAgcTable(padapter, 0);
              btdm_2AntAdcBackOff(padapter, 0);
              btdm_2AntDacSwing(padapter, 0, 192U);
              bCommon = 1U;
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          tmp___4 = BTDM_IsWifiConnectionExist(padapter);
          if ((unsigned int )tmp___4 != 0U) {
            goto _L___2;
          } else {
            tmp___5 = check_fwstate(& padapter->mlmepriv, 2176);
            if ((int )tmp___5) {
              _L___2: /* CIL Label */ 
              if ((unsigned int )pBtdm8723->btStatus == 1U) {
                if (BTCoexDbgLevel == 1U) {
                  printk("Wifi non-idle + Bt connected idle!!\n");
                } else {

                }
                btdm_2AntLowPenaltyRa(padapter, 1);
                btdm_2AntRfShrink(padapter, 1);
                btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
                btdm_2AntIgnoreWlanAct(padapter, 0);
                btdm_2AntPsTdma(padapter, 0, 0);
                btdm_2AntFwDacSwingLvl(padapter, 32);
                btdm_2AntDecBtPwr(padapter, 1);
                btdm_2AntAgcTable(padapter, 0);
                btdm_2AntAdcBackOff(padapter, 0);
                btdm_2AntDacSwing(padapter, 0, 192U);
                bCommon = 1U;
              } else {
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              tmp___1 = BTDM_IsWifiConnectionExist(padapter);
              if ((unsigned int )tmp___1 == 0U) {
                tmp___2 = check_fwstate(& padapter->mlmepriv, 2176);
                if (tmp___2) {
                  tmp___3 = 0;
                } else {
                  tmp___3 = 1;
                }
                if (tmp___3) {
                  if ((unsigned int )pBtdm8723->btStatus == 2U) {
                    if (BTCoexDbgLevel == 1U) {
                      printk("Wifi idle + BT non-idle!!\n");
                    } else {

                    }
                    btdm_2AntLowPenaltyRa(padapter, 1);
                    btdm_2AntRfShrink(padapter, 1);
                    btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
                    btdm_2AntIgnoreWlanAct(padapter, 0);
                    btdm_2AntPsTdma(padapter, 0, 0);
                    btdm_2AntFwDacSwingLvl(padapter, 32);
                    btdm_2AntDecBtPwr(padapter, 0);
                    btdm_2AntAgcTable(padapter, 0);
                    btdm_2AntAdcBackOff(padapter, 0);
                    btdm_2AntDacSwing(padapter, 0, 192U);
                    bCommon = 1U;
                  } else {
                    goto _L___0;
                  }
                } else {
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                if (BTCoexDbgLevel == 1U) {
                  printk("Wifi non-idle + BT non-idle!!\n");
                } else {

                }
                btdm_2AntLowPenaltyRa(padapter, 1);
                btdm_2AntRfShrink(padapter, 1);
                btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
                btdm_2AntIgnoreWlanAct(padapter, 0);
                btdm_2AntFwDacSwingLvl(padapter, 32);
                bCommon = 0U;
              }
            }
          }
        }
      }
    }
  }
  return (bCommon);
}
}
static void btdm_2AntTdmaDurationAdjust(struct rtw_adapter *padapter , u8 bScoHid ,
                                        u8 bTxPause , u8 maxInterval ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  s32 up___0 ;
  s32 dn ;
  s32 m ;
  s32 n ;
  s32 WaitCount ;
  s32 result ;
  u8 retryCount ;
  bool tmp ;
  int tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  retryCount = 0U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], TdmaDurationAdjust()\n");
  } else {

  }
  if ((unsigned int )pBtdm8723->bResetTdmaAdjust != 0U) {
    pBtdm8723->bResetTdmaAdjust = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], first run TdmaDurationAdjust()!!\n");
    } else {

    }
    if ((unsigned int )bScoHid != 0U) {
      if ((unsigned int )bTxPause != 0U) {
        btdm_2AntPsTdma(padapter, 1, 15);
        pBtdm8723->psTdmaDuAdjType = 15U;
      } else {
        btdm_2AntPsTdma(padapter, 1, 11);
        pBtdm8723->psTdmaDuAdjType = 11U;
      }
    } else
    if ((unsigned int )bTxPause != 0U) {
      btdm_2AntPsTdma(padapter, 1, 7);
      pBtdm8723->psTdmaDuAdjType = 7U;
    } else {
      btdm_2AntPsTdma(padapter, 1, 3);
      pBtdm8723->psTdmaDuAdjType = 3U;
    }
    up___0 = 0;
    dn = 0;
    m = 1;
    n = 3;
    result = 0;
    WaitCount = 0;
  } else {
    retryCount = pHalData->bt_coexist.halCoex8723.btRetryCnt;
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], retryCount = %d\n", (int )retryCount);
    } else {

    }
    result = 0;
    WaitCount = WaitCount + 1;
    if ((unsigned int )retryCount == 0U) {
      up___0 = up___0 + 1;
      dn = dn - 1;
      if (dn <= 0) {
        dn = 0;
      } else {

      }
      if (up___0 >= n) {
        WaitCount = 0;
        n = 3;
        up___0 = 0;
        dn = 0;
        result = 1;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Increase wifi duration!!\n");
        } else {

        }
      } else {

      }
    } else
    if ((unsigned int )retryCount <= 3U) {
      up___0 = up___0 - 1;
      dn = dn + 1;
      if (up___0 <= 0) {
        up___0 = 0;
      } else {

      }
      if (dn == 2) {
        if (WaitCount <= 2) {
          m = m + 1;
        } else {
          m = 1;
        }
        if (m > 19) {
          m = 20;
        } else {

        }
        n = m * 3;
        up___0 = 0;
        dn = 0;
        WaitCount = 0;
        result = -1;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Decrease wifi duration for retryCounter<3!!\n");
        } else {

        }
      } else {

      }
    } else {
      if (WaitCount == 1) {
        m = m + 1;
      } else {
        m = 1;
      }
      if (m > 19) {
        m = 20;
      } else {

      }
      n = m * 3;
      up___0 = 0;
      dn = 0;
      WaitCount = 0;
      result = -1;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Decrease wifi duration for retryCounter>3!!\n");
      } else {

      }
    }
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], max Interval = %d\n", (int )maxInterval);
    } else {

    }
    if ((unsigned int )maxInterval == 1U) {
      if ((unsigned int )bTxPause != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
          btdm_2AntPsTdma(padapter, 1, 5);
          pBtdm8723->psTdmaDuAdjType = 5U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          btdm_2AntPsTdma(padapter, 1, 6);
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
          btdm_2AntPsTdma(padapter, 1, 8);
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          btdm_2AntPsTdma(padapter, 1, 13);
          pBtdm8723->psTdmaDuAdjType = 13U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
          btdm_2AntPsTdma(padapter, 1, 14);
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
          btdm_2AntPsTdma(padapter, 1, 16);
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 8);
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 16);
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 5);
            pBtdm8723->psTdmaDuAdjType = 5U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 13);
            pBtdm8723->psTdmaDuAdjType = 13U;
          } else {

          }
        } else {

        }
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
          btdm_2AntPsTdma(padapter, 1, 1);
          pBtdm8723->psTdmaDuAdjType = 1U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
          btdm_2AntPsTdma(padapter, 1, 2);
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
          btdm_2AntPsTdma(padapter, 1, 4);
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
          btdm_2AntPsTdma(padapter, 1, 9);
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
          btdm_2AntPsTdma(padapter, 1, 10);
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
          btdm_2AntPsTdma(padapter, 1, 12);
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 4);
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 12);
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 1);
            pBtdm8723->psTdmaDuAdjType = 1U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 9);
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {

          }
        } else {

        }
      }
    } else
    if ((unsigned int )maxInterval == 2U) {
      if ((unsigned int )bTxPause != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
          btdm_2AntPsTdma(padapter, 1, 6);
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          btdm_2AntPsTdma(padapter, 1, 6);
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
          btdm_2AntPsTdma(padapter, 1, 8);
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          btdm_2AntPsTdma(padapter, 1, 14);
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
          btdm_2AntPsTdma(padapter, 1, 14);
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
          btdm_2AntPsTdma(padapter, 1, 16);
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 8);
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 16);
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else {

          }
        } else {

        }
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
          btdm_2AntPsTdma(padapter, 1, 2);
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
          btdm_2AntPsTdma(padapter, 1, 2);
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
          btdm_2AntPsTdma(padapter, 1, 4);
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
          btdm_2AntPsTdma(padapter, 1, 10);
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
          btdm_2AntPsTdma(padapter, 1, 10);
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
          btdm_2AntPsTdma(padapter, 1, 12);
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 4);
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 12);
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else {

          }
        } else {

        }
      }
    } else
    if ((unsigned int )maxInterval == 3U) {
      if ((unsigned int )bTxPause != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
          btdm_2AntPsTdma(padapter, 1, 8);
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
          btdm_2AntPsTdma(padapter, 1, 16);
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 8);
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 16);
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else {

          }
        } else {

        }
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
          btdm_2AntPsTdma(padapter, 1, 4);
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
          btdm_2AntPsTdma(padapter, 1, 12);
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 4);
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 12);
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else {

          }
        } else {

        }
      }
    } else {

    }
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], PsTdma type : recordPsTdma =%d\n", (int )pBtdm8723->psTdmaDuAdjType);
  } else {

  }
  if ((int )pBtdm8723->curPsTdma != (int )pBtdm8723->psTdmaDuAdjType) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], PsTdma type dismatch!!!, curPsTdma =%d, recordPsTdma =%d\n",
             (int )pBtdm8723->curPsTdma, (int )pBtdm8723->psTdmaDuAdjType);
    } else {

    }
    tmp = check_fwstate(& padapter->mlmepriv, 2176);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      btdm_2AntPsTdma(padapter, 1, (int )pBtdm8723->psTdmaDuAdjType);
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
    } else {

    }
  } else {

  }
  return;
}
}
static void btdm_2Ant8723ASCOAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntPsTdma(padapter, 1, 11);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntPsTdma(padapter, 1, 15);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntPsTdma(padapter, 1, 11);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntPsTdma(padapter, 1, 15);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AHIDAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntPsTdma(padapter, 1, 9);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntPsTdma(padapter, 1, 13);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 0);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntPsTdma(padapter, 1, 9);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntPsTdma(padapter, 1, 13);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AA2DPAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  struct hal_data_8723a *pHalData ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
      }
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
      }
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723APANEDRAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntPsTdma(padapter, 1, 2);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntPsTdma(padapter, 1, 6);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntPsTdma(padapter, 1, 2);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntPsTdma(padapter, 1, 6);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723APANHSAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 tmp ;

  {
  tmp = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      btdm_2AntDecBtPwr(padapter, 1);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntDecBtPwr(padapter, 0);
    }
    btdm_2AntPsTdma(padapter, 0, 0);
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high\n");
      } else {

      }
      btdm_2AntDecBtPwr(padapter, 1);
      btdm_2AntPsTdma(padapter, 0, 0);
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low\n");
      } else {

      }
      btdm_2AntDecBtPwr(padapter, 0);
      btdm_2AntPsTdma(padapter, 0, 0);
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723APANEDRA2DPAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 4);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 2);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 8);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 6);
      }
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 4);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 2);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 8);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 6);
      }
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723APANEDRHIDAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntPsTdma(padapter, 1, 10);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntPsTdma(padapter, 1, 14);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntPsTdma(padapter, 1, 10);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntPsTdma(padapter, 1, 14);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AHIDA2DPPANEDRAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 12);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 10);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 16);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 14);
      }
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 37, 0);
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 12);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 10);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 16);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntPsTdma(padapter, 1, 14);
      }
    }
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AHIDA2DPAction(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 1);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 1);
      }
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 1);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {

        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 1);
      }
    }
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AA2dp(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
  btdm_2AntIgnoreWlanAct(padapter, 0);
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {

    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {

      }
      rtl8723au_write8(padapter, 2179, 64);
      btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {

      }
      btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {

      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void BTDM_2AntParaInit(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], 2Ant Parameter Init!!\n");
  } else {

  }
  rtl8723au_write8(padapter, 1902, 4);
  rtl8723au_write8(padapter, 1912, 3);
  rtl8723au_write8(padapter, 64, 32);
  pBtdm8723->preVal0x6c0 = 0U;
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
  pBtdm8723->bPrePsTdmaOn = 1U;
  btdm_2AntPsTdma(padapter, 0, 0);
  pBtdm8723->preFwDacSwingLvl = 16U;
  btdm_2AntFwDacSwingLvl(padapter, 32);
  pBtdm8723->bPreDecBtPwr = 1U;
  btdm_2AntDecBtPwr(padapter, 0);
  pBtdm8723->bPreAgcTableEn = 1U;
  btdm_2AntAgcTable(padapter, 0);
  pBtdm8723->bPreAdcBackOff = 1U;
  btdm_2AntAdcBackOff(padapter, 0);
  pBtdm8723->bPreLowPenaltyRa = 1U;
  btdm_2AntLowPenaltyRa(padapter, 0);
  pBtdm8723->bPreRfRxLpfShrink = 1U;
  btdm_2AntRfShrink(padapter, 0);
  pBtdm8723->bPreDacSwingOn = 1U;
  btdm_2AntDacSwing(padapter, 0, 192U);
  pBtdm8723->bPreIgnoreWlanAct = 1U;
  btdm_2AntIgnoreWlanAct(padapter, 0);
  return;
}
}
static void BTDM_2AntHwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
  return;
}
}
static void BTDM_2AntFwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
  btdm_2AntIgnoreWlanAct(padapter, 0);
  btdm_2AntPsTdma(padapter, 0, 0);
  btdm_2AntFwDacSwingLvl(padapter, 32);
  btdm_2AntDecBtPwr(padapter, 0);
  return;
}
}
static void BTDM_2AntSwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
  btdm_2AntAgcTable(padapter, 0);
  btdm_2AntAdcBackOff(padapter, 0);
  btdm_2AntLowPenaltyRa(padapter, 0);
  btdm_2AntRfShrink(padapter, 0);
  btdm_2AntDacSwing(padapter, 0, 192U);
  return;
}
}
static void BTDM_2AntFwC2hBtInfo8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 btInfo ;
  u8 algorithm ;
  u8 bBtLinkExist ;
  u8 bBtHsModeExist ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  btInfo = 0U;
  algorithm = 0U;
  bBtLinkExist = 0U;
  bBtHsModeExist = 0U;
  btInfo = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;
  pBtdm8723->btStatus = 0U;
  if (((unsigned long )btInfo & 4UL) != 0UL) {
    if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage == 0U) {
      pBtMgnt->ExtConfig.bHoldForBtOperation = 1U;
      pBtMgnt->ExtConfig.bHoldPeriodCnt = 1U;
      btdm_2AntBtInquiryPage(padapter);
    } else {
      pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      btdm_HoldForBtInqPage(padapter);
    }
    pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = 1U;
  } else {
    pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = 0U;
    pBtMgnt->ExtConfig.bHoldForBtOperation = 0U;
    pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H], pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage =%x pBtMgnt->ExtConfig.bHoldPeriodCnt =%x pBtMgnt->ExtConfig.bHoldForBtOperation =%x\n",
           (int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage, pBtMgnt->ExtConfig.bHoldPeriodCnt,
           (int )pBtMgnt->ExtConfig.bHoldForBtOperation);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H],   btInfo =%x   pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal =%x\n",
           (int )btInfo, (int )pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal);
  } else {

  }
  if ((int )btInfo & 1) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTC2H], BTInfo: bConnect = true   btInfo =%x\n", (int )btInfo);
    } else {

    }
    bBtLinkExist = 1U;
    if (((unsigned long )btInfo & 240UL) != 0UL || (unsigned int )pHalData->bt_coexist.halCoex8723.btRetryCnt != 0U) {
      pBtdm8723->btStatus = 2U;
    } else {
      pBtdm8723->btStatus = 1U;
    }
    if (((unsigned long )btInfo & 2UL) != 0UL || ((unsigned long )btInfo & 16UL) != 0UL) {
      if (((int )((signed char )btInfo) < 0 || ((unsigned long )btInfo & 64UL) != 0UL) || ((unsigned long )btInfo & 32UL) != 0UL) {
        switch ((int )btInfo & 224) {
        case 32: ;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], SCO + HID\n");
        } else {

        }
        algorithm = 2U;
        goto ldv_57849;
        case 64: ;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Error!!! SCO + A2DP\n");
        } else {

        }
        goto ldv_57849;
        case 128: ;
        if ((unsigned int )bBtHsModeExist != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], SCO + PAN(HS)\n");
          } else {

          }
          algorithm = 1U;
        } else {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], SCO + PAN(EDR)\n");
          } else {

          }
          algorithm = 7U;
        }
        goto ldv_57849;
        case 96: ;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + A2DP\n");
        } else {

        }
        algorithm = 9U;
        goto ldv_57849;
        case 160: ;
        if ((unsigned int )bBtHsModeExist != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + PAN(HS)\n");
          } else {

          }
          algorithm = 9U;
        } else {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + PAN(EDR)\n");
          } else {

          }
          algorithm = 7U;
        }
        goto ldv_57849;
        case 192: ;
        if ((unsigned int )bBtHsModeExist != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], A2DP + PAN(HS)\n");
          } else {

          }
          algorithm = 3U;
        } else {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], A2DP + PAN(EDR)\n");
          } else {

          }
          algorithm = 6U;
        }
        goto ldv_57849;
        case 224: ;
        if ((unsigned int )bBtHsModeExist != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + A2DP + PAN(HS)\n");
          } else {

          }
          algorithm = 9U;
        } else {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
          } else {

          }
          algorithm = 8U;
        }
        goto ldv_57849;
        }
        ldv_57849: ;
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], SCO only\n");
        } else {

        }
        algorithm = 1U;
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], non SCO\n");
      } else {

      }
      switch ((int )btInfo & 224) {
      case 32: ;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], HID\n");
      } else {

      }
      algorithm = 2U;
      goto ldv_57857;
      case 64: ;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex],  A2DP\n");
      } else {

      }
      algorithm = 3U;
      goto ldv_57857;
      case 128: ;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], PAN(EDR)\n");
      } else {

      }
      algorithm = 7U;
      goto ldv_57857;
      case 96: ;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], HID + A2DP\n");
      } else {

      }
      algorithm = 9U;
      goto ldv_57857;
      case 160: ;
      if ((unsigned int )bBtHsModeExist != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + PAN(HS)\n");
        } else {

        }
        algorithm = 9U;
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + PAN(EDR)\n");
        } else {

        }
        algorithm = 7U;
      }
      goto ldv_57857;
      case 192: ;
      if ((unsigned int )bBtHsModeExist != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], A2DP + PAN(HS)\n");
        } else {

        }
        algorithm = 3U;
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], A2DP + PAN(EDR)\n");
        } else {

        }
        algorithm = 6U;
      }
      goto ldv_57857;
      case 224: ;
      if ((unsigned int )bBtHsModeExist != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + A2DP + PAN(HS)\n");
        } else {

        }
        algorithm = 9U;
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
        } else {

        }
        algorithm = 8U;
      }
      goto ldv_57857;
      }
      ldv_57857: ;
    }
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTC2H], BTInfo: bConnect = false\n");
    } else {

    }
    pBtdm8723->btStatus = 0U;
  }
  pBtdm8723->curAlgorithm = algorithm;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Algorithm = %d \n", (int )pBtdm8723->curAlgorithm);
  } else {

  }
  BTDM_CheckWiFiState(padapter);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Action Manual control, won\'t execute bt coexist mechanism!!\n");
    } else {

    }
    return;
  } else {

  }
  return;
}
}
void BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 btInfoOriginal ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  btInfoOriginal = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  tmp___1 = BTDM_BtProfileSupport(padapter);
  if ((unsigned int )tmp___1 != 0U) {
    if ((unsigned int )pBtMgnt->ExtConfig.bHoldForBtOperation != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Action for BT Operation adjust!!\n");
      } else {

      }
      return;
    } else {

    }
    if (pBtMgnt->ExtConfig.bHoldPeriodCnt != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Hold BT inquiry/page scan setting (cnt = %d)!!\n", pBtMgnt->ExtConfig.bHoldPeriodCnt);
      } else {

      }
      if (pBtMgnt->ExtConfig.bHoldPeriodCnt > 10U) {
        pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
      } else {
        pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      }
      return;
    } else {

    }
    if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[Dbg control], ");
      } else {

      }
    } else {

    }
    pBtdm8723->curAlgorithm = btdm_ActionAlgorithm(padapter);
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Algorithm = %d \n", (int )pBtdm8723->curAlgorithm);
    } else {

    }
    tmp = btdm_Is2Ant8723ACommonAction(padapter);
    if ((unsigned int )tmp != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant common.\n");
      } else {

      }
      pBtdm8723->bResetTdmaAdjust = 1U;
    } else {
      if ((int )pBtdm8723->curAlgorithm != (int )pBtdm8723->preAlgorithm) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n", (int )pBtdm8723->preAlgorithm,
                 (int )pBtdm8723->curAlgorithm);
        } else {

        }
        pBtdm8723->bResetTdmaAdjust = 1U;
      } else {

      }
      switch ((int )pBtdm8723->curAlgorithm) {
      case 1: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = SCO.\n");
      } else {

      }
      btdm_2Ant8723ASCOAction(padapter);
      goto ldv_57874;
      case 2: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID.\n");
      } else {

      }
      btdm_2Ant8723AHIDAction(padapter);
      goto ldv_57874;
      case 3: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = A2DP.\n");
      } else {

      }
      btdm_2Ant8723AA2DPAction(padapter);
      goto ldv_57874;
      case 4: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN(EDR).\n");
      } else {

      }
      btdm_2Ant8723APANEDRAction(padapter);
      goto ldv_57874;
      case 5: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HS mode.\n");
      } else {

      }
      btdm_2Ant8723APANHSAction(padapter);
      goto ldv_57874;
      case 6: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN+A2DP.\n");
      } else {

      }
      btdm_2Ant8723APANEDRA2DPAction(padapter);
      goto ldv_57874;
      case 7: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
      } else {

      }
      btdm_2Ant8723APANEDRHIDAction(padapter);
      goto ldv_57874;
      case 8: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
      } else {

      }
      btdm_2Ant8723AHIDA2DPPANEDRAction(padapter);
      goto ldv_57874;
      case 9: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID+A2DP.\n");
      } else {

      }
      btdm_2Ant8723AHIDA2DPAction(padapter);
      goto ldv_57874;
      default: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = 0.\n");
      } else {

      }
      btdm_2Ant8723AA2DPAction(padapter);
      goto ldv_57874;
      }
      ldv_57874: 
      pBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;
    }
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex] Get bt info by fw!!\n");
    } else {

    }
    if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInfoReqSent != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex] c2h for btInfo not rcvd yet!!\n");
      } else {

      }
    } else {

    }
    btInfoOriginal = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;
    if ((unsigned int )pBtMgnt->ExtConfig.bHoldForBtOperation != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Action for BT Operation adjust!!\n");
      } else {

      }
      return;
    } else {

    }
    if (pBtMgnt->ExtConfig.bHoldPeriodCnt != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Hold BT inquiry/page scan setting (cnt = %d)!!\n", pBtMgnt->ExtConfig.bHoldPeriodCnt);
      } else {

      }
      if (pBtMgnt->ExtConfig.bHoldPeriodCnt > 10U) {
        pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
      } else {
        pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      }
      return;
    } else {

    }
    if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[Dbg control], ");
      } else {

      }
    } else {

    }
    tmp___0 = btdm_Is2Ant8723ACommonAction(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant common.\n");
      } else {

      }
      pBtdm8723->bResetTdmaAdjust = 1U;
    } else {
      if ((int )pBtdm8723->curAlgorithm != (int )pBtdm8723->preAlgorithm) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n", (int )pBtdm8723->preAlgorithm,
                 (int )pBtdm8723->curAlgorithm);
        } else {

        }
        pBtdm8723->bResetTdmaAdjust = 1U;
      } else {

      }
      switch ((int )pBtdm8723->curAlgorithm) {
      case 1: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = SCO.\n");
      } else {

      }
      btdm_2Ant8723ASCOAction(padapter);
      goto ldv_57885;
      case 2: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID.\n");
      } else {

      }
      btdm_2Ant8723AHIDAction(padapter);
      goto ldv_57885;
      case 3: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = A2DP.\n");
      } else {

      }
      btdm_2Ant8723AA2dp(padapter);
      goto ldv_57885;
      case 4: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN(EDR).\n");
      } else {

      }
      btdm_2Ant8723APANEDRAction(padapter);
      goto ldv_57885;
      case 5: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HS mode.\n");
      } else {

      }
      btdm_2Ant8723APANHSAction(padapter);
      goto ldv_57885;
      case 6: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN+A2DP.\n");
      } else {

      }
      btdm_2Ant8723APANEDRA2DPAction(padapter);
      goto ldv_57885;
      case 7: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
      } else {

      }
      btdm_2Ant8723APANEDRHIDAction(padapter);
      goto ldv_57885;
      case 8: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
      } else {

      }
      btdm_2Ant8723AHIDA2DPPANEDRAction(padapter);
      goto ldv_57885;
      case 9: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID+A2DP.\n");
      } else {

      }
      btdm_2Ant8723AHIDA2DPAction(padapter);
      goto ldv_57885;
      default: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = 0.\n");
      } else {

      }
      btdm_2Ant8723AA2DPAction(padapter);
      goto ldv_57885;
      }
      ldv_57885: 
      pBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;
    }
  }
  return;
}
}
static u8 btCoexDbgBuf[100U]  ;
static char const   * const  BtProfileString[5U]  = {      "NONE",      "A2DP",      "PAN",      "HID", 
        "SCO"};
static char const   * const  BtSpecString[7U]  = {      "1.0b",      "1.1",      "1.2",      "2.0+EDR", 
        "2.1+EDR",      "3.0+HS",      "4.0"};
static char const   * const  BtLinkRoleString[2U]  = {      "Master",      "Slave"};
static u8 btdm_BtWifiAntNum(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U) {
    if ((unsigned int )pBtCoex->TotalAntNum == 0U) {
      return (0U);
    } else {
      return (1U);
    }
  } else {
    return (1U);
  }
  return (0U);
}
}
static void btdm_BtHwCountersMonitor(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 regHPTxRx ;
  u32 regLPTxRx ;
  u32 u4Tmp ;
  u32 regHPTx ;
  u32 regHPRx ;
  u32 regLPTx ;
  u32 regLPRx ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  regHPTx = 0U;
  regHPRx = 0U;
  regLPTx = 0U;
  regLPRx = 0U;
  regHPTxRx = 1904U;
  regLPTxRx = 1908U;
  u4Tmp = rtl8723au_read32(padapter, (int )((u16 )regHPTxRx));
  regHPTx = u4Tmp & 65535U;
  regHPRx = u4Tmp >> 16;
  u4Tmp = rtl8723au_read32(padapter, (int )((u16 )regLPTxRx));
  regLPTx = u4Tmp & 65535U;
  regLPRx = u4Tmp >> 16;
  pHalData->bt_coexist.halCoex8723.highPriorityTx = regHPTx;
  pHalData->bt_coexist.halCoex8723.highPriorityRx = regHPRx;
  pHalData->bt_coexist.halCoex8723.lowPriorityTx = regLPTx;
  pHalData->bt_coexist.halCoex8723.lowPriorityRx = regLPRx;
  if (BTCoexDbgLevel == 1U) {
    printk("High Priority Tx/Rx = %d / %d\n", regHPTx, regHPRx);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("Low Priority Tx/Rx = %d / %d\n", regLPTx, regLPRx);
  } else {

  }
  rtl8723au_write8(padapter, 1902, 12);
  return;
}
}
static void btdm_BtEnableDisableCheck8723A(struct rtw_adapter *padapter ) 
{ 
  u8 btAlife ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;

  {
  btAlife = 1U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 0U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 0U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 0U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 0U) {
    btAlife = 0U;
  } else {

  }
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 60138U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 60138U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 60138U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 60138U) {
    btAlife = 0U;
  } else {

  }
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 65535U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 65535U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 65535U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 65535U) {
    btAlife = 0U;
  } else {

  }
  if ((unsigned int )btAlife != 0U) {
    pHalData->bt_coexist.btActiveZeroCnt = 0U;
    pHalData->bt_coexist.bCurBtDisabled = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("8723A BT is enabled !!\n");
    } else {

    }
  } else {
    pHalData->bt_coexist.btActiveZeroCnt = (u8 )((int )pHalData->bt_coexist.btActiveZeroCnt + 1);
    if (BTCoexDbgLevel == 1U) {
      printk("8723A bt all counters = 0, %d times!!\n", (int )pHalData->bt_coexist.btActiveZeroCnt);
    } else {

    }
    if ((unsigned int )pHalData->bt_coexist.btActiveZeroCnt > 1U) {
      pHalData->bt_coexist.bCurBtDisabled = 1U;
      if (BTCoexDbgLevel == 1U) {
        printk("8723A BT is disabled !!\n");
      } else {

      }
    } else {

    }
  }
  if ((unsigned int )pHalData->bt_coexist.bCurBtDisabled == 0U) {
    tmp = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp != 0U) {
      BTDM_SetFwChnlInfo(padapter, 1);
    } else {
      BTDM_SetFwChnlInfo(padapter, 0);
    }
  } else {

  }
  if ((int )pHalData->bt_coexist.bPreBtDisabled != (int )pHalData->bt_coexist.bCurBtDisabled) {
    if (BTCoexDbgLevel == 1U) {
      printk("8723A BT is from %s to %s!!\n", (unsigned int )pHalData->bt_coexist.bPreBtDisabled != 0U ? (char *)"disabled" : (char *)"enabled",
             (unsigned int )pHalData->bt_coexist.bCurBtDisabled != 0U ? (char *)"disabled" : (char *)"enabled");
    } else {

    }
    pHalData->bt_coexist.bPreBtDisabled = pHalData->bt_coexist.bCurBtDisabled;
  } else {

  }
  return;
}
}
static void btdm_BTCoexist8723AHandler(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 2 Ant mechanism\n");
    } else {

    }
    BTDM_2AntBtCoexist8723A(padapter);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 1 Ant mechanism\n");
    } else {

    }
    BTDM_1AntBtCoexist8723A(padapter);
  }
  tmp___0 = BTDM_IsSameCoexistState(padapter);
  if ((unsigned int )tmp___0 == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Coexist State[bitMap] change from 0x%llx to 0x%llx\n", pHalData->bt_coexist.PreviousState,
             pHalData->bt_coexist.CurrentState);
    } else {

    }
    pHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;
    if (BTCoexDbgLevel == 1U) {
      printk("[");
    } else {

    }
    if ((int )pHalData->bt_coexist.CurrentState & 1) {
      if (BTCoexDbgLevel == 1U) {
        printk("BT 3.0, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 2ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("HT20, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 4ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("HT40, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 8ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Legacy, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 16ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Rssi_Low, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 32ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Rssi_Mid, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 64ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Rssi_High, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 256ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi_Idle, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 512ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi_Uplink, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 1024ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi_Downlink, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 4096ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("BT_idle, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 1048576ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("PRO_HID, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 2097152ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("PRO_A2DP, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 4194304ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("PRO_PAN, ");
      } else {

      }
    } else {

    }
    if ((pHalData->bt_coexist.CurrentState & 8388608ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("PRO_SCO, ");
      } else {

      }
    } else {

    }
    if (BTCoexDbgLevel == 1U) {
      printk("]\n");
    } else {

    }
  } else {

  }
  return;
}
}
u32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 counters ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  counters = 0U;
  counters = pHalData->bt_coexist.halCoex8723.highPriorityTx + pHalData->bt_coexist.halCoex8723.highPriorityRx;
  return (counters);
}
}
u32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 counters ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  counters = 0U;
  counters = pHalData->bt_coexist.halCoex8723.lowPriorityTx + pHalData->bt_coexist.halCoex8723.lowPriorityRx;
  return (counters);
}
}
void BTDM_SetFwChnlInfo(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  u8 chnl ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  u8 tmp___3 ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {

    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )mstatus == 1U) {
    H2C_Parameter[0] = 1U;
  } else {

  }
  tmp___2 = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp___2) {
    chnl = pmlmeext->cur_channel;
    tmp___0 = BTDM_IsHT40(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      if ((unsigned int )pmlmeext->cur_ch_offset == 2U) {
        chnl = (unsigned int )chnl + 254U;
      } else
      if ((unsigned int )pmlmeext->cur_ch_offset == 1U) {
        chnl = (unsigned int )chnl + 2U;
      } else {

      }
    } else {

    }
    H2C_Parameter[1] = chnl;
  } else {
    tmp___1 = BT_Operation(padapter);
    if ((unsigned int )tmp___1 != 0U) {
      H2C_Parameter[1] = pBtMgnt->BTChannel;
    } else {
      H2C_Parameter[1] = pmlmeext->cur_channel;
    }
  }
  tmp___3 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___3 != 0U) {
    H2C_Parameter[2] = 48U;
  } else {
    H2C_Parameter[2] = 32U;
  }
  FillH2CCmd(padapter, 25, 3U, (u8 *)(& H2C_Parameter));
  return;
}
}
u8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter ) 
{ 
  u8 bRet ;
  u8 tmp ;
  bool tmp___0 ;

  {
  bRet = 0U;
  tmp = BTHCI_HsConnectionEstablished(padapter);
  if ((unsigned int )tmp != 0U) {
    bRet = 1U;
  } else {

  }
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp___0) {
    bRet = 1U;
  } else {

  }
  return (bRet);
}
}
void BTDM_SetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 , u8 byte3 ,
                  u8 byte4 , u8 byte5 ) 
{ 
  u8 H2C_Parameter[5U] ;
  unsigned int tmp ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 BtState ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {

    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  tmp___3 = rtl8723a_BT_using_antenna_1(padapter);
  if ((int )tmp___3) {
    tmp___0 = check_fwstate(& padapter->mlmepriv, 8);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      tmp___2 = get_fwstate(& padapter->mlmepriv);
      if (tmp___2 != 0) {
        pHalData = (struct hal_data_8723a *)padapter->HalData;
        pBtCoex = & pHalData->bt_coexist.halCoex8723;
        BtState = pBtCoex->c2hBtInfo;
        if ((unsigned int )BtState != 1U && (unsigned int )BtState != 2U) {
          if (((unsigned long )byte1 & 16UL) != 0UL) {
            byte1 = (unsigned int )byte1 & 239U;
            byte1 = (u8 )((unsigned int )byte1 | 32U);
          } else {

          }
          byte5 = (u8 )((unsigned int )byte5 | 32U);
          if (((unsigned long )byte5 & 64UL) != 0UL) {
            byte5 = (unsigned int )byte5 & 191U;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  H2C_Parameter[0] = byte1;
  H2C_Parameter[1] = byte2;
  H2C_Parameter[2] = byte3;
  H2C_Parameter[3] = byte4;
  H2C_Parameter[4] = byte5;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], FW write 0x3a(5bytes) = 0x%02x%08x\n", (int )H2C_Parameter[0],
           ((((int )H2C_Parameter[1] << 24) | ((int )H2C_Parameter[2] << 16)) | ((int )H2C_Parameter[3] << 8)) | (int )H2C_Parameter[4]);
  } else {

  }
  FillH2CCmd(padapter, 58, 5U, (u8 *)(& H2C_Parameter));
  return;
}
}
void BTDM_QueryBtInformation(struct rtw_adapter *padapter ) 
{ 
  u8 H2C_Parameter[1U] ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  int tmp___0 ;

  {
  H2C_Parameter[0] = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  tmp = rtl8723a_BT_enabled(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    pBtCoex->c2hBtInfo = 0U;
    pBtCoex->bC2hBtInfoReqSent = 0U;
    return;
  } else {

  }
  if ((unsigned int )pBtCoex->c2hBtInfo == 0U) {
    pBtCoex->c2hBtInfo = 1U;
  } else {

  }
  if ((unsigned int )pBtCoex->bC2hBtInfoReqSent == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], didn\'t recv previous BtInfo report!\n");
    } else {

    }
  } else {
    pBtCoex->bC2hBtInfoReqSent = 1U;
  }
  H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 1U);
  FillH2CCmd(padapter, 56, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
void BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )type == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Shrink RF Rx LPF corner!!\n");
    } else {

    }
    PHY_SetRFReg(padapter, 0, 30U, 1048575U, 987127U);
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else
  if ((unsigned int )type == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Resume RF Rx LPF corner!!\n");
    } else {

    }
    PHY_SetRFReg(padapter, 0, 30U, 1048575U, pHalData->bt_coexist.BtRfRegOrigin1E);
  } else {

  }
  return;
}
}
void BTDM_SetSwPenaltyTxRateAdaptive(struct rtw_adapter *padapter , u8 raType ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmpU1 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmpU1 = rtl8723au_read8(padapter, 1277);
  tmpU1 = (u8 )((unsigned int )tmpU1 | 1U);
  if ((unsigned int )raType == 1U) {
    tmpU1 = (unsigned int )tmpU1 & 251U;
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else
  if ((unsigned int )raType == 0U) {
    tmpU1 = (u8 )((unsigned int )tmpU1 | 4U);
  } else {

  }
  rtl8723au_write8(padapter, 1277, (int )tmpU1);
  return;
}
}
void BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[1U] ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  H2C_Parameter[0] = 0U;
  if ((unsigned int )bDecBtPwr != 0U) {
    H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 2U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], decrease Bt Power : %s, write 0x21 = 0x%x\n", (unsigned int )bDecBtPwr != 0U ? (char *)"Yes!!" : (char *)"No!!",
           (int )H2C_Parameter[0]);
  } else {

  }
  FillH2CCmd(padapter, 33, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
u8 BTDM_BtProfileSupport(struct rtw_adapter *padapter ) 
{ 
  u8 bRet ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;

  {
  bRet = 0U;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pBtMgnt->bSupportProfile != 0U && (unsigned int )pHalData->bt_coexist.halCoex8723.bForceFwBtInfo == 0U) {
    bRet = 1U;
  } else {

  }
  return (bRet);
}
}
static void BTDM_AdjustForBtOperation8723A(struct rtw_adapter *padapter ) 
{ 


  {
  return;
}
}
static void BTDM_FwC2hBtRssi8723A(struct rtw_adapter *padapter , u8 *tmpBuf ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 percent ;
  u8 u1tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  percent = 0U;
  u1tmp = 0U;
  u1tmp = *tmpBuf;
  percent = (unsigned int )((u8 )((int )u1tmp + 5)) * 2U;
  pHalData->bt_coexist.halCoex8723.btRssi = percent;
  return;
}
}
void rtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter , u8 *tmpBuf , u8 length ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 i ;
  u8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBtCoex->bC2hBtInfoReqSent = 0U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H], BT info[%d]=[", (int )length);
  } else {

  }
  pBtCoex->btRetryCnt = 0U;
  i = 0U;
  goto ldv_58015;
  ldv_58014: ;
  switch ((int )i) {
  case 0: 
  pBtCoex->c2hBtInfoOriginal = *(tmpBuf + (unsigned long )i);
  goto ldv_58010;
  case 1: 
  pBtCoex->btRetryCnt = *(tmpBuf + (unsigned long )i);
  goto ldv_58010;
  case 2: 
  BTDM_FwC2hBtRssi8723A(padapter, tmpBuf + (unsigned long )i);
  goto ldv_58010;
  case 3: 
  pBtCoex->btInfoExt = (unsigned int )*(tmpBuf + (unsigned long )i) & 1U;
  goto ldv_58010;
  }
  ldv_58010: ;
  if ((int )i == (int )length + -1) {
    if (BTCoexDbgLevel == 1U) {
      printk("0x%02x]\n", (int )*(tmpBuf + (unsigned long )i));
    } else {

    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("0x%02x, ", (int )*(tmpBuf + (unsigned long )i));
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_58015: ;
  if ((int )i < (int )length) {
    goto ldv_58014;
  } else {

  }

  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H], BT RSSI =%d\n", (int )pBtCoex->btRssi);
  } else {

  }
  if ((unsigned int )pBtCoex->btInfoExt != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTC2H], pBtCoex->btInfoExt =%x\n", (int )pBtCoex->btInfoExt);
    } else {

    }
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntFwC2hBtInfo8723A(padapter);
  } else {
    BTDM_2AntFwC2hBtInfo8723A(padapter);
  }
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("%s: Action Manual control!!\n", "rtl8723a_fw_c2h_BT_info");
    } else {

    }
    return;
  } else {

  }
  btdm_BTCoexist8723AHandler(padapter);
  return;
}
}
static void BTDM_Display8723ABtCoexInfo(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 u1Tmp ;
  u8 u1Tmp1 ;
  u8 u1Tmp2 ;
  u8 i ;
  u8 btInfoExt ;
  u8 psTdmaCase ;
  u32 u4Tmp[4U] ;
  u8 antNum ;
  bool tmp ;
  int tmp___0 ;
  s32 tmp___1 ;
  u8 tmp___3 ;
  char *tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___7 ;
  char *tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  psTdmaCase = 0U;
  antNum = 0U;
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n ============[BT Coexist info]============");
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n BT not exists !!!");
    return;
  } else {

  }
  antNum = btdm_BtWifiAntNum(padapter);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d/%d ", (char *)"Ant mechanism PG/Now run :",
           (unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U ? 2 : 1, (unsigned int )antNum == 0U ? 2 : 1);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"[Action Manual control]!!");
  } else {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s / %d", (char *)"BT stack/ hci ext ver",
             (unsigned int )pBtMgnt->bSupportProfile != 0U ? (char *)"Yes" : (char *)"No",
             (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  }
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = / %d", (char *)"Dot11 channel / BT channel",
           (int )pBtMgnt->BTChannel);
  tmp___1 = BTDM_GetRxSS(padapter);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = %d / %d / %d", (char *)"Wifi/BT/HS rssi",
           tmp___1, (int )pHalData->bt_coexist.halCoex8723.btRssi, pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    tmp___5 = BTDM_IsWifiBusy(padapter);
    if ((unsigned int )tmp___5 != 0U) {
      tmp___3 = BTDM_IsWifiUplink(padapter);
      tmp___4 = (unsigned int )tmp___3 != 0U ? (char *)"uplink" : (char *)"downlink";
    } else {
      tmp___4 = (char *)"idle";
    }
    tmp___9 = BTDM_Legacy(padapter);
    if ((unsigned int )tmp___9 == 0U) {
      tmp___7 = BTDM_IsHT40(padapter);
      tmp___8 = (unsigned int )tmp___7 != 0U ? (char *)"HT40" : (char *)"HT20";
    } else {
      tmp___8 = (char *)"Legacy";
    }
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = %s / %s ", (char *)"WIfi status",
             tmp___8, tmp___4);
    if ((unsigned int )pBtMgnt->bSupportProfile != 0U) {
      tmp___10 = BTHCI_CheckProfileExist(padapter, 1);
      tmp___11 = BTHCI_CheckProfileExist(padapter, 2);
      tmp___12 = BTHCI_CheckProfileExist(padapter, 3);
      tmp___13 = BTHCI_CheckProfileExist(padapter, 4);
      snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d / %d / %d",
               (char *)"SCO/HID/PAN/A2DP", (unsigned int )tmp___13 != 0U, (unsigned int )tmp___12 != 0U,
               (unsigned int )tmp___11 != 0U, (unsigned int )tmp___10 != 0U);
      i = 0U;
      goto ldv_58034;
      ldv_58033: ;
      if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer != 0U) {
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s/ %s/ %s", (char *)"Bt link type/spec/role",
                 BtProfileString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile],
                 BtSpecString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec],
                 BtLinkRoleString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole]);
        btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s", (char *)"A2DP rate",
                 (int )btInfoExt & 1 ? (char *)"Basic rate" : (char *)"EDR rate");
      } else {
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s/ %s", (char *)"Bt link type/spec",
                 BtProfileString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile],
                 BtSpecString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec]);
      }
      i = (u8 )((int )i + 1);
      ldv_58034: ;
      if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
        goto ldv_58033;
      } else {

      }

    } else {

    }
  } else {

  }
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Sw BT Coex mechanism]============");
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"AGC Table",
             (int )pBtCoex->btdm2Ant.bCurAgcTableEn);
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"ADC Backoff",
             (int )pBtCoex->btdm2Ant.bCurAdcBackOff);
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"Low penalty RA",
             (int )pBtCoex->btdm2Ant.bCurLowPenaltyRa);
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"RF Rx LPF Shrink",
             (int )pBtCoex->btdm2Ant.bCurRfRxLpfShrink);
  } else {

  }
  u4Tmp[0] = PHY_QueryRFReg(padapter, 0, 30U, 4080U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x", (char *)"RF-A, 0x1e[11:4]/original val",
           u4Tmp[0], pHalData->bt_coexist.BtRfRegOrigin1E);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Fw BT Coex mechanism]============");
  } else {

  }
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    tmp___14 = btdm_BtWifiAntNum(padapter);
    if ((unsigned int )tmp___14 == 1U) {
      psTdmaCase = pHalData->bt_coexist.halCoex8723.btdm1Ant.curPsTdma;
    } else {
      psTdmaCase = pHalData->bt_coexist.halCoex8723.btdm2Ant.curPsTdma;
    }
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d",
             (char *)"PS TDMA(0x3a)", (int )pHalData->bt_coexist.fw3aVal[0], (int )pHalData->bt_coexist.fw3aVal[1],
             (int )pHalData->bt_coexist.fw3aVal[2], (int )pHalData->bt_coexist.fw3aVal[3],
             (int )pHalData->bt_coexist.fw3aVal[4], (int )psTdmaCase);
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"Decrease Bt Power",
             (int )pBtCoex->btdm2Ant.bCurDecBtPwr);
  } else {

  }
  u1Tmp = rtl8723au_read8(padapter, 1912);
  u1Tmp1 = rtl8723au_read8(padapter, 1923);
  u1Tmp2 = rtl8723au_read8(padapter, 1942);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", (char *)"0x778/ 0x783/ 0x796",
           (int )u1Tmp, (int )u1Tmp1, (int )u1Tmp2);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x / 0x%x", (char *)"Sw DacSwing Ctrl/Val",
             (int )pBtCoex->btdm2Ant.bCurDacSwingOn, pBtCoex->btdm2Ant.curDacSwingLvl);
  } else {

  }
  u4Tmp[0] = rtl8723au_read32(padapter, 2176);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x880",
           u4Tmp[0]);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Hw BT Coex mechanism]============");
  } else {

  }
  u1Tmp = rtl8723au_read8(padapter, 64);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x40", (int )u1Tmp);
  u4Tmp[0] = rtl8723au_read32(padapter, 1360);
  u1Tmp = rtl8723au_read8(padapter, 1314);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/0x%x", (char *)"0x550(bcn contrl)/0x522",
           u4Tmp[0], (int )u1Tmp);
  u4Tmp[0] = rtl8723au_read32(padapter, 1156);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x484(rate adaptive)",
           u4Tmp[0]);
  u4Tmp[0] = rtl8723au_read32(padapter, 80);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0xc50(dig)",
           u4Tmp[0]);
  u4Tmp[0] = rtl8723au_read32(padapter, 3488);
  u4Tmp[1] = rtl8723au_read32(padapter, 3492);
  u4Tmp[2] = rtl8723au_read32(padapter, 3496);
  u4Tmp[3] = rtl8723au_read32(padapter, 3500);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
           (char *)"0xda0/0xda4/0xda8/0xdac(FA cnt)", u4Tmp[0], u4Tmp[1], u4Tmp[2],
           u4Tmp[3]);
  u4Tmp[0] = rtl8723au_read32(padapter, 1728);
  u4Tmp[1] = rtl8723au_read32(padapter, 1732);
  u4Tmp[2] = rtl8723au_read32(padapter, 1736);
  u1Tmp = rtl8723au_read8(padapter, 1740);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
           (char *)"0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", u4Tmp[0], u4Tmp[1], u4Tmp[2],
           (int )u1Tmp);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d", (char *)"0x770(Hi pri Rx[31:16]/Tx[15:0])",
           pHalData->bt_coexist.halCoex8723.highPriorityRx, pHalData->bt_coexist.halCoex8723.highPriorityTx);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d", (char *)"0x774(Lo pri Rx[31:16]/Tx[15:0])",
           pHalData->bt_coexist.halCoex8723.lowPriorityRx, pHalData->bt_coexist.halCoex8723.lowPriorityTx);
  u1Tmp = rtl8723au_read8(padapter, 1051);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x41b (hang chk == 0xf)",
           (int )u1Tmp);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"lastHMEBoxNum",
           (int )pHalData->LastHMEBoxNum);
  return;
}
}
static void BTDM_8723ASignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi ,
                                         u8 *rssi_bt ) 
{ 
  u8 tmp ;

  {
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntSignalCompensation(padapter, rssi_wifi, rssi_bt);
  } else {

  }
  return;
}
}
static void BTDM_8723AInit(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    BTDM_2AntParaInit(padapter);
  } else {
    BTDM_1AntParaInit(padapter);
  }
  return;
}
}
static void BTDM_HWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    BTDM_2AntHwCoexAllOff8723A(padapter);
  } else {

  }
  return;
}
}
static void BTDM_FWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    BTDM_2AntFwCoexAllOff8723A(padapter);
  } else {

  }
  return;
}
}
static void BTDM_SWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    BTDM_2AntSwCoexAllOff8723A(padapter);
  } else {

  }
  return;
}
}
static void BTDM_Set8723ABtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  if ((unsigned int )antNum == 1U) {
    pBtCoex->TotalAntNum = 1U;
  } else
  if ((unsigned int )antNum == 2U) {
    pBtCoex->TotalAntNum = 0U;
  } else {

  }
  return;
}
}
void rtl8723a_BT_lps_leave(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntLpsLeave(padapter);
  } else {

  }
  return;
}
}
static void BTDM_ForHalt8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntForHalt(padapter);
  } else {

  }
  return;
}
}
static void BTDM_WifiScanNotify8723A(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntWifiScanNotify(padapter, (int )scanType);
  } else {

  }
  return;
}
}
static void BTDM_WifiAssociateNotify8723A(struct rtw_adapter *padapter , u8 action ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntWifiAssociateNotify(padapter, (int )action);
  } else {

  }
  return;
}
}
static void BTDM_MediaStatusNotify8723A(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], MediaStatusNotify, %s\n", (unsigned int )mstatus != 0U ? (char *)"connect" : (char *)"disconnect");
  } else {

  }
  BTDM_SetFwChnlInfo(padapter, mstatus);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntMediaStatusNotify(padapter, mstatus);
  } else {

  }
  return;
}
}
static void BTDM_ForDhcp8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntForDhcp(padapter);
  } else {

  }
  return;
}
}
bool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    return (1);
  } else {
    return (0);
  }
}
}
static void BTDM_BTCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], beacon RSSI = 0x%x(%d)\n", pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB,
           pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);
  } else {

  }
  btdm_BtHwCountersMonitor(padapter);
  btdm_BtEnableDisableCheck8723A(padapter);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("%s: Action Manual control!!\n", "BTDM_BTCoexist8723A");
    } else {

    }
    return;
  } else {

  }
  if ((unsigned int )pBtCoex->bC2hBtInfoReqSent != 0U) {
    tmp = rtl8723a_BT_enabled(padapter);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      pBtCoex->c2hBtInfo = 0U;
    } else
    if ((unsigned int )pBtCoex->c2hBtInfo == 0U) {
      pBtCoex->c2hBtInfo = 1U;
    } else {

    }
    btdm_BTCoexist8723AHandler(padapter);
  } else {
    tmp___1 = rtl8723a_BT_enabled(padapter);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      pBtCoex->c2hBtInfo = 0U;
      btdm_BTCoexist8723AHandler(padapter);
    } else {

    }
  }
  BTDM_QueryBtInformation(padapter);
  return;
}
}
static void BTDM_SetAntenna(struct rtw_adapter *padapter , u8 who ) 
{ 


  {
  return;
}
}
void BTDM_SingleAnt(struct rtw_adapter *padapter , u8 bSingleAntOn , u8 bInterruptOn ,
                    u8 bMultiNAVOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {

    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 1U) {
    return;
  } else {

  }
  H2C_Parameter[2] = 0U;
  H2C_Parameter[1] = 0U;
  H2C_Parameter[0] = 0U;
  if ((unsigned int )bInterruptOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 2U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
  pHalData->bt_coexist.bInterruptOn = bInterruptOn;
  if ((unsigned int )bSingleAntOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 16U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
  pHalData->bt_coexist.bSingleAntOn = bSingleAntOn;
  if ((unsigned int )bMultiNAVOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 32U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
  pHalData->bt_coexist.bMultiNAVOn = bMultiNAVOn;
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], SingleAntenna =[%s:%s:%s], write 0xe = 0x%x\n", (unsigned int )bSingleAntOn != 0U ? (char *)"ON" : (char *)"OFF",
           (unsigned int )bInterruptOn != 0U ? (char *)"ON" : (char *)"OFF", (unsigned int )bMultiNAVOn != 0U ? (char *)"ON" : (char *)"OFF",
           (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
  return;
}
}
void BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 stateChange ;
  u32 BT_Polling ;
  u32 Ratio_Act ;
  u32 Ratio_STA ;
  u32 BT_Active ;
  u32 BT_State ;
  u32 regBTActive ;
  u32 regBTState ;
  u32 regBTPolling ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  stateChange = 0U;
  regBTActive = 0U;
  regBTState = 0U;
  regBTPolling = 0U;
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {

  }
  if ((unsigned int )pHalData->bt_coexist.BT_CoexistType != 4U) {
    return;
  } else {

  }
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 1U) {
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], FirmwareVersion = 0x%x(%d)\n", (int )pHalData->FirmwareVersion,
           (int )pHalData->FirmwareVersion);
  } else {

  }
  regBTActive = 1092U;
  regBTState = 1096U;
  if ((unsigned int )pHalData->FirmwareVersion > 73U) {
    regBTPolling = 1100U;
  } else {
    regBTPolling = 1792U;
  }
  BT_Active = rtl8723au_read32(padapter, (int )((u16 )regBTActive));
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], BT_Active(0x%x) =%x\n", regBTActive, BT_Active);
  } else {

  }
  BT_Active = BT_Active & 16777215U;
  BT_State = rtl8723au_read32(padapter, (int )((u16 )regBTState));
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], BT_State(0x%x) =%x\n", regBTState, BT_State);
  } else {

  }
  BT_State = BT_State & 16777215U;
  BT_Polling = rtl8723au_read32(padapter, (int )((u16 )regBTPolling));
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], BT_Polling(0x%x) =%x\n", regBTPolling, BT_Polling);
  } else {

  }
  if ((BT_Active == 4294967295U && BT_State == 4294967295U) && BT_Polling == 4294967295U) {
    return;
  } else {

  }
  if (BT_Polling == 0U) {
    return;
  } else {

  }
  Ratio_Act = (BT_Active * 1000U) / BT_Polling;
  Ratio_STA = (BT_State * 1000U) / BT_Polling;
  pHalData->bt_coexist.Ratio_Tx = Ratio_Act;
  pHalData->bt_coexist.Ratio_PRI = Ratio_STA;
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], Ratio_Act =%d\n", Ratio_Act);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], Ratio_STA =%d\n", Ratio_STA);
  } else {

  }
  if (Ratio_STA <= 59U && Ratio_Act <= 499U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32768ULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffdffffULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffff7fffULL;
    if (Ratio_STA != 0U) {
      if (Ratio_Act / Ratio_STA <= 1U) {
        pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 65536ULL;
        pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffdffffULL;
      } else {
        pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
        pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 131072ULL;
      }
    } else {
      pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 0U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
      pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 1U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 131072ULL;
    }
  }
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfSCO == 0U) {
    pBtMgnt->ExtConfig.bBTBusy = 0U;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  } else
  if (Ratio_STA <= 59U) {
    pBtMgnt->ExtConfig.bBTBusy = 0U;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  } else {
    pBtMgnt->ExtConfig.bBTBusy = 1U;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffefffULL;
  }
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfSCO == 0U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffff7ffffULL;
    pBtMgnt->ExtConfig.MIN_BT_RSSI = 0;
    BTDM_SetAntenna(padapter, 0);
  } else
  if ((int )pBtMgnt->ExtConfig.MIN_BT_RSSI < -4) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 524288ULL;
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], core stack notify bt rssi Low\n");
    } else {

    }
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffff7ffffULL;
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], core stack notify bt rssi Normal\n");
    } else {

    }
  }
  if ((int )pHalData->bt_coexist.bBTBusyTraffic != (int )pBtMgnt->ExtConfig.bBTBusy) {
    pHalData->bt_coexist.bBTBusyTraffic = pBtMgnt->ExtConfig.bBTBusy;
    stateChange = 1U;
  } else {

  }
  if ((unsigned int )stateChange != 0U) {
    if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy == 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], BT is idle or disable\n");
      } else {

      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], BT is non-idle\n");
    } else {

    }
  } else {

  }
  if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], BT is idle or disable\n");
    } else {

    }
    tmp___1 = check_fwstate(& padapter->mlmepriv, 2176);
    if ((int )tmp___1) {
      BTDM_SetAntenna(padapter, 1);
    } else {

    }
  } else {

  }
  return;
}
}
void BTDM_DiminishWiFi(struct rtw_adapter *padapter , u8 bDACOn , u8 bInterruptOn ,
                       u8 DACSwingLevel , u8 bNAVOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {

    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 0U) {
    return;
  } else {

  }
  if ((pHalData->bt_coexist.CurrentState & 524288ULL) != 0ULL && (unsigned int )DACSwingLevel == 32U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]DiminishWiFi 0x20 original, but set 0x18 for Low RSSI!\n");
    } else {

    }
    DACSwingLevel = 24U;
  } else {

  }
  H2C_Parameter[2] = 0U;
  H2C_Parameter[1] = DACSwingLevel;
  H2C_Parameter[0] = 0U;
  if ((unsigned int )bDACOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 1U);
    if ((unsigned int )bInterruptOn != 0U) {
      H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 2U);
    } else {

    }
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
  if ((unsigned int )bNAVOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 8U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], bDACOn = %s, bInterruptOn = %s, write 0xe = 0x%x\n", (unsigned int )bDACOn != 0U ? (char *)"ON" : (char *)"OFF",
           (unsigned int )bInterruptOn != 0U ? (char *)"ON" : (char *)"OFF", (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], bNAVOn = %s\n", (unsigned int )bNAVOn != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
  return;
}
}
static void btdm_ResetFWCoexState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->bt_coexist.CurrentState = 0ULL;
  pHalData->bt_coexist.PreviousState = 0ULL;
  return;
}
}
static void btdm_InitBtCoexistDM(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->bt_coexist.BtRfRegOrigin1E = PHY_QueryRFReg(padapter, 0, 30U, 1048575U);
  pHalData->bt_coexist.BtRfRegOrigin1F = PHY_QueryRFReg(padapter, 0, 31U, 240U);
  pHalData->bt_coexist.CurrentState = 0ULL;
  pHalData->bt_coexist.PreviousState = 0ULL;
  BTDM_8723AInit(padapter);
  pHalData->bt_coexist.bInitlized = 1U;
  return;
}
}
void BTDM_CheckAntSelMode(struct rtw_adapter *padapter ) 
{ 


  {
  return;
}
}
void BTDM_FwC2hBtRssi(struct rtw_adapter *padapter , u8 *tmpBuf ) 
{ 


  {
  BTDM_FwC2hBtRssi8723A(padapter, tmpBuf);
  return;
}
}
void BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter ) 
{ 


  {
  BTDM_Display8723ABtCoexInfo(padapter);
  return;
}
}
void BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter , u8 bReject ) 
{ 


  {
  return;
}
}
u8 BTDM_IsHT40(struct rtw_adapter *padapter ) 
{ 
  u8 isht40 ;
  enum ht_channel_width bw ;

  {
  isht40 = 1U;
  bw = (enum ht_channel_width )padapter->mlmeextpriv.cur_bwmode;
  if ((unsigned int )bw == 0U) {
    isht40 = 0U;
  } else
  if ((unsigned int )bw == 1U) {
    isht40 = 1U;
  } else {

  }
  return (isht40);
}
}
u8 BTDM_Legacy(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  u8 isLegacy ;

  {
  isLegacy = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  if (((unsigned int )pmlmeext->cur_wireless_mode == 1U || (unsigned int )pmlmeext->cur_wireless_mode == 2U) || (unsigned int )pmlmeext->cur_wireless_mode == 3U) {
    isLegacy = 1U;
  } else {

  }
  return (isLegacy);
}
}
void BTDM_CheckWiFiState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffeffULL;
    if ((int )pmlmepriv->LinkDetectInfo.bTxBusyTraffic) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 512ULL;
    } else {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffdffULL;
    }
    if ((int )pmlmepriv->LinkDetectInfo.bRxBusyTraffic) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1024ULL;
    } else {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffbffULL;
    }
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 256ULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffdffULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffbffULL;
  }
  tmp___0 = BTDM_Legacy(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8ULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffdULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffbULL;
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffff7ULL;
    tmp = BTDM_IsHT40(padapter);
    if ((unsigned int )tmp != 0U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffdULL;
    } else {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffbULL;
    }
  }
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1ULL;
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffeULL;
  }
  return;
}
}
s32 BTDM_GetRxSS(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  bool tmp ;

  {
  UndecoratedSmoothedPWDB = 0;
  pmlmepriv = & padapter->mlmepriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    UndecoratedSmoothedPWDB = ((struct hal_data_8723a *)padapter->HalData)->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  } else {
    UndecoratedSmoothedPWDB = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_GetRxSS() = %d\n", UndecoratedSmoothedPWDB);
  } else {

  }
  return (UndecoratedSmoothedPWDB);
}
}
static s32 BTDM_GetRxBeaconSS(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  s32 pwdbBeacon ;
  bool tmp ;

  {
  pwdbBeacon = 0;
  pmlmepriv = & padapter->mlmepriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    pwdbBeacon = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_GetRxBeaconSS() = %d\n", pwdbBeacon);
  } else {

  }
  return (pwdbBeacon);
}
}
u8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                              u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 pwdbBeacon ;
  u8 bcnRssiState ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pwdbBeacon = 0;
  bcnRssiState = 0U;
  pwdbBeacon = BTDM_GetRxBeaconSS(padapter);
  if ((unsigned int )levelNum == 2U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 2U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 5U) {
      if ((int )RssiThresh + 6 <= pwdbBeacon) {
        bcnRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 536870912ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state switch to High\n");
        } else {

        }
      } else {
        bcnRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state stay at Low\n");
        } else {

        }
      }
    } else
    if ((int )RssiThresh > pwdbBeacon) {
      bcnRssiState = 2U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 134217728ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON state switch to Low\n");
      } else {

      }
    } else {
      bcnRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON state stay at High\n");
      } else {

      }
    }
  } else
  if ((unsigned int )levelNum == 3U) {
    if ((int )RssiThresh > (int )RssiThresh1) {
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON thresh error!!\n");
      } else {

      }
      return (pHalData->bt_coexist.preRssiStateBeacon);
    } else {

    }
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 2U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 5U) {
      if ((int )RssiThresh + 6 <= pwdbBeacon) {
        bcnRssiState = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 268435456ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state switch to Medium\n");
        } else {

        }
      } else {
        bcnRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state stay at Low\n");
        } else {

        }
      }
    } else
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 1U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 4U) {
      if ((int )RssiThresh1 + 6 <= pwdbBeacon) {
        bcnRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 536870912ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state switch to High\n");
        } else {

        }
      } else
      if ((int )RssiThresh > pwdbBeacon) {
        bcnRssiState = 2U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 134217728ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state switch to Low\n");
        } else {

        }
      } else {
        bcnRssiState = 4U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state stay at Medium\n");
        } else {

        }
      }
    } else
    if ((int )RssiThresh1 > pwdbBeacon) {
      bcnRssiState = 1U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 268435456ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON state switch to Medium\n");
      } else {

      }
    } else {
      bcnRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON state stay at High\n");
      } else {

      }
    }
  } else {

  }
  pHalData->bt_coexist.preRssiStateBeacon = bcnRssiState;
  return (bcnRssiState);
}
}
u8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                            u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  u8 btRssiState ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  UndecoratedSmoothedPWDB = 0;
  btRssiState = 0U;
  UndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);
  if ((unsigned int )levelNum == 2U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 2U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 5U) {
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 67108864ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state switch to High\n");
        } else {

        }
      } else {
        btRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state stay at Low\n");
        } else {

        }
      }
    } else
    if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
      btRssiState = 2U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16777216ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 state switch to Low\n");
      } else {

      }
    } else {
      btRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 state stay at High\n");
      } else {

      }
    }
  } else
  if ((unsigned int )levelNum == 3U) {
    if ((int )RssiThresh > (int )RssiThresh1) {
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 thresh error!!\n");
      } else {

      }
      return (pHalData->bt_coexist.preRssiState1);
    } else {

    }
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 2U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 5U) {
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 33554432ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state switch to Medium\n");
        } else {

        }
      } else {
        btRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state stay at Low\n");
        } else {

        }
      }
    } else
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 1U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 4U) {
      if ((int )RssiThresh1 + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 67108864ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state switch to High\n");
        } else {

        }
      } else
      if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
        btRssiState = 2U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16777216ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state switch to Low\n");
        } else {

        }
      } else {
        btRssiState = 4U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state stay at Medium\n");
        } else {

        }
      }
    } else
    if ((int )RssiThresh1 > UndecoratedSmoothedPWDB) {
      btRssiState = 1U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 33554432ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 state switch to Medium\n");
      } else {

      }
    } else {
      btRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 state stay at High\n");
      } else {

      }
    }
  } else {

  }
  pHalData->bt_coexist.preRssiState1 = btRssiState;
  return (btRssiState);
}
}
u8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                           u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  u8 btRssiState ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  UndecoratedSmoothedPWDB = 0;
  btRssiState = 0U;
  UndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);
  if ((unsigned int )levelNum == 2U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 2U || (unsigned int )pHalData->bt_coexist.preRssiState == 5U) {
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 64ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state switch to High\n");
        } else {

        }
      } else {
        btRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state stay at Low\n");
        } else {

        }
      }
    } else
    if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
      btRssiState = 2U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI state switch to Low\n");
      } else {

      }
    } else {
      btRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI state stay at High\n");
      } else {

      }
    }
  } else
  if ((unsigned int )levelNum == 3U) {
    if ((int )RssiThresh > (int )RssiThresh1) {
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI thresh error!!\n");
      } else {

      }
      return (pHalData->bt_coexist.preRssiState);
    } else {

    }
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 2U || (unsigned int )pHalData->bt_coexist.preRssiState == 5U) {
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state switch to Medium\n");
        } else {

        }
      } else {
        btRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state stay at Low\n");
        } else {

        }
      }
    } else
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 1U || (unsigned int )pHalData->bt_coexist.preRssiState == 4U) {
      if ((int )RssiThresh1 + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 64ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state switch to High\n");
        } else {

        }
      } else
      if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
        btRssiState = 2U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state switch to Low\n");
        } else {

        }
      } else {
        btRssiState = 4U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state stay at Medium\n");
        } else {

        }
      }
    } else
    if ((int )RssiThresh1 > UndecoratedSmoothedPWDB) {
      btRssiState = 1U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI state switch to Medium\n");
      } else {

      }
    } else {
      btRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI state stay at High\n");
      } else {

      }
    }
  } else {

  }
  pHalData->bt_coexist.preRssiState = btRssiState;
  return (btRssiState);
}
}
bool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter ) 
{ 
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 bBtChangeEDCA ;
  u32 EDCA_BT_BE ;
  u32 cur_EDCA_reg ;
  bool bRet ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  bBtChangeEDCA = 0U;
  EDCA_BT_BE = 6202411U;
  bRet = 0;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtMgnt = & pHalData->BtInfo.BtMgnt;
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    bRet = 0;
    pHalData->bt_coexist.lastBtEdca = 0U;
    return (bRet);
  } else {

  }
  if ((unsigned int )pBtMgnt->bSupportProfile == 0U && (unsigned int )pHalData->bt_coexist.BT_CoexistType != 4U) {
    bRet = 0;
    pHalData->bt_coexist.lastBtEdca = 0U;
    return (bRet);
  } else {

  }
  tmp___1 = rtl8723a_BT_using_antenna_1(padapter);
  if ((int )tmp___1) {
    bRet = 0;
    pHalData->bt_coexist.lastBtEdca = 0U;
    return (bRet);
  } else {

  }
  if ((unsigned int )pHalData->bt_coexist.exec_cnt <= 2U) {
    pHalData->bt_coexist.exec_cnt = (u8 )((int )pHalData->bt_coexist.exec_cnt + 1);
  } else {
    pHalData->bt_coexist.bEDCAInitialized = 1U;
  }
  if ((pHalData->bt_coexist.CurrentState & 4096ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("BT state non idle, set bt EDCA\n");
    } else {

    }
    if ((int )pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA) {
      bBtChangeEDCA = 1U;
      pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA = 0;
      pHalData->dmpriv.prv_traffic_idx = 3U;
    } else {

    }
    cur_EDCA_reg = rtl8723au_read32(padapter, 1288);
    if (cur_EDCA_reg != EDCA_BT_BE) {
      bBtChangeEDCA = 1U;
    } else {

    }
    if ((unsigned int )bBtChangeEDCA != 0U || (unsigned int )pHalData->bt_coexist.bEDCAInitialized == 0U) {
      rtl8723au_write32(padapter, 1288, EDCA_BT_BE);
      pHalData->bt_coexist.lastBtEdca = EDCA_BT_BE;
    } else {

    }
    bRet = 1;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("BT state idle, set original EDCA\n");
    } else {

    }
    pHalData->bt_coexist.lastBtEdca = 0U;
    bRet = 0;
  }
  return (bRet);
}
}
void BTDM_Balance(struct rtw_adapter *padapter , u8 bBalanceOn , u8 ms0 , u8 ms1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {

    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )bBalanceOn != 0U) {
    H2C_Parameter[2] = 1U;
    H2C_Parameter[1] = ms1;
    H2C_Parameter[0] = ms0;
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
    H2C_Parameter[2] = 0U;
    H2C_Parameter[1] = 0U;
    H2C_Parameter[0] = 0U;
  }
  pHalData->bt_coexist.bBalanceOn = bBalanceOn;
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], Balance =[%s:%dms:%dms], write 0xc = 0x%x\n", (unsigned int )bBalanceOn != 0U ? (char *)"ON" : (char *)"OFF",
           (int )ms0, (int )ms1, (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
  FillH2CCmd(padapter, 12, 3U, (u8 *)(& H2C_Parameter));
  return;
}
}
void BTDM_AGCTable(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )type == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]AGCTable Off!\n");
    } else {

    }
    rtl8723au_write32(padapter, 3192, 1679556609U);
    rtl8723au_write32(padapter, 3192, 1662844929U);
    rtl8723au_write32(padapter, 3192, 1646133249U);
    rtl8723au_write32(padapter, 3192, 1629421569U);
    rtl8723au_write32(padapter, 3192, 1612709889U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 204800U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 462848U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 720896U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 1032192U);
    PHY_SetRFReg(padapter, 0, 26U, 1048575U, 197461U);
    pHalData->bt_coexist.b8723aAgcTableOn = 0U;
  } else
  if ((unsigned int )type == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]AGCTable On!\n");
    } else {

    }
    rtl8723au_write32(padapter, 3192, 1310457857U);
    rtl8723au_write32(padapter, 3192, 1293746177U);
    rtl8723au_write32(padapter, 3192, 1277034497U);
    rtl8723au_write32(padapter, 3192, 1260322817U);
    rtl8723au_write32(padapter, 3192, 1243611137U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 901120U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 589824U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 331776U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 73728U);
    PHY_SetRFReg(padapter, 0, 26U, 1048575U, 853U);
    pHalData->bt_coexist.b8723aAgcTableOn = 1U;
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {

  }
  return;
}
}
void BTDM_BBBackOffLevel(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )type == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]BBBackOffLevel Off!\n");
    } else {

    }
    rtl8723au_write32(padapter, 3076, 60839441U);
  } else
  if ((unsigned int )type == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]BBBackOffLevel On!\n");
    } else {

    }
    rtl8723au_write32(padapter, 3076, 60847633U);
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {

  }
  return;
}
}
void BTDM_FWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_FWCoexAllOff()\n");
  } else {

  }
  if ((unsigned int )pHalData->bt_coexist.bFWCoexistAllOff != 0U) {
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_FWCoexAllOff(), real Do\n");
  } else {

  }
  BTDM_FWCoexAllOff8723A(padapter);
  pHalData->bt_coexist.bFWCoexistAllOff = 1U;
  return;
}
}
void BTDM_SWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_SWCoexAllOff()\n");
  } else {

  }
  if ((unsigned int )pHalData->bt_coexist.bSWCoexistAllOff != 0U) {
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_SWCoexAllOff(), real Do\n");
  } else {

  }
  BTDM_SWCoexAllOff8723A(padapter);
  pHalData->bt_coexist.bSWCoexistAllOff = 1U;
  return;
}
}
void BTDM_HWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_HWCoexAllOff()\n");
  } else {

  }
  if ((unsigned int )pHalData->bt_coexist.bHWCoexistAllOff != 0U) {
    return;
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_HWCoexAllOff(), real Do\n");
  } else {

  }
  BTDM_HWCoexAllOff8723A(padapter);
  pHalData->bt_coexist.bHWCoexistAllOff = 1U;
  return;
}
}
void BTDM_CoexAllOff(struct rtw_adapter *padapter ) 
{ 


  {
  BTDM_FWCoexAllOff(padapter);
  BTDM_SWCoexAllOff(padapter);
  BTDM_HWCoexAllOff(padapter);
  return;
}
}
void rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *ppwrctrl ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  ppwrctrl = & padapter->pwrctrlpriv;
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  tmp___1 = rtl8723a_BT_using_antenna_1(padapter);
  if ((int )tmp___1) {
    return;
  } else {

  }
  if ((unsigned int )ppwrctrl->reg_rfoff == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT][DM], Before enter IPS, turn off all Coexist DM\n");
    } else {

    }
    btdm_ResetFWCoexState(padapter);
    BTDM_CoexAllOff(padapter);
    BTDM_SetAntenna(padapter, 2);
  } else {

  }
  return;
}
}
void BTDM_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 


  {
  BTDM_8723ASignalCompensation(padapter, rssi_wifi, rssi_bt);
  return;
}
}
void rtl8723a_BT_do_coexist(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  int tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], BT not exists!!\n");
    } else {

    }
    return;
  } else {

  }
  if ((unsigned int )pHalData->bt_coexist.bInitlized == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], btdm_InitBtCoexistDM()\n");
    } else {

    }
    btdm_InitBtCoexistDM(padapter);
  } else {

  }
  if (BTCoexDbgLevel == 1U) {
    printk("\n\n[DM][BT], BTDM start!!\n");
  } else {

  }
  BTDM_PWDBMonitor(padapter);
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], HW type is 8723\n");
  } else {

  }
  BTDM_BTCoexist8723A(padapter);
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], BTDM end!!\n\n");
  } else {

  }
  return;
}
}
void BTDM_UpdateCoexState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = BTDM_IsSameCoexistState(padapter);
  if ((unsigned int )tmp == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Coexist State[bitMap] change from 0x%llx to 0x%llx,  changeBits = 0x%llx\n",
             pHalData->bt_coexist.PreviousState, pHalData->bt_coexist.CurrentState,
             pHalData->bt_coexist.PreviousState ^ pHalData->bt_coexist.CurrentState);
    } else {

    }
    pHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;
  } else {

  }
  return;
}
}
u8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {
    return (1U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], Coexist state changed!!\n");
    } else {

    }
    return (0U);
  }
}
}
void BTDM_PWDBMonitor(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  s32 tmpBTEntryMaxPWDB ;
  s32 tmpBTEntryMinPWDB ;
  u8 i ;
  u32 __i ;
  u8 *ptr ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {

    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  tmpBTEntryMaxPWDB = 0;
  tmpBTEntryMinPWDB = 255;
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
    i = 0U;
    goto ldv_58302;
    ldv_58301: ;
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U) {
      if (pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB < tmpBTEntryMinPWDB) {
        tmpBTEntryMinPWDB = pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      } else {

      }
      if (pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB > tmpBTEntryMaxPWDB) {
        tmpBTEntryMaxPWDB = pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      } else {

      }
      H2C_Parameter[2] = (unsigned char )pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      H2C_Parameter[0] = 63U - (unsigned int )i;
      if (BTCoexDbgLevel == 1U) {
        printk("RSSI report for BT[%d], H2C_Par = 0x%x\n", (int )i, (int )H2C_Parameter[0]);
      } else {

      }
      FillH2CCmd(padapter, 5, 3U, (u8 *)(& H2C_Parameter));
      if (BTCoexDbgLevel == 1U) {
        ptr = (u8 *)(& pBTInfo->BtAsocEntry[(int )i].BTRemoteMACAddr);
        printk("BT_Entry Mac :");
        printk(" ");
        __i = 0U;
        goto ldv_58299;
        ldv_58298: 
        printk("%02X%s", (int )*(ptr + (unsigned long )__i), __i == 5U ? (char *)"" : (char *)"-");
        __i = __i + 1U;
        ldv_58299: ;
        if (__i <= 5U) {
          goto ldv_58298;
        } else {

        }
        printk("\n");
      } else {

      }
      if (BTCoexDbgLevel == 1U) {
        printk("BT rx pwdb[%d] = 0x%x(%d)\n", (int )i, pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB,
               pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB);
      } else {

      }
    } else {

    }
    i = (u8 )((int )i + 1);
    ldv_58302: ;
    if ((unsigned int )i <= 1U) {
      goto ldv_58301;
    } else {

    }

    if (tmpBTEntryMaxPWDB != 0) {
      pHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = tmpBTEntryMaxPWDB;
      if (BTCoexDbgLevel == 1U) {
        printk("BT_EntryMaxPWDB = 0x%x(%d)\n", tmpBTEntryMaxPWDB, tmpBTEntryMaxPWDB);
      } else {

      }
    } else {
      pHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = 0;
    }
    if (tmpBTEntryMinPWDB != 255) {
      pHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = tmpBTEntryMinPWDB;
      if (BTCoexDbgLevel == 1U) {
        printk("BT_EntryMinPWDB = 0x%x(%d)\n", tmpBTEntryMinPWDB, tmpBTEntryMinPWDB);
      } else {

      }
    } else {
      pHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = 0;
    }
  } else {

  }
  return;
}
}
u8 BTDM_IsBTBusy(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsWifiBusy(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtTraffic = & pBTInfo->BtTraffic;
  if (((int )pmlmepriv->LinkDetectInfo.bBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic != 0U) || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {
    return (0U);
  } else {
    return (1U);
  }
}
}
u8 BTDM_IsWifiUplink(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtTraffic = & pBTInfo->BtTraffic;
  if ((int )pmlmepriv->LinkDetectInfo.bTxBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtTraffic = & pBTInfo->BtTraffic;
  if ((int )pmlmepriv->LinkDetectInfo.bRxBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsBTHSMode(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_mgnt *pBtMgnt ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtMgnt = & pHalData->BtInfo.BtMgnt;
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsBTUplink(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsBTDownlink(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
void BTDM_AdjustForBtOperation(struct rtw_adapter *padapter ) 
{ 


  {
  if (BTCoexDbgLevel == 1U) {
    printk("[BT][DM], BTDM_AdjustForBtOperation()\n");
  } else {

  }
  BTDM_AdjustForBtOperation8723A(padapter);
  return;
}
}
void BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) 
{ 


  {
  BTDM_Set8723ABtCoexCurrAntNum(padapter, (int )antNum);
  return;
}
}
void BTDM_ForHalt(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  BTDM_ForHalt8723A(padapter);
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.bInitlized = 0U;
  return;
}
}
void BTDM_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  BTDM_WifiScanNotify8723A(padapter, (int )scanType);
  return;
}
}
void BTDM_WifiAssociateNotify(struct rtw_adapter *padapter , u8 action ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  BTDM_WifiAssociateNotify8723A(padapter, (int )action);
  return;
}
}
void rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  BTDM_MediaStatusNotify8723A(padapter, mstatus);
  return;
}
}
void rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  BTDM_ForDhcp8723A(padapter);
  return;
}
}
void BTDM_ResetActionProfileState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffff0fffffULL;
  return;
}
}
u8 BTDM_IsActionSCO(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 1U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8388608ULL;
      bRet = 1U;
    } else {

    }
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfSCO != 0U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8388608ULL;
    bRet = 1U;
  } else {

  }
  return (bRet);
}
}
u8 BTDM_IsActionHID(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct hal_data_8723a *pHalData ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 2U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1048576ULL;
      bRet = 1U;
    } else {

    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 3);
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1048576ULL;
      bRet = 1U;
    } else {

    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 3U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2097152ULL;
      bRet = 1U;
    } else {

    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 1);
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2097152ULL;
      bRet = 1U;
    } else {

    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionPAN(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 4U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4194304ULL;
      bRet = 1U;
    } else {

    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 2);
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4194304ULL;
      bRet = 1U;
    } else {

    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 5U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 3145728ULL;
      bRet = 1U;
    } else {

    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 3);
    if ((unsigned int )tmp != 0U) {
      tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
      if ((unsigned int )tmp___0 != 0U) {
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 3145728ULL;
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 6U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 5242880ULL;
      bRet = 1U;
    } else {

    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 3);
    if ((unsigned int )tmp != 0U) {
      tmp___0 = BTHCI_CheckProfileExist(padapter, 2);
      if ((unsigned int )tmp___0 != 0U) {
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 5242880ULL;
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 7U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 6291456ULL;
      bRet = 1U;
    } else {

    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 2);
    if ((unsigned int )tmp != 0U) {
      tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
      if ((unsigned int )tmp___0 != 0U) {
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 6291456ULL;
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
  return (bRet);
}
}
bool rtl8723a_BT_enabled(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pHalData->bt_coexist.bCurBtDisabled != 0U) {
    return (0);
  } else {
    return (1);
  }
}
}
static void halbt_InitHwConfig8723A(struct rtw_adapter *padapter ) 
{ 


  {
  return;
}
}
u8 HALBT_GetPGAntNum(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  return (pHalData->bt_coexist.BT_Ant_Num);
}
}
void HALBT_SetKey(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_asoc_entry *pBtAssocEntry ;
  u16 usConfig ;

  {
  usConfig = 0U;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtAssocEntry = (struct bt_asoc_entry *)(& pBTinfo->BtAsocEntry) + (unsigned long )EntryNum;
  pBtAssocEntry->HwCAMIndex = (unsigned int )EntryNum + 12U;
  usConfig = 32784U;
  rtl8723a_cam_write(padapter, (int )pBtAssocEntry->HwCAMIndex, (int )usConfig, (u8 const   *)(& pBtAssocEntry->BTRemoteMACAddr),
                     (u8 const   *)(& pBtAssocEntry->PTK) + 32U);
  return;
}
}
void HALBT_RemoveKey(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_asoc_entry *pBtAssocEntry ;

  {
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtAssocEntry = (struct bt_asoc_entry *)(& pBTinfo->BtAsocEntry) + (unsigned long )EntryNum;
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].HwCAMIndex != 0U) {
    if ((unsigned int )pBtAssocEntry->HwCAMIndex > 11U && (unsigned int )pBtAssocEntry->HwCAMIndex <= 15U) {
      rtl8723a_cam_empty_entry(padapter, (int )pBtAssocEntry->HwCAMIndex);
    } else {

    }
    pBTinfo->BtAsocEntry[(int )EntryNum].HwCAMIndex = 0U;
  } else {

  }
  return;
}
}
void rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  bool tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->bt_coexist.BluetoothCoexist = pHalData->EEPROMBluetoothCoexist;
  pHalData->bt_coexist.BT_Ant_Num = pHalData->EEPROMBluetoothAntNum;
  pHalData->bt_coexist.BT_CoexistType = pHalData->EEPROMBluetoothType;
  pHalData->bt_coexist.BT_Ant_isolation = pHalData->EEPROMBluetoothAntIsolation;
  pHalData->bt_coexist.bt_radiosharedtype = pHalData->EEPROMBluetoothRadioShared;
  if (GlobalDebugLevel23A > 6U) {
    tmp = rtl8723a_BT_coexist(padapter);
    rt_trace(16384, 7, "BT Coexistance = 0x%x\n", (int )tmp);
  } else {

  }
  tmp___0 = rtl8723a_BT_coexist(padapter);
  if ((int )tmp___0) {
    if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U) {
      BTDM_SetBtCoexCurrAntNum(padapter, 2);
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(16384, 7, "BlueTooth BT_Ant_Num = Antx2\n");
      } else {

      }
    } else
    if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 1U) {
      BTDM_SetBtCoexCurrAntNum(padapter, 1);
      if (GlobalDebugLevel23A > 6U) {
        rt_trace(16384, 7, "BlueTooth BT_Ant_Num = Antx1\n");
      } else {

      }
    } else {

    }
    pHalData->bt_coexist.bBTBusyTraffic = 0U;
    pHalData->bt_coexist.bBTTrafficModeSet = 0U;
    pHalData->bt_coexist.bBTNonTrafficModeSet = 0U;
    pHalData->bt_coexist.CurrentState = 0ULL;
    pHalData->bt_coexist.PreviousState = 0ULL;
    if (GlobalDebugLevel23A > 6U) {
      rt_trace(16384, 7, "bt_radiosharedType = 0x%x\n", (int )pHalData->bt_coexist.bt_radiosharedtype);
    } else {

    }
  } else {

  }
  return;
}
}
bool rtl8723a_BT_coexist(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pHalData->bt_coexist.BluetoothCoexist != 0U) {
    return (1);
  } else {
    return (0);
  }
}
}
u8 HALBT_BTChipType(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  return (pHalData->bt_coexist.BT_CoexistType);
}
}
void rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter ) 
{ 


  {
  halbt_InitHwConfig8723A(padapter);
  rtl8723a_BT_do_coexist(padapter);
  return;
}
}
void HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter ) 
{ 


  {
  return;
}
}
void rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct sw_ant_sw *pDM_SWAT_Table ;
  u8 i ;
  u8 btAntNum ;
  u8 tmp ;
  bool tmp___0 ;

  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pDM_Odm = & pHalData->odmpriv;
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
  if ((unsigned int )pHalData->bAntennaDetected == 0U) {
    tmp = HALBT_GetPGAntNum(padapter);
    btAntNum = tmp;
    if ((unsigned int )btAntNum == 0U) {
      pDM_SWAT_Table->ANTB_ON = 1;
    } else
    if ((unsigned int )btAntNum == 1U) {
      pDM_SWAT_Table->ANTB_ON = 0;
    } else {
      pDM_SWAT_Table->ANTB_ON = 1;
    }
    if ((unsigned int )pHalData->CustomerID != 9U) {
      i = 0U;
      goto ldv_58479;
      ldv_58478: 
      tmp___0 = ODM_SingleDualAntennaDetection(& pHalData->odmpriv, 0);
      if ((int )tmp___0) {
        goto ldv_58477;
      } else {

      }
      i = (u8 )((int )i + 1);
      ldv_58479: ;
      if ((unsigned int )i <= 9U) {
        goto ldv_58478;
      } else {

      }
      ldv_58477: ;
      if ((unsigned int )btAntNum == 0U) {
        BTDM_SetBtCoexCurrAntNum(padapter, (int )pDM_SWAT_Table->ANTB_ON ? 2 : 1);
      } else {

      }
    } else {

    }
    pHalData->bAntennaDetected = 1U;
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_763(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_764(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_765(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_766(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_767(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_768(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_769(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_770(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_771(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_772(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_773(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_774(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_775(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_776(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_777(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_778(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_779(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_780(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_781(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_782(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_783(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_11(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_784(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_11(ldv_func_arg1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_811(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_813(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_812(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_815(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_814(struct workqueue_struct *ldv_func_arg1 ) ;
void update_sta_info23a_apmode23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void rtw_set_macaddr_acl23a(struct rtw_adapter *padapter , int mode ) ;
int rtw_acl_add_sta23a(struct rtw_adapter *padapter , u8 *addr ) ;
int rtw_acl_remove_sta23a(struct rtw_adapter *padapter , u8 *addr ) ;
u8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
int rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter , u8 new_ch , u8 ch_offset ) ;
void init_mlme_ap_info23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct lock_class_key __key ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  spinlock_check(& pmlmepriv->bcn_update_lock);
  __raw_spin_lock_init(& pmlmepriv->bcn_update_lock.__annonCompField18.rlock, "&(&pmlmepriv->bcn_update_lock)->rlock",
                       & __key);
  _rtw_init_queue23a(& pacl_list->acl_node_q);
  start_ap_mode23a(padapter);
  return;
}
}
void free_mlme_ap_info23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmepriv->update_bcn = 0U;
  pmlmeext->bstart_bss = 0U;
  rtw_sta_flush23a(padapter);
  pmlmeinfo->state = 0U;
  rtw_free_all_stainfo23a(padapter);
  psta = rtw_get_bcmc_stainfo23a(padapter);
  spin_lock_bh(& pstapriv->sta_hash_lock);
  rtw_free_stainfo23a(padapter, psta);
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return;
}
}
static void update_BCNTIM(struct rtw_adapter *padapter ) 
{ 
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork_mlmeext ;
  unsigned char *pie ;
  u8 *p ;
  u8 *dst_ie ;
  u8 *premainder_ie ;
  u8 *pbackup_remainder_ie ;
  uint offset ;
  uint tmp_len ;
  uint tim_ielen ;
  uint tim_ie_offset ;
  uint remainder_ielen ;
  void *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;

  {
  pstapriv = & padapter->stapriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork_mlmeext = & pmlmeinfo->network;
  pie = (unsigned char *)(& pnetwork_mlmeext->IEs);
  premainder_ie = (u8 *)0U;
  pbackup_remainder_ie = (u8 *)0U;
  p = rtw_get_ie23a(pie, 5, (int *)(& tim_ielen), (int )pnetwork_mlmeext->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && tim_ielen != 0U) {
    tim_ielen = tim_ielen + 2U;
    premainder_ie = p + (unsigned long )tim_ielen;
    tim_ie_offset = (unsigned int )((long )p) - (unsigned int )((long )pie);
    remainder_ielen = (pnetwork_mlmeext->IELength - tim_ie_offset) - tim_ielen;
    dst_ie = p;
  } else {
    tim_ielen = 0U;
    offset = 0U;
    p = rtw_get_ie23a(pie, 0, (int *)(& tmp_len), (int )pnetwork_mlmeext->IELength);
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
      offset = (tmp_len + offset) + 2U;
    } else {

    }
    p = rtw_get_ie23a(pie, 1, (int *)(& tmp_len), (int )pnetwork_mlmeext->IELength);
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
      offset = (tmp_len + offset) + 2U;
    } else {

    }
    offset = offset + 3U;
    premainder_ie = pie + (unsigned long )offset;
    remainder_ielen = (pnetwork_mlmeext->IELength - offset) - tim_ielen;
    dst_ie = pie + (unsigned long )offset;
  }
  if (remainder_ielen != 0U) {
    tmp = kmalloc((size_t )remainder_ielen, 32U);
    pbackup_remainder_ie = (u8 *)tmp;
    if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U) && (unsigned long )premainder_ie != (unsigned long )((u8 *)0U)) {
      memcpy((void *)pbackup_remainder_ie, (void const   *)premainder_ie, (size_t )remainder_ielen);
    } else {

    }
  } else {

  }
  tmp___0 = dst_ie;
  dst_ie = dst_ie + 1;
  *tmp___0 = 5U;
  if (((int )pstapriv->tim_bitmap & 65280) != 0 && ((int )pstapriv->tim_bitmap & 252) != 0) {
    tim_ielen = 5U;
  } else {
    tim_ielen = 4U;
  }
  tmp___1 = dst_ie;
  dst_ie = dst_ie + 1;
  *tmp___1 = (u8 )tim_ielen;
  tmp___2 = dst_ie;
  dst_ie = dst_ie + 1;
  *tmp___2 = 0U;
  tmp___3 = dst_ie;
  dst_ie = dst_ie + 1;
  *tmp___3 = 1U;
  if ((int )pstapriv->tim_bitmap & 1) {
    tmp___4 = dst_ie;
    dst_ie = dst_ie + 1;
    *tmp___4 = 1U;
  } else {
    tmp___5 = dst_ie;
    dst_ie = dst_ie + 1;
    *tmp___5 = 0U;
  }
  if (tim_ielen == 4U) {
    tmp___6 = dst_ie;
    dst_ie = dst_ie + 1;
    *tmp___6 = (u8 )pstapriv->tim_bitmap;
  } else
  if (tim_ielen == 5U) {
    put_unaligned_le16((int )pstapriv->tim_bitmap, (void *)dst_ie);
    dst_ie = dst_ie + 2UL;
  } else {

  }
  if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
    memcpy((void *)dst_ie, (void const   *)pbackup_remainder_ie, (size_t )remainder_ielen);
    kfree((void const   *)pbackup_remainder_ie);
  } else {

  }
  offset = (unsigned int )((long )dst_ie) - (unsigned int )((long )pie);
  pnetwork_mlmeext->IELength = offset + remainder_ielen;
  set_tx_beacon_cmd23a(padapter);
  return;
}
}
static u8 chk_sta_is_alive(struct sta_info *psta ) 
{ 
  u8 ret ;

  {
  ret = 0U;
  if (psta->sta_stats.last_rx_data_pkts + psta->sta_stats.last_rx_ctrl_pkts != psta->sta_stats.rx_data_pkts + psta->sta_stats.rx_ctrl_pkts) {
    ret = 1U;
  } else {

  }
  psta->sta_stats.last_rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts;
  psta->sta_stats.last_rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts;
  psta->sta_stats.last_rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts;
  psta->sta_stats.last_rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts;
  psta->sta_stats.last_rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts;
  psta->sta_stats.last_rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts;
  psta->sta_stats.last_rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts;
  psta->sta_stats.last_rx_data_pkts = psta->sta_stats.rx_data_pkts;
  return (ret);
}
}
void expire_timeout_chk23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 updated ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u8 tmp ;
  struct mlme_ext_priv *pmlmeext ;
  u32 tmp___0 ;
  u8 tmp___1 ;
  u8 backup_oper_channel ;
  struct mlme_ext_priv *pmlmeext___0 ;
  u8 tmp___2 ;
  int ret ;
  int tmp___3 ;

  {
  updated = 0U;
  pstapriv = & padapter->stapriv;
  chk_alive_num = 0U;
  spin_lock_bh(& pstapriv->auth_list_lock);
  phead = & pstapriv->auth_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_55757;
  ldv_55756: 
  __mptr = (struct list_head  const  *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb80UL;
  if (psta->expire_to != 0U) {
    psta->expire_to = psta->expire_to - 1U;
    if (psta->expire_to == 0U) {
      list_del_init(& psta->auth_list);
      pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: auth expire %pM\n", (u8 *)(& psta->hwaddr));
      } else {

      }
      spin_unlock_bh(& pstapriv->auth_list_lock);
      spin_lock_bh(& pstapriv->sta_hash_lock);
      rtw_free_stainfo23a(padapter, psta);
      spin_unlock_bh(& pstapriv->sta_hash_lock);
      spin_lock_bh(& pstapriv->auth_list_lock);
    } else {

    }
  } else {

  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_55757: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55756;
  } else {

  }
  spin_unlock_bh(& pstapriv->auth_list_lock);
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_55765;
  ldv_55764: 
  __mptr___0 = (struct list_head  const  *)plist;
  psta = (struct sta_info *)__mptr___0 + 0xffffffffffffeb90UL;
  tmp = chk_sta_is_alive(psta);
  if ((unsigned int )tmp != 0U || psta->expire_to == 0U) {
    psta->expire_to = pstapriv->expire_to;
    psta->keep_alive_trycnt = 0U;
  } else {
    psta->expire_to = psta->expire_to - 1U;
  }
  if (psta->expire_to == 0U) {
    pmlmeext = & padapter->mlmeextpriv;
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
      psta->expire_to = pstapriv->expire_to;
      goto ldv_55762;
    } else {

    }
    if ((psta->state & 4U) != 0U) {
      if ((psta->state & 1024U) == 0U) {
        psta->expire_to = pstapriv->expire_to;
        psta->state = psta->state | 1024U;
        tmp___0 = CHKBIT(psta->aid);
        pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap | (int )((u16 )tmp___0);
        update_beacon23a(padapter, 5, (u8 *)0U, 0);
        if ((unsigned int )pmlmeext->active_keep_alive_check == 0U) {
          goto ldv_55762;
        } else {

        }
      } else {

      }
    } else {

    }
    if ((unsigned int )pmlmeext->active_keep_alive_check != 0U) {
      tmp___1 = chk_alive_num;
      chk_alive_num = (u8 )((int )chk_alive_num + 1);
      chk_alive_list[(int )tmp___1] = psta;
      goto ldv_55762;
    } else {

    }
    list_del_init(& psta->asoc_list);
    pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: asoc expire %pM, state = 0x%x\n", (u8 *)(& psta->hwaddr),
             psta->state);
    } else {

    }
    updated = ap_free_sta23a(padapter, psta, 0, 3);
  } else
  if (psta->sleepq_len > (unsigned int )(256 / (int )pstapriv->asoc_list_cnt) && padapter->xmitpriv.free_xmitframe_cnt < 128 / (int )pstapriv->asoc_list_cnt) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s sta:%pM, sleepq_len:%u, free_xmitframe_cnt:%u, asoc_list_cnt:%u, clear sleep_q\n",
             "expire_timeout_chk23a", (u8 *)(& psta->hwaddr), psta->sleepq_len, padapter->xmitpriv.free_xmitframe_cnt,
             (int )pstapriv->asoc_list_cnt);
    } else {

    }
    wakeup_sta_to_xmit23a(padapter, psta);
  } else {

  }
  ldv_55762: 
  plist = ptmp;
  ptmp = plist->next;
  ldv_55765: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55764;
  } else {

  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  if ((unsigned int )chk_alive_num != 0U) {
    backup_oper_channel = 0U;
    pmlmeext___0 = & padapter->mlmeextpriv;
    tmp___2 = rtw_get_oper_ch23a(padapter);
    if ((int )tmp___2 != (int )pmlmeext___0->cur_channel) {
      backup_oper_channel = rtw_get_oper_ch23a(padapter);
      SelectChannel23a(padapter, (int )pmlmeext___0->cur_channel);
    } else {

    }
    i = 0;
    goto ldv_55772;
    ldv_55771: 
    ret = 0;
    psta = chk_alive_list[i];
    if ((psta->state & 1U) == 0U) {
      goto ldv_55770;
    } else {

    }
    if ((psta->state & 4U) != 0U) {
      ret = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 1,
                              50);
    } else {
      ret = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 3,
                              50);
    }
    psta->keep_alive_trycnt = (u8 )((int )psta->keep_alive_trycnt + 1);
    if (ret == 1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: asoc check, sta(%pM) is alive\n", (u8 *)(& psta->hwaddr));
      } else {

      }
      psta->expire_to = pstapriv->expire_to;
      psta->keep_alive_trycnt = 0U;
      goto ldv_55770;
    } else
    if ((unsigned int )psta->keep_alive_trycnt <= 3U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: ack check for asoc expire, keep_alive_trycnt =%d\n",
               (int )psta->keep_alive_trycnt);
      } else {

      }
      psta->expire_to = 1U;
      goto ldv_55770;
    } else {

    }
    psta->keep_alive_trycnt = 0U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: asoc expire %pM, state = 0x%x\n", (u8 *)(& psta->hwaddr),
             psta->state);
    } else {

    }
    spin_lock_bh(& pstapriv->asoc_list_lock);
    tmp___3 = list_empty((struct list_head  const  *)(& psta->asoc_list));
    if (tmp___3 == 0) {
      list_del_init(& psta->asoc_list);
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
      updated = ap_free_sta23a(padapter, psta, 0, 3);
    } else {

    }
    spin_unlock_bh(& pstapriv->asoc_list_lock);
    ldv_55770: 
    i = i + 1;
    ldv_55772: ;
    if ((int )chk_alive_num > i) {
      goto ldv_55771;
    } else {

    }

    if ((unsigned int )backup_oper_channel != 0U) {
      SelectChannel23a(padapter, (int )backup_oper_channel);
    } else {

    }
  } else {

  }
  associated_clients_update23a(padapter, (int )updated);
  return;
}
}
void add_RATid23a(struct rtw_adapter *padapter , struct sta_info *psta , u8 rssi_level ) 
{ 
  int i ;
  u8 rf_type ;
  u32 init_rate ;
  unsigned char sta_band ;
  unsigned char raid ;
  unsigned char shortGIrate ;
  unsigned char limit ;
  unsigned int tx_ra_bitmap ;
  struct ht_priv *psta_ht ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_network ;
  int tmp ;
  unsigned char tmp___0 ;
  u8 arg ;

  {
  init_rate = 0U;
  sta_band = 0U;
  shortGIrate = 0U;
  tx_ra_bitmap = 0U;
  psta_ht = (struct ht_priv *)0;
  pmlmepriv = & padapter->mlmepriv;
  pcur_network = & pmlmepriv->cur_network.network;
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    psta_ht = & psta->htpriv;
  } else {
    return;
  }
  if ((psta->state & 1U) == 0U) {
    return;
  } else {

  }
  i = 0;
  goto ldv_55791;
  ldv_55790: ;
  if ((unsigned int )psta->bssrateset[i] != 0U) {
    tmp = rtw_get_bit_value_from_ieee_value23a((int )psta->bssrateset[i] & 127);
    tx_ra_bitmap = (unsigned int )tmp | tx_ra_bitmap;
  } else {

  }
  i = i + 1;
  ldv_55791: ;
  if ((unsigned int )i <= 15U) {
    goto ldv_55790;
  } else {

  }

  if ((int )psta_ht->ht_option) {
    rf_type = rtl8723a_get_rf_type(padapter);
    if ((unsigned int )rf_type == 2U) {
      limit = 16U;
    } else {
      limit = 8U;
    }
    i = 0;
    goto ldv_55794;
    ldv_55793: ;
    if ((int )((unsigned long )psta_ht->ht_cap.mcs.rx_mask[i / 8] >> i % 8) & 1) {
      tx_ra_bitmap = (unsigned int )(1UL << (i + 12)) | tx_ra_bitmap;
    } else {

    }
    i = i + 1;
    ldv_55794: ;
    if ((int )limit > i) {
      goto ldv_55793;
    } else {

    }
    shortGIrate = psta_ht->sgi;
  } else {

  }
  if (pcur_network->DSConfig > 14U) {
    if ((tx_ra_bitmap & 268431360U) != 0U) {
      sta_band = (unsigned int )sta_band | 20U;
    } else {
      sta_band = (unsigned int )sta_band | 4U;
    }
  } else
  if ((tx_ra_bitmap & 268431360U) != 0U) {
    sta_band = (unsigned int )sta_band | 11U;
  } else
  if ((tx_ra_bitmap & 4080U) != 0U) {
    sta_band = (unsigned int )sta_band | 3U;
  } else {
    sta_band = (unsigned int )sta_band | 1U;
  }
  psta->wireless_mode = sta_band;
  raid = networktype_to_raid23a((int )sta_band);
  tmp___0 = get_highest_rate_idx23a(tx_ra_bitmap & 268435455U);
  init_rate = (u32 )tmp___0 & 63U;
  if (psta->aid <= 31U) {
    arg = 0U;
    arg = (unsigned int )((u8 )psta->mac_id) & 31U;
    arg = (u8 )((unsigned int )arg | 128U);
    if ((unsigned int )shortGIrate == 1U) {
      arg = (u8 )((unsigned int )arg | 32U);
    } else {

    }
    tx_ra_bitmap = (unsigned int )((int )raid << 28) | tx_ra_bitmap;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s => mac_id:%d , raid:%d , bitmap = 0x%x, arg = 0x%x\n",
             "add_RATid23a", psta->mac_id, (int )raid, tx_ra_bitmap, (int )arg);
    } else {

    }
    rtl8723a_add_rateatid(padapter, tx_ra_bitmap, (int )arg, (int )rssi_level);
    if ((unsigned int )shortGIrate == 1U) {
      init_rate = init_rate | 64U;
    } else {

    }
    psta->raid = raid;
    psta->init_rate = (u8 )init_rate;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: station aid %d exceed the max number\n", psta->aid);
  } else {

  }
  return;
}
}
static void update_bmc_sta(struct rtw_adapter *padapter ) 
{ 
  u32 init_rate ;
  unsigned char network_type ;
  unsigned char raid ;
  int i ;
  int supportRateNum ;
  unsigned int tx_ra_bitmap ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_network ;
  struct sta_info *psta ;
  struct sta_info *tmp ;
  uint tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char tmp___3 ;
  u8 arg ;

  {
  init_rate = 0U;
  supportRateNum = 0;
  tx_ra_bitmap = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pcur_network = & pmlmepriv->cur_network.network;
  tmp = rtw_get_bcmc_stainfo23a(padapter);
  psta = tmp;
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    psta->aid = 0U;
    psta->mac_id = psta->aid + 1U;
    psta->qos_option = 0U;
    psta->htpriv.ht_option = 0;
    psta->ieee8021x_blocked = 0U;
    memset((void *)(& psta->sta_stats), 0, 168UL);
    tmp___0 = rtw_get_rateset_len23a((u8 *)(& pcur_network->SupportedRates));
    supportRateNum = (int )tmp___0;
    tmp___1 = rtw_check_network_type23a((unsigned char *)(& pcur_network->SupportedRates),
                                        supportRateNum, 1);
    network_type = (unsigned char )tmp___1;
    memcpy((void *)(& psta->bssrateset), (void const   *)(& pcur_network->SupportedRates),
             (size_t )supportRateNum);
    psta->bssratelen = (u32 )supportRateNum;
    i = 0;
    goto ldv_55811;
    ldv_55810: ;
    if ((unsigned int )psta->bssrateset[i] != 0U) {
      tmp___2 = rtw_get_bit_value_from_ieee_value23a((int )psta->bssrateset[i] & 127);
      tx_ra_bitmap = (unsigned int )tmp___2 | tx_ra_bitmap;
    } else {

    }
    i = i + 1;
    ldv_55811: ;
    if (i < supportRateNum) {
      goto ldv_55810;
    } else {

    }

    if (pcur_network->DSConfig > 14U) {
      network_type = 4U;
      tx_ra_bitmap = 336U;
    } else {
      network_type = 1U;
      tx_ra_bitmap = 15U;
    }
    raid = networktype_to_raid23a((int )network_type);
    tmp___3 = get_highest_rate_idx23a(tx_ra_bitmap & 268435455U);
    init_rate = (u32 )tmp___3 & 63U;
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
    arg = 0U;
    arg = (unsigned int )((u8 )psta->mac_id) & 31U;
    arg = (u8 )((unsigned int )arg | 128U);
    tx_ra_bitmap = (unsigned int )((int )raid << 28) | tx_ra_bitmap;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: update_bmc_sta, mask = 0x%x, arg = 0x%x\n", tx_ra_bitmap,
             (int )arg);
    } else {

    }
    rtl8723a_add_rateatid(padapter, tx_ra_bitmap, (int )arg, 0);
    psta->raid = raid;
    psta->init_rate = (u8 )init_rate;
    spin_lock_bh(& psta->lock);
    psta->state = 1U;
    spin_unlock_bh(& psta->lock);
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: add_RATid23a_bmc_sta error!\n");
  } else {

  }
  return;
}
}
void update_sta_info23a_apmode23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct ht_priv *phtpriv_ap ;
  struct ht_priv *phtpriv_sta ;

  {
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmeext = & padapter->mlmeextpriv;
  phtpriv_ap = & pmlmepriv->htpriv;
  phtpriv_sta = & psta->htpriv;
  psta->mac_id = psta->aid + 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_sta_info23a_apmode23a");
  } else {

  }
  rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
  if (psecuritypriv->dot11AuthAlgrthm == 2U) {
    psta->ieee8021x_blocked = 1U;
  } else {
    psta->ieee8021x_blocked = 0U;
  }
  VCS_update23a(padapter, psta);
  if ((int )phtpriv_sta->ht_option) {
    phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
    if ((((int )phtpriv_sta->ht_cap.cap_info & (int )phtpriv_ap->ht_cap.cap_info) & 96) != 0) {
      phtpriv_sta->sgi = 1U;
    } else {

    }
    if ((((int )phtpriv_sta->ht_cap.cap_info & (int )phtpriv_ap->ht_cap.cap_info) & 2) != 0) {
      phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
      phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
    } else {

    }
    psta->qos_option = 1U;
  } else {
    phtpriv_sta->ampdu_enable = 0;
    phtpriv_sta->sgi = 0U;
    phtpriv_sta->bwmode = 0U;
    phtpriv_sta->ch_offset = 0U;
  }
  send_delba23a(padapter, 0, (u8 *)(& psta->hwaddr));
  send_delba23a(padapter, 1, (u8 *)(& psta->hwaddr));
  phtpriv_sta->agg_enable_bitmap = 0U;
  phtpriv_sta->candidate_tid_bitmap = 0U;
  memset((void *)(& psta->sta_stats), 0, 168UL);
  spin_lock_bh(& psta->lock);
  psta->state = psta->state | 1U;
  spin_unlock_bh(& psta->lock);
  return;
}
}
static void update_hw_ht_param(struct rtw_adapter *padapter ) 
{ 
  unsigned char max_AMPDU_len ;
  unsigned char min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_hw_ht_param");
  } else {

  }
  max_AMPDU_len = (unsigned int )pmlmeinfo->ht_cap.ampdu_params_info & 3U;
  min_MPDU_spacing = (unsigned char )(((int )pmlmeinfo->ht_cap.ampdu_params_info & 28) >> 2);
  rtl8723a_set_ampdu_min_space(padapter, (int )min_MPDU_spacing);
  rtl8723a_set_ampdu_factor(padapter, (int )max_AMPDU_len);
  pmlmeinfo->SM_PS = (u8 )(((int )pmlmeinfo->ht_cap.cap_info & 12) >> 2);
  if ((unsigned int )pmlmeinfo->SM_PS == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): WLAN_HT_CAP_SM_PS_STATIC\n", "update_hw_ht_param");
    } else {

    }
  } else {

  }
  return;
}
}
static void start_bss_network(struct rtw_adapter *padapter , u8 *pbuf ) 
{ 
  u8 const   *p ;
  u8 val8 ;
  u8 cur_channel ;
  u8 cur_bwmode ;
  u8 cur_ch_offset ;
  u16 bcn_interval ;
  u32 acparm ;
  struct registry_priv *pregpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct wlan_bssid_ex *pnetwork ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork_mlmeext ;
  struct ieee80211_ht_operation *pht_info ;
  u8 const   *tmp ;
  int tmp___0 ;

  {
  pregpriv = & padapter->registrypriv;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pnetwork = & pmlmepriv->cur_network.network;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork_mlmeext = & pmlmeinfo->network;
  pht_info = (struct ieee80211_ht_operation *)0;
  bcn_interval = pnetwork->beacon_interval;
  cur_channel = (u8 )pnetwork->DSConfig;
  cur_bwmode = 0U;
  cur_ch_offset = 0U;
  tmp = cfg80211_find_vendor_ie(20722U, 4, (u8 const   *)(& pnetwork->IEs), (int )pnetwork->IELength);
  if ((unsigned long )tmp == (unsigned long )((u8 const   *)0U)) {
    pmlmeext->bstart_bss = 1U;
  } else {

  }
  if (pmlmepriv->qos_option != 0U) {
    pmlmeinfo->WMM_enable = 1U;
  } else {

  }
  if ((int )pmlmepriv->htpriv.ht_option) {
    pmlmeinfo->WMM_enable = 1U;
    pmlmeinfo->HT_enable = 1U;
    update_hw_ht_param(padapter);
  } else {

  }
  if (pmlmepriv->cur_network.join_res != 1) {
    if (psecuritypriv->dot11PrivacyAlgrthm != 1027073U && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
      flush_all_cam_entry23a(padapter);
    } else {

    }
  } else {

  }
  rtl8723a_set_media_status(padapter, 3);
  hw_var_set_bssid(padapter, (u8 *)(& pnetwork->MacAddress));
  acparm = 3093015U;
  rtl8723a_set_ac_param_vo(padapter, acparm);
  acparm = 6177559U;
  rtl8723a_set_ac_param_vi(padapter, acparm);
  acparm = 6202411U;
  rtl8723a_set_ac_param_be(padapter, acparm);
  acparm = 42052U;
  rtl8723a_set_ac_param_bk(padapter, acparm);
  val8 = psecuritypriv->dot11AuthAlgrthm == 2U ? 204U : 207U;
  rtl8723a_set_sec_cfg(padapter, (int )val8);
  rtl8723a_set_beacon_interval(padapter, (int )bcn_interval);
  UpdateBrateTbl23a(padapter, (u8 *)(& pnetwork->SupportedRates));
  HalSetBrateCfg23a(padapter, (u8 *)(& pnetwork->SupportedRates));
  if (pmlmepriv->cur_network.join_res == 0) {
    rtl8723a_odm_support_ability_set(padapter, 268435455U);
  } else {

  }
  p = cfg80211_find_ie(61, (u8 const   *)(& pnetwork->IEs), (int )pnetwork->IELength);
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_info = (struct ieee80211_ht_operation *)p + 2U;
    if ((unsigned int )pregpriv->cbw40_enable != 0U && ((int )pht_info->ht_param & 4) != 0) {
      cur_bwmode = 1U;
      switch ((int )pht_info->ht_param & 3) {
      case 1: 
      cur_ch_offset = 1U;
      goto ldv_55852;
      case 3: 
      cur_ch_offset = 2U;
      goto ldv_55852;
      default: 
      cur_ch_offset = 0U;
      goto ldv_55852;
      }
      ldv_55852: ;
    } else {

    }
  } else {

  }
  set_channel_bwmode23a(padapter, (int )cur_channel, (int )cur_ch_offset, (int )cur_bwmode);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: CH =%d, BW =%d, offset =%d\n", (int )cur_channel, (int )cur_bwmode,
           (int )cur_ch_offset);
  } else {

  }
  pmlmeext->cur_channel = cur_channel;
  pmlmeext->cur_bwmode = cur_bwmode;
  pmlmeext->cur_ch_offset = cur_ch_offset;
  pmlmeext->cur_wireless_mode = (unsigned char )pmlmepriv->cur_network.network_type;
  update_wireless_mode23a(padapter);
  update_capinfo23a(padapter, (int )pnetwork->capability);
  memcpy((void *)pnetwork_mlmeext, (void const   *)pnetwork, (size_t )pnetwork->Length);
  if ((unsigned int )pmlmeext->bstart_bss != 0U) {
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
    tmp___0 = send_beacon23a(padapter);
    if (tmp___0 == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: issue_beacon23a, fail!\n");
      } else {

      }
    } else {

    }
  } else {

  }
  update_bmc_sta(padapter);
  return;
}
}
int rtw_check_beacon_data23a(struct rtw_adapter *padapter , struct ieee80211_mgmt *mgmt ,
                             unsigned int len ) 
{ 
  int ret ;
  u8 *p ;
  u8 *pHT_caps_ie ;
  u8 *pHT_info_ie ;
  struct sta_info *psta ;
  u16 ht_cap ;
  uint ie_len ;
  int group_cipher ;
  int pairwise_cipher ;
  u8 channel ;
  u8 network_type ;
  u8 supportRate[16U] ;
  int supportRateNum ;
  u8 WMM_PARA_IE[6U] ;
  struct registry_priv *pregistrypriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pbss_network ;
  u8 *ie ;
  u8 *pbuf ;
  bool tmp ;
  int tmp___0 ;
  u8 *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  u8 rf_type ;
  struct ieee80211_ht_cap *pht_cap ;

  {
  ret = 1;
  pHT_caps_ie = (u8 *)0U;
  pHT_info_ie = (u8 *)0U;
  psta = (struct sta_info *)0;
  ht_cap = 0U;
  ie_len = 0U;
  supportRateNum = 0;
  WMM_PARA_IE[0] = 0U;
  WMM_PARA_IE[1] = 80U;
  WMM_PARA_IE[2] = 242U;
  WMM_PARA_IE[3] = 2U;
  WMM_PARA_IE[4] = 1U;
  WMM_PARA_IE[5] = 1U;
  pregistrypriv = & padapter->registrypriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmepriv = & padapter->mlmepriv;
  pbss_network = & pmlmepriv->cur_network.network;
  ie = (u8 *)(& pbss_network->IEs);
  pbuf = (u8 *)(& mgmt->u.beacon.variable);
  len = len - 36U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, len =%d\n", "rtw_check_beacon_data23a", len);
  } else {

  }
  tmp = check_fwstate(pmlmepriv, 16);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  if (len > 768U) {
    return (0);
  } else {

  }
  pbss_network->IELength = len;
  memset((void *)ie, 0, 768UL);
  memcpy((void *)ie, (void const   *)pbuf, (size_t )pbss_network->IELength);
  if ((unsigned int )pbss_network->ifmode != 3U && (unsigned int )pbss_network->ifmode != 9U) {
    return (0);
  } else {

  }
  pbss_network->Rssi = 0L;
  tmp___1 = myid(& padapter->eeprompriv);
  memcpy((void *)(& pbss_network->MacAddress), (void const   *)tmp___1, 6UL);
  p = rtw_get_ie23a(ie, 0, (int *)(& ie_len), (int )pbss_network->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    memset((void *)(& pbss_network->Ssid), 0, 33UL);
    memcpy((void *)(& pbss_network->Ssid.ssid), (void const   *)p + 2U, (size_t )ie_len);
    pbss_network->Ssid.ssid_len = (u8 )ie_len;
  } else {

  }
  channel = 0U;
  p = rtw_get_ie23a(ie, 3, (int *)(& ie_len), (int )pbss_network->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    channel = *(p + 2UL);
  } else {

  }
  pbss_network->DSConfig = (u32 )channel;
  memset((void *)(& supportRate), 0, 16UL);
  p = rtw_get_ie23a(ie, 1, (int *)(& ie_len), (int )pbss_network->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
    memcpy((void *)(& supportRate), (void const   *)p + 2U, (size_t )ie_len);
    supportRateNum = (int )ie_len;
  } else {

  }
  p = rtw_get_ie23a(ie, 50, (int *)(& ie_len), (int )pbss_network->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
    memcpy((void *)(& supportRate) + (unsigned long )supportRateNum, (void const   *)p + 2U,
             (size_t )ie_len);
    supportRateNum = (int )((uint )supportRateNum + ie_len);
  } else {

  }
  tmp___2 = rtw_check_network_type23a((unsigned char *)(& supportRate), supportRateNum,
                                      (int )channel);
  network_type = (u8 )tmp___2;
  rtw_set_supported_rate23a((u8 *)(& pbss_network->SupportedRates), (uint )network_type);
  p = rtw_get_ie23a(ie, 42, (int *)(& ie_len), (int )pbss_network->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    ERP_IE_handler23a(padapter, (u8 const   *)p);
  } else {

  }
  if (((unsigned long )pbss_network->capability & 16UL) != 0UL) {
    pbss_network->Privacy = 1U;
  } else {
    pbss_network->Privacy = 0U;
  }
  psecuritypriv->wpa_psk = 0U;
  group_cipher = 0;
  pairwise_cipher = 0;
  psecuritypriv->wpa2_group_cipher = 0U;
  psecuritypriv->wpa2_pairwise_cipher = 0U;
  p = rtw_get_ie23a(ie, 48, (int *)(& ie_len), (int )pbss_network->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    tmp___3 = rtw_parse_wpa2_ie23a((u8 const   *)p, (int )(ie_len + 2U), & group_cipher,
                                   & pairwise_cipher, (int *)0);
    if (tmp___3 == 1) {
      psecuritypriv->dot11AuthAlgrthm = 2U;
      psecuritypriv->dot8021xalg = 1U;
      psecuritypriv->wpa_psk = psecuritypriv->wpa_psk | 2U;
      psecuritypriv->wpa2_group_cipher = (unsigned int )group_cipher;
      psecuritypriv->wpa2_pairwise_cipher = (unsigned int )pairwise_cipher;
    } else {

    }
  } else {

  }
  ie_len = 0U;
  group_cipher = 0;
  pairwise_cipher = 0;
  psecuritypriv->wpa_group_cipher = 0U;
  psecuritypriv->wpa_pairwise_cipher = 0U;
  p = ie;
  ldv_55882: 
  p = rtw_get_ie23a(p, 221, (int *)(& ie_len), (int )((pbss_network->IELength - ie_len) - 2U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
    tmp___5 = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                     4UL);
    if (tmp___5 == 0) {
      tmp___4 = rtw_parse_wpa_ie23a((u8 const   *)p, (int )(ie_len + 2U), & group_cipher,
                                    & pairwise_cipher, (int *)0);
      if (tmp___4 == 1) {
        psecuritypriv->dot11AuthAlgrthm = 2U;
        psecuritypriv->dot8021xalg = 1U;
        psecuritypriv->wpa_psk = psecuritypriv->wpa_psk | 1U;
        psecuritypriv->wpa_group_cipher = (unsigned int )group_cipher;
        psecuritypriv->wpa_pairwise_cipher = (unsigned int )pairwise_cipher;
      } else {

      }
      goto ldv_55881;
    } else {

    }
  } else {

  }
  if ((unsigned long )p == (unsigned long )((u8 *)0U) || ie_len == 0U) {
    goto ldv_55881;
  } else {

  }
  p = p + (unsigned long )(ie_len + 2U);
  goto ldv_55882;
  ldv_55881: 
  ie_len = 0U;
  pmlmepriv->qos_option = 0U;
  if ((unsigned int )pregistrypriv->wmm_enable != 0U) {
    p = ie;
    ldv_55884: 
    p = rtw_get_ie23a(p, 221, (int *)(& ie_len), (int )((pbss_network->IELength - ie_len) - 2U));
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
      tmp___6 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_PARA_IE), 6UL);
      if (tmp___6 == 0) {
        pmlmepriv->qos_option = 1U;
        *(p + 8UL) = (u8 )((unsigned int )*(p + 8UL) | 128U);
        *(p + 10UL) = (unsigned int )*(p + 10UL) & 239U;
        *(p + 14UL) = (unsigned int )*(p + 14UL) & 239U;
        *(p + 18UL) = (unsigned int )*(p + 18UL) & 239U;
        *(p + 22UL) = (unsigned int )*(p + 22UL) & 239U;
        goto ldv_55883;
      } else {

      }
    } else {

    }
    if ((unsigned long )p == (unsigned long )((u8 *)0U) || ie_len == 0U) {
      goto ldv_55883;
    } else {

    }
    p = p + (unsigned long )(ie_len + 2U);
    goto ldv_55884;
    ldv_55883: ;
  } else {

  }
  p = rtw_get_ie23a(ie, 45, (int *)(& ie_len), (int )pbss_network->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    pht_cap = (struct ieee80211_ht_cap *)p + 2U;
    pHT_caps_ie = p;
    ht_cap = 1U;
    network_type = (u8 )((unsigned int )network_type | 8U);
    rf_type = rtl8723a_get_rf_type(padapter);
    if (((unsigned long )psecuritypriv->wpa_pairwise_cipher & 16UL) != 0UL || ((unsigned long )psecuritypriv->wpa2_pairwise_cipher & 16UL) != 0UL) {
      pht_cap->ampdu_params_info = (u8 )((unsigned int )pht_cap->ampdu_params_info | 28U);
    } else {
      pht_cap->ampdu_params_info = pht_cap->ampdu_params_info;
    }
    pht_cap->ampdu_params_info = (u8 )((unsigned int )pht_cap->ampdu_params_info | 3U);
    if ((unsigned int )rf_type == 3U) {
      pht_cap->mcs.rx_mask[0] = 255U;
      pht_cap->mcs.rx_mask[1] = 0U;
    } else {

    }
    memcpy((void *)(& pmlmepriv->htpriv.ht_cap), (void const   *)p + 2U, (size_t )ie_len);
  } else {

  }
  p = rtw_get_ie23a(ie, 61, (int *)(& ie_len), (int )pbss_network->IELength);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    pHT_info_ie = p;
  } else {

  }
  pmlmepriv->cur_network.network_type = (int )network_type;
  pmlmepriv->htpriv.ht_option = 0;
  if ((unsigned int )pregistrypriv->ht_enable != 0U && (unsigned int )ht_cap != 0U) {
    pmlmepriv->htpriv.ht_option = 1;
    pmlmepriv->qos_option = 1U;
    if ((unsigned int )pregistrypriv->ampdu_enable == 1U) {
      pmlmepriv->htpriv.ampdu_enable = 1;
    } else {

    }
    HT_caps_handler23a(padapter, (u8 const   *)pHT_caps_ie);
    HT_info_handler23a(padapter, (u8 const   *)pHT_info_ie);
  } else {

  }
  pbss_network->Length = get_wlan_bssid_ex_sz(pbss_network);
  start_bss_network(padapter, (u8 *)pbss_network);
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pbss_network->MacAddress));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    psta = rtw_alloc_stainfo23a(& padapter->stapriv, (u8 const   *)(& pbss_network->MacAddress),
                                208U);
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
      return (0);
    } else {

    }
  } else {

  }
  psta->state = psta->state | 16U;
  rtw_indicate_connect23a(padapter);
  pmlmepriv->cur_network.join_res = 1;
  return (ret);
}
}
void rtw_set_macaddr_acl23a(struct rtw_adapter *padapter , int mode ) 
{ 
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;

  {
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, mode =%d\n", "rtw_set_macaddr_acl23a", mode);
  } else {

  }
  pacl_list->mode = mode;
  return;
}
}
int rtw_acl_add_sta23a(struct rtw_adapter *padapter , u8 *addr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  u8 added ;
  int i ;
  int ret ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head *tmp___0 ;

  {
  added = 0U;
  ret = 0;
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  pacl_node_q = & pacl_list->acl_node_q;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(acl_num =%d) =%pM\n", "rtw_acl_add_sta23a", pacl_list->num,
           addr);
  } else {

  }
  if (pacl_list->num > 15) {
    return (-1);
  } else {

  }
  spin_lock_bh(& pacl_node_q->lock);
  phead = get_list_head(pacl_node_q);
  plist = phead->next;
  goto ldv_55912;
  ldv_55911: 
  __mptr = (struct list_head  const  *)plist;
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
  tmp = memcmp((void const   *)(& paclnode->addr), (void const   *)addr, 6UL);
  if (tmp == 0) {
    if ((unsigned int )paclnode->valid == 1U) {
      added = 1U;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s, sta has been added\n", "rtw_acl_add_sta23a");
      } else {

      }
      goto ldv_55910;
    } else {

    }
  } else {

  }
  plist = plist->next;
  ldv_55912: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55911;
  } else {

  }
  ldv_55910: 
  spin_unlock_bh(& pacl_node_q->lock);
  if ((unsigned int )added != 0U) {
    return (ret);
  } else {

  }
  spin_lock_bh(& pacl_node_q->lock);
  i = 0;
  goto ldv_55915;
  ldv_55914: 
  paclnode = (struct rtw_wlan_acl_node *)(& pacl_list->aclnode) + (unsigned long )i;
  if ((unsigned int )paclnode->valid == 0U) {
    INIT_LIST_HEAD(& paclnode->list);
    memcpy((void *)(& paclnode->addr), (void const   *)addr, 6UL);
    paclnode->valid = 1U;
    tmp___0 = get_list_head(pacl_node_q);
    list_add_tail(& paclnode->list, tmp___0);
    pacl_list->num = pacl_list->num + 1;
    goto ldv_55913;
  } else {

  }
  i = i + 1;
  ldv_55915: ;
  if (i <= 15) {
    goto ldv_55914;
  } else {

  }
  ldv_55913: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, acl_num =%d\n", "rtw_acl_add_sta23a", pacl_list->num);
  } else {

  }
  spin_unlock_bh(& pacl_node_q->lock);
  return (ret);
}
}
int rtw_acl_remove_sta23a(struct rtw_adapter *padapter , u8 *addr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  pacl_node_q = & pacl_list->acl_node_q;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(acl_num =%d) = %pM\n", "rtw_acl_remove_sta23a", pacl_list->num,
           addr);
  } else {

  }
  spin_lock_bh(& pacl_node_q->lock);
  phead = get_list_head(pacl_node_q);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_55931;
  ldv_55930: 
  __mptr = (struct list_head  const  *)plist;
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
  tmp = memcmp((void const   *)(& paclnode->addr), (void const   *)addr, 6UL);
  if (tmp == 0) {
    if ((unsigned int )paclnode->valid != 0U) {
      paclnode->valid = 0U;
      list_del_init(& paclnode->list);
      pacl_list->num = pacl_list->num - 1;
    } else {

    }
  } else {

  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_55931: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55930;
  } else {

  }
  spin_unlock_bh(& pacl_node_q->lock);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, acl_num =%d\n", "rtw_acl_remove_sta23a", pacl_list->num);
  } else {

  }
  return (0);
}
}
static void update_bcn_fixed_ie(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_fixed_ie");
  } else {

  }
  return;
}
}
static void update_bcn_erpinfo_ie(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  unsigned char *p ;
  unsigned char *ie ;
  u32 len ;
  u8 *tmp ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  ie = (unsigned char *)(& pnetwork->IEs);
  len = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ERP_enable =%d\n", "update_bcn_erpinfo_ie", (int )pmlmeinfo->ERP_enable);
  } else {

  }
  if ((unsigned int )pmlmeinfo->ERP_enable == 0U) {
    return;
  } else {

  }
  tmp = rtw_get_ie23a(ie, 42, (int *)(& len), (int )pnetwork->IELength);
  p = tmp;
  if ((unsigned long )p != (unsigned long )((unsigned char *)0U) && len != 0U) {
    if (pmlmepriv->num_sta_non_erp == 1) {
      *(p + 2UL) = (unsigned int )*(p + 2UL) | 3U;
    } else {
      *(p + 2UL) = (unsigned int )*(p + 2UL) & 252U;
    }
    if (pmlmepriv->num_sta_no_short_preamble > 0) {
      *(p + 2UL) = (unsigned int )*(p + 2UL) | 4U;
    } else {
      *(p + 2UL) = (unsigned int )*(p + 2UL) & 251U;
    }
    ERP_IE_handler23a(padapter, (u8 const   *)p);
  } else {

  }
  return;
}
}
static void update_bcn_htcap_ie(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_htcap_ie");
  } else {

  }
  return;
}
}
static void update_bcn_htinfo_ie(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_htinfo_ie");
  } else {

  }
  return;
}
}
static void update_bcn_rsn_ie(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_rsn_ie");
  } else {

  }
  return;
}
}
static void update_bcn_wpa_ie(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_wpa_ie");
  } else {

  }
  return;
}
}
static void update_bcn_wmm_ie(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_wmm_ie");
  } else {

  }
  return;
}
}
static void update_bcn_wps_ie(struct rtw_adapter *padapter ) 
{ 


  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_wps_ie");
  } else {

  }
  return;
}
}
static void update_bcn_p2p_ie(struct rtw_adapter *padapter ) 
{ 


  {
  return;
}
}
static void update_bcn_vendor_spec_ie(struct rtw_adapter *padapter , u8 *oui ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_vendor_spec_ie");
  } else {

  }
  tmp___2 = memcmp((void const   *)(& RTW_WPA_OUI23A_TYPE), (void const   *)oui, 4UL);
  if (tmp___2 == 0) {
    update_bcn_wpa_ie(padapter);
  } else {
    tmp___1 = memcmp((void const   *)(& WMM_OUI23A), (void const   *)oui, 4UL);
    if (tmp___1 == 0) {
      update_bcn_wmm_ie(padapter);
    } else {
      tmp___0 = memcmp((void const   *)(& WPS_OUI23A), (void const   *)oui, 4UL);
      if (tmp___0 == 0) {
        update_bcn_wps_ie(padapter);
      } else {
        tmp = memcmp((void const   *)(& P2P_OUI23A), (void const   *)oui, 4UL);
        if (tmp == 0) {
          update_bcn_p2p_ie(padapter);
        } else
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: unknown OUI type!\n");
        } else {

        }
      }
    }
  }
  return;
}
}
void update_beacon23a(struct rtw_adapter *padapter , u8 ie_id , u8 *oui , u8 tx ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;

  {
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {

  }
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned int )pmlmeext->bstart_bss == 0U) {
    return;
  } else {

  }
  spin_lock_bh(& pmlmepriv->bcn_update_lock);
  switch ((int )ie_id) {
  case 255: 
  update_bcn_fixed_ie(padapter);
  goto ldv_55989;
  case 5: 
  update_BCNTIM(padapter);
  goto ldv_55989;
  case 42: 
  update_bcn_erpinfo_ie(padapter);
  goto ldv_55989;
  case 45: 
  update_bcn_htcap_ie(padapter);
  goto ldv_55989;
  case 48: 
  update_bcn_rsn_ie(padapter);
  goto ldv_55989;
  case 61: 
  update_bcn_htinfo_ie(padapter);
  goto ldv_55989;
  case 221: 
  update_bcn_vendor_spec_ie(padapter, oui);
  goto ldv_55989;
  default: ;
  goto ldv_55989;
  }
  ldv_55989: 
  pmlmepriv->update_bcn = 1U;
  spin_unlock_bh(& pmlmepriv->bcn_update_lock);
  if ((unsigned int )tx != 0U) {
    set_tx_beacon_cmd23a(padapter);
  } else {

  }
  return;
}
}
static int rtw_ht_operation_update(struct rtw_adapter *padapter ) 
{ 
  u16 cur_op_mode ;
  u16 new_op_mode ;
  int op_mode_changes ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv_ap ;

  {
  op_mode_changes = 0;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv_ap = & pmlmepriv->htpriv;
  if ((int )pmlmepriv->htpriv.ht_option) {
    return (0);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s current operation mode = 0x%X\n", "rtw_ht_operation_update",
           (int )pmlmepriv->ht_op_mode);
  } else {

  }
  if (((int )pmlmepriv->ht_op_mode & 4) == 0 && pmlmepriv->num_sta_ht_no_gf != 0) {
    pmlmepriv->ht_op_mode = (u16 )((unsigned int )pmlmepriv->ht_op_mode | 4U);
    op_mode_changes = op_mode_changes + 1;
  } else
  if (((int )pmlmepriv->ht_op_mode & 4) != 0 && pmlmepriv->num_sta_ht_no_gf == 0) {
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65531U;
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
  if (((int )pmlmepriv->ht_op_mode & 16) == 0 && (pmlmepriv->num_sta_no_ht != 0 || pmlmepriv->olbc_ht != 0)) {
    pmlmepriv->ht_op_mode = (u16 )((unsigned int )pmlmepriv->ht_op_mode | 16U);
    op_mode_changes = op_mode_changes + 1;
  } else
  if (((int )pmlmepriv->ht_op_mode & 16) != 0 && (pmlmepriv->num_sta_no_ht == 0 && pmlmepriv->olbc_ht == 0)) {
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65519U;
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
  if (pmlmepriv->num_sta_no_ht != 0 || ((int )pmlmepriv->ht_op_mode & 4) != 0) {
    new_op_mode = 3U;
  } else
  if (((int )phtpriv_ap->ht_cap.cap_info & 2) != 0 && pmlmepriv->num_sta_ht_20mhz != 0) {
    new_op_mode = 2U;
  } else
  if (pmlmepriv->olbc_ht != 0) {
    new_op_mode = 1U;
  } else {
    new_op_mode = 0U;
  }
  cur_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 3U;
  if ((int )cur_op_mode != (int )new_op_mode) {
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65532U;
    pmlmepriv->ht_op_mode = (u16 )((int )pmlmepriv->ht_op_mode | (int )new_op_mode);
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s new operation mode = 0x%X changes =%d\n", "rtw_ht_operation_update",
           (int )pmlmepriv->ht_op_mode, op_mode_changes);
  } else {

  }
  return (op_mode_changes);
}
}
void associated_clients_update23a(struct rtw_adapter *padapter , u8 updated ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct list_head  const  *__mptr ;

  {
  if ((unsigned int )updated == 1U) {
    pstapriv = & padapter->stapriv;
    spin_lock_bh(& pstapriv->asoc_list_lock);
    phead = & pstapriv->asoc_list;
    plist = phead->next;
    ptmp = plist->next;
    goto ldv_56018;
    ldv_56017: 
    __mptr = (struct list_head  const  *)plist;
    psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
    VCS_update23a(padapter, psta);
    plist = ptmp;
    ptmp = plist->next;
    ldv_56018: ;
    if ((unsigned long )plist != (unsigned long )phead) {
      goto ldv_56017;
    } else {

    }
    spin_unlock_bh(& pstapriv->asoc_list_lock);
  } else {

  }
  return;
}
}
void bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 beacon_updated ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  u16 ht_capab ;
  int tmp ;

  {
  beacon_updated = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  if (((unsigned long )psta->flags & 128UL) == 0UL) {
    if ((unsigned int )psta->no_short_preamble_set == 0U) {
      psta->no_short_preamble_set = 1U;
      pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble + 1;
      if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 1) {
        beacon_updated = 1U;
        update_beacon23a(padapter, 255, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
  if ((unsigned int )psta->no_short_preamble_set != 0U) {
    psta->no_short_preamble_set = 0U;
    pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble - 1;
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
  if (psta->flags < 0) {
    if ((unsigned int )psta->nonerp_set == 0U) {
      psta->nonerp_set = 1U;
      pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp + 1;
      if (pmlmepriv->num_sta_non_erp == 1) {
        beacon_updated = 1U;
        update_beacon23a(padapter, 42, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
  if ((unsigned int )psta->nonerp_set != 0U) {
    psta->nonerp_set = 0U;
    pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp - 1;
    if (pmlmepriv->num_sta_non_erp == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 42, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
  if (((int )psta->capability & 1024) == 0) {
    if ((unsigned int )psta->no_short_slot_time_set == 0U) {
      psta->no_short_slot_time_set = 1U;
      pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time + 1;
      if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 1) {
        beacon_updated = 1U;
        update_beacon23a(padapter, 255, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
  if ((unsigned int )psta->no_short_slot_time_set != 0U) {
    psta->no_short_slot_time_set = 0U;
    pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time - 1;
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
  if (((unsigned long )psta->flags & 2048UL) != 0UL) {
    ht_capab = psta->htpriv.ht_cap.cap_info;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: HT: STA %pM HT Capabilities Info: 0x%04x\n", (u8 *)(& psta->hwaddr),
             (int )ht_capab);
    } else {

    }
    if ((unsigned int )psta->no_ht_set != 0U) {
      psta->no_ht_set = 0U;
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht - 1;
    } else {

    }
    if (((int )ht_capab & 16) == 0) {
      if ((unsigned int )psta->no_ht_gf_set == 0U) {
        psta->no_ht_gf_set = 1U;
        pmlmepriv->num_sta_ht_no_gf = pmlmepriv->num_sta_ht_no_gf + 1;
      } else {

      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s STA %pM - no greenfield, num of non-gf stations %d\n",
               "bss_cap_update_on_sta_join23a", (u8 *)(& psta->hwaddr), pmlmepriv->num_sta_ht_no_gf);
      } else {

      }
    } else {

    }
    if (((int )ht_capab & 2) == 0) {
      if ((unsigned int )psta->ht_20mhz_set == 0U) {
        psta->ht_20mhz_set = 1U;
        pmlmepriv->num_sta_ht_20mhz = pmlmepriv->num_sta_ht_20mhz + 1;
      } else {

      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s STA %pM - 20 MHz HT, num of 20MHz HT STAs %d\n",
               "bss_cap_update_on_sta_join23a", (u8 *)(& psta->hwaddr), pmlmepriv->num_sta_ht_20mhz);
      } else {

      }
    } else {

    }
  } else {
    if ((unsigned int )psta->no_ht_set == 0U) {
      psta->no_ht_set = 1U;
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht + 1;
    } else {

    }
    if ((int )pmlmepriv->htpriv.ht_option) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s STA %pM - no HT, num of non-HT stations %d\n", "bss_cap_update_on_sta_join23a",
               (u8 *)(& psta->hwaddr), pmlmepriv->num_sta_no_ht);
      } else {

      }
    } else {

    }
  }
  tmp = rtw_ht_operation_update(padapter);
  if (tmp > 0) {
    update_beacon23a(padapter, 45, (u8 *)0U, 0);
    update_beacon23a(padapter, 61, (u8 *)0U, 1);
  } else {

  }
  associated_clients_update23a(padapter, (int )beacon_updated);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, updated =%d\n", "bss_cap_update_on_sta_join23a", (int )beacon_updated);
  } else {

  }
  return;
}
}
u8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 beacon_updated ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;

  {
  beacon_updated = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (beacon_updated);
  } else {

  }
  if ((unsigned int )psta->no_short_preamble_set != 0U) {
    psta->no_short_preamble_set = 0U;
    pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble - 1;
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
  if ((unsigned int )psta->nonerp_set != 0U) {
    psta->nonerp_set = 0U;
    pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp - 1;
    if (pmlmepriv->num_sta_non_erp == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 42, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
  if ((unsigned int )psta->no_short_slot_time_set != 0U) {
    psta->no_short_slot_time_set = 0U;
    pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time - 1;
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
  if ((unsigned int )psta->no_ht_gf_set != 0U) {
    psta->no_ht_gf_set = 0U;
    pmlmepriv->num_sta_ht_no_gf = pmlmepriv->num_sta_ht_no_gf - 1;
  } else {

  }
  if ((unsigned int )psta->no_ht_set != 0U) {
    psta->no_ht_set = 0U;
    pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht - 1;
  } else {

  }
  if ((unsigned int )psta->ht_20mhz_set != 0U) {
    psta->ht_20mhz_set = 0U;
    pmlmepriv->num_sta_ht_20mhz = pmlmepriv->num_sta_ht_20mhz - 1;
  } else {

  }
  tmp = rtw_ht_operation_update(padapter);
  if (tmp > 0) {
    update_beacon23a(padapter, 45, (u8 *)0U, 0);
    update_beacon23a(padapter, 61, (u8 *)0U, 1);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, updated =%d\n", "bss_cap_update_on_sta_leave23a", (int )beacon_updated);
  } else {

  }
  return (beacon_updated);
}
}
u8 ap_free_sta23a(struct rtw_adapter *padapter , struct sta_info *psta , bool active ,
                  u16 reason ) 
{ 
  struct sta_priv *pstapriv ;
  u8 beacon_updated ;

  {
  pstapriv = & padapter->stapriv;
  beacon_updated = 0U;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (beacon_updated);
  } else {

  }
  if ((int )active) {
    send_delba23a(padapter, 0, (u8 *)(& psta->hwaddr));
    send_delba23a(padapter, 1, (u8 *)(& psta->hwaddr));
    issue_deauth23a(padapter, (unsigned char *)(& psta->hwaddr), (int )reason);
  } else {

  }
  psta->htpriv.agg_enable_bitmap = 0U;
  psta->htpriv.candidate_tid_bitmap = 0U;
  rtw_clearstakey_cmd23a(padapter, (u8 *)psta, (int )((unsigned int )((unsigned char )psta->mac_id) + 3U),
                         1);
  spin_lock_bh(& psta->lock);
  psta->state = psta->state & 4294967294U;
  spin_unlock_bh(& psta->lock);
  rtw_cfg80211_indicate_sta_disassoc(padapter, (unsigned char *)(& psta->hwaddr),
                                     (int )reason);
  report_del_sta_event23a(padapter, (unsigned char *)(& psta->hwaddr), (int )reason);
  beacon_updated = bss_cap_update_on_sta_leave23a(padapter, psta);
  spin_lock_bh(& pstapriv->sta_hash_lock);
  rtw_free_stainfo23a(padapter, psta);
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return (beacon_updated);
}
}
int rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter , u8 new_ch , u8 ch_offset ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 bc_addr___0[6U] ;
  struct list_head  const  *__mptr ;

  {
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  bc_addr___0[0] = 255U;
  bc_addr___0[1] = 255U;
  bc_addr___0[2] = 255U;
  bc_addr___0[3] = 255U;
  bc_addr___0[4] = 255U;
  bc_addr___0[5] = 255U;
  if ((pmlmeinfo->state & 3U) != 3U) {
    return (0);
  } else {

  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): with ch:%u, offset:%u\n", "rtw_ap_inform_ch_switch23a",
           (char *)(& (padapter->pnetdev)->name), (int )new_ch, (int )ch_offset);
  } else {

  }
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  goto ldv_56061;
  ldv_56060: 
  __mptr = (struct list_head  const  *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
  issue_action_spct_ch_switch23a(padapter, (u8 *)(& psta->hwaddr), (int )new_ch, (int )ch_offset);
  psta->expire_to = 5U < pstapriv->expire_to * 2U ? 5U : pstapriv->expire_to * 2U;
  plist = plist->next;
  ldv_56061: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_56060;
  } else {

  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  issue_action_spct_ch_switch23a(padapter, (u8 *)(& bc_addr___0), (int )new_ch, (int )ch_offset);
  return (0);
}
}
int rtw_sta_flush23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 bc_addr___0[6U] ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  u8 tmp ;

  {
  pstapriv = & padapter->stapriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  bc_addr___0[0] = 255U;
  bc_addr___0[1] = 255U;
  bc_addr___0[2] = 255U;
  bc_addr___0[3] = 255U;
  bc_addr___0[4] = 255U;
  bc_addr___0[5] = 255U;
  chk_alive_num = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "rtw_sta_flush23a", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
  if ((pmlmeinfo->state & 3U) != 3U) {
    return (0);
  } else {

  }
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_56081;
  ldv_56080: 
  __mptr = (struct list_head  const  *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
  list_del_init(& psta->asoc_list);
  pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
  tmp = chk_alive_num;
  chk_alive_num = (u8 )((int )chk_alive_num + 1);
  chk_alive_list[(int )tmp] = psta;
  plist = ptmp;
  ptmp = plist->next;
  ldv_56081: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_56080;
  } else {

  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  i = 0;
  goto ldv_56084;
  ldv_56083: 
  ap_free_sta23a(padapter, chk_alive_list[i], 1, 3);
  i = i + 1;
  ldv_56084: ;
  if ((int )chk_alive_num > i) {
    goto ldv_56083;
  } else {

  }
  issue_deauth23a(padapter, (unsigned char *)(& bc_addr___0), 3);
  associated_clients_update23a(padapter, 1);
  return (0);
}
}
void sta_info_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  int flags ;
  struct mlme_priv *pmlmepriv ;

  {
  flags = psta->flags;
  pmlmepriv = & padapter->mlmepriv;
  if ((flags & 512) != 0) {
    psta->qos_option = 1U;
  } else {
    psta->qos_option = 0U;
  }
  if (pmlmepriv->qos_option == 0U) {
    psta->qos_option = 0U;
  } else {

  }
  if ((flags & 2048) != 0) {
    psta->htpriv.ht_option = 1;
    psta->qos_option = 1U;
  } else {
    psta->htpriv.ht_option = 0;
  }
  if (! pmlmepriv->htpriv.ht_option) {
    psta->htpriv.ht_option = 0;
  } else {

  }
  update_sta_info23a_apmode23a(padapter, psta);
  return;
}
}
void ap_sta_info_defer_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
  if ((int )psta->state & 1) {
    add_RATid23a(padapter, psta, 0);
  } else {

  }
  return;
}
}
void rtw_ap_restore_network(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct security_priv *psecuritypriv ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  u8 tmp ;

  {
  mlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pstapriv = & padapter->stapriv;
  psecuritypriv = & padapter->securitypriv;
  chk_alive_num = 0U;
  rtw_setopmode_cmd23a(padapter, 3);
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  start_bss_network(padapter, (u8 *)(& mlmepriv->cur_network.network));
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
    rtw_set_key23a(padapter, psecuritypriv, (int )psecuritypriv->dot118021XGrpKeyid,
                   0);
  } else {

  }
  if (padapter->securitypriv.dot11PrivacyAlgrthm != 1027074U && padapter->securitypriv.dot11PrivacyAlgrthm != 1027076U) {
    return;
  } else {

  }
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_56113;
  ldv_56112: 
  __mptr = (struct list_head  const  *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
  tmp = chk_alive_num;
  chk_alive_num = (u8 )((int )chk_alive_num + 1);
  chk_alive_list[(int )tmp] = psta;
  plist = ptmp;
  ptmp = plist->next;
  ldv_56113: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_56112;
  } else {

  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  i = 0;
  goto ldv_56116;
  ldv_56115: 
  psta = chk_alive_list[i];
  if ((int )psta->state & 1) {
    Update_RA_Entry23a(padapter, psta);
    rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
  } else {

  }
  i = i + 1;
  ldv_56116: ;
  if ((int )chk_alive_num > i) {
    goto ldv_56115;
  } else {

  }

  return;
}
}
void start_ap_mode23a(struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_acl_pool *pacl_list ;

  {
  pmlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  pmlmeext = & padapter->mlmeextpriv;
  pacl_list = & pstapriv->acl_list;
  pmlmepriv->update_bcn = 0U;
  pmlmeext->bstart_bss = 0U;
  pmlmepriv->num_sta_non_erp = 0;
  pmlmepriv->num_sta_no_short_slot_time = 0;
  pmlmepriv->num_sta_no_short_preamble = 0;
  pmlmepriv->num_sta_ht_no_gf = 0;
  pmlmepriv->num_sta_no_ht = 0;
  pmlmepriv->num_sta_ht_20mhz = 0;
  pmlmepriv->olbc = 0;
  pmlmepriv->olbc_ht = 0;
  pmlmepriv->ht_op_mode = 0U;
  i = 0;
  goto ldv_56127;
  ldv_56126: 
  pstapriv->sta_aid[i] = (struct sta_info *)0;
  i = i + 1;
  ldv_56127: ;
  if (i <= 31) {
    goto ldv_56126;
  } else {

  }
  INIT_LIST_HEAD(& pacl_list->acl_node_q.queue);
  pacl_list->num = 0;
  pacl_list->mode = 0;
  i = 0;
  goto ldv_56130;
  ldv_56129: 
  INIT_LIST_HEAD(& pacl_list->aclnode[i].list);
  pacl_list->aclnode[i].valid = 0U;
  i = i + 1;
  ldv_56130: ;
  if (i <= 15) {
    goto ldv_56129;
  } else {

  }

  return;
}
}
void stop_ap_mode23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;

  {
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pacl_list = & pstapriv->acl_list;
  pacl_node_q = & pacl_list->acl_node_q;
  pmlmepriv->update_bcn = 0U;
  pmlmeext->bstart_bss = 0U;
  memset((void *)(& padapter->securitypriv), 0, 4272UL);
  padapter->securitypriv.ndisauthtype = 0U;
  padapter->securitypriv.ndisencryptstatus = 1U;
  spin_lock_bh(& pacl_node_q->lock);
  phead = get_list_head(pacl_node_q);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_56148;
  ldv_56147: 
  __mptr = (struct list_head  const  *)plist;
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
  if ((unsigned int )paclnode->valid == 1U) {
    paclnode->valid = 0U;
    list_del_init(& paclnode->list);
    pacl_list->num = pacl_list->num - 1;
  } else {

  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_56148: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_56147;
  } else {

  }
  spin_unlock_bh(& pacl_node_q->lock);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, free acl_node_queue, num =%d\n", "stop_ap_mode23a",
           pacl_list->num);
  } else {

  }
  rtw_sta_flush23a(padapter);
  rtw_free_all_stainfo23a(padapter);
  psta = rtw_get_bcmc_stainfo23a(padapter);
  spin_lock_bh(& pstapriv->sta_hash_lock);
  rtw_free_stainfo23a(padapter, psta);
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  rtw_init_bcmc_stainfo23a(padapter);
  rtw23a_free_mlme_priv_ie_data(pmlmepriv);
  return;
}
}
bool ldv_queue_work_on_811(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_812(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_813(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_2(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_814(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_2(2);
  return;
}
}
bool ldv_queue_delayed_work_on_815(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_2(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
extern void *memset(void * , int  , size_t  ) ;
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
  __VERIFIER_error();
}
}
bool ldv_is_err(void const   *ptr ) 
{ 


  {
  return ((unsigned long )ptr > 2012UL);
}
}
void *ldv_err_ptr(long error ) 
{ 


  {
  return ((void *)(2012L - error));
}
}
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
  return ((long )(2012UL - (unsigned long )ptr));
}
}
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
    tmp___0 = 1;
  } else {
    tmp = ldv_is_err(ptr);
    if ((int )tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((bool )tmp___0);
}
}
int ldv_module_refcounter  =    1;
void ldv_module_get(struct module *module ) 
{ 


  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
  return;
}
}
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    module_get_succeeded = ldv_undef_int();
    if (module_get_succeeded == 1) {
      ldv_module_refcounter = ldv_module_refcounter + 1;
      return (1);
    } else {
      return (0);
    }
  } else {

  }
  return (0);
}
}
void ldv_module_put(struct module *module ) 
{ 


  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    if (ldv_module_refcounter <= 1) {
      ldv_error();
    } else {

    }
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
  return;
}
}
void ldv_module_put_and_exit(void) 
{ 


  {
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
  goto LDV_STOP;
}
}
unsigned int ldv_module_refcount(void) 
{ 


  {
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
void ldv_check_final_state(void) 
{ 


  {
  if (ldv_module_refcounter != 1) {
    ldv_error();
  } else {

  }
  return;
}
}
