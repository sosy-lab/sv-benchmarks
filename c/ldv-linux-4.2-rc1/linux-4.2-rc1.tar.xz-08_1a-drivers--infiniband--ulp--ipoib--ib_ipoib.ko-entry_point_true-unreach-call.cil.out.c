extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct ethtool_coalesce;
#line 87
struct device_attribute;
#line 88
struct nlattr;
#line 170
struct ib_device;
#line 158 "include/linux/kmemcheck.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_217 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38
struct kiocb;
#line 54 "include/uapi/linux/net.h"
struct poll_table_struct;
#line 55
struct net;
#line 72
struct fasync_struct;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 176
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1284 "include/linux/device.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 380 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_218 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_218 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_223 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_224 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_223 __annonCompField62 ;
   union __anonunion____missing_field_name_224 __annonCompField63 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_227 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_226 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_227 __annonCompField64 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_226 __annonCompField65 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_230 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_229 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_230 __annonCompField66 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_228 {
   struct __anonstruct____missing_field_name_229 __annonCompField67 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_232 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_231 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_232 __annonCompField69 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_233 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_234 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_235 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_228 __annonCompField68 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_231 __annonCompField70 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_233 __annonCompField71 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_234 __annonCompField72 ;
   union __anonunion____missing_field_name_235 __annonCompField73 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_237 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_237 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_238 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_238 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_239 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_239 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_240 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_240 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_241 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_241 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_242 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_242 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_243 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_243 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_244 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_244 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_245 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_246 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_245 ifr_ifrn ;
   union __anonunion_ifr_ifru_246 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_251 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_250 {
   struct __anonstruct____missing_field_name_251 __annonCompField74 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_250 __annonCompField75 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_253 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_252 {
   struct __anonstruct____missing_field_name_253 __annonCompField76 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_252 __annonCompField77 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_254 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_254 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_258 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_257 {
   struct __anonstruct____missing_field_name_258 __annonCompField78 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_257 __annonCompField79 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 62
struct kstatfs;
#line 63
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_262 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_262 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_263 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_263 __annonCompField81 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_266 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_267 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_268 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_266 __annonCompField82 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_267 __annonCompField83 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_268 __annonCompField84 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_269 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_269 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_271 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_270 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_271 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_270 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118
struct proc_dir_entry;
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_302 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_302 possible_net_t;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 657 "include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 80 "include/linux/phy.h"
typedef int phy_interface_t;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   int state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_315 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_317 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_315 adj_list ;
   struct __anonstruct_all_adj_list_316 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_317 __annonCompField94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 2893
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 506 "include/uapi/linux/rtnetlink.h"
struct tcmsg {
   unsigned char tcm_family ;
   unsigned char tcm__pad1 ;
   unsigned short tcm__pad2 ;
   int tcm_ifindex ;
   __u32 tcm_handle ;
   __u32 tcm_parent ;
   __u32 tcm_info ;
};
#line 136 "include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 25 "include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy  const  *slave_policy ;
   int (*slave_validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*slave_changelink)(struct net_device * , struct net_device * , struct nlattr ** ,
                           struct nlattr ** ) ;
   size_t (*get_slave_size)(struct net_device  const  * , struct net_device  const  * ) ;
   int (*fill_slave_info)(struct sk_buff * , struct net_device  const  * , struct net_device  const  * ) ;
   struct net *(*get_link_net)(struct net_device  const  * ) ;
};
#line 171
struct neigh_table;
#line 171 "include/net/rtnetlink.h"
struct neigh_parms {
   possible_net_t net ;
   struct net_device *dev ;
   struct list_head list ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[13U] ;
   unsigned long data_state[1U] ;
};
#line 110 "include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 129
struct neigh_ops;
#line 129 "include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 158 "include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 166 "include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   possible_net_t net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 174 "include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 187 "include/net/neighbour.h"
struct neigh_table {
   int family ;
   int entry_size ;
   int key_len ;
   __be16 protocol ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   bool (*key_eq)(struct neighbour  const  * , void const   * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   struct list_head parms_list ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 519 "include/net/neighbour.h"
struct tc_stats {
   __u64 bytes ;
   __u32 packets ;
   __u32 drops ;
   __u32 overlimits ;
   __u32 bps ;
   __u32 pps ;
   __u32 qlen ;
   __u32 backlog ;
};
#line 92 "./include/uapi/linux/pkt_sched.h"
struct tc_sizespec {
   unsigned char cell_log ;
   unsigned char size_log ;
   short cell_align ;
   int overhead ;
   unsigned int linklayer ;
   unsigned int mpu ;
   unsigned int mtu ;
   unsigned int tsize ;
};
#line 26 "./include/uapi/linux/gen_stats.h"
struct gnet_stats_basic_packed {
   __u64 bytes ;
   __u32 packets ;
};
#line 40 "./include/uapi/linux/gen_stats.h"
struct gnet_stats_rate_est64 {
   __u64 bps ;
   __u64 pps ;
};
#line 50 "./include/uapi/linux/gen_stats.h"
struct gnet_stats_queue {
   __u32 qlen ;
   __u32 backlog ;
   __u32 drops ;
   __u32 requeues ;
   __u32 overlimits ;
};
#line 76 "./include/uapi/linux/gen_stats.h"
struct gnet_stats_basic_cpu {
   struct gnet_stats_basic_packed bstats ;
   struct u64_stats_sync syncp ;
};
#line 13 "include/net/gen_stats.h"
struct gnet_dump {
   spinlock_t *lock ;
   struct sk_buff *skb ;
   struct nlattr *tail ;
   int compat_tc_stats ;
   int compat_xstats ;
   void *xstats ;
   int xstats_len ;
   struct tc_stats tc_stats ;
};
#line 61
struct Qdisc_ops;
#line 62
struct qdisc_walker;
#line 63
struct tcf_walker;
#line 35 "include/net/sch_generic.h"
struct qdisc_size_table {
   struct callback_head rcu ;
   struct list_head list ;
   struct tc_sizespec szopts ;
   int refcnt ;
   u16 data[] ;
};
#line 46 "include/net/sch_generic.h"
struct Qdisc {
   int (*enqueue)(struct sk_buff * , struct Qdisc * ) ;
   struct sk_buff *(*dequeue)(struct Qdisc * ) ;
   unsigned int flags ;
   u32 limit ;
   struct Qdisc_ops  const  *ops ;
   struct qdisc_size_table *stab ;
   struct list_head list ;
   u32 handle ;
   u32 parent ;
   int (*reshape_fail)(struct sk_buff * , struct Qdisc * ) ;
   void *u32_node ;
   struct Qdisc *__parent ;
   struct netdev_queue *dev_queue ;
   struct gnet_stats_rate_est64 rate_est ;
   struct gnet_stats_basic_cpu *cpu_bstats ;
   struct gnet_stats_queue *cpu_qstats ;
   struct Qdisc *next_sched ;
   struct sk_buff *gso_skb ;
   unsigned long state ;
   struct sk_buff_head q ;
   struct gnet_stats_basic_packed bstats ;
   unsigned int __state ;
   struct gnet_stats_queue qstats ;
   struct callback_head callback_head ;
   int padded ;
   atomic_t refcnt ;
   spinlock_t busylock ;
};
#line 149 "include/net/sch_generic.h"
struct Qdisc_class_ops {
   struct netdev_queue *(*select_queue)(struct Qdisc * , struct tcmsg * ) ;
   int (*graft)(struct Qdisc * , unsigned long  , struct Qdisc * , struct Qdisc ** ) ;
   struct Qdisc *(*leaf)(struct Qdisc * , unsigned long  ) ;
   void (*qlen_notify)(struct Qdisc * , unsigned long  ) ;
   unsigned long (*get)(struct Qdisc * , u32  ) ;
   void (*put)(struct Qdisc * , unsigned long  ) ;
   int (*change)(struct Qdisc * , u32  , u32  , struct nlattr ** , unsigned long * ) ;
   int (*delete)(struct Qdisc * , unsigned long  ) ;
   void (*walk)(struct Qdisc * , struct qdisc_walker * ) ;
   struct tcf_proto **(*tcf_chain)(struct Qdisc * , unsigned long  ) ;
   unsigned long (*bind_tcf)(struct Qdisc * , unsigned long  , u32  ) ;
   void (*unbind_tcf)(struct Qdisc * , unsigned long  ) ;
   int (*dump)(struct Qdisc * , unsigned long  , struct sk_buff * , struct tcmsg * ) ;
   int (*dump_stats)(struct Qdisc * , unsigned long  , struct gnet_dump * ) ;
};
#line 177 "include/net/sch_generic.h"
struct Qdisc_ops {
   struct Qdisc_ops *next ;
   struct Qdisc_class_ops  const  *cl_ops ;
   char id[16U] ;
   int priv_size ;
   int (*enqueue)(struct sk_buff * , struct Qdisc * ) ;
   struct sk_buff *(*dequeue)(struct Qdisc * ) ;
   struct sk_buff *(*peek)(struct Qdisc * ) ;
   unsigned int (*drop)(struct Qdisc * ) ;
   int (*init)(struct Qdisc * , struct nlattr * ) ;
   void (*reset)(struct Qdisc * ) ;
   void (*destroy)(struct Qdisc * ) ;
   int (*change)(struct Qdisc * , struct nlattr * ) ;
   void (*attach)(struct Qdisc * ) ;
   int (*dump)(struct Qdisc * , struct sk_buff * ) ;
   int (*dump_stats)(struct Qdisc * , struct gnet_dump * ) ;
   struct module *owner ;
};
#line 201 "include/net/sch_generic.h"
struct tcf_result {
   unsigned long class ;
   u32 classid ;
};
#line 207 "include/net/sch_generic.h"
struct tcf_proto_ops {
   struct list_head head ;
   char kind[16U] ;
   int (*classify)(struct sk_buff * , struct tcf_proto  const  * , struct tcf_result * ) ;
   int (*init)(struct tcf_proto * ) ;
   bool (*destroy)(struct tcf_proto * , bool  ) ;
   unsigned long (*get)(struct tcf_proto * , u32  ) ;
   int (*change)(struct net * , struct sk_buff * , struct tcf_proto * , unsigned long  ,
                 u32  , struct nlattr ** , unsigned long * , bool  ) ;
   int (*delete)(struct tcf_proto * , unsigned long  ) ;
   void (*walk)(struct tcf_proto * , struct tcf_walker * ) ;
   int (*dump)(struct net * , struct tcf_proto * , unsigned long  , struct sk_buff * ,
               struct tcmsg * ) ;
   struct module *owner ;
};
#line 232 "include/net/sch_generic.h"
struct tcf_proto {
   struct tcf_proto *next ;
   void *root ;
   int (*classify)(struct sk_buff * , struct tcf_proto  const  * , struct tcf_result * ) ;
   __be16 protocol ;
   u32 prio ;
   u32 classid ;
   struct Qdisc *q ;
   void *data ;
   struct tcf_proto_ops  const  *ops ;
   struct callback_head rcu ;
};
#line 250 "include/net/sch_generic.h"
struct qdisc_skb_cb {
   unsigned int pkt_len ;
   u16 slave_dev_queue_mapping ;
   u16 _pad ;
   unsigned char data[20U] ;
};
#line 779
struct mmu_notifier;
#line 780
struct mmu_notifier_ops;
#line 781 "include/net/sch_generic.h"
struct mmu_notifier_mm {
   struct hlist_head list ;
   spinlock_t lock ;
};
#line 26 "include/linux/mmu_notifier.h"
struct mmu_notifier_ops {
   void (*release)(struct mmu_notifier * , struct mm_struct * ) ;
   int (*clear_flush_young)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
   int (*test_young)(struct mmu_notifier * , struct mm_struct * , unsigned long  ) ;
   void (*change_pte)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                      pte_t  ) ;
   void (*invalidate_page)(struct mmu_notifier * , struct mm_struct * , unsigned long  ) ;
   void (*invalidate_range_start)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                                  unsigned long  ) ;
   void (*invalidate_range_end)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                                unsigned long  ) ;
   void (*invalidate_range)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
};
#line 170 "include/linux/mmu_notifier.h"
struct mmu_notifier {
   struct hlist_node hlist ;
   struct mmu_notifier_ops  const  *ops ;
};
#line 58 "include/rdma/ib_verbs.h"
struct __anonstruct_global_342 {
   __be64 subnet_prefix ;
   __be64 interface_id ;
};
#line 58 "include/rdma/ib_verbs.h"
union ib_gid {
   u8 raw[16U] ;
   struct __anonstruct_global_342 global ;
};
#line 93
enum rdma_link_layer {
    IB_LINK_LAYER_UNSPECIFIED = 0,
    IB_LINK_LAYER_INFINIBAND = 1,
    IB_LINK_LAYER_ETHERNET = 2
} ;
#line 141
enum ib_atomic_cap {
    IB_ATOMIC_NONE = 0,
    IB_ATOMIC_HCA = 1,
    IB_ATOMIC_GLOB = 2
} ;
#line 159 "include/rdma/ib_verbs.h"
struct __anonstruct_per_transport_caps_343 {
   uint32_t rc_odp_caps ;
   uint32_t uc_odp_caps ;
   uint32_t ud_odp_caps ;
};
#line 159 "include/rdma/ib_verbs.h"
struct ib_odp_caps {
   uint64_t general_caps ;
   struct __anonstruct_per_transport_caps_343 per_transport_caps ;
};
#line 179 "include/rdma/ib_verbs.h"
struct ib_cq_init_attr {
   unsigned int cqe ;
   int comp_vector ;
   u32 flags ;
};
#line 185 "include/rdma/ib_verbs.h"
struct ib_device_attr {
   u64 fw_ver ;
   __be64 sys_image_guid ;
   u64 max_mr_size ;
   u64 page_size_cap ;
   u32 vendor_id ;
   u32 vendor_part_id ;
   u32 hw_ver ;
   int max_qp ;
   int max_qp_wr ;
   int device_cap_flags ;
   int max_sge ;
   int max_sge_rd ;
   int max_cq ;
   int max_cqe ;
   int max_mr ;
   int max_pd ;
   int max_qp_rd_atom ;
   int max_ee_rd_atom ;
   int max_res_rd_atom ;
   int max_qp_init_rd_atom ;
   int max_ee_init_rd_atom ;
   enum ib_atomic_cap atomic_cap ;
   enum ib_atomic_cap masked_atomic_cap ;
   int max_ee ;
   int max_rdd ;
   int max_mw ;
   int max_raw_ipv6_qp ;
   int max_raw_ethy_qp ;
   int max_mcast_grp ;
   int max_mcast_qp_attach ;
   int max_total_mcast_qp_attach ;
   int max_ah ;
   int max_fmr ;
   int max_map_per_fmr ;
   int max_srq ;
   int max_srq_wr ;
   int max_srq_sge ;
   unsigned int max_fast_reg_page_list_len ;
   u16 max_pkeys ;
   u8 local_ca_ack_delay ;
   int sig_prot_cap ;
   int sig_guard_cap ;
   struct ib_odp_caps odp_caps ;
   uint64_t timestamp_mask ;
   uint64_t hca_core_clock ;
};
#line 233
enum ib_mtu {
    IB_MTU_256 = 1,
    IB_MTU_512 = 2,
    IB_MTU_1024 = 3,
    IB_MTU_2048 = 4,
    IB_MTU_4096 = 5
} ;
#line 253
enum ib_port_state {
    IB_PORT_NOP = 0,
    IB_PORT_DOWN = 1,
    IB_PORT_INIT = 2,
    IB_PORT_ARMED = 3,
    IB_PORT_ACTIVE = 4,
    IB_PORT_ACTIVE_DEFER = 5
} ;
#line 316 "include/rdma/ib_verbs.h"
struct ib_protocol_stats {

};
#line 319 "include/rdma/ib_verbs.h"
struct iw_protocol_stats {
   u64 ipInReceives ;
   u64 ipInHdrErrors ;
   u64 ipInTooBigErrors ;
   u64 ipInNoRoutes ;
   u64 ipInAddrErrors ;
   u64 ipInUnknownProtos ;
   u64 ipInTruncatedPkts ;
   u64 ipInDiscards ;
   u64 ipInDelivers ;
   u64 ipOutForwDatagrams ;
   u64 ipOutRequests ;
   u64 ipOutDiscards ;
   u64 ipOutNoRoutes ;
   u64 ipReasmTimeout ;
   u64 ipReasmReqds ;
   u64 ipReasmOKs ;
   u64 ipReasmFails ;
   u64 ipFragOKs ;
   u64 ipFragFails ;
   u64 ipFragCreates ;
   u64 ipInMcastPkts ;
   u64 ipOutMcastPkts ;
   u64 ipInBcastPkts ;
   u64 ipOutBcastPkts ;
   u64 tcpRtoAlgorithm ;
   u64 tcpRtoMin ;
   u64 tcpRtoMax ;
   u64 tcpMaxConn ;
   u64 tcpActiveOpens ;
   u64 tcpPassiveOpens ;
   u64 tcpAttemptFails ;
   u64 tcpEstabResets ;
   u64 tcpCurrEstab ;
   u64 tcpInSegs ;
   u64 tcpOutSegs ;
   u64 tcpRetransSegs ;
   u64 tcpInErrs ;
   u64 tcpOutRsts ;
};
#line 362 "include/rdma/ib_verbs.h"
union rdma_protocol_stats {
   struct ib_protocol_stats ib ;
   struct iw_protocol_stats iw ;
};
#line 367 "include/rdma/ib_verbs.h"
struct ib_port_attr {
   enum ib_port_state state ;
   enum ib_mtu max_mtu ;
   enum ib_mtu active_mtu ;
   int gid_tbl_len ;
   u32 port_cap_flags ;
   u32 max_msg_sz ;
   u32 bad_pkey_cntr ;
   u32 qkey_viol_cntr ;
   u16 pkey_tbl_len ;
   u16 lid ;
   u16 sm_lid ;
   u8 lmc ;
   u8 max_vl_num ;
   u8 sm_sl ;
   u8 subnet_timeout ;
   u8 init_type_reply ;
   u8 active_width ;
   u8 active_speed ;
   u8 phys_state ;
};
#line 430 "include/rdma/ib_verbs.h"
struct ib_device_modify {
   u64 sys_image_guid ;
   char node_desc[64U] ;
};
#line 441 "include/rdma/ib_verbs.h"
struct ib_port_modify {
   u32 set_port_cap_mask ;
   u32 clr_port_cap_mask ;
   u8 init_type ;
};
#line 447
enum ib_event_type {
    IB_EVENT_CQ_ERR = 0,
    IB_EVENT_QP_FATAL = 1,
    IB_EVENT_QP_REQ_ERR = 2,
    IB_EVENT_QP_ACCESS_ERR = 3,
    IB_EVENT_COMM_EST = 4,
    IB_EVENT_SQ_DRAINED = 5,
    IB_EVENT_PATH_MIG = 6,
    IB_EVENT_PATH_MIG_ERR = 7,
    IB_EVENT_DEVICE_FATAL = 8,
    IB_EVENT_PORT_ACTIVE = 9,
    IB_EVENT_PORT_ERR = 10,
    IB_EVENT_LID_CHANGE = 11,
    IB_EVENT_PKEY_CHANGE = 12,
    IB_EVENT_SM_CHANGE = 13,
    IB_EVENT_SRQ_ERR = 14,
    IB_EVENT_SRQ_LIMIT_REACHED = 15,
    IB_EVENT_QP_LAST_WQE_REACHED = 16,
    IB_EVENT_CLIENT_REREGISTER = 17,
    IB_EVENT_GID_CHANGE = 18
} ;
#line 471
struct ib_cq;
#line 471
struct ib_qp;
#line 471
struct ib_srq;
#line 471 "include/rdma/ib_verbs.h"
union __anonunion_element_344 {
   struct ib_cq *cq ;
   struct ib_qp *qp ;
   struct ib_srq *srq ;
   u8 port_num ;
};
#line 471 "include/rdma/ib_verbs.h"
struct ib_event {
   struct ib_device *device ;
   union __anonunion_element_344 element ;
   enum ib_event_type event ;
};
#line 482 "include/rdma/ib_verbs.h"
struct ib_event_handler {
   struct ib_device *device ;
   void (*handler)(struct ib_event_handler * , struct ib_event * ) ;
   struct list_head list ;
};
#line 488 "include/rdma/ib_verbs.h"
struct ib_global_route {
   union ib_gid dgid ;
   u32 flow_label ;
   u8 sgid_index ;
   u8 hop_limit ;
   u8 traffic_class ;
};
#line 503 "include/rdma/ib_verbs.h"
struct ib_grh {
   __be32 version_tclass_flow ;
   __be16 paylen ;
   u8 next_hdr ;
   u8 hop_limit ;
   union ib_gid sgid ;
   union ib_gid dgid ;
};
#line 562 "include/rdma/ib_verbs.h"
struct ib_mr_init_attr {
   int max_reg_descriptors ;
   u32 flags ;
};
#line 574
enum ib_signature_type {
    IB_SIG_TYPE_NONE = 0,
    IB_SIG_TYPE_T10_DIF = 1
} ;
#line 579
enum ib_t10_dif_bg_type {
    IB_T10DIF_CRC = 0,
    IB_T10DIF_CSUM = 1
} ;
#line 584 "include/rdma/ib_verbs.h"
struct ib_t10_dif_domain {
   enum ib_t10_dif_bg_type bg_type ;
   u16 pi_interval ;
   u16 bg ;
   u16 app_tag ;
   u32 ref_tag ;
   bool ref_remap ;
   bool app_escape ;
   bool ref_escape ;
   u16 apptag_check_mask ;
};
#line 619 "include/rdma/ib_verbs.h"
union __anonunion_sig_345 {
   struct ib_t10_dif_domain dif ;
};
#line 619 "include/rdma/ib_verbs.h"
struct ib_sig_domain {
   enum ib_signature_type sig_type ;
   union __anonunion_sig_345 sig ;
};
#line 632 "include/rdma/ib_verbs.h"
struct ib_sig_attrs {
   u8 check_mask ;
   struct ib_sig_domain mem ;
   struct ib_sig_domain wire ;
};
#line 644
enum ib_sig_err_type {
    IB_SIG_BAD_GUARD = 0,
    IB_SIG_BAD_REFTAG = 1,
    IB_SIG_BAD_APPTAG = 2
} ;
#line 650 "include/rdma/ib_verbs.h"
struct ib_sig_err {
   enum ib_sig_err_type err_type ;
   u32 expected ;
   u32 actual ;
   u64 sig_err_offset ;
   u32 key ;
};
#line 665 "include/rdma/ib_verbs.h"
struct ib_mr_status {
   u32 fail_status ;
   struct ib_sig_err sig_err ;
};
#line 685 "include/rdma/ib_verbs.h"
struct ib_ah_attr {
   struct ib_global_route grh ;
   u16 dlid ;
   u8 sl ;
   u8 src_path_bits ;
   u8 static_rate ;
   u8 ah_flags ;
   u8 port_num ;
   u8 dmac[6U] ;
   u16 vlan_id ;
};
#line 697
enum ib_wc_status {
    IB_WC_SUCCESS = 0,
    IB_WC_LOC_LEN_ERR = 1,
    IB_WC_LOC_QP_OP_ERR = 2,
    IB_WC_LOC_EEC_OP_ERR = 3,
    IB_WC_LOC_PROT_ERR = 4,
    IB_WC_WR_FLUSH_ERR = 5,
    IB_WC_MW_BIND_ERR = 6,
    IB_WC_BAD_RESP_ERR = 7,
    IB_WC_LOC_ACCESS_ERR = 8,
    IB_WC_REM_INV_REQ_ERR = 9,
    IB_WC_REM_ACCESS_ERR = 10,
    IB_WC_REM_OP_ERR = 11,
    IB_WC_RETRY_EXC_ERR = 12,
    IB_WC_RNR_RETRY_EXC_ERR = 13,
    IB_WC_LOC_RDD_VIOL_ERR = 14,
    IB_WC_REM_INV_RD_REQ_ERR = 15,
    IB_WC_REM_ABORT_ERR = 16,
    IB_WC_INV_EECN_ERR = 17,
    IB_WC_INV_EEC_STATE_ERR = 18,
    IB_WC_FATAL_ERR = 19,
    IB_WC_RESP_TIMEOUT_ERR = 20,
    IB_WC_GENERAL_ERR = 21
} ;
#line 724
enum ib_wc_opcode {
    IB_WC_SEND = 0,
    IB_WC_RDMA_WRITE = 1,
    IB_WC_RDMA_READ = 2,
    IB_WC_COMP_SWAP = 3,
    IB_WC_FETCH_ADD = 4,
    IB_WC_BIND_MW = 5,
    IB_WC_LSO = 6,
    IB_WC_LOCAL_INV = 7,
    IB_WC_FAST_REG_MR = 8,
    IB_WC_MASKED_COMP_SWAP = 9,
    IB_WC_MASKED_FETCH_ADD = 10,
    IB_WC_RECV = 128,
    IB_WC_RECV_RDMA_WITH_IMM = 129
} ;
#line 749 "include/rdma/ib_verbs.h"
union __anonunion_ex_346 {
   __be32 imm_data ;
   u32 invalidate_rkey ;
};
#line 749 "include/rdma/ib_verbs.h"
struct ib_wc {
   u64 wr_id ;
   enum ib_wc_status status ;
   enum ib_wc_opcode opcode ;
   u32 vendor_err ;
   u32 byte_len ;
   struct ib_qp *qp ;
   union __anonunion_ex_346 ex ;
   u32 src_qp ;
   int wc_flags ;
   u16 pkey_index ;
   u16 slid ;
   u8 sl ;
   u8 dlid_path_bits ;
   u8 port_num ;
   u8 smac[6U] ;
   u16 vlan_id ;
};
#line 775
enum ib_cq_notify_flags {
    IB_CQ_SOLICITED = 1,
    IB_CQ_NEXT_COMP = 2,
    IB_CQ_SOLICITED_MASK = 3,
    IB_CQ_REPORT_MISSED_EVENTS = 4
} ;
#line 782
enum ib_srq_type {
    IB_SRQT_BASIC = 0,
    IB_SRQT_XRC = 1
} ;
#line 787
enum ib_srq_attr_mask {
    IB_SRQ_MAX_WR = 1,
    IB_SRQ_LIMIT = 2
} ;
#line 792 "include/rdma/ib_verbs.h"
struct ib_srq_attr {
   u32 max_wr ;
   u32 max_sge ;
   u32 srq_limit ;
};
#line 798
struct ib_xrcd;
#line 798 "include/rdma/ib_verbs.h"
struct __anonstruct_xrc_348 {
   struct ib_xrcd *xrcd ;
   struct ib_cq *cq ;
};
#line 798 "include/rdma/ib_verbs.h"
union __anonunion_ext_347 {
   struct __anonstruct_xrc_348 xrc ;
};
#line 798 "include/rdma/ib_verbs.h"
struct ib_srq_init_attr {
   void (*event_handler)(struct ib_event * , void * ) ;
   void *srq_context ;
   struct ib_srq_attr attr ;
   enum ib_srq_type srq_type ;
   union __anonunion_ext_347 ext ;
};
#line 812 "include/rdma/ib_verbs.h"
struct ib_qp_cap {
   u32 max_send_wr ;
   u32 max_recv_wr ;
   u32 max_send_sge ;
   u32 max_recv_sge ;
   u32 max_inline_data ;
};
#line 820
enum ib_sig_type {
    IB_SIGNAL_ALL_WR = 0,
    IB_SIGNAL_REQ_WR = 1
} ;
#line 825
enum ib_qp_type {
    IB_QPT_SMI = 0,
    IB_QPT_GSI = 1,
    IB_QPT_RC = 2,
    IB_QPT_UC = 3,
    IB_QPT_UD = 4,
    IB_QPT_RAW_IPV6 = 5,
    IB_QPT_RAW_ETHERTYPE = 6,
    IB_QPT_RAW_PACKET = 8,
    IB_QPT_XRC_INI = 9,
    IB_QPT_XRC_TGT = 10,
    IB_QPT_MAX = 11,
    IB_QPT_RESERVED1 = 4096,
    IB_QPT_RESERVED2 = 4097,
    IB_QPT_RESERVED3 = 4098,
    IB_QPT_RESERVED4 = 4099,
    IB_QPT_RESERVED5 = 4100,
    IB_QPT_RESERVED6 = 4101,
    IB_QPT_RESERVED7 = 4102,
    IB_QPT_RESERVED8 = 4103,
    IB_QPT_RESERVED9 = 4104,
    IB_QPT_RESERVED10 = 4105
} ;
#line 849
enum ib_qp_create_flags {
    IB_QP_CREATE_IPOIB_UD_LSO = 1,
    IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
    IB_QP_CREATE_NETIF_QP = 32,
    IB_QP_CREATE_SIGNATURE_EN = 64,
    IB_QP_CREATE_USE_GFP_NOIO = 128,
    IB_QP_CREATE_RESERVED_START = 67108864,
    IB_QP_CREATE_RESERVED_END = (-0x7FFFFFFF-1)
} ;
#line 859 "include/rdma/ib_verbs.h"
struct ib_qp_init_attr {
   void (*event_handler)(struct ib_event * , void * ) ;
   void *qp_context ;
   struct ib_cq *send_cq ;
   struct ib_cq *recv_cq ;
   struct ib_srq *srq ;
   struct ib_xrcd *xrcd ;
   struct ib_qp_cap cap ;
   enum ib_sig_type sq_sig_type ;
   enum ib_qp_type qp_type ;
   enum ib_qp_create_flags create_flags ;
   u8 port_num ;
};
#line 960
enum ib_qp_state {
    IB_QPS_RESET = 0,
    IB_QPS_INIT = 1,
    IB_QPS_RTR = 2,
    IB_QPS_RTS = 3,
    IB_QPS_SQD = 4,
    IB_QPS_SQE = 5,
    IB_QPS_ERR = 6
} ;
#line 970
enum ib_mig_state {
    IB_MIG_MIGRATED = 0,
    IB_MIG_REARM = 1,
    IB_MIG_ARMED = 2
} ;
#line 976
enum ib_mw_type {
    IB_MW_TYPE_1 = 1,
    IB_MW_TYPE_2 = 2
} ;
#line 981 "include/rdma/ib_verbs.h"
struct ib_qp_attr {
   enum ib_qp_state qp_state ;
   enum ib_qp_state cur_qp_state ;
   enum ib_mtu path_mtu ;
   enum ib_mig_state path_mig_state ;
   u32 qkey ;
   u32 rq_psn ;
   u32 sq_psn ;
   u32 dest_qp_num ;
   int qp_access_flags ;
   struct ib_qp_cap cap ;
   struct ib_ah_attr ah_attr ;
   struct ib_ah_attr alt_ah_attr ;
   u16 pkey_index ;
   u16 alt_pkey_index ;
   u8 en_sqd_async_notify ;
   u8 sq_draining ;
   u8 max_rd_atomic ;
   u8 max_dest_rd_atomic ;
   u8 min_rnr_timer ;
   u8 port_num ;
   u8 timeout ;
   u8 retry_cnt ;
   u8 rnr_retry ;
   u8 alt_port_num ;
   u8 alt_timeout ;
   u8 smac[6U] ;
   u8 alt_smac[6U] ;
   u16 vlan_id ;
   u16 alt_vlan_id ;
};
#line 1013
enum ib_wr_opcode {
    IB_WR_RDMA_WRITE = 0,
    IB_WR_RDMA_WRITE_WITH_IMM = 1,
    IB_WR_SEND = 2,
    IB_WR_SEND_WITH_IMM = 3,
    IB_WR_RDMA_READ = 4,
    IB_WR_ATOMIC_CMP_AND_SWP = 5,
    IB_WR_ATOMIC_FETCH_AND_ADD = 6,
    IB_WR_LSO = 7,
    IB_WR_SEND_WITH_INV = 8,
    IB_WR_RDMA_READ_WITH_INV = 9,
    IB_WR_LOCAL_INV = 10,
    IB_WR_FAST_REG_MR = 11,
    IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
    IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
    IB_WR_BIND_MW = 14,
    IB_WR_REG_SIG_MR = 15,
    IB_WR_RESERVED1 = 240,
    IB_WR_RESERVED2 = 241,
    IB_WR_RESERVED3 = 242,
    IB_WR_RESERVED4 = 243,
    IB_WR_RESERVED5 = 244,
    IB_WR_RESERVED6 = 245,
    IB_WR_RESERVED7 = 246,
    IB_WR_RESERVED8 = 247,
    IB_WR_RESERVED9 = 248,
    IB_WR_RESERVED10 = 249
} ;
#line 1052 "include/rdma/ib_verbs.h"
struct ib_sge {
   u64 addr ;
   u32 length ;
   u32 lkey ;
};
#line 1063 "include/rdma/ib_verbs.h"
struct ib_fast_reg_page_list {
   struct ib_device *device ;
   u64 *page_list ;
   unsigned int max_page_list_len ;
};
#line 1069
struct ib_mr;
#line 1069 "include/rdma/ib_verbs.h"
struct ib_mw_bind_info {
   struct ib_mr *mr ;
   u64 addr ;
   u64 length ;
   int mw_access_flags ;
};
#line 1086 "include/rdma/ib_verbs.h"
union __anonunion_ex_349 {
   __be32 imm_data ;
   u32 invalidate_rkey ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_rdma_351 {
   u64 remote_addr ;
   u32 rkey ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_atomic_352 {
   u64 remote_addr ;
   u64 compare_add ;
   u64 swap ;
   u64 compare_add_mask ;
   u64 swap_mask ;
   u32 rkey ;
};
#line 1086
struct ib_ah;
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_ud_353 {
   struct ib_ah *ah ;
   void *header ;
   int hlen ;
   int mss ;
   u32 remote_qpn ;
   u32 remote_qkey ;
   u16 pkey_index ;
   u8 port_num ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_fast_reg_354 {
   u64 iova_start ;
   struct ib_fast_reg_page_list *page_list ;
   unsigned int page_shift ;
   unsigned int page_list_len ;
   u32 length ;
   int access_flags ;
   u32 rkey ;
};
#line 1086
struct ib_mw;
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_bind_mw_355 {
   struct ib_mw *mw ;
   u32 rkey ;
   struct ib_mw_bind_info bind_info ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct __anonstruct_sig_handover_356 {
   struct ib_sig_attrs *sig_attrs ;
   struct ib_mr *sig_mr ;
   int access_flags ;
   struct ib_sge *prot ;
};
#line 1086 "include/rdma/ib_verbs.h"
union __anonunion_wr_350 {
   struct __anonstruct_rdma_351 rdma ;
   struct __anonstruct_atomic_352 atomic ;
   struct __anonstruct_ud_353 ud ;
   struct __anonstruct_fast_reg_354 fast_reg ;
   struct __anonstruct_bind_mw_355 bind_mw ;
   struct __anonstruct_sig_handover_356 sig_handover ;
};
#line 1086 "include/rdma/ib_verbs.h"
struct ib_send_wr {
   struct ib_send_wr *next ;
   u64 wr_id ;
   struct ib_sge *sg_list ;
   int num_sge ;
   enum ib_wr_opcode opcode ;
   int send_flags ;
   union __anonunion_ex_349 ex ;
   union __anonunion_wr_350 wr ;
   u32 xrc_remote_srq_num ;
};
#line 1145 "include/rdma/ib_verbs.h"
struct ib_recv_wr {
   struct ib_recv_wr *next ;
   u64 wr_id ;
   struct ib_sge *sg_list ;
   int num_sge ;
};
#line 1162 "include/rdma/ib_verbs.h"
struct ib_phys_buf {
   u64 addr ;
   u64 size ;
};
#line 1167
struct ib_pd;
#line 1167 "include/rdma/ib_verbs.h"
struct ib_mr_attr {
   struct ib_pd *pd ;
   u64 device_virt_addr ;
   u64 size ;
   int mr_access_flags ;
   u32 lkey ;
   u32 rkey ;
};
#line 1183 "include/rdma/ib_verbs.h"
struct ib_mw_bind {
   u64 wr_id ;
   int send_flags ;
   struct ib_mw_bind_info bind_info ;
};
#line 1195 "include/rdma/ib_verbs.h"
struct ib_fmr_attr {
   int max_pages ;
   int max_maps ;
   u8 page_shift ;
};
#line 1201
struct ib_umem;
#line 1202 "include/rdma/ib_verbs.h"
struct ib_ucontext {
   struct ib_device *device ;
   struct list_head pd_list ;
   struct list_head mr_list ;
   struct list_head mw_list ;
   struct list_head cq_list ;
   struct list_head qp_list ;
   struct list_head srq_list ;
   struct list_head ah_list ;
   struct list_head xrcd_list ;
   struct list_head rule_list ;
   int closing ;
   struct pid *tgid ;
   struct rb_root umem_tree ;
   struct rw_semaphore umem_rwsem ;
   void (*invalidate_range)(struct ib_umem * , unsigned long  , unsigned long  ) ;
   struct mmu_notifier mn ;
   atomic_t notifier_count ;
   struct list_head no_private_counters ;
   int odp_mrs_count ;
};
#line 1234 "include/rdma/ib_verbs.h"
struct ib_uobject {
   u64 user_handle ;
   struct ib_ucontext *context ;
   void *object ;
   struct list_head list ;
   int id ;
   struct kref ref ;
   struct rw_semaphore mutex ;
   int live ;
};
#line 1246 "include/rdma/ib_verbs.h"
struct ib_udata {
   void const   *inbuf ;
   void *outbuf ;
   size_t inlen ;
   size_t outlen ;
};
#line 1253 "include/rdma/ib_verbs.h"
struct ib_pd {
   struct ib_device *device ;
   struct ib_uobject *uobject ;
   atomic_t usecnt ;
};
#line 1259 "include/rdma/ib_verbs.h"
struct ib_xrcd {
   struct ib_device *device ;
   atomic_t usecnt ;
   struct inode *inode ;
   struct mutex tgt_qp_mutex ;
   struct list_head tgt_qp_list ;
};
#line 1268 "include/rdma/ib_verbs.h"
struct ib_ah {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
};
#line 1276 "include/rdma/ib_verbs.h"
struct ib_cq {
   struct ib_device *device ;
   struct ib_uobject *uobject ;
   void (*comp_handler)(struct ib_cq * , void * ) ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *cq_context ;
   int cqe ;
   atomic_t usecnt ;
};
#line 1286 "include/rdma/ib_verbs.h"
struct __anonstruct_xrc_358 {
   struct ib_xrcd *xrcd ;
   struct ib_cq *cq ;
   u32 srq_num ;
};
#line 1286 "include/rdma/ib_verbs.h"
union __anonunion_ext_357 {
   struct __anonstruct_xrc_358 xrc ;
};
#line 1286 "include/rdma/ib_verbs.h"
struct ib_srq {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *srq_context ;
   enum ib_srq_type srq_type ;
   atomic_t usecnt ;
   union __anonunion_ext_357 ext ;
};
#line 1304 "include/rdma/ib_verbs.h"
struct ib_qp {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_cq *send_cq ;
   struct ib_cq *recv_cq ;
   struct ib_srq *srq ;
   struct ib_xrcd *xrcd ;
   struct list_head xrcd_list ;
   atomic_t usecnt ;
   struct list_head open_list ;
   struct ib_qp *real_qp ;
   struct ib_uobject *uobject ;
   void (*event_handler)(struct ib_event * , void * ) ;
   void *qp_context ;
   u32 qp_num ;
   enum ib_qp_type qp_type ;
};
#line 1323 "include/rdma/ib_verbs.h"
struct ib_mr {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   u32 lkey ;
   u32 rkey ;
   atomic_t usecnt ;
};
#line 1332 "include/rdma/ib_verbs.h"
struct ib_mw {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct ib_uobject *uobject ;
   u32 rkey ;
   enum ib_mw_type type ;
};
#line 1340 "include/rdma/ib_verbs.h"
struct ib_fmr {
   struct ib_device *device ;
   struct ib_pd *pd ;
   struct list_head list ;
   u32 lkey ;
   u32 rkey ;
};
#line 1348
enum ib_flow_attr_type {
    IB_FLOW_ATTR_NORMAL = 0,
    IB_FLOW_ATTR_ALL_DEFAULT = 1,
    IB_FLOW_ATTR_MC_DEFAULT = 2,
    IB_FLOW_ATTR_SNIFFER = 3
} ;
#line 1450 "include/rdma/ib_verbs.h"
struct ib_flow_attr {
   enum ib_flow_attr_type type ;
   u16 size ;
   u16 priority ;
   u32 flags ;
   u8 num_of_specs ;
   u8 port ;
};
#line 1459 "include/rdma/ib_verbs.h"
struct ib_flow {
   struct ib_qp *qp ;
   struct ib_uobject *uobject ;
};
#line 1468
struct ib_mad_hdr;
#line 1482
struct ib_pkey_cache;
#line 1482
struct ib_gid_cache;
#line 1482 "include/rdma/ib_verbs.h"
struct ib_cache {
   rwlock_t lock ;
   struct ib_event_handler event_handler ;
   struct ib_pkey_cache **pkey_cache ;
   struct ib_gid_cache **gid_cache ;
   u8 *lmc_cache ;
};
#line 1494 "include/rdma/ib_verbs.h"
struct ib_dma_mapping_ops {
   int (*mapping_error)(struct ib_device * , u64  ) ;
   u64 (*map_single)(struct ib_device * , void * , size_t  , enum dma_data_direction  ) ;
   void (*unmap_single)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   u64 (*map_page)(struct ib_device * , struct page * , unsigned long  , size_t  ,
                   enum dma_data_direction  ) ;
   void (*unmap_page)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   int (*map_sg)(struct ib_device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*unmap_sg)(struct ib_device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_single_for_cpu)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct ib_device * , u64  , size_t  , enum dma_data_direction  ) ;
   void *(*alloc_coherent)(struct ib_device * , size_t  , u64 * , gfp_t  ) ;
   void (*free_coherent)(struct ib_device * , size_t  , void * , u64  ) ;
};
#line 1531
struct iw_cm_verbs;
#line 1532 "include/rdma/ib_verbs.h"
struct ib_port_immutable {
   int pkey_tbl_len ;
   int gid_tbl_len ;
   u32 core_cap_flags ;
   u32 max_mad_size ;
};
#line 1542
enum ldv_32676 {
    IB_DEV_UNINITIALIZED = 0,
    IB_DEV_REGISTERED = 1,
    IB_DEV_UNREGISTERED = 2
} ;
#line 1548 "include/rdma/ib_verbs.h"
struct ib_device {
   struct device *dma_device ;
   char name[64U] ;
   struct list_head event_handler_list ;
   spinlock_t event_handler_lock ;
   spinlock_t client_data_lock ;
   struct list_head core_list ;
   struct list_head client_data_list ;
   struct ib_cache cache ;
   struct ib_port_immutable *port_immutable ;
   int num_comp_vectors ;
   struct iw_cm_verbs *iwcm ;
   int (*get_protocol_stats)(struct ib_device * , union rdma_protocol_stats * ) ;
   int (*query_device)(struct ib_device * , struct ib_device_attr * , struct ib_udata * ) ;
   int (*query_port)(struct ib_device * , u8  , struct ib_port_attr * ) ;
   enum rdma_link_layer (*get_link_layer)(struct ib_device * , u8  ) ;
   int (*query_gid)(struct ib_device * , u8  , int  , union ib_gid * ) ;
   int (*query_pkey)(struct ib_device * , u8  , u16  , u16 * ) ;
   int (*modify_device)(struct ib_device * , int  , struct ib_device_modify * ) ;
   int (*modify_port)(struct ib_device * , u8  , int  , struct ib_port_modify * ) ;
   struct ib_ucontext *(*alloc_ucontext)(struct ib_device * , struct ib_udata * ) ;
   int (*dealloc_ucontext)(struct ib_ucontext * ) ;
   int (*mmap)(struct ib_ucontext * , struct vm_area_struct * ) ;
   struct ib_pd *(*alloc_pd)(struct ib_device * , struct ib_ucontext * , struct ib_udata * ) ;
   int (*dealloc_pd)(struct ib_pd * ) ;
   struct ib_ah *(*create_ah)(struct ib_pd * , struct ib_ah_attr * ) ;
   int (*modify_ah)(struct ib_ah * , struct ib_ah_attr * ) ;
   int (*query_ah)(struct ib_ah * , struct ib_ah_attr * ) ;
   int (*destroy_ah)(struct ib_ah * ) ;
   struct ib_srq *(*create_srq)(struct ib_pd * , struct ib_srq_init_attr * , struct ib_udata * ) ;
   int (*modify_srq)(struct ib_srq * , struct ib_srq_attr * , enum ib_srq_attr_mask  ,
                     struct ib_udata * ) ;
   int (*query_srq)(struct ib_srq * , struct ib_srq_attr * ) ;
   int (*destroy_srq)(struct ib_srq * ) ;
   int (*post_srq_recv)(struct ib_srq * , struct ib_recv_wr * , struct ib_recv_wr ** ) ;
   struct ib_qp *(*create_qp)(struct ib_pd * , struct ib_qp_init_attr * , struct ib_udata * ) ;
   int (*modify_qp)(struct ib_qp * , struct ib_qp_attr * , int  , struct ib_udata * ) ;
   int (*query_qp)(struct ib_qp * , struct ib_qp_attr * , int  , struct ib_qp_init_attr * ) ;
   int (*destroy_qp)(struct ib_qp * ) ;
   int (*post_send)(struct ib_qp * , struct ib_send_wr * , struct ib_send_wr ** ) ;
   int (*post_recv)(struct ib_qp * , struct ib_recv_wr * , struct ib_recv_wr ** ) ;
   struct ib_cq *(*create_cq)(struct ib_device * , struct ib_cq_init_attr  const  * ,
                              struct ib_ucontext * , struct ib_udata * ) ;
   int (*modify_cq)(struct ib_cq * , u16  , u16  ) ;
   int (*destroy_cq)(struct ib_cq * ) ;
   int (*resize_cq)(struct ib_cq * , int  , struct ib_udata * ) ;
   int (*poll_cq)(struct ib_cq * , int  , struct ib_wc * ) ;
   int (*peek_cq)(struct ib_cq * , int  ) ;
   int (*req_notify_cq)(struct ib_cq * , enum ib_cq_notify_flags  ) ;
   int (*req_ncomp_notif)(struct ib_cq * , int  ) ;
   struct ib_mr *(*get_dma_mr)(struct ib_pd * , int  ) ;
   struct ib_mr *(*reg_phys_mr)(struct ib_pd * , struct ib_phys_buf * , int  , int  ,
                                u64 * ) ;
   struct ib_mr *(*reg_user_mr)(struct ib_pd * , u64  , u64  , u64  , int  , struct ib_udata * ) ;
   int (*rereg_user_mr)(struct ib_mr * , int  , u64  , u64  , u64  , int  , struct ib_pd * ,
                        struct ib_udata * ) ;
   int (*query_mr)(struct ib_mr * , struct ib_mr_attr * ) ;
   int (*dereg_mr)(struct ib_mr * ) ;
   int (*destroy_mr)(struct ib_mr * ) ;
   struct ib_mr *(*create_mr)(struct ib_pd * , struct ib_mr_init_attr * ) ;
   struct ib_mr *(*alloc_fast_reg_mr)(struct ib_pd * , int  ) ;
   struct ib_fast_reg_page_list *(*alloc_fast_reg_page_list)(struct ib_device * ,
                                                             int  ) ;
   void (*free_fast_reg_page_list)(struct ib_fast_reg_page_list * ) ;
   int (*rereg_phys_mr)(struct ib_mr * , int  , struct ib_pd * , struct ib_phys_buf * ,
                        int  , int  , u64 * ) ;
   struct ib_mw *(*alloc_mw)(struct ib_pd * , enum ib_mw_type  ) ;
   int (*bind_mw)(struct ib_qp * , struct ib_mw * , struct ib_mw_bind * ) ;
   int (*dealloc_mw)(struct ib_mw * ) ;
   struct ib_fmr *(*alloc_fmr)(struct ib_pd * , int  , struct ib_fmr_attr * ) ;
   int (*map_phys_fmr)(struct ib_fmr * , u64 * , int  , u64  ) ;
   int (*unmap_fmr)(struct list_head * ) ;
   int (*dealloc_fmr)(struct ib_fmr * ) ;
   int (*attach_mcast)(struct ib_qp * , union ib_gid * , u16  ) ;
   int (*detach_mcast)(struct ib_qp * , union ib_gid * , u16  ) ;
   int (*process_mad)(struct ib_device * , int  , u8  , struct ib_wc  const  * , struct ib_grh  const  * ,
                      struct ib_mad_hdr  const  * , size_t  , struct ib_mad_hdr * ,
                      size_t * , u16 * ) ;
   struct ib_xrcd *(*alloc_xrcd)(struct ib_device * , struct ib_ucontext * , struct ib_udata * ) ;
   int (*dealloc_xrcd)(struct ib_xrcd * ) ;
   struct ib_flow *(*create_flow)(struct ib_qp * , struct ib_flow_attr * , int  ) ;
   int (*destroy_flow)(struct ib_flow * ) ;
   int (*check_mr_status)(struct ib_mr * , u32  , struct ib_mr_status * ) ;
   struct ib_dma_mapping_ops *dma_ops ;
   struct module *owner ;
   struct device dev ;
   struct kobject *ports_parent ;
   struct list_head port_list ;
   enum ldv_32676 reg_state ;
   int uverbs_abi_ver ;
   u64 uverbs_cmd_mask ;
   u64 uverbs_ex_cmd_mask ;
   char node_desc[64U] ;
   __be64 node_guid ;
   u32 local_dma_lkey ;
   u8 node_type ;
   u8 phys_port_cnt ;
   int (*get_port_immutable)(struct ib_device * , u8  , struct ib_port_immutable * ) ;
};
#line 1759 "include/rdma/ib_verbs.h"
struct ib_client {
   char *name ;
   void (*add)(struct ib_device * ) ;
   void (*remove)(struct ib_device * ) ;
   struct list_head list ;
};
#line 249 "include/uapi/rdma/ib_user_mad.h"
struct ib_mad_hdr {
   u8 base_version ;
   u8 mgmt_class ;
   u8 class_version ;
   u8 method ;
   __be16 status ;
   __be16 class_specific ;
   __be64 tid ;
   __be16 attr_id ;
   __be16 resv ;
   __be32 attr_mod ;
};
#line 169 "include/rdma/ib_mad.h"
typedef u64 ib_sa_comp_mask;
#line 751 "include/rdma/ib_mad.h"
struct ib_sa_path_rec {
   __be64 service_id ;
   union ib_gid dgid ;
   union ib_gid sgid ;
   __be16 dlid ;
   __be16 slid ;
   int raw_traffic ;
   __be32 flow_label ;
   u8 hop_limit ;
   u8 traffic_class ;
   int reversible ;
   u8 numb_path ;
   __be16 pkey ;
   __be16 qos_class ;
   u8 sl ;
   u8 mtu_selector ;
   u8 mtu ;
   u8 rate_selector ;
   u8 rate ;
   u8 packet_life_time_selector ;
   u8 packet_life_time ;
   u8 preference ;
   u8 smac[6U] ;
   u8 dmac[6U] ;
   u16 vlan_id ;
};
#line 161 "include/rdma/ib_sa.h"
struct ib_sa_mcmember_rec {
   union ib_gid mgid ;
   union ib_gid port_gid ;
   __be32 qkey ;
   __be16 mlid ;
   u8 mtu_selector ;
   u8 mtu ;
   u8 traffic_class ;
   __be16 pkey ;
   u8 rate_selector ;
   u8 rate ;
   u8 packet_life_time_selector ;
   u8 packet_life_time ;
   u8 sl ;
   __be32 flow_label ;
   u8 hop_limit ;
   u8 scope ;
   u8 join_state ;
   int proxy_join ;
};
#line 278 "include/rdma/ib_sa.h"
struct ib_sa_client {
   atomic_t users ;
   struct completion comp ;
};
#line 294
struct ib_sa_query;
#line 311 "include/rdma/ib_sa.h"
struct ib_sa_multicast {
   struct ib_sa_mcmember_rec rec ;
   ib_sa_comp_mask comp_mask ;
   int (*callback)(int  , struct ib_sa_multicast * ) ;
   void *context ;
};
#line 465 "include/rdma/ib_sa.h"
struct ipoib_header {
   __be16 proto ;
   u16 reserved ;
};
#line 133 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_cb {
   struct qdisc_skb_cb qdisc_cb ;
   u8 hwaddr[20U] ;
};
#line 144
struct ipoib_ah;
#line 144 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_mcast {
   struct ib_sa_mcmember_rec mcmember ;
   struct ib_sa_multicast *mc ;
   struct ipoib_ah *ah ;
   struct rb_node rb_node ;
   struct list_head list ;
   unsigned long created ;
   unsigned long backoff ;
   unsigned long delay_until ;
   unsigned long flags ;
   unsigned char logcount ;
   struct list_head neigh_list ;
   struct sk_buff_head pkt_queue ;
   struct net_device *dev ;
   struct completion done ;
};
#line 168 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_rx_buf {
   struct sk_buff *skb ;
   u64 mapping[2U] ;
};
#line 173 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_tx_buf {
   struct sk_buff *skb ;
   u64 mapping[18U] ;
};
#line 178 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_cm_tx_buf {
   struct sk_buff *skb ;
   u64 mapping ;
};
#line 183
struct ib_cm_id;
#line 196
struct ipoib_cm_rx_buf;
#line 234
struct ipoib_neigh;
#line 234
struct ipoib_path;
#line 234 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_cm_tx {
   struct ib_cm_id *id ;
   struct ib_qp *qp ;
   struct list_head list ;
   struct net_device *dev ;
   struct ipoib_neigh *neigh ;
   struct ipoib_path *path ;
   struct ipoib_cm_tx_buf *tx_ring ;
   unsigned int tx_head ;
   unsigned int tx_tail ;
   unsigned long flags ;
   u32 mtu ;
};
#line 248 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_cm_rx_buf {
   struct sk_buff *skb ;
   u64 mapping[16U] ;
};
#line 253 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_cm_dev_priv {
   struct ib_srq *srq ;
   struct ipoib_cm_rx_buf *srq_ring ;
   struct ib_cm_id *id ;
   struct list_head passive_ids ;
   struct list_head rx_error_list ;
   struct list_head rx_flush_list ;
   struct list_head rx_drain_list ;
   struct list_head rx_reap_list ;
   struct work_struct start_task ;
   struct work_struct reap_task ;
   struct work_struct skb_task ;
   struct work_struct rx_reap_task ;
   struct delayed_work stale_task ;
   struct sk_buff_head skb_queue ;
   struct list_head start_list ;
   struct list_head reap_list ;
   struct ib_wc ibwc[4U] ;
   struct ib_sge rx_sge[16U] ;
   struct ib_recv_wr rx_wr ;
   int nonsrq_conn_qp ;
   int max_cm_mtu ;
   int num_frags ;
};
#line 278 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_ethtool_st {
   u16 coalesce_usecs ;
   u16 max_coalesced_frames ;
};
#line 283
struct ipoib_neigh_table;
#line 284 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_neigh_hash {
   struct ipoib_neigh_table *ntbl ;
   struct ipoib_neigh **buckets ;
   struct callback_head rcu ;
   u32 mask ;
   u32 size ;
};
#line 293 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_neigh_table {
   struct ipoib_neigh_hash *htbl ;
   atomic_t entries ;
   struct completion flushed ;
   struct completion deleted ;
};
#line 300
struct ipoib_dev_priv;
#line 305 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_dev_priv {
   spinlock_t lock ;
   struct net_device *dev ;
   struct napi_struct napi ;
   unsigned long flags ;
   struct rw_semaphore vlan_rwsem ;
   struct rb_root path_tree ;
   struct list_head path_list ;
   struct ipoib_neigh_table ntbl ;
   struct ipoib_mcast *broadcast ;
   struct list_head multicast_list ;
   struct rb_root multicast_tree ;
   struct workqueue_struct *wq ;
   struct delayed_work mcast_task ;
   struct work_struct carrier_on_task ;
   struct work_struct flush_light ;
   struct work_struct flush_normal ;
   struct work_struct flush_heavy ;
   struct work_struct restart_task ;
   struct delayed_work ah_reap_task ;
   struct delayed_work neigh_reap_task ;
   struct ib_device *ca ;
   u8 port ;
   u16 pkey ;
   u16 pkey_index ;
   struct ib_pd *pd ;
   struct ib_mr *mr ;
   struct ib_cq *recv_cq ;
   struct ib_cq *send_cq ;
   struct ib_qp *qp ;
   u32 qkey ;
   union ib_gid local_gid ;
   u16 local_lid ;
   unsigned int admin_mtu ;
   unsigned int mcast_mtu ;
   unsigned int max_ib_mtu ;
   struct ipoib_rx_buf *rx_ring ;
   struct ipoib_tx_buf *tx_ring ;
   unsigned int tx_head ;
   unsigned int tx_tail ;
   struct ib_sge tx_sge[18U] ;
   struct ib_send_wr tx_wr ;
   unsigned int tx_outstanding ;
   struct ib_wc send_wc[16U] ;
   struct ib_recv_wr rx_wr ;
   struct ib_sge rx_sge[2U] ;
   struct ib_wc ibwc[4U] ;
   struct list_head dead_ahs ;
   struct ib_event_handler event_handler ;
   struct net_device *parent ;
   struct list_head child_intfs ;
   struct list_head list ;
   int child_type ;
   struct ipoib_cm_dev_priv cm ;
   struct list_head fs_list ;
   struct dentry *mcg_dentry ;
   struct dentry *path_dentry ;
   int hca_caps ;
   struct ipoib_ethtool_st ethtool ;
   struct timer_list poll_timer ;
};
#line 395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_ah {
   struct net_device *dev ;
   struct ib_ah *ah ;
   struct list_head list ;
   struct kref ref ;
   unsigned int last_send ;
};
#line 403 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_path {
   struct net_device *dev ;
   struct ib_sa_path_rec pathrec ;
   struct ipoib_ah *ah ;
   struct sk_buff_head queue ;
   struct list_head neigh_list ;
   int query_id ;
   struct ib_sa_query *query ;
   struct completion done ;
   struct rb_node rb_node ;
   struct list_head list ;
   int valid ;
};
#line 420 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_neigh {
   struct ipoib_ah *ah ;
   struct ipoib_cm_tx *cm ;
   u8 daddr[20U] ;
   struct sk_buff_head queue ;
   struct net_device *dev ;
   struct list_head list ;
   struct ipoib_neigh *hnext ;
   struct callback_head rcu ;
   atomic_t refcnt ;
   unsigned long alive ;
};
#line 517
struct ipoib_path_iter;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
struct ipoib_path_iter {
   struct net_device *dev ;
   struct ipoib_path path ;
};
#line 890 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
union __anonunion___u_362 {
   struct ipoib_neigh_hash *__val ;
   char __c[1U] ;
};
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
union __anonunion___u_364 {
   struct ipoib_neigh *__val ;
   char __c[1U] ;
};
#line 898 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
union __anonunion___u_366 {
   struct ipoib_neigh *__val ;
   char __c[1U] ;
};
#line 2152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 2163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 2174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 2193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 2204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef bool ldv_func_ret_type___3;
#line 2215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef bool ldv_func_ret_type___4;
#line 2226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 2255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef bool ldv_func_ret_type___6;
#line 2290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
typedef bool ldv_func_ret_type___7;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 39 "include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 243 "include/linux/timer.h"
enum hrtimer_restart;
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 217 "./include/uapi/asm-generic/fcntl.h"
enum ldv_21443 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_21443 socket_state;
#line 72 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 215 "include/linux/skbuff.h"
struct skb_frag_struct;
#line 215 "include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 216 "include/linux/skbuff.h"
struct __anonstruct_page_225 {
   struct page *p ;
};
#line 216 "include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_225 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 249 "include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};
#line 319 "include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 767
struct rtable;
#line 97 "include/linux/security.h"
struct xfrm_policy;
#line 98
struct xfrm_state;
#line 114
struct request_sock;
#line 331 "include/linux/netdevice.h"
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
} ;
#line 339 "include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 131 "include/linux/uaccess.h"
struct page_counter {
   atomic_long_t count ;
   unsigned long limit ;
   struct page_counter *parent ;
   unsigned long watermark ;
   unsigned long failcnt ;
};
#line 170 "./arch/x86/include/asm/cacheflush.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 49 "include/uapi/linux/filter.h"
struct bpf_insn {
   __u8 code ;
   unsigned char dst_reg : 4 ;
   unsigned char src_reg : 4 ;
   __s16 off ;
   __s32 imm ;
};
#line 81 "include/uapi/linux/bpf.h"
enum bpf_prog_type {
    BPF_PROG_TYPE_UNSPEC = 0,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
    BPF_PROG_TYPE_KPROBE = 2,
    BPF_PROG_TYPE_SCHED_CLS = 3,
    BPF_PROG_TYPE_SCHED_ACT = 4
} ;
#line 273
struct bpf_prog_aux;
#line 314 "include/linux/filter.h"
struct sock_fprog_kern {
   u16 len ;
   struct sock_filter *filter ;
};
#line 325 "include/linux/filter.h"
union __anonunion____missing_field_name_328 {
   struct sock_filter insns[0U] ;
   struct bpf_insn insnsi[0U] ;
};
#line 325 "include/linux/filter.h"
struct bpf_prog {
   u16 pages ;
   bool jited ;
   bool gpl_compatible ;
   u32 len ;
   enum bpf_prog_type type ;
   struct bpf_prog_aux *aux ;
   struct sock_fprog_kern *orig_prog ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct bpf_insn  const  * ) ;
   union __anonunion____missing_field_name_328 __annonCompField99 ;
};
#line 342 "include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   struct callback_head rcu ;
   struct bpf_prog *prog ;
};
#line 101 "include/linux/rculist_nulls.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 519 "include/net/neighbour.h"
struct dn_route;
#line 519 "include/net/neighbour.h"
union __anonunion____missing_field_name_339 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 519 "include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sock * , struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion____missing_field_name_339 __annonCompField100 ;
};
#line 124 "include/net/sock.h"
struct __anonstruct_socket_lock_t_340 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 124 "include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_340 socket_lock_t;
#line 124
struct proto;
#line 130 "include/net/sock.h"
typedef __u32 __portpair;
#line 131 "include/net/sock.h"
typedef __u64 __addrpair;
#line 132 "include/net/sock.h"
struct __anonstruct____missing_field_name_342 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_341 {
   __addrpair skc_addrpair ;
   struct __anonstruct____missing_field_name_342 __annonCompField101 ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_343 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 132 "include/net/sock.h"
struct __anonstruct____missing_field_name_345 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_344 {
   __portpair skc_portpair ;
   struct __anonstruct____missing_field_name_345 __annonCompField104 ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_346 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 132 "include/net/sock.h"
union __anonunion____missing_field_name_347 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 132 "include/net/sock.h"
struct sock_common {
   union __anonunion____missing_field_name_341 __annonCompField102 ;
   union __anonunion____missing_field_name_343 __annonCompField103 ;
   union __anonunion____missing_field_name_344 __annonCompField105 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 1 ;
   unsigned char skc_ipv6only : 1 ;
   unsigned char skc_net_refcnt : 1 ;
   int skc_bound_dev_if ;
   union __anonunion____missing_field_name_346 __annonCompField106 ;
   struct proto *skc_prot ;
   possible_net_t skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   atomic64_t skc_cookie ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion____missing_field_name_347 __annonCompField107 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 219
struct cg_proto;
#line 220 "include/net/sock.h"
struct __anonstruct_sk_backlog_348 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 220 "include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_348 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   u16 sk_incoming_cpu ;
   __u32 sk_txhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned char sk_shutdown : 2 ;
   unsigned char sk_no_check_tx : 1 ;
   unsigned char sk_no_check_rx : 1 ;
   unsigned char sk_userlocks : 4 ;
   unsigned char sk_protocol ;
   unsigned short sk_type ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   u32 sk_ack_backlog ;
   u32 sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   u16 sk_tsflags ;
   u32 sk_tskey ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 906
struct request_sock_ops;
#line 907
struct timewait_sock_ops;
#line 908
struct inet_hashinfo;
#line 909
struct raw_hashinfo;
#line 923
struct udp_table;
#line 923 "include/net/sock.h"
union __anonunion_h_351 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 923 "include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct sock * , struct msghdr * , size_t  , int  , int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock  const  * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_351 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 1046 "include/net/sock.h"
struct cg_proto {
   struct page_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 174 "include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct request_sock  const  * ) ;
};
#line 46 "include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   struct sock *rsk_listener ;
   u16 mss ;
   u8 num_retrans ;
   unsigned char cookie_ts : 1 ;
   unsigned char num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   struct timer_list rsk_timer ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 *saved_syn ;
   u32 secid ;
   u32 peer_secid ;
};
#line 330 "include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 132 "include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   unsigned char res1 : 4 ;
   unsigned char doff : 4 ;
   unsigned char fin : 1 ;
   unsigned char syn : 1 ;
   unsigned char rst : 1 ;
   unsigned char psh : 1 ;
   unsigned char ack : 1 ;
   unsigned char urg : 1 ;
   unsigned char ece : 1 ;
   unsigned char cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};
#line 421 "include/rdma/ib_sa.h"
enum ipoib_flush_level {
    IPOIB_FLUSH_LIGHT = 0,
    IPOIB_FLUSH_NORMAL = 1,
    IPOIB_FLUSH_HEAVY = 2
} ;
#line 300 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_qp_state_validate {
   struct work_struct work ;
   struct ipoib_dev_priv *priv ;
};
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
typedef int ldv_func_ret_type___8;
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
typedef bool ldv_func_ret_type___10;
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
typedef int ldv_func_ret_type___11;
#line 428 "./arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 197 "./arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 191 "include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 67 "include/linux/igmp.h"
struct ip_sf_list {
   struct ip_sf_list *sf_next ;
   __be32 sf_inaddr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 76 "include/linux/igmp.h"
union __anonunion____missing_field_name_325 {
   struct ip_mc_list *next ;
   struct ip_mc_list *next_rcu ;
};
#line 76 "include/linux/igmp.h"
struct ip_mc_list {
   struct in_device *interface ;
   __be32 multiaddr ;
   unsigned int sfmode ;
   struct ip_sf_list *sources ;
   struct ip_sf_list *tomb ;
   unsigned long sfcount[2U] ;
   union __anonunion____missing_field_name_325 __annonCompField95 ;
   struct ip_mc_list *next_hash ;
   struct timer_list timer ;
   int users ;
   atomic_t refcnt ;
   spinlock_t lock ;
   char tm_running ;
   char reporter ;
   char unsolicit_count ;
   char loaded ;
   unsigned char gsquery ;
   unsigned char crcount ;
   struct callback_head rcu ;
};
#line 134 "include/linux/igmp.h"
struct ipv4_devconf {
   void *sysctl ;
   int data[29U] ;
   unsigned long state[1U] ;
};
#line 20 "include/linux/inetdevice.h"
struct in_ifaddr;
#line 20 "include/linux/inetdevice.h"
struct in_device {
   struct net_device *dev ;
   atomic_t refcnt ;
   int dead ;
   struct in_ifaddr *ifa_list ;
   struct ip_mc_list *mc_list ;
   struct ip_mc_list **mc_hash ;
   int mc_count ;
   spinlock_t mc_tomb_lock ;
   struct ip_mc_list *mc_tomb ;
   unsigned long mr_v1_seen ;
   unsigned long mr_v2_seen ;
   unsigned long mr_maxdelay ;
   unsigned char mr_qrv ;
   unsigned char mr_gq_running ;
   unsigned char mr_ifc_count ;
   struct timer_list mr_gq_timer ;
   struct timer_list mr_ifc_timer ;
   struct neigh_parms *arp_parms ;
   struct ipv4_devconf cnf ;
   struct callback_head callback_head ;
};
#line 71 "include/linux/inetdevice.h"
struct in_ifaddr {
   struct hlist_node hash ;
   struct in_ifaddr *ifa_next ;
   struct in_device *ifa_dev ;
   struct callback_head callback_head ;
   __be32 ifa_local ;
   __be32 ifa_address ;
   __be32 ifa_mask ;
   __be32 ifa_broadcast ;
   unsigned char ifa_scope ;
   unsigned char ifa_prefixlen ;
   __u32 ifa_flags ;
   char ifa_label[16U] ;
   __u32 ifa_valid_lft ;
   __u32 ifa_preferred_lft ;
   unsigned long ifa_cstamp ;
   unsigned long ifa_tstamp ;
};
#line 508 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_mcast_iter;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
struct ipoib_mcast_iter {
   struct net_device *dev ;
   union ib_gid mgid ;
   unsigned long created ;
   unsigned int queuelen ;
   unsigned int complete ;
   unsigned int send_only ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 489 "./arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_33 {
   unsigned long seg ;
};
#line 489 "./arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_33 mm_segment_t;
#line 131 "include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 43 "include/rdma/ib_cm.h"
enum ib_cm_state {
    IB_CM_IDLE = 0,
    IB_CM_LISTEN = 1,
    IB_CM_REQ_SENT = 2,
    IB_CM_REQ_RCVD = 3,
    IB_CM_MRA_REQ_SENT = 4,
    IB_CM_MRA_REQ_RCVD = 5,
    IB_CM_REP_SENT = 6,
    IB_CM_REP_RCVD = 7,
    IB_CM_MRA_REP_SENT = 8,
    IB_CM_MRA_REP_RCVD = 9,
    IB_CM_ESTABLISHED = 10,
    IB_CM_DREQ_SENT = 11,
    IB_CM_DREQ_RCVD = 12,
    IB_CM_TIMEWAIT = 13,
    IB_CM_SIDR_REQ_SENT = 14,
    IB_CM_SIDR_REQ_RCVD = 15
} ;
#line 62
enum ib_cm_lap_state {
    IB_CM_LAP_UNINIT = 0,
    IB_CM_LAP_IDLE = 1,
    IB_CM_LAP_SENT = 2,
    IB_CM_LAP_RCVD = 3,
    IB_CM_MRA_LAP_SENT = 4,
    IB_CM_MRA_LAP_RCVD = 5
} ;
#line 71
enum ib_cm_event_type {
    IB_CM_REQ_ERROR = 0,
    IB_CM_REQ_RECEIVED = 1,
    IB_CM_REP_ERROR = 2,
    IB_CM_REP_RECEIVED = 3,
    IB_CM_RTU_RECEIVED = 4,
    IB_CM_USER_ESTABLISHED = 5,
    IB_CM_DREQ_ERROR = 6,
    IB_CM_DREQ_RECEIVED = 7,
    IB_CM_DREP_RECEIVED = 8,
    IB_CM_TIMEWAIT_EXIT = 9,
    IB_CM_MRA_RECEIVED = 10,
    IB_CM_REJ_RECEIVED = 11,
    IB_CM_LAP_ERROR = 12,
    IB_CM_LAP_RECEIVED = 13,
    IB_CM_APR_RECEIVED = 14,
    IB_CM_SIDR_REQ_ERROR = 15,
    IB_CM_SIDR_REQ_RECEIVED = 16,
    IB_CM_SIDR_REP_RECEIVED = 17
} ;
#line 111 "include/rdma/ib_cm.h"
struct ib_cm_req_event_param {
   struct ib_cm_id *listen_id ;
   u8 port ;
   struct ib_sa_path_rec *primary_path ;
   struct ib_sa_path_rec *alternate_path ;
   __be64 remote_ca_guid ;
   u32 remote_qkey ;
   u32 remote_qpn ;
   enum ib_qp_type qp_type ;
   u32 starting_psn ;
   u8 responder_resources ;
   u8 initiator_depth ;
   unsigned char local_cm_response_timeout : 5 ;
   unsigned char flow_control : 1 ;
   unsigned char remote_cm_response_timeout : 5 ;
   unsigned char retry_count : 3 ;
   unsigned char rnr_retry_count : 3 ;
   unsigned char srq : 1 ;
};
#line 136 "include/rdma/ib_cm.h"
struct ib_cm_rep_event_param {
   __be64 remote_ca_guid ;
   u32 remote_qkey ;
   u32 remote_qpn ;
   u32 starting_psn ;
   u8 responder_resources ;
   u8 initiator_depth ;
   unsigned char target_ack_delay : 5 ;
   unsigned char failover_accepted : 2 ;
   unsigned char flow_control : 1 ;
   unsigned char rnr_retry_count : 3 ;
   unsigned char srq : 1 ;
};
#line 150
enum ib_cm_rej_reason {
    IB_CM_REJ_NO_QP = 1,
    IB_CM_REJ_NO_EEC = 2,
    IB_CM_REJ_NO_RESOURCES = 3,
    IB_CM_REJ_TIMEOUT = 4,
    IB_CM_REJ_UNSUPPORTED = 5,
    IB_CM_REJ_INVALID_COMM_ID = 6,
    IB_CM_REJ_INVALID_COMM_INSTANCE = 7,
    IB_CM_REJ_INVALID_SERVICE_ID = 8,
    IB_CM_REJ_INVALID_TRANSPORT_TYPE = 9,
    IB_CM_REJ_STALE_CONN = 10,
    IB_CM_REJ_RDC_NOT_EXIST = 11,
    IB_CM_REJ_INVALID_GID = 12,
    IB_CM_REJ_INVALID_LID = 13,
    IB_CM_REJ_INVALID_SL = 14,
    IB_CM_REJ_INVALID_TRAFFIC_CLASS = 15,
    IB_CM_REJ_INVALID_HOP_LIMIT = 16,
    IB_CM_REJ_INVALID_PACKET_RATE = 17,
    IB_CM_REJ_INVALID_ALT_GID = 18,
    IB_CM_REJ_INVALID_ALT_LID = 19,
    IB_CM_REJ_INVALID_ALT_SL = 20,
    IB_CM_REJ_INVALID_ALT_TRAFFIC_CLASS = 21,
    IB_CM_REJ_INVALID_ALT_HOP_LIMIT = 22,
    IB_CM_REJ_INVALID_ALT_PACKET_RATE = 23,
    IB_CM_REJ_PORT_CM_REDIRECT = 24,
    IB_CM_REJ_PORT_REDIRECT = 25,
    IB_CM_REJ_INVALID_MTU = 26,
    IB_CM_REJ_INSUFFICIENT_RESP_RESOURCES = 27,
    IB_CM_REJ_CONSUMER_DEFINED = 28,
    IB_CM_REJ_INVALID_RNR_RETRY = 29,
    IB_CM_REJ_DUPLICATE_LOCAL_COMM_ID = 30,
    IB_CM_REJ_INVALID_CLASS_VERSION = 31,
    IB_CM_REJ_INVALID_FLOW_LABEL = 32,
    IB_CM_REJ_INVALID_ALT_FLOW_LABEL = 33
} ;
#line 186 "include/rdma/ib_cm.h"
struct ib_cm_rej_event_param {
   enum ib_cm_rej_reason reason ;
   void *ari ;
   u8 ari_length ;
};
#line 192 "include/rdma/ib_cm.h"
struct ib_cm_mra_event_param {
   u8 service_timeout ;
};
#line 196 "include/rdma/ib_cm.h"
struct ib_cm_lap_event_param {
   struct ib_sa_path_rec *alternate_path ;
};
#line 200
enum ib_cm_apr_status {
    IB_CM_APR_SUCCESS = 0,
    IB_CM_APR_INVALID_COMM_ID = 1,
    IB_CM_APR_UNSUPPORTED = 2,
    IB_CM_APR_REJECT = 3,
    IB_CM_APR_REDIRECT = 4,
    IB_CM_APR_IS_CURRENT = 5,
    IB_CM_APR_INVALID_QPN_EECN = 6,
    IB_CM_APR_INVALID_LID = 7,
    IB_CM_APR_INVALID_GID = 8,
    IB_CM_APR_INVALID_FLOW_LABEL = 9,
    IB_CM_APR_INVALID_TCLASS = 10,
    IB_CM_APR_INVALID_HOP_LIMIT = 11,
    IB_CM_APR_INVALID_PACKET_RATE = 12,
    IB_CM_APR_INVALID_SL = 13
} ;
#line 217 "include/rdma/ib_cm.h"
struct ib_cm_apr_event_param {
   enum ib_cm_apr_status ap_status ;
   void *apr_info ;
   u8 info_len ;
};
#line 223 "include/rdma/ib_cm.h"
struct ib_cm_sidr_req_event_param {
   struct ib_cm_id *listen_id ;
   u8 port ;
   u16 pkey ;
};
#line 229
enum ib_cm_sidr_status {
    IB_SIDR_SUCCESS = 0,
    IB_SIDR_UNSUPPORTED = 1,
    IB_SIDR_REJECT = 2,
    IB_SIDR_NO_QP = 3,
    IB_SIDR_REDIRECT = 4,
    IB_SIDR_UNSUPPORTED_VERSION = 5
} ;
#line 238 "include/rdma/ib_cm.h"
struct ib_cm_sidr_rep_event_param {
   enum ib_cm_sidr_status status ;
   u32 qkey ;
   u32 qpn ;
   void *info ;
   u8 info_len ;
};
#line 246 "include/rdma/ib_cm.h"
union __anonunion_param_236 {
   struct ib_cm_req_event_param req_rcvd ;
   struct ib_cm_rep_event_param rep_rcvd ;
   struct ib_cm_rej_event_param rej_rcvd ;
   struct ib_cm_mra_event_param mra_rcvd ;
   struct ib_cm_lap_event_param lap_rcvd ;
   struct ib_cm_apr_event_param apr_rcvd ;
   struct ib_cm_sidr_req_event_param sidr_req_rcvd ;
   struct ib_cm_sidr_rep_event_param sidr_rep_rcvd ;
   enum ib_wc_status send_status ;
};
#line 246 "include/rdma/ib_cm.h"
struct ib_cm_event {
   enum ib_cm_event_type event ;
   union __anonunion_param_236 param ;
   void *private_data ;
};
#line 295 "include/rdma/ib_cm.h"
struct ib_cm_id {
   int (*cm_handler)(struct ib_cm_id * , struct ib_cm_event * ) ;
   void *context ;
   struct ib_device *device ;
   __be64 service_id ;
   __be64 service_mask ;
   enum ib_cm_state state ;
   enum ib_cm_lap_state lap_state ;
   __be32 local_id ;
   __be32 remote_id ;
   u32 remote_cm_qpn ;
};
#line 332 "include/rdma/ib_cm.h"
struct ib_cm_compare_data {
   u32 data[16U] ;
   u32 mask[16U] ;
};
#line 362 "include/rdma/ib_cm.h"
struct ib_cm_req_param {
   struct ib_sa_path_rec *primary_path ;
   struct ib_sa_path_rec *alternate_path ;
   __be64 service_id ;
   u32 qp_num ;
   enum ib_qp_type qp_type ;
   u32 starting_psn ;
   void const   *private_data ;
   u8 private_data_len ;
   u8 peer_to_peer ;
   u8 responder_resources ;
   u8 initiator_depth ;
   u8 remote_cm_response_timeout ;
   u8 flow_control ;
   u8 local_cm_response_timeout ;
   u8 retry_count ;
   u8 rnr_retry_count ;
   u8 max_cm_retries ;
   u8 srq ;
};
#line 393 "include/rdma/ib_cm.h"
struct ib_cm_rep_param {
   u32 qp_num ;
   u32 starting_psn ;
   void const   *private_data ;
   u8 private_data_len ;
   u8 responder_resources ;
   u8 initiator_depth ;
   u8 failover_accepted ;
   u8 flow_control ;
   u8 rnr_retry_count ;
   u8 srq ;
};
#line 183 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_cm_data {
   __be32 qpn ;
   __be32 mtu ;
};
#line 190
enum ipoib_cm_state {
    IPOIB_CM_RX_LIVE = 0,
    IPOIB_CM_RX_ERROR = 1,
    IPOIB_CM_RX_FLUSH = 2
} ;
#line 196 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ipoib_cm_rx {
   struct ib_cm_id *id ;
   struct ib_qp *qp ;
   struct ipoib_cm_rx_buf *rx_ring ;
   struct list_head list ;
   struct net_device *dev ;
   unsigned long jiffies ;
   enum ipoib_cm_state state ;
   int recv_count ;
};
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
struct __anonstruct_t_397 {
   struct ib_recv_wr wr ;
   struct ib_sge sge[16U] ;
};
#line 364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
struct __anonstruct_399 {
   struct ib_recv_wr wr ;
   struct ib_sge sge[16U] ;
};
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
struct __anonstruct_401 {
   struct ib_recv_wr wr ;
   struct ib_sge sge[16U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 520 "include/rdma/ib_verbs.h"
enum ib_rate {
    IB_RATE_PORT_CURRENT = 0,
    IB_RATE_2_5_GBPS = 2,
    IB_RATE_5_GBPS = 5,
    IB_RATE_10_GBPS = 3,
    IB_RATE_20_GBPS = 6,
    IB_RATE_30_GBPS = 4,
    IB_RATE_40_GBPS = 7,
    IB_RATE_60_GBPS = 8,
    IB_RATE_80_GBPS = 9,
    IB_RATE_120_GBPS = 10,
    IB_RATE_14_GBPS = 11,
    IB_RATE_56_GBPS = 12,
    IB_RATE_112_GBPS = 13,
    IB_RATE_168_GBPS = 14,
    IB_RATE_25_GBPS = 15,
    IB_RATE_100_GBPS = 16,
    IB_RATE_200_GBPS = 17,
    IB_RATE_300_GBPS = 18
} ;
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 201 "include/linux/compiler.h"
__inline static void __read_once_size(void const volatile   *p , void *res , int size ) 
{ 


  {
#line 203
  switch (size) {
  case 1: 
#line 204
  *((__u8 *)res) = *((__u8 volatile   *)p);
#line 204
  goto ldv_880;
  case 2: 
#line 205
  *((__u16 *)res) = *((__u16 volatile   *)p);
#line 205
  goto ldv_880;
  case 4: 
#line 206
  *((__u32 *)res) = *((__u32 volatile   *)p);
#line 206
  goto ldv_880;
  case 8: 
#line 207
  *((__u64 *)res) = *((__u64 volatile   *)p);
#line 207
  goto ldv_880;
  default: 
#line 209
  __asm__  volatile   ("": : : "memory");
#line 210
  __builtin_memcpy(res, (void const   *)p, (unsigned long )size);
#line 211
  __asm__  volatile   ("": : : "memory");
  }
  ldv_880: ;
#line 214
  return;
}
}
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 479 "./arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 490
  return (bitpos + 1);
}
}
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 167 "include/uapi/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 172
  tmp = __fswab32(*p);
#line 172
  return (tmp);
}
}
#line 79 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 81
  tmp = __swab32p(p);
#line 81
  return (tmp);
}
}
#line 108 "include/linux/bitops.h"
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 


  {
#line 110
  return ((word << shift) | (word >> (8UL * sizeof(word) - (unsigned long )shift)));
}
}
#line 174 "include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ 
  int tmp___0 ;

  {
#line 178
  tmp___0 = fls64((__u64 )l);
#line 178
  return ((unsigned int )tmp___0);
}
}
#line 61 "include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
#line 63
  tmp = fls_long(n - 1UL);
#line 63
  return (1UL << (int )tmp);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 233
extern void dump_stack(void) ;
#line 393 "include/linux/kernel.h"
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
#line 402
extern int sprintf(char * , char const   *  , ...) ;
#line 417
extern int sscanf(char const   * , char const   *  , ...) ;
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 4
bool ldv_is_err_or_null(void const   *ptr ) ;
#line 5
void *ldv_err_ptr(long error ) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 113
extern void list_del(struct list_head * ) ;
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 274 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
#line 278
  first = list->next;
#line 279
  last = list->prev;
#line 281
  first->prev = prev;
#line 282
  prev->next = first;
#line 284
  last->next = next;
#line 285
  next->prev = last;
#line 286
  return;
}
}
#line 319 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 322
  tmp = list_empty((struct list_head  const  *)list);
#line 322
  if (tmp == 0) {
#line 323
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 324
    INIT_LIST_HEAD(list);
  } else {

  }
#line 326
  return;
}
}
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 295 "include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 63
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 67
extern int strcmp(char const   * , char const   * ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 50
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) ;
#line 13 "./arch/x86/include/asm/cmpxchg.h"
extern void __cmpxchg_wrong_size(void) ;
#line 15
extern void __xadd_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 79 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2, %0; sete %1": "+m" (v->counter),
                       "=qm" (c): "er" (i): "memory");
#line 81
  return ((int )((signed char )c) != 0);
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 116 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  char c ;

  {
#line 118
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 118
  return ((int )((signed char )c) != 0);
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5659: ;
#line 157
  return (__ret + i);
}
}
#line 175 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new ) 
{ 
  int __ret ;
  int __old ;
  int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 177
  __old = old;
#line 177
  __new = new;
#line 177
  switch (4UL) {
  case 1UL: 
#line 177
  __ptr = (u8 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                       "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5679;
  case 2UL: 
#line 177
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                       "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5679;
  case 4UL: 
#line 177
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                       "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5679;
  case 8UL: 
#line 177
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                       "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5679;
  default: 
#line 177
  __cmpxchg_wrong_size();
  }
  ldv_5679: ;
#line 177
  return (__ret);
}
}
#line 194 "./arch/x86/include/asm/atomic.h"
__inline static int __atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int c ;
  int old ;
  long tmp ;
  long tmp___0 ;

  {
#line 197
  c = atomic_read((atomic_t const   *)v);
  ldv_5708: 
#line 199
  tmp = ldv__builtin_expect(c == u, 0L);
#line 199
  if (tmp != 0L) {
#line 200
    goto ldv_5707;
  } else {

  }
#line 201
  old = atomic_cmpxchg(v, c, c + a);
#line 202
  tmp___0 = ldv__builtin_expect(old == c, 1L);
#line 202
  if (tmp___0 != 0L) {
#line 203
    goto ldv_5707;
  } else {

  }
#line 204
  c = old;
#line 205
  goto ldv_5708;
  ldv_5707: ;
#line 206
  return (c);
}
}
#line 15 "include/linux/atomic.h"
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int tmp ;

  {
#line 17
  tmp = __atomic_add_unless(v, a, u);
#line 17
  return (tmp != u);
}
}
#line 7 "include/linux/bottom_half.h"
extern void __local_bh_disable_ip(unsigned long  , unsigned int  ) ;
#line 16 "include/linux/bottom_half.h"
__inline static void local_bh_disable(void) 
{ 


  {
#line 18
  __local_bh_disable_ip(0UL, 512U);
#line 19
  return;
}
}
#line 22
extern void __local_bh_enable_ip(unsigned long  , unsigned int  ) ;
#line 29 "include/linux/bottom_half.h"
__inline static void local_bh_enable(void) 
{ 


  {
#line 31
  __local_bh_enable_ip(0UL, 512U);
#line 32
  return;
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 333
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
#line 337
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
#line 342
extern int lock_is_held(struct lockdep_map * ) ;
#line 545
extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 31
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 34
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 340 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 342
  _raw_spin_lock_irq(& lock->__annonCompField18.rlock);
#line 343
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 358
  return;
}
}
#line 365 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 367
  _raw_spin_unlock_irq(& lock->__annonCompField18.rlock);
#line 368
  return;
}
}
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
#line 373
  return;
}
}
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 84 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 108
extern void down_read(struct rw_semaphore * ) ;
#line 128
extern void up_read(struct rw_semaphore * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 91
extern void wait_for_completion(struct completion * ) ;
#line 106
extern void complete(struct completion * ) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 284
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 215 "include/linux/rcupdate.h"
extern void call_rcu_sched(struct callback_head * , void (*)(struct callback_head * ) ) ;
#line 104 "include/linux/rcutree.h"
extern bool rcu_is_watching(void) ;
#line 447 "include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map ) 
{ 


  {
#line 449
  lock_acquire(map, 0U, 0, 2, 0, (struct lockdep_map *)0, 0UL);
#line 450
  return;
}
}
#line 452 "include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map ) 
{ 


  {
#line 454
  lock_release(map, 1, 0UL);
#line 455
  return;
}
}
#line 458
extern struct lockdep_map rcu_bh_lock_map ;
#line 461
extern int debug_lockdep_rcu_enabled(void) ;
#line 464
extern int rcu_read_lock_bh_held(void) ;
#line 923 "include/linux/rcupdate.h"
__inline static void rcu_read_lock_bh(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 925
  local_bh_disable();
#line 927
  rcu_lock_acquire(& rcu_bh_lock_map);
#line 928
  tmp = debug_lockdep_rcu_enabled();
#line 928
  if (tmp != 0 && ! __warned) {
#line 928
    tmp___0 = rcu_is_watching();
#line 928
    if (tmp___0) {
#line 928
      tmp___1 = 0;
    } else {
#line 928
      tmp___1 = 1;
    }
#line 928
    if (tmp___1) {
#line 928
      __warned = 1;
#line 928
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 929, "rcu_read_lock_bh() used illegally while idle");
    } else {

    }
  } else {

  }
#line 931
  return;
}
}
#line 937 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock_bh(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 939
  tmp = debug_lockdep_rcu_enabled();
#line 939
  if (tmp != 0 && ! __warned) {
#line 939
    tmp___0 = rcu_is_watching();
#line 939
    if (tmp___0) {
#line 939
      tmp___1 = 0;
    } else {
#line 939
      tmp___1 = 1;
    }
#line 939
    if (tmp___1) {
#line 939
      __warned = 1;
#line 939
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 940, "rcu_read_unlock_bh() used illegally while idle");
    } else {

    }
  } else {

  }
#line 941
  rcu_lock_release(& rcu_bh_lock_map);
#line 943
  local_bh_enable();
#line 944
  return;
}
}
#line 88 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 62 "include/linux/rbtree.h"
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
#line 63
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
#line 67
extern struct rb_node *rb_next(struct rb_node  const  * ) ;
#line 69
extern struct rb_node *rb_first(struct rb_root  const  * ) ;
#line 80 "include/linux/rbtree.h"
__inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
                                  struct rb_node **rb_link ) 
{ 
  struct rb_node *tmp ;

  {
#line 83
  node->__rb_parent_color = (unsigned long )parent;
#line 84
  tmp = (struct rb_node *)0;
#line 84
  node->rb_right = tmp;
#line 84
  node->rb_left = tmp;
#line 86
  *rb_link = node;
#line 87
  return;
}
}
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 181
extern void __init_work(struct work_struct * , int  ) ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_23(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_24(struct workqueue_struct *ldv_func_arg1 ) ;
#line 437
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 441
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 445
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 447
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 451
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 460
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 463
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
void ldv_flush_workqueue_14(struct workqueue_struct *ldv_func_arg1 ) ;
#line 471
void ldv_flush_workqueue_16(struct workqueue_struct *ldv_func_arg1 ) ;
#line 475
void ldv_flush_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) ;
#line 479
void ldv_flush_workqueue_20(struct workqueue_struct *ldv_func_arg1 ) ;
#line 491
extern bool cancel_delayed_work(struct delayed_work * ) ;
#line 494
bool ldv_cancel_delayed_work_10(struct delayed_work *ldv_func_arg1 ) ;
#line 498
bool ldv_cancel_delayed_work_11(struct delayed_work *ldv_func_arg1 ) ;
#line 502
bool ldv_cancel_delayed_work_15(struct delayed_work *ldv_func_arg1 ) ;
#line 506
bool ldv_cancel_delayed_work_19(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_5(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_6(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 41 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_9_2  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_20  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_12_3  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_1_1  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_14_2  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_9_3  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_14_0  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_13_3  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_14  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_17  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_10_1  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct ethtool_coalesce *ipoib_ethtool_ops_group0  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_7_2  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_19  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_3  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_27  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_9  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_13_0  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_7_1  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_timer_15_3  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_3_3  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct timer_list *ldv_timer_list_15_0  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_11_0  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_0  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct net_device *ipoib_link_ops_group2  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_7  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_1_3  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_4_0  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_12_3  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_7_2  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_26  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_13_1  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_28  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_7_0  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_6_0  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct inode *ipoib_path_fops_group1  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_8_3  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_timer_15_1  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_13_2  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_14_3  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_5_2  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_7_1  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_6_2  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_2_1  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct inode *ipoib_mcg_fops_group1  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_8  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct device *dev_attr_mode_group1  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_15  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_8_0  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_14_2  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_21  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_13_2  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_8_0  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct net_device  const  *ipoib_link_ops_group0  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_timer_15_0  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_14_3  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_3_0  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_11_1  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_10_0  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_12_2  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct timer_list *ldv_timer_list_15_3  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct device_attribute *dev_attr_umcast_group0  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct nlattr **ipoib_link_ops_group3  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_5_3  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
loff_t *ipoib_mcg_seq_ops_group3  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_6_1  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_10  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_7_0  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_12_0  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_4_1  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_10_1  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_7_3  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_2  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_25  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_2_0  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_10_0  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_4_2  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct seq_file *ipoib_path_seq_ops_group1  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_11  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_1_2  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_18  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_5_0  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_9_1  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_2_2  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_11_3  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_11_2  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_30  ;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct device_attribute *dev_attr_mode_group0  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_8_1  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_0  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct file *ipoib_mcg_fops_group2  ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_12  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_13_1  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_22  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct net_device *ipoib_netdev_ops_group1  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_29  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_8_1  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_6_0  ;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_9_0  ;
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_6_1  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ref_cnt  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_10_3  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_8_3  ;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_23  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct timer_list *ldv_timer_list_15_2  ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void *ipoib_path_seq_ops_group2  ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_6  ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_5_0  ;
#line 138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct timer_list *ldv_timer_list_15_1  ;
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct device *dev_attr_umcast_group1  ;
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_2  ;
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct nlattr **ipoib_link_ops_group1  ;
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_5_1  ;
#line 143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_3  ;
#line 144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void *ipoib_mcg_seq_ops_group2  ;
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_12_1  ;
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_11_0  ;
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_1_0  ;
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_11_2  ;
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_4  ;
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_9_0  ;
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_9_3  ;
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_10_2  ;
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_9_2  ;
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_13_0  ;
#line 155 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_6_3  ;
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_5_2  ;
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_9_1  ;
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_timer_15_2  ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_5  ;
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_5_3  ;
#line 161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_14_1  ;
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_13  ;
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct file *ipoib_path_fops_group2  ;
#line 164 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_3_2  ;
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_13_3  ;
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
loff_t *ipoib_path_seq_ops_group3  ;
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct seq_file *ipoib_mcg_seq_ops_group1  ;
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_11_1  ;
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct ib_device *ipoib_client_group0  ;
#line 171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_7_3  ;
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_24  ;
#line 173 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_12_0  ;
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_14_0  ;
#line 175 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_1  ;
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_12_1  ;
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct net_device *ipoib_ethtool_ops_group1  ;
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_6_2  ;
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_10_2  ;
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_8_2  ;
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_4_3  ;
#line 182 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_3_1  ;
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_state_variable_16  ;
#line 184 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_12_2  ;
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_5_1  ;
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_6_3  ;
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_14_1  ;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_8_2  ;
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_4_1  ;
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_2_3  ;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_work_10_3  ;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
struct work_struct *ldv_work_struct_11_3  ;
#line 196
void activate_work_5(struct work_struct *work , int state ) ;
#line 197
void ldv_initialize_ethtool_ops_22(void) ;
#line 199
void work_init_9(void) ;
#line 200
void work_init_5(void) ;
#line 201
void invoke_work_8(void) ;
#line 202
void call_and_disable_all_4(int state ) ;
#line 203
void ldv_initialize_device_attribute_26(void) ;
#line 204
void activate_work_1(struct work_struct *work , int state ) ;
#line 205
void ldv_net_device_ops_28(void) ;
#line 206
void call_and_disable_work_3(struct work_struct *work ) ;
#line 207
void ldv_file_operations_16(void) ;
#line 208
void disable_work_7(struct work_struct *work ) ;
#line 209
void disable_work_3(struct work_struct *work ) ;
#line 213
void work_init_1(void) ;
#line 215
void invoke_work_4(void) ;
#line 218
void ldv_initialize_ib_client_30(void) ;
#line 219
void call_and_disable_all_11(int state ) ;
#line 221
void activate_work_6(struct work_struct *work , int state ) ;
#line 222
void ldv_initialize_device_attribute_20(void) ;
#line 223
void call_and_disable_work_7(struct work_struct *work ) ;
#line 225
void work_init_8(void) ;
#line 226
void activate_work_2(struct work_struct *work , int state ) ;
#line 227
void work_init_14(void) ;
#line 232
void work_init_10(void) ;
#line 233
void invoke_work_5(void) ;
#line 234
void call_and_disable_work_8(struct work_struct *work ) ;
#line 236
void disable_work_4(struct work_struct *work ) ;
#line 237
void work_init_13(void) ;
#line 238
void work_init_4(void) ;
#line 241
void invoke_work_1(void) ;
#line 243
void disable_work_8(struct work_struct *work ) ;
#line 245
void call_and_disable_all_3(int state ) ;
#line 246
void call_and_disable_work_4(struct work_struct *work ) ;
#line 247
void work_init_3(void) ;
#line 248
void call_and_disable_all_7(int state ) ;
#line 250
void call_and_disable_work_1(struct work_struct *work ) ;
#line 252
void invoke_work_6(void) ;
#line 253
void work_init_11(void) ;
#line 254
void activate_work_11(struct work_struct *work , int state ) ;
#line 255
void call_and_disable_all_2(int state ) ;
#line 256
void disable_work_11(struct work_struct *work ) ;
#line 258
void activate_work_3(struct work_struct *work , int state ) ;
#line 260
void work_init_7(void) ;
#line 261
void invoke_work_7(void) ;
#line 262
void disable_work_5(struct work_struct *work ) ;
#line 263
void timer_init_15(void) ;
#line 264
void call_and_disable_all_8(int state ) ;
#line 266
void disable_work_1(struct work_struct *work ) ;
#line 267
void call_and_disable_all_6(int state ) ;
#line 269
void call_and_disable_work_5(struct work_struct *work ) ;
#line 271
void activate_work_8(struct work_struct *work , int state ) ;
#line 272
void invoke_work_2(void) ;
#line 274
void activate_work_4(struct work_struct *work , int state ) ;
#line 275
void call_and_disable_all_5(int state ) ;
#line 277
void work_init_2(void) ;
#line 278
void call_and_disable_all_1(int state ) ;
#line 280
void disable_work_6(struct work_struct *work ) ;
#line 281
void work_init_6(void) ;
#line 282
void work_init_12(void) ;
#line 287
void activate_work_7(struct work_struct *work , int state ) ;
#line 288
void ldv_file_operations_18(void) ;
#line 290
void disable_work_2(struct work_struct *work ) ;
#line 291
void invoke_work_3(void) ;
#line 294
void call_and_disable_work_6(struct work_struct *work ) ;
#line 296
void ldv_initialize_rtnl_link_ops_21(void) ;
#line 297
void call_and_disable_work_2(struct work_struct *work ) ;
#line 591 "include/linux/device.h"
extern int device_create_file(struct device * , struct device_attribute  const  * ) ;
#line 1259 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_peek(struct sk_buff_head  const  *list_ ) 
{ 
  struct sk_buff *skb ;

  {
#line 1261
  skb = list_->next;
#line 1263
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)list_)) {
#line 1264
    skb = (struct sk_buff *)0;
  } else {

  }
#line 1265
  return (skb);
}
}
#line 1316 "include/linux/skbuff.h"
__inline static __u32 skb_queue_len(struct sk_buff_head  const  *list_ ) 
{ 


  {
#line 1318
  return ((__u32 )list_->qlen);
}
}
#line 1331 "include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1333
  tmp = (struct sk_buff *)list;
#line 1333
  list->next = tmp;
#line 1333
  list->prev = tmp;
#line 1334
  list->qlen = 0U;
#line 1335
  return;
}
}
#line 1345 "include/linux/skbuff.h"
__inline static void skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct lock_class_key __key ;

  {
#line 1347
  spinlock_check(& list->lock);
#line 1347
  __raw_spin_lock_init(& list->lock.__annonCompField18.rlock, "&(&list->lock)->rlock",
                       & __key);
#line 1348
  __skb_queue_head_init(list);
#line 1349
  return;
}
}
#line 1366 "include/linux/skbuff.h"
__inline static void __skb_insert(struct sk_buff *newsk , struct sk_buff *prev , struct sk_buff *next ,
                                  struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1370
  newsk->__annonCompField68.__annonCompField67.next = next;
#line 1371
  newsk->__annonCompField68.__annonCompField67.prev = prev;
#line 1372
  tmp = newsk;
#line 1372
  prev->__annonCompField68.__annonCompField67.next = tmp;
#line 1372
  next->__annonCompField68.__annonCompField67.prev = tmp;
#line 1373
  list->qlen = list->qlen + 1U;
#line 1374
  return;
}
}
#line 1474 "include/linux/skbuff.h"
__inline static void __skb_queue_before(struct sk_buff_head *list , struct sk_buff *next ,
                                        struct sk_buff *newsk ) 
{ 


  {
#line 1478
  __skb_insert(newsk, next->__annonCompField68.__annonCompField67.prev, next, list);
#line 1479
  return;
}
}
#line 1509 "include/linux/skbuff.h"
__inline static void __skb_queue_tail(struct sk_buff_head *list , struct sk_buff *newsk ) 
{ 


  {
#line 1512
  __skb_queue_before(list, (struct sk_buff *)list, newsk);
#line 1513
  return;
}
}
#line 1520 "include/linux/skbuff.h"
__inline static void __skb_unlink(struct sk_buff *skb , struct sk_buff_head *list ) 
{ 
  struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *tmp ;

  {
#line 1524
  list->qlen = list->qlen - 1U;
#line 1525
  next = skb->__annonCompField68.__annonCompField67.next;
#line 1526
  prev = skb->__annonCompField68.__annonCompField67.prev;
#line 1527
  tmp = (struct sk_buff *)0;
#line 1527
  skb->__annonCompField68.__annonCompField67.prev = tmp;
#line 1527
  skb->__annonCompField68.__annonCompField67.next = tmp;
#line 1528
  next->__annonCompField68.__annonCompField67.prev = prev;
#line 1529
  prev->__annonCompField68.__annonCompField67.next = next;
#line 1530
  return;
}
}
#line 1541 "include/linux/skbuff.h"
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
#line 1543
  tmp = skb_peek((struct sk_buff_head  const  *)list);
#line 1543
  skb = tmp;
#line 1544
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1545
    __skb_unlink(skb, list);
  } else {

  }
#line 1546
  return (skb);
}
}
#line 1702
extern unsigned char *skb_push(struct sk_buff * , unsigned int  ) ;
#line 1822 "include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1825
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 1880 "include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1882
  return ((void *)dev + 3008U);
}
}
#line 1911
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int  ) ,
                           int  ) ;
#line 2187
extern int dev_queue_xmit_sk(struct sock * , struct sk_buff * ) ;
#line 2188 "include/linux/netdevice.h"
__inline static int dev_queue_xmit(struct sk_buff *skb ) 
{ 
  int tmp ;

  {
#line 2190
  tmp = dev_queue_xmit_sk(skb->sk, skb);
#line 2190
  return (tmp);
}
}
#line 2194
extern void unregister_netdevice_queue(struct net_device * , struct list_head * ) ;
#line 2195
extern void unregister_netdevice_many(struct list_head * ) ;
#line 2202
extern void free_netdev(struct net_device * ) ;
#line 2205
void ldv_free_netdev_17(struct net_device *dev ) ;
#line 2209
void ldv_free_netdev_22(struct net_device *dev ) ;
#line 2505
extern void netif_schedule_queue(struct netdev_queue * ) ;
#line 2515 "include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2517
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2518
  return;
}
}
#line 2526 "include/linux/netdevice.h"
__inline static void netif_start_queue(struct net_device *dev ) 
{ 
  struct netdev_queue *tmp ;

  {
#line 2528
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, 0U);
#line 2528
  netif_tx_start_queue(tmp);
#line 2529
  return;
}
}
#line 2565 "include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2567
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2568
  return;
}
}
#line 2577 "include/linux/netdevice.h"
__inline static void netif_stop_queue(struct net_device *dev ) 
{ 
  struct netdev_queue *tmp ;

  {
#line 2579
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, 0U);
#line 2579
  netif_tx_stop_queue(tmp);
#line 2580
  return;
}
}
#line 2584 "include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
#line 2586
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
#line 2586
  return (tmp != 0);
}
}
#line 2595 "include/linux/netdevice.h"
__inline static bool netif_queue_stopped(struct net_device  const  *dev ) 
{ 
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
#line 2597
  tmp = netdev_get_tx_queue(dev, 0U);
#line 2597
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp);
#line 2597
  return (tmp___0);
}
}
#line 2899
extern void __dev_kfree_skb_irq(struct sk_buff * , enum skb_free_reason  ) ;
#line 2900
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
#line 2921 "include/linux/netdevice.h"
__inline static void dev_kfree_skb_irq(struct sk_buff *skb ) 
{ 


  {
#line 2923
  __dev_kfree_skb_irq(skb, 1);
#line 2924
  return;
}
}
#line 2931 "include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
#line 2933
  __dev_kfree_skb_any(skb, 1);
#line 2934
  return;
}
}
#line 2971
extern int dev_change_flags(struct net_device * , unsigned int  ) ;
#line 2977
extern int dev_set_mtu(struct net_device * , int  ) ;
#line 3049
extern void netif_carrier_off(struct net_device * ) ;
#line 3170 "include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu ) 
{ 


  {
#line 3172
  spin_lock(& txq->_xmit_lock);
#line 3173
  txq->xmit_lock_owner = cpu;
#line 3174
  return;
}
}
#line 3190 "include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq ) 
{ 


  {
#line 3192
  txq->xmit_lock_owner = -1;
#line 3193
  spin_unlock(& txq->_xmit_lock);
#line 3194
  return;
}
}
#line 3214 "include/linux/netdevice.h"
__inline static void netif_tx_lock(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3219
  spin_lock(& dev->tx_global_lock);
#line 3220
  __vpp_verify = (void const   *)0;
#line 3220
  switch (4UL) {
  case 1UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43370;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43370;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43370;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43370;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43370: 
#line 3220
  pscr_ret__ = pfo_ret__;
#line 3220
  goto ldv_43376;
  case 2UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43380;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43380;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43380;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43380;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43380: 
#line 3220
  pscr_ret__ = pfo_ret_____0;
#line 3220
  goto ldv_43376;
  case 4UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43389;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43389;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43389;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43389;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43389: 
#line 3220
  pscr_ret__ = pfo_ret_____1;
#line 3220
  goto ldv_43376;
  case 8UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43398;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43398;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43398;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43398;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43398: 
#line 3220
  pscr_ret__ = pfo_ret_____2;
#line 3220
  goto ldv_43376;
  default: 
#line 3220
  __bad_size_call_parameter();
#line 3220
  goto ldv_43376;
  }
  ldv_43376: 
#line 3220
  cpu = pscr_ret__;
#line 3221
  i = 0U;
#line 3221
  goto ldv_43408;
  ldv_43407: 
#line 3222
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3222
  txq = tmp;
#line 3230
  __netif_tx_lock(txq, cpu);
#line 3231
  set_bit(2L, (unsigned long volatile   *)(& txq->state));
#line 3232
  __netif_tx_unlock(txq);
#line 3221
  i = i + 1U;
  ldv_43408: ;
#line 3221
  if (dev->num_tx_queues > i) {
#line 3223
    goto ldv_43407;
  } else {

  }

#line 3228
  return;
}
}
#line 3236 "include/linux/netdevice.h"
__inline static void netif_tx_lock_bh(struct net_device *dev ) 
{ 


  {
#line 3238
  local_bh_disable();
#line 3239
  netif_tx_lock(dev);
#line 3240
  return;
}
}
#line 3242 "include/linux/netdevice.h"
__inline static void netif_tx_unlock(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3246
  i = 0U;
#line 3246
  goto ldv_43419;
  ldv_43418: 
#line 3247
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3247
  txq = tmp;
#line 3253
  clear_bit(2L, (unsigned long volatile   *)(& txq->state));
#line 3254
  netif_schedule_queue(txq);
#line 3246
  i = i + 1U;
  ldv_43419: ;
#line 3246
  if (dev->num_tx_queues > i) {
#line 3248
    goto ldv_43418;
  } else {

  }
#line 3256
  spin_unlock(& dev->tx_global_lock);
#line 3257
  return;
}
}
#line 3259 "include/linux/netdevice.h"
__inline static void netif_tx_unlock_bh(struct net_device *dev ) 
{ 


  {
#line 3261
  netif_tx_unlock(dev);
#line 3262
  local_bh_enable();
#line 3263
  return;
}
}
#line 3341
extern struct net_device *alloc_netdev_mqs(int  , char const   * , unsigned char  ,
                                           void (*)(struct net_device * ) , unsigned int  ,
                                           unsigned int  ) ;
#line 3352
extern int register_netdev(struct net_device * ) ;
#line 3355
int ldv_register_netdev_12(struct net_device *dev ) ;
#line 3357
extern void unregister_netdev(struct net_device * ) ;
#line 3360
void ldv_unregister_netdev_13(struct net_device *dev ) ;
#line 3364
void ldv_unregister_netdev_21(struct net_device *dev ) ;
#line 3683
extern void netdev_update_features(struct net_device * ) ;
#line 3785 "include/linux/netdevice.h"
__inline static void netif_keep_dst(struct net_device *dev ) 
{ 


  {
#line 3787
  dev->priv_flags = dev->priv_flags & 4290771967U;
#line 3788
  return;
}
}
#line 27 "include/linux/rtnetlink.h"
extern void rtnl_lock(void) ;
#line 28
extern void rtnl_unlock(void) ;
#line 30
extern int rtnl_is_locked(void) ;
#line 242 "include/rdma/ib_verbs.h"
__inline static int ib_mtu_enum_to_int(enum ib_mtu mtu ) 
{ 


  {
#line 244
  switch ((unsigned int )mtu) {
  case 1U: ;
#line 245
  return (256);
  case 2U: ;
#line 246
  return (512);
  case 3U: ;
#line 247
  return (1024);
  case 4U: ;
#line 248
  return (2048);
  case 5U: ;
#line 249
  return (4096);
  default: ;
#line 250
  return (-1);
  }
}
}
#line 1776
extern int ib_register_client(struct ib_client * ) ;
#line 1777
extern void ib_unregister_client(struct ib_client * ) ;
#line 1779
extern void *ib_get_client_data(struct ib_device * , struct ib_client * ) ;
#line 1780
extern void ib_set_client_data(struct ib_device * , struct ib_client * , void * ) ;
#line 1813
extern int ib_register_event_handler(struct ib_event_handler * ) ;
#line 1814
extern int ib_unregister_event_handler(struct ib_event_handler * ) ;
#line 1817
extern int ib_query_device(struct ib_device * , struct ib_device_attr * ) ;
#line 1820
extern int ib_query_port(struct ib_device * , u8  , struct ib_port_attr * ) ;
#line 1853 "include/rdma/ib_verbs.h"
__inline static bool rdma_protocol_ib(struct ib_device  const  *device , u8 port_num ) 
{ 


  {
#line 1855
  return (((device->port_immutable + (unsigned long )port_num)->core_cap_flags & 1048576U) != 0U);
}
}
#line 2104
extern int ib_query_gid(struct ib_device * , u8  , int  , union ib_gid * ) ;
#line 2107
extern int ib_query_pkey(struct ib_device * , u8  , u16  , u16 * ) ;
#line 287 "include/rdma/ib_sa.h"
extern void ib_sa_register_client(struct ib_sa_client * ) ;
#line 293
extern void ib_sa_unregister_client(struct ib_sa_client * ) ;
#line 297
extern void ib_sa_cancel_query(int  , struct ib_sa_query * ) ;
#line 299
extern int ib_sa_path_rec_get(struct ib_sa_client * , struct ib_device * , u8  , struct ib_sa_path_rec * ,
                              ib_sa_comp_mask  , int  , gfp_t  , void (*)(int  , struct ib_sa_path_rec * ,
                                                                          void * ) ,
                              void * , struct ib_sa_query ** ) ;
#line 403
extern int ib_init_ah_from_path(struct ib_device * , u8  , struct ib_sa_path_rec * ,
                                struct ib_ah_attr * ) ;
#line 139 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static struct ipoib_cb *ipoib_skb_cb(struct sk_buff  const  *skb ) 
{ 


  {
#line 142
  return ((struct ipoib_cb *)(& skb->cb));
}
}
#line 441
void ipoib_neigh_dtor(struct ipoib_neigh *neigh ) ;
#line 442 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static void ipoib_neigh_put(struct ipoib_neigh *neigh ) 
{ 
  int tmp ;

  {
#line 444
  tmp = atomic_dec_and_test(& neigh->refcnt);
#line 444
  if (tmp != 0) {
#line 445
    ipoib_neigh_dtor(neigh);
  } else {

  }
#line 446
  return;
}
}
#line 447
struct ipoib_neigh *ipoib_neigh_get(struct net_device *dev , u8 *daddr ) ;
#line 448
struct ipoib_neigh *ipoib_neigh_alloc(u8 *daddr , struct net_device *dev ) ;
#line 450
void ipoib_neigh_free(struct ipoib_neigh *neigh ) ;
#line 451
void ipoib_del_neighs_by_gid(struct net_device *dev , u8 *gid ) ;
#line 453 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct workqueue_struct *ipoib_workqueue  ;
#line 457
int ipoib_poll(struct napi_struct *napi , int budget ) ;
#line 461
struct ipoib_ah *ipoib_create_ah(struct net_device *dev , struct ib_pd *pd , struct ib_ah_attr *attr ) ;
#line 463
void ipoib_free_ah(struct kref *kref ) ;
#line 464 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static void ipoib_put_ah(struct ipoib_ah *ah ) 
{ 


  {
#line 466
  kref_put(& ah->ref, & ipoib_free_ah);
#line 467
  return;
}
}
#line 468
int ipoib_open(struct net_device *dev ) ;
#line 469
int ipoib_add_pkey_attr(struct net_device *dev ) ;
#line 470
int ipoib_add_umcast_attr(struct net_device *dev ) ;
#line 472
void ipoib_send(struct net_device *dev , struct sk_buff *skb , struct ipoib_ah *address ,
                u32 qpn ) ;
#line 474
void ipoib_reap_ah(struct work_struct *work ) ;
#line 476
void ipoib_mark_paths_invalid(struct net_device *dev ) ;
#line 477
void ipoib_flush_paths(struct net_device *dev ) ;
#line 478
struct ipoib_dev_priv *ipoib_intf_alloc(char const   *name ) ;
#line 480
int ipoib_ib_dev_init(struct net_device *dev , struct ib_device *ca , int port ) ;
#line 481
void ipoib_ib_dev_flush_light(struct work_struct *work ) ;
#line 482
void ipoib_ib_dev_flush_normal(struct work_struct *work ) ;
#line 483
void ipoib_ib_dev_flush_heavy(struct work_struct *work ) ;
#line 485
void ipoib_ib_dev_cleanup(struct net_device *dev ) ;
#line 487
int ipoib_ib_dev_open(struct net_device *dev ) ;
#line 488
int ipoib_ib_dev_up(struct net_device *dev ) ;
#line 489
int ipoib_ib_dev_down(struct net_device *dev ) ;
#line 490
int ipoib_ib_dev_stop(struct net_device *dev ) ;
#line 493
int ipoib_dev_init(struct net_device *dev , struct ib_device *ca , int port ) ;
#line 494
void ipoib_dev_cleanup(struct net_device *dev ) ;
#line 496
void ipoib_mcast_join_task(struct work_struct *work ) ;
#line 497
void ipoib_mcast_carrier_on_task(struct work_struct *work ) ;
#line 498
void ipoib_mcast_send(struct net_device *dev , u8 *daddr , struct sk_buff *skb ) ;
#line 500
void ipoib_mcast_restart_task(struct work_struct *work ) ;
#line 517
struct ipoib_path_iter *ipoib_path_iter_init(struct net_device *dev ) ;
#line 518
int ipoib_path_iter_next(struct ipoib_path_iter *iter ) ;
#line 519
void ipoib_path_iter_read(struct ipoib_path_iter *iter , struct ipoib_path *path ) ;
#line 530
void ipoib_event(struct ib_event_handler *handler , struct ib_event *record ) ;
#line 533
int ipoib_vlan_add(struct net_device *pdev , unsigned short pkey ) ;
#line 534
int ipoib_vlan_delete(struct net_device *pdev , unsigned short pkey ) ;
#line 539
int ipoib_netlink_init(void) ;
#line 540
void ipoib_netlink_fini(void) ;
#line 542
void ipoib_set_umcast(struct net_device *ndev , int umcast_val ) ;
#line 543
int ipoib_set_mode(struct net_device *dev , char const   *buf ) ;
#line 545
void ipoib_setup(struct net_device *dev ) ;
#line 550
void ipoib_set_ethtool_ops(struct net_device *dev ) ;
#line 551
int ipoib_set_dev_features(struct ipoib_dev_priv *priv , struct ib_device *hca ) ;
#line 561
int ipoib_max_conn_qp ;
#line 563 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static int ipoib_cm_admin_enabled(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 565
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 565
  priv = (struct ipoib_dev_priv *)tmp;
#line 566
  if ((int )((signed char )*(dev->dev_addr)) < 0) {
#line 566
    tmp___0 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->flags));
#line 566
    if (tmp___0 != 0) {
#line 566
      tmp___1 = 1;
    } else {
#line 566
      tmp___1 = 0;
    }
  } else {
#line 566
    tmp___1 = 0;
  }
#line 566
  return (tmp___1);
}
}
#line 570 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static int ipoib_cm_enabled(struct net_device *dev , u8 *hwaddr ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 572
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 572
  priv = (struct ipoib_dev_priv *)tmp;
#line 573
  if ((int )((signed char )*hwaddr) < 0) {
#line 573
    tmp___0 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->flags));
#line 573
    if (tmp___0 != 0) {
#line 573
      tmp___1 = 1;
    } else {
#line 573
      tmp___1 = 0;
    }
  } else {
#line 573
    tmp___1 = 0;
  }
#line 573
  return (tmp___1);
}
}
#line 577 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static int ipoib_cm_up(struct ipoib_neigh *neigh ) 
{ 
  int tmp ;

  {
#line 580
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& (neigh->cm)->flags));
#line 580
  return (tmp);
}
}
#line 583 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static struct ipoib_cm_tx *ipoib_cm_get(struct ipoib_neigh *neigh ) 
{ 


  {
#line 585
  return (neigh->cm);
}
}
#line 588 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static void ipoib_cm_set(struct ipoib_neigh *neigh , struct ipoib_cm_tx *tx ) 
{ 


  {
#line 590
  neigh->cm = tx;
#line 591
  return;
}
}
#line 599 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static unsigned int ipoib_cm_max_mtu(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 601
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 601
  priv = (struct ipoib_dev_priv *)tmp;
#line 602
  return ((unsigned int )priv->cm.max_cm_mtu);
}
}
#line 605
void ipoib_cm_send(struct net_device *dev , struct sk_buff *skb , struct ipoib_cm_tx *tx ) ;
#line 609
int ipoib_cm_add_mode_attr(struct net_device *dev ) ;
#line 611
struct ipoib_cm_tx *ipoib_cm_create_tx(struct net_device *dev , struct ipoib_path *path ,
                                       struct ipoib_neigh *neigh ) ;
#line 613
void ipoib_cm_destroy_tx(struct ipoib_cm_tx *tx ) ;
#line 724
void ipoib_create_debug_files(struct net_device *dev ) ;
#line 725
void ipoib_delete_debug_files(struct net_device *dev ) ;
#line 726
int ipoib_register_debugfs(void) ;
#line 727
void ipoib_unregister_debugfs(void) ;
#line 740
int ipoib_sendq_size ;
#line 741
int ipoib_recvq_size ;
#line 743 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
struct ib_sa_client ipoib_sa_client  ;
#line 746 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
int ipoib_debug_level  ;
#line 778
char const   ipoib_driver_version[6U] ;
#line 70 "include/linux/vmalloc.h"
extern void *vzalloc(unsigned long  ) ;
#line 83
extern void vfree(void const   * ) ;
#line 149 "include/linux/jhash.h"
__inline static u32 __jhash_nwords(u32 a , u32 b , u32 c , u32 initval ) 
{ 
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
#line 151
  a = a + initval;
#line 152
  b = b + initval;
#line 153
  c = c + initval;
#line 155
  c = c ^ b;
#line 155
  tmp = rol32(b, 14U);
#line 155
  c = c - tmp;
#line 155
  a = a ^ c;
#line 155
  tmp___0 = rol32(c, 11U);
#line 155
  a = a - tmp___0;
#line 155
  b = b ^ a;
#line 155
  tmp___1 = rol32(a, 25U);
#line 155
  b = b - tmp___1;
#line 155
  c = c ^ b;
#line 155
  tmp___2 = rol32(b, 16U);
#line 155
  c = c - tmp___2;
#line 155
  a = a ^ c;
#line 155
  tmp___3 = rol32(c, 4U);
#line 155
  a = a - tmp___3;
#line 155
  b = b ^ a;
#line 155
  tmp___4 = rol32(a, 14U);
#line 155
  b = b - tmp___4;
#line 155
  c = c ^ b;
#line 155
  tmp___5 = rol32(b, 24U);
#line 155
  c = c - tmp___5;
#line 157
  return (c);
}
}
#line 160 "include/linux/jhash.h"
__inline static u32 jhash_3words(u32 a , u32 b , u32 c , u32 initval ) 
{ 
  u32 tmp ;

  {
#line 162
  tmp = __jhash_nwords(a, b, c, initval + 3735928571U);
#line 162
  return (tmp);
}
}
#line 10 "include/net/arp.h"
extern struct neigh_table arp_tbl ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
char const   ipoib_driver_version[6U]  = {      '1',      '.',      '0',      '.', 
        '0',      '\000'};
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_sendq_size  =    128;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_recvq_size  =    256;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static u8 const   ipv4_bcast_addr[20U]  = 
#line 81
  {      0U,      255U,      255U,      255U, 
        255U,      18U,      64U,      27U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        255U,      255U,      255U,      255U};
#line 91
static void ipoib_add_one(struct ib_device *device ) ;
#line 92
static void ipoib_remove_one(struct ib_device *device ) ;
#line 93
static void ipoib_neigh_reclaim(struct callback_head *rp ) ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct ib_client ipoib_client  =    {(char *)"ipoib", & ipoib_add_one, & ipoib_remove_one, {0, 0}};
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_open(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ipoib_dev_priv *cpriv ;
  struct list_head  const  *__mptr ;
  int flags ;
  struct list_head  const  *__mptr___0 ;
  int tmp___3 ;

  {
#line 103
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 103
  priv = (struct ipoib_dev_priv *)tmp;
#line 105
  if (ipoib_debug_level > 0) {
#line 105
    printk("\017%s: bringing up interface\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 107
  netif_carrier_off(dev);
#line 109
  set_bit(2L, (unsigned long volatile   *)(& priv->flags));
#line 111
  tmp___1 = ipoib_ib_dev_open(dev);
#line 111
  if (tmp___1 != 0) {
#line 112
    tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->flags));
#line 112
    if (tmp___0 == 0) {
#line 113
      return (0);
    } else {

    }
#line 114
    goto err_disable;
  } else {

  }
#line 117
  tmp___2 = ipoib_ib_dev_up(dev);
#line 117
  if (tmp___2 != 0) {
#line 118
    goto err_stop;
  } else {

  }
#line 120
  tmp___3 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->flags));
#line 120
  if (tmp___3 == 0) {
#line 124
    down_read(& priv->vlan_rwsem);
#line 125
    __mptr = (struct list_head  const  *)priv->child_intfs.next;
#line 125
    cpriv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff128UL;
#line 125
    goto ldv_50249;
    ldv_50248: 
#line 128
    flags = (int )(cpriv->dev)->flags;
#line 129
    if (flags & 1) {
#line 130
      goto ldv_50247;
    } else {

    }
#line 132
    dev_change_flags(cpriv->dev, (unsigned int )(flags | 1));
    ldv_50247: 
#line 125
    __mptr___0 = (struct list_head  const  *)cpriv->list.next;
#line 125
    cpriv = (struct ipoib_dev_priv *)__mptr___0 + 0xfffffffffffff128UL;
    ldv_50249: ;
#line 125
    if ((unsigned long )(& cpriv->list) != (unsigned long )(& priv->child_intfs)) {
#line 127
      goto ldv_50248;
    } else {

    }
#line 134
    up_read(& priv->vlan_rwsem);
  } else {

  }
#line 137
  netif_start_queue(dev);
#line 139
  return (0);
  err_stop: 
#line 142
  ipoib_ib_dev_stop(dev);
  err_disable: 
#line 145
  clear_bit(2L, (unsigned long volatile   *)(& priv->flags));
#line 147
  return (-22);
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int ipoib_stop(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_dev_priv *cpriv ;
  struct list_head  const  *__mptr ;
  int flags ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;

  {
#line 152
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 152
  priv = (struct ipoib_dev_priv *)tmp;
#line 154
  if (ipoib_debug_level > 0) {
#line 154
    printk("\017%s: stopping interface\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 156
  clear_bit(2L, (unsigned long volatile   *)(& priv->flags));
#line 158
  netif_stop_queue(dev);
#line 160
  ipoib_ib_dev_down(dev);
#line 161
  ipoib_ib_dev_stop(dev);
#line 163
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->flags));
#line 163
  if (tmp___0 == 0) {
#line 167
    down_read(& priv->vlan_rwsem);
#line 168
    __mptr = (struct list_head  const  *)priv->child_intfs.next;
#line 168
    cpriv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff128UL;
#line 168
    goto ldv_50263;
    ldv_50262: 
#line 171
    flags = (int )(cpriv->dev)->flags;
#line 172
    if ((flags & 1) == 0) {
#line 173
      goto ldv_50261;
    } else {

    }
#line 175
    dev_change_flags(cpriv->dev, (unsigned int )flags & 4294967294U);
    ldv_50261: 
#line 168
    __mptr___0 = (struct list_head  const  *)cpriv->list.next;
#line 168
    cpriv = (struct ipoib_dev_priv *)__mptr___0 + 0xfffffffffffff128UL;
    ldv_50263: ;
#line 168
    if ((unsigned long )(& cpriv->list) != (unsigned long )(& priv->child_intfs)) {
#line 170
      goto ldv_50262;
    } else {

    }
#line 177
    up_read(& priv->vlan_rwsem);
  } else {

  }
#line 180
  return (0);
}
}
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_uninit(struct net_device *dev ) 
{ 


  {
#line 185
  ipoib_dev_cleanup(dev);
#line 186
  return;
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static netdev_features_t ipoib_fix_features(struct net_device *dev , netdev_features_t features ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;

  {
#line 190
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 190
  priv = (struct ipoib_dev_priv *)tmp;
#line 192
  tmp___0 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->flags));
#line 192
  if (tmp___0 != 0) {
#line 193
    features = features & 0xfffffffffffefffcULL;
  } else {

  }
#line 195
  return (features);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int ipoib_change_mtu(struct net_device *dev , int new_mtu ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int _min1 ;
  unsigned int _min2 ;

  {
#line 200
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 200
  priv = (struct ipoib_dev_priv *)tmp;
#line 203
  tmp___1 = ipoib_cm_admin_enabled(dev);
#line 203
  if (tmp___1 != 0) {
#line 204
    tmp___0 = ipoib_cm_max_mtu(dev);
#line 204
    if ((unsigned int )new_mtu > tmp___0) {
#line 205
      return (-22);
    } else {

    }
#line 207
    if ((unsigned int )new_mtu > priv->mcast_mtu) {
#line 208
      printk("\f%s: mtu > %d will cause multicast packet drops.\n", (char *)(& (priv->dev)->name),
             priv->mcast_mtu);
    } else {

    }
#line 211
    dev->mtu = (unsigned int )new_mtu;
#line 212
    return (0);
  } else {

  }
#line 215
  if ((unsigned int )new_mtu > priv->max_ib_mtu - 4U) {
#line 216
    return (-22);
  } else {

  }
#line 218
  priv->admin_mtu = (unsigned int )new_mtu;
#line 220
  _min1 = priv->mcast_mtu;
#line 220
  _min2 = priv->admin_mtu;
#line 220
  dev->mtu = _min1 < _min2 ? _min1 : _min2;
#line 222
  return (0);
}
}
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_set_mode(struct net_device *dev , char const   *buf ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  int tmp___1 ;

  {
#line 227
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 227
  priv = (struct ipoib_dev_priv *)tmp;
#line 230
  if ((int )((signed char )*(dev->dev_addr)) < 0) {
#line 230
    tmp___0 = strcmp(buf, "connected\n");
#line 230
    if (tmp___0 == 0) {
#line 231
      set_bit(9L, (unsigned long volatile   *)(& priv->flags));
#line 232
      printk("\f%s: enabling connected mode will cause multicast packet drops\n",
             (char *)(& (priv->dev)->name));
#line 234
      netdev_update_features(dev);
#line 235
      rtnl_unlock();
#line 236
      priv->tx_wr.send_flags = priv->tx_wr.send_flags & -17;
#line 238
      ipoib_flush_paths(dev);
#line 239
      rtnl_lock();
#line 240
      return (0);
    } else {

    }
  } else {

  }
#line 243
  tmp___1 = strcmp(buf, "datagram\n");
#line 243
  if (tmp___1 == 0) {
#line 244
    clear_bit(9L, (unsigned long volatile   *)(& priv->flags));
#line 245
    netdev_update_features(dev);
#line 246
    _min1 = priv->mcast_mtu;
#line 246
    _min2 = dev->mtu;
#line 246
    dev_set_mtu(dev, (int )(_min1 < _min2 ? _min1 : _min2));
#line 247
    rtnl_unlock();
#line 248
    ipoib_flush_paths(dev);
#line 249
    rtnl_lock();
#line 250
    return (0);
  } else {

  }
#line 253
  return (-22);
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct ipoib_path *__path_find(struct net_device *dev , void *gid ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct rb_node *n ;
  struct ipoib_path *path ;
  int ret ;
  struct rb_node  const  *__mptr ;

  {
#line 258
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 258
  priv = (struct ipoib_dev_priv *)tmp;
#line 259
  n = priv->path_tree.rb_node;
#line 263
  goto ldv_50300;
  ldv_50299: 
#line 264
  __mptr = (struct rb_node  const  *)n;
#line 264
  path = (struct ipoib_path *)__mptr + 0xfffffffffffffeb8UL;
#line 266
  ret = memcmp((void const   *)gid, (void const   *)(& path->pathrec.dgid.raw), 16UL);
#line 269
  if (ret < 0) {
#line 270
    n = n->rb_left;
  } else
#line 271
  if (ret > 0) {
#line 272
    n = n->rb_right;
  } else {
#line 274
    return (path);
  }
  ldv_50300: ;
#line 263
  if ((unsigned long )n != (unsigned long )((struct rb_node *)0)) {
#line 265
    goto ldv_50299;
  } else {

  }

#line 277
  return ((struct ipoib_path *)0);
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int __path_add(struct net_device *dev , struct ipoib_path *path ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct rb_node **n ;
  struct rb_node *pn ;
  struct ipoib_path *tpath ;
  int ret ;
  struct rb_node  const  *__mptr ;

  {
#line 282
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 282
  priv = (struct ipoib_dev_priv *)tmp;
#line 283
  n = & priv->path_tree.rb_node;
#line 284
  pn = (struct rb_node *)0;
#line 288
  goto ldv_50314;
  ldv_50313: 
#line 289
  pn = *n;
#line 290
  __mptr = (struct rb_node  const  *)pn;
#line 290
  tpath = (struct ipoib_path *)__mptr + 0xfffffffffffffeb8UL;
#line 292
  ret = memcmp((void const   *)(& path->pathrec.dgid.raw), (void const   *)(& tpath->pathrec.dgid.raw),
               16UL);
#line 294
  if (ret < 0) {
#line 295
    n = & pn->rb_left;
  } else
#line 296
  if (ret > 0) {
#line 297
    n = & pn->rb_right;
  } else {
#line 299
    return (-17);
  }
  ldv_50314: ;
#line 288
  if ((unsigned long )*n != (unsigned long )((struct rb_node *)0)) {
#line 290
    goto ldv_50313;
  } else {

  }
#line 302
  rb_link_node(& path->rb_node, pn, n);
#line 303
  rb_insert_color(& path->rb_node, & priv->path_tree);
#line 305
  list_add_tail(& path->list, & priv->path_list);
#line 307
  return (0);
}
}
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void path_free(struct net_device *dev , struct ipoib_path *path ) 
{ 
  struct sk_buff *skb ;
  void *tmp ;

  {
#line 314
  goto ldv_50322;
  ldv_50321: 
#line 315
  dev_kfree_skb_irq(skb);
  ldv_50322: 
#line 314
  skb = __skb_dequeue(& path->queue);
#line 314
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 316
    goto ldv_50321;
  } else {

  }

#line 317
  if (ipoib_debug_level > 0) {
#line 317
    tmp = netdev_priv((struct net_device  const  *)dev);
#line 317
    printk("\017%s: path_free\n", (char *)(& (((struct ipoib_dev_priv *)tmp)->dev)->name));
  } else {

  }
#line 320
  ipoib_del_neighs_by_gid(dev, (u8 *)(& path->pathrec.dgid.raw));
#line 322
  if ((unsigned long )path->ah != (unsigned long )((struct ipoib_ah *)0)) {
#line 323
    ipoib_put_ah(path->ah);
  } else {

  }
#line 325
  kfree((void const   *)path);
#line 326
  return;
}
}
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
struct ipoib_path_iter *ipoib_path_iter_init(struct net_device *dev ) 
{ 
  struct ipoib_path_iter *iter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 334
  tmp = kmalloc(384UL, 208U);
#line 334
  iter = (struct ipoib_path_iter *)tmp;
#line 335
  if ((unsigned long )iter == (unsigned long )((struct ipoib_path_iter *)0)) {
#line 336
    return ((struct ipoib_path_iter *)0);
  } else {

  }
#line 338
  iter->dev = dev;
#line 339
  memset((void *)(& iter->path.pathrec.dgid.raw), 0, 16UL);
#line 341
  tmp___0 = ipoib_path_iter_next(iter);
#line 341
  if (tmp___0 != 0) {
#line 342
    kfree((void const   *)iter);
#line 343
    return ((struct ipoib_path_iter *)0);
  } else {

  }
#line 346
  return (iter);
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_path_iter_next(struct ipoib_path_iter *iter ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct rb_node *n ;
  struct ipoib_path *path ;
  int ret ;
  struct rb_node  const  *__mptr ;
  int tmp___0 ;

  {
#line 351
  tmp = netdev_priv((struct net_device  const  *)iter->dev);
#line 351
  priv = (struct ipoib_dev_priv *)tmp;
#line 354
  ret = 1;
#line 356
  spin_lock_irq(& priv->lock);
#line 358
  n = rb_first((struct rb_root  const  *)(& priv->path_tree));
#line 360
  goto ldv_50339;
  ldv_50338: 
#line 361
  __mptr = (struct rb_node  const  *)n;
#line 361
  path = (struct ipoib_path *)__mptr + 0xfffffffffffffeb8UL;
#line 363
  tmp___0 = memcmp((void const   *)(& iter->path.pathrec.dgid.raw), (void const   *)(& path->pathrec.dgid.raw),
                   16UL);
#line 363
  if (tmp___0 < 0) {
#line 365
    iter->path = *path;
#line 366
    ret = 0;
#line 367
    goto ldv_50337;
  } else {

  }
#line 370
  n = rb_next((struct rb_node  const  *)n);
  ldv_50339: ;
#line 360
  if ((unsigned long )n != (unsigned long )((struct rb_node *)0)) {
#line 362
    goto ldv_50338;
  } else {

  }
  ldv_50337: 
#line 373
  spin_unlock_irq(& priv->lock);
#line 375
  return (ret);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_path_iter_read(struct ipoib_path_iter *iter , struct ipoib_path *path ) 
{ 


  {
#line 381
  *path = iter->path;
#line 382
  return;
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_mark_paths_invalid(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_path *path ;
  struct ipoib_path *tp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  __u16 tmp___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 388
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 388
  priv = (struct ipoib_dev_priv *)tmp;
#line 391
  spin_lock_irq(& priv->lock);
#line 393
  __mptr = (struct list_head  const  *)priv->path_list.next;
#line 393
  path = (struct ipoib_path *)__mptr + 0xfffffffffffffea0UL;
#line 393
  __mptr___0 = (struct list_head  const  *)path->list.next;
#line 393
  tp = (struct ipoib_path *)__mptr___0 + 0xfffffffffffffea0UL;
#line 393
  goto ldv_50357;
  ldv_50356: ;
#line 394
  if (ipoib_debug_level > 0) {
#line 394
    tmp___0 = __fswab16((int )path->pathrec.dlid);
#line 394
    printk("\017%s: mark path LID 0x%04x GID %pI6 invalid\n", (char *)(& (priv->dev)->name),
           (int )tmp___0, (u8 *)(& path->pathrec.dgid.raw));
  } else {

  }
#line 397
  path->valid = 0;
#line 393
  path = tp;
#line 393
  __mptr___1 = (struct list_head  const  *)tp->list.next;
#line 393
  tp = (struct ipoib_path *)__mptr___1 + 0xfffffffffffffea0UL;
  ldv_50357: ;
#line 393
  if ((unsigned long )(& path->list) != (unsigned long )(& priv->path_list)) {
#line 395
    goto ldv_50356;
  } else {

  }
#line 400
  spin_unlock_irq(& priv->lock);
#line 401
  return;
}
}
#line 403 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_flush_paths(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_path *path ;
  struct ipoib_path *tp ;
  struct list_head remove_list ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  raw_spinlock_t *tmp___1 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 405
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 405
  priv = (struct ipoib_dev_priv *)tmp;
#line 407
  remove_list.next = & remove_list;
#line 407
  remove_list.prev = & remove_list;
#line 410
  netif_tx_lock_bh(dev);
#line 411
  tmp___0 = spinlock_check(& priv->lock);
#line 411
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 413
  list_splice_init(& priv->path_list, & remove_list);
#line 415
  __mptr = (struct list_head  const  *)remove_list.next;
#line 415
  path = (struct ipoib_path *)__mptr + 0xfffffffffffffea0UL;
#line 415
  goto ldv_50375;
  ldv_50374: 
#line 416
  rb_erase(& path->rb_node, & priv->path_tree);
#line 415
  __mptr___0 = (struct list_head  const  *)path->list.next;
#line 415
  path = (struct ipoib_path *)__mptr___0 + 0xfffffffffffffea0UL;
  ldv_50375: ;
#line 415
  if ((unsigned long )(& path->list) != (unsigned long )(& remove_list)) {
#line 417
    goto ldv_50374;
  } else {

  }
#line 418
  __mptr___1 = (struct list_head  const  *)remove_list.next;
#line 418
  path = (struct ipoib_path *)__mptr___1 + 0xfffffffffffffea0UL;
#line 418
  __mptr___2 = (struct list_head  const  *)path->list.next;
#line 418
  tp = (struct ipoib_path *)__mptr___2 + 0xfffffffffffffea0UL;
#line 418
  goto ldv_50387;
  ldv_50386: ;
#line 419
  if ((unsigned long )path->query != (unsigned long )((struct ib_sa_query *)0)) {
#line 420
    ib_sa_cancel_query(path->query_id, path->query);
  } else {

  }
#line 421
  spin_unlock_irqrestore(& priv->lock, flags);
#line 422
  netif_tx_unlock_bh(dev);
#line 423
  wait_for_completion(& path->done);
#line 424
  path_free(dev, path);
#line 425
  netif_tx_lock_bh(dev);
#line 426
  tmp___1 = spinlock_check(& priv->lock);
#line 426
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 418
  path = tp;
#line 418
  __mptr___3 = (struct list_head  const  *)tp->list.next;
#line 418
  tp = (struct ipoib_path *)__mptr___3 + 0xfffffffffffffea0UL;
  ldv_50387: ;
#line 418
  if ((unsigned long )(& path->list) != (unsigned long )(& remove_list)) {
#line 420
    goto ldv_50386;
  } else {

  }
#line 429
  spin_unlock_irqrestore(& priv->lock, flags);
#line 430
  netif_tx_unlock_bh(dev);
#line 431
  return;
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void path_rec_completion(int status , struct ib_sa_path_rec *pathrec , void *path_ptr ) 
{ 
  struct ipoib_path *path ;
  struct net_device *dev ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_ah *ah ;
  struct ipoib_ah *old_ah ;
  struct ipoib_neigh *neigh ;
  struct ipoib_neigh *tn ;
  struct sk_buff_head skqueue ;
  struct sk_buff *skb ;
  unsigned long flags ;
  __u16 tmp___0 ;
  struct ib_ah_attr av ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  __u16 tmp___3 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int __ret_warn_on ;
  long tmp___4 ;
  struct ipoib_cm_tx *tmp___5 ;
  struct ipoib_cm_tx *tmp___6 ;
  struct ipoib_cm_tx *tmp___7 ;
  int tmp___8 ;
  struct list_head  const  *__mptr___1 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;

  {
#line 437
  path = (struct ipoib_path *)path_ptr;
#line 438
  dev = path->dev;
#line 439
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 439
  priv = (struct ipoib_dev_priv *)tmp;
#line 440
  ah = (struct ipoib_ah *)0;
#line 441
  old_ah = (struct ipoib_ah *)0;
#line 447
  if (status == 0) {
#line 448
    if (ipoib_debug_level > 0) {
#line 448
      tmp___0 = __fswab16((int )pathrec->dlid);
#line 448
      printk("\017%s: PathRec LID 0x%04x for GID %pI6\n", (char *)(& (priv->dev)->name),
             (int )tmp___0, (u8 *)(& pathrec->dgid.raw));
    } else {

    }
  } else
#line 451
  if (ipoib_debug_level > 0) {
#line 451
    printk("\017%s: PathRec status %d for GID %pI6\n", (char *)(& (priv->dev)->name),
           status, (u8 *)(& path->pathrec.dgid.raw));
  } else {

  }
#line 454
  skb_queue_head_init(& skqueue);
#line 456
  if (status == 0) {
#line 459
    tmp___1 = ib_init_ah_from_path(priv->ca, (int )priv->port, pathrec, & av);
#line 459
    if (tmp___1 == 0) {
#line 460
      ah = ipoib_create_ah(dev, priv->pd, & av);
    } else {

    }
  } else {

  }
#line 463
  tmp___2 = spinlock_check(& priv->lock);
#line 463
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 465
  tmp___9 = IS_ERR_OR_NULL((void const   *)ah);
#line 465
  if (tmp___9) {
#line 465
    tmp___10 = 0;
  } else {
#line 465
    tmp___10 = 1;
  }
#line 465
  if (tmp___10) {
#line 466
    path->pathrec = *pathrec;
#line 468
    old_ah = path->ah;
#line 469
    path->ah = ah;
#line 471
    if (ipoib_debug_level > 0) {
#line 471
      tmp___3 = __fswab16((int )pathrec->dlid);
#line 471
      printk("\017%s: created address handle %p for LID 0x%04x, SL %d\n", (char *)(& (priv->dev)->name),
             ah, (int )tmp___3, (int )pathrec->sl);
    } else {

    }
#line 474
    goto ldv_50409;
    ldv_50408: 
#line 475
    __skb_queue_tail(& skqueue, skb);
    ldv_50409: 
#line 474
    skb = __skb_dequeue(& path->queue);
#line 474
    if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 476
      goto ldv_50408;
    } else {

    }
#line 477
    __mptr = (struct list_head  const  *)path->neigh_list.next;
#line 477
    neigh = (struct ipoib_neigh *)__mptr + 0xffffffffffffff70UL;
#line 477
    __mptr___0 = (struct list_head  const  *)neigh->list.next;
#line 477
    tn = (struct ipoib_neigh *)__mptr___0 + 0xffffffffffffff70UL;
#line 477
    goto ldv_50424;
    ldv_50423: ;
#line 478
    if ((unsigned long )neigh->ah != (unsigned long )((struct ipoib_ah *)0)) {
#line 479
      __ret_warn_on = (unsigned long )neigh->ah != (unsigned long )old_ah;
#line 479
      tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 479
      if (tmp___4 != 0L) {
#line 479
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                           479);
      } else {

      }
#line 479
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 487
      ipoib_put_ah(neigh->ah);
    } else {

    }
#line 489
    kref_get(& (path->ah)->ref);
#line 490
    neigh->ah = path->ah;
#line 492
    tmp___8 = ipoib_cm_enabled(dev, (u8 *)(& neigh->daddr));
#line 492
    if (tmp___8 != 0) {
#line 493
      tmp___6 = ipoib_cm_get(neigh);
#line 493
      if ((unsigned long )tmp___6 == (unsigned long )((struct ipoib_cm_tx *)0)) {
#line 494
        tmp___5 = ipoib_cm_create_tx(dev, path, neigh);
#line 494
        ipoib_cm_set(neigh, tmp___5);
      } else {

      }
#line 497
      tmp___7 = ipoib_cm_get(neigh);
#line 497
      if ((unsigned long )tmp___7 == (unsigned long )((struct ipoib_cm_tx *)0)) {
#line 498
        ipoib_neigh_free(neigh);
#line 499
        goto ldv_50419;
      } else {

      }
    } else {

    }
#line 503
    goto ldv_50421;
    ldv_50420: 
#line 504
    __skb_queue_tail(& skqueue, skb);
    ldv_50421: 
#line 503
    skb = __skb_dequeue(& neigh->queue);
#line 503
    if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 505
      goto ldv_50420;
    } else {

    }

    ldv_50419: 
#line 477
    neigh = tn;
#line 477
    __mptr___1 = (struct list_head  const  *)tn->list.next;
#line 477
    tn = (struct ipoib_neigh *)__mptr___1 + 0xffffffffffffff70UL;
    ldv_50424: ;
#line 477
    if ((unsigned long )(& neigh->list) != (unsigned long )(& path->neigh_list)) {
#line 479
      goto ldv_50423;
    } else {

    }
#line 506
    path->valid = 1;
  } else {

  }
#line 509
  path->query = (struct ib_sa_query *)0;
#line 510
  complete(& path->done);
#line 512
  spin_unlock_irqrestore(& priv->lock, flags);
#line 514
  tmp___11 = IS_ERR_OR_NULL((void const   *)ah);
#line 514
  if ((int )tmp___11) {
#line 515
    ipoib_del_neighs_by_gid(dev, (u8 *)(& path->pathrec.dgid.raw));
  } else {

  }
#line 517
  if ((unsigned long )old_ah != (unsigned long )((struct ipoib_ah *)0)) {
#line 518
    ipoib_put_ah(old_ah);
  } else {

  }
#line 520
  goto ldv_50427;
  ldv_50426: 
#line 521
  skb->dev = dev;
#line 522
  tmp___12 = dev_queue_xmit(skb);
#line 522
  if (tmp___12 != 0) {
#line 523
    printk("\f%s: dev_queue_xmit failed to requeue packet\n", (char *)(& (priv->dev)->name));
  } else {

  }
  ldv_50427: 
#line 520
  skb = __skb_dequeue(& skqueue);
#line 520
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 522
    goto ldv_50426;
  } else {

  }

#line 527
  return;
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct ipoib_path *path_rec_create(struct net_device *dev , void *gid ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_path *path ;
  void *tmp___0 ;
  __u16 tmp___1 ;

  {
#line 530
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 530
  priv = (struct ipoib_dev_priv *)tmp;
#line 533
  if ((unsigned long )priv->broadcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 534
    return ((struct ipoib_path *)0);
  } else {

  }
#line 536
  tmp___0 = kzalloc(376UL, 32U);
#line 536
  path = (struct ipoib_path *)tmp___0;
#line 537
  if ((unsigned long )path == (unsigned long )((struct ipoib_path *)0)) {
#line 538
    return ((struct ipoib_path *)0);
  } else {

  }
#line 540
  path->dev = dev;
#line 542
  skb_queue_head_init(& path->queue);
#line 544
  INIT_LIST_HEAD(& path->neigh_list);
#line 546
  memcpy((void *)(& path->pathrec.dgid.raw), (void const   *)gid, 16UL);
#line 547
  path->pathrec.sgid = priv->local_gid;
#line 548
  tmp___1 = __fswab16((int )priv->pkey);
#line 548
  path->pathrec.pkey = tmp___1;
#line 549
  path->pathrec.numb_path = 1U;
#line 550
  path->pathrec.traffic_class = (priv->broadcast)->mcmember.traffic_class;
#line 552
  return (path);
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int path_rec_start(struct net_device *dev , struct ipoib_path *path ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 558
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 558
  priv = (struct ipoib_dev_priv *)tmp;
#line 560
  if (ipoib_debug_level > 0) {
#line 560
    printk("\017%s: Start path record lookup for %pI6\n", (char *)(& (priv->dev)->name),
           (u8 *)(& path->pathrec.dgid.raw));
  } else {

  }
#line 563
  init_completion(& path->done);
#line 565
  path->query_id = ib_sa_path_rec_get(& ipoib_sa_client, priv->ca, (int )priv->port,
                                      & path->pathrec, 879327827244089344ULL, 1000,
                                      32U, & path_rec_completion, (void *)path, & path->query);
#line 576
  if (path->query_id < 0) {
#line 577
    printk("\f%s: ib_sa_path_rec_get failed: %d\n", (char *)(& (priv->dev)->name),
           path->query_id);
#line 578
    path->query = (struct ib_sa_query *)0;
#line 579
    complete(& path->done);
#line 580
    return (path->query_id);
  } else {

  }
#line 583
  return (0);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void neigh_add_path(struct sk_buff *skb , u8 *daddr , struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_path *path ;
  struct ipoib_neigh *neigh ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  struct ipoib_cm_tx *tmp___1 ;
  struct ipoib_cm_tx *tmp___2 ;
  struct ipoib_cm_tx *tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __u32 tmp___9 ;

  {
#line 589
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 589
  priv = (struct ipoib_dev_priv *)tmp;
#line 594
  tmp___0 = spinlock_check(& priv->lock);
#line 594
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 595
  neigh = ipoib_neigh_alloc(daddr, dev);
#line 596
  if ((unsigned long )neigh == (unsigned long )((struct ipoib_neigh *)0)) {
#line 597
    spin_unlock_irqrestore(& priv->lock, flags);
#line 598
    dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 599
    dev_kfree_skb_any(skb);
#line 600
    return;
  } else {

  }
#line 603
  path = __path_find(dev, (void *)daddr + 4U);
#line 604
  if ((unsigned long )path == (unsigned long )((struct ipoib_path *)0)) {
#line 605
    path = path_rec_create(dev, (void *)daddr + 4U);
#line 606
    if ((unsigned long )path == (unsigned long )((struct ipoib_path *)0)) {
#line 607
      goto err_path;
    } else {

    }
#line 609
    __path_add(dev, path);
  } else {

  }
#line 612
  list_add_tail(& neigh->list, & path->neigh_list);
#line 614
  if ((unsigned long )path->ah != (unsigned long )((struct ipoib_ah *)0)) {
#line 615
    kref_get(& (path->ah)->ref);
#line 616
    neigh->ah = path->ah;
#line 618
    tmp___7 = ipoib_cm_enabled(dev, (u8 *)(& neigh->daddr));
#line 618
    if (tmp___7 != 0) {
#line 619
      tmp___2 = ipoib_cm_get(neigh);
#line 619
      if ((unsigned long )tmp___2 == (unsigned long )((struct ipoib_cm_tx *)0)) {
#line 620
        tmp___1 = ipoib_cm_create_tx(dev, path, neigh);
#line 620
        ipoib_cm_set(neigh, tmp___1);
      } else {

      }
#line 621
      tmp___3 = ipoib_cm_get(neigh);
#line 621
      if ((unsigned long )tmp___3 == (unsigned long )((struct ipoib_cm_tx *)0)) {
#line 622
        ipoib_neigh_free(neigh);
#line 623
        goto err_drop;
      } else {

      }
#line 625
      tmp___5 = skb_queue_len((struct sk_buff_head  const  *)(& neigh->queue));
#line 625
      if (tmp___5 <= 2U) {
#line 626
        __skb_queue_tail(& neigh->queue, skb);
      } else {
#line 628
        tmp___4 = skb_queue_len((struct sk_buff_head  const  *)(& neigh->queue));
#line 628
        printk("\f%s: queue length limit %d. Packet drop.\n", (char *)(& (priv->dev)->name),
               tmp___4);
#line 630
        goto err_drop;
      }
    } else {
#line 633
      spin_unlock_irqrestore(& priv->lock, flags);
#line 634
      tmp___6 = __be32_to_cpup((__be32 const   *)daddr);
#line 634
      ipoib_send(dev, skb, path->ah, tmp___6 & 16777215U);
#line 635
      ipoib_neigh_put(neigh);
#line 636
      return;
    }
  } else {
#line 639
    neigh->ah = (struct ipoib_ah *)0;
#line 641
    if ((unsigned long )path->query == (unsigned long )((struct ib_sa_query *)0)) {
#line 641
      tmp___8 = path_rec_start(dev, path);
#line 641
      if (tmp___8 != 0) {
#line 642
        goto err_path;
      } else {

      }
    } else {

    }
#line 643
    tmp___9 = skb_queue_len((struct sk_buff_head  const  *)(& neigh->queue));
#line 643
    if (tmp___9 <= 2U) {
#line 644
      __skb_queue_tail(& neigh->queue, skb);
    } else {
#line 646
      goto err_drop;
    }
  }
#line 649
  spin_unlock_irqrestore(& priv->lock, flags);
#line 650
  ipoib_neigh_put(neigh);
#line 651
  return;
  err_path: 
#line 654
  ipoib_neigh_free(neigh);
  err_drop: 
#line 656
  dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 657
  dev_kfree_skb_any(skb);
#line 659
  spin_unlock_irqrestore(& priv->lock, flags);
#line 660
  ipoib_neigh_put(neigh);
#line 661
  return;
}
}
#line 663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void unicast_arp_send(struct sk_buff *skb , struct net_device *dev , struct ipoib_cb *cb ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_path *path ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  int new_path ;
  __u32 tmp___1 ;
  int tmp___2 ;
  __u16 tmp___3 ;
  __u32 tmp___4 ;
  int tmp___5 ;
  __u32 tmp___6 ;

  {
#line 666
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 666
  priv = (struct ipoib_dev_priv *)tmp;
#line 670
  tmp___0 = spinlock_check(& priv->lock);
#line 670
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 672
  path = __path_find(dev, (void *)(& cb->hwaddr) + 4U);
#line 673
  if ((unsigned long )path == (unsigned long )((struct ipoib_path *)0) || path->valid == 0) {
#line 674
    new_path = 0;
#line 676
    if ((unsigned long )path == (unsigned long )((struct ipoib_path *)0)) {
#line 677
      path = path_rec_create(dev, (void *)(& cb->hwaddr) + 4U);
#line 678
      new_path = 1;
    } else {

    }
#line 680
    if ((unsigned long )path != (unsigned long )((struct ipoib_path *)0)) {
#line 681
      tmp___1 = skb_queue_len((struct sk_buff_head  const  *)(& path->queue));
#line 681
      if (tmp___1 <= 2U) {
#line 682
        __skb_queue_tail(& path->queue, skb);
      } else {
#line 684
        dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 685
        dev_kfree_skb_any(skb);
      }
#line 688
      if ((unsigned long )path->query == (unsigned long )((struct ib_sa_query *)0)) {
#line 688
        tmp___2 = path_rec_start(dev, path);
#line 688
        if (tmp___2 != 0) {
#line 689
          spin_unlock_irqrestore(& priv->lock, flags);
#line 690
          if (new_path != 0) {
#line 691
            path_free(dev, path);
          } else {

          }
#line 692
          return;
        } else {
#line 694
          __path_add(dev, path);
        }
      } else {
#line 694
        __path_add(dev, path);
      }
    } else {
#line 696
      dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 697
      dev_kfree_skb_any(skb);
    }
#line 700
    spin_unlock_irqrestore(& priv->lock, flags);
#line 701
    return;
  } else {

  }
#line 704
  if ((unsigned long )path->ah != (unsigned long )((struct ipoib_ah *)0)) {
#line 705
    if (ipoib_debug_level > 0) {
#line 705
      tmp___3 = __fswab16((int )path->pathrec.dlid);
#line 705
      printk("\017%s: Send unicast ARP to %04x\n", (char *)(& (priv->dev)->name),
             (int )tmp___3);
    } else {

    }
#line 708
    spin_unlock_irqrestore(& priv->lock, flags);
#line 709
    tmp___4 = __be32_to_cpup((__be32 const   *)(& cb->hwaddr));
#line 709
    ipoib_send(dev, skb, path->ah, tmp___4 & 16777215U);
#line 710
    return;
  } else
#line 711
  if ((unsigned long )path->query != (unsigned long )((struct ib_sa_query *)0)) {
#line 711
    goto _L;
  } else {
#line 711
    tmp___5 = path_rec_start(dev, path);
#line 711
    if (tmp___5 == 0) {
      _L: /* CIL Label */ 
#line 711
      tmp___6 = skb_queue_len((struct sk_buff_head  const  *)(& path->queue));
#line 711
      if (tmp___6 <= 2U) {
#line 713
        __skb_queue_tail(& path->queue, skb);
      } else {
#line 715
        dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 716
        dev_kfree_skb_any(skb);
      }
    } else {
#line 715
      dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 716
      dev_kfree_skb_any(skb);
    }
  }
#line 719
  spin_unlock_irqrestore(& priv->lock, flags);
#line 720
  return;
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int ipoib_start_xmit(struct sk_buff *skb , struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_neigh *neigh ;
  struct ipoib_cb *cb ;
  struct ipoib_cb *tmp___0 ;
  struct ipoib_header *header ;
  unsigned long flags ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  struct ipoib_cm_tx *tmp___4 ;
  int tmp___5 ;
  __u32 tmp___6 ;
  struct ipoib_cm_tx *tmp___7 ;
  raw_spinlock_t *tmp___8 ;
  __u32 tmp___9 ;

  {
#line 724
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 724
  priv = (struct ipoib_dev_priv *)tmp;
#line 726
  tmp___0 = ipoib_skb_cb((struct sk_buff  const  *)skb);
#line 726
  cb = tmp___0;
#line 730
  header = (struct ipoib_header *)skb->data;
#line 732
  tmp___2 = ldv__builtin_expect((unsigned int )cb->hwaddr[4] == 255U, 0L);
#line 732
  if (tmp___2 != 0L) {
#line 734
    if (((((unsigned int )header->proto != 8U && (unsigned int )header->proto != 56710U) && (unsigned int )header->proto != 1544U) && (unsigned int )header->proto != 13696U) && (unsigned int )header->proto != 51848U) {
#line 740
      dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 741
      dev_kfree_skb_any(skb);
#line 742
      return (0);
    } else {

    }
#line 745
    cb->hwaddr[8] = (u8 )((int )priv->pkey >> 8);
#line 746
    cb->hwaddr[9] = (u8 )priv->pkey;
#line 748
    neigh = ipoib_neigh_get(dev, (u8 *)(& cb->hwaddr));
#line 749
    tmp___1 = ldv__builtin_expect((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0),
                               1L);
#line 749
    if (tmp___1 != 0L) {
#line 750
      goto send_using_neigh;
    } else {

    }
#line 751
    ipoib_mcast_send(dev, (u8 *)(& cb->hwaddr), skb);
#line 752
    return (0);
  } else {

  }
#line 756
  switch ((int )header->proto) {
  case 8: ;
  case 56710: ;
  case 51848: 
#line 760
  neigh = ipoib_neigh_get(dev, (u8 *)(& cb->hwaddr));
#line 761
  tmp___3 = ldv__builtin_expect((unsigned long )neigh == (unsigned long )((struct ipoib_neigh *)0),
                             0L);
#line 761
  if (tmp___3 != 0L) {
#line 762
    neigh_add_path(skb, (u8 *)(& cb->hwaddr), dev);
#line 763
    return (0);
  } else {

  }
#line 765
  goto ldv_50479;
  case 1544: ;
  case 13696: 
#line 769
  unicast_arp_send(skb, dev, cb);
#line 770
  return (0);
  default: 
#line 773
  dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 774
  dev_kfree_skb_any(skb);
#line 775
  return (0);
  }
  ldv_50479: ;
  send_using_neigh: 
#line 780
  tmp___7 = ipoib_cm_get(neigh);
#line 780
  if ((unsigned long )tmp___7 != (unsigned long )((struct ipoib_cm_tx *)0)) {
#line 781
    tmp___5 = ipoib_cm_up(neigh);
#line 781
    if (tmp___5 != 0) {
#line 782
      tmp___4 = ipoib_cm_get(neigh);
#line 782
      ipoib_cm_send(dev, skb, tmp___4);
#line 783
      goto unref;
    } else {

    }
  } else
#line 785
  if ((unsigned long )neigh->ah != (unsigned long )((struct ipoib_ah *)0)) {
#line 786
    tmp___6 = __be32_to_cpup((__be32 const   *)(& cb->hwaddr));
#line 786
    ipoib_send(dev, skb, neigh->ah, tmp___6 & 16777215U);
#line 787
    goto unref;
  } else {

  }
#line 790
  tmp___9 = skb_queue_len((struct sk_buff_head  const  *)(& neigh->queue));
#line 790
  if (tmp___9 <= 2U) {
#line 791
    tmp___8 = spinlock_check(& priv->lock);
#line 791
    flags = _raw_spin_lock_irqsave(tmp___8);
#line 792
    __skb_queue_tail(& neigh->queue, skb);
#line 793
    spin_unlock_irqrestore(& priv->lock, flags);
  } else {
#line 795
    dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 796
    dev_kfree_skb_any(skb);
  }
  unref: 
#line 800
  ipoib_neigh_put(neigh);
#line 802
  return (0);
}
}
#line 805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_timeout(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
#line 807
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 807
  priv = (struct ipoib_dev_priv *)tmp;
#line 809
  tmp___0 = jiffies_to_msecs((unsigned long )jiffies - dev->trans_start);
#line 809
  printk("\f%s: transmit timeout: latency %d msecs\n", (char *)(& (priv->dev)->name),
         tmp___0);
#line 811
  tmp___1 = netif_queue_stopped((struct net_device  const  *)dev);
#line 811
  printk("\f%s: queue stopped %d, tx_head %u, tx_tail %u\n", (char *)(& (priv->dev)->name),
         (int )tmp___1, priv->tx_head, priv->tx_tail);
#line 812
  return;
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int ipoib_hard_header(struct sk_buff *skb , struct net_device *dev , unsigned short type ,
                             void const   *daddr , void const   *saddr , unsigned int len ) 
{ 
  struct ipoib_header *header ;
  struct ipoib_cb *cb ;
  struct ipoib_cb *tmp ;
  unsigned char *tmp___0 ;
  __u16 tmp___1 ;

  {
#line 823
  tmp = ipoib_skb_cb((struct sk_buff  const  *)skb);
#line 823
  cb = tmp;
#line 825
  tmp___0 = skb_push(skb, 4U);
#line 825
  header = (struct ipoib_header *)tmp___0;
#line 827
  tmp___1 = __fswab16((int )type);
#line 827
  header->proto = tmp___1;
#line 828
  header->reserved = 0U;
#line 835
  memcpy((void *)(& cb->hwaddr), daddr, 20UL);
#line 837
  return (4);
}
}
#line 840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_set_mcast_list(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;

  {
#line 842
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 842
  priv = (struct ipoib_dev_priv *)tmp;
#line 844
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->flags));
#line 844
  if (tmp___0 == 0) {
#line 845
    if (ipoib_debug_level > 0) {
#line 845
      printk("\017%s: IPOIB_FLAG_OPER_UP not set", (char *)(& (priv->dev)->name));
    } else {

    }
#line 846
    return;
  } else {

  }
#line 849
  queue_work(priv->wq, & priv->restart_task);
#line 850
  return;
}
}
#line 852 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int ipoib_get_iflink(struct net_device  const  *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;

  {
#line 854
  tmp = netdev_priv(dev);
#line 854
  priv = (struct ipoib_dev_priv *)tmp;
#line 857
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->flags));
#line 857
  if (tmp___0 == 0) {
#line 858
    return ((int )dev->ifindex);
  } else {

  }
#line 861
  return ((priv->parent)->ifindex);
}
}
#line 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static u32 ipoib_addr_hash(struct ipoib_neigh_hash *htbl , u8 *daddr ) 
{ 
  u32 *d32 ;
  u32 hv ;

  {
#line 873
  d32 = (u32 *)daddr;
#line 876
  hv = jhash_3words(*(d32 + 3UL), *(d32 + 4UL), *d32 & 4294967040U, 0U);
#line 877
  return (htbl->mask & hv);
}
}
#line 880 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
struct ipoib_neigh *ipoib_neigh_get(struct net_device *dev , u8 *daddr ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_neigh_table *ntbl ;
  struct ipoib_neigh_hash *htbl ;
  struct ipoib_neigh *neigh ;
  u32 hash_val ;
  struct ipoib_neigh_hash *________p1 ;
  struct ipoib_neigh_hash *_________p1 ;
  union __anonunion___u_362 __u ;
  bool __warned ;
  int tmp___0 ;
  int tmp___1 ;
  struct ipoib_neigh *________p1___0 ;
  struct ipoib_neigh *_________p1___0 ;
  union __anonunion___u_364 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct ipoib_neigh *________p1___1 ;
  struct ipoib_neigh *_________p1___1 ;
  union __anonunion___u_366 __u___1 ;
  bool __warned___1 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 882
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 882
  priv = (struct ipoib_dev_priv *)tmp;
#line 883
  ntbl = & priv->ntbl;
#line 885
  neigh = (struct ipoib_neigh *)0;
#line 888
  rcu_read_lock_bh();
#line 890
  __read_once_size((void const volatile   *)(& ntbl->htbl), (void *)(& __u.__c), 8);
#line 890
  _________p1 = __u.__val;
#line 890
  ________p1 = _________p1;
#line 890
  tmp___0 = debug_lockdep_rcu_enabled();
#line 890
  if (tmp___0 != 0 && ! __warned) {
#line 890
    tmp___1 = rcu_read_lock_bh_held();
#line 890
    if (tmp___1 == 0) {
#line 890
      __warned = 1;
#line 890
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             890, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 890
  htbl = ________p1;
#line 892
  if ((unsigned long )htbl == (unsigned long )((struct ipoib_neigh_hash *)0)) {
#line 893
    goto out_unlock;
  } else {

  }
#line 895
  hash_val = ipoib_addr_hash(htbl, daddr);
#line 896
  __read_once_size((void const volatile   *)htbl->buckets + (unsigned long )hash_val,
                   (void *)(& __u___0.__c), 8);
#line 896
  _________p1___0 = __u___0.__val;
#line 896
  ________p1___0 = _________p1___0;
#line 896
  tmp___2 = debug_lockdep_rcu_enabled();
#line 896
  if (tmp___2 != 0 && ! __warned___0) {
#line 896
    tmp___3 = rcu_read_lock_bh_held();
#line 896
    if (tmp___3 == 0) {
#line 896
      __warned___0 = 1;
#line 896
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             896, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 896
  neigh = ________p1___0;
#line 896
  goto ldv_50556;
  ldv_50555: 
#line 899
  tmp___5 = memcmp((void const   *)daddr, (void const   *)(& neigh->daddr), 20UL);
#line 899
  if (tmp___5 == 0) {
#line 901
    tmp___4 = atomic_add_unless(& neigh->refcnt, 1, 0);
#line 901
    if (tmp___4 == 0) {
#line 903
      neigh = (struct ipoib_neigh *)0;
#line 904
      goto out_unlock;
    } else {

    }
#line 906
    neigh->alive = jiffies;
#line 907
    goto out_unlock;
  } else {

  }
#line 898
  __read_once_size((void const volatile   *)(& neigh->hnext), (void *)(& __u___1.__c),
                   8);
#line 898
  _________p1___1 = __u___1.__val;
#line 898
  ________p1___1 = _________p1___1;
#line 898
  tmp___6 = debug_lockdep_rcu_enabled();
#line 898
  if (tmp___6 != 0 && ! __warned___1) {
#line 898
    tmp___7 = rcu_read_lock_bh_held();
#line 898
    if (tmp___7 == 0) {
#line 898
      __warned___1 = 1;
#line 898
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             898, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
#line 898
  neigh = ________p1___1;
  ldv_50556: ;
#line 896
  if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 899
    goto ldv_50555;
  } else {

  }

  out_unlock: 
#line 912
  rcu_read_unlock_bh();
#line 913
  return (neigh);
}
}
#line 953
extern void __compiletime_assert_953(void) ;
#line 916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void __ipoib_reap_neigh(struct ipoib_dev_priv *priv ) 
{ 
  struct ipoib_neigh_table *ntbl ;
  struct ipoib_neigh_hash *htbl ;
  unsigned long neigh_obsolete ;
  unsigned long dt ;
  unsigned long flags ;
  int i ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  bool __warned ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct ipoib_neigh *neigh ;
  struct ipoib_neigh **np ;
  bool __cond ;
  struct ipoib_neigh *__var ;
  bool __warned___0 ;
  int tmp___4 ;
  int tmp___5 ;
  bool __warned___1 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 918
  ntbl = & priv->ntbl;
#line 925
  tmp = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->flags));
#line 925
  if (tmp != 0) {
#line 926
    return;
  } else {

  }
#line 928
  tmp___0 = spinlock_check(& priv->lock);
#line 928
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 930
  tmp___1 = debug_lockdep_rcu_enabled();
#line 930
  if (tmp___1 != 0 && ! __warned) {
#line 930
    tmp___2 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 930
    if (tmp___2 == 0) {
#line 930
      __warned = 1;
#line 930
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             931, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 930
  htbl = ntbl->htbl;
#line 933
  if ((unsigned long )htbl == (unsigned long )((struct ipoib_neigh_hash *)0)) {
#line 934
    goto out_unlock;
  } else {

  }
#line 937
  dt = (unsigned long )(arp_tbl.gc_interval * 2);
#line 938
  neigh_obsolete = (unsigned long )jiffies - dt;
#line 940
  tmp___3 = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->flags));
#line 940
  if (tmp___3 != 0) {
#line 941
    goto out_unlock;
  } else {

  }
#line 943
  i = 0;
#line 943
  goto ldv_50597;
  ldv_50596: 
#line 945
  np = htbl->buckets + (unsigned long )i;
#line 947
  goto ldv_50594;
  ldv_50593: ;
#line 950
  if ((long )(neigh->alive - neigh_obsolete) < 0L) {
#line 951
    __cond = 0;
#line 951
    if ((int )__cond) {
#line 951
      __compiletime_assert_953();
    } else {

    }
#line 951
    __asm__  volatile   ("": : : "memory");
#line 951
    __var = (struct ipoib_neigh *)0;
#line 951
    tmp___4 = debug_lockdep_rcu_enabled();
#line 951
    if (tmp___4 != 0 && ! __warned___0) {
#line 951
      tmp___5 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 951
      if (tmp___5 == 0) {
#line 951
        __warned___0 = 1;
#line 951
        lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                               953, "suspicious rcu_dereference_protected() usage");
      } else {

      }
    } else {

    }
#line 951
    *((struct ipoib_neigh * volatile  *)np) = neigh->hnext;
#line 955
    list_del(& neigh->list);
#line 956
    call_rcu_sched(& neigh->rcu, & ipoib_neigh_reclaim);
  } else {
#line 958
    np = & neigh->hnext;
  }
  ldv_50594: 
#line 947
  tmp___6 = debug_lockdep_rcu_enabled();
#line 947
  if (tmp___6 != 0 && ! __warned___1) {
#line 947
    tmp___7 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 947
    if (tmp___7 == 0) {
#line 947
      __warned___1 = 1;
#line 947
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             948, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 947
  neigh = *np;
#line 947
  if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 950
    goto ldv_50593;
  } else {

  }
#line 943
  i = i + 1;
  ldv_50597: ;
#line 943
  if ((u32 )i < htbl->size) {
#line 945
    goto ldv_50596;
  } else {

  }

  out_unlock: 
#line 965
  spin_unlock_irqrestore(& priv->lock, flags);
#line 966
  return;
}
}
#line 968 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_reap_neigh(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;

  {
#line 971
  __mptr = (struct work_struct  const  *)work;
#line 971
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff990UL;
#line 973
  __ipoib_reap_neigh(priv);
#line 975
  tmp = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->flags));
#line 975
  if (tmp == 0) {
#line 976
    queue_delayed_work(priv->wq, & priv->neigh_reap_task, (unsigned long )arp_tbl.gc_interval);
  } else {

  }
#line 978
  return;
}
}
#line 981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct ipoib_neigh *ipoib_neigh_ctor(u8 *daddr , struct net_device *dev ) 
{ 
  struct ipoib_neigh *neigh ;
  void *tmp ;

  {
#line 986
  tmp = kzalloc(200UL, 32U);
#line 986
  neigh = (struct ipoib_neigh *)tmp;
#line 987
  if ((unsigned long )neigh == (unsigned long )((struct ipoib_neigh *)0)) {
#line 988
    return ((struct ipoib_neigh *)0);
  } else {

  }
#line 990
  neigh->dev = dev;
#line 991
  memcpy((void *)(& neigh->daddr), (void const   *)daddr, 20UL);
#line 992
  skb_queue_head_init(& neigh->queue);
#line 993
  INIT_LIST_HEAD(& neigh->list);
#line 994
  ipoib_cm_set(neigh, (struct ipoib_cm_tx *)0);
#line 996
  atomic_set(& neigh->refcnt, 1);
#line 998
  return (neigh);
}
}
#line 1048
extern void __compiletime_assert_1048(void) ;
#line 1049
extern void __compiletime_assert_1049(void) ;
#line 1001 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
struct ipoib_neigh *ipoib_neigh_alloc(u8 *daddr , struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_neigh_table *ntbl ;
  struct ipoib_neigh_hash *htbl ;
  struct ipoib_neigh *neigh ;
  u32 hash_val ;
  bool __warned ;
  int tmp___0 ;
  int tmp___1 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool __warned___1 ;
  int tmp___6 ;
  int tmp___7 ;
  bool __cond ;
  struct ipoib_neigh *__var ;
  bool __warned___2 ;
  int tmp___8 ;
  int tmp___9 ;
  bool __cond___0 ;
  struct ipoib_neigh *__var___0 ;

  {
#line 1004
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1004
  priv = (struct ipoib_dev_priv *)tmp;
#line 1005
  ntbl = & priv->ntbl;
#line 1010
  tmp___0 = debug_lockdep_rcu_enabled();
#line 1010
  if (tmp___0 != 0 && ! __warned) {
#line 1010
    tmp___1 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1010
    if (tmp___1 == 0) {
#line 1010
      __warned = 1;
#line 1010
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1011, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1010
  htbl = ntbl->htbl;
#line 1012
  if ((unsigned long )htbl == (unsigned long )((struct ipoib_neigh_hash *)0)) {
#line 1013
    neigh = (struct ipoib_neigh *)0;
#line 1014
    goto out_unlock;
  } else {

  }
#line 1020
  hash_val = ipoib_addr_hash(htbl, daddr);
#line 1021
  tmp___2 = debug_lockdep_rcu_enabled();
#line 1021
  if (tmp___2 != 0 && ! __warned___0) {
#line 1021
    tmp___3 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1021
    if (tmp___3 == 0) {
#line 1021
      __warned___0 = 1;
#line 1021
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1022, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1021
  neigh = *(htbl->buckets + (unsigned long )hash_val);
#line 1021
  goto ldv_50628;
  ldv_50627: 
#line 1026
  tmp___5 = memcmp((void const   *)daddr, (void const   *)(& neigh->daddr), 20UL);
#line 1026
  if (tmp___5 == 0) {
#line 1028
    tmp___4 = atomic_add_unless(& neigh->refcnt, 1, 0);
#line 1028
    if (tmp___4 == 0) {
#line 1030
      neigh = (struct ipoib_neigh *)0;
#line 1031
      goto ldv_50626;
    } else {

    }
#line 1033
    neigh->alive = jiffies;
#line 1034
    goto out_unlock;
  } else {

  }
#line 1024
  tmp___6 = debug_lockdep_rcu_enabled();
#line 1024
  if (tmp___6 != 0 && ! __warned___1) {
#line 1024
    tmp___7 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1024
    if (tmp___7 == 0) {
#line 1024
      __warned___1 = 1;
#line 1024
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1025, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1024
  neigh = neigh->hnext;
  ldv_50628: ;
#line 1021
  if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 1025
    goto ldv_50627;
  } else {

  }
  ldv_50626: 
#line 1038
  neigh = ipoib_neigh_ctor(daddr, dev);
#line 1039
  if ((unsigned long )neigh == (unsigned long )((struct ipoib_neigh *)0)) {
#line 1040
    goto out_unlock;
  } else {

  }
#line 1043
  atomic_inc(& neigh->refcnt);
#line 1044
  neigh->alive = jiffies;
#line 1046
  __cond = 0;
#line 1046
  if ((int )__cond) {
#line 1046
    __compiletime_assert_1048();
  } else {

  }
#line 1046
  __asm__  volatile   ("": : : "memory");
#line 1046
  __var = (struct ipoib_neigh *)0;
#line 1046
  tmp___8 = debug_lockdep_rcu_enabled();
#line 1046
  if (tmp___8 != 0 && ! __warned___2) {
#line 1046
    tmp___9 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1046
    if (tmp___9 == 0) {
#line 1046
      __warned___2 = 1;
#line 1046
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1048, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1046
  *((struct ipoib_neigh * volatile  *)(& neigh->hnext)) = *(htbl->buckets + (unsigned long )hash_val);
#line 1049
  __cond___0 = 0;
#line 1049
  if ((int )__cond___0) {
#line 1049
    __compiletime_assert_1049();
  } else {

  }
#line 1049
  __asm__  volatile   ("": : : "memory");
#line 1049
  __var___0 = (struct ipoib_neigh *)0;
#line 1049
  *((struct ipoib_neigh * volatile  *)htbl->buckets + (unsigned long )hash_val) = neigh;
#line 1050
  atomic_inc(& ntbl->entries);
  out_unlock: ;
#line 1054
  return (neigh);
}
}
#line 1057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_neigh_dtor(struct ipoib_neigh *neigh ) 
{ 
  struct net_device *dev ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct sk_buff *skb ;
  struct ipoib_cm_tx *tmp___0 ;
  struct ipoib_cm_tx *tmp___1 ;
  __u32 tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1060
  dev = neigh->dev;
#line 1061
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1061
  priv = (struct ipoib_dev_priv *)tmp;
#line 1063
  if ((unsigned long )neigh->ah != (unsigned long )((struct ipoib_ah *)0)) {
#line 1064
    ipoib_put_ah(neigh->ah);
  } else {

  }
#line 1065
  goto ldv_50652;
  ldv_50651: 
#line 1066
  dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 1067
  dev_kfree_skb_any(skb);
  ldv_50652: 
#line 1065
  skb = __skb_dequeue(& neigh->queue);
#line 1065
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1067
    goto ldv_50651;
  } else {

  }
#line 1069
  tmp___1 = ipoib_cm_get(neigh);
#line 1069
  if ((unsigned long )tmp___1 != (unsigned long )((struct ipoib_cm_tx *)0)) {
#line 1070
    tmp___0 = ipoib_cm_get(neigh);
#line 1070
    ipoib_cm_destroy_tx(tmp___0);
  } else {

  }
#line 1071
  if (ipoib_debug_level > 0) {
#line 1071
    tmp___2 = __be32_to_cpup((__be32 const   *)(& neigh->daddr));
#line 1071
    tmp___3 = netdev_priv((struct net_device  const  *)dev);
#line 1071
    printk("\017%s: neigh free for %06x %pI6\n", (char *)(& (((struct ipoib_dev_priv *)tmp___3)->dev)->name),
           tmp___2 & 16777215U, (u8 *)(& neigh->daddr) + 4UL);
  } else {

  }
#line 1075
  kfree((void const   *)neigh);
#line 1076
  tmp___5 = atomic_dec_and_test(& priv->ntbl.entries);
#line 1076
  if (tmp___5 != 0) {
#line 1077
    tmp___4 = constant_test_bit(12L, (unsigned long const volatile   *)(& priv->flags));
#line 1077
    if (tmp___4 != 0) {
#line 1078
      complete(& priv->ntbl.flushed);
    } else {

    }
  } else {

  }
#line 1079
  return;
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_neigh_reclaim(struct callback_head *rp ) 
{ 
  struct ipoib_neigh *neigh ;
  struct callback_head  const  *__mptr ;

  {
#line 1085
  __mptr = (struct callback_head  const  *)rp;
#line 1085
  neigh = (struct ipoib_neigh *)__mptr + 0xffffffffffffff58UL;
#line 1087
  ipoib_neigh_put(neigh);
#line 1088
  return;
}
}
#line 1116
extern void __compiletime_assert_1116(void) ;
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_neigh_free(struct ipoib_neigh *neigh ) 
{ 
  struct net_device *dev ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_neigh_table *ntbl ;
  struct ipoib_neigh_hash *htbl ;
  struct ipoib_neigh **np ;
  struct ipoib_neigh *n ;
  u32 hash_val ;
  bool __warned ;
  int tmp___0 ;
  int tmp___1 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;
  bool __cond ;
  struct ipoib_neigh *__var ;
  bool __warned___1 ;
  int tmp___4 ;
  int tmp___5 ;
  bool __warned___2 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1092
  dev = neigh->dev;
#line 1093
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1093
  priv = (struct ipoib_dev_priv *)tmp;
#line 1094
  ntbl = & priv->ntbl;
#line 1100
  tmp___0 = debug_lockdep_rcu_enabled();
#line 1100
  if (tmp___0 != 0 && ! __warned) {
#line 1100
    tmp___1 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1100
    if (tmp___1 == 0) {
#line 1100
      __warned = 1;
#line 1100
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1101, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1100
  htbl = ntbl->htbl;
#line 1102
  if ((unsigned long )htbl == (unsigned long )((struct ipoib_neigh_hash *)0)) {
#line 1103
    return;
  } else {

  }
#line 1105
  hash_val = ipoib_addr_hash(htbl, (u8 *)(& neigh->daddr));
#line 1106
  np = htbl->buckets + (unsigned long )hash_val;
#line 1107
  tmp___2 = debug_lockdep_rcu_enabled();
#line 1107
  if (tmp___2 != 0 && ! __warned___0) {
#line 1107
    tmp___3 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1107
    if (tmp___3 == 0) {
#line 1107
      __warned___0 = 1;
#line 1107
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1108, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1107
  n = *np;
#line 1107
  goto ldv_50687;
  ldv_50686: ;
#line 1112
  if ((unsigned long )n == (unsigned long )neigh) {
#line 1114
    __cond = 0;
#line 1114
    if ((int )__cond) {
#line 1114
      __compiletime_assert_1116();
    } else {

    }
#line 1114
    __asm__  volatile   ("": : : "memory");
#line 1114
    __var = (struct ipoib_neigh *)0;
#line 1114
    tmp___4 = debug_lockdep_rcu_enabled();
#line 1114
    if (tmp___4 != 0 && ! __warned___1) {
#line 1114
      tmp___5 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1114
      if (tmp___5 == 0) {
#line 1114
        __warned___1 = 1;
#line 1114
        lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                               1116, "suspicious rcu_dereference_protected() usage");
      } else {

      }
    } else {

    }
#line 1114
    *((struct ipoib_neigh * volatile  *)np) = neigh->hnext;
#line 1118
    list_del(& neigh->list);
#line 1119
    call_rcu_sched(& neigh->rcu, & ipoib_neigh_reclaim);
#line 1120
    return;
  } else {
#line 1122
    np = & n->hnext;
  }
#line 1110
  tmp___6 = debug_lockdep_rcu_enabled();
#line 1110
  if (tmp___6 != 0 && ! __warned___2) {
#line 1110
    tmp___7 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1110
    if (tmp___7 == 0) {
#line 1110
      __warned___2 = 1;
#line 1110
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1111, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1110
  n = *np;
  ldv_50687: ;
#line 1107
  if ((unsigned long )n != (unsigned long )((struct ipoib_neigh *)0)) {
#line 1111
    goto ldv_50686;
  } else {

  }

#line 1116
  return;
}
}
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int ipoib_neigh_hash_init(struct ipoib_dev_priv *priv ) 
{ 
  struct ipoib_neigh_table *ntbl ;
  struct ipoib_neigh_hash *htbl ;
  struct ipoib_neigh **buckets ;
  u32 size ;
  void *tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;

  {
#line 1129
  ntbl = & priv->ntbl;
#line 1134
  clear_bit(12L, (unsigned long volatile   *)(& priv->flags));
#line 1135
  ntbl->htbl = (struct ipoib_neigh_hash *)0;
#line 1136
  tmp = kzalloc(40UL, 208U);
#line 1136
  htbl = (struct ipoib_neigh_hash *)tmp;
#line 1137
  if ((unsigned long )htbl == (unsigned long )((struct ipoib_neigh_hash *)0)) {
#line 1138
    return (-12);
  } else {

  }
#line 1139
  set_bit(11L, (unsigned long volatile   *)(& priv->flags));
#line 1140
  tmp___0 = __roundup_pow_of_two((unsigned long )arp_tbl.gc_thresh3);
#line 1140
  size = (u32 )tmp___0;
#line 1141
  tmp___1 = kzalloc((unsigned long )size * 8UL, 208U);
#line 1141
  buckets = (struct ipoib_neigh **)tmp___1;
#line 1142
  if ((unsigned long )buckets == (unsigned long )((struct ipoib_neigh **)0)) {
#line 1143
    kfree((void const   *)htbl);
#line 1144
    return (-12);
  } else {

  }
#line 1146
  htbl->size = size;
#line 1147
  htbl->mask = size - 1U;
#line 1148
  htbl->buckets = buckets;
#line 1149
  ntbl->htbl = htbl;
#line 1150
  htbl->ntbl = ntbl;
#line 1151
  atomic_set(& ntbl->entries, 0);
#line 1154
  clear_bit(11L, (unsigned long volatile   *)(& priv->flags));
#line 1155
  queue_delayed_work(priv->wq, & priv->neigh_reap_task, (unsigned long )arp_tbl.gc_interval);
#line 1158
  return (0);
}
}
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void neigh_hash_free_rcu(struct callback_head *head ) 
{ 
  struct ipoib_neigh_hash *htbl ;
  struct callback_head  const  *__mptr ;
  struct ipoib_neigh **buckets ;
  struct ipoib_neigh_table *ntbl ;

  {
#line 1163
  __mptr = (struct callback_head  const  *)head;
#line 1163
  htbl = (struct ipoib_neigh_hash *)__mptr + 0xfffffffffffffff0UL;
#line 1166
  buckets = htbl->buckets;
#line 1167
  ntbl = htbl->ntbl;
#line 1169
  kfree((void const   *)buckets);
#line 1170
  kfree((void const   *)htbl);
#line 1171
  complete(& ntbl->deleted);
#line 1172
  return;
}
}
#line 1201
extern void __compiletime_assert_1201(void) ;
#line 1174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_del_neighs_by_gid(struct net_device *dev , u8 *gid ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_neigh_table *ntbl ;
  struct ipoib_neigh_hash *htbl ;
  unsigned long flags ;
  int i ;
  raw_spinlock_t *tmp___0 ;
  bool __warned ;
  int tmp___1 ;
  int tmp___2 ;
  struct ipoib_neigh *neigh ;
  struct ipoib_neigh **np ;
  bool __cond ;
  struct ipoib_neigh *__var ;
  bool __warned___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool __warned___1 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1176
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1176
  priv = (struct ipoib_dev_priv *)tmp;
#line 1177
  ntbl = & priv->ntbl;
#line 1183
  tmp___0 = spinlock_check(& priv->lock);
#line 1183
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1185
  tmp___1 = debug_lockdep_rcu_enabled();
#line 1185
  if (tmp___1 != 0 && ! __warned) {
#line 1185
    tmp___2 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1185
    if (tmp___2 == 0) {
#line 1185
      __warned = 1;
#line 1185
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1186, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1185
  htbl = ntbl->htbl;
#line 1188
  if ((unsigned long )htbl == (unsigned long )((struct ipoib_neigh_hash *)0)) {
#line 1189
    goto out_unlock;
  } else {

  }
#line 1191
  i = 0;
#line 1191
  goto ldv_50737;
  ldv_50736: 
#line 1193
  np = htbl->buckets + (unsigned long )i;
#line 1195
  goto ldv_50734;
  ldv_50733: 
#line 1198
  tmp___5 = memcmp((void const   *)gid, (void const   *)(& neigh->daddr) + 4U, 16UL);
#line 1198
  if (tmp___5 == 0) {
#line 1199
    __cond = 0;
#line 1199
    if ((int )__cond) {
#line 1199
      __compiletime_assert_1201();
    } else {

    }
#line 1199
    __asm__  volatile   ("": : : "memory");
#line 1199
    __var = (struct ipoib_neigh *)0;
#line 1199
    tmp___3 = debug_lockdep_rcu_enabled();
#line 1199
    if (tmp___3 != 0 && ! __warned___0) {
#line 1199
      tmp___4 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1199
      if (tmp___4 == 0) {
#line 1199
        __warned___0 = 1;
#line 1199
        lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                               1201, "suspicious rcu_dereference_protected() usage");
      } else {

      }
    } else {

    }
#line 1199
    *((struct ipoib_neigh * volatile  *)np) = neigh->hnext;
#line 1203
    list_del(& neigh->list);
#line 1204
    call_rcu_sched(& neigh->rcu, & ipoib_neigh_reclaim);
  } else {
#line 1206
    np = & neigh->hnext;
  }
  ldv_50734: 
#line 1195
  tmp___6 = debug_lockdep_rcu_enabled();
#line 1195
  if (tmp___6 != 0 && ! __warned___1) {
#line 1195
    tmp___7 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1195
    if (tmp___7 == 0) {
#line 1195
      __warned___1 = 1;
#line 1195
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1196, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1195
  neigh = *np;
#line 1195
  if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 1198
    goto ldv_50733;
  } else {

  }
#line 1191
  i = i + 1;
  ldv_50737: ;
#line 1191
  if ((u32 )i < htbl->size) {
#line 1193
    goto ldv_50736;
  } else {

  }

  out_unlock: 
#line 1212
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1213
  return;
}
}
#line 1243
extern void __compiletime_assert_1243(void) ;
#line 1251
extern void __compiletime_assert_1251(void) ;
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_flush_neighs(struct ipoib_dev_priv *priv ) 
{ 
  struct ipoib_neigh_table *ntbl ;
  struct ipoib_neigh_hash *htbl ;
  unsigned long flags ;
  int i ;
  int wait_flushed ;
  raw_spinlock_t *tmp ;
  bool __warned ;
  int tmp___0 ;
  int tmp___1 ;
  struct ipoib_neigh *neigh ;
  struct ipoib_neigh **np ;
  bool __cond ;
  struct ipoib_neigh *__var ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;
  bool __warned___1 ;
  int tmp___4 ;
  int tmp___5 ;
  bool __cond___0 ;
  struct ipoib_neigh_hash *__var___0 ;

  {
#line 1217
  ntbl = & priv->ntbl;
#line 1220
  wait_flushed = 0;
#line 1222
  init_completion(& priv->ntbl.flushed);
#line 1224
  tmp = spinlock_check(& priv->lock);
#line 1224
  flags = _raw_spin_lock_irqsave(tmp);
#line 1226
  tmp___0 = debug_lockdep_rcu_enabled();
#line 1226
  if (tmp___0 != 0 && ! __warned) {
#line 1226
    tmp___1 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1226
    if (tmp___1 == 0) {
#line 1226
      __warned = 1;
#line 1226
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1227, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1226
  htbl = ntbl->htbl;
#line 1228
  if ((unsigned long )htbl == (unsigned long )((struct ipoib_neigh_hash *)0)) {
#line 1229
    goto out_unlock;
  } else {

  }
#line 1231
  wait_flushed = atomic_read((atomic_t const   *)(& priv->ntbl.entries));
#line 1232
  if (wait_flushed == 0) {
#line 1233
    goto free_htbl;
  } else {

  }
#line 1235
  i = 0;
#line 1235
  goto ldv_50772;
  ldv_50771: 
#line 1237
  np = htbl->buckets + (unsigned long )i;
#line 1239
  goto ldv_50769;
  ldv_50768: 
#line 1241
  __cond = 0;
#line 1241
  if ((int )__cond) {
#line 1241
    __compiletime_assert_1243();
  } else {

  }
#line 1241
  __asm__  volatile   ("": : : "memory");
#line 1241
  __var = (struct ipoib_neigh *)0;
#line 1241
  tmp___2 = debug_lockdep_rcu_enabled();
#line 1241
  if (tmp___2 != 0 && ! __warned___0) {
#line 1241
    tmp___3 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1241
    if (tmp___3 == 0) {
#line 1241
      __warned___0 = 1;
#line 1241
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1243, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1241
  *((struct ipoib_neigh * volatile  *)np) = neigh->hnext;
#line 1245
  list_del(& neigh->list);
#line 1246
  call_rcu_sched(& neigh->rcu, & ipoib_neigh_reclaim);
  ldv_50769: 
#line 1239
  tmp___4 = debug_lockdep_rcu_enabled();
#line 1239
  if (tmp___4 != 0 && ! __warned___1) {
#line 1239
    tmp___5 = lock_is_held(& priv->lock.__annonCompField18.__annonCompField17.dep_map);
#line 1239
    if (tmp___5 == 0) {
#line 1239
      __warned___1 = 1;
#line 1239
      lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
                             1240, "suspicious rcu_dereference_protected() usage");
    } else {

    }
  } else {

  }
#line 1239
  neigh = *np;
#line 1239
  if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 1242
    goto ldv_50768;
  } else {

  }
#line 1235
  i = i + 1;
  ldv_50772: ;
#line 1235
  if ((u32 )i < htbl->size) {
#line 1237
    goto ldv_50771;
  } else {

  }

  free_htbl: 
#line 1251
  __cond___0 = 0;
#line 1251
  if ((int )__cond___0) {
#line 1251
    __compiletime_assert_1251();
  } else {

  }
#line 1251
  __asm__  volatile   ("": : : "memory");
#line 1251
  __var___0 = (struct ipoib_neigh_hash *)0;
#line 1251
  *((struct ipoib_neigh_hash * volatile  *)(& ntbl->htbl)) = (struct ipoib_neigh_hash */* volatile  */)0;
#line 1252
  call_rcu_sched(& htbl->rcu, & neigh_hash_free_rcu);
  out_unlock: 
#line 1255
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1256
  if (wait_flushed != 0) {
#line 1257
    wait_for_completion(& priv->ntbl.flushed);
  } else {

  }
#line 1258
  return;
}
}
#line 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_neigh_hash_uninit(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int stopped ;

  {
#line 1262
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1262
  priv = (struct ipoib_dev_priv *)tmp;
#line 1265
  if (ipoib_debug_level > 0) {
#line 1265
    printk("\017%s: ipoib_neigh_hash_uninit\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 1266
  init_completion(& priv->ntbl.deleted);
#line 1267
  set_bit(12L, (unsigned long volatile   *)(& priv->flags));
#line 1270
  stopped = test_and_set_bit(11L, (unsigned long volatile   *)(& priv->flags));
#line 1271
  if (stopped == 0) {
#line 1272
    ldv_cancel_delayed_work_10(& priv->neigh_reap_task);
  } else {

  }
#line 1274
  ipoib_flush_neighs(priv);
#line 1276
  wait_for_completion(& priv->ntbl.deleted);
#line 1277
  return;
}
}
#line 1280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_dev_init(struct net_device *dev , struct ib_device *ca , int port ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1282
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1282
  priv = (struct ipoib_dev_priv *)tmp;
#line 1285
  tmp___0 = kzalloc((unsigned long )ipoib_recvq_size * 24UL, 208U);
#line 1285
  priv->rx_ring = (struct ipoib_rx_buf *)tmp___0;
#line 1287
  if ((unsigned long )priv->rx_ring == (unsigned long )((struct ipoib_rx_buf *)0)) {
#line 1288
    printk("\f%s: failed to allocate RX ring (%d entries)\n", (char *)(& ca->name),
           ipoib_recvq_size);
#line 1290
    goto out;
  } else {

  }
#line 1293
  tmp___1 = vzalloc((unsigned long )ipoib_sendq_size * 152UL);
#line 1293
  priv->tx_ring = (struct ipoib_tx_buf *)tmp___1;
#line 1294
  if ((unsigned long )priv->tx_ring == (unsigned long )((struct ipoib_tx_buf *)0)) {
#line 1295
    printk("\f%s: failed to allocate TX ring (%d entries)\n", (char *)(& ca->name),
           ipoib_sendq_size);
#line 1297
    goto out_rx_ring_cleanup;
  } else {

  }
#line 1302
  tmp___2 = ipoib_ib_dev_init(dev, ca, port);
#line 1302
  if (tmp___2 != 0) {
#line 1303
    goto out_tx_ring_cleanup;
  } else {

  }
#line 1309
  tmp___3 = ipoib_neigh_hash_init(priv);
#line 1309
  if (tmp___3 < 0) {
#line 1310
    goto out_dev_uninit;
  } else {

  }
#line 1312
  return (0);
  out_dev_uninit: 
#line 1315
  ipoib_ib_dev_cleanup(dev);
  out_tx_ring_cleanup: 
#line 1318
  vfree((void const   *)priv->tx_ring);
  out_rx_ring_cleanup: 
#line 1321
  kfree((void const   *)priv->rx_ring);
  out: ;
#line 1324
  return (-12);
}
}
#line 1327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_dev_cleanup(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_dev_priv *cpriv ;
  struct ipoib_dev_priv *tcpriv ;
  struct list_head head ;
  int tmp___0 ;
  long tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1329
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1329
  priv = (struct ipoib_dev_priv *)tmp;
#line 1330
  head.next = & head;
#line 1330
  head.prev = & head;
#line 1332
  tmp___0 = rtnl_is_locked();
#line 1332
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 1332
  if (tmp___1 != 0L) {
#line 1332
    printk("\vRTNL: assertion failed at %s (%d)\n", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c",
           1332);
#line 1332
    dump_stack();
  } else {

  }
#line 1334
  ipoib_delete_debug_files(dev);
#line 1337
  __mptr = (struct list_head  const  *)priv->child_intfs.next;
#line 1337
  cpriv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff128UL;
#line 1337
  __mptr___0 = (struct list_head  const  *)cpriv->list.next;
#line 1337
  tcpriv = (struct ipoib_dev_priv *)__mptr___0 + 0xfffffffffffff128UL;
#line 1337
  goto ldv_50809;
  ldv_50808: 
#line 1339
  set_bit(11L, (unsigned long volatile   *)(& cpriv->flags));
#line 1340
  ldv_cancel_delayed_work_11(& cpriv->neigh_reap_task);
#line 1341
  unregister_netdevice_queue(cpriv->dev, & head);
#line 1337
  cpriv = tcpriv;
#line 1337
  __mptr___1 = (struct list_head  const  *)tcpriv->list.next;
#line 1337
  tcpriv = (struct ipoib_dev_priv *)__mptr___1 + 0xfffffffffffff128UL;
  ldv_50809: ;
#line 1337
  if ((unsigned long )(& cpriv->list) != (unsigned long )(& priv->child_intfs)) {
#line 1339
    goto ldv_50808;
  } else {

  }
#line 1343
  unregister_netdevice_many(& head);
#line 1349
  ipoib_neigh_hash_uninit(dev);
#line 1351
  ipoib_ib_dev_cleanup(dev);
#line 1353
  kfree((void const   *)priv->rx_ring);
#line 1354
  vfree((void const   *)priv->tx_ring);
#line 1356
  priv->rx_ring = (struct ipoib_rx_buf *)0;
#line 1357
  priv->tx_ring = (struct ipoib_tx_buf *)0;
#line 1358
  return;
}
}
#line 1360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct header_ops  const  ipoib_header_ops  =    {& ipoib_hard_header, 0, 0, 0};
#line 1364 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct net_device_ops  const  ipoib_netdev_ops  = 
#line 1364
     {0, & ipoib_uninit, & ipoib_open, & ipoib_stop, (netdev_tx_t (*)(struct sk_buff * ,
                                                                    struct net_device * ))(& ipoib_start_xmit),
    0, 0, & ipoib_set_mcast_list, 0, 0, 0, 0, & ipoib_change_mtu, 0, & ipoib_timeout,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, & ipoib_fix_features, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, & ipoib_get_iflink};
#line 1376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_setup(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___4 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_3 ;
  struct lock_class_key __key___6 ;
  atomic_long_t __constr_expr_4 ;
  struct lock_class_key __key___7 ;
  atomic_long_t __constr_expr_5 ;
  struct lock_class_key __key___8 ;
  atomic_long_t __constr_expr_6 ;
  struct lock_class_key __key___9 ;
  struct lock_class_key __key___10 ;
  atomic_long_t __constr_expr_7 ;
  struct lock_class_key __key___11 ;

  {
#line 1378
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1378
  priv = (struct ipoib_dev_priv *)tmp;
#line 1380
  dev->netdev_ops = & ipoib_netdev_ops;
#line 1381
  dev->header_ops = & ipoib_header_ops;
#line 1383
  ipoib_set_ethtool_ops(dev);
#line 1385
  netif_napi_add(dev, & priv->napi, & ipoib_poll, 64);
#line 1387
  dev->watchdog_timeo = 250;
#line 1389
  dev->flags = dev->flags | 4098U;
#line 1391
  dev->hard_header_len = 4U;
#line 1392
  dev->addr_len = 20U;
#line 1393
  dev->type = 32U;
#line 1394
  dev->tx_queue_len = (unsigned long )(ipoib_sendq_size * 2);
#line 1395
  dev->features = 1056ULL;
#line 1397
  netif_keep_dst(dev);
#line 1399
  memcpy((void *)(& dev->broadcast), (void const   *)(& ipv4_bcast_addr), 20UL);
#line 1401
  priv->dev = dev;
#line 1403
  spinlock_check(& priv->lock);
#line 1403
  __raw_spin_lock_init(& priv->lock.__annonCompField18.rlock, "&(&priv->lock)->rlock",
                       & __key);
#line 1405
  __init_rwsem(& priv->vlan_rwsem, "&priv->vlan_rwsem", & __key___0);
#line 1407
  INIT_LIST_HEAD(& priv->path_list);
#line 1408
  INIT_LIST_HEAD(& priv->child_intfs);
#line 1409
  INIT_LIST_HEAD(& priv->dead_ahs);
#line 1410
  INIT_LIST_HEAD(& priv->multicast_list);
#line 1412
  __init_work(& priv->mcast_task.work, 0);
#line 1412
  __constr_expr_0.counter = 137438953408L;
#line 1412
  priv->mcast_task.work.data = __constr_expr_0;
#line 1412
  lockdep_init_map(& priv->mcast_task.work.lockdep_map, "(&(&priv->mcast_task)->work)",
                   & __key___1, 0);
#line 1412
  INIT_LIST_HEAD(& priv->mcast_task.work.entry);
#line 1412
  priv->mcast_task.work.func = & ipoib_mcast_join_task;
#line 1412
  init_timer_key(& priv->mcast_task.timer, 2097152U, "(&(&priv->mcast_task)->timer)",
                 & __key___2);
#line 1412
  priv->mcast_task.timer.function = & delayed_work_timer_fn;
#line 1412
  priv->mcast_task.timer.data = (unsigned long )(& priv->mcast_task);
#line 1413
  __init_work(& priv->carrier_on_task, 0);
#line 1413
  __constr_expr_1.counter = 137438953408L;
#line 1413
  priv->carrier_on_task.data = __constr_expr_1;
#line 1413
  lockdep_init_map(& priv->carrier_on_task.lockdep_map, "(&priv->carrier_on_task)",
                   & __key___3, 0);
#line 1413
  INIT_LIST_HEAD(& priv->carrier_on_task.entry);
#line 1413
  priv->carrier_on_task.func = & ipoib_mcast_carrier_on_task;
#line 1414
  __init_work(& priv->flush_light, 0);
#line 1414
  __constr_expr_2.counter = 137438953408L;
#line 1414
  priv->flush_light.data = __constr_expr_2;
#line 1414
  lockdep_init_map(& priv->flush_light.lockdep_map, "(&priv->flush_light)", & __key___4,
                   0);
#line 1414
  INIT_LIST_HEAD(& priv->flush_light.entry);
#line 1414
  priv->flush_light.func = & ipoib_ib_dev_flush_light;
#line 1415
  __init_work(& priv->flush_normal, 0);
#line 1415
  __constr_expr_3.counter = 137438953408L;
#line 1415
  priv->flush_normal.data = __constr_expr_3;
#line 1415
  lockdep_init_map(& priv->flush_normal.lockdep_map, "(&priv->flush_normal)", & __key___5,
                   0);
#line 1415
  INIT_LIST_HEAD(& priv->flush_normal.entry);
#line 1415
  priv->flush_normal.func = & ipoib_ib_dev_flush_normal;
#line 1416
  __init_work(& priv->flush_heavy, 0);
#line 1416
  __constr_expr_4.counter = 137438953408L;
#line 1416
  priv->flush_heavy.data = __constr_expr_4;
#line 1416
  lockdep_init_map(& priv->flush_heavy.lockdep_map, "(&priv->flush_heavy)", & __key___6,
                   0);
#line 1416
  INIT_LIST_HEAD(& priv->flush_heavy.entry);
#line 1416
  priv->flush_heavy.func = & ipoib_ib_dev_flush_heavy;
#line 1417
  __init_work(& priv->restart_task, 0);
#line 1417
  __constr_expr_5.counter = 137438953408L;
#line 1417
  priv->restart_task.data = __constr_expr_5;
#line 1417
  lockdep_init_map(& priv->restart_task.lockdep_map, "(&priv->restart_task)", & __key___7,
                   0);
#line 1417
  INIT_LIST_HEAD(& priv->restart_task.entry);
#line 1417
  priv->restart_task.func = & ipoib_mcast_restart_task;
#line 1418
  __init_work(& priv->ah_reap_task.work, 0);
#line 1418
  __constr_expr_6.counter = 137438953408L;
#line 1418
  priv->ah_reap_task.work.data = __constr_expr_6;
#line 1418
  lockdep_init_map(& priv->ah_reap_task.work.lockdep_map, "(&(&priv->ah_reap_task)->work)",
                   & __key___8, 0);
#line 1418
  INIT_LIST_HEAD(& priv->ah_reap_task.work.entry);
#line 1418
  priv->ah_reap_task.work.func = & ipoib_reap_ah;
#line 1418
  init_timer_key(& priv->ah_reap_task.timer, 2097152U, "(&(&priv->ah_reap_task)->timer)",
                 & __key___9);
#line 1418
  priv->ah_reap_task.timer.function = & delayed_work_timer_fn;
#line 1418
  priv->ah_reap_task.timer.data = (unsigned long )(& priv->ah_reap_task);
#line 1419
  __init_work(& priv->neigh_reap_task.work, 0);
#line 1419
  __constr_expr_7.counter = 137438953408L;
#line 1419
  priv->neigh_reap_task.work.data = __constr_expr_7;
#line 1419
  lockdep_init_map(& priv->neigh_reap_task.work.lockdep_map, "(&(&priv->neigh_reap_task)->work)",
                   & __key___10, 0);
#line 1419
  INIT_LIST_HEAD(& priv->neigh_reap_task.work.entry);
#line 1419
  priv->neigh_reap_task.work.func = & ipoib_reap_neigh;
#line 1419
  init_timer_key(& priv->neigh_reap_task.timer, 2097152U, "(&(&priv->neigh_reap_task)->timer)",
                 & __key___11);
#line 1419
  priv->neigh_reap_task.timer.function = & delayed_work_timer_fn;
#line 1419
  priv->neigh_reap_task.timer.data = (unsigned long )(& priv->neigh_reap_task);
#line 1420
  return;
}
}
#line 1422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
struct ipoib_dev_priv *ipoib_intf_alloc(char const   *name ) 
{ 
  struct net_device *dev ;
  void *tmp ;

  {
#line 1426
  dev = alloc_netdev_mqs(5328, name, 0, & ipoib_setup, 1U, 1U);
#line 1428
  if ((unsigned long )dev == (unsigned long )((struct net_device *)0)) {
#line 1429
    return ((struct ipoib_dev_priv *)0);
  } else {

  }
#line 1431
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1431
  return ((struct ipoib_dev_priv *)tmp);
}
}
#line 1434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static ssize_t show_pkey(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1437
  __mptr = (struct device  const  *)dev;
#line 1437
  tmp = netdev_priv((struct net_device  const  *)((struct net_device *)__mptr + 0xfffffffffffffaa0UL));
#line 1437
  priv = (struct ipoib_dev_priv *)tmp;
#line 1439
  tmp___0 = sprintf(buf, "0x%04x\n", (int )priv->pkey);
#line 1439
  return ((ssize_t )tmp___0);
}
}
#line 1441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct device_attribute dev_attr_pkey  =    {{"pkey", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                  {(char)0}, {(char)0}, {(char)0}}}}, & show_pkey,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 1443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static ssize_t show_umcast(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1446
  __mptr = (struct device  const  *)dev;
#line 1446
  tmp = netdev_priv((struct net_device  const  *)((struct net_device *)__mptr + 0xfffffffffffffaa0UL));
#line 1446
  priv = (struct ipoib_dev_priv *)tmp;
#line 1448
  tmp___0 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->flags));
#line 1448
  tmp___1 = sprintf(buf, "%d\n", tmp___0);
#line 1448
  return ((ssize_t )tmp___1);
}
}
#line 1451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
void ipoib_set_umcast(struct net_device *ndev , int umcast_val ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 1453
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1453
  priv = (struct ipoib_dev_priv *)tmp;
#line 1455
  if (umcast_val > 0) {
#line 1456
    set_bit(10L, (unsigned long volatile   *)(& priv->flags));
#line 1457
    printk("\f%s: ignoring multicast groups joined directly by userspace\n", (char *)(& (priv->dev)->name));
  } else {
#line 1460
    clear_bit(10L, (unsigned long volatile   *)(& priv->flags));
  }
#line 1461
  return;
}
}
#line 1463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static ssize_t set_umcast(struct device *dev , struct device_attribute *attr , char const   *buf ,
                          size_t count ) 
{ 
  unsigned long umcast_val ;
  unsigned long tmp ;
  struct device  const  *__mptr ;

  {
#line 1467
  tmp = simple_strtoul(buf, (char **)0, 0U);
#line 1467
  umcast_val = tmp;
#line 1469
  __mptr = (struct device  const  *)dev;
#line 1469
  ipoib_set_umcast((struct net_device *)__mptr + 0xfffffffffffffaa0UL, (int )umcast_val);
#line 1471
  return ((ssize_t )count);
}
}
#line 1473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct device_attribute dev_attr_umcast  =    {{"umcast", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & show_umcast,
    & set_umcast};
#line 1475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_add_umcast_attr(struct net_device *dev ) 
{ 
  int tmp ;

  {
#line 1477
  tmp = device_create_file(& dev->dev, (struct device_attribute  const  *)(& dev_attr_umcast));
#line 1477
  return (tmp);
}
}
#line 1480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static ssize_t create_child(struct device *dev , struct device_attribute *attr , char const   *buf ,
                            size_t count ) 
{ 
  int pkey ;
  int ret ;
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 1487
  tmp = sscanf(buf, "%i", & pkey);
#line 1487
  if (tmp != 1) {
#line 1488
    return (-22L);
  } else {

  }
#line 1490
  if ((pkey <= 0 || pkey > 65535) || pkey == 32768) {
#line 1491
    return (-22L);
  } else {

  }
#line 1497
  pkey = pkey | 32768;
#line 1499
  __mptr = (struct device  const  *)dev;
#line 1499
  ret = ipoib_vlan_add((struct net_device *)__mptr + 0xfffffffffffffaa0UL, (int )((unsigned short )pkey));
#line 1501
  return ((ssize_t )(ret != 0 ? (size_t )ret : count));
}
}
#line 1503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct device_attribute dev_attr_create_child  =    {{"create_child", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    (ssize_t (*)(struct device * , struct device_attribute * , char * ))0, & create_child};
#line 1505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static ssize_t delete_child(struct device *dev , struct device_attribute *attr , char const   *buf ,
                            size_t count ) 
{ 
  int pkey ;
  int ret ;
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 1512
  tmp = sscanf(buf, "%i", & pkey);
#line 1512
  if (tmp != 1) {
#line 1513
    return (-22L);
  } else {

  }
#line 1515
  if (pkey < 0 || pkey > 65535) {
#line 1516
    return (-22L);
  } else {

  }
#line 1518
  __mptr = (struct device  const  *)dev;
#line 1518
  ret = ipoib_vlan_delete((struct net_device *)__mptr + 0xfffffffffffffaa0UL, (int )((unsigned short )pkey));
#line 1520
  return ((ssize_t )(ret != 0 ? (size_t )ret : count));
}
}
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct device_attribute dev_attr_delete_child  =    {{"delete_child", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    (ssize_t (*)(struct device * , struct device_attribute * , char * ))0, & delete_child};
#line 1525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_add_pkey_attr(struct net_device *dev ) 
{ 
  int tmp ;

  {
#line 1527
  tmp = device_create_file(& dev->dev, (struct device_attribute  const  *)(& dev_attr_pkey));
#line 1527
  return (tmp);
}
}
#line 1530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
int ipoib_set_dev_features(struct ipoib_dev_priv *priv , struct ib_device *hca ) 
{ 
  struct ib_device_attr *device_attr ;
  int result ;
  void *tmp ;

  {
#line 1533
  result = -12;
#line 1535
  tmp = kmalloc(224UL, 208U);
#line 1535
  device_attr = (struct ib_device_attr *)tmp;
#line 1536
  if ((unsigned long )device_attr == (unsigned long )((struct ib_device_attr *)0)) {
#line 1537
    printk("\f%s: allocation of %zu bytes failed\n", (char *)(& hca->name), 224UL);
#line 1539
    return (result);
  } else {

  }
#line 1542
  result = ib_query_device(hca, device_attr);
#line 1543
  if (result != 0) {
#line 1544
    printk("\f%s: ib_query_device failed (ret = %d)\n", (char *)(& hca->name), result);
#line 1546
    kfree((void const   *)device_attr);
#line 1547
    return (result);
  } else {

  }
#line 1549
  priv->hca_caps = device_attr->device_cap_flags;
#line 1551
  kfree((void const   *)device_attr);
#line 1553
  if ((priv->hca_caps & 262144) != 0) {
#line 1554
    (priv->dev)->hw_features = 17179869187ULL;
#line 1557
    if ((priv->hca_caps & 524288) != 0) {
#line 1558
      (priv->dev)->hw_features = (priv->dev)->hw_features | 65536ULL;
    } else {

    }
#line 1560
    (priv->dev)->features = (priv->dev)->features | (priv->dev)->hw_features;
  } else {

  }
#line 1563
  return (0);
}
}
#line 1566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static struct net_device *ipoib_add_port(char const   *format , struct ib_device *hca ,
                                         u8 port ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct ib_port_attr attr ;
  int result ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 1571
  result = -12;
#line 1573
  priv = ipoib_intf_alloc(format);
#line 1574
  if ((unsigned long )priv == (unsigned long )((struct ipoib_dev_priv *)0)) {
#line 1575
    goto alloc_mem_failed;
  } else {

  }
#line 1577
  (priv->dev)->dev.parent = hca->dma_device;
#line 1578
  (priv->dev)->dev_id = (unsigned int )((unsigned short )port) + 65535U;
#line 1580
  tmp___0 = ib_query_port(hca, (int )port, & attr);
#line 1580
  if (tmp___0 == 0) {
#line 1581
    tmp = ib_mtu_enum_to_int(attr.max_mtu);
#line 1581
    priv->max_ib_mtu = (unsigned int )tmp;
  } else {
#line 1583
    printk("\f%s: ib_query_port %d failed\n", (char *)(& hca->name), (int )port);
#line 1585
    goto device_init_failed;
  }
#line 1589
  (priv->dev)->mtu = priv->max_ib_mtu - 4U;
#line 1590
  tmp___1 = (priv->dev)->mtu;
#line 1590
  priv->admin_mtu = tmp___1;
#line 1590
  priv->mcast_mtu = tmp___1;
#line 1592
  (priv->dev)->neigh_priv_len = 200U;
#line 1594
  result = ib_query_pkey(hca, (int )port, 0, & priv->pkey);
#line 1595
  if (result != 0) {
#line 1596
    printk("\f%s: ib_query_pkey port %d failed (ret = %d)\n", (char *)(& hca->name),
           (int )port, result);
#line 1598
    goto device_init_failed;
  } else {

  }
#line 1601
  tmp___2 = ipoib_set_dev_features(priv, hca);
#line 1601
  if (tmp___2 != 0) {
#line 1602
    goto device_init_failed;
  } else {

  }
#line 1608
  priv->pkey = (u16 )((unsigned int )priv->pkey | 32768U);
#line 1610
  (priv->dev)->broadcast[8] = (unsigned char )((int )priv->pkey >> 8);
#line 1611
  (priv->dev)->broadcast[9] = (unsigned char )priv->pkey;
#line 1613
  result = ib_query_gid(hca, (int )port, 0, & priv->local_gid);
#line 1614
  if (result != 0) {
#line 1615
    printk("\f%s: ib_query_gid port %d failed (ret = %d)\n", (char *)(& hca->name),
           (int )port, result);
#line 1617
    goto device_init_failed;
  } else {
#line 1619
    memcpy((void *)(priv->dev)->dev_addr + 4U, (void const   *)(& priv->local_gid.raw),
             16UL);
  }
#line 1621
  result = ipoib_dev_init(priv->dev, hca, (int )port);
#line 1622
  if (result < 0) {
#line 1623
    printk("\f%s: failed to initialize port %d (ret = %d)\n", (char *)(& hca->name),
           (int )port, result);
#line 1625
    goto device_init_failed;
  } else {

  }
#line 1628
  priv->event_handler.device = priv->ca;
#line 1628
  priv->event_handler.handler = & ipoib_event;
#line 1628
  INIT_LIST_HEAD(& priv->event_handler.list);
#line 1630
  result = ib_register_event_handler(& priv->event_handler);
#line 1631
  if (result < 0) {
#line 1632
    printk("\f%s: ib_register_event_handler failed for port %d (ret = %d)\n", (char *)(& hca->name),
           (int )port, result);
#line 1635
    goto event_failed;
  } else {

  }
#line 1638
  result = ldv_register_netdev_12(priv->dev);
#line 1639
  if (result != 0) {
#line 1640
    printk("\f%s: couldn\'t register ipoib port %d; error %d\n", (char *)(& hca->name),
           (int )port, result);
#line 1642
    goto register_failed;
  } else {

  }
#line 1645
  ipoib_create_debug_files(priv->dev);
#line 1647
  tmp___3 = ipoib_cm_add_mode_attr(priv->dev);
#line 1647
  if (tmp___3 != 0) {
#line 1648
    goto sysfs_failed;
  } else {

  }
#line 1649
  tmp___4 = ipoib_add_pkey_attr(priv->dev);
#line 1649
  if (tmp___4 != 0) {
#line 1650
    goto sysfs_failed;
  } else {

  }
#line 1651
  tmp___5 = ipoib_add_umcast_attr(priv->dev);
#line 1651
  if (tmp___5 != 0) {
#line 1652
    goto sysfs_failed;
  } else {

  }
#line 1653
  tmp___6 = device_create_file(& (priv->dev)->dev, (struct device_attribute  const  *)(& dev_attr_create_child));
#line 1653
  if (tmp___6 != 0) {
#line 1654
    goto sysfs_failed;
  } else {

  }
#line 1655
  tmp___7 = device_create_file(& (priv->dev)->dev, (struct device_attribute  const  *)(& dev_attr_delete_child));
#line 1655
  if (tmp___7 != 0) {
#line 1656
    goto sysfs_failed;
  } else {

  }
#line 1658
  return (priv->dev);
  sysfs_failed: 
#line 1661
  ipoib_delete_debug_files(priv->dev);
#line 1662
  ldv_unregister_netdev_13(priv->dev);
  register_failed: 
#line 1665
  ib_unregister_event_handler(& priv->event_handler);
#line 1666
  ldv_flush_workqueue_14(ipoib_workqueue);
#line 1668
  set_bit(11L, (unsigned long volatile   *)(& priv->flags));
#line 1669
  ldv_cancel_delayed_work_15(& priv->neigh_reap_task);
#line 1670
  ldv_flush_workqueue_16(priv->wq);
  event_failed: 
#line 1673
  ipoib_dev_cleanup(priv->dev);
  device_init_failed: 
#line 1676
  ldv_free_netdev_17(priv->dev);
  alloc_mem_failed: 
#line 1679
  tmp___8 = ERR_PTR((long )result);
#line 1679
  return ((struct net_device *)tmp___8);
}
}
#line 1682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_add_one(struct ib_device *device ) 
{ 
  struct list_head *dev_list ;
  struct net_device *dev ;
  struct ipoib_dev_priv *priv ;
  int s ;
  int e ;
  int p ;
  int count ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 1688
  count = 0;
#line 1690
  tmp = kmalloc(16UL, 208U);
#line 1690
  dev_list = (struct list_head *)tmp;
#line 1691
  if ((unsigned long )dev_list == (unsigned long )((struct list_head *)0)) {
#line 1692
    return;
  } else {

  }
#line 1694
  INIT_LIST_HEAD(dev_list);
#line 1696
  if ((unsigned int )device->node_type == 2U) {
#line 1697
    s = 0;
#line 1698
    e = 0;
  } else {
#line 1700
    s = 1;
#line 1701
    e = (int )device->phys_port_cnt;
  }
#line 1704
  p = s;
#line 1704
  goto ldv_50981;
  ldv_50980: 
#line 1705
  tmp___0 = rdma_protocol_ib((struct ib_device  const  *)device, (int )((u8 )p));
#line 1705
  if (tmp___0) {
#line 1705
    tmp___1 = 0;
  } else {
#line 1705
    tmp___1 = 1;
  }
#line 1705
  if (tmp___1) {
#line 1706
    goto ldv_50979;
  } else {

  }
#line 1707
  dev = ipoib_add_port("ib%d", device, (int )((u8 )p));
#line 1708
  tmp___3 = IS_ERR((void const   *)dev);
#line 1708
  if (tmp___3) {
#line 1708
    tmp___4 = 0;
  } else {
#line 1708
    tmp___4 = 1;
  }
#line 1708
  if (tmp___4) {
#line 1709
    tmp___2 = netdev_priv((struct net_device  const  *)dev);
#line 1709
    priv = (struct ipoib_dev_priv *)tmp___2;
#line 1710
    list_add_tail(& priv->list, dev_list);
#line 1711
    count = count + 1;
  } else {

  }
  ldv_50979: 
#line 1704
  p = p + 1;
  ldv_50981: ;
#line 1704
  if (p <= e) {
#line 1706
    goto ldv_50980;
  } else {

  }

#line 1715
  if (count == 0) {
#line 1716
    kfree((void const   *)dev_list);
#line 1717
    return;
  } else {

  }
#line 1720
  ib_set_client_data(device, & ipoib_client, (void *)dev_list);
#line 1721
  return;
}
}
#line 1723 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_remove_one(struct ib_device *device ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct ipoib_dev_priv *tmp ;
  struct list_head *dev_list ;
  void *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1728
  tmp___0 = ib_get_client_data(device, & ipoib_client);
#line 1728
  dev_list = (struct list_head *)tmp___0;
#line 1729
  if ((unsigned long )dev_list == (unsigned long )((struct list_head *)0)) {
#line 1730
    return;
  } else {

  }
#line 1732
  __mptr = (struct list_head  const  *)dev_list->next;
#line 1732
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff128UL;
#line 1732
  __mptr___0 = (struct list_head  const  *)priv->list.next;
#line 1732
  tmp = (struct ipoib_dev_priv *)__mptr___0 + 0xfffffffffffff128UL;
#line 1732
  goto ldv_50996;
  ldv_50995: 
#line 1733
  ib_unregister_event_handler(& priv->event_handler);
#line 1734
  ldv_flush_workqueue_18(ipoib_workqueue);
#line 1736
  rtnl_lock();
#line 1737
  dev_change_flags(priv->dev, (priv->dev)->flags & 4294967294U);
#line 1738
  rtnl_unlock();
#line 1741
  set_bit(11L, (unsigned long volatile   *)(& priv->flags));
#line 1742
  ldv_cancel_delayed_work_19(& priv->neigh_reap_task);
#line 1743
  ldv_flush_workqueue_20(priv->wq);
#line 1745
  ldv_unregister_netdev_21(priv->dev);
#line 1746
  ldv_free_netdev_22(priv->dev);
#line 1732
  priv = tmp;
#line 1732
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 1732
  tmp = (struct ipoib_dev_priv *)__mptr___1 + 0xfffffffffffff128UL;
  ldv_50996: ;
#line 1732
  if ((unsigned long )(& priv->list) != (unsigned long )dev_list) {
#line 1734
    goto ldv_50995;
  } else {

  }
#line 1749
  kfree((void const   *)dev_list);
#line 1750
  return;
}
}
#line 1752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static int ipoib_init_module(void) 
{ 
  int ret ;
  unsigned long tmp ;
  int _min1 ;
  int _min2 ;
  int _max1 ;
  int _max2 ;
  unsigned long tmp___0 ;
  int _min1___0 ;
  int _min2___0 ;
  int _max1___0 ;
  int _max1___1 ;
  int _max2___0 ;
  int _max2___1 ;
  int _min1___1 ;
  int _min2___1 ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___1 ;

  {
#line 1756
  tmp = __roundup_pow_of_two((unsigned long )ipoib_recvq_size);
#line 1756
  ipoib_recvq_size = (int )tmp;
#line 1757
  _min1 = ipoib_recvq_size;
#line 1757
  _min2 = 8192;
#line 1757
  ipoib_recvq_size = _min1 < _min2 ? _min1 : _min2;
#line 1758
  _max1 = ipoib_recvq_size;
#line 1758
  _max2 = 2;
#line 1758
  ipoib_recvq_size = _max1 > _max2 ? _max1 : _max2;
#line 1760
  tmp___0 = __roundup_pow_of_two((unsigned long )ipoib_sendq_size);
#line 1760
  ipoib_sendq_size = (int )tmp___0;
#line 1761
  _min1___0 = ipoib_sendq_size;
#line 1761
  _min2___0 = 8192;
#line 1761
  ipoib_sendq_size = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 1762
  _max1___1 = ipoib_sendq_size;
#line 1762
  _max2___0 = 32;
#line 1762
  _max1___0 = _max1___1 > _max2___0 ? _max1___1 : _max2___0;
#line 1762
  _max2___1 = 2;
#line 1762
  ipoib_sendq_size = _max1___0 > _max2___1 ? _max1___0 : _max2___1;
#line 1764
  _min1___1 = ipoib_max_conn_qp;
#line 1764
  _min2___1 = 4096;
#line 1764
  ipoib_max_conn_qp = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
#line 1773
  ret = ipoib_register_debugfs();
#line 1774
  if (ret != 0) {
#line 1775
    return (ret);
  } else {

  }
#line 1787
  __lock_name = "\"%s\"\"ipoib_flush\"";
#line 1787
  tmp___1 = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)"ipoib_flush");
#line 1787
  ipoib_workqueue = tmp___1;
#line 1788
  if ((unsigned long )ipoib_workqueue == (unsigned long )((struct workqueue_struct *)0)) {
#line 1789
    ret = -12;
#line 1790
    goto err_fs;
  } else {

  }
#line 1793
  ib_sa_register_client(& ipoib_sa_client);
#line 1795
  ret = ib_register_client(& ipoib_client);
#line 1796
  if (ret != 0) {
#line 1797
    goto err_sa;
  } else {

  }
#line 1799
  ret = ipoib_netlink_init();
#line 1800
  if (ret != 0) {
#line 1801
    goto err_client;
  } else {

  }
#line 1803
  return (0);
  err_client: 
#line 1806
  ib_unregister_client(& ipoib_client);
  err_sa: 
#line 1809
  ib_sa_unregister_client(& ipoib_sa_client);
#line 1810
  ldv_destroy_workqueue_23(ipoib_workqueue);
  err_fs: 
#line 1813
  ipoib_unregister_debugfs();
#line 1815
  return (ret);
}
}
#line 1818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.c"
static void ipoib_cleanup_module(void) 
{ 


  {
#line 1820
  ipoib_netlink_fini();
#line 1821
  ib_unregister_client(& ipoib_client);
#line 1822
  ib_sa_unregister_client(& ipoib_sa_client);
#line 1823
  ipoib_unregister_debugfs();
#line 1824
  ldv_destroy_workqueue_24(ipoib_workqueue);
#line 1825
  return;
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_retval_5  ;
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_retval_6  ;
#line 301
extern void ldv_initialize(void) ;
#line 302
void ldv_check_final_state(void) ;
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_retval_3  ;
#line 304
extern int ldv_ndo_init_28(void) ;
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void activate_work_5(struct work_struct *work , int state ) 
{ 


  {
#line 308
  if (ldv_work_5_0 == 0) {
#line 309
    ldv_work_struct_5_0 = work;
#line 310
    ldv_work_5_0 = state;
#line 311
    return;
  } else {

  }
#line 314
  if (ldv_work_5_1 == 0) {
#line 315
    ldv_work_struct_5_1 = work;
#line 316
    ldv_work_5_1 = state;
#line 317
    return;
  } else {

  }
#line 320
  if (ldv_work_5_2 == 0) {
#line 321
    ldv_work_struct_5_2 = work;
#line 322
    ldv_work_5_2 = state;
#line 323
    return;
  } else {

  }
#line 326
  if (ldv_work_5_3 == 0) {
#line 327
    ldv_work_struct_5_3 = work;
#line 328
    ldv_work_5_3 = state;
#line 329
    return;
  } else {

  }
#line 331
  return;
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void work_init_5(void) 
{ 


  {
#line 335
  ldv_work_5_0 = 0;
#line 336
  ldv_work_5_1 = 0;
#line 337
  ldv_work_5_2 = 0;
#line 338
  ldv_work_5_3 = 0;
#line 339
  return;
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void invoke_work_8(void) 
{ 
  int tmp ;

  {
#line 344
  tmp = __VERIFIER_nondet_int();
#line 344
  switch (tmp) {
  case 0: ;
#line 346
  if (ldv_work_8_0 == 2 || ldv_work_8_0 == 3) {
#line 347
    ldv_work_8_0 = 4;
#line 348
    ipoib_reap_neigh(ldv_work_struct_8_0);
#line 349
    ldv_work_8_0 = 1;
  } else {

  }
#line 352
  goto ldv_51064;
  case 1: ;
#line 354
  if (ldv_work_8_1 == 2 || ldv_work_8_1 == 3) {
#line 355
    ldv_work_8_1 = 4;
#line 356
    ipoib_reap_neigh(ldv_work_struct_8_0);
#line 357
    ldv_work_8_1 = 1;
  } else {

  }
#line 360
  goto ldv_51064;
  case 2: ;
#line 362
  if (ldv_work_8_2 == 2 || ldv_work_8_2 == 3) {
#line 363
    ldv_work_8_2 = 4;
#line 364
    ipoib_reap_neigh(ldv_work_struct_8_0);
#line 365
    ldv_work_8_2 = 1;
  } else {

  }
#line 368
  goto ldv_51064;
  case 3: ;
#line 370
  if (ldv_work_8_3 == 2 || ldv_work_8_3 == 3) {
#line 371
    ldv_work_8_3 = 4;
#line 372
    ipoib_reap_neigh(ldv_work_struct_8_0);
#line 373
    ldv_work_8_3 = 1;
  } else {

  }
#line 376
  goto ldv_51064;
  default: 
#line 377
  ldv_stop();
  }
  ldv_51064: ;
#line 379
  return;
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_all_4(int state ) 
{ 


  {
#line 385
  if (ldv_work_4_0 == state) {
#line 386
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
#line 387
  if (ldv_work_4_1 == state) {
#line 388
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
#line 389
  if (ldv_work_4_2 == state) {
#line 390
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
#line 391
  if (ldv_work_4_3 == state) {
#line 392
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
#line 393
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_initialize_device_attribute_26(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 397
  tmp = ldv_init_zalloc(48UL);
#line 397
  dev_attr_umcast_group0 = (struct device_attribute *)tmp;
#line 398
  tmp___0 = ldv_init_zalloc(1416UL);
#line 398
  dev_attr_umcast_group1 = (struct device *)tmp___0;
#line 399
  return;
}
}
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 402
  if (ldv_work_1_0 == 0) {
#line 403
    ldv_work_struct_1_0 = work;
#line 404
    ldv_work_1_0 = state;
#line 405
    return;
  } else {

  }
#line 408
  if (ldv_work_1_1 == 0) {
#line 409
    ldv_work_struct_1_1 = work;
#line 410
    ldv_work_1_1 = state;
#line 411
    return;
  } else {

  }
#line 414
  if (ldv_work_1_2 == 0) {
#line 415
    ldv_work_struct_1_2 = work;
#line 416
    ldv_work_1_2 = state;
#line 417
    return;
  } else {

  }
#line 420
  if (ldv_work_1_3 == 0) {
#line 421
    ldv_work_struct_1_3 = work;
#line 422
    ldv_work_1_3 = state;
#line 423
    return;
  } else {

  }
#line 425
  return;
}
}
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_net_device_ops_28(void) 
{ 
  void *tmp ;

  {
#line 429
  tmp = ldv_init_zalloc(3008UL);
#line 429
  ipoib_netdev_ops_group1 = (struct net_device *)tmp;
#line 430
  return;
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 436
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 438
    ipoib_ib_dev_flush_light(work);
#line 439
    ldv_work_3_0 = 1;
#line 440
    return;
  } else {

  }
#line 442
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 444
    ipoib_ib_dev_flush_light(work);
#line 445
    ldv_work_3_1 = 1;
#line 446
    return;
  } else {

  }
#line 448
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 450
    ipoib_ib_dev_flush_light(work);
#line 451
    ldv_work_3_2 = 1;
#line 452
    return;
  } else {

  }
#line 454
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 456
    ipoib_ib_dev_flush_light(work);
#line 457
    ldv_work_3_3 = 1;
#line 458
    return;
  } else {

  }
#line 460
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void disable_work_7(struct work_struct *work ) 
{ 


  {
#line 465
  if ((ldv_work_7_0 == 3 || ldv_work_7_0 == 2) && (unsigned long )ldv_work_struct_7_0 == (unsigned long )work) {
#line 467
    ldv_work_7_0 = 1;
  } else {

  }
#line 469
  if ((ldv_work_7_1 == 3 || ldv_work_7_1 == 2) && (unsigned long )ldv_work_struct_7_1 == (unsigned long )work) {
#line 471
    ldv_work_7_1 = 1;
  } else {

  }
#line 473
  if ((ldv_work_7_2 == 3 || ldv_work_7_2 == 2) && (unsigned long )ldv_work_struct_7_2 == (unsigned long )work) {
#line 475
    ldv_work_7_2 = 1;
  } else {

  }
#line 477
  if ((ldv_work_7_3 == 3 || ldv_work_7_3 == 2) && (unsigned long )ldv_work_struct_7_3 == (unsigned long )work) {
#line 479
    ldv_work_7_3 = 1;
  } else {

  }
#line 480
  return;
}
}
#line 484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 486
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 488
    ldv_work_3_0 = 1;
  } else {

  }
#line 490
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 492
    ldv_work_3_1 = 1;
  } else {

  }
#line 494
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 496
    ldv_work_3_2 = 1;
  } else {

  }
#line 498
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 500
    ldv_work_3_3 = 1;
  } else {

  }
#line 501
  return;
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 506
  ldv_work_1_0 = 0;
#line 507
  ldv_work_1_1 = 0;
#line 508
  ldv_work_1_2 = 0;
#line 509
  ldv_work_1_3 = 0;
#line 510
  return;
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void invoke_work_4(void) 
{ 
  int tmp ;

  {
#line 515
  tmp = __VERIFIER_nondet_int();
#line 515
  switch (tmp) {
  case 0: ;
#line 517
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
#line 518
    ldv_work_4_0 = 4;
#line 519
    ipoib_ib_dev_flush_normal(ldv_work_struct_4_0);
#line 520
    ldv_work_4_0 = 1;
  } else {

  }
#line 523
  goto ldv_51102;
  case 1: ;
#line 525
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
#line 526
    ldv_work_4_1 = 4;
#line 527
    ipoib_ib_dev_flush_normal(ldv_work_struct_4_0);
#line 528
    ldv_work_4_1 = 1;
  } else {

  }
#line 531
  goto ldv_51102;
  case 2: ;
#line 533
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
#line 534
    ldv_work_4_2 = 4;
#line 535
    ipoib_ib_dev_flush_normal(ldv_work_struct_4_0);
#line 536
    ldv_work_4_2 = 1;
  } else {

  }
#line 539
  goto ldv_51102;
  case 3: ;
#line 541
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
#line 542
    ldv_work_4_3 = 4;
#line 543
    ipoib_ib_dev_flush_normal(ldv_work_struct_4_0);
#line 544
    ldv_work_4_3 = 1;
  } else {

  }
#line 547
  goto ldv_51102;
  default: 
#line 548
  ldv_stop();
  }
  ldv_51102: ;
#line 550
  return;
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_initialize_ib_client_30(void) 
{ 
  void *tmp ;

  {
#line 555
  tmp = ldv_init_zalloc(2488UL);
#line 555
  ipoib_client_group0 = (struct ib_device *)tmp;
#line 556
  return;
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void activate_work_6(struct work_struct *work , int state ) 
{ 


  {
#line 559
  if (ldv_work_6_0 == 0) {
#line 560
    ldv_work_struct_6_0 = work;
#line 561
    ldv_work_6_0 = state;
#line 562
    return;
  } else {

  }
#line 565
  if (ldv_work_6_1 == 0) {
#line 566
    ldv_work_struct_6_1 = work;
#line 567
    ldv_work_6_1 = state;
#line 568
    return;
  } else {

  }
#line 571
  if (ldv_work_6_2 == 0) {
#line 572
    ldv_work_struct_6_2 = work;
#line 573
    ldv_work_6_2 = state;
#line 574
    return;
  } else {

  }
#line 577
  if (ldv_work_6_3 == 0) {
#line 578
    ldv_work_struct_6_3 = work;
#line 579
    ldv_work_6_3 = state;
#line 580
    return;
  } else {

  }
#line 582
  return;
}
}
#line 585 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_work_7(struct work_struct *work ) 
{ 


  {
#line 588
  if ((ldv_work_7_0 == 2 || ldv_work_7_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_0) {
#line 590
    ipoib_reap_ah(work);
#line 591
    ldv_work_7_0 = 1;
#line 592
    return;
  } else {

  }
#line 594
  if ((ldv_work_7_1 == 2 || ldv_work_7_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_1) {
#line 596
    ipoib_reap_ah(work);
#line 597
    ldv_work_7_1 = 1;
#line 598
    return;
  } else {

  }
#line 600
  if ((ldv_work_7_2 == 2 || ldv_work_7_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_2) {
#line 602
    ipoib_reap_ah(work);
#line 603
    ldv_work_7_2 = 1;
#line 604
    return;
  } else {

  }
#line 606
  if ((ldv_work_7_3 == 2 || ldv_work_7_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_3) {
#line 608
    ipoib_reap_ah(work);
#line 609
    ldv_work_7_3 = 1;
#line 610
    return;
  } else {

  }
#line 612
  return;
}
}
#line 615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void work_init_8(void) 
{ 


  {
#line 616
  ldv_work_8_0 = 0;
#line 617
  ldv_work_8_1 = 0;
#line 618
  ldv_work_8_2 = 0;
#line 619
  ldv_work_8_3 = 0;
#line 620
  return;
}
}
#line 623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 624
  if (ldv_work_2_0 == 0) {
#line 625
    ldv_work_struct_2_0 = work;
#line 626
    ldv_work_2_0 = state;
#line 627
    return;
  } else {

  }
#line 630
  if (ldv_work_2_1 == 0) {
#line 631
    ldv_work_struct_2_1 = work;
#line 632
    ldv_work_2_1 = state;
#line 633
    return;
  } else {

  }
#line 636
  if (ldv_work_2_2 == 0) {
#line 637
    ldv_work_struct_2_2 = work;
#line 638
    ldv_work_2_2 = state;
#line 639
    return;
  } else {

  }
#line 642
  if (ldv_work_2_3 == 0) {
#line 643
    ldv_work_struct_2_3 = work;
#line 644
    ldv_work_2_3 = state;
#line 645
    return;
  } else {

  }
#line 647
  return;
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void invoke_work_5(void) 
{ 
  int tmp ;

  {
#line 652
  tmp = __VERIFIER_nondet_int();
#line 652
  switch (tmp) {
  case 0: ;
#line 654
  if (ldv_work_5_0 == 2 || ldv_work_5_0 == 3) {
#line 655
    ldv_work_5_0 = 4;
#line 656
    ipoib_ib_dev_flush_heavy(ldv_work_struct_5_0);
#line 657
    ldv_work_5_0 = 1;
  } else {

  }
#line 660
  goto ldv_51132;
  case 1: ;
#line 662
  if (ldv_work_5_1 == 2 || ldv_work_5_1 == 3) {
#line 663
    ldv_work_5_1 = 4;
#line 664
    ipoib_ib_dev_flush_heavy(ldv_work_struct_5_0);
#line 665
    ldv_work_5_1 = 1;
  } else {

  }
#line 668
  goto ldv_51132;
  case 2: ;
#line 670
  if (ldv_work_5_2 == 2 || ldv_work_5_2 == 3) {
#line 671
    ldv_work_5_2 = 4;
#line 672
    ipoib_ib_dev_flush_heavy(ldv_work_struct_5_0);
#line 673
    ldv_work_5_2 = 1;
  } else {

  }
#line 676
  goto ldv_51132;
  case 3: ;
#line 678
  if (ldv_work_5_3 == 2 || ldv_work_5_3 == 3) {
#line 679
    ldv_work_5_3 = 4;
#line 680
    ipoib_ib_dev_flush_heavy(ldv_work_struct_5_0);
#line 681
    ldv_work_5_3 = 1;
  } else {

  }
#line 684
  goto ldv_51132;
  default: 
#line 685
  ldv_stop();
  }
  ldv_51132: ;
#line 687
  return;
}
}
#line 691 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_work_8(struct work_struct *work ) 
{ 


  {
#line 694
  if ((ldv_work_8_0 == 2 || ldv_work_8_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_0) {
#line 696
    ipoib_reap_neigh(work);
#line 697
    ldv_work_8_0 = 1;
#line 698
    return;
  } else {

  }
#line 700
  if ((ldv_work_8_1 == 2 || ldv_work_8_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_1) {
#line 702
    ipoib_reap_neigh(work);
#line 703
    ldv_work_8_1 = 1;
#line 704
    return;
  } else {

  }
#line 706
  if ((ldv_work_8_2 == 2 || ldv_work_8_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_2) {
#line 708
    ipoib_reap_neigh(work);
#line 709
    ldv_work_8_2 = 1;
#line 710
    return;
  } else {

  }
#line 712
  if ((ldv_work_8_3 == 2 || ldv_work_8_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_3) {
#line 714
    ipoib_reap_neigh(work);
#line 715
    ldv_work_8_3 = 1;
#line 716
    return;
  } else {

  }
#line 718
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void disable_work_4(struct work_struct *work ) 
{ 


  {
#line 723
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
#line 725
    ldv_work_4_0 = 1;
  } else {

  }
#line 727
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
#line 729
    ldv_work_4_1 = 1;
  } else {

  }
#line 731
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
#line 733
    ldv_work_4_2 = 1;
  } else {

  }
#line 735
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
#line 737
    ldv_work_4_3 = 1;
  } else {

  }
#line 738
  return;
}
}
#line 742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void work_init_4(void) 
{ 


  {
#line 743
  ldv_work_4_0 = 0;
#line 744
  ldv_work_4_1 = 0;
#line 745
  ldv_work_4_2 = 0;
#line 746
  ldv_work_4_3 = 0;
#line 747
  return;
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 752
  tmp = __VERIFIER_nondet_int();
#line 752
  switch (tmp) {
  case 0: ;
#line 754
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 755
    ldv_work_1_0 = 4;
#line 756
    ipoib_mcast_join_task(ldv_work_struct_1_0);
#line 757
    ldv_work_1_0 = 1;
  } else {

  }
#line 760
  goto ldv_51154;
  case 1: ;
#line 762
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 763
    ldv_work_1_1 = 4;
#line 764
    ipoib_mcast_join_task(ldv_work_struct_1_0);
#line 765
    ldv_work_1_1 = 1;
  } else {

  }
#line 768
  goto ldv_51154;
  case 2: ;
#line 770
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 771
    ldv_work_1_2 = 4;
#line 772
    ipoib_mcast_join_task(ldv_work_struct_1_0);
#line 773
    ldv_work_1_2 = 1;
  } else {

  }
#line 776
  goto ldv_51154;
  case 3: ;
#line 778
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 779
    ldv_work_1_3 = 4;
#line 780
    ipoib_mcast_join_task(ldv_work_struct_1_0);
#line 781
    ldv_work_1_3 = 1;
  } else {

  }
#line 784
  goto ldv_51154;
  default: 
#line 785
  ldv_stop();
  }
  ldv_51154: ;
#line 787
  return;
}
}
#line 791 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void disable_work_8(struct work_struct *work ) 
{ 


  {
#line 793
  if ((ldv_work_8_0 == 3 || ldv_work_8_0 == 2) && (unsigned long )ldv_work_struct_8_0 == (unsigned long )work) {
#line 795
    ldv_work_8_0 = 1;
  } else {

  }
#line 797
  if ((ldv_work_8_1 == 3 || ldv_work_8_1 == 2) && (unsigned long )ldv_work_struct_8_1 == (unsigned long )work) {
#line 799
    ldv_work_8_1 = 1;
  } else {

  }
#line 801
  if ((ldv_work_8_2 == 3 || ldv_work_8_2 == 2) && (unsigned long )ldv_work_struct_8_2 == (unsigned long )work) {
#line 803
    ldv_work_8_2 = 1;
  } else {

  }
#line 805
  if ((ldv_work_8_3 == 3 || ldv_work_8_3 == 2) && (unsigned long )ldv_work_struct_8_3 == (unsigned long )work) {
#line 807
    ldv_work_8_3 = 1;
  } else {

  }
#line 808
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 814
  if (ldv_work_3_0 == state) {
#line 815
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 816
  if (ldv_work_3_1 == state) {
#line 817
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 818
  if (ldv_work_3_2 == state) {
#line 819
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 820
  if (ldv_work_3_3 == state) {
#line 821
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 822
  return;
}
}
#line 825 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
#line 828
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
#line 830
    ipoib_ib_dev_flush_normal(work);
#line 831
    ldv_work_4_0 = 1;
#line 832
    return;
  } else {

  }
#line 834
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
#line 836
    ipoib_ib_dev_flush_normal(work);
#line 837
    ldv_work_4_1 = 1;
#line 838
    return;
  } else {

  }
#line 840
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
#line 842
    ipoib_ib_dev_flush_normal(work);
#line 843
    ldv_work_4_2 = 1;
#line 844
    return;
  } else {

  }
#line 846
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
#line 848
    ipoib_ib_dev_flush_normal(work);
#line 849
    ldv_work_4_3 = 1;
#line 850
    return;
  } else {

  }
#line 852
  return;
}
}
#line 855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 856
  ldv_work_3_0 = 0;
#line 857
  ldv_work_3_1 = 0;
#line 858
  ldv_work_3_2 = 0;
#line 859
  ldv_work_3_3 = 0;
#line 860
  return;
}
}
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_all_7(int state ) 
{ 


  {
#line 865
  if (ldv_work_7_0 == state) {
#line 866
    call_and_disable_work_7(ldv_work_struct_7_0);
  } else {

  }
#line 867
  if (ldv_work_7_1 == state) {
#line 868
    call_and_disable_work_7(ldv_work_struct_7_1);
  } else {

  }
#line 869
  if (ldv_work_7_2 == state) {
#line 870
    call_and_disable_work_7(ldv_work_struct_7_2);
  } else {

  }
#line 871
  if (ldv_work_7_3 == state) {
#line 872
    call_and_disable_work_7(ldv_work_struct_7_3);
  } else {

  }
#line 873
  return;
}
}
#line 876 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 879
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 881
    ipoib_mcast_join_task(work);
#line 882
    ldv_work_1_0 = 1;
#line 883
    return;
  } else {

  }
#line 885
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 887
    ipoib_mcast_join_task(work);
#line 888
    ldv_work_1_1 = 1;
#line 889
    return;
  } else {

  }
#line 891
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 893
    ipoib_mcast_join_task(work);
#line 894
    ldv_work_1_2 = 1;
#line 895
    return;
  } else {

  }
#line 897
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 899
    ipoib_mcast_join_task(work);
#line 900
    ldv_work_1_3 = 1;
#line 901
    return;
  } else {

  }
#line 903
  return;
}
}
#line 906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void invoke_work_6(void) 
{ 
  int tmp ;

  {
#line 908
  tmp = __VERIFIER_nondet_int();
#line 908
  switch (tmp) {
  case 0: ;
#line 910
  if (ldv_work_6_0 == 2 || ldv_work_6_0 == 3) {
#line 911
    ldv_work_6_0 = 4;
#line 912
    ipoib_mcast_restart_task(ldv_work_struct_6_0);
#line 913
    ldv_work_6_0 = 1;
  } else {

  }
#line 916
  goto ldv_51187;
  case 1: ;
#line 918
  if (ldv_work_6_1 == 2 || ldv_work_6_1 == 3) {
#line 919
    ldv_work_6_1 = 4;
#line 920
    ipoib_mcast_restart_task(ldv_work_struct_6_0);
#line 921
    ldv_work_6_1 = 1;
  } else {

  }
#line 924
  goto ldv_51187;
  case 2: ;
#line 926
  if (ldv_work_6_2 == 2 || ldv_work_6_2 == 3) {
#line 927
    ldv_work_6_2 = 4;
#line 928
    ipoib_mcast_restart_task(ldv_work_struct_6_0);
#line 929
    ldv_work_6_2 = 1;
  } else {

  }
#line 932
  goto ldv_51187;
  case 3: ;
#line 934
  if (ldv_work_6_3 == 2 || ldv_work_6_3 == 3) {
#line 935
    ldv_work_6_3 = 4;
#line 936
    ipoib_mcast_restart_task(ldv_work_struct_6_0);
#line 937
    ldv_work_6_3 = 1;
  } else {

  }
#line 940
  goto ldv_51187;
  default: 
#line 941
  ldv_stop();
  }
  ldv_51187: ;
#line 943
  return;
}
}
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 949
  if (ldv_work_2_0 == state) {
#line 950
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 951
  if (ldv_work_2_1 == state) {
#line 952
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 953
  if (ldv_work_2_2 == state) {
#line 954
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 955
  if (ldv_work_2_3 == state) {
#line 956
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 957
  return;
}
}
#line 960 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 961
  if (ldv_work_3_0 == 0) {
#line 962
    ldv_work_struct_3_0 = work;
#line 963
    ldv_work_3_0 = state;
#line 964
    return;
  } else {

  }
#line 967
  if (ldv_work_3_1 == 0) {
#line 968
    ldv_work_struct_3_1 = work;
#line 969
    ldv_work_3_1 = state;
#line 970
    return;
  } else {

  }
#line 973
  if (ldv_work_3_2 == 0) {
#line 974
    ldv_work_struct_3_2 = work;
#line 975
    ldv_work_3_2 = state;
#line 976
    return;
  } else {

  }
#line 979
  if (ldv_work_3_3 == 0) {
#line 980
    ldv_work_struct_3_3 = work;
#line 981
    ldv_work_3_3 = state;
#line 982
    return;
  } else {

  }
#line 984
  return;
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void work_init_7(void) 
{ 


  {
#line 988
  ldv_work_7_0 = 0;
#line 989
  ldv_work_7_1 = 0;
#line 990
  ldv_work_7_2 = 0;
#line 991
  ldv_work_7_3 = 0;
#line 992
  return;
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void invoke_work_7(void) 
{ 
  int tmp ;

  {
#line 997
  tmp = __VERIFIER_nondet_int();
#line 997
  switch (tmp) {
  case 0: ;
#line 999
  if (ldv_work_7_0 == 2 || ldv_work_7_0 == 3) {
#line 1000
    ldv_work_7_0 = 4;
#line 1001
    ipoib_reap_ah(ldv_work_struct_7_0);
#line 1002
    ldv_work_7_0 = 1;
  } else {

  }
#line 1005
  goto ldv_51208;
  case 1: ;
#line 1007
  if (ldv_work_7_1 == 2 || ldv_work_7_1 == 3) {
#line 1008
    ldv_work_7_1 = 4;
#line 1009
    ipoib_reap_ah(ldv_work_struct_7_0);
#line 1010
    ldv_work_7_1 = 1;
  } else {

  }
#line 1013
  goto ldv_51208;
  case 2: ;
#line 1015
  if (ldv_work_7_2 == 2 || ldv_work_7_2 == 3) {
#line 1016
    ldv_work_7_2 = 4;
#line 1017
    ipoib_reap_ah(ldv_work_struct_7_0);
#line 1018
    ldv_work_7_2 = 1;
  } else {

  }
#line 1021
  goto ldv_51208;
  case 3: ;
#line 1023
  if (ldv_work_7_3 == 2 || ldv_work_7_3 == 3) {
#line 1024
    ldv_work_7_3 = 4;
#line 1025
    ipoib_reap_ah(ldv_work_struct_7_0);
#line 1026
    ldv_work_7_3 = 1;
  } else {

  }
#line 1029
  goto ldv_51208;
  default: 
#line 1030
  ldv_stop();
  }
  ldv_51208: ;
#line 1032
  return;
}
}
#line 1036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void disable_work_5(struct work_struct *work ) 
{ 


  {
#line 1038
  if ((ldv_work_5_0 == 3 || ldv_work_5_0 == 2) && (unsigned long )ldv_work_struct_5_0 == (unsigned long )work) {
#line 1040
    ldv_work_5_0 = 1;
  } else {

  }
#line 1042
  if ((ldv_work_5_1 == 3 || ldv_work_5_1 == 2) && (unsigned long )ldv_work_struct_5_1 == (unsigned long )work) {
#line 1044
    ldv_work_5_1 = 1;
  } else {

  }
#line 1046
  if ((ldv_work_5_2 == 3 || ldv_work_5_2 == 2) && (unsigned long )ldv_work_struct_5_2 == (unsigned long )work) {
#line 1048
    ldv_work_5_2 = 1;
  } else {

  }
#line 1050
  if ((ldv_work_5_3 == 3 || ldv_work_5_3 == 2) && (unsigned long )ldv_work_struct_5_3 == (unsigned long )work) {
#line 1052
    ldv_work_5_3 = 1;
  } else {

  }
#line 1053
  return;
}
}
#line 1057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_all_8(int state ) 
{ 


  {
#line 1059
  if (ldv_work_8_0 == state) {
#line 1060
    call_and_disable_work_8(ldv_work_struct_8_0);
  } else {

  }
#line 1061
  if (ldv_work_8_1 == state) {
#line 1062
    call_and_disable_work_8(ldv_work_struct_8_1);
  } else {

  }
#line 1063
  if (ldv_work_8_2 == state) {
#line 1064
    call_and_disable_work_8(ldv_work_struct_8_2);
  } else {

  }
#line 1065
  if (ldv_work_8_3 == state) {
#line 1066
    call_and_disable_work_8(ldv_work_struct_8_3);
  } else {

  }
#line 1067
  return;
}
}
#line 1070 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 1072
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 1074
    ldv_work_1_0 = 1;
  } else {

  }
#line 1076
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 1078
    ldv_work_1_1 = 1;
  } else {

  }
#line 1080
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 1082
    ldv_work_1_2 = 1;
  } else {

  }
#line 1084
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 1086
    ldv_work_1_3 = 1;
  } else {

  }
#line 1087
  return;
}
}
#line 1091 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_all_6(int state ) 
{ 


  {
#line 1093
  if (ldv_work_6_0 == state) {
#line 1094
    call_and_disable_work_6(ldv_work_struct_6_0);
  } else {

  }
#line 1095
  if (ldv_work_6_1 == state) {
#line 1096
    call_and_disable_work_6(ldv_work_struct_6_1);
  } else {

  }
#line 1097
  if (ldv_work_6_2 == state) {
#line 1098
    call_and_disable_work_6(ldv_work_struct_6_2);
  } else {

  }
#line 1099
  if (ldv_work_6_3 == state) {
#line 1100
    call_and_disable_work_6(ldv_work_struct_6_3);
  } else {

  }
#line 1101
  return;
}
}
#line 1104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_work_5(struct work_struct *work ) 
{ 


  {
#line 1107
  if ((ldv_work_5_0 == 2 || ldv_work_5_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_0) {
#line 1109
    ipoib_ib_dev_flush_heavy(work);
#line 1110
    ldv_work_5_0 = 1;
#line 1111
    return;
  } else {

  }
#line 1113
  if ((ldv_work_5_1 == 2 || ldv_work_5_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_1) {
#line 1115
    ipoib_ib_dev_flush_heavy(work);
#line 1116
    ldv_work_5_1 = 1;
#line 1117
    return;
  } else {

  }
#line 1119
  if ((ldv_work_5_2 == 2 || ldv_work_5_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_2) {
#line 1121
    ipoib_ib_dev_flush_heavy(work);
#line 1122
    ldv_work_5_2 = 1;
#line 1123
    return;
  } else {

  }
#line 1125
  if ((ldv_work_5_3 == 2 || ldv_work_5_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_3) {
#line 1127
    ipoib_ib_dev_flush_heavy(work);
#line 1128
    ldv_work_5_3 = 1;
#line 1129
    return;
  } else {

  }
#line 1131
  return;
}
}
#line 1134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void activate_work_8(struct work_struct *work , int state ) 
{ 


  {
#line 1135
  if (ldv_work_8_0 == 0) {
#line 1136
    ldv_work_struct_8_0 = work;
#line 1137
    ldv_work_8_0 = state;
#line 1138
    return;
  } else {

  }
#line 1141
  if (ldv_work_8_1 == 0) {
#line 1142
    ldv_work_struct_8_1 = work;
#line 1143
    ldv_work_8_1 = state;
#line 1144
    return;
  } else {

  }
#line 1147
  if (ldv_work_8_2 == 0) {
#line 1148
    ldv_work_struct_8_2 = work;
#line 1149
    ldv_work_8_2 = state;
#line 1150
    return;
  } else {

  }
#line 1153
  if (ldv_work_8_3 == 0) {
#line 1154
    ldv_work_struct_8_3 = work;
#line 1155
    ldv_work_8_3 = state;
#line 1156
    return;
  } else {

  }
#line 1158
  return;
}
}
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 1163
  tmp = __VERIFIER_nondet_int();
#line 1163
  switch (tmp) {
  case 0: ;
#line 1165
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 1166
    ldv_work_2_0 = 4;
#line 1167
    ipoib_mcast_carrier_on_task(ldv_work_struct_2_0);
#line 1168
    ldv_work_2_0 = 1;
  } else {

  }
#line 1171
  goto ldv_51240;
  case 1: ;
#line 1173
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 1174
    ldv_work_2_1 = 4;
#line 1175
    ipoib_mcast_carrier_on_task(ldv_work_struct_2_0);
#line 1176
    ldv_work_2_1 = 1;
  } else {

  }
#line 1179
  goto ldv_51240;
  case 2: ;
#line 1181
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 1182
    ldv_work_2_2 = 4;
#line 1183
    ipoib_mcast_carrier_on_task(ldv_work_struct_2_0);
#line 1184
    ldv_work_2_2 = 1;
  } else {

  }
#line 1187
  goto ldv_51240;
  case 3: ;
#line 1189
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 1190
    ldv_work_2_3 = 4;
#line 1191
    ipoib_mcast_carrier_on_task(ldv_work_struct_2_0);
#line 1192
    ldv_work_2_3 = 1;
  } else {

  }
#line 1195
  goto ldv_51240;
  default: 
#line 1196
  ldv_stop();
  }
  ldv_51240: ;
#line 1198
  return;
}
}
#line 1202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
#line 1203
  if (ldv_work_4_0 == 0) {
#line 1204
    ldv_work_struct_4_0 = work;
#line 1205
    ldv_work_4_0 = state;
#line 1206
    return;
  } else {

  }
#line 1209
  if (ldv_work_4_1 == 0) {
#line 1210
    ldv_work_struct_4_1 = work;
#line 1211
    ldv_work_4_1 = state;
#line 1212
    return;
  } else {

  }
#line 1215
  if (ldv_work_4_2 == 0) {
#line 1216
    ldv_work_struct_4_2 = work;
#line 1217
    ldv_work_4_2 = state;
#line 1218
    return;
  } else {

  }
#line 1221
  if (ldv_work_4_3 == 0) {
#line 1222
    ldv_work_struct_4_3 = work;
#line 1223
    ldv_work_4_3 = state;
#line 1224
    return;
  } else {

  }
#line 1226
  return;
}
}
#line 1229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_all_5(int state ) 
{ 


  {
#line 1231
  if (ldv_work_5_0 == state) {
#line 1232
    call_and_disable_work_5(ldv_work_struct_5_0);
  } else {

  }
#line 1233
  if (ldv_work_5_1 == state) {
#line 1234
    call_and_disable_work_5(ldv_work_struct_5_1);
  } else {

  }
#line 1235
  if (ldv_work_5_2 == state) {
#line 1236
    call_and_disable_work_5(ldv_work_struct_5_2);
  } else {

  }
#line 1237
  if (ldv_work_5_3 == state) {
#line 1238
    call_and_disable_work_5(ldv_work_struct_5_3);
  } else {

  }
#line 1239
  return;
}
}
#line 1242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 1243
  ldv_work_2_0 = 0;
#line 1244
  ldv_work_2_1 = 0;
#line 1245
  ldv_work_2_2 = 0;
#line 1246
  ldv_work_2_3 = 0;
#line 1247
  return;
}
}
#line 1250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 1252
  if (ldv_work_1_0 == state) {
#line 1253
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 1254
  if (ldv_work_1_1 == state) {
#line 1255
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 1256
  if (ldv_work_1_2 == state) {
#line 1257
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 1258
  if (ldv_work_1_3 == state) {
#line 1259
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 1260
  return;
}
}
#line 1263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void disable_work_6(struct work_struct *work ) 
{ 


  {
#line 1265
  if ((ldv_work_6_0 == 3 || ldv_work_6_0 == 2) && (unsigned long )ldv_work_struct_6_0 == (unsigned long )work) {
#line 1267
    ldv_work_6_0 = 1;
  } else {

  }
#line 1269
  if ((ldv_work_6_1 == 3 || ldv_work_6_1 == 2) && (unsigned long )ldv_work_struct_6_1 == (unsigned long )work) {
#line 1271
    ldv_work_6_1 = 1;
  } else {

  }
#line 1273
  if ((ldv_work_6_2 == 3 || ldv_work_6_2 == 2) && (unsigned long )ldv_work_struct_6_2 == (unsigned long )work) {
#line 1275
    ldv_work_6_2 = 1;
  } else {

  }
#line 1277
  if ((ldv_work_6_3 == 3 || ldv_work_6_3 == 2) && (unsigned long )ldv_work_struct_6_3 == (unsigned long )work) {
#line 1279
    ldv_work_6_3 = 1;
  } else {

  }
#line 1280
  return;
}
}
#line 1284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void work_init_6(void) 
{ 


  {
#line 1285
  ldv_work_6_0 = 0;
#line 1286
  ldv_work_6_1 = 0;
#line 1287
  ldv_work_6_2 = 0;
#line 1288
  ldv_work_6_3 = 0;
#line 1289
  return;
}
}
#line 1292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void activate_work_7(struct work_struct *work , int state ) 
{ 


  {
#line 1293
  if (ldv_work_7_0 == 0) {
#line 1294
    ldv_work_struct_7_0 = work;
#line 1295
    ldv_work_7_0 = state;
#line 1296
    return;
  } else {

  }
#line 1299
  if (ldv_work_7_1 == 0) {
#line 1300
    ldv_work_struct_7_1 = work;
#line 1301
    ldv_work_7_1 = state;
#line 1302
    return;
  } else {

  }
#line 1305
  if (ldv_work_7_2 == 0) {
#line 1306
    ldv_work_struct_7_2 = work;
#line 1307
    ldv_work_7_2 = state;
#line 1308
    return;
  } else {

  }
#line 1311
  if (ldv_work_7_3 == 0) {
#line 1312
    ldv_work_struct_7_3 = work;
#line 1313
    ldv_work_7_3 = state;
#line 1314
    return;
  } else {

  }
#line 1316
  return;
}
}
#line 1319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 1321
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 1323
    ldv_work_2_0 = 1;
  } else {

  }
#line 1325
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 1327
    ldv_work_2_1 = 1;
  } else {

  }
#line 1329
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 1331
    ldv_work_2_2 = 1;
  } else {

  }
#line 1333
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 1335
    ldv_work_2_3 = 1;
  } else {

  }
#line 1336
  return;
}
}
#line 1340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 1342
  tmp = __VERIFIER_nondet_int();
#line 1342
  switch (tmp) {
  case 0: ;
#line 1344
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 1345
    ldv_work_3_0 = 4;
#line 1346
    ipoib_ib_dev_flush_light(ldv_work_struct_3_0);
#line 1347
    ldv_work_3_0 = 1;
  } else {

  }
#line 1350
  goto ldv_51277;
  case 1: ;
#line 1352
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 1353
    ldv_work_3_1 = 4;
#line 1354
    ipoib_ib_dev_flush_light(ldv_work_struct_3_0);
#line 1355
    ldv_work_3_1 = 1;
  } else {

  }
#line 1358
  goto ldv_51277;
  case 2: ;
#line 1360
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 1361
    ldv_work_3_2 = 4;
#line 1362
    ipoib_ib_dev_flush_light(ldv_work_struct_3_0);
#line 1363
    ldv_work_3_2 = 1;
  } else {

  }
#line 1366
  goto ldv_51277;
  case 3: ;
#line 1368
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 1369
    ldv_work_3_3 = 4;
#line 1370
    ipoib_ib_dev_flush_light(ldv_work_struct_3_0);
#line 1371
    ldv_work_3_3 = 1;
  } else {

  }
#line 1374
  goto ldv_51277;
  default: 
#line 1375
  ldv_stop();
  }
  ldv_51277: ;
#line 1377
  return;
}
}
#line 1382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_work_6(struct work_struct *work ) 
{ 


  {
#line 1385
  if ((ldv_work_6_0 == 2 || ldv_work_6_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_0) {
#line 1387
    ipoib_mcast_restart_task(work);
#line 1388
    ldv_work_6_0 = 1;
#line 1389
    return;
  } else {

  }
#line 1391
  if ((ldv_work_6_1 == 2 || ldv_work_6_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_1) {
#line 1393
    ipoib_mcast_restart_task(work);
#line 1394
    ldv_work_6_1 = 1;
#line 1395
    return;
  } else {

  }
#line 1397
  if ((ldv_work_6_2 == 2 || ldv_work_6_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_2) {
#line 1399
    ipoib_mcast_restart_task(work);
#line 1400
    ldv_work_6_2 = 1;
#line 1401
    return;
  } else {

  }
#line 1403
  if ((ldv_work_6_3 == 2 || ldv_work_6_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_3) {
#line 1405
    ipoib_mcast_restart_task(work);
#line 1406
    ldv_work_6_3 = 1;
#line 1407
    return;
  } else {

  }
#line 1409
  return;
}
}
#line 1412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 1415
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 1417
    ipoib_mcast_carrier_on_task(work);
#line 1418
    ldv_work_2_0 = 1;
#line 1419
    return;
  } else {

  }
#line 1421
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 1423
    ipoib_mcast_carrier_on_task(work);
#line 1424
    ldv_work_2_1 = 1;
#line 1425
    return;
  } else {

  }
#line 1427
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 1429
    ipoib_mcast_carrier_on_task(work);
#line 1430
    ldv_work_2_2 = 1;
#line 1431
    return;
  } else {

  }
#line 1433
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 1435
    ipoib_mcast_carrier_on_task(work);
#line 1436
    ldv_work_2_3 = 1;
#line 1437
    return;
  } else {

  }
#line 1439
  return;
}
}
#line 1443
void ldv_main_exported_22(void) ;
#line 1452
void ldv_main_exported_23(void) ;
#line 1453
void ldv_main_exported_18(void) ;
#line 1454
void ldv_main_exported_19(void) ;
#line 1455
void ldv_main_exported_16(void) ;
#line 1456
void ldv_main_exported_17(void) ;
#line 1457
void ldv_main_exported_21(void) ;
#line 1458
void ldv_main_exported_20(void) ;
#line 1462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void main(void) 
{ 
  size_t ldvarg4 ;
  char *ldvarg3 ;
  void *tmp ;
  char *ldvarg5 ;
  void *tmp___0 ;
  struct net_device *ldvarg24 ;
  void *tmp___1 ;
  void *ldvarg21 ;
  void *tmp___2 ;
  void *ldvarg25 ;
  void *tmp___3 ;
  unsigned int ldvarg20 ;
  unsigned short ldvarg23 ;
  struct sk_buff *ldvarg22 ;
  void *tmp___4 ;
  char *ldvarg27 ;
  void *tmp___5 ;
  struct device *ldvarg26 ;
  void *tmp___6 ;
  struct device_attribute *ldvarg28 ;
  void *tmp___7 ;
  struct device_attribute *ldvarg32 ;
  void *tmp___8 ;
  char *ldvarg31 ;
  void *tmp___9 ;
  size_t ldvarg29 ;
  struct device *ldvarg30 ;
  void *tmp___10 ;
  int ldvarg35 ;
  struct net_device *ldvarg36 ;
  void *tmp___11 ;
  struct sk_buff *ldvarg34 ;
  void *tmp___12 ;
  netdev_features_t ldvarg33 ;
  struct device *ldvarg41 ;
  void *tmp___13 ;
  struct device_attribute *ldvarg43 ;
  void *tmp___14 ;
  char *ldvarg42 ;
  void *tmp___15 ;
  size_t ldvarg40 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 1466
  tmp = ldv_init_zalloc(1UL);
#line 1466
  ldvarg3 = (char *)tmp;
#line 1467
  tmp___0 = ldv_init_zalloc(1UL);
#line 1467
  ldvarg5 = (char *)tmp___0;
#line 1468
  tmp___1 = ldv_init_zalloc(3008UL);
#line 1468
  ldvarg24 = (struct net_device *)tmp___1;
#line 1469
  tmp___2 = ldv_init_zalloc(1UL);
#line 1469
  ldvarg21 = tmp___2;
#line 1470
  tmp___3 = ldv_init_zalloc(1UL);
#line 1470
  ldvarg25 = tmp___3;
#line 1473
  tmp___4 = ldv_init_zalloc(232UL);
#line 1473
  ldvarg22 = (struct sk_buff *)tmp___4;
#line 1474
  tmp___5 = ldv_init_zalloc(1UL);
#line 1474
  ldvarg27 = (char *)tmp___5;
#line 1475
  tmp___6 = ldv_init_zalloc(1416UL);
#line 1475
  ldvarg26 = (struct device *)tmp___6;
#line 1476
  tmp___7 = ldv_init_zalloc(48UL);
#line 1476
  ldvarg28 = (struct device_attribute *)tmp___7;
#line 1477
  tmp___8 = ldv_init_zalloc(48UL);
#line 1477
  ldvarg32 = (struct device_attribute *)tmp___8;
#line 1478
  tmp___9 = ldv_init_zalloc(1UL);
#line 1478
  ldvarg31 = (char *)tmp___9;
#line 1480
  tmp___10 = ldv_init_zalloc(1416UL);
#line 1480
  ldvarg30 = (struct device *)tmp___10;
#line 1482
  tmp___11 = ldv_init_zalloc(3008UL);
#line 1482
  ldvarg36 = (struct net_device *)tmp___11;
#line 1483
  tmp___12 = ldv_init_zalloc(232UL);
#line 1483
  ldvarg34 = (struct sk_buff *)tmp___12;
#line 1485
  tmp___13 = ldv_init_zalloc(1416UL);
#line 1485
  ldvarg41 = (struct device *)tmp___13;
#line 1486
  tmp___14 = ldv_init_zalloc(48UL);
#line 1486
  ldvarg43 = (struct device_attribute *)tmp___14;
#line 1487
  tmp___15 = ldv_init_zalloc(1UL);
#line 1487
  ldvarg42 = (char *)tmp___15;
#line 1463
  ldv_initialize();
#line 1465
  ldv_memset((void *)(& ldvarg4), 0, 8UL);
#line 1471
  ldv_memset((void *)(& ldvarg20), 0, 4UL);
#line 1472
  ldv_memset((void *)(& ldvarg23), 0, 2UL);
#line 1479
  ldv_memset((void *)(& ldvarg29), 0, 8UL);
#line 1481
  ldv_memset((void *)(& ldvarg35), 0, 4UL);
#line 1484
  ldv_memset((void *)(& ldvarg33), 0, 8UL);
#line 1488
  ldv_memset((void *)(& ldvarg40), 0, 8UL);
#line 1491
  work_init_11();
#line 1493
  ldv_state_variable_11 = 1;
#line 1494
  ldv_state_variable_21 = 0;
#line 1496
  work_init_7();
#line 1498
  ldv_state_variable_7 = 1;
#line 1499
  ldv_state_variable_26 = 0;
#line 1500
  ldv_state_variable_17 = 0;
#line 1502
  work_init_2();
#line 1504
  ldv_state_variable_2 = 1;
#line 1505
  ldv_state_variable_22 = 0;
#line 1507
  work_init_1();
#line 1509
  ldv_state_variable_1 = 1;
#line 1510
  ldv_state_variable_18 = 0;
#line 1511
  ref_cnt = 0;
#line 1512
  ldv_state_variable_0 = 1;
#line 1513
  ldv_state_variable_30 = 0;
#line 1514
  ldv_state_variable_23 = 0;
#line 1515
  ldv_state_variable_16 = 0;
#line 1517
  work_init_13();
#line 1519
  ldv_state_variable_13 = 1;
#line 1520
  ldv_state_variable_29 = 0;
#line 1521
  ldv_state_variable_27 = 0;
#line 1522
  ldv_state_variable_25 = 0;
#line 1524
  work_init_6();
#line 1526
  ldv_state_variable_6 = 1;
#line 1527
  ldv_state_variable_28 = 0;
#line 1529
  work_init_3();
#line 1531
  ldv_state_variable_3 = 1;
#line 1533
  work_init_9();
#line 1535
  ldv_state_variable_9 = 1;
#line 1537
  work_init_12();
#line 1539
  ldv_state_variable_12 = 1;
#line 1540
  ldv_state_variable_20 = 0;
#line 1542
  work_init_14();
#line 1544
  ldv_state_variable_14 = 1;
#line 1546
  timer_init_15();
#line 1548
  ldv_state_variable_15 = 1;
#line 1550
  work_init_8();
#line 1552
  ldv_state_variable_8 = 1;
#line 1554
  work_init_4();
#line 1556
  ldv_state_variable_4 = 1;
#line 1557
  ldv_state_variable_24 = 0;
#line 1558
  ldv_state_variable_19 = 0;
#line 1560
  work_init_10();
#line 1562
  ldv_state_variable_10 = 1;
#line 1564
  work_init_5();
#line 1566
  ldv_state_variable_5 = 1;
  ldv_51423: 
#line 1568
  tmp___16 = __VERIFIER_nondet_int();
#line 1568
  switch (tmp___16) {
  case 0: ;
#line 1575
  goto ldv_51354;
  case 1: ;
#line 1579
  if (ldv_state_variable_21 != 0) {
#line 1580
    ldv_main_exported_21();
  } else {

  }
#line 1583
  goto ldv_51354;
  case 2: ;
#line 1587
  if (ldv_state_variable_7 != 0) {
#line 1588
    invoke_work_7();
  } else {

  }
#line 1591
  goto ldv_51354;
  case 3: ;
#line 1595
  if (ldv_state_variable_26 != 0) {
#line 1596
    tmp___17 = __VERIFIER_nondet_int();
#line 1596
    switch (tmp___17) {
    case 0: ;
#line 1599
    if (ldv_state_variable_26 == 1) {
#line 1601
      set_umcast(dev_attr_umcast_group1, dev_attr_umcast_group0, (char const   *)ldvarg5,
                 ldvarg4);
#line 1603
      ldv_state_variable_26 = 1;
    } else {

    }
#line 1606
    goto ldv_51359;
    case 1: ;
#line 1609
    if (ldv_state_variable_26 == 1) {
#line 1611
      show_umcast(dev_attr_umcast_group1, dev_attr_umcast_group0, ldvarg3);
#line 1613
      ldv_state_variable_26 = 1;
    } else {

    }
#line 1616
    goto ldv_51359;
    default: 
#line 1617
    ldv_stop();
    }
    ldv_51359: ;
  } else {

  }
#line 1621
  goto ldv_51354;
  case 4: ;
#line 1625
  if (ldv_state_variable_17 != 0) {
#line 1626
    ldv_main_exported_17();
  } else {

  }
#line 1629
  goto ldv_51354;
  case 5: ;
#line 1633
  if (ldv_state_variable_2 != 0) {
#line 1634
    invoke_work_2();
  } else {

  }
#line 1637
  goto ldv_51354;
  case 6: ;
#line 1641
  if (ldv_state_variable_22 != 0) {
#line 1642
    ldv_main_exported_22();
  } else {

  }
#line 1645
  goto ldv_51354;
  case 7: ;
#line 1649
  if (ldv_state_variable_1 != 0) {
#line 1650
    invoke_work_1();
  } else {

  }
#line 1653
  goto ldv_51354;
  case 8: ;
#line 1657
  if (ldv_state_variable_18 != 0) {
#line 1658
    ldv_main_exported_18();
  } else {

  }
#line 1661
  goto ldv_51354;
  case 9: ;
#line 1665
  if (ldv_state_variable_0 != 0) {
#line 1666
    tmp___18 = __VERIFIER_nondet_int();
#line 1666
    switch (tmp___18) {
    case 0: ;
#line 1669
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 1671
      ipoib_cleanup_module();
#line 1672
      ldv_state_variable_0 = 2;
#line 1673
      goto ldv_final;
    } else {

    }
#line 1676
    goto ldv_51370;
    case 1: ;
#line 1679
    if (ldv_state_variable_0 == 1) {
#line 1681
      ldv_retval_3 = ipoib_init_module();
#line 1683
      if (ldv_retval_3 == 0) {
#line 1684
        ldv_state_variable_0 = 3;
#line 1685
        ldv_state_variable_29 = 1;
#line 1686
        ldv_state_variable_23 = 1;
#line 1687
        ldv_state_variable_16 = 1;
#line 1688
        ldv_file_operations_16();
#line 1689
        ldv_state_variable_24 = 1;
#line 1690
        ldv_state_variable_30 = 1;
#line 1691
        ldv_initialize_ib_client_30();
#line 1692
        ldv_state_variable_18 = 1;
#line 1693
        ldv_file_operations_18();
#line 1694
        ldv_state_variable_22 = 1;
#line 1695
        ldv_initialize_ethtool_ops_22();
#line 1696
        ldv_state_variable_20 = 1;
#line 1697
        ldv_initialize_device_attribute_20();
#line 1698
        ldv_state_variable_26 = 1;
#line 1699
        ldv_initialize_device_attribute_26();
#line 1700
        ldv_state_variable_21 = 1;
#line 1701
        ldv_initialize_rtnl_link_ops_21();
#line 1702
        ldv_state_variable_25 = 1;
#line 1703
        ldv_state_variable_27 = 1;
      } else {

      }
#line 1705
      if (ldv_retval_3 != 0) {
#line 1706
        ldv_state_variable_0 = 2;
#line 1707
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 1711
    goto ldv_51370;
    default: 
#line 1712
    ldv_stop();
    }
    ldv_51370: ;
  } else {

  }
#line 1716
  goto ldv_51354;
  case 10: ;
#line 1720
  if (ldv_state_variable_30 != 0) {
#line 1721
    tmp___19 = __VERIFIER_nondet_int();
#line 1721
    switch (tmp___19) {
    case 0: ;
#line 1724
    if (ldv_state_variable_30 == 1) {
#line 1726
      ipoib_add_one(ipoib_client_group0);
#line 1728
      ldv_state_variable_30 = 2;
#line 1729
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 1732
    goto ldv_51375;
    case 1: ;
#line 1735
    if (ldv_state_variable_30 == 2) {
#line 1737
      ipoib_remove_one(ipoib_client_group0);
#line 1739
      ldv_state_variable_30 = 1;
#line 1740
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1743
    goto ldv_51375;
    default: 
#line 1744
    ldv_stop();
    }
    ldv_51375: ;
  } else {

  }
#line 1748
  goto ldv_51354;
  case 11: ;
#line 1752
  if (ldv_state_variable_23 != 0) {
#line 1753
    ldv_main_exported_23();
  } else {

  }
#line 1756
  goto ldv_51354;
  case 12: ;
#line 1760
  if (ldv_state_variable_16 != 0) {
#line 1761
    ldv_main_exported_16();
  } else {

  }
#line 1764
  goto ldv_51354;
  case 13: ;
#line 1771
  goto ldv_51354;
  case 14: ;
#line 1775
  if (ldv_state_variable_29 != 0) {
#line 1776
    tmp___20 = __VERIFIER_nondet_int();
#line 1776
    switch (tmp___20) {
    case 0: ;
#line 1779
    if (ldv_state_variable_29 == 1) {
#line 1781
      ipoib_hard_header(ldvarg22, ldvarg24, (int )ldvarg23, (void const   *)ldvarg21,
                        (void const   *)ldvarg25, ldvarg20);
#line 1783
      ldv_state_variable_29 = 1;
    } else {

    }
#line 1786
    goto ldv_51383;
    default: 
#line 1787
    ldv_stop();
    }
    ldv_51383: ;
  } else {

  }
#line 1791
  goto ldv_51354;
  case 15: ;
#line 1795
  if (ldv_state_variable_27 != 0) {
#line 1796
    tmp___21 = __VERIFIER_nondet_int();
#line 1796
    switch (tmp___21) {
    case 0: ;
#line 1799
    if (ldv_state_variable_27 == 1) {
#line 1801
      show_pkey(ldvarg26, ldvarg28, ldvarg27);
#line 1803
      ldv_state_variable_27 = 1;
    } else {

    }
#line 1806
    goto ldv_51387;
    default: 
#line 1807
    ldv_stop();
    }
    ldv_51387: ;
  } else {

  }
#line 1811
  goto ldv_51354;
  case 16: ;
#line 1815
  if (ldv_state_variable_25 != 0) {
#line 1816
    tmp___22 = __VERIFIER_nondet_int();
#line 1816
    switch (tmp___22) {
    case 0: ;
#line 1819
    if (ldv_state_variable_25 == 1) {
#line 1821
      create_child(ldvarg30, ldvarg32, (char const   *)ldvarg31, ldvarg29);
#line 1823
      ldv_state_variable_25 = 1;
    } else {

    }
#line 1826
    goto ldv_51391;
    default: 
#line 1827
    ldv_stop();
    }
    ldv_51391: ;
  } else {

  }
#line 1831
  goto ldv_51354;
  case 17: ;
#line 1835
  if (ldv_state_variable_6 != 0) {
#line 1836
    invoke_work_6();
  } else {

  }
#line 1839
  goto ldv_51354;
  case 18: ;
#line 1843
  if (ldv_state_variable_28 != 0) {
#line 1844
    tmp___23 = __VERIFIER_nondet_int();
#line 1844
    switch (tmp___23) {
    case 0: ;
#line 1847
    if (ldv_state_variable_28 == 3) {
#line 1849
      ipoib_stop(ipoib_netdev_ops_group1);
#line 1850
      ldv_state_variable_28 = 2;
    } else {

    }
#line 1853
    goto ldv_51396;
    case 1: ;
#line 1856
    if (ldv_state_variable_28 == 1) {
#line 1858
      ipoib_set_mcast_list(ipoib_netdev_ops_group1);
#line 1860
      ldv_state_variable_28 = 1;
    } else {

    }
#line 1863
    if (ldv_state_variable_28 == 3) {
#line 1865
      ipoib_set_mcast_list(ipoib_netdev_ops_group1);
#line 1867
      ldv_state_variable_28 = 3;
    } else {

    }
#line 1870
    if (ldv_state_variable_28 == 2) {
#line 1872
      ipoib_set_mcast_list(ipoib_netdev_ops_group1);
#line 1874
      ldv_state_variable_28 = 2;
    } else {

    }
#line 1877
    goto ldv_51396;
    case 2: ;
#line 1880
    if (ldv_state_variable_28 == 1) {
#line 1882
      ipoib_get_iflink((struct net_device  const  *)ldvarg36);
#line 1884
      ldv_state_variable_28 = 1;
    } else {

    }
#line 1887
    if (ldv_state_variable_28 == 3) {
#line 1889
      ipoib_get_iflink((struct net_device  const  *)ldvarg36);
#line 1891
      ldv_state_variable_28 = 3;
    } else {

    }
#line 1894
    if (ldv_state_variable_28 == 2) {
#line 1896
      ipoib_get_iflink((struct net_device  const  *)ldvarg36);
#line 1898
      ldv_state_variable_28 = 2;
    } else {

    }
#line 1901
    goto ldv_51396;
    case 3: ;
#line 1904
    if (ldv_state_variable_28 == 3) {
#line 1906
      ipoib_change_mtu(ipoib_netdev_ops_group1, ldvarg35);
#line 1908
      ldv_state_variable_28 = 3;
    } else {

    }
#line 1911
    if (ldv_state_variable_28 == 2) {
#line 1913
      ipoib_change_mtu(ipoib_netdev_ops_group1, ldvarg35);
#line 1915
      ldv_state_variable_28 = 2;
    } else {

    }
#line 1918
    goto ldv_51396;
    case 4: ;
#line 1921
    if (ldv_state_variable_28 == 2) {
#line 1923
      ldv_retval_6 = ipoib_open(ipoib_netdev_ops_group1);
#line 1924
      if (ldv_retval_6 == 0) {
#line 1925
        ldv_state_variable_28 = 3;
      } else {

      }
    } else {

    }
#line 1929
    goto ldv_51396;
    case 5: ;
#line 1932
    if (ldv_state_variable_28 == 2) {
#line 1934
      ipoib_uninit(ipoib_netdev_ops_group1);
#line 1935
      ldv_state_variable_28 = 1;
#line 1936
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1939
    goto ldv_51396;
    case 6: ;
#line 1942
    if (ldv_state_variable_28 == 3) {
#line 1944
      ipoib_start_xmit(ldvarg34, ipoib_netdev_ops_group1);
#line 1946
      ldv_state_variable_28 = 3;
    } else {

    }
#line 1949
    goto ldv_51396;
    case 7: ;
#line 1952
    if (ldv_state_variable_28 == 1) {
#line 1954
      ipoib_fix_features(ipoib_netdev_ops_group1, ldvarg33);
#line 1956
      ldv_state_variable_28 = 1;
    } else {

    }
#line 1959
    if (ldv_state_variable_28 == 3) {
#line 1961
      ipoib_fix_features(ipoib_netdev_ops_group1, ldvarg33);
#line 1963
      ldv_state_variable_28 = 3;
    } else {

    }
#line 1966
    if (ldv_state_variable_28 == 2) {
#line 1968
      ipoib_fix_features(ipoib_netdev_ops_group1, ldvarg33);
#line 1970
      ldv_state_variable_28 = 2;
    } else {

    }
#line 1973
    goto ldv_51396;
    case 8: ;
#line 1976
    if (ldv_state_variable_28 == 1) {
#line 1978
      ipoib_timeout(ipoib_netdev_ops_group1);
#line 1980
      ldv_state_variable_28 = 1;
    } else {

    }
#line 1983
    if (ldv_state_variable_28 == 3) {
#line 1985
      ipoib_timeout(ipoib_netdev_ops_group1);
#line 1987
      ldv_state_variable_28 = 3;
    } else {

    }
#line 1990
    if (ldv_state_variable_28 == 2) {
#line 1992
      ipoib_timeout(ipoib_netdev_ops_group1);
#line 1994
      ldv_state_variable_28 = 2;
    } else {

    }
#line 1997
    goto ldv_51396;
    case 9: ;
#line 2000
    if (ldv_state_variable_28 == 1) {
#line 2002
      ldv_retval_5 = ldv_ndo_init_28();
#line 2003
      if (ldv_retval_5 == 0) {
#line 2004
        ldv_state_variable_28 = 2;
#line 2005
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 2009
    goto ldv_51396;
    default: 
#line 2010
    ldv_stop();
    }
    ldv_51396: ;
  } else {

  }
#line 2014
  goto ldv_51354;
  case 19: ;
#line 2018
  if (ldv_state_variable_3 != 0) {
#line 2019
    invoke_work_3();
  } else {

  }
#line 2022
  goto ldv_51354;
  case 20: ;
#line 2029
  goto ldv_51354;
  case 21: ;
#line 2036
  goto ldv_51354;
  case 22: ;
#line 2040
  if (ldv_state_variable_20 != 0) {
#line 2041
    ldv_main_exported_20();
  } else {

  }
#line 2044
  goto ldv_51354;
  case 23: ;
#line 2051
  goto ldv_51354;
  case 24: ;
#line 2058
  goto ldv_51354;
  case 25: ;
#line 2062
  if (ldv_state_variable_8 != 0) {
#line 2063
    invoke_work_8();
  } else {

  }
#line 2066
  goto ldv_51354;
  case 26: ;
#line 2070
  if (ldv_state_variable_4 != 0) {
#line 2071
    invoke_work_4();
  } else {

  }
#line 2074
  goto ldv_51354;
  case 27: ;
#line 2078
  if (ldv_state_variable_24 != 0) {
#line 2079
    tmp___24 = __VERIFIER_nondet_int();
#line 2079
    switch (tmp___24) {
    case 0: ;
#line 2082
    if (ldv_state_variable_24 == 1) {
#line 2084
      delete_child(ldvarg41, ldvarg43, (char const   *)ldvarg42, ldvarg40);
#line 2086
      ldv_state_variable_24 = 1;
    } else {

    }
#line 2089
    goto ldv_51417;
    default: 
#line 2090
    ldv_stop();
    }
    ldv_51417: ;
  } else {

  }
#line 2094
  goto ldv_51354;
  case 28: ;
#line 2098
  if (ldv_state_variable_19 != 0) {
#line 2099
    ldv_main_exported_19();
  } else {

  }
#line 2102
  goto ldv_51354;
  case 29: ;
#line 2109
  goto ldv_51354;
  case 30: ;
#line 2113
  if (ldv_state_variable_5 != 0) {
#line 2114
    invoke_work_5();
  } else {

  }
#line 2117
  goto ldv_51354;
  default: 
#line 2118
  ldv_stop();
  }
  ldv_51354: ;
#line 2120
  goto ldv_51423;
  ldv_final: 
#line 2122
  ldv_check_final_state();
#line 2123
  return;
}
}
#line 2126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 2129
  tmp = ldv_err_ptr(error);
#line 2129
  return (tmp);
}
}
#line 2138 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 2141
  tmp = ldv_is_err(ptr);
#line 2141
  return (tmp);
}
}
#line 2144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 2147
  tmp = ldv_is_err_or_null(ptr);
#line 2147
  return (tmp);
}
}
#line 2150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 2154
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2154
  ldv_func_res = tmp;
#line 2156
  activate_work_11(ldv_func_arg3, 2);
#line 2158
  return (ldv_func_res);
}
}
#line 2161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 2165
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2165
  ldv_func_res = tmp;
#line 2167
  activate_work_11(& ldv_func_arg3->work, 2);
#line 2169
  return (ldv_func_res);
}
}
#line 2172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 2176
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2176
  ldv_func_res = tmp;
#line 2178
  activate_work_11(ldv_func_arg3, 2);
#line 2180
  return (ldv_func_res);
}
}
#line 2183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2186
  flush_workqueue(ldv_func_arg1);
#line 2188
  call_and_disable_all_11(2);
#line 2189
  return;
}
}
#line 2191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 2195
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 2195
  ldv_func_res = tmp;
#line 2197
  activate_work_11(& ldv_func_arg3->work, 2);
#line 2199
  return (ldv_func_res);
}
}
#line 2202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_cancel_delayed_work_10(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 2206
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 2206
  ldv_func_res = tmp;
#line 2208
  disable_work_11(& ldv_func_arg1->work);
#line 2210
  return (ldv_func_res);
}
}
#line 2213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_cancel_delayed_work_11(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 2217
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 2217
  ldv_func_res = tmp;
#line 2219
  disable_work_11(& ldv_func_arg1->work);
#line 2221
  return (ldv_func_res);
}
}
#line 2224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
int ldv_register_netdev_12(struct net_device *dev ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 2228
  tmp = register_netdev(dev);
#line 2228
  ldv_func_res = tmp;
#line 2230
  ldv_state_variable_28 = 1;
#line 2231
  ldv_net_device_ops_28();
#line 2234
  return (ldv_func_res);
}
}
#line 2237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_unregister_netdev_13(struct net_device *dev ) 
{ 


  {
#line 2240
  unregister_netdev(dev);
#line 2242
  ldv_state_variable_28 = 0;
#line 2243
  return;
}
}
#line 2245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_flush_workqueue_14(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2248
  flush_workqueue(ldv_func_arg1);
#line 2250
  call_and_disable_all_11(2);
#line 2251
  return;
}
}
#line 2253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_cancel_delayed_work_15(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
#line 2257
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 2257
  ldv_func_res = tmp;
#line 2259
  disable_work_11(& ldv_func_arg1->work);
#line 2261
  return (ldv_func_res);
}
}
#line 2264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_flush_workqueue_16(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2267
  flush_workqueue(ldv_func_arg1);
#line 2269
  call_and_disable_all_11(2);
#line 2270
  return;
}
}
#line 2272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_free_netdev_17(struct net_device *dev ) 
{ 


  {
#line 2275
  free_netdev(dev);
#line 2277
  ldv_state_variable_28 = 0;
#line 2278
  return;
}
}
#line 2280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_flush_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2283
  flush_workqueue(ldv_func_arg1);
#line 2285
  call_and_disable_all_11(2);
#line 2286
  return;
}
}
#line 2288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
bool ldv_cancel_delayed_work_19(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
#line 2292
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 2292
  ldv_func_res = tmp;
#line 2294
  disable_work_11(& ldv_func_arg1->work);
#line 2296
  return (ldv_func_res);
}
}
#line 2299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_flush_workqueue_20(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2302
  flush_workqueue(ldv_func_arg1);
#line 2304
  call_and_disable_all_11(2);
#line 2305
  return;
}
}
#line 2307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_unregister_netdev_21(struct net_device *dev ) 
{ 


  {
#line 2310
  unregister_netdev(dev);
#line 2312
  ldv_state_variable_28 = 0;
#line 2313
  return;
}
}
#line 2315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_free_netdev_22(struct net_device *dev ) 
{ 


  {
#line 2318
  free_netdev(dev);
#line 2320
  ldv_state_variable_28 = 0;
#line 2321
  return;
}
}
#line 2323 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_destroy_workqueue_23(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2326
  destroy_workqueue(ldv_func_arg1);
#line 2328
  call_and_disable_all_11(2);
#line 2329
  return;
}
}
#line 2331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_main.o.c.prepared"
void ldv_destroy_workqueue_24(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 2334
  destroy_workqueue(ldv_func_arg1);
#line 2336
  call_and_disable_all_11(2);
#line 2337
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_54(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_55(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_58(struct timer_list *ldv_func_arg1 ) ;
#line 253
extern unsigned long round_jiffies_relative(unsigned long  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_52(struct workqueue_struct *ldv_func_arg1 ) ;
#line 459
void ldv_flush_workqueue_57(struct workqueue_struct *ldv_func_arg1 ) ;
#line 474
bool ldv_cancel_delayed_work_56(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_49(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work___0(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                            unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_50(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 32 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 34
  atomic_set(& kref->refcount, 1);
#line 35
  return;
}
}
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void activate_suitable_timer_15(struct timer_list *timer , unsigned long data ) ;
#line 223
int reg_timer_15(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 227
void call_and_disable_all_9(int state ) ;
#line 229
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 238
void invoke_work_9(void) ;
#line 243
void activate_work_9(struct work_struct *work , int state ) ;
#line 258
void choose_timer_15(void) ;
#line 264
void call_and_disable_work_9(struct work_struct *work ) ;
#line 269
void ldv_timer_15(int state , struct timer_list *timer ) ;
#line 275
void disable_work_9(struct work_struct *work ) ;
#line 283
void disable_suitable_timer_15(struct timer_list *timer ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_25109: ;
#line 19
    goto ldv_25109;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_25118: ;
#line 36
    goto ldv_25118;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 76 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 80
  tmp = get_dma_ops(dev);
#line 80
  ops = tmp;
#line 83
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 83
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 84
  tmp___1 = valid_dma_direction((int )dir);
#line 84
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 84
  if (tmp___2 != 0L) {
#line 84
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (84), "i" (12UL));
    ldv_25153: ;
#line 84
    goto ldv_25153;
  } else {

  }
#line 85
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
#line 86
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 88
  return (addr);
}
}
#line 91 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 94
  tmp = get_dma_ops(dev);
#line 94
  ops = tmp;
#line 96
  tmp___0 = valid_dma_direction((int )dir);
#line 96
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 96
  if (tmp___1 != 0L) {
#line 96
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (96), "i" (12UL));
    ldv_25161: ;
#line 96
    goto ldv_25161;
  } else {

  }
#line 97
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 98
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
  } else {

  }
#line 99
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 100
  return;
}
}
#line 47 "./arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 230 "include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const   *frag ) 
{ 


  {
#line 232
  return ((unsigned int )frag->size);
}
}
#line 976 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 978
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 1572 "include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff  const  *skb ) 
{ 


  {
#line 1574
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
#line 1692
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 1710
extern unsigned char *skb_pull(struct sk_buff * , unsigned int  ) ;
#line 1793 "include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb , int len ) 
{ 


  {
#line 1795
  skb->data = skb->data + (unsigned long )len;
#line 1796
  skb->tail = skb->tail + (sk_buff_data_t )len;
#line 1797
  return;
}
}
#line 1884 "include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1886
  return ((unsigned char *)skb->head + (unsigned long )skb->transport_header);
}
}
#line 1927 "include/linux/skbuff.h"
__inline static void skb_reset_mac_header(struct sk_buff *skb ) 
{ 


  {
#line 1929
  skb->mac_header = (int )((__u16 )((long )skb->data)) - (int )((__u16 )((long )skb->head));
#line 1930
  return;
}
}
#line 1971 "include/linux/skbuff.h"
__inline static int skb_transport_offset(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 1973
  tmp = skb_transport_header(skb);
#line 1973
  return ((int )((unsigned int )((long )tmp) - (unsigned int )((long )skb->data)));
}
}
#line 2099 "include/linux/skbuff.h"
__inline static void skb_orphan(struct sk_buff *skb ) 
{ 
  long tmp ;

  {
#line 2101
  if ((unsigned long )skb->destructor != (unsigned long )((void (*)(struct sk_buff * ))0)) {
#line 2102
    (*(skb->destructor))(skb);
#line 2103
    skb->destructor = (void (*)(struct sk_buff * ))0;
#line 2104
    skb->sk = (struct sock *)0;
  } else {
#line 2106
    tmp = ldv__builtin_expect((unsigned long )skb->sk != (unsigned long )((struct sock *)0),
                           0L);
#line 2106
    if (tmp != 0L) {
#line 2106
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/skbuff.h"),
                           "i" (2106), "i" (12UL));
      ldv_27690: ;
#line 2106
      goto ldv_27690;
    } else {

    }
  }
#line 2108
  return;
}
}
#line 2144
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 2160 "include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev , unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2163
  tmp = __netdev_alloc_skb(dev, length, 32U);
#line 2163
  return (tmp);
}
}
#line 2174 "include/linux/skbuff.h"
__inline static struct sk_buff *dev_alloc_skb(unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2176
  tmp = netdev_alloc_skb((struct net_device *)0, length);
#line 2176
  return (tmp);
}
}
#line 2276 "include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const   *frag ) 
{ 


  {
#line 2278
  return ((struct page *)frag->page.p);
}
}
#line 3385 "include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 3387
  tmp = skb_end_pointer(skb);
#line 3387
  return ((unsigned int )((struct skb_shared_info *)tmp)->gso_size != 0U);
}
}
#line 391 "include/linux/netdevice.h"
extern void __napi_schedule(struct napi_struct * ) ;
#line 394 "include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n ) 
{ 
  int tmp ;

  {
#line 396
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& n->state));
#line 396
  return (tmp != 0);
}
}
#line 408 "include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 410
  tmp = napi_disable_pending(n);
#line 410
  if (tmp) {
#line 410
    tmp___0 = 0;
  } else {
#line 410
    tmp___0 = 1;
  }
#line 410
  if (tmp___0) {
#line 410
    tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
#line 410
    if (tmp___1 == 0) {
#line 410
      tmp___2 = 1;
    } else {
#line 410
      tmp___2 = 0;
    }
  } else {
#line 410
    tmp___2 = 0;
  }
#line 410
  return ((bool )tmp___2);
}
}
#line 421 "include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n ) 
{ 
  bool tmp ;

  {
#line 423
  tmp = napi_schedule_prep(n);
#line 423
  if ((int )tmp) {
#line 424
    __napi_schedule(n);
  } else {

  }
#line 425
  return;
}
}
#line 440 "include/linux/netdevice.h"
__inline static bool napi_reschedule(struct napi_struct *napi ) 
{ 
  bool tmp ;

  {
#line 442
  tmp = napi_schedule_prep(napi);
#line 442
  if ((int )tmp) {
#line 443
    __napi_schedule(napi);
#line 444
    return (1);
  } else {

  }
#line 446
  return (0);
}
}
#line 458 "include/linux/netdevice.h"
__inline static void napi_complete(struct napi_struct *n ) 
{ 


  {
#line 460
  return;
}
}
#line 496
extern void napi_disable(struct napi_struct * ) ;
#line 505 "include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 507
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& n->state));
#line 507
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 507
  if (tmp___0 != 0L) {
#line 507
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (507), "i" (12UL));
    ldv_41839: ;
#line 507
    goto ldv_41839;
  } else {

  }
#line 508
  __asm__  volatile   ("": : : "memory");
#line 509
  clear_bit(0L, (unsigned long volatile   *)(& n->state));
#line 510
  return;
}
}
#line 2541
extern void netif_tx_wake_queue(struct netdev_queue * ) ;
#line 2550 "include/linux/netdevice.h"
__inline static void netif_wake_queue(struct net_device *dev ) 
{ 
  struct netdev_queue *tmp ;

  {
#line 2552
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, 0U);
#line 2552
  netif_tx_wake_queue(tmp);
#line 2553
  return;
}
}
#line 2948
extern gro_result_t napi_gro_receive(struct napi_struct * , struct sk_buff * ) ;
#line 3214 "include/linux/netdevice.h"
__inline static void netif_tx_lock___0(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3219
  spin_lock(& dev->tx_global_lock);
#line 3220
  __vpp_verify = (void const   *)0;
#line 3220
  switch (4UL) {
  case 1UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43416;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43416;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43416;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43416;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43416: 
#line 3220
  pscr_ret__ = pfo_ret__;
#line 3220
  goto ldv_43422;
  case 2UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43426;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43426;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43426;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43426;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43426: 
#line 3220
  pscr_ret__ = pfo_ret_____0;
#line 3220
  goto ldv_43422;
  case 4UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43435;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43435;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43435;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43435;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43435: 
#line 3220
  pscr_ret__ = pfo_ret_____1;
#line 3220
  goto ldv_43422;
  case 8UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43444;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43444;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43444;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43444;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43444: 
#line 3220
  pscr_ret__ = pfo_ret_____2;
#line 3220
  goto ldv_43422;
  default: 
#line 3220
  __bad_size_call_parameter();
#line 3220
  goto ldv_43422;
  }
  ldv_43422: 
#line 3220
  cpu = pscr_ret__;
#line 3221
  i = 0U;
#line 3221
  goto ldv_43454;
  ldv_43453: 
#line 3222
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3222
  txq = tmp;
#line 3230
  __netif_tx_lock(txq, cpu);
#line 3231
  set_bit(2L, (unsigned long volatile   *)(& txq->state));
#line 3232
  __netif_tx_unlock(txq);
#line 3221
  i = i + 1U;
  ldv_43454: ;
#line 3221
  if (dev->num_tx_queues > i) {
#line 3223
    goto ldv_43453;
  } else {

  }

#line 3228
  return;
}
}
#line 3236 "include/linux/netdevice.h"
__inline static void netif_tx_lock_bh___0(struct net_device *dev ) 
{ 


  {
#line 3238
  local_bh_disable();
#line 3239
  netif_tx_lock___0(dev);
#line 3240
  return;
}
}
#line 3242 "include/linux/netdevice.h"
__inline static void netif_tx_unlock___0(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3246
  i = 0U;
#line 3246
  goto ldv_43465;
  ldv_43464: 
#line 3247
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3247
  txq = tmp;
#line 3253
  clear_bit(2L, (unsigned long volatile   *)(& txq->state));
#line 3254
  netif_schedule_queue(txq);
#line 3246
  i = i + 1U;
  ldv_43465: ;
#line 3246
  if (dev->num_tx_queues > i) {
#line 3248
    goto ldv_43464;
  } else {

  }
#line 3256
  spin_unlock(& dev->tx_global_lock);
#line 3257
  return;
}
}
#line 3259 "include/linux/netdevice.h"
__inline static void netif_tx_unlock_bh___0(struct net_device *dev ) 
{ 


  {
#line 3261
  netif_tx_unlock___0(dev);
#line 3262
  local_bh_enable();
#line 3263
  return;
}
}
#line 265 "include/net/dst.h"
extern void dst_release(struct dst_entry * ) ;
#line 267 "include/net/dst.h"
__inline static void refdst_drop(unsigned long refdst ) 
{ 


  {
#line 269
  if ((refdst & 1UL) == 0UL) {
#line 270
    dst_release((struct dst_entry *)(refdst & 0xfffffffffffffffeUL));
  } else {

  }
#line 271
  return;
}
}
#line 279 "include/net/dst.h"
__inline static void skb_dst_drop(struct sk_buff *skb ) 
{ 


  {
#line 281
  if (skb->_skb_refdst != 0UL) {
#line 282
    refdst_drop(skb->_skb_refdst);
#line 283
    skb->_skb_refdst = 0UL;
  } else {

  }
#line 285
  return;
}
}
#line 27 "include/linux/tcp.h"
__inline static struct tcphdr *tcp_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 29
  tmp = skb_transport_header(skb);
#line 29
  return ((struct tcphdr *)tmp);
}
}
#line 32 "include/linux/tcp.h"
__inline static unsigned int tcp_hdrlen(struct sk_buff  const  *skb ) 
{ 
  struct tcphdr *tmp ;

  {
#line 34
  tmp = tcp_hdr(skb);
#line 34
  return ((unsigned int )((int )tmp->doff * 4));
}
}
#line 2121 "include/rdma/ib_verbs.h"
extern int ib_find_pkey(struct ib_device * , u8  , u16  , u16 * ) ;
#line 2147
extern struct ib_ah *ib_create_ah(struct ib_pd * , struct ib_ah_attr * ) ;
#line 2201
extern int ib_destroy_ah(struct ib_ah * ) ;
#line 2284
extern int ib_modify_qp(struct ib_qp * , struct ib_qp_attr * , int  ) ;
#line 2299
extern int ib_query_qp(struct ib_qp * , struct ib_qp_attr * , int  , struct ib_qp_init_attr * ) ;
#line 2342 "include/rdma/ib_verbs.h"
__inline static int ib_post_send(struct ib_qp *qp , struct ib_send_wr *send_wr , struct ib_send_wr **bad_send_wr ) 
{ 
  int tmp ;

  {
#line 2346
  tmp = (*((qp->device)->post_send))(qp, send_wr, bad_send_wr);
#line 2346
  return (tmp);
}
}
#line 2357 "include/rdma/ib_verbs.h"
__inline static int ib_post_recv(struct ib_qp *qp , struct ib_recv_wr *recv_wr , struct ib_recv_wr **bad_recv_wr ) 
{ 
  int tmp ;

  {
#line 2361
  tmp = (*((qp->device)->post_recv))(qp, recv_wr, bad_recv_wr);
#line 2361
  return (tmp);
}
}
#line 2419 "include/rdma/ib_verbs.h"
__inline static int ib_poll_cq(struct ib_cq *cq , int num_entries , struct ib_wc *wc ) 
{ 
  int tmp ;

  {
#line 2422
  tmp = (*((cq->device)->poll_cq))(cq, num_entries, wc);
#line 2422
  return (tmp);
}
}
#line 2464 "include/rdma/ib_verbs.h"
__inline static int ib_req_notify_cq(struct ib_cq *cq , enum ib_cq_notify_flags flags ) 
{ 
  int tmp ;

  {
#line 2467
  tmp = (*((cq->device)->req_notify_cq))(cq, flags);
#line 2467
  return (tmp);
}
}
#line 2501 "include/rdma/ib_verbs.h"
__inline static int ib_dma_mapping_error(struct ib_device *dev , u64 dma_addr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2503
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2504
    tmp = (*((dev->dma_ops)->mapping_error))(dev, dma_addr);
#line 2504
    return (tmp);
  } else {

  }
#line 2505
  tmp___0 = dma_mapping_error(dev->dma_device, dma_addr);
#line 2505
  return (tmp___0);
}
}
#line 2515 "include/rdma/ib_verbs.h"
__inline static u64 ib_dma_map_single(struct ib_device *dev , void *cpu_addr , size_t size ,
                                      enum dma_data_direction direction ) 
{ 
  u64 tmp ;
  dma_addr_t tmp___0 ;

  {
#line 2519
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2520
    tmp = (*((dev->dma_ops)->map_single))(dev, cpu_addr, size, direction);
#line 2520
    return (tmp);
  } else {

  }
#line 2521
  tmp___0 = dma_map_single_attrs(dev->dma_device, cpu_addr, size, direction, (struct dma_attrs *)0);
#line 2521
  return (tmp___0);
}
}
#line 2531 "include/rdma/ib_verbs.h"
__inline static void ib_dma_unmap_single(struct ib_device *dev , u64 addr , size_t size ,
                                         enum dma_data_direction direction ) 
{ 


  {
#line 2535
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2536
    (*((dev->dma_ops)->unmap_single))(dev, addr, size, direction);
  } else {
#line 2538
    dma_unmap_single_attrs(dev->dma_device, addr, size, direction, (struct dma_attrs *)0);
  }
#line 2539
  return;
}
}
#line 2567 "include/rdma/ib_verbs.h"
__inline static u64 ib_dma_map_page(struct ib_device *dev , struct page *page , unsigned long offset ,
                                    size_t size , enum dma_data_direction direction ) 
{ 
  u64 tmp ;
  dma_addr_t tmp___0 ;

  {
#line 2573
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2574
    tmp = (*((dev->dma_ops)->map_page))(dev, page, offset, size, direction);
#line 2574
    return (tmp);
  } else {

  }
#line 2575
  tmp___0 = dma_map_page(dev->dma_device, page, offset, size, direction);
#line 2575
  return (tmp___0);
}
}
#line 2585 "include/rdma/ib_verbs.h"
__inline static void ib_dma_unmap_page(struct ib_device *dev , u64 addr , size_t size ,
                                       enum dma_data_direction direction ) 
{ 


  {
#line 2589
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2590
    (*((dev->dma_ops)->unmap_page))(dev, addr, size, direction);
  } else {
#line 2592
    dma_unmap_page(dev->dma_device, addr, size, direction);
  }
#line 2593
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
void ipoib_ib_completion(struct ib_cq *cq , void *dev_ptr ) ;
#line 459
void ipoib_send_comp_handler(struct ib_cq *cq , void *dev_ptr ) ;
#line 491
void ipoib_pkey_dev_check_presence(struct net_device *dev ) ;
#line 501
int ipoib_mcast_start_thread(struct net_device *dev ) ;
#line 502
int ipoib_mcast_stop_thread(struct net_device *dev ) ;
#line 505
void ipoib_mcast_dev_flush(struct net_device *dev ) ;
#line 526
int ipoib_init_qp(struct net_device *dev ) ;
#line 527
int ipoib_transport_dev_init(struct net_device *dev , struct ib_device *ca ) ;
#line 528
void ipoib_transport_dev_cleanup(struct net_device *dev ) ;
#line 548
void ipoib_drain_cq(struct net_device *dev ) ;
#line 606
int ipoib_cm_dev_open(struct net_device *dev ) ;
#line 607
void ipoib_cm_dev_stop(struct net_device *dev ) ;
#line 614
void ipoib_cm_skb_too_long(struct net_device *dev , struct sk_buff *skb , unsigned int mtu ) ;
#line 616
void ipoib_cm_handle_rx_wc(struct net_device *dev , struct ib_wc *wc ) ;
#line 617
void ipoib_cm_handle_tx_wc(struct net_device *dev , struct ib_wc *wc ) ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static int data_debug_level  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
struct ipoib_ah *ipoib_create_ah(struct net_device *dev , struct ib_pd *pd , struct ib_ah_attr *attr ) 
{ 
  struct ipoib_ah *ah ;
  struct ib_ah *vah ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;

  {
#line 62
  tmp = kmalloc(40UL, 208U);
#line 62
  ah = (struct ipoib_ah *)tmp;
#line 63
  if ((unsigned long )ah == (unsigned long )((struct ipoib_ah *)0)) {
#line 64
    tmp___0 = ERR_PTR(-12L);
#line 64
    return ((struct ipoib_ah *)tmp___0);
  } else {

  }
#line 66
  ah->dev = dev;
#line 67
  ah->last_send = 0U;
#line 68
  kref_init(& ah->ref);
#line 70
  vah = ib_create_ah(pd, attr);
#line 71
  tmp___2 = IS_ERR((void const   *)vah);
#line 71
  if ((int )tmp___2) {
#line 72
    kfree((void const   *)ah);
#line 73
    ah = (struct ipoib_ah *)vah;
  } else {
#line 75
    ah->ah = vah;
#line 76
    if (ipoib_debug_level > 0) {
#line 76
      tmp___1 = netdev_priv((struct net_device  const  *)dev);
#line 76
      printk("\017%s: Created ah %p\n", (char *)(& (((struct ipoib_dev_priv *)tmp___1)->dev)->name),
             ah->ah);
    } else {

    }
  }
#line 79
  return (ah);
}
}
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_free_ah(struct kref *kref ) 
{ 
  struct ipoib_ah *ah ;
  struct kref  const  *__mptr ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;

  {
#line 84
  __mptr = (struct kref  const  *)kref;
#line 84
  ah = (struct ipoib_ah *)__mptr + 0xffffffffffffffe0UL;
#line 85
  tmp = netdev_priv((struct net_device  const  *)ah->dev);
#line 85
  priv = (struct ipoib_dev_priv *)tmp;
#line 89
  tmp___0 = spinlock_check(& priv->lock);
#line 89
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 90
  list_add_tail(& ah->list, & priv->dead_ahs);
#line 91
  spin_unlock_irqrestore(& priv->lock, flags);
#line 92
  return;
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void ipoib_ud_dma_unmap_rx(struct ipoib_dev_priv *priv , u64 *mapping ) 
{ 


  {
#line 97
  ib_dma_unmap_single(priv->ca, *mapping, (size_t )(priv->max_ib_mtu + 40U), 2);
#line 99
  return;
}
}
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static int ipoib_ib_post_receive(struct net_device *dev , int id ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_recv_wr *bad_wr ;
  int ret ;
  long tmp___0 ;

  {
#line 104
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 104
  priv = (struct ipoib_dev_priv *)tmp;
#line 108
  priv->rx_wr.wr_id = (u64 )((unsigned long )id | 2147483648UL);
#line 109
  priv->rx_sge[0].addr = (priv->rx_ring + (unsigned long )id)->mapping[0];
#line 110
  priv->rx_sge[1].addr = (priv->rx_ring + (unsigned long )id)->mapping[1];
#line 113
  ret = ib_post_recv(priv->qp, & priv->rx_wr, & bad_wr);
#line 114
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 114
  if (tmp___0 != 0L) {
#line 115
    printk("\f%s: receive failed for buf %d (%d)\n", (char *)(& (priv->dev)->name),
           id, ret);
#line 116
    ipoib_ud_dma_unmap_rx(priv, (u64 *)(& (priv->rx_ring + (unsigned long )id)->mapping));
#line 117
    dev_kfree_skb_any((priv->rx_ring + (unsigned long )id)->skb);
#line 118
    (priv->rx_ring + (unsigned long )id)->skb = (struct sk_buff *)0;
  } else {

  }
#line 121
  return (ret);
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static struct sk_buff *ipoib_alloc_rx_skb(struct net_device *dev , int id ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct sk_buff *skb ;
  int buf_size ;
  u64 *mapping ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 126
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 126
  priv = (struct ipoib_dev_priv *)tmp;
#line 131
  buf_size = (int )(priv->max_ib_mtu + 40U);
#line 133
  skb = dev_alloc_skb((unsigned int )(buf_size + 4));
#line 134
  tmp___0 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                             0L);
#line 134
  if (tmp___0 != 0L) {
#line 135
    return ((struct sk_buff *)0);
  } else {

  }
#line 142
  skb_reserve(skb, 4);
#line 144
  mapping = (u64 *)(& (priv->rx_ring + (unsigned long )id)->mapping);
#line 145
  *mapping = ib_dma_map_single(priv->ca, (void *)skb->data, (size_t )buf_size, 2);
#line 147
  tmp___1 = ib_dma_mapping_error(priv->ca, *mapping);
#line 147
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 147
  if (tmp___2 != 0L) {
#line 148
    goto error;
  } else {

  }
#line 150
  (priv->rx_ring + (unsigned long )id)->skb = skb;
#line 151
  return (skb);
  error: 
#line 153
  dev_kfree_skb_any(skb);
#line 154
  return ((struct sk_buff *)0);
}
}
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static int ipoib_ib_post_receives(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int i ;
  struct sk_buff *tmp___0 ;
  int tmp___1 ;

  {
#line 159
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 159
  priv = (struct ipoib_dev_priv *)tmp;
#line 162
  i = 0;
#line 162
  goto ldv_53233;
  ldv_53232: 
#line 163
  tmp___0 = ipoib_alloc_rx_skb(dev, i);
#line 163
  if ((unsigned long )tmp___0 == (unsigned long )((struct sk_buff *)0)) {
#line 164
    printk("\f%s: failed to allocate receive buffer %d\n", (char *)(& (priv->dev)->name),
           i);
#line 165
    return (-12);
  } else {

  }
#line 167
  tmp___1 = ipoib_ib_post_receive(dev, i);
#line 167
  if (tmp___1 != 0) {
#line 168
    printk("\f%s: ipoib_ib_post_receive failed for buf %d\n", (char *)(& (priv->dev)->name),
           i);
#line 169
    return (-5);
  } else {

  }
#line 162
  i = i + 1;
  ldv_53233: ;
#line 162
  if (i < ipoib_recvq_size) {
#line 164
    goto ldv_53232;
  } else {

  }

#line 173
  return (0);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void ipoib_ib_handle_rx_wc(struct net_device *dev , struct ib_wc *wc ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned int wr_id ;
  struct sk_buff *skb ;
  u64 mapping[2U] ;
  union ib_gid *dgid ;
  long tmp___0 ;
  long tmp___1 ;
  struct sk_buff *tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;

  {
#line 178
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 178
  priv = (struct ipoib_dev_priv *)tmp;
#line 179
  wr_id = (unsigned int )wc->wr_id & 2147483647U;
#line 184
  if (data_debug_level > 0) {
#line 184
    printk("\017%s: recv completion: id %d, status: %d\n", (char *)(& (priv->dev)->name),
           wr_id, (unsigned int )wc->status);
  } else {

  }
#line 187
  tmp___0 = ldv__builtin_expect((unsigned int )ipoib_recvq_size <= wr_id, 0L);
#line 187
  if (tmp___0 != 0L) {
#line 188
    printk("\f%s: recv completion event with wrid %d (> %d)\n", (char *)(& (priv->dev)->name),
           wr_id, ipoib_recvq_size);
#line 190
    return;
  } else {

  }
#line 193
  skb = (priv->rx_ring + (unsigned long )wr_id)->skb;
#line 195
  tmp___1 = ldv__builtin_expect((unsigned int )wc->status != 0U, 0L);
#line 195
  if (tmp___1 != 0L) {
#line 196
    if ((unsigned int )wc->status != 5U) {
#line 197
      printk("\f%s: failed recv event (status=%d, wrid=%d vend_err %x)\n", (char *)(& (priv->dev)->name),
             (unsigned int )wc->status, wr_id, wc->vendor_err);
    } else {

    }
#line 200
    ipoib_ud_dma_unmap_rx(priv, (u64 *)(& (priv->rx_ring + (unsigned long )wr_id)->mapping));
#line 201
    dev_kfree_skb_any(skb);
#line 202
    (priv->rx_ring + (unsigned long )wr_id)->skb = (struct sk_buff *)0;
#line 203
    return;
  } else {

  }
#line 210
  if ((int )wc->slid == (int )priv->local_lid && wc->src_qp == (priv->qp)->qp_num) {
#line 211
    goto repost;
  } else {

  }
#line 213
  memcpy((void *)(& mapping), (void const   *)(& (priv->rx_ring + (unsigned long )wr_id)->mapping),
           16UL);
#line 220
  tmp___2 = ipoib_alloc_rx_skb(dev, (int )wr_id);
#line 220
  tmp___3 = ldv__builtin_expect((unsigned long )tmp___2 == (unsigned long )((struct sk_buff *)0),
                             0L);
#line 220
  if (tmp___3 != 0L) {
#line 221
    dev->stats.rx_dropped = dev->stats.rx_dropped + 1UL;
#line 222
    goto repost;
  } else {

  }
#line 225
  if (data_debug_level > 0) {
#line 225
    printk("\017%s: received %d bytes, SLID 0x%04x\n", (char *)(& (priv->dev)->name),
           wc->byte_len, (int )wc->slid);
  } else {

  }
#line 228
  ipoib_ud_dma_unmap_rx(priv, (u64 *)(& mapping));
#line 230
  skb_put(skb, wc->byte_len);
#line 233
  dgid = & ((struct ib_grh *)skb->data)->dgid;
#line 235
  if ((wc->wc_flags & 1) == 0 || (unsigned int )dgid->raw[0] != 255U) {
#line 236
    skb->pkt_type = 0U;
  } else {
#line 237
    tmp___4 = memcmp((void const   *)dgid, (void const   *)(& dev->broadcast) + 4U,
                     16UL);
#line 237
    if (tmp___4 == 0) {
#line 238
      skb->pkt_type = 1U;
    } else {
#line 240
      skb->pkt_type = 2U;
    }
  }
#line 242
  skb_pull(skb, 40U);
#line 244
  skb->protocol = ((struct ipoib_header *)skb->data)->proto;
#line 245
  skb_reset_mac_header(skb);
#line 246
  skb_pull(skb, 4U);
#line 248
  skb->truesize = skb->len + 576U;
#line 250
  dev->stats.rx_packets = dev->stats.rx_packets + 1UL;
#line 251
  dev->stats.rx_bytes = dev->stats.rx_bytes + (unsigned long )skb->len;
#line 253
  skb->dev = dev;
#line 254
  if ((dev->features & 17179869184ULL) != 0ULL) {
#line 254
    tmp___5 = ldv__builtin_expect((wc->wc_flags & 8) != 0, 1L);
#line 254
    if (tmp___5 != 0L) {
#line 256
      skb->ip_summed = 1U;
    } else {

    }
  } else {

  }
#line 258
  napi_gro_receive(& priv->napi, skb);
  repost: 
#line 261
  tmp___6 = ipoib_ib_post_receive(dev, (int )wr_id);
#line 261
  tmp___7 = ldv__builtin_expect(tmp___6 != 0, 0L);
#line 261
  if (tmp___7 != 0L) {
#line 262
    printk("\f%s: ipoib_ib_post_receive failed for buf %d\n", (char *)(& (priv->dev)->name),
           wr_id);
  } else {

  }
#line 263
  return;
}
}
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static int ipoib_dma_map_tx(struct ib_device *ca , struct ipoib_tx_buf *tx_req ) 
{ 
  struct sk_buff *skb ;
  u64 *mapping ;
  int i ;
  int off ;
  unsigned int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  skb_frag_t const   *frag ;
  unsigned char *tmp___3 ;
  unsigned int tmp___4 ;
  struct page *tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  unsigned char *tmp___8 ;
  skb_frag_t const   *frag___0 ;
  unsigned char *tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 269
  skb = tx_req->skb;
#line 270
  mapping = (u64 *)(& tx_req->mapping);
#line 274
  tmp___2 = skb_headlen((struct sk_buff  const  *)skb);
#line 274
  if (tmp___2 != 0U) {
#line 275
    tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 275
    *mapping = ib_dma_map_single(ca, (void *)skb->data, (size_t )tmp, 1);
#line 277
    tmp___0 = ib_dma_mapping_error(ca, *mapping);
#line 277
    tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 277
    if (tmp___1 != 0L) {
#line 278
      return (-5);
    } else {

    }
#line 280
    off = 1;
  } else {
#line 282
    off = 0;
  }
#line 284
  i = 0;
#line 284
  goto ldv_53256;
  ldv_53255: 
#line 285
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 285
  frag = (skb_frag_t const   *)(& ((struct skb_shared_info *)tmp___3)->frags) + (unsigned long )i;
#line 286
  tmp___4 = skb_frag_size(frag);
#line 286
  tmp___5 = skb_frag_page(frag);
#line 286
  *(mapping + (unsigned long )(i + off)) = ib_dma_map_page(ca, tmp___5, (unsigned long )frag->page_offset,
                                                           (size_t )tmp___4, 1);
#line 290
  tmp___6 = ib_dma_mapping_error(ca, *(mapping + (unsigned long )(i + off)));
#line 290
  tmp___7 = ldv__builtin_expect(tmp___6 != 0, 0L);
#line 290
  if (tmp___7 != 0L) {
#line 291
    goto partial_error;
  } else {

  }
#line 284
  i = i + 1;
  ldv_53256: 
#line 284
  tmp___8 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 284
  if ((int )((struct skb_shared_info *)tmp___8)->nr_frags > i) {
#line 286
    goto ldv_53255;
  } else {

  }

#line 293
  return (0);
  partial_error: ;
#line 296
  goto ldv_53260;
  ldv_53259: 
#line 297
  tmp___9 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 297
  frag___0 = (skb_frag_t const   *)(& ((struct skb_shared_info *)tmp___9)->frags) + ((unsigned long )i + 0xffffffffffffffffUL);
#line 299
  tmp___10 = skb_frag_size(frag___0);
#line 299
  ib_dma_unmap_page(ca, *(mapping + (unsigned long )(i - (off == 0))), (size_t )tmp___10,
                    1);
#line 296
  i = i - 1;
  ldv_53260: ;
#line 296
  if (i > 0) {
#line 298
    goto ldv_53259;
  } else {

  }

#line 302
  if (off != 0) {
#line 303
    tmp___11 = skb_headlen((struct sk_buff  const  *)skb);
#line 303
    ib_dma_unmap_single(ca, *mapping, (size_t )tmp___11, 1);
  } else {

  }
#line 305
  return (-5);
}
}
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void ipoib_dma_unmap_tx(struct ib_device *ca , struct ipoib_tx_buf *tx_req ) 
{ 
  struct sk_buff *skb ;
  u64 *mapping ;
  int i ;
  int off ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  skb_frag_t const   *frag ;
  unsigned char *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 311
  skb = tx_req->skb;
#line 312
  mapping = (u64 *)(& tx_req->mapping);
#line 316
  tmp___0 = skb_headlen((struct sk_buff  const  *)skb);
#line 316
  if (tmp___0 != 0U) {
#line 317
    tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 317
    ib_dma_unmap_single(ca, *mapping, (size_t )tmp, 1);
#line 318
    off = 1;
  } else {
#line 320
    off = 0;
  }
#line 322
  i = 0;
#line 322
  goto ldv_53272;
  ldv_53271: 
#line 323
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 323
  frag = (skb_frag_t const   *)(& ((struct skb_shared_info *)tmp___1)->frags) + (unsigned long )i;
#line 325
  tmp___2 = skb_frag_size(frag);
#line 325
  ib_dma_unmap_page(ca, *(mapping + (unsigned long )(i + off)), (size_t )tmp___2,
                    1);
#line 322
  i = i + 1;
  ldv_53272: 
#line 322
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 322
  if ((int )((struct skb_shared_info *)tmp___3)->nr_frags > i) {
#line 324
    goto ldv_53271;
  } else {

  }

#line 329
  return;
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void ipoib_qp_state_validate_work(struct work_struct *work ) 
{ 
  struct ipoib_qp_state_validate *qp_work ;
  struct work_struct  const  *__mptr ;
  struct ipoib_dev_priv *priv ;
  struct ib_qp_attr qp_attr ;
  struct ib_qp_init_attr query_init_attr ;
  int ret ;

  {
#line 338
  __mptr = (struct work_struct  const  *)work;
#line 338
  qp_work = (struct ipoib_qp_state_validate *)__mptr;
#line 340
  priv = qp_work->priv;
#line 345
  ret = ib_query_qp(priv->qp, & qp_attr, 1, & query_init_attr);
#line 346
  if (ret != 0) {
#line 347
    printk("\f%s: %s: Failed to query QP ret: %d\n", (char *)(& (priv->dev)->name),
           "ipoib_qp_state_validate_work", ret);
#line 349
    goto free_res;
  } else {

  }
#line 351
  printk("\016%s: QP: 0x%x is in state: %d\n", "ipoib_qp_state_validate_work", (priv->qp)->qp_num,
         (unsigned int )qp_attr.qp_state);
#line 355
  if ((unsigned int )qp_attr.qp_state == 5U) {
#line 356
    qp_attr.qp_state = 3;
#line 358
    ret = ib_modify_qp(priv->qp, & qp_attr, 1);
#line 359
    if (ret != 0) {
#line 360
      printk("\ffailed(%d) modify QP:0x%x SQE->RTS\n", ret, (priv->qp)->qp_num);
#line 362
      goto free_res;
    } else {

    }
#line 364
    printk("\016%s: QP: 0x%x moved from IB_QPS_SQE to IB_QPS_RTS\n", "ipoib_qp_state_validate_work",
           (priv->qp)->qp_num);
  } else {
#line 367
    printk("\fQP (%d) will stay in state: %d\n", (priv->qp)->qp_num, (unsigned int )qp_attr.qp_state);
  }
  free_res: 
#line 372
  kfree((void const   *)qp_work);
#line 373
  return;
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void ipoib_ib_handle_tx_wc(struct net_device *dev , struct ib_wc *wc ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned int wr_id ;
  struct ipoib_tx_buf *tx_req ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  struct ipoib_qp_state_validate *qp_work ;
  void *tmp___4 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 377
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 377
  priv = (struct ipoib_dev_priv *)tmp;
#line 378
  wr_id = (unsigned int )wc->wr_id;
#line 381
  if (data_debug_level > 0) {
#line 381
    printk("\017%s: send completion: id %d, status: %d\n", (char *)(& (priv->dev)->name),
           wr_id, (unsigned int )wc->status);
  } else {

  }
#line 384
  tmp___0 = ldv__builtin_expect((unsigned int )ipoib_sendq_size <= wr_id, 0L);
#line 384
  if (tmp___0 != 0L) {
#line 385
    printk("\f%s: send completion event with wrid %d (> %d)\n", (char *)(& (priv->dev)->name),
           wr_id, ipoib_sendq_size);
#line 387
    return;
  } else {

  }
#line 390
  tx_req = priv->tx_ring + (unsigned long )wr_id;
#line 392
  ipoib_dma_unmap_tx(priv->ca, tx_req);
#line 394
  dev->stats.tx_packets = dev->stats.tx_packets + 1UL;
#line 395
  dev->stats.tx_bytes = dev->stats.tx_bytes + (unsigned long )(tx_req->skb)->len;
#line 397
  dev_kfree_skb_any(tx_req->skb);
#line 399
  priv->tx_tail = priv->tx_tail + 1U;
#line 400
  priv->tx_outstanding = priv->tx_outstanding - 1U;
#line 400
  tmp___1 = ldv__builtin_expect(priv->tx_outstanding == (unsigned int )(ipoib_sendq_size >> 1),
                             0L);
#line 400
  if (tmp___1 != 0L) {
#line 400
    tmp___2 = netif_queue_stopped((struct net_device  const  *)dev);
#line 400
    if ((int )tmp___2) {
#line 400
      tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->flags));
#line 400
      if (tmp___3 != 0) {
#line 403
        netif_wake_queue(dev);
      } else {

      }
    } else {

    }
  } else {

  }
#line 405
  if ((unsigned int )wc->status != 0U && (unsigned int )wc->status != 5U) {
#line 408
    printk("\f%s: failed send event (status=%d, wrid=%d vend_err %x)\n", (char *)(& (priv->dev)->name),
           (unsigned int )wc->status, wr_id, wc->vendor_err);
#line 411
    tmp___4 = kzalloc(88UL, 32U);
#line 411
    qp_work = (struct ipoib_qp_state_validate *)tmp___4;
#line 412
    if ((unsigned long )qp_work == (unsigned long )((struct ipoib_qp_state_validate *)0)) {
#line 413
      printk("\f%s: %s Failed alloc ipoib_qp_state_validate for qp: 0x%x\n", (char *)(& (priv->dev)->name),
             "ipoib_ib_handle_tx_wc", (priv->qp)->qp_num);
#line 415
      return;
    } else {

    }
#line 418
    __init_work(& qp_work->work, 0);
#line 418
    __constr_expr_0.counter = 137438953408L;
#line 418
    qp_work->work.data = __constr_expr_0;
#line 418
    lockdep_init_map(& qp_work->work.lockdep_map, "(&qp_work->work)", & __key, 0);
#line 418
    INIT_LIST_HEAD(& qp_work->work.entry);
#line 418
    qp_work->work.func = & ipoib_qp_state_validate_work;
#line 419
    qp_work->priv = priv;
#line 420
    queue_work___0(priv->wq, & qp_work->work);
  } else {

  }
#line 422
  return;
}
}
#line 424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static int poll_tx(struct ipoib_dev_priv *priv ) 
{ 
  int n ;
  int i ;

  {
#line 428
  n = ib_poll_cq(priv->send_cq, 16, (struct ib_wc *)(& priv->send_wc));
#line 429
  i = 0;
#line 429
  goto ldv_53303;
  ldv_53302: 
#line 430
  ipoib_ib_handle_tx_wc(priv->dev, (struct ib_wc *)(& priv->send_wc) + (unsigned long )i);
#line 429
  i = i + 1;
  ldv_53303: ;
#line 429
  if (i < n) {
#line 431
    goto ldv_53302;
  } else {

  }

#line 432
  return (n == 16);
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
int ipoib_poll(struct napi_struct *napi , int budget ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct napi_struct  const  *__mptr ;
  struct net_device *dev ;
  int done ;
  int t ;
  int n ;
  int i ;
  int max ;
  int _min1 ;
  int _min2 ;
  struct ib_wc *wc ;
  int tmp ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 437
  __mptr = (struct napi_struct  const  *)napi;
#line 437
  priv = (struct ipoib_dev_priv *)__mptr + 0xffffffffffffffb0UL;
#line 438
  dev = priv->dev;
#line 443
  done = 0;
  poll_more: ;
#line 446
  goto ldv_53328;
  ldv_53327: 
#line 447
  max = budget - done;
#line 449
  _min1 = 4;
#line 449
  _min2 = max;
#line 449
  t = _min1 < _min2 ? _min1 : _min2;
#line 450
  n = ib_poll_cq(priv->recv_cq, t, (struct ib_wc *)(& priv->ibwc));
#line 452
  i = 0;
#line 452
  goto ldv_53324;
  ldv_53323: 
#line 453
  wc = (struct ib_wc *)(& priv->ibwc) + (unsigned long )i;
#line 455
  if ((wc->wr_id & 2147483648ULL) != 0ULL) {
#line 456
    done = done + 1;
#line 457
    if ((wc->wr_id & 1073741824ULL) != 0ULL) {
#line 458
      ipoib_cm_handle_rx_wc(dev, wc);
    } else {
#line 460
      ipoib_ib_handle_rx_wc(dev, wc);
    }
  } else {
#line 462
    ipoib_cm_handle_tx_wc(priv->dev, wc);
  }
#line 452
  i = i + 1;
  ldv_53324: ;
#line 452
  if (i < n) {
#line 454
    goto ldv_53323;
  } else {

  }

#line 465
  if (n != t) {
#line 466
    goto ldv_53326;
  } else {

  }
  ldv_53328: ;
#line 446
  if (done < budget) {
#line 448
    goto ldv_53327;
  } else {

  }
  ldv_53326: ;
#line 469
  if (done < budget) {
#line 470
    napi_complete(napi);
#line 471
    tmp = ib_req_notify_cq(priv->recv_cq, 6);
#line 471
    tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 471
    if (tmp___0 != 0L) {
#line 471
      tmp___1 = napi_reschedule(napi);
#line 471
      if ((int )tmp___1) {
#line 475
        goto poll_more;
      } else {

      }
    } else {

    }
  } else {

  }
#line 478
  return (done);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_ib_completion(struct ib_cq *cq , void *dev_ptr ) 
{ 
  struct net_device *dev ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 483
  dev = (struct net_device *)dev_ptr;
#line 484
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 484
  priv = (struct ipoib_dev_priv *)tmp;
#line 486
  napi_schedule(& priv->napi);
#line 487
  return;
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void drain_tx_cq(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 491
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 491
  priv = (struct ipoib_dev_priv *)tmp;
#line 493
  netif_tx_lock___0(dev);
#line 494
  goto ldv_53340;
  ldv_53339: ;
  ldv_53340: 
#line 494
  tmp___0 = poll_tx(priv);
#line 494
  if (tmp___0 != 0) {
#line 496
    goto ldv_53339;
  } else {

  }
#line 497
  tmp___1 = netif_queue_stopped((struct net_device  const  *)dev);
#line 497
  if ((int )tmp___1) {
#line 498
    ldv_mod_timer_54(& priv->poll_timer, (unsigned long )jiffies + 1UL);
  } else {

  }
#line 500
  netif_tx_unlock___0(dev);
#line 501
  return;
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_send_comp_handler(struct ib_cq *cq , void *dev_ptr ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 505
  tmp = netdev_priv((struct net_device  const  *)dev_ptr);
#line 505
  priv = (struct ipoib_dev_priv *)tmp;
#line 507
  ldv_mod_timer_55(& priv->poll_timer, jiffies);
#line 508
  return;
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
__inline static int post_send(struct ipoib_dev_priv *priv , unsigned int wr_id , struct ib_ah *address ,
                              u32 qpn , struct ipoib_tx_buf *tx_req , void *head ,
                              int hlen ) 
{ 
  struct ib_send_wr *bad_wr ;
  int i ;
  int off ;
  struct sk_buff *skb ;
  skb_frag_t *frags ;
  unsigned char *tmp ;
  int nr_frags ;
  unsigned char *tmp___0 ;
  u64 *mapping ;
  unsigned int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;

  {
#line 518
  skb = tx_req->skb;
#line 519
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 519
  frags = (skb_frag_t *)(& ((struct skb_shared_info *)tmp)->frags);
#line 520
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 520
  nr_frags = (int )((struct skb_shared_info *)tmp___0)->nr_frags;
#line 521
  mapping = (u64 *)(& tx_req->mapping);
#line 523
  tmp___1 = skb_headlen((struct sk_buff  const  *)skb);
#line 523
  if (tmp___1 != 0U) {
#line 524
    priv->tx_sge[0].addr = *mapping;
#line 525
    priv->tx_sge[0].length = skb_headlen((struct sk_buff  const  *)skb);
#line 526
    off = 1;
  } else {
#line 528
    off = 0;
  }
#line 530
  i = 0;
#line 530
  goto ldv_53364;
  ldv_53363: 
#line 531
  priv->tx_sge[i + off].addr = *(mapping + (unsigned long )(i + off));
#line 532
  priv->tx_sge[i + off].length = skb_frag_size((skb_frag_t const   *)frags + (unsigned long )i);
#line 530
  i = i + 1;
  ldv_53364: ;
#line 530
  if (i < nr_frags) {
#line 532
    goto ldv_53363;
  } else {

  }
#line 534
  priv->tx_wr.num_sge = nr_frags + off;
#line 535
  priv->tx_wr.wr_id = (u64 )wr_id;
#line 536
  priv->tx_wr.wr.ud.remote_qpn = qpn;
#line 537
  priv->tx_wr.wr.ud.ah = address;
#line 539
  if ((unsigned long )head != (unsigned long )((void *)0)) {
#line 540
    tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 540
    priv->tx_wr.wr.ud.mss = (int )((struct skb_shared_info *)tmp___2)->gso_size;
#line 541
    priv->tx_wr.wr.ud.header = head;
#line 542
    priv->tx_wr.wr.ud.hlen = hlen;
#line 543
    priv->tx_wr.opcode = 7;
  } else {
#line 545
    priv->tx_wr.opcode = 2;
  }
#line 547
  tmp___3 = ib_post_send(priv->qp, & priv->tx_wr, & bad_wr);
#line 547
  return (tmp___3);
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_send(struct net_device *dev , struct sk_buff *skb , struct ipoib_ah *address ,
                u32 qpn ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_tx_buf *tx_req ;
  int hlen ;
  int rc ;
  void *phead ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned char *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;

  {
#line 553
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 553
  priv = (struct ipoib_dev_priv *)tmp;
#line 558
  tmp___5 = skb_is_gso((struct sk_buff  const  *)skb);
#line 558
  if ((int )tmp___5) {
#line 559
    tmp___0 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 559
    tmp___1 = tcp_hdrlen((struct sk_buff  const  *)skb);
#line 559
    hlen = (int )((unsigned int )tmp___0 + tmp___1);
#line 560
    phead = (void *)skb->data;
#line 561
    tmp___2 = skb_pull(skb, (unsigned int )hlen);
#line 561
    tmp___3 = ldv__builtin_expect((unsigned long )tmp___2 == (unsigned long )((unsigned char *)0U),
                               0L);
#line 561
    if (tmp___3 != 0L) {
#line 562
      printk("\f%s: linear data too small\n", (char *)(& (priv->dev)->name));
#line 563
      dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 564
      dev->stats.tx_errors = dev->stats.tx_errors + 1UL;
#line 565
      dev_kfree_skb_any(skb);
#line 566
      return;
    } else {

    }
  } else {
#line 569
    tmp___4 = ldv__builtin_expect(skb->len > priv->mcast_mtu + 4U, 0L);
#line 569
    if (tmp___4 != 0L) {
#line 570
      printk("\f%s: packet len %d (> %d) too long to send, dropping\n", (char *)(& (priv->dev)->name),
             skb->len, priv->mcast_mtu + 4U);
#line 572
      dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 573
      dev->stats.tx_errors = dev->stats.tx_errors + 1UL;
#line 574
      ipoib_cm_skb_too_long(dev, skb, priv->mcast_mtu);
#line 575
      return;
    } else {

    }
#line 577
    phead = (void *)0;
#line 578
    hlen = 0;
  }
#line 581
  if (data_debug_level > 0) {
#line 581
    printk("\017%s: sending packet, length=%d address=%p qpn=0x%06x\n", (char *)(& (priv->dev)->name),
           skb->len, address, qpn);
  } else {

  }
#line 591
  tx_req = priv->tx_ring + (unsigned long )(priv->tx_head & (unsigned int )(ipoib_sendq_size + -1));
#line 592
  tx_req->skb = skb;
#line 593
  tmp___6 = ipoib_dma_map_tx(priv->ca, tx_req);
#line 593
  tmp___7 = ldv__builtin_expect(tmp___6 != 0, 0L);
#line 593
  if (tmp___7 != 0L) {
#line 594
    dev->stats.tx_errors = dev->stats.tx_errors + 1UL;
#line 595
    dev_kfree_skb_any(skb);
#line 596
    return;
  } else {

  }
#line 599
  if ((unsigned int )*((unsigned char *)skb + 145UL) == 6U) {
#line 600
    priv->tx_wr.send_flags = priv->tx_wr.send_flags | 16;
  } else {
#line 602
    priv->tx_wr.send_flags = priv->tx_wr.send_flags & -17;
  }
#line 604
  priv->tx_outstanding = priv->tx_outstanding + 1U;
#line 604
  if (priv->tx_outstanding == (unsigned int )ipoib_sendq_size) {
#line 605
    if (ipoib_debug_level > 0) {
#line 605
      printk("\017%s: TX ring full, stopping kernel net queue\n", (char *)(& (priv->dev)->name));
    } else {

    }
#line 606
    tmp___8 = ib_req_notify_cq(priv->send_cq, 2);
#line 606
    if (tmp___8 != 0) {
#line 607
      printk("\f%s: request notify on send CQ failed\n", (char *)(& (priv->dev)->name));
    } else {

    }
#line 608
    netif_stop_queue(dev);
  } else {

  }
#line 611
  skb_orphan(skb);
#line 612
  skb_dst_drop(skb);
#line 614
  rc = post_send(priv, priv->tx_head & (unsigned int )(ipoib_sendq_size + -1), address->ah,
                 qpn, tx_req, phead, hlen);
#line 616
  tmp___10 = ldv__builtin_expect(rc != 0, 0L);
#line 616
  if (tmp___10 != 0L) {
#line 617
    printk("\f%s: post_send failed, error %d\n", (char *)(& (priv->dev)->name), rc);
#line 618
    dev->stats.tx_errors = dev->stats.tx_errors + 1UL;
#line 619
    priv->tx_outstanding = priv->tx_outstanding - 1U;
#line 620
    ipoib_dma_unmap_tx(priv->ca, tx_req);
#line 621
    dev_kfree_skb_any(skb);
#line 622
    tmp___9 = netif_queue_stopped((struct net_device  const  *)dev);
#line 622
    if ((int )tmp___9) {
#line 623
      netif_wake_queue(dev);
    } else {

    }
  } else {
#line 625
    dev->trans_start = jiffies;
#line 627
    address->last_send = priv->tx_head;
#line 628
    priv->tx_head = priv->tx_head + 1U;
  }
#line 631
  tmp___12 = ldv__builtin_expect(priv->tx_outstanding > 16U, 0L);
#line 631
  if (tmp___12 != 0L) {
#line 632
    goto ldv_53378;
    ldv_53377: ;
    ldv_53378: 
#line 632
    tmp___11 = poll_tx(priv);
#line 632
    if (tmp___11 != 0) {
#line 634
      goto ldv_53377;
    } else {

    }

  } else {

  }
#line 640
  return;
}
}
#line 636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void __ipoib_reap_ah(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_ah *ah ;
  struct ipoib_ah *tah ;
  struct list_head remove_list ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 638
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 638
  priv = (struct ipoib_dev_priv *)tmp;
#line 640
  remove_list.next = & remove_list;
#line 640
  remove_list.prev = & remove_list;
#line 643
  netif_tx_lock_bh___0(dev);
#line 644
  tmp___0 = spinlock_check(& priv->lock);
#line 644
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 646
  __mptr = (struct list_head  const  *)priv->dead_ahs.next;
#line 646
  ah = (struct ipoib_ah *)__mptr + 0xfffffffffffffff0UL;
#line 646
  __mptr___0 = (struct list_head  const  *)ah->list.next;
#line 646
  tah = (struct ipoib_ah *)__mptr___0 + 0xfffffffffffffff0UL;
#line 646
  goto ldv_53398;
  ldv_53397: ;
#line 647
  if ((int )priv->tx_tail - (int )ah->last_send >= 0) {
#line 648
    list_del(& ah->list);
#line 649
    ib_destroy_ah(ah->ah);
#line 650
    kfree((void const   *)ah);
  } else {

  }
#line 646
  ah = tah;
#line 646
  __mptr___1 = (struct list_head  const  *)tah->list.next;
#line 646
  tah = (struct ipoib_ah *)__mptr___1 + 0xfffffffffffffff0UL;
  ldv_53398: ;
#line 646
  if ((unsigned long )(& ah->list) != (unsigned long )(& priv->dead_ahs)) {
#line 648
    goto ldv_53397;
  } else {

  }
#line 653
  spin_unlock_irqrestore(& priv->lock, flags);
#line 654
  netif_tx_unlock_bh___0(dev);
#line 655
  return;
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_reap_ah(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct net_device *dev ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 660
  __mptr = (struct work_struct  const  *)work;
#line 660
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffffa70UL;
#line 661
  dev = priv->dev;
#line 663
  __ipoib_reap_ah(dev);
#line 665
  tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->flags));
#line 665
  if (tmp___0 == 0) {
#line 666
    tmp = round_jiffies_relative(250UL);
#line 666
    queue_delayed_work___0(priv->wq, & priv->ah_reap_task, tmp);
  } else {

  }
#line 668
  return;
}
}
#line 670 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void ipoib_flush_ah(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 672
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 672
  priv = (struct ipoib_dev_priv *)tmp;
#line 674
  ldv_cancel_delayed_work_56(& priv->ah_reap_task);
#line 675
  ldv_flush_workqueue_57(priv->wq);
#line 676
  ipoib_reap_ah(& priv->ah_reap_task.work);
#line 677
  return;
}
}
#line 679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void ipoib_stop_ah(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 681
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 681
  priv = (struct ipoib_dev_priv *)tmp;
#line 683
  set_bit(7L, (unsigned long volatile   *)(& priv->flags));
#line 684
  ipoib_flush_ah(dev);
#line 685
  return;
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void ipoib_ib_tx_timer_func(unsigned long ctx ) 
{ 


  {
#line 689
  drain_tx_cq((struct net_device *)ctx);
#line 690
  return;
}
}
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
int ipoib_ib_dev_open(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int ret ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 694
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 694
  priv = (struct ipoib_dev_priv *)tmp;
#line 697
  ipoib_pkey_dev_check_presence(dev);
#line 699
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->flags));
#line 699
  if (tmp___0 == 0) {
#line 700
    printk("\f%s: P_Key 0x%04x is %s\n", (char *)(& (priv->dev)->name), (int )priv->pkey,
           ((int )priv->pkey & 32767) == 0 ? (char *)"Invalid" : (char *)"not found");
#line 702
    return (-1);
  } else {

  }
#line 705
  ret = ipoib_init_qp(dev);
#line 706
  if (ret != 0) {
#line 707
    printk("\f%s: ipoib_init_qp returned %d\n", (char *)(& (priv->dev)->name), ret);
#line 708
    return (-1);
  } else {

  }
#line 711
  ret = ipoib_ib_post_receives(dev);
#line 712
  if (ret != 0) {
#line 713
    printk("\f%s: ipoib_ib_post_receives returned %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 714
    goto dev_stop;
  } else {

  }
#line 717
  ret = ipoib_cm_dev_open(dev);
#line 718
  if (ret != 0) {
#line 719
    printk("\f%s: ipoib_cm_dev_open returned %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 720
    goto dev_stop;
  } else {

  }
#line 723
  clear_bit(7L, (unsigned long volatile   *)(& priv->flags));
#line 724
  tmp___1 = round_jiffies_relative(250UL);
#line 724
  queue_delayed_work___0(priv->wq, & priv->ah_reap_task, tmp___1);
#line 727
  tmp___2 = test_and_set_bit(1L, (unsigned long volatile   *)(& priv->flags));
#line 727
  if (tmp___2 == 0) {
#line 728
    napi_enable(& priv->napi);
  } else {

  }
#line 730
  return (0);
  dev_stop: 
#line 732
  tmp___3 = test_and_set_bit(1L, (unsigned long volatile   *)(& priv->flags));
#line 732
  if (tmp___3 == 0) {
#line 733
    napi_enable(& priv->napi);
  } else {

  }
#line 734
  ipoib_ib_dev_stop(dev);
#line 735
  return (-1);
}
}
#line 738 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_pkey_dev_check_presence(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;

  {
#line 740
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 740
  priv = (struct ipoib_dev_priv *)tmp;
#line 742
  if (((int )priv->pkey & 32767) == 0) {
#line 745
    clear_bit(3L, (unsigned long volatile   *)(& priv->flags));
  } else {
#line 742
    tmp___0 = ib_find_pkey(priv->ca, (int )priv->port, (int )priv->pkey, & priv->pkey_index);
#line 742
    if (tmp___0 != 0) {
#line 745
      clear_bit(3L, (unsigned long volatile   *)(& priv->flags));
    } else {
#line 747
      set_bit(3L, (unsigned long volatile   *)(& priv->flags));
    }
  }
#line 748
  return;
}
}
#line 750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
int ipoib_ib_dev_up(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 752
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 752
  priv = (struct ipoib_dev_priv *)tmp;
#line 754
  ipoib_pkey_dev_check_presence(dev);
#line 756
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->flags));
#line 756
  if (tmp___0 == 0) {
#line 757
    if (ipoib_debug_level > 0) {
#line 757
      printk("\017%s: PKEY is not assigned.\n", (char *)(& (priv->dev)->name));
    } else {

    }
#line 758
    return (0);
  } else {

  }
#line 761
  set_bit(0L, (unsigned long volatile   *)(& priv->flags));
#line 763
  tmp___1 = ipoib_mcast_start_thread(dev);
#line 763
  return (tmp___1);
}
}
#line 766 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
int ipoib_ib_dev_down(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 768
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 768
  priv = (struct ipoib_dev_priv *)tmp;
#line 770
  if (ipoib_debug_level > 0) {
#line 770
    printk("\017%s: downing ib_dev\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 772
  clear_bit(0L, (unsigned long volatile   *)(& priv->flags));
#line 773
  netif_carrier_off(dev);
#line 775
  ipoib_mcast_stop_thread(dev);
#line 776
  ipoib_mcast_dev_flush(dev);
#line 778
  ipoib_flush_paths(dev);
#line 780
  return (0);
}
}
#line 783 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static int recvs_pending(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int pending ;
  int i ;

  {
#line 785
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 785
  priv = (struct ipoib_dev_priv *)tmp;
#line 786
  pending = 0;
#line 789
  i = 0;
#line 789
  goto ldv_53443;
  ldv_53442: ;
#line 790
  if ((unsigned long )(priv->rx_ring + (unsigned long )i)->skb != (unsigned long )((struct sk_buff *)0)) {
#line 791
    pending = pending + 1;
  } else {

  }
#line 789
  i = i + 1;
  ldv_53443: ;
#line 789
  if (i < ipoib_recvq_size) {
#line 791
    goto ldv_53442;
  } else {

  }

#line 793
  return (pending);
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_drain_cq(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int i ;
  int n ;
  int tmp___0 ;

  {
#line 798
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 798
  priv = (struct ipoib_dev_priv *)tmp;
#line 806
  local_bh_disable();
  ldv_53454: 
#line 809
  n = ib_poll_cq(priv->recv_cq, 4, (struct ib_wc *)(& priv->ibwc));
#line 810
  i = 0;
#line 810
  goto ldv_53452;
  ldv_53451: ;
#line 816
  if ((unsigned int )priv->ibwc[i].status == 0U) {
#line 817
    priv->ibwc[i].status = 5;
  } else {

  }
#line 819
  if ((priv->ibwc[i].wr_id & 2147483648ULL) != 0ULL) {
#line 820
    if ((priv->ibwc[i].wr_id & 1073741824ULL) != 0ULL) {
#line 821
      ipoib_cm_handle_rx_wc(dev, (struct ib_wc *)(& priv->ibwc) + (unsigned long )i);
    } else {
#line 823
      ipoib_ib_handle_rx_wc(dev, (struct ib_wc *)(& priv->ibwc) + (unsigned long )i);
    }
  } else {
#line 825
    ipoib_cm_handle_tx_wc(dev, (struct ib_wc *)(& priv->ibwc) + (unsigned long )i);
  }
#line 810
  i = i + 1;
  ldv_53452: ;
#line 810
  if (i < n) {
#line 812
    goto ldv_53451;
  } else {

  }

#line 827
  if (n == 4) {
#line 829
    goto ldv_53454;
  } else {

  }

#line 829
  goto ldv_53457;
  ldv_53456: ;
  ldv_53457: 
#line 829
  tmp___0 = poll_tx(priv);
#line 829
  if (tmp___0 != 0) {
#line 831
    goto ldv_53456;
  } else {

  }
#line 832
  local_bh_enable();
#line 833
  return;
}
}
#line 835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
int ipoib_ib_dev_stop(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_qp_attr qp_attr ;
  unsigned long begin ;
  struct ipoib_tx_buf *tx_req ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ipoib_rx_buf *rx_req ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 837
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 837
  priv = (struct ipoib_dev_priv *)tmp;
#line 843
  tmp___0 = test_and_clear_bit(1L, (unsigned long volatile   *)(& priv->flags));
#line 843
  if (tmp___0 != 0) {
#line 844
    napi_disable(& priv->napi);
  } else {

  }
#line 846
  ipoib_cm_dev_stop(dev);
#line 852
  qp_attr.qp_state = 6;
#line 853
  tmp___1 = ib_modify_qp(priv->qp, & qp_attr, 1);
#line 853
  if (tmp___1 != 0) {
#line 854
    printk("\f%s: Failed to modify QP to OLD_ERROR state\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 857
  begin = jiffies;
#line 859
  goto ldv_53483;
  ldv_53482: ;
#line 860
  if ((long )((begin - (unsigned long )jiffies) + 1250UL) < 0L) {
#line 861
    tmp___2 = recvs_pending(dev);
#line 861
    printk("\f%s: timing out; %d sends %d receives not completed\n", (char *)(& (priv->dev)->name),
           priv->tx_head - priv->tx_tail, tmp___2);
#line 868
    goto ldv_53474;
    ldv_53473: 
#line 869
    tx_req = priv->tx_ring + (unsigned long )(priv->tx_tail & (unsigned int )(ipoib_sendq_size + -1));
#line 871
    ipoib_dma_unmap_tx(priv->ca, tx_req);
#line 872
    dev_kfree_skb_any(tx_req->skb);
#line 873
    priv->tx_tail = priv->tx_tail + 1U;
#line 874
    priv->tx_outstanding = priv->tx_outstanding - 1U;
    ldv_53474: ;
#line 868
    if ((int )priv->tx_tail - (int )priv->tx_head < 0) {
#line 870
      goto ldv_53473;
    } else {

    }
#line 877
    i = 0;
#line 877
    goto ldv_53479;
    ldv_53478: 
#line 880
    rx_req = priv->rx_ring + (unsigned long )i;
#line 881
    if ((unsigned long )rx_req->skb == (unsigned long )((struct sk_buff *)0)) {
#line 882
      goto ldv_53477;
    } else {

    }
#line 883
    ipoib_ud_dma_unmap_rx(priv, (u64 *)(& (priv->rx_ring + (unsigned long )i)->mapping));
#line 885
    dev_kfree_skb_any(rx_req->skb);
#line 886
    rx_req->skb = (struct sk_buff *)0;
    ldv_53477: 
#line 877
    i = i + 1;
    ldv_53479: ;
#line 877
    if (i < ipoib_recvq_size) {
#line 879
      goto ldv_53478;
    } else {

    }

#line 889
    goto timeout;
  } else {

  }
#line 892
  ipoib_drain_cq(dev);
#line 894
  msleep(1U);
  ldv_53483: ;
#line 859
  if (priv->tx_head != priv->tx_tail) {
#line 861
    goto ldv_53482;
  } else {
#line 859
    tmp___3 = recvs_pending(dev);
#line 859
    if (tmp___3 != 0) {
#line 861
      goto ldv_53482;
    } else {
#line 864
      goto ldv_53484;
    }
  }
  ldv_53484: ;
#line 897
  if (ipoib_debug_level > 0) {
#line 897
    printk("\017%s: All sends and receives done.\n", (char *)(& (priv->dev)->name));
  } else {

  }
  timeout: 
#line 900
  ldv_del_timer_sync_58(& priv->poll_timer);
#line 901
  qp_attr.qp_state = 0;
#line 902
  tmp___4 = ib_modify_qp(priv->qp, & qp_attr, 1);
#line 902
  if (tmp___4 != 0) {
#line 903
    printk("\f%s: Failed to modify QP to RESET state\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 905
  ipoib_flush_ah(dev);
#line 907
  ib_req_notify_cq(priv->recv_cq, 2);
#line 909
  return (0);
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
int ipoib_ib_dev_init(struct net_device *dev , struct ib_device *ca , int port ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 914
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 914
  priv = (struct ipoib_dev_priv *)tmp;
#line 916
  priv->ca = ca;
#line 917
  priv->port = (u8 )port;
#line 918
  priv->qp = (struct ib_qp *)0;
#line 920
  tmp___0 = ipoib_transport_dev_init(dev, ca);
#line 920
  if (tmp___0 != 0) {
#line 921
    printk("\f%s: ipoib_transport_dev_init failed\n", (char *)(& ca->name));
#line 922
    return (-19);
  } else {

  }
#line 925
  reg_timer_15(& priv->poll_timer, & ipoib_ib_tx_timer_func, (unsigned long )dev);
#line 928
  if ((int )dev->flags & 1) {
#line 929
    tmp___1 = ipoib_ib_dev_open(dev);
#line 929
    if (tmp___1 != 0) {
#line 930
      ipoib_transport_dev_cleanup(dev);
#line 931
      return (-19);
    } else {

    }
  } else {

  }
#line 935
  return (0);
}
}
#line 942 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
__inline static int update_parent_pkey(struct ipoib_dev_priv *priv ) 
{ 
  int result ;
  u16 prev_pkey ;

  {
#line 947
  prev_pkey = priv->pkey;
#line 948
  result = ib_query_pkey(priv->ca, (int )priv->port, 0, & priv->pkey);
#line 949
  if (result != 0) {
#line 950
    printk("\f%s: ib_query_pkey port %d failed (ret = %d)\n", (char *)(& (priv->dev)->name),
           (int )priv->port, result);
#line 952
    return (result);
  } else {

  }
#line 955
  priv->pkey = (u16 )((unsigned int )priv->pkey | 32768U);
#line 957
  if ((int )priv->pkey != (int )prev_pkey) {
#line 958
    if (ipoib_debug_level > 0) {
#line 958
      printk("\017%s: pkey changed from 0x%x to 0x%x\n", (char *)(& (priv->dev)->name),
             (int )prev_pkey, (int )priv->pkey);
    } else {

    }
#line 964
    (priv->dev)->broadcast[8] = (unsigned char )((int )priv->pkey >> 8);
#line 965
    (priv->dev)->broadcast[9] = (unsigned char )priv->pkey;
#line 966
    return (0);
  } else {

  }
#line 969
  return (1);
}
}
#line 974 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
__inline static int update_child_pkey(struct ipoib_dev_priv *priv ) 
{ 
  u16 old_index ;
  int tmp ;

  {
#line 976
  old_index = priv->pkey_index;
#line 978
  priv->pkey_index = 0U;
#line 979
  ipoib_pkey_dev_check_presence(priv->dev);
#line 981
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->flags));
#line 981
  if (tmp != 0 && (int )priv->pkey_index == (int )old_index) {
#line 983
    return (1);
  } else {

  }
#line 984
  return (0);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
static void __ipoib_ib_dev_flush(struct ipoib_dev_priv *priv , enum ipoib_flush_level level ) 
{ 
  struct ipoib_dev_priv *cpriv ;
  struct net_device *dev ;
  int result ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 991
  dev = priv->dev;
#line 994
  down_read(& priv->vlan_rwsem);
#line 1000
  __mptr = (struct list_head  const  *)priv->child_intfs.next;
#line 1000
  cpriv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff128UL;
#line 1000
  goto ldv_53512;
  ldv_53511: 
#line 1001
  __ipoib_ib_dev_flush(cpriv, level);
#line 1000
  __mptr___0 = (struct list_head  const  *)cpriv->list.next;
#line 1000
  cpriv = (struct ipoib_dev_priv *)__mptr___0 + 0xfffffffffffff128UL;
  ldv_53512: ;
#line 1000
  if ((unsigned long )(& cpriv->list) != (unsigned long )(& priv->child_intfs)) {
#line 1002
    goto ldv_53511;
  } else {

  }
#line 1003
  up_read(& priv->vlan_rwsem);
#line 1005
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& priv->flags));
#line 1005
  if (tmp == 0 && (unsigned int )level != 2U) {
#line 1007
    if (ipoib_debug_level > 0) {
#line 1007
      printk("\017%s: Not flushing - IPOIB_FLAG_INITIALIZED not set.\n", (char *)(& (priv->dev)->name));
    } else {

    }
#line 1008
    return;
  } else {

  }
#line 1011
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->flags));
#line 1011
  if (tmp___1 == 0) {
#line 1013
    if ((unsigned int )level == 2U) {
#line 1014
      tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->flags));
#line 1014
      if (tmp___0 == 0) {
#line 1015
        update_parent_pkey(priv);
      } else {
#line 1017
        update_child_pkey(priv);
      }
    } else {

    }
#line 1019
    if (ipoib_debug_level > 0) {
#line 1019
      printk("\017%s: Not flushing - IPOIB_FLAG_ADMIN_UP not set.\n", (char *)(& (priv->dev)->name));
    } else {

    }
#line 1020
    return;
  } else {

  }
#line 1023
  if ((unsigned int )level == 2U) {
#line 1027
    tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->flags));
#line 1027
    if (tmp___2 != 0) {
#line 1028
      result = update_child_pkey(priv);
#line 1029
      if (result != 0) {
#line 1031
        if (ipoib_debug_level > 0) {
#line 1031
          printk("\017%s: Not flushing - P_Key index not changed.\n", (char *)(& (priv->dev)->name));
        } else {

        }
#line 1032
        return;
      } else {

      }
    } else {
#line 1036
      result = update_parent_pkey(priv);
#line 1038
      if (result != 0) {
#line 1039
        if (ipoib_debug_level > 0) {
#line 1039
          printk("\017%s: Not flushing - P_Key value not changed.\n", (char *)(& (priv->dev)->name));
        } else {

        }
#line 1040
        return;
      } else {

      }
    }
  } else {

  }
#line 1045
  if ((unsigned int )level == 0U) {
#line 1046
    ipoib_mark_paths_invalid(dev);
#line 1047
    ipoib_mcast_dev_flush(dev);
#line 1048
    ipoib_flush_ah(dev);
  } else {

  }
#line 1051
  if ((unsigned int )level != 0U) {
#line 1052
    ipoib_ib_dev_down(dev);
  } else {

  }
#line 1054
  if ((unsigned int )level == 2U) {
#line 1055
    tmp___3 = constant_test_bit(1L, (unsigned long const volatile   *)(& priv->flags));
#line 1055
    if (tmp___3 != 0) {
#line 1056
      ipoib_ib_dev_stop(dev);
    } else {

    }
#line 1057
    tmp___4 = ipoib_ib_dev_open(dev);
#line 1057
    if (tmp___4 != 0) {
#line 1058
      return;
    } else {

    }
#line 1059
    tmp___5 = netif_queue_stopped((struct net_device  const  *)dev);
#line 1059
    if ((int )tmp___5) {
#line 1060
      netif_start_queue(dev);
    } else {

    }
  } else {

  }
#line 1067
  tmp___6 = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->flags));
#line 1067
  if (tmp___6 != 0) {
#line 1068
    if ((unsigned int )level != 0U) {
#line 1069
      ipoib_ib_dev_up(dev);
    } else {

    }
#line 1070
    ipoib_mcast_restart_task(& priv->restart_task);
  } else {

  }
#line 1072
  return;
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_ib_dev_flush_light(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
#line 1077
  __mptr = (struct work_struct  const  *)work;
#line 1077
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffffbb0UL;
#line 1079
  __ipoib_ib_dev_flush(priv, 0);
#line 1080
  return;
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_ib_dev_flush_normal(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
#line 1085
  __mptr = (struct work_struct  const  *)work;
#line 1085
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffffb60UL;
#line 1087
  __ipoib_ib_dev_flush(priv, 1);
#line 1088
  return;
}
}
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_ib_dev_flush_heavy(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
#line 1093
  __mptr = (struct work_struct  const  *)work;
#line 1093
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffffb10UL;
#line 1095
  __ipoib_ib_dev_flush(priv, 2);
#line 1096
  return;
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.c"
void ipoib_ib_dev_cleanup(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 1100
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1100
  priv = (struct ipoib_dev_priv *)tmp;
#line 1102
  if (ipoib_debug_level > 0) {
#line 1102
    printk("\017%s: cleaning up ib_dev\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 1107
  ipoib_flush_paths(dev);
#line 1109
  ipoib_mcast_stop_thread(dev);
#line 1110
  ipoib_mcast_dev_flush(dev);
#line 1118
  ipoib_stop_ah(dev);
#line 1120
  ipoib_transport_dev_cleanup(dev);
#line 1121
  return;
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void work_init_9(void) 
{ 


  {
#line 300
  ldv_work_9_0 = 0;
#line 301
  ldv_work_9_1 = 0;
#line 302
  ldv_work_9_2 = 0;
#line 303
  ldv_work_9_3 = 0;
#line 304
  return;
}
}
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void activate_suitable_timer_15(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 308
  if (ldv_timer_15_0 == 0 || ldv_timer_15_0 == 2) {
#line 309
    ldv_timer_list_15_0 = timer;
#line 310
    ldv_timer_list_15_0->data = data;
#line 311
    ldv_timer_15_0 = 1;
#line 312
    return;
  } else {

  }
#line 314
  if (ldv_timer_15_1 == 0 || ldv_timer_15_1 == 2) {
#line 315
    ldv_timer_list_15_1 = timer;
#line 316
    ldv_timer_list_15_1->data = data;
#line 317
    ldv_timer_15_1 = 1;
#line 318
    return;
  } else {

  }
#line 320
  if (ldv_timer_15_2 == 0 || ldv_timer_15_2 == 2) {
#line 321
    ldv_timer_list_15_2 = timer;
#line 322
    ldv_timer_list_15_2->data = data;
#line 323
    ldv_timer_15_2 = 1;
#line 324
    return;
  } else {

  }
#line 326
  if (ldv_timer_15_3 == 0 || ldv_timer_15_3 == 2) {
#line 327
    ldv_timer_list_15_3 = timer;
#line 328
    ldv_timer_list_15_3->data = data;
#line 329
    ldv_timer_15_3 = 1;
#line 330
    return;
  } else {

  }
#line 332
  return;
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
int reg_timer_15(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 337
  if ((unsigned long )function == (unsigned long )(& ipoib_ib_tx_timer_func)) {
#line 338
    activate_suitable_timer_15(timer, data);
  } else {

  }
#line 339
  return (0);
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void call_and_disable_all_9(int state ) 
{ 


  {
#line 345
  if (ldv_work_9_0 == state) {
#line 346
    call_and_disable_work_9(ldv_work_struct_9_0);
  } else {

  }
#line 347
  if (ldv_work_9_1 == state) {
#line 348
    call_and_disable_work_9(ldv_work_struct_9_1);
  } else {

  }
#line 349
  if (ldv_work_9_2 == state) {
#line 350
    call_and_disable_work_9(ldv_work_struct_9_2);
  } else {

  }
#line 351
  if (ldv_work_9_3 == state) {
#line 352
    call_and_disable_work_9(ldv_work_struct_9_3);
  } else {

  }
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 357
  if ((unsigned long )ldv_timer_list_15_0 == (unsigned long )timer) {
#line 358
    if (ldv_timer_15_0 == 2 || pending_flag != 0) {
#line 359
      ldv_timer_list_15_0 = timer;
#line 360
      ldv_timer_list_15_0->data = data;
#line 361
      ldv_timer_15_0 = 1;
    } else {

    }
#line 363
    return;
  } else {

  }
#line 366
  if ((unsigned long )ldv_timer_list_15_1 == (unsigned long )timer) {
#line 367
    if (ldv_timer_15_1 == 2 || pending_flag != 0) {
#line 368
      ldv_timer_list_15_1 = timer;
#line 369
      ldv_timer_list_15_1->data = data;
#line 370
      ldv_timer_15_1 = 1;
    } else {

    }
#line 372
    return;
  } else {

  }
#line 375
  if ((unsigned long )ldv_timer_list_15_2 == (unsigned long )timer) {
#line 376
    if (ldv_timer_15_2 == 2 || pending_flag != 0) {
#line 377
      ldv_timer_list_15_2 = timer;
#line 378
      ldv_timer_list_15_2->data = data;
#line 379
      ldv_timer_15_2 = 1;
    } else {

    }
#line 381
    return;
  } else {

  }
#line 384
  if ((unsigned long )ldv_timer_list_15_3 == (unsigned long )timer) {
#line 385
    if (ldv_timer_15_3 == 2 || pending_flag != 0) {
#line 386
      ldv_timer_list_15_3 = timer;
#line 387
      ldv_timer_list_15_3->data = data;
#line 388
      ldv_timer_15_3 = 1;
    } else {

    }
#line 390
    return;
  } else {

  }
#line 392
  activate_suitable_timer_15(timer, data);
#line 393
  return;
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void invoke_work_9(void) 
{ 
  int tmp ;

  {
#line 398
  tmp = __VERIFIER_nondet_int();
#line 398
  switch (tmp) {
  case 0: ;
#line 400
  if (ldv_work_9_0 == 2 || ldv_work_9_0 == 3) {
#line 401
    ldv_work_9_0 = 4;
#line 402
    ipoib_qp_state_validate_work(ldv_work_struct_9_0);
#line 403
    ldv_work_9_0 = 1;
  } else {

  }
#line 406
  goto ldv_53563;
  case 1: ;
#line 408
  if (ldv_work_9_1 == 2 || ldv_work_9_1 == 3) {
#line 409
    ldv_work_9_1 = 4;
#line 410
    ipoib_qp_state_validate_work(ldv_work_struct_9_0);
#line 411
    ldv_work_9_1 = 1;
  } else {

  }
#line 414
  goto ldv_53563;
  case 2: ;
#line 416
  if (ldv_work_9_2 == 2 || ldv_work_9_2 == 3) {
#line 417
    ldv_work_9_2 = 4;
#line 418
    ipoib_qp_state_validate_work(ldv_work_struct_9_0);
#line 419
    ldv_work_9_2 = 1;
  } else {

  }
#line 422
  goto ldv_53563;
  case 3: ;
#line 424
  if (ldv_work_9_3 == 2 || ldv_work_9_3 == 3) {
#line 425
    ldv_work_9_3 = 4;
#line 426
    ipoib_qp_state_validate_work(ldv_work_struct_9_0);
#line 427
    ldv_work_9_3 = 1;
  } else {

  }
#line 430
  goto ldv_53563;
  default: 
#line 431
  ldv_stop();
  }
  ldv_53563: ;
#line 433
  return;
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void activate_work_9(struct work_struct *work , int state ) 
{ 


  {
#line 438
  if (ldv_work_9_0 == 0) {
#line 439
    ldv_work_struct_9_0 = work;
#line 440
    ldv_work_9_0 = state;
#line 441
    return;
  } else {

  }
#line 444
  if (ldv_work_9_1 == 0) {
#line 445
    ldv_work_struct_9_1 = work;
#line 446
    ldv_work_9_1 = state;
#line 447
    return;
  } else {

  }
#line 450
  if (ldv_work_9_2 == 0) {
#line 451
    ldv_work_struct_9_2 = work;
#line 452
    ldv_work_9_2 = state;
#line 453
    return;
  } else {

  }
#line 456
  if (ldv_work_9_3 == 0) {
#line 457
    ldv_work_struct_9_3 = work;
#line 458
    ldv_work_9_3 = state;
#line 459
    return;
  } else {

  }
#line 461
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void choose_timer_15(void) 
{ 
  int tmp ;

  {
#line 465
  tmp = __VERIFIER_nondet_int();
#line 465
  switch (tmp) {
  case 0: ;
#line 467
  if (ldv_timer_15_0 == 1) {
#line 468
    ldv_timer_15_0 = 2;
#line 469
    ldv_timer_15(ldv_timer_15_0, ldv_timer_list_15_0);
  } else {

  }
#line 472
  goto ldv_53576;
  case 1: ;
#line 474
  if (ldv_timer_15_1 == 1) {
#line 475
    ldv_timer_15_1 = 2;
#line 476
    ldv_timer_15(ldv_timer_15_1, ldv_timer_list_15_1);
  } else {

  }
#line 479
  goto ldv_53576;
  case 2: ;
#line 481
  if (ldv_timer_15_2 == 1) {
#line 482
    ldv_timer_15_2 = 2;
#line 483
    ldv_timer_15(ldv_timer_15_2, ldv_timer_list_15_2);
  } else {

  }
#line 486
  goto ldv_53576;
  case 3: ;
#line 488
  if (ldv_timer_15_3 == 1) {
#line 489
    ldv_timer_15_3 = 2;
#line 490
    ldv_timer_15(ldv_timer_15_3, ldv_timer_list_15_3);
  } else {

  }
#line 493
  goto ldv_53576;
  default: 
#line 494
  ldv_stop();
  }
  ldv_53576: ;
#line 496
  return;
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void timer_init_15(void) 
{ 


  {
#line 501
  ldv_timer_15_0 = 0;
#line 502
  ldv_timer_15_1 = 0;
#line 503
  ldv_timer_15_2 = 0;
#line 504
  ldv_timer_15_3 = 0;
#line 505
  return;
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void call_and_disable_work_9(struct work_struct *work ) 
{ 


  {
#line 511
  if ((ldv_work_9_0 == 2 || ldv_work_9_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_0) {
#line 513
    ipoib_qp_state_validate_work(work);
#line 514
    ldv_work_9_0 = 1;
#line 515
    return;
  } else {

  }
#line 517
  if ((ldv_work_9_1 == 2 || ldv_work_9_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_1) {
#line 519
    ipoib_qp_state_validate_work(work);
#line 520
    ldv_work_9_1 = 1;
#line 521
    return;
  } else {

  }
#line 523
  if ((ldv_work_9_2 == 2 || ldv_work_9_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_2) {
#line 525
    ipoib_qp_state_validate_work(work);
#line 526
    ldv_work_9_2 = 1;
#line 527
    return;
  } else {

  }
#line 529
  if ((ldv_work_9_3 == 2 || ldv_work_9_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_3) {
#line 531
    ipoib_qp_state_validate_work(work);
#line 532
    ldv_work_9_3 = 1;
#line 533
    return;
  } else {

  }
#line 535
  return;
}
}
#line 538 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void ldv_timer_15(int state , struct timer_list *timer ) 
{ 


  {
#line 539
  LDV_IN_INTERRUPT = 2;
#line 540
  ipoib_ib_tx_timer_func(timer->data);
#line 541
  LDV_IN_INTERRUPT = 1;
#line 542
  return;
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void disable_work_9(struct work_struct *work ) 
{ 


  {
#line 547
  if ((ldv_work_9_0 == 3 || ldv_work_9_0 == 2) && (unsigned long )ldv_work_struct_9_0 == (unsigned long )work) {
#line 549
    ldv_work_9_0 = 1;
  } else {

  }
#line 551
  if ((ldv_work_9_1 == 3 || ldv_work_9_1 == 2) && (unsigned long )ldv_work_struct_9_1 == (unsigned long )work) {
#line 553
    ldv_work_9_1 = 1;
  } else {

  }
#line 555
  if ((ldv_work_9_2 == 3 || ldv_work_9_2 == 2) && (unsigned long )ldv_work_struct_9_2 == (unsigned long )work) {
#line 557
    ldv_work_9_2 = 1;
  } else {

  }
#line 559
  if ((ldv_work_9_3 == 3 || ldv_work_9_3 == 2) && (unsigned long )ldv_work_struct_9_3 == (unsigned long )work) {
#line 561
    ldv_work_9_3 = 1;
  } else {

  }
#line 562
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void disable_suitable_timer_15(struct timer_list *timer ) 
{ 


  {
#line 567
  if (ldv_timer_15_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_0) {
#line 568
    ldv_timer_15_0 = 0;
#line 569
    return;
  } else {

  }
#line 571
  if (ldv_timer_15_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_1) {
#line 572
    ldv_timer_15_1 = 0;
#line 573
    return;
  } else {

  }
#line 575
  if (ldv_timer_15_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_2) {
#line 576
    ldv_timer_15_2 = 0;
#line 577
    return;
  } else {

  }
#line 579
  if (ldv_timer_15_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_3) {
#line 580
    ldv_timer_15_3 = 0;
#line 581
    return;
  } else {

  }
#line 583
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 614
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 614
  ldv_func_res = tmp;
#line 616
  activate_work_11(ldv_func_arg3, 2);
#line 618
  return (ldv_func_res);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
bool ldv_queue_delayed_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 625
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 625
  ldv_func_res = tmp;
#line 627
  activate_work_11(& ldv_func_arg3->work, 2);
#line 629
  return (ldv_func_res);
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 636
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 636
  ldv_func_res = tmp;
#line 638
  activate_work_11(ldv_func_arg3, 2);
#line 640
  return (ldv_func_res);
}
}
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void ldv_flush_workqueue_52(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 646
  flush_workqueue(ldv_func_arg1);
#line 648
  call_and_disable_all_11(2);
#line 649
  return;
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
bool ldv_queue_delayed_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 655
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 655
  ldv_func_res = tmp;
#line 657
  activate_work_11(& ldv_func_arg3->work, 2);
#line 659
  return (ldv_func_res);
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
int ldv_mod_timer_54(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 666
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 666
  ldv_func_res = tmp;
#line 668
  activate_pending_timer_15(ldv_func_arg1, ldv_func_arg2, 1);
#line 670
  return (ldv_func_res);
}
}
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
int ldv_mod_timer_55(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 677
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 677
  ldv_func_res = tmp;
#line 679
  activate_pending_timer_15(ldv_func_arg1, ldv_func_arg2, 1);
#line 681
  return (ldv_func_res);
}
}
#line 684 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
bool ldv_cancel_delayed_work_56(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  bool tmp ;

  {
#line 688
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 688
  ldv_func_res = tmp;
#line 690
  disable_work_11(& ldv_func_arg1->work);
#line 692
  return (ldv_func_res);
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
void ldv_flush_workqueue_57(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 698
  flush_workqueue(ldv_func_arg1);
#line 700
  call_and_disable_all_11(2);
#line 701
  return;
}
}
#line 703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ib.o.c.prepared"
int ldv_del_timer_sync_58(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 707
  tmp = del_timer_sync(ldv_func_arg1);
#line 707
  ldv_func_res = tmp;
#line 709
  disable_suitable_timer_15(ldv_func_arg1);
#line 711
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 369 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
long ldv_ptr_err(void const   *ptr ) ;
#line 112 "include/linux/list.h"
extern void __list_del_entry(struct list_head * ) ;
#line 165 "include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 168
  __list_del_entry(list);
#line 169
  list_add_tail(list, head);
#line 170
  return;
}
}
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
#line 831
    goto ldv_4860;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 834 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_restore(unsigned long f ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 836
  __edi = __edi;
#line 836
  __esi = __esi;
#line 836
  __edx = __edx;
#line 836
  __ecx = __ecx;
#line 836
  __eax = __eax;
#line 836
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0),
                         0L);
#line 836
  if (tmp != 0L) {
#line 836
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (836), "i" (12UL));
    ldv_4870: ;
#line 836
    goto ldv_4870;
  } else {

  }
#line 836
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
#line 838
  return;
}
}
#line 839 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_disable(void) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 841
  __edi = __edi;
#line 841
  __esi = __esi;
#line 841
  __edx = __edx;
#line 841
  __ecx = __ecx;
#line 841
  __eax = __eax;
#line 841
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0),
                         0L);
#line 841
  if (tmp != 0L) {
#line 841
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (841), "i" (12UL));
    ldv_4879: ;
#line 841
    goto ldv_4879;
  } else {

  }
#line 841
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 843
  return;
}
}
#line 849 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_irq_save(void) 
{ 
  unsigned long f ;

  {
#line 853
  f = arch_local_save_flags();
#line 854
  arch_local_irq_disable();
#line 855
  return (f);
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 50
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) ;
#line 151 "./arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 153
  return ((flags & 512UL) == 0UL);
}
}
#line 20 "include/linux/irqflags.h"
extern void trace_hardirqs_on(void) ;
#line 21
extern void trace_hardirqs_off(void) ;
#line 77 "include/linux/rbtree.h"
extern void rb_replace_node(struct rb_node * , struct rb_node * , struct rb_root * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_73(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_74(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_76(struct workqueue_struct *ldv_func_arg1 ) ;
#line 459
void ldv_flush_workqueue_81(struct workqueue_struct *ldv_func_arg1 ) ;
#line 474
bool ldv_cancel_delayed_work_78(struct delayed_work *ldv_func_arg1 ) ;
#line 478
bool ldv_cancel_delayed_work_79(struct delayed_work *ldv_func_arg1 ) ;
#line 482
bool ldv_cancel_delayed_work_80(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___1(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_73(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work___1(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                            unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_74(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 41 "include/linux/kref.h"
__inline static void kref_get___0(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub___0(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put___0(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub___0(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 1011 "include/linux/skbuff.h"
__inline static int skb_queue_empty(struct sk_buff_head  const  *list ) 
{ 


  {
#line 1013
  return ((unsigned long )((struct sk_buff  const  *)list->next) == (unsigned long )((struct sk_buff  const  *)list));
}
}
#line 1508
extern void skb_queue_tail(struct sk_buff_head * , struct sk_buff * ) ;
#line 1540
extern struct sk_buff *skb_dequeue(struct sk_buff_head * ) ;
#line 3047 "include/linux/netdevice.h"
extern void netif_carrier_on(struct net_device * ) ;
#line 3214 "include/linux/netdevice.h"
__inline static void netif_tx_lock___1(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3219
  spin_lock(& dev->tx_global_lock);
#line 3220
  __vpp_verify = (void const   *)0;
#line 3220
  switch (4UL) {
  case 1UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43336;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43336;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43336;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_43336;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43336: 
#line 3220
  pscr_ret__ = pfo_ret__;
#line 3220
  goto ldv_43342;
  case 2UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43346;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43346;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43346;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_43346;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43346: 
#line 3220
  pscr_ret__ = pfo_ret_____0;
#line 3220
  goto ldv_43342;
  case 4UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43355;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43355;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43355;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_43355;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43355: 
#line 3220
  pscr_ret__ = pfo_ret_____1;
#line 3220
  goto ldv_43342;
  case 8UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43364;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43364;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43364;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_43364;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_43364: 
#line 3220
  pscr_ret__ = pfo_ret_____2;
#line 3220
  goto ldv_43342;
  default: 
#line 3220
  __bad_size_call_parameter();
#line 3220
  goto ldv_43342;
  }
  ldv_43342: 
#line 3220
  cpu = pscr_ret__;
#line 3221
  i = 0U;
#line 3221
  goto ldv_43374;
  ldv_43373: 
#line 3222
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3222
  txq = tmp;
#line 3230
  __netif_tx_lock(txq, cpu);
#line 3231
  set_bit(2L, (unsigned long volatile   *)(& txq->state));
#line 3232
  __netif_tx_unlock(txq);
#line 3221
  i = i + 1U;
  ldv_43374: ;
#line 3221
  if (dev->num_tx_queues > i) {
#line 3223
    goto ldv_43373;
  } else {

  }

#line 3228
  return;
}
}
#line 3236 "include/linux/netdevice.h"
__inline static void netif_tx_lock_bh___1(struct net_device *dev ) 
{ 


  {
#line 3238
  local_bh_disable();
#line 3239
  netif_tx_lock___1(dev);
#line 3240
  return;
}
}
#line 3242 "include/linux/netdevice.h"
__inline static void netif_tx_unlock___1(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3246
  i = 0U;
#line 3246
  goto ldv_43385;
  ldv_43384: 
#line 3247
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3247
  txq = tmp;
#line 3253
  clear_bit(2L, (unsigned long volatile   *)(& txq->state));
#line 3254
  netif_schedule_queue(txq);
#line 3246
  i = i + 1U;
  ldv_43385: ;
#line 3246
  if (dev->num_tx_queues > i) {
#line 3248
    goto ldv_43384;
  } else {

  }
#line 3256
  spin_unlock(& dev->tx_global_lock);
#line 3257
  return;
}
}
#line 3259 "include/linux/netdevice.h"
__inline static void netif_tx_unlock_bh___1(struct net_device *dev ) 
{ 


  {
#line 3261
  netif_tx_unlock___1(dev);
#line 3262
  local_bh_enable();
#line 3263
  return;
}
}
#line 3299 "include/linux/netdevice.h"
__inline static void netif_addr_lock(struct net_device *dev ) 
{ 


  {
#line 3301
  spin_lock(& dev->addr_list_lock);
#line 3302
  return;
}
}
#line 3319 "include/linux/netdevice.h"
__inline static void netif_addr_unlock(struct net_device *dev ) 
{ 


  {
#line 3321
  spin_unlock(& dev->addr_list_lock);
#line 3322
  return;
}
}
#line 29 "include/linux/rtnetlink.h"
extern int rtnl_trylock(void) ;
#line 2983 "include/rdma/ib_verbs.h"
extern int ib_detach_mcast(struct ib_qp * , union ib_gid * , u16  ) ;
#line 358 "include/rdma/ib_sa.h"
extern struct ib_sa_multicast *ib_sa_join_multicast(struct ib_sa_client * , struct ib_device * ,
                                                    u8  , struct ib_sa_mcmember_rec * ,
                                                    ib_sa_comp_mask  , gfp_t  , int (*)(int  ,
                                                                                        struct ib_sa_multicast * ) ,
                                                    void * ) ;
#line 377
extern void ib_sa_free_multicast(struct ib_sa_multicast * ) ;
#line 388
extern int ib_sa_get_mcmember_rec(struct ib_device * , u8  , union ib_gid * , struct ib_sa_mcmember_rec * ) ;
#line 464 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static void ipoib_put_ah___0(struct ipoib_ah *ah ) 
{ 


  {
#line 466
  kref_put___0(& ah->ref, & ipoib_free_ah);
#line 467
  return;
}
}
#line 508
struct ipoib_mcast_iter *ipoib_mcast_iter_init(struct net_device *dev ) ;
#line 509
int ipoib_mcast_iter_next(struct ipoib_mcast_iter *iter ) ;
#line 510
void ipoib_mcast_iter_read(struct ipoib_mcast_iter *iter , union ib_gid *mgid , unsigned long *created ,
                           unsigned int *queuelen , unsigned int *complete___0 , unsigned int *send_only ) ;
#line 523
int ipoib_mcast_attach(struct net_device *dev , u16 mlid , union ib_gid *mgid , int set_qkey ) ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static int mcast_debug_level  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static void __ipoib_mcast_schedule_join_thread(struct ipoib_dev_priv *priv , struct ipoib_mcast *mcast ,
                                               bool delay ) 
{ 
  int tmp ;

  {
#line 74
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->flags));
#line 74
  if (tmp == 0) {
#line 75
    return;
  } else {

  }
#line 81
  ldv_cancel_delayed_work_78(& priv->mcast_task);
#line 82
  if ((unsigned long )mcast != (unsigned long )((struct ipoib_mcast *)0) && (int )delay) {
#line 86
    mcast->backoff = mcast->backoff * 2UL;
#line 87
    if (mcast->backoff > 16UL) {
#line 88
      mcast->backoff = 16UL;
    } else {

    }
#line 89
    mcast->delay_until = mcast->backoff * 250UL + (unsigned long )jiffies;
#line 97
    queue_delayed_work___1(priv->wq, & priv->mcast_task, 0UL);
  } else
#line 98
  if ((int )delay) {
#line 104
    queue_delayed_work___1(priv->wq, & priv->mcast_task, 250UL);
  } else {
#line 106
    queue_delayed_work___1(priv->wq, & priv->mcast_task, 0UL);
  }
#line 107
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static void ipoib_mcast_free(struct ipoib_mcast *mcast ) 
{ 
  struct net_device *dev ;
  int tx_dropped ;
  void *tmp ;
  struct sk_buff *tmp___0 ;
  int tmp___1 ;

  {
#line 111
  dev = mcast->dev;
#line 112
  tx_dropped = 0;
#line 114
  if (mcast_debug_level > 0) {
#line 114
    tmp = netdev_priv((struct net_device  const  *)dev);
#line 114
    printk("\017%s: deleting multicast group %pI6\n", (char *)(& (((struct ipoib_dev_priv *)tmp)->dev)->name),
           (u8 *)(& mcast->mcmember.mgid.raw));
  } else {

  }
#line 118
  ipoib_del_neighs_by_gid(dev, (u8 *)(& mcast->mcmember.mgid.raw));
#line 120
  if ((unsigned long )mcast->ah != (unsigned long )((struct ipoib_ah *)0)) {
#line 121
    ipoib_put_ah___0(mcast->ah);
  } else {

  }
#line 123
  goto ldv_50337;
  ldv_50336: 
#line 124
  tx_dropped = tx_dropped + 1;
#line 125
  tmp___0 = skb_dequeue(& mcast->pkt_queue);
#line 125
  dev_kfree_skb_any(tmp___0);
  ldv_50337: 
#line 123
  tmp___1 = skb_queue_empty((struct sk_buff_head  const  *)(& mcast->pkt_queue));
#line 123
  if (tmp___1 == 0) {
#line 125
    goto ldv_50336;
  } else {

  }
#line 128
  netif_tx_lock_bh___1(dev);
#line 129
  dev->stats.tx_dropped = dev->stats.tx_dropped + (unsigned long )tx_dropped;
#line 130
  netif_tx_unlock_bh___1(dev);
#line 132
  kfree((void const   *)mcast);
#line 133
  return;
}
}
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static struct ipoib_mcast *ipoib_mcast_alloc(struct net_device *dev , int can_sleep ) 
{ 
  struct ipoib_mcast *mcast ;
  void *tmp ;

  {
#line 140
  tmp = kzalloc(376UL, can_sleep != 0 ? 208U : 32U);
#line 140
  mcast = (struct ipoib_mcast *)tmp;
#line 141
  if ((unsigned long )mcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 142
    return ((struct ipoib_mcast *)0);
  } else {

  }
#line 144
  mcast->dev = dev;
#line 145
  mcast->created = jiffies;
#line 146
  mcast->delay_until = jiffies;
#line 147
  mcast->backoff = 1UL;
#line 149
  INIT_LIST_HEAD(& mcast->list);
#line 150
  INIT_LIST_HEAD(& mcast->neigh_list);
#line 151
  skb_queue_head_init(& mcast->pkt_queue);
#line 153
  return (mcast);
}
}
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static struct ipoib_mcast *__ipoib_mcast_find(struct net_device *dev , void *mgid ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct rb_node *n ;
  struct ipoib_mcast *mcast ;
  int ret ;
  struct rb_node  const  *__mptr ;

  {
#line 158
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 158
  priv = (struct ipoib_dev_priv *)tmp;
#line 159
  n = priv->multicast_tree.rb_node;
#line 161
  goto ldv_50355;
  ldv_50354: 
#line 165
  __mptr = (struct rb_node  const  *)n;
#line 165
  mcast = (struct ipoib_mcast *)__mptr + 0xffffffffffffffb0UL;
#line 167
  ret = memcmp((void const   *)mgid, (void const   *)(& mcast->mcmember.mgid.raw),
               16UL);
#line 169
  if (ret < 0) {
#line 170
    n = n->rb_left;
  } else
#line 171
  if (ret > 0) {
#line 172
    n = n->rb_right;
  } else {
#line 174
    return (mcast);
  }
  ldv_50355: ;
#line 161
  if ((unsigned long )n != (unsigned long )((struct rb_node *)0)) {
#line 163
    goto ldv_50354;
  } else {

  }

#line 177
  return ((struct ipoib_mcast *)0);
}
}
#line 180 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static int __ipoib_mcast_add(struct net_device *dev , struct ipoib_mcast *mcast ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct rb_node **n ;
  struct rb_node *pn ;
  struct ipoib_mcast *tmcast ;
  int ret ;
  struct rb_node  const  *__mptr ;

  {
#line 182
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 182
  priv = (struct ipoib_dev_priv *)tmp;
#line 183
  n = & priv->multicast_tree.rb_node;
#line 183
  pn = (struct rb_node *)0;
#line 185
  goto ldv_50369;
  ldv_50368: 
#line 189
  pn = *n;
#line 190
  __mptr = (struct rb_node  const  *)pn;
#line 190
  tmcast = (struct ipoib_mcast *)__mptr + 0xffffffffffffffb0UL;
#line 192
  ret = memcmp((void const   *)(& mcast->mcmember.mgid.raw), (void const   *)(& tmcast->mcmember.mgid.raw),
               16UL);
#line 194
  if (ret < 0) {
#line 195
    n = & pn->rb_left;
  } else
#line 196
  if (ret > 0) {
#line 197
    n = & pn->rb_right;
  } else {
#line 199
    return (-17);
  }
  ldv_50369: ;
#line 185
  if ((unsigned long )*n != (unsigned long )((struct rb_node *)0)) {
#line 187
    goto ldv_50368;
  } else {

  }
#line 202
  rb_link_node(& mcast->rb_node, pn, n);
#line 203
  rb_insert_color(& mcast->rb_node, & priv->multicast_tree);
#line 205
  return (0);
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static int ipoib_mcast_join_finish(struct ipoib_mcast *mcast , struct ib_sa_mcmember_rec *mcmember ) 
{ 
  struct net_device *dev ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_ah *ah ;
  int ret ;
  int set_qkey ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __u32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __u16 tmp___6 ;
  int tmp___7 ;
  struct ib_ah_attr av ;
  __u32 tmp___8 ;
  __u16 tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  __u16 tmp___12 ;
  bool tmp___13 ;
  struct sk_buff *skb ;
  struct sk_buff *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 211
  dev = mcast->dev;
#line 212
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 212
  priv = (struct ipoib_dev_priv *)tmp;
#line 215
  set_qkey = 0;
#line 217
  mcast->mcmember = *mcmember;
#line 222
  tmp___4 = memcmp((void const   *)(& mcast->mcmember.mgid.raw), (void const   *)(& (priv->dev)->broadcast) + 4U,
                   16UL);
#line 222
  if (tmp___4 == 0) {
#line 224
    spin_lock_irq(& priv->lock);
#line 225
    if ((unsigned long )priv->broadcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 226
      spin_unlock_irq(& priv->lock);
#line 227
      return (-11);
    } else {

    }
#line 230
    (priv->broadcast)->mcmember.qkey = mcmember->qkey;
#line 231
    (priv->broadcast)->mcmember.mtu = mcmember->mtu;
#line 232
    (priv->broadcast)->mcmember.traffic_class = mcmember->traffic_class;
#line 233
    (priv->broadcast)->mcmember.rate = mcmember->rate;
#line 234
    (priv->broadcast)->mcmember.sl = mcmember->sl;
#line 235
    (priv->broadcast)->mcmember.flow_label = mcmember->flow_label;
#line 236
    (priv->broadcast)->mcmember.hop_limit = mcmember->hop_limit;
#line 238
    if (priv->mcast_mtu == priv->admin_mtu) {
#line 239
      tmp___1 = ib_mtu_enum_to_int((enum ib_mtu )(priv->broadcast)->mcmember.mtu);
#line 239
      tmp___0 = (unsigned int )(tmp___1 + -4);
#line 239
      priv->mcast_mtu = tmp___0;
#line 239
      priv->admin_mtu = tmp___0;
    } else {
#line 243
      tmp___2 = ib_mtu_enum_to_int((enum ib_mtu )(priv->broadcast)->mcmember.mtu);
#line 243
      priv->mcast_mtu = (unsigned int )(tmp___2 + -4);
    }
#line 246
    tmp___3 = __fswab32((priv->broadcast)->mcmember.qkey);
#line 246
    priv->qkey = tmp___3;
#line 247
    spin_unlock_irq(& priv->lock);
#line 248
    priv->tx_wr.wr.ud.remote_qkey = priv->qkey;
#line 249
    set_qkey = 1;
  } else {

  }
#line 252
  tmp___7 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 252
  if (tmp___7 == 0) {
#line 253
    tmp___5 = test_and_set_bit(3L, (unsigned long volatile   *)(& mcast->flags));
#line 253
    if (tmp___5 != 0) {
#line 254
      printk("\f%s: multicast group %pI6 already attached\n", (char *)(& (priv->dev)->name),
             (u8 *)(& mcast->mcmember.mgid.raw));
#line 257
      return (0);
    } else {

    }
#line 260
    tmp___6 = __fswab16((int )mcast->mcmember.mlid);
#line 260
    ret = ipoib_mcast_attach(dev, (int )tmp___6, & mcast->mcmember.mgid, set_qkey);
#line 262
    if (ret < 0) {
#line 263
      printk("\f%s: couldn\'t attach QP to multicast group %pI6\n", (char *)(& (priv->dev)->name),
             (u8 *)(& mcast->mcmember.mgid.raw));
#line 266
      clear_bit(3L, (unsigned long volatile   *)(& mcast->flags));
#line 267
      return (ret);
    } else {

    }
  } else {

  }
#line 272
  tmp___8 = __fswab32(mcast->mcmember.flow_label);
#line 272
  tmp___9 = __fswab16((int )mcast->mcmember.mlid);
#line 272
  av.grh.dgid.raw[0] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[1] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[2] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[3] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[4] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[5] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[6] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[7] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[8] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[9] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[10] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[11] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[12] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[13] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[14] = (unsigned char)0;
#line 272
  av.grh.dgid.raw[15] = (unsigned char)0;
#line 272
  av.grh.flow_label = tmp___8;
#line 272
  av.grh.sgid_index = 0U;
#line 272
  av.grh.hop_limit = mcast->mcmember.hop_limit;
#line 272
  av.grh.traffic_class = mcast->mcmember.traffic_class;
#line 272
  av.dlid = tmp___9;
#line 272
  av.sl = mcast->mcmember.sl;
#line 272
  av.src_path_bits = (unsigned char)0;
#line 272
  av.static_rate = mcast->mcmember.rate;
#line 272
  av.ah_flags = 1U;
#line 272
  av.port_num = priv->port;
#line 272
  av.dmac[0] = (unsigned char)0;
#line 272
  av.dmac[1] = (unsigned char)0;
#line 272
  av.dmac[2] = (unsigned char)0;
#line 272
  av.dmac[3] = (unsigned char)0;
#line 272
  av.dmac[4] = (unsigned char)0;
#line 272
  av.dmac[5] = (unsigned char)0;
#line 272
  av.vlan_id = (unsigned short)0;
#line 285
  av.grh.dgid = mcast->mcmember.mgid;
#line 287
  ah = ipoib_create_ah(dev, priv->pd, & av);
#line 288
  tmp___13 = IS_ERR((void const   *)ah);
#line 288
  if ((int )tmp___13) {
#line 289
    tmp___10 = PTR_ERR((void const   *)ah);
#line 289
    printk("\f%s: ib_address_create failed %ld\n", (char *)(& (priv->dev)->name),
           - tmp___10);
#line 292
    tmp___11 = PTR_ERR((void const   *)ah);
#line 292
    return ((int )tmp___11);
  } else {
#line 294
    spin_lock_irq(& priv->lock);
#line 295
    mcast->ah = ah;
#line 296
    spin_unlock_irq(& priv->lock);
#line 298
    if (mcast_debug_level > 0) {
#line 298
      tmp___12 = __fswab16((int )mcast->mcmember.mlid);
#line 298
      printk("\017%s: MGID %pI6 AV %p, LID 0x%04x, SL %d\n", (char *)(& (priv->dev)->name),
             (u8 *)(& mcast->mcmember.mgid.raw), (mcast->ah)->ah, (int )tmp___12,
             (int )mcast->mcmember.sl);
    } else {

    }
  }
#line 307
  netif_tx_lock_bh___1(dev);
#line 308
  goto ldv_50383;
  ldv_50382: 
#line 309
  tmp___14 = skb_dequeue(& mcast->pkt_queue);
#line 309
  skb = tmp___14;
#line 311
  netif_tx_unlock_bh___1(dev);
#line 313
  skb->dev = dev;
#line 314
  tmp___15 = dev_queue_xmit(skb);
#line 314
  if (tmp___15 != 0) {
#line 315
    printk("\f%s: dev_queue_xmit failed to requeue packet\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 317
  netif_tx_lock_bh___1(dev);
  ldv_50383: 
#line 308
  tmp___16 = skb_queue_empty((struct sk_buff_head  const  *)(& mcast->pkt_queue));
#line 308
  if (tmp___16 == 0) {
#line 310
    goto ldv_50382;
  } else {

  }
#line 319
  netif_tx_unlock_bh___1(dev);
#line 321
  return (0);
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
void ipoib_mcast_carrier_on_task(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct ib_port_attr attr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  int tmp___2 ;

  {
#line 326
  __mptr = (struct work_struct  const  *)work;
#line 326
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffffc00UL;
#line 330
  tmp = ib_query_port(priv->ca, (int )priv->port, & attr);
#line 330
  if (tmp != 0 || (unsigned int )attr.state != 4U) {
#line 332
    if (ipoib_debug_level > 0) {
#line 332
      printk("\017%s: Keeping carrier off until IB port is active\n", (char *)(& (priv->dev)->name));
    } else {

    }
#line 333
    return;
  } else {

  }
#line 345
  goto ldv_50393;
  ldv_50392: 
#line 346
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->flags));
#line 346
  if (tmp___0 == 0) {
#line 347
    return;
  } else {
#line 349
    msleep(20U);
  }
  ldv_50393: 
#line 345
  tmp___1 = rtnl_trylock();
#line 345
  if (tmp___1 == 0) {
#line 347
    goto ldv_50392;
  } else {

  }
#line 351
  tmp___2 = ipoib_cm_admin_enabled(priv->dev);
#line 351
  if (tmp___2 == 0) {
#line 352
    _min1 = priv->mcast_mtu;
#line 352
    _min2 = priv->admin_mtu;
#line 352
    dev_set_mtu(priv->dev, (int )(_min1 < _min2 ? _min1 : _min2));
  } else {

  }
#line 353
  netif_carrier_on(priv->dev);
#line 354
  rtnl_unlock();
#line 355
  return;
}
}
#line 357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static int ipoib_mcast_join_complete(int status , struct ib_sa_multicast *multicast ) 
{ 
  struct ipoib_mcast *mcast ;
  struct net_device *dev ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char tmp___3 ;
  struct sk_buff *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 360
  mcast = (struct ipoib_mcast *)multicast->context;
#line 361
  dev = mcast->dev;
#line 362
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 362
  priv = (struct ipoib_dev_priv *)tmp;
#line 364
  if (mcast_debug_level > 0) {
#line 364
    tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 364
    printk("\017%s: %sjoin completion for %pI6 (status %d)\n", (char *)(& (priv->dev)->name),
           tmp___0 != 0 ? (char *)"sendonly " : (char *)"", (u8 *)(& mcast->mcmember.mgid.raw),
           status);
  } else {

  }
#line 370
  if (status == -102) {
#line 371
    status = 0;
#line 372
    goto out;
  } else {

  }
#line 375
  if (status == 0) {
#line 376
    status = ipoib_mcast_join_finish(mcast, & multicast->rec);
  } else {

  }
#line 378
  if (status == 0) {
#line 379
    mcast->backoff = 1UL;
#line 380
    mcast->delay_until = jiffies;
#line 389
    if ((unsigned long )priv->broadcast == (unsigned long )mcast) {
#line 390
      spin_lock_irq(& priv->lock);
#line 391
      queue_work___1(priv->wq, & priv->carrier_on_task);
#line 392
      __ipoib_mcast_schedule_join_thread(priv, (struct ipoib_mcast *)0, 0);
#line 393
      goto out_locked;
    } else {

    }
  } else {
#line 396
    tmp___3 = mcast->logcount;
#line 396
    mcast->logcount = (unsigned char )((int )mcast->logcount + 1);
#line 396
    if ((unsigned int )tmp___3 <= 19U) {
#line 397
      if (status == -110 || status == -11) {
#line 398
        if (mcast_debug_level > 0) {
#line 398
          tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 398
          printk("\017%s: %smulticast join failed for %pI6, status %d\n", (char *)(& (priv->dev)->name),
                 tmp___1 != 0 ? (char *)"sendonly " : (char *)"", (u8 *)(& mcast->mcmember.mgid.raw),
                 status);
        } else {

        }
      } else {
#line 402
        tmp___2 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 402
        printk("\f%s: %smulticast join failed for %pI6, status %d\n", (char *)(& (priv->dev)->name),
               tmp___2 != 0 ? (char *)"sendonly " : (char *)"", (u8 *)(& mcast->mcmember.mgid.raw),
               status);
      }
    } else {

    }
#line 408
    tmp___6 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 408
    if (tmp___6 != 0 && mcast->backoff > 1UL) {
#line 419
      mcast->backoff = 1UL;
#line 420
      netif_tx_lock_bh___1(dev);
#line 421
      goto ldv_50408;
      ldv_50407: 
#line 422
      dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 423
      tmp___4 = skb_dequeue(& mcast->pkt_queue);
#line 423
      dev_kfree_skb_any(tmp___4);
      ldv_50408: 
#line 421
      tmp___5 = skb_queue_empty((struct sk_buff_head  const  *)(& mcast->pkt_queue));
#line 421
      if (tmp___5 == 0) {
#line 423
        goto ldv_50407;
      } else {

      }
#line 425
      netif_tx_unlock_bh___1(dev);
    } else {
#line 427
      spin_lock_irq(& priv->lock);
#line 429
      __ipoib_mcast_schedule_join_thread(priv, mcast, 1);
#line 430
      goto out_locked;
    }
  }
  out: 
#line 434
  spin_lock_irq(& priv->lock);
  out_locked: ;
#line 440
  if (status != 0) {
#line 441
    mcast->mc = (struct ib_sa_multicast *)0;
  } else {
#line 443
    mcast->mc = multicast;
  }
#line 444
  clear_bit(2L, (unsigned long volatile   *)(& mcast->flags));
#line 445
  spin_unlock_irq(& priv->lock);
#line 446
  complete(& mcast->done);
#line 448
  return (status);
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static void ipoib_mcast_join(struct net_device *dev , struct ipoib_mcast *mcast ,
                             int create ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_sa_multicast *multicast ;
  struct ib_sa_mcmember_rec rec ;
  ib_sa_comp_mask comp_mask ;
  int ret ;
  __u16 tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;

  {
#line 454
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 454
  priv = (struct ipoib_dev_priv *)tmp;
#line 456
  rec.mgid.raw[0] = (unsigned char)0;
#line 456
  rec.mgid.raw[1] = (unsigned char)0;
#line 456
  rec.mgid.raw[2] = (unsigned char)0;
#line 456
  rec.mgid.raw[3] = (unsigned char)0;
#line 456
  rec.mgid.raw[4] = (unsigned char)0;
#line 456
  rec.mgid.raw[5] = (unsigned char)0;
#line 456
  rec.mgid.raw[6] = (unsigned char)0;
#line 456
  rec.mgid.raw[7] = (unsigned char)0;
#line 456
  rec.mgid.raw[8] = (unsigned char)0;
#line 456
  rec.mgid.raw[9] = (unsigned char)0;
#line 456
  rec.mgid.raw[10] = (unsigned char)0;
#line 456
  rec.mgid.raw[11] = (unsigned char)0;
#line 456
  rec.mgid.raw[12] = (unsigned char)0;
#line 456
  rec.mgid.raw[13] = (unsigned char)0;
#line 456
  rec.mgid.raw[14] = (unsigned char)0;
#line 456
  rec.mgid.raw[15] = (unsigned char)0;
#line 456
  rec.port_gid.raw[0] = (unsigned char)0;
#line 456
  rec.port_gid.raw[1] = (unsigned char)0;
#line 456
  rec.port_gid.raw[2] = (unsigned char)0;
#line 456
  rec.port_gid.raw[3] = (unsigned char)0;
#line 456
  rec.port_gid.raw[4] = (unsigned char)0;
#line 456
  rec.port_gid.raw[5] = (unsigned char)0;
#line 456
  rec.port_gid.raw[6] = (unsigned char)0;
#line 456
  rec.port_gid.raw[7] = (unsigned char)0;
#line 456
  rec.port_gid.raw[8] = (unsigned char)0;
#line 456
  rec.port_gid.raw[9] = (unsigned char)0;
#line 456
  rec.port_gid.raw[10] = (unsigned char)0;
#line 456
  rec.port_gid.raw[11] = (unsigned char)0;
#line 456
  rec.port_gid.raw[12] = (unsigned char)0;
#line 456
  rec.port_gid.raw[13] = (unsigned char)0;
#line 456
  rec.port_gid.raw[14] = (unsigned char)0;
#line 456
  rec.port_gid.raw[15] = (unsigned char)0;
#line 456
  rec.qkey = 0U;
#line 456
  rec.mlid = (unsigned short)0;
#line 456
  rec.mtu_selector = (unsigned char)0;
#line 456
  rec.mtu = (unsigned char)0;
#line 456
  rec.traffic_class = (unsigned char)0;
#line 456
  rec.pkey = (unsigned short)0;
#line 456
  rec.rate_selector = (unsigned char)0;
#line 456
  rec.rate = (unsigned char)0;
#line 456
  rec.packet_life_time_selector = (unsigned char)0;
#line 456
  rec.packet_life_time = (unsigned char)0;
#line 456
  rec.sl = (unsigned char)0;
#line 456
  rec.flow_label = 0U;
#line 456
  rec.hop_limit = (unsigned char)0;
#line 456
  rec.scope = (unsigned char)0;
#line 456
  rec.join_state = 1U;
#line 456
  rec.proxy_join = 0;
#line 460
  ret = 0;
#line 462
  if (mcast_debug_level > 0) {
#line 462
    printk("\017%s: joining MGID %pI6\n", (char *)(& (priv->dev)->name), (u8 *)(& mcast->mcmember.mgid.raw));
  } else {

  }
#line 464
  rec.mgid = mcast->mcmember.mgid;
#line 465
  rec.port_gid = priv->local_gid;
#line 466
  tmp___0 = __fswab16((int )priv->pkey);
#line 466
  rec.pkey = tmp___0;
#line 468
  comp_mask = 0x8300010000000000ULL;
#line 474
  if (create != 0) {
#line 475
    comp_mask = comp_mask | 8391050530721366016ULL;
#line 486
    rec.qkey = (priv->broadcast)->mcmember.qkey;
#line 487
    rec.mtu_selector = 2U;
#line 488
    rec.mtu = (priv->broadcast)->mcmember.mtu;
#line 489
    rec.traffic_class = (priv->broadcast)->mcmember.traffic_class;
#line 490
    rec.rate_selector = 2U;
#line 491
    rec.rate = (priv->broadcast)->mcmember.rate;
#line 492
    rec.sl = (priv->broadcast)->mcmember.sl;
#line 493
    rec.flow_label = (priv->broadcast)->mcmember.flow_label;
#line 494
    rec.hop_limit = (priv->broadcast)->mcmember.hop_limit;
  } else {

  }
#line 497
  multicast = ib_sa_join_multicast(& ipoib_sa_client, priv->ca, (int )priv->port,
                                   & rec, comp_mask, 208U, & ipoib_mcast_join_complete,
                                   (void *)mcast);
#line 500
  tmp___2 = IS_ERR((void const   *)multicast);
#line 500
  if ((int )tmp___2) {
#line 501
    tmp___1 = PTR_ERR((void const   *)multicast);
#line 501
    ret = (int )tmp___1;
#line 502
    printk("\f%s: ib_sa_join_multicast failed, status %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 503
    spin_lock_irq(& priv->lock);
#line 505
    __ipoib_mcast_schedule_join_thread(priv, mcast, 1);
#line 506
    clear_bit(2L, (unsigned long volatile   *)(& mcast->flags));
#line 507
    spin_unlock_irq(& priv->lock);
#line 508
    complete(& mcast->done);
  } else {

  }
#line 510
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
void ipoib_mcast_join_task(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct net_device *dev ;
  struct ib_port_attr port_attr ;
  unsigned long delay_until ;
  struct ipoib_mcast *mcast ;
  int create ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ipoib_mcast *broadcast ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 515
  __mptr = (struct work_struct  const  *)work;
#line 515
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffffce0UL;
#line 516
  dev = priv->dev;
#line 518
  delay_until = 0UL;
#line 519
  mcast = (struct ipoib_mcast *)0;
#line 520
  create = 1;
#line 522
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->flags));
#line 522
  if (tmp == 0) {
#line 523
    return;
  } else {

  }
#line 525
  tmp___0 = ib_query_port(priv->ca, (int )priv->port, & port_attr);
#line 525
  if (tmp___0 != 0 || (unsigned int )port_attr.state != 4U) {
#line 527
    if (ipoib_debug_level > 0) {
#line 527
      printk("\017%s: port state is not ACTIVE (state = %d) suspending join task\n",
             (char *)(& (priv->dev)->name), (unsigned int )port_attr.state);
    } else {

    }
#line 529
    return;
  } else {

  }
#line 531
  priv->local_lid = port_attr.lid;
#line 533
  tmp___1 = ib_query_gid(priv->ca, (int )priv->port, 0, & priv->local_gid);
#line 533
  if (tmp___1 != 0) {
#line 534
    printk("\f%s: ib_query_gid() failed\n", (char *)(& (priv->dev)->name));
  } else {
#line 536
    memcpy((void *)(priv->dev)->dev_addr + 4U, (void const   *)(& priv->local_gid.raw),
             16UL);
  }
#line 538
  spin_lock_irq(& priv->lock);
#line 539
  tmp___2 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->flags));
#line 539
  if (tmp___2 == 0) {
#line 540
    goto out;
  } else {

  }
#line 542
  if ((unsigned long )priv->broadcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 545
    broadcast = ipoib_mcast_alloc(dev, 0);
#line 546
    if ((unsigned long )broadcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 547
      printk("\f%s: failed to allocate broadcast group\n", (char *)(& (priv->dev)->name));
#line 554
      __ipoib_mcast_schedule_join_thread(priv, (struct ipoib_mcast *)0, 1);
#line 555
      goto out;
    } else {

    }
#line 558
    memcpy((void *)(& broadcast->mcmember.mgid.raw), (void const   *)(& (priv->dev)->broadcast) + 4U,
             16UL);
#line 560
    priv->broadcast = broadcast;
#line 562
    __ipoib_mcast_add(dev, priv->broadcast);
  } else {

  }
#line 565
  tmp___5 = constant_test_bit(3L, (unsigned long const volatile   *)(& (priv->broadcast)->flags));
#line 565
  if (tmp___5 == 0) {
#line 566
    tmp___3 = IS_ERR_OR_NULL((void const   *)(priv->broadcast)->mc);
#line 566
    if ((int )tmp___3) {
#line 566
      tmp___4 = constant_test_bit(2L, (unsigned long const volatile   *)(& (priv->broadcast)->flags));
#line 566
      if (tmp___4 == 0) {
#line 568
        mcast = priv->broadcast;
#line 569
        create = 0;
#line 571
        if (mcast->backoff > 1UL && (long )((unsigned long )jiffies - mcast->delay_until) < 0L) {
#line 572
          delay_until = mcast->delay_until;
#line 573
          mcast = (struct ipoib_mcast *)0;
        } else {

        }
      } else {

      }
    } else {

    }
#line 576
    goto out;
  } else {

  }
#line 583
  __mptr___0 = (struct list_head  const  *)priv->multicast_list.next;
#line 583
  mcast = (struct ipoib_mcast *)__mptr___0 + 0xffffffffffffff98UL;
#line 583
  goto ldv_50456;
  ldv_50455: 
#line 584
  tmp___7 = IS_ERR_OR_NULL((void const   *)mcast->mc);
#line 584
  if ((int )tmp___7) {
#line 584
    tmp___8 = constant_test_bit(2L, (unsigned long const volatile   *)(& mcast->flags));
#line 584
    if (tmp___8 == 0) {
#line 584
      tmp___9 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 584
      if (tmp___9 == 0) {
#line 584
        goto _L;
      } else {
#line 584
        tmp___10 = skb_queue_empty((struct sk_buff_head  const  *)(& mcast->pkt_queue));
#line 584
        if (tmp___10 == 0) {
          _L: /* CIL Label */ 
#line 589
          if (mcast->backoff == 1UL || (long )((unsigned long )jiffies - mcast->delay_until) >= 0L) {
#line 591
            init_completion(& mcast->done);
#line 592
            set_bit(2L, (unsigned long volatile   *)(& mcast->flags));
#line 593
            tmp___6 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 593
            if (tmp___6 != 0) {
#line 594
              create = 0;
            } else {
#line 596
              create = 1;
            }
#line 597
            spin_unlock_irq(& priv->lock);
#line 598
            ipoib_mcast_join(dev, mcast, create);
#line 599
            spin_lock_irq(& priv->lock);
          } else
#line 601
          if (delay_until == 0UL || (long )(mcast->delay_until - delay_until) < 0L) {
#line 602
            delay_until = mcast->delay_until;
          } else {

          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
#line 583
  __mptr___1 = (struct list_head  const  *)mcast->list.next;
#line 583
  mcast = (struct ipoib_mcast *)__mptr___1 + 0xffffffffffffff98UL;
  ldv_50456: ;
#line 583
  if ((unsigned long )(& mcast->list) != (unsigned long )(& priv->multicast_list)) {
#line 585
    goto ldv_50455;
  } else {

  }
#line 606
  mcast = (struct ipoib_mcast *)0;
#line 607
  if (mcast_debug_level > 0) {
#line 607
    printk("\017%s: successfully started all multicast joins\n", (char *)(& (priv->dev)->name));
  } else {

  }
  out: ;
#line 610
  if (delay_until != 0UL) {
#line 611
    ldv_cancel_delayed_work_79(& priv->mcast_task);
#line 612
    queue_delayed_work___1(priv->wq, & priv->mcast_task, delay_until - (unsigned long )jiffies);
  } else {

  }
#line 615
  if ((unsigned long )mcast != (unsigned long )((struct ipoib_mcast *)0)) {
#line 616
    init_completion(& mcast->done);
#line 617
    set_bit(2L, (unsigned long volatile   *)(& mcast->flags));
  } else {

  }
#line 619
  spin_unlock_irq(& priv->lock);
#line 620
  if ((unsigned long )mcast != (unsigned long )((struct ipoib_mcast *)0)) {
#line 621
    ipoib_mcast_join(dev, mcast, create);
  } else {

  }
#line 622
  return;
}
}
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
int ipoib_mcast_start_thread(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;

  {
#line 626
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 626
  priv = (struct ipoib_dev_priv *)tmp;
#line 629
  if (mcast_debug_level > 0) {
#line 629
    printk("\017%s: starting multicast thread\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 631
  tmp___0 = spinlock_check(& priv->lock);
#line 631
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 632
  __ipoib_mcast_schedule_join_thread(priv, (struct ipoib_mcast *)0, 0);
#line 633
  spin_unlock_irqrestore(& priv->lock, flags);
#line 635
  return (0);
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
int ipoib_mcast_stop_thread(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;

  {
#line 640
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 640
  priv = (struct ipoib_dev_priv *)tmp;
#line 643
  if (mcast_debug_level > 0) {
#line 643
    printk("\017%s: stopping multicast thread\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 645
  tmp___0 = spinlock_check(& priv->lock);
#line 645
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 646
  ldv_cancel_delayed_work_80(& priv->mcast_task);
#line 647
  spin_unlock_irqrestore(& priv->lock, flags);
#line 649
  ldv_flush_workqueue_81(priv->wq);
#line 651
  return (0);
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static int ipoib_mcast_leave(struct net_device *dev , struct ipoib_mcast *mcast ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int ret ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  __u16 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 656
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 656
  priv = (struct ipoib_dev_priv *)tmp;
#line 657
  ret = 0;
#line 659
  tmp___0 = test_and_clear_bit(2L, (unsigned long volatile   *)(& mcast->flags));
#line 659
  if (tmp___0 != 0) {
#line 660
    printk("\f%s: ipoib_mcast_leave on an in-flight join\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 662
  tmp___1 = IS_ERR_OR_NULL((void const   *)mcast->mc);
#line 662
  if (tmp___1) {
#line 662
    tmp___2 = 0;
  } else {
#line 662
    tmp___2 = 1;
  }
#line 662
  if (tmp___2) {
#line 663
    ib_sa_free_multicast(mcast->mc);
  } else {

  }
#line 665
  tmp___5 = test_and_clear_bit(3L, (unsigned long volatile   *)(& mcast->flags));
#line 665
  if (tmp___5 != 0) {
#line 666
    if (mcast_debug_level > 0) {
#line 666
      printk("\017%s: leaving MGID %pI6\n", (char *)(& (priv->dev)->name), (u8 *)(& mcast->mcmember.mgid.raw));
    } else {

    }
#line 670
    tmp___3 = __fswab16((int )mcast->mcmember.mlid);
#line 670
    ret = ib_detach_mcast(priv->qp, & mcast->mcmember.mgid, (int )tmp___3);
#line 672
    if (ret != 0) {
#line 673
      printk("\f%s: ib_detach_mcast failed (result = %d)\n", (char *)(& (priv->dev)->name),
             ret);
    } else {

    }
  } else {
#line 674
    tmp___4 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 674
    if (tmp___4 == 0) {
#line 675
      if (ipoib_debug_level > 0) {
#line 675
        printk("\017%s: leaving with no mcmember but not a SENDONLY join\n", (char *)(& (priv->dev)->name));
      } else {

      }
    } else {

    }
  }
#line 678
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
void ipoib_mcast_send(struct net_device *dev , u8 *daddr , struct sk_buff *skb ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_mcast *mcast ;
  unsigned long flags ;
  void *mgid ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __u32 tmp___3 ;
  int tmp___4 ;
  struct ipoib_neigh *neigh ;
  raw_spinlock_t *tmp___5 ;

  {
#line 683
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 683
  priv = (struct ipoib_dev_priv *)tmp;
#line 686
  mgid = (void *)daddr + 4U;
#line 688
  tmp___0 = spinlock_check(& priv->lock);
#line 688
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 690
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->flags));
#line 690
  if (tmp___1 == 0 || (unsigned long )priv->broadcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 693
    dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 694
    dev_kfree_skb_any(skb);
#line 695
    goto unlock;
  } else {
#line 690
    tmp___2 = constant_test_bit(3L, (unsigned long const volatile   *)(& (priv->broadcast)->flags));
#line 690
    if (tmp___2 == 0) {
#line 693
      dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 694
      dev_kfree_skb_any(skb);
#line 695
      goto unlock;
    } else {

    }
  }
#line 698
  mcast = __ipoib_mcast_find(dev, mgid);
#line 699
  if ((unsigned long )mcast == (unsigned long )((struct ipoib_mcast *)0) || (unsigned long )mcast->ah == (unsigned long )((struct ipoib_ah *)0)) {
#line 700
    if ((unsigned long )mcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 702
      if (mcast_debug_level > 0) {
#line 702
        printk("\017%s: setting up send only multicast group for %pI6\n", (char *)(& (priv->dev)->name),
               mgid);
      } else {

      }
#line 705
      mcast = ipoib_mcast_alloc(dev, 0);
#line 706
      if ((unsigned long )mcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 707
        printk("\f%s: unable to allocate memory for multicast structure\n", (char *)(& (priv->dev)->name));
#line 709
        dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 710
        dev_kfree_skb_any(skb);
#line 711
        goto unlock;
      } else {

      }
#line 714
      set_bit(1L, (unsigned long volatile   *)(& mcast->flags));
#line 715
      memcpy((void *)(& mcast->mcmember.mgid.raw), (void const   *)mgid, 16UL);
#line 717
      __ipoib_mcast_add(dev, mcast);
#line 718
      list_add_tail(& mcast->list, & priv->multicast_list);
    } else {

    }
#line 720
    tmp___3 = skb_queue_len((struct sk_buff_head  const  *)(& mcast->pkt_queue));
#line 720
    if (tmp___3 <= 2U) {
#line 721
      skb_queue_tail(& mcast->pkt_queue, skb);
    } else {
#line 723
      dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 724
      dev_kfree_skb_any(skb);
    }
#line 726
    tmp___4 = constant_test_bit(2L, (unsigned long const volatile   *)(& mcast->flags));
#line 726
    if (tmp___4 == 0) {
#line 727
      __ipoib_mcast_schedule_join_thread(priv, (struct ipoib_mcast *)0, 0);
    } else {

    }
  } else {
#line 732
    spin_unlock_irqrestore(& priv->lock, flags);
#line 733
    neigh = ipoib_neigh_get(dev, daddr);
#line 734
    tmp___5 = spinlock_check(& priv->lock);
#line 734
    flags = _raw_spin_lock_irqsave(tmp___5);
#line 735
    if ((unsigned long )neigh == (unsigned long )((struct ipoib_neigh *)0)) {
#line 736
      neigh = ipoib_neigh_alloc(daddr, dev);
#line 737
      if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 738
        kref_get___0(& (mcast->ah)->ref);
#line 739
        neigh->ah = mcast->ah;
#line 740
        list_add_tail(& neigh->list, & mcast->neigh_list);
      } else {

      }
    } else {

    }
#line 743
    spin_unlock_irqrestore(& priv->lock, flags);
#line 744
    ipoib_send(dev, skb, mcast->ah, 16777215U);
#line 745
    if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 746
      ipoib_neigh_put(neigh);
    } else {

    }
#line 747
    return;
  }
  unlock: 
#line 751
  spin_unlock_irqrestore(& priv->lock, flags);
#line 752
  return;
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
void ipoib_mcast_dev_flush(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct list_head remove_list ;
  struct ipoib_mcast *mcast ;
  struct ipoib_mcast *tmcast ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  int tmp___1 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  struct list_head  const  *__mptr___7 ;

  {
#line 756
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 756
  priv = (struct ipoib_dev_priv *)tmp;
#line 757
  remove_list.next = & remove_list;
#line 757
  remove_list.prev = & remove_list;
#line 761
  if (mcast_debug_level > 0) {
#line 761
    printk("\017%s: flushing multicast list\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 763
  tmp___0 = spinlock_check(& priv->lock);
#line 763
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 765
  __mptr = (struct list_head  const  *)priv->multicast_list.next;
#line 765
  mcast = (struct ipoib_mcast *)__mptr + 0xffffffffffffff98UL;
#line 765
  __mptr___0 = (struct list_head  const  *)mcast->list.next;
#line 765
  tmcast = (struct ipoib_mcast *)__mptr___0 + 0xffffffffffffff98UL;
#line 765
  goto ldv_50515;
  ldv_50514: 
#line 766
  list_del(& mcast->list);
#line 767
  rb_erase(& mcast->rb_node, & priv->multicast_tree);
#line 768
  list_add_tail(& mcast->list, & remove_list);
#line 765
  mcast = tmcast;
#line 765
  __mptr___1 = (struct list_head  const  *)tmcast->list.next;
#line 765
  tmcast = (struct ipoib_mcast *)__mptr___1 + 0xffffffffffffff98UL;
  ldv_50515: ;
#line 765
  if ((unsigned long )(& mcast->list) != (unsigned long )(& priv->multicast_list)) {
#line 767
    goto ldv_50514;
  } else {

  }

#line 771
  if ((unsigned long )priv->broadcast != (unsigned long )((struct ipoib_mcast *)0)) {
#line 772
    rb_erase(& (priv->broadcast)->rb_node, & priv->multicast_tree);
#line 773
    list_add_tail(& (priv->broadcast)->list, & remove_list);
#line 774
    priv->broadcast = (struct ipoib_mcast *)0;
  } else {

  }
#line 777
  spin_unlock_irqrestore(& priv->lock, flags);
#line 783
  __mptr___2 = (struct list_head  const  *)remove_list.next;
#line 783
  mcast = (struct ipoib_mcast *)__mptr___2 + 0xffffffffffffff98UL;
#line 783
  __mptr___3 = (struct list_head  const  *)mcast->list.next;
#line 783
  tmcast = (struct ipoib_mcast *)__mptr___3 + 0xffffffffffffff98UL;
#line 783
  goto ldv_50524;
  ldv_50523: 
#line 784
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& mcast->flags));
#line 784
  if (tmp___1 != 0) {
#line 785
    wait_for_completion(& mcast->done);
  } else {

  }
#line 783
  mcast = tmcast;
#line 783
  __mptr___4 = (struct list_head  const  *)tmcast->list.next;
#line 783
  tmcast = (struct ipoib_mcast *)__mptr___4 + 0xffffffffffffff98UL;
  ldv_50524: ;
#line 783
  if ((unsigned long )(& mcast->list) != (unsigned long )(& remove_list)) {
#line 785
    goto ldv_50523;
  } else {

  }
#line 787
  __mptr___5 = (struct list_head  const  *)remove_list.next;
#line 787
  mcast = (struct ipoib_mcast *)__mptr___5 + 0xffffffffffffff98UL;
#line 787
  __mptr___6 = (struct list_head  const  *)mcast->list.next;
#line 787
  tmcast = (struct ipoib_mcast *)__mptr___6 + 0xffffffffffffff98UL;
#line 787
  goto ldv_50533;
  ldv_50532: 
#line 788
  ipoib_mcast_leave(dev, mcast);
#line 789
  ipoib_mcast_free(mcast);
#line 787
  mcast = tmcast;
#line 787
  __mptr___7 = (struct list_head  const  *)tmcast->list.next;
#line 787
  tmcast = (struct ipoib_mcast *)__mptr___7 + 0xffffffffffffff98UL;
  ldv_50533: ;
#line 787
  if ((unsigned long )(& mcast->list) != (unsigned long )(& remove_list)) {
#line 789
    goto ldv_50532;
  } else {

  }

#line 794
  return;
}
}
#line 793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
static int ipoib_mcast_addr_is_valid(u8 const   *addr , u8 const   *broadcast ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 796
  tmp = memcmp((void const   *)addr, (void const   *)broadcast, 6UL);
#line 796
  if (tmp != 0) {
#line 797
    return (0);
  } else {

  }
#line 799
  tmp___0 = memcmp((void const   *)addr + 7U, (void const   *)broadcast + 7U, 3UL);
#line 799
  if (tmp___0 != 0) {
#line 800
    return (0);
  } else {

  }
#line 801
  return (1);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
void ipoib_mcast_restart_task(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct net_device *dev ;
  struct netdev_hw_addr *ha ;
  struct ipoib_mcast *mcast ;
  struct ipoib_mcast *tmcast ;
  struct list_head remove_list ;
  unsigned long flags ;
  struct ib_sa_mcmember_rec rec ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  union ib_gid mgid ;
  int tmp___0 ;
  struct ipoib_mcast *nmcast ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  int tmp___4 ;
  int tmp___5 ;
  struct list_head  const  *__mptr___6 ;
  int tmp___6 ;
  struct list_head  const  *__mptr___7 ;
  struct list_head  const  *__mptr___8 ;
  int tmp___7 ;
  struct list_head  const  *__mptr___9 ;
  struct list_head  const  *__mptr___10 ;
  struct list_head  const  *__mptr___11 ;
  struct list_head  const  *__mptr___12 ;
  raw_spinlock_t *tmp___8 ;
  int tmp___9 ;

  {
#line 807
  __mptr = (struct work_struct  const  *)work;
#line 807
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffffac0UL;
#line 808
  dev = priv->dev;
#line 811
  remove_list.next = & remove_list;
#line 811
  remove_list.prev = & remove_list;
#line 815
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->flags));
#line 815
  if (tmp == 0) {
#line 820
    return;
  } else {

  }
#line 822
  if (mcast_debug_level > 0) {
#line 822
    printk("\017%s: restarting multicast task\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 824
  flags = arch_local_irq_save();
#line 824
  trace_hardirqs_off();
#line 825
  netif_addr_lock(dev);
#line 826
  spin_lock(& priv->lock);
#line 835
  __mptr___0 = (struct list_head  const  *)priv->multicast_list.next;
#line 835
  mcast = (struct ipoib_mcast *)__mptr___0 + 0xffffffffffffff98UL;
#line 835
  goto ldv_50560;
  ldv_50559: 
#line 836
  clear_bit(0L, (unsigned long volatile   *)(& mcast->flags));
#line 835
  __mptr___1 = (struct list_head  const  *)mcast->list.next;
#line 835
  mcast = (struct ipoib_mcast *)__mptr___1 + 0xffffffffffffff98UL;
  ldv_50560: ;
#line 835
  if ((unsigned long )(& mcast->list) != (unsigned long )(& priv->multicast_list)) {
#line 837
    goto ldv_50559;
  } else {

  }
#line 839
  __mptr___2 = (struct list_head  const  *)dev->mc.list.next;
#line 839
  ha = (struct netdev_hw_addr *)__mptr___2;
#line 839
  goto ldv_50570;
  ldv_50569: 
#line 842
  tmp___0 = ipoib_mcast_addr_is_valid((u8 const   *)(& ha->addr), (u8 const   *)(& dev->broadcast));
#line 842
  if (tmp___0 == 0) {
#line 843
    goto ldv_50567;
  } else {

  }
#line 845
  memcpy((void *)(& mgid.raw), (void const   *)(& ha->addr) + 4U, 16UL);
#line 847
  mcast = __ipoib_mcast_find(dev, (void *)(& mgid));
#line 848
  if ((unsigned long )mcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 848
    goto _L;
  } else {
#line 848
    tmp___3 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 848
    if (tmp___3 != 0) {
      _L: /* CIL Label */ 
#line 852
      tmp___1 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->flags));
#line 852
      if (tmp___1 != 0) {
#line 852
        tmp___2 = ib_sa_get_mcmember_rec(priv->ca, (int )priv->port, & mgid, & rec);
#line 852
        if (tmp___2 == 0) {
#line 854
          if (mcast_debug_level > 0) {
#line 854
            printk("\017%s: ignoring multicast entry for mgid %pI6\n", (char *)(& (priv->dev)->name),
                   (u8 *)(& mgid.raw));
          } else {

          }
#line 856
          goto ldv_50567;
        } else {

        }
      } else {

      }
#line 860
      if (mcast_debug_level > 0) {
#line 860
        printk("\017%s: adding multicast entry for mgid %pI6\n", (char *)(& (priv->dev)->name),
               (u8 *)(& mgid.raw));
      } else {

      }
#line 863
      nmcast = ipoib_mcast_alloc(dev, 0);
#line 864
      if ((unsigned long )nmcast == (unsigned long )((struct ipoib_mcast *)0)) {
#line 865
        printk("\f%s: unable to allocate memory for multicast structure\n", (char *)(& (priv->dev)->name));
#line 866
        goto ldv_50567;
      } else {

      }
#line 869
      set_bit(0L, (unsigned long volatile   *)(& nmcast->flags));
#line 871
      nmcast->mcmember.mgid = mgid;
#line 873
      if ((unsigned long )mcast != (unsigned long )((struct ipoib_mcast *)0)) {
#line 875
        list_move_tail(& mcast->list, & remove_list);
#line 877
        rb_replace_node(& mcast->rb_node, & nmcast->rb_node, & priv->multicast_tree);
      } else {
#line 881
        __ipoib_mcast_add(dev, nmcast);
      }
#line 883
      list_add_tail(& nmcast->list, & priv->multicast_list);
    } else {

    }
  }
#line 886
  if ((unsigned long )mcast != (unsigned long )((struct ipoib_mcast *)0)) {
#line 887
    set_bit(0L, (unsigned long volatile   *)(& mcast->flags));
  } else {

  }
  ldv_50567: 
#line 839
  __mptr___3 = (struct list_head  const  *)ha->list.next;
#line 839
  ha = (struct netdev_hw_addr *)__mptr___3;
  ldv_50570: ;
#line 839
  if ((unsigned long )(& ha->list) != (unsigned long )(& dev->mc.list)) {
#line 841
    goto ldv_50569;
  } else {

  }
#line 891
  __mptr___4 = (struct list_head  const  *)priv->multicast_list.next;
#line 891
  mcast = (struct ipoib_mcast *)__mptr___4 + 0xffffffffffffff98UL;
#line 891
  __mptr___5 = (struct list_head  const  *)mcast->list.next;
#line 891
  tmcast = (struct ipoib_mcast *)__mptr___5 + 0xffffffffffffff98UL;
#line 891
  goto ldv_50579;
  ldv_50578: 
#line 892
  tmp___4 = constant_test_bit(0L, (unsigned long const volatile   *)(& mcast->flags));
#line 892
  if (tmp___4 == 0) {
#line 892
    tmp___5 = constant_test_bit(1L, (unsigned long const volatile   *)(& mcast->flags));
#line 892
    if (tmp___5 == 0) {
#line 894
      if (mcast_debug_level > 0) {
#line 894
        printk("\017%s: deleting multicast group %pI6\n", (char *)(& (priv->dev)->name),
               (u8 *)(& mcast->mcmember.mgid.raw));
      } else {

      }
#line 897
      rb_erase(& mcast->rb_node, & priv->multicast_tree);
#line 900
      list_move_tail(& mcast->list, & remove_list);
    } else {

    }
  } else {

  }
#line 891
  mcast = tmcast;
#line 891
  __mptr___6 = (struct list_head  const  *)tmcast->list.next;
#line 891
  tmcast = (struct ipoib_mcast *)__mptr___6 + 0xffffffffffffff98UL;
  ldv_50579: ;
#line 891
  if ((unsigned long )(& mcast->list) != (unsigned long )(& priv->multicast_list)) {
#line 893
    goto ldv_50578;
  } else {

  }
#line 904
  spin_unlock(& priv->lock);
#line 905
  netif_addr_unlock(dev);
#line 906
  tmp___6 = arch_irqs_disabled_flags(flags);
#line 906
  if (tmp___6 != 0) {
#line 906
    arch_local_irq_restore(flags);
#line 906
    trace_hardirqs_off();
  } else {
#line 906
    trace_hardirqs_on();
#line 906
    arch_local_irq_restore(flags);
  }
#line 912
  __mptr___7 = (struct list_head  const  *)remove_list.next;
#line 912
  mcast = (struct ipoib_mcast *)__mptr___7 + 0xffffffffffffff98UL;
#line 912
  __mptr___8 = (struct list_head  const  *)mcast->list.next;
#line 912
  tmcast = (struct ipoib_mcast *)__mptr___8 + 0xffffffffffffff98UL;
#line 912
  goto ldv_50598;
  ldv_50597: 
#line 913
  tmp___7 = constant_test_bit(2L, (unsigned long const volatile   *)(& mcast->flags));
#line 913
  if (tmp___7 != 0) {
#line 914
    wait_for_completion(& mcast->done);
  } else {

  }
#line 912
  mcast = tmcast;
#line 912
  __mptr___9 = (struct list_head  const  *)tmcast->list.next;
#line 912
  tmcast = (struct ipoib_mcast *)__mptr___9 + 0xffffffffffffff98UL;
  ldv_50598: ;
#line 912
  if ((unsigned long )(& mcast->list) != (unsigned long )(& remove_list)) {
#line 914
    goto ldv_50597;
  } else {

  }
#line 916
  __mptr___10 = (struct list_head  const  *)remove_list.next;
#line 916
  mcast = (struct ipoib_mcast *)__mptr___10 + 0xffffffffffffff98UL;
#line 916
  __mptr___11 = (struct list_head  const  *)mcast->list.next;
#line 916
  tmcast = (struct ipoib_mcast *)__mptr___11 + 0xffffffffffffff98UL;
#line 916
  goto ldv_50607;
  ldv_50606: 
#line 917
  ipoib_mcast_leave(mcast->dev, mcast);
#line 918
  ipoib_mcast_free(mcast);
#line 916
  mcast = tmcast;
#line 916
  __mptr___12 = (struct list_head  const  *)tmcast->list.next;
#line 916
  tmcast = (struct ipoib_mcast *)__mptr___12 + 0xffffffffffffff98UL;
  ldv_50607: ;
#line 916
  if ((unsigned long )(& mcast->list) != (unsigned long )(& remove_list)) {
#line 918
    goto ldv_50606;
  } else {

  }
#line 924
  tmp___9 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->flags));
#line 924
  if (tmp___9 != 0) {
#line 925
    tmp___8 = spinlock_check(& priv->lock);
#line 925
    flags = _raw_spin_lock_irqsave(tmp___8);
#line 926
    __ipoib_mcast_schedule_join_thread(priv, (struct ipoib_mcast *)0, 0);
#line 927
    spin_unlock_irqrestore(& priv->lock, flags);
  } else {

  }
#line 929
  return;
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
struct ipoib_mcast_iter *ipoib_mcast_iter_init(struct net_device *dev ) 
{ 
  struct ipoib_mcast_iter *iter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 937
  tmp = kmalloc(48UL, 208U);
#line 937
  iter = (struct ipoib_mcast_iter *)tmp;
#line 938
  if ((unsigned long )iter == (unsigned long )((struct ipoib_mcast_iter *)0)) {
#line 939
    return ((struct ipoib_mcast_iter *)0);
  } else {

  }
#line 941
  iter->dev = dev;
#line 942
  memset((void *)(& iter->mgid.raw), 0, 16UL);
#line 944
  tmp___0 = ipoib_mcast_iter_next(iter);
#line 944
  if (tmp___0 != 0) {
#line 945
    kfree((void const   *)iter);
#line 946
    return ((struct ipoib_mcast_iter *)0);
  } else {

  }
#line 949
  return (iter);
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
int ipoib_mcast_iter_next(struct ipoib_mcast_iter *iter ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct rb_node *n ;
  struct ipoib_mcast *mcast ;
  int ret ;
  struct rb_node  const  *__mptr ;
  int tmp___0 ;

  {
#line 954
  tmp = netdev_priv((struct net_device  const  *)iter->dev);
#line 954
  priv = (struct ipoib_dev_priv *)tmp;
#line 957
  ret = 1;
#line 959
  spin_lock_irq(& priv->lock);
#line 961
  n = rb_first((struct rb_root  const  *)(& priv->multicast_tree));
#line 963
  goto ldv_50627;
  ldv_50626: 
#line 964
  __mptr = (struct rb_node  const  *)n;
#line 964
  mcast = (struct ipoib_mcast *)__mptr + 0xffffffffffffffb0UL;
#line 966
  tmp___0 = memcmp((void const   *)(& iter->mgid.raw), (void const   *)(& mcast->mcmember.mgid.raw),
                   16UL);
#line 966
  if (tmp___0 < 0) {
#line 968
    iter->mgid = mcast->mcmember.mgid;
#line 969
    iter->created = mcast->created;
#line 970
    iter->queuelen = skb_queue_len((struct sk_buff_head  const  *)(& mcast->pkt_queue));
#line 971
    iter->complete = (unsigned long )mcast->ah != (unsigned long )((struct ipoib_ah *)0);
#line 972
    iter->send_only = (mcast->flags & 2UL) != 0UL;
#line 974
    ret = 0;
#line 976
    goto ldv_50625;
  } else {

  }
#line 979
  n = rb_next((struct rb_node  const  *)n);
  ldv_50627: ;
#line 963
  if ((unsigned long )n != (unsigned long )((struct rb_node *)0)) {
#line 965
    goto ldv_50626;
  } else {

  }
  ldv_50625: 
#line 982
  spin_unlock_irq(& priv->lock);
#line 984
  return (ret);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c"
void ipoib_mcast_iter_read(struct ipoib_mcast_iter *iter , union ib_gid *mgid , unsigned long *created ,
                           unsigned int *queuelen , unsigned int *complete___0 , unsigned int *send_only ) 
{ 


  {
#line 994
  *mgid = iter->mgid;
#line 995
  *created = iter->created;
#line 996
  *queuelen = iter->queuelen;
#line 997
  *complete___0 = iter->complete;
#line 998
  *send_only = iter->send_only;
#line 999
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 307
  tmp = ldv_ptr_err(ptr);
#line 307
  return (tmp);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
bool ldv_queue_work_on_73(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 326
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 326
  ldv_func_res = tmp;
#line 328
  activate_work_11(ldv_func_arg3, 2);
#line 330
  return (ldv_func_res);
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
bool ldv_queue_delayed_work_on_74(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 337
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 337
  ldv_func_res = tmp;
#line 339
  activate_work_11(& ldv_func_arg3->work, 2);
#line 341
  return (ldv_func_res);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
bool ldv_queue_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 348
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 348
  ldv_func_res = tmp;
#line 350
  activate_work_11(ldv_func_arg3, 2);
#line 352
  return (ldv_func_res);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
void ldv_flush_workqueue_76(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 358
  flush_workqueue(ldv_func_arg1);
#line 360
  call_and_disable_all_11(2);
#line 361
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
bool ldv_queue_delayed_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 367
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 367
  ldv_func_res = tmp;
#line 369
  activate_work_11(& ldv_func_arg3->work, 2);
#line 371
  return (ldv_func_res);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
bool ldv_cancel_delayed_work_78(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 378
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 378
  ldv_func_res = tmp;
#line 380
  disable_work_11(& ldv_func_arg1->work);
#line 382
  return (ldv_func_res);
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
bool ldv_cancel_delayed_work_79(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
#line 389
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 389
  ldv_func_res = tmp;
#line 391
  disable_work_11(& ldv_func_arg1->work);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
bool ldv_cancel_delayed_work_80(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 400
  ldv_func_res = tmp;
#line 402
  disable_work_11(& ldv_func_arg1->work);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_multicast.o.c.prepared"
void ldv_flush_workqueue_81(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 410
  flush_workqueue(ldv_func_arg1);
#line 412
  call_and_disable_all_11(2);
#line 413
  return;
}
}
#line 41 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) ;
#line 424 "include/linux/workqueue.h"
void ldv_destroy_workqueue_100(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_102(struct workqueue_struct *ldv_func_arg1 ) ;
#line 441
bool ldv_queue_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 445
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 451
bool ldv_queue_delayed_work_on_96(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
bool ldv_queue_delayed_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 463
void ldv_flush_workqueue_98(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
void ldv_flush_workqueue_101(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___2(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_95(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 2131 "include/rdma/ib_verbs.h"
extern struct ib_pd *ib_alloc_pd(struct ib_device * ) ;
#line 2137
extern int ib_dealloc_pd(struct ib_pd * ) ;
#line 2272
extern struct ib_qp *ib_create_qp(struct ib_pd * , struct ib_qp_init_attr * ) ;
#line 2308
extern int ib_destroy_qp(struct ib_qp * ) ;
#line 2377
extern struct ib_cq *ib_create_cq(struct ib_device * , void (*)(struct ib_cq * , void * ) ,
                                  void (*)(struct ib_event * , void * ) , void * ,
                                  struct ib_cq_init_attr  const  * ) ;
#line 2405
extern int ib_destroy_cq(struct ib_cq * ) ;
#line 2494
extern struct ib_mr *ib_get_dma_mr(struct ib_pd * , int  ) ;
#line 2808
extern int ib_dereg_mr(struct ib_mr * ) ;
#line 2975
extern int ib_attach_mcast(struct ib_qp * , union ib_gid * , u16  ) ;
#line 593 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
__inline static int ipoib_cm_has_srq(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 595
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 595
  priv = (struct ipoib_dev_priv *)tmp;
#line 596
  return ((unsigned long )priv->cm.srq != (unsigned long )((struct ib_srq *)0));
}
}
#line 608
int ipoib_cm_dev_init(struct net_device *dev ) ;
#line 610
void ipoib_cm_dev_cleanup(struct net_device *dev ) ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c"
int ipoib_mcast_attach(struct net_device *dev , u16 mlid , union ib_gid *mgid , int set_qkey ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_qp_attr *qp_attr ;
  int ret ;
  u16 pkey_index ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 40
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 40
  priv = (struct ipoib_dev_priv *)tmp;
#line 41
  qp_attr = (struct ib_qp_attr *)0;
#line 45
  tmp___0 = ib_find_pkey(priv->ca, (int )priv->port, (int )priv->pkey, & pkey_index);
#line 45
  if (tmp___0 != 0) {
#line 46
    clear_bit(3L, (unsigned long volatile   *)(& priv->flags));
#line 47
    ret = -6;
#line 48
    goto out;
  } else {

  }
#line 50
  set_bit(3L, (unsigned long volatile   *)(& priv->flags));
#line 52
  if (set_qkey != 0) {
#line 53
    ret = -12;
#line 54
    tmp___1 = kmalloc(168UL, 208U);
#line 54
    qp_attr = (struct ib_qp_attr *)tmp___1;
#line 55
    if ((unsigned long )qp_attr == (unsigned long )((struct ib_qp_attr *)0)) {
#line 56
      goto out;
    } else {

    }
#line 59
    qp_attr->qkey = priv->qkey;
#line 60
    ret = ib_modify_qp(priv->qp, qp_attr, 64);
#line 61
    if (ret != 0) {
#line 62
      printk("\f%s: failed to modify QP, ret = %d\n", (char *)(& (priv->dev)->name),
             ret);
#line 63
      goto out;
    } else {

    }
  } else {

  }
#line 68
  ret = ib_attach_mcast(priv->qp, mgid, (int )mlid);
#line 69
  if (ret != 0) {
#line 70
    printk("\f%s: failed to attach to multicast group, ret = %d\n", (char *)(& (priv->dev)->name),
           ret);
  } else {

  }
  out: 
#line 73
  kfree((void const   *)qp_attr);
#line 74
  return (ret);
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c"
int ipoib_init_qp(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int ret ;
  struct ib_qp_attr qp_attr ;
  int attr_mask ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 79
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 79
  priv = (struct ipoib_dev_priv *)tmp;
#line 84
  tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->flags));
#line 84
  if (tmp___0 == 0) {
#line 85
    return (-1);
  } else {

  }
#line 87
  qp_attr.qp_state = 1;
#line 88
  qp_attr.qkey = 0U;
#line 89
  qp_attr.port_num = priv->port;
#line 90
  qp_attr.pkey_index = priv->pkey_index;
#line 91
  attr_mask = 113;
#line 96
  ret = ib_modify_qp(priv->qp, & qp_attr, attr_mask);
#line 97
  if (ret != 0) {
#line 98
    printk("\f%s: failed to modify QP to init, ret = %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 99
    goto out_fail;
  } else {

  }
#line 102
  qp_attr.qp_state = 2;
#line 104
  attr_mask = attr_mask & -33;
#line 105
  ret = ib_modify_qp(priv->qp, & qp_attr, attr_mask);
#line 106
  if (ret != 0) {
#line 107
    printk("\f%s: failed to modify QP to RTR, ret = %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 108
    goto out_fail;
  } else {

  }
#line 111
  qp_attr.qp_state = 3;
#line 112
  qp_attr.sq_psn = 0U;
#line 113
  attr_mask = attr_mask | 65536;
#line 114
  attr_mask = attr_mask & -17;
#line 115
  ret = ib_modify_qp(priv->qp, & qp_attr, attr_mask);
#line 116
  if (ret != 0) {
#line 117
    printk("\f%s: failed to modify QP to RTS, ret = %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 118
    goto out_fail;
  } else {

  }
#line 121
  return (0);
  out_fail: 
#line 124
  qp_attr.qp_state = 0;
#line 125
  tmp___1 = ib_modify_qp(priv->qp, & qp_attr, 1);
#line 125
  if (tmp___1 != 0) {
#line 126
    printk("\f%s: Failed to modify QP to RESET state\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 128
  return (ret);
}
}
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c"
int ipoib_transport_dev_init(struct net_device *dev , struct ib_device *ca ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_qp_init_attr init_attr ;
  struct ib_cq_init_attr cq_attr ;
  int ret ;
  int size ;
  int i ;
  bool tmp___0 ;
  bool tmp___1 ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
#line 133
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 133
  priv = (struct ipoib_dev_priv *)tmp;
#line 134
  init_attr.event_handler = 0;
#line 134
  init_attr.qp_context = 0;
#line 134
  init_attr.send_cq = 0;
#line 134
  init_attr.recv_cq = 0;
#line 134
  init_attr.srq = 0;
#line 134
  init_attr.xrcd = 0;
#line 134
  init_attr.cap.max_send_wr = (unsigned int )ipoib_sendq_size;
#line 134
  init_attr.cap.max_recv_wr = (unsigned int )ipoib_recvq_size;
#line 134
  init_attr.cap.max_send_sge = 1U;
#line 134
  init_attr.cap.max_recv_sge = 2U;
#line 134
  init_attr.cap.max_inline_data = 0U;
#line 134
  init_attr.sq_sig_type = 0;
#line 134
  init_attr.qp_type = 4;
#line 134
  init_attr.create_flags = 0;
#line 134
  init_attr.port_num = (unsigned char)0;
#line 144
  cq_attr.cqe = 0U;
#line 144
  cq_attr.comp_vector = 0;
#line 144
  cq_attr.flags = 0U;
#line 149
  priv->pd = ib_alloc_pd(priv->ca);
#line 150
  tmp___0 = IS_ERR((void const   *)priv->pd);
#line 150
  if ((int )tmp___0) {
#line 151
    printk("\f%s: failed to allocate PD\n", (char *)(& ca->name));
#line 152
    return (-19);
  } else {

  }
#line 155
  priv->mr = ib_get_dma_mr(priv->pd, 1);
#line 156
  tmp___1 = IS_ERR((void const   *)priv->mr);
#line 156
  if ((int )tmp___1) {
#line 157
    printk("\f%s: ib_get_dma_mr failed\n", (char *)(& ca->name));
#line 158
    goto out_free_pd;
  } else {

  }
#line 165
  __lock_name = "\"%s\"\"ipoib_wq\"";
#line 165
  tmp___2 = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)"ipoib_wq");
#line 165
  priv->wq = tmp___2;
#line 166
  if ((unsigned long )priv->wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 167
    printk("\fipoib: failed to allocate device WQ\n");
#line 168
    goto out_free_mr;
  } else {

  }
#line 171
  size = ipoib_recvq_size + 1;
#line 172
  ret = ipoib_cm_dev_init(dev);
#line 173
  if (ret == 0) {
#line 174
    size = size + ipoib_sendq_size;
#line 175
    tmp___3 = ipoib_cm_has_srq(dev);
#line 175
    if (tmp___3 != 0) {
#line 176
      size = (ipoib_recvq_size + 1) + size;
    } else {
#line 178
      size = ipoib_recvq_size * ipoib_max_conn_qp + size;
    }
  } else {
#line 180
    goto out_free_wq;
  }
#line 182
  cq_attr.cqe = (unsigned int )size;
#line 183
  priv->recv_cq = ib_create_cq(priv->ca, & ipoib_ib_completion, (void (*)(struct ib_event * ,
                                                                          void * ))0,
                               (void *)dev, (struct ib_cq_init_attr  const  *)(& cq_attr));
#line 185
  tmp___4 = IS_ERR((void const   *)priv->recv_cq);
#line 185
  if ((int )tmp___4) {
#line 186
    printk("\f%s: failed to create receive CQ\n", (char *)(& ca->name));
#line 187
    goto out_cm_dev_cleanup;
  } else {

  }
#line 190
  cq_attr.cqe = (unsigned int )ipoib_sendq_size;
#line 191
  priv->send_cq = ib_create_cq(priv->ca, & ipoib_send_comp_handler, (void (*)(struct ib_event * ,
                                                                              void * ))0,
                               (void *)dev, (struct ib_cq_init_attr  const  *)(& cq_attr));
#line 193
  tmp___5 = IS_ERR((void const   *)priv->send_cq);
#line 193
  if ((int )tmp___5) {
#line 194
    printk("\f%s: failed to create send CQ\n", (char *)(& ca->name));
#line 195
    goto out_free_recv_cq;
  } else {

  }
#line 198
  tmp___6 = ib_req_notify_cq(priv->recv_cq, 2);
#line 198
  if (tmp___6 != 0) {
#line 199
    goto out_free_send_cq;
  } else {

  }
#line 201
  init_attr.send_cq = priv->send_cq;
#line 202
  init_attr.recv_cq = priv->recv_cq;
#line 204
  if ((priv->hca_caps & 524288) != 0) {
#line 205
    init_attr.create_flags = (enum ib_qp_create_flags )((int )init_attr.create_flags | 1);
  } else {

  }
#line 207
  if ((priv->hca_caps & 4194304) != 0) {
#line 208
    init_attr.create_flags = (enum ib_qp_create_flags )((int )init_attr.create_flags | 2);
  } else {

  }
#line 210
  if ((priv->hca_caps & 536870912) != 0) {
#line 211
    init_attr.create_flags = (enum ib_qp_create_flags )((int )init_attr.create_flags | 32);
  } else {

  }
#line 213
  if ((int )dev->features & 1) {
#line 214
    init_attr.cap.max_send_sge = 18U;
  } else {

  }
#line 216
  priv->qp = ib_create_qp(priv->pd, & init_attr);
#line 217
  tmp___7 = IS_ERR((void const   *)priv->qp);
#line 217
  if ((int )tmp___7) {
#line 218
    printk("\f%s: failed to create QP\n", (char *)(& ca->name));
#line 219
    goto out_free_send_cq;
  } else {

  }
#line 222
  *((priv->dev)->dev_addr + 1UL) = (unsigned char )((priv->qp)->qp_num >> 16);
#line 223
  *((priv->dev)->dev_addr + 2UL) = (unsigned char )((priv->qp)->qp_num >> 8);
#line 224
  *((priv->dev)->dev_addr + 3UL) = (unsigned char )(priv->qp)->qp_num;
#line 226
  i = 0;
#line 226
  goto ldv_49733;
  ldv_49732: 
#line 227
  priv->tx_sge[i].lkey = (priv->mr)->lkey;
#line 226
  i = i + 1;
  ldv_49733: ;
#line 226
  if ((unsigned int )i <= 17U) {
#line 228
    goto ldv_49732;
  } else {

  }
#line 229
  priv->tx_wr.opcode = 2;
#line 230
  priv->tx_wr.sg_list = (struct ib_sge *)(& priv->tx_sge);
#line 231
  priv->tx_wr.send_flags = 2;
#line 233
  priv->rx_sge[0].lkey = (priv->mr)->lkey;
#line 235
  priv->rx_sge[0].length = priv->max_ib_mtu + 40U;
#line 236
  priv->rx_wr.num_sge = 1;
#line 238
  priv->rx_wr.next = (struct ib_recv_wr *)0;
#line 239
  priv->rx_wr.sg_list = (struct ib_sge *)(& priv->rx_sge);
#line 241
  return (0);
  out_free_send_cq: 
#line 244
  ib_destroy_cq(priv->send_cq);
  out_free_recv_cq: 
#line 247
  ib_destroy_cq(priv->recv_cq);
  out_cm_dev_cleanup: 
#line 250
  ipoib_cm_dev_cleanup(dev);
  out_free_wq: 
#line 253
  ldv_destroy_workqueue_100(priv->wq);
#line 254
  priv->wq = (struct workqueue_struct *)0;
  out_free_mr: 
#line 257
  ib_dereg_mr(priv->mr);
  out_free_pd: 
#line 260
  ib_dealloc_pd(priv->pd);
#line 262
  return (-19);
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c"
void ipoib_transport_dev_cleanup(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 267
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 267
  priv = (struct ipoib_dev_priv *)tmp;
#line 269
  if ((unsigned long )priv->qp != (unsigned long )((struct ib_qp *)0)) {
#line 270
    tmp___0 = ib_destroy_qp(priv->qp);
#line 270
    if (tmp___0 != 0) {
#line 271
      printk("\f%s: ib_qp_destroy failed\n", (char *)(& (priv->dev)->name));
    } else {

    }
#line 273
    priv->qp = (struct ib_qp *)0;
#line 274
    clear_bit(3L, (unsigned long volatile   *)(& priv->flags));
  } else {

  }
#line 277
  tmp___1 = ib_destroy_cq(priv->send_cq);
#line 277
  if (tmp___1 != 0) {
#line 278
    printk("\f%s: ib_cq_destroy (send) failed\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 280
  tmp___2 = ib_destroy_cq(priv->recv_cq);
#line 280
  if (tmp___2 != 0) {
#line 281
    printk("\f%s: ib_cq_destroy (recv) failed\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 283
  ipoib_cm_dev_cleanup(dev);
#line 285
  if ((unsigned long )priv->wq != (unsigned long )((struct workqueue_struct *)0)) {
#line 286
    ldv_flush_workqueue_101(priv->wq);
#line 287
    ldv_destroy_workqueue_102(priv->wq);
#line 288
    priv->wq = (struct workqueue_struct *)0;
  } else {

  }
#line 291
  tmp___3 = ib_dereg_mr(priv->mr);
#line 291
  if (tmp___3 != 0) {
#line 292
    printk("\f%s: ib_dereg_mr failed\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 294
  tmp___4 = ib_dealloc_pd(priv->pd);
#line 294
  if (tmp___4 != 0) {
#line 295
    printk("\f%s: ib_dealloc_pd failed\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 296
  return;
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c"
void ipoib_event(struct ib_event_handler *handler , struct ib_event *record ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct ib_event_handler  const  *__mptr ;

  {
#line 303
  __mptr = (struct ib_event_handler  const  *)handler;
#line 303
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff160UL;
#line 305
  if ((int )record->element.port_num != (int )priv->port) {
#line 306
    return;
  } else {

  }
#line 308
  if (ipoib_debug_level > 0) {
#line 308
    printk("\017%s: Event %d on device %s port %d\n", (char *)(& (priv->dev)->name),
           (unsigned int )record->event, (char *)(& (record->device)->name), (int )record->element.port_num);
  } else {

  }
#line 311
  if ((unsigned int )record->event == 13U || (unsigned int )record->event == 17U) {
#line 313
    queue_work___2(ipoib_workqueue, & priv->flush_light);
  } else
#line 314
  if (((unsigned int )record->event == 10U || (unsigned int )record->event == 9U) || (unsigned int )record->event == 11U) {
#line 317
    queue_work___2(ipoib_workqueue, & priv->flush_normal);
  } else
#line 318
  if ((unsigned int )record->event == 12U) {
#line 319
    queue_work___2(ipoib_workqueue, & priv->flush_heavy);
  } else {

  }
#line 320
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.o.c.prepared"
bool ldv_queue_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 326
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 326
  ldv_func_res = tmp;
#line 328
  activate_work_11(ldv_func_arg3, 2);
#line 330
  return (ldv_func_res);
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.o.c.prepared"
bool ldv_queue_delayed_work_on_96(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 337
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 337
  ldv_func_res = tmp;
#line 339
  activate_work_11(& ldv_func_arg3->work, 2);
#line 341
  return (ldv_func_res);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.o.c.prepared"
bool ldv_queue_work_on_97(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 348
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 348
  ldv_func_res = tmp;
#line 350
  activate_work_11(ldv_func_arg3, 2);
#line 352
  return (ldv_func_res);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.o.c.prepared"
void ldv_flush_workqueue_98(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 358
  flush_workqueue(ldv_func_arg1);
#line 360
  call_and_disable_all_11(2);
#line 361
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.o.c.prepared"
bool ldv_queue_delayed_work_on_99(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 367
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 367
  ldv_func_res = tmp;
#line 369
  activate_work_11(& ldv_func_arg3->work, 2);
#line 371
  return (ldv_func_res);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.o.c.prepared"
void ldv_destroy_workqueue_100(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 377
  destroy_workqueue(ldv_func_arg1);
#line 379
  call_and_disable_all_11(2);
#line 380
  return;
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.o.c.prepared"
void ldv_flush_workqueue_101(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 385
  flush_workqueue(ldv_func_arg1);
#line 387
  call_and_disable_all_11(2);
#line 388
  return;
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_verbs.o.c.prepared"
void ldv_destroy_workqueue_102(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 393
  destroy_workqueue(ldv_func_arg1);
#line 395
  call_and_disable_all_11(2);
#line 396
  return;
}
}
#line 405 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3129: ;
#line 14
  return (pfo_ret__);
}
}
#line 69 "include/linux/thread_info.h"
__inline static void set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 


  {
#line 71
  set_bit((long )flag, (unsigned long volatile   *)(& ti->flags));
#line 72
  return;
}
}
#line 118 "include/linux/rwsem.h"
extern void down_write(struct rw_semaphore * ) ;
#line 133
extern void up_write(struct rw_semaphore * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_115(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_116(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_118(struct workqueue_struct *ldv_func_arg1 ) ;
#line 215 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 2801 "include/linux/sched.h"
__inline static void set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 


  {
#line 2803
  set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2804
  return;
}
}
#line 2841 "include/linux/sched.h"
__inline static int restart_syscall(void) 
{ 
  struct task_struct *tmp ;

  {
#line 2843
  tmp = get_current();
#line 2843
  set_tsk_thread_flag(tmp, 2);
#line 2844
  return (-513);
}
}
#line 2193 "include/linux/netdevice.h"
extern int register_netdevice(struct net_device * ) ;
#line 2196 "include/linux/netdevice.h"
__inline static void unregister_netdevice(struct net_device *dev ) 
{ 


  {
#line 2198
  unregister_netdevice_queue(dev, (struct list_head *)0);
#line 2199
  return;
}
}
#line 2205
void ldv_free_netdev_120(struct net_device *dev ) ;
#line 2209
void ldv_free_netdev_121(struct net_device *dev ) ;
#line 536 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/infiniband/ulp/ipoib/ipoib.h"
int __ipoib_vlan_add(struct ipoib_dev_priv *ppriv , struct ipoib_dev_priv *priv ,
                     u16 pkey , int type ) ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c"
static ssize_t show_parent(struct device *d , struct device_attribute *attr , char *buf ) 
{ 
  struct net_device *dev ;
  struct device  const  *__mptr ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int tmp___0 ;

  {
#line 45
  __mptr = (struct device  const  *)d;
#line 45
  dev = (struct net_device *)__mptr + 0xfffffffffffffaa0UL;
#line 46
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 46
  priv = (struct ipoib_dev_priv *)tmp;
#line 48
  tmp___0 = sprintf(buf, "%s\n", (char *)(& (priv->parent)->name));
#line 48
  return ((ssize_t )tmp___0);
}
}
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c"
static struct device_attribute dev_attr_parent  =    {{"parent", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & show_parent,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c"
int __ipoib_vlan_add(struct ipoib_dev_priv *ppriv , struct ipoib_dev_priv *priv ,
                     u16 pkey , int type ) 
{ 
  int result ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 57
  priv->max_ib_mtu = ppriv->max_ib_mtu;
#line 59
  (priv->dev)->mtu = priv->max_ib_mtu - 4U;
#line 60
  tmp = (priv->dev)->mtu;
#line 60
  priv->admin_mtu = tmp;
#line 60
  priv->mcast_mtu = tmp;
#line 61
  priv->parent = ppriv->dev;
#line 62
  set_bit(5L, (unsigned long volatile   *)(& priv->flags));
#line 64
  result = ipoib_set_dev_features(priv, ppriv->ca);
#line 65
  if (result != 0) {
#line 66
    goto err;
  } else {

  }
#line 68
  priv->pkey = pkey;
#line 70
  memcpy((void *)(priv->dev)->dev_addr, (void const   *)(ppriv->dev)->dev_addr,
           20UL);
#line 71
  (priv->dev)->broadcast[8] = (unsigned char )((int )pkey >> 8);
#line 72
  (priv->dev)->broadcast[9] = (unsigned char )pkey;
#line 74
  result = ipoib_dev_init(priv->dev, ppriv->ca, (int )ppriv->port);
#line 75
  if (result < 0) {
#line 76
    printk("\f%s: failed to initialize subinterface: device %s, port %d", (char *)(& (ppriv->dev)->name),
           (char *)(& (ppriv->ca)->name), (int )ppriv->port);
#line 79
    goto err;
  } else {

  }
#line 82
  result = register_netdevice(priv->dev);
#line 83
  if (result != 0) {
#line 84
    printk("\f%s: failed to initialize; error %i", (char *)(& (priv->dev)->name),
           result);
#line 85
    goto register_failed;
  } else {

  }
#line 88
  ipoib_create_debug_files(priv->dev);
#line 91
  if (type == 1) {
#line 92
    tmp___0 = ipoib_cm_add_mode_attr(priv->dev);
#line 92
    if (tmp___0 != 0) {
#line 93
      goto sysfs_failed;
    } else {

    }
#line 94
    tmp___1 = ipoib_add_pkey_attr(priv->dev);
#line 94
    if (tmp___1 != 0) {
#line 95
      goto sysfs_failed;
    } else {

    }
#line 96
    tmp___2 = ipoib_add_umcast_attr(priv->dev);
#line 96
    if (tmp___2 != 0) {
#line 97
      goto sysfs_failed;
    } else {

    }
#line 99
    tmp___3 = device_create_file(& (priv->dev)->dev, (struct device_attribute  const  *)(& dev_attr_parent));
#line 99
    if (tmp___3 != 0) {
#line 100
      goto sysfs_failed;
    } else {

    }
  } else {

  }
#line 103
  priv->child_type = type;
#line 104
  list_add_tail(& priv->list, & ppriv->child_intfs);
#line 106
  return (0);
  sysfs_failed: 
#line 109
  result = -12;
#line 110
  ipoib_delete_debug_files(priv->dev);
#line 111
  unregister_netdevice(priv->dev);
  register_failed: 
#line 114
  ipoib_dev_cleanup(priv->dev);
  err: ;
#line 117
  return (result);
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c"
int ipoib_vlan_add(struct net_device *pdev , unsigned short pkey ) 
{ 
  struct ipoib_dev_priv *ppriv ;
  struct ipoib_dev_priv *priv ;
  char intf_name[16U] ;
  struct ipoib_dev_priv *tpriv ;
  int result ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 127
  tmp = capable(12);
#line 127
  if (tmp) {
#line 127
    tmp___0 = 0;
  } else {
#line 127
    tmp___0 = 1;
  }
#line 127
  if (tmp___0) {
#line 128
    return (-1);
  } else {

  }
#line 130
  tmp___1 = netdev_priv((struct net_device  const  *)pdev);
#line 130
  ppriv = (struct ipoib_dev_priv *)tmp___1;
#line 132
  snprintf((char *)(& intf_name), 16UL, "%s.%04x", (char *)(& (ppriv->dev)->name),
           (int )pkey);
#line 134
  priv = ipoib_intf_alloc((char const   *)(& intf_name));
#line 135
  if ((unsigned long )priv == (unsigned long )((struct ipoib_dev_priv *)0)) {
#line 136
    return (-12);
  } else {

  }
#line 138
  tmp___3 = rtnl_trylock();
#line 138
  if (tmp___3 == 0) {
#line 139
    tmp___2 = restart_syscall();
#line 139
    return (tmp___2);
  } else {

  }
#line 141
  down_write(& ppriv->vlan_rwsem);
#line 148
  if ((int )ppriv->pkey == (int )pkey) {
#line 149
    result = -76;
#line 150
    goto out;
  } else {

  }
#line 153
  __mptr = (struct list_head  const  *)ppriv->child_intfs.next;
#line 153
  tpriv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff128UL;
#line 153
  goto ldv_49737;
  ldv_49736: ;
#line 154
  if ((int )tpriv->pkey == (int )pkey && tpriv->child_type == 1) {
#line 156
    result = -76;
#line 157
    goto out;
  } else {

  }
#line 153
  __mptr___0 = (struct list_head  const  *)tpriv->list.next;
#line 153
  tpriv = (struct ipoib_dev_priv *)__mptr___0 + 0xfffffffffffff128UL;
  ldv_49737: ;
#line 153
  if ((unsigned long )(& tpriv->list) != (unsigned long )(& ppriv->child_intfs)) {
#line 155
    goto ldv_49736;
  } else {

  }
#line 161
  result = __ipoib_vlan_add(ppriv, priv, (int )pkey, 1);
  out: 
#line 164
  up_write(& ppriv->vlan_rwsem);
#line 166
  if (result != 0) {
#line 167
    ldv_free_netdev_120(priv->dev);
  } else {

  }
#line 169
  rtnl_unlock();
#line 171
  return (result);
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c"
int ipoib_vlan_delete(struct net_device *pdev , unsigned short pkey ) 
{ 
  struct ipoib_dev_priv *ppriv ;
  struct ipoib_dev_priv *priv ;
  struct ipoib_dev_priv *tpriv ;
  struct net_device *dev ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 177
  dev = (struct net_device *)0;
#line 179
  tmp = capable(12);
#line 179
  if (tmp) {
#line 179
    tmp___0 = 0;
  } else {
#line 179
    tmp___0 = 1;
  }
#line 179
  if (tmp___0) {
#line 180
    return (-1);
  } else {

  }
#line 182
  tmp___1 = netdev_priv((struct net_device  const  *)pdev);
#line 182
  ppriv = (struct ipoib_dev_priv *)tmp___1;
#line 184
  tmp___3 = rtnl_trylock();
#line 184
  if (tmp___3 == 0) {
#line 185
    tmp___2 = restart_syscall();
#line 185
    return (tmp___2);
  } else {

  }
#line 187
  down_write(& ppriv->vlan_rwsem);
#line 188
  __mptr = (struct list_head  const  *)ppriv->child_intfs.next;
#line 188
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff128UL;
#line 188
  __mptr___0 = (struct list_head  const  *)priv->list.next;
#line 188
  tpriv = (struct ipoib_dev_priv *)__mptr___0 + 0xfffffffffffff128UL;
#line 188
  goto ldv_49755;
  ldv_49754: ;
#line 189
  if ((int )priv->pkey == (int )pkey && priv->child_type == 1) {
#line 191
    unregister_netdevice(priv->dev);
#line 192
    list_del(& priv->list);
#line 193
    dev = priv->dev;
#line 194
    goto ldv_49753;
  } else {

  }
#line 188
  priv = tpriv;
#line 188
  __mptr___1 = (struct list_head  const  *)tpriv->list.next;
#line 188
  tpriv = (struct ipoib_dev_priv *)__mptr___1 + 0xfffffffffffff128UL;
  ldv_49755: ;
#line 188
  if ((unsigned long )(& priv->list) != (unsigned long )(& ppriv->child_intfs)) {
#line 190
    goto ldv_49754;
  } else {

  }
  ldv_49753: 
#line 197
  up_write(& ppriv->vlan_rwsem);
#line 199
  rtnl_unlock();
#line 201
  if ((unsigned long )dev != (unsigned long )((struct net_device *)0)) {
#line 202
    ldv_free_netdev_121(dev);
#line 203
    return (0);
  } else {

  }
#line 206
  return (-19);
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.o.c.prepared"
void ldv_main_exported_23(void) 
{ 
  struct device *ldvarg12 ;
  void *tmp ;
  char *ldvarg13 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg14 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 300
  tmp = ldv_init_zalloc(1416UL);
#line 300
  ldvarg12 = (struct device *)tmp;
#line 301
  tmp___0 = ldv_init_zalloc(1UL);
#line 301
  ldvarg13 = (char *)tmp___0;
#line 302
  tmp___1 = ldv_init_zalloc(48UL);
#line 302
  ldvarg14 = (struct device_attribute *)tmp___1;
#line 304
  tmp___2 = __VERIFIER_nondet_int();
#line 304
  switch (tmp___2) {
  case 0: ;
#line 307
  if (ldv_state_variable_23 == 1) {
#line 309
    show_parent(ldvarg12, ldvarg14, ldvarg13);
#line 311
    ldv_state_variable_23 = 1;
  } else {

  }
#line 314
  goto ldv_49763;
  default: 
#line 315
  ldv_stop();
  }
  ldv_49763: ;
#line 319
  return;
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.o.c.prepared"
bool ldv_queue_work_on_115(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 348
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 348
  ldv_func_res = tmp;
#line 350
  activate_work_11(ldv_func_arg3, 2);
#line 352
  return (ldv_func_res);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.o.c.prepared"
bool ldv_queue_delayed_work_on_116(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 359
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 359
  ldv_func_res = tmp;
#line 361
  activate_work_11(& ldv_func_arg3->work, 2);
#line 363
  return (ldv_func_res);
}
}
#line 366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.o.c.prepared"
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 370
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 370
  ldv_func_res = tmp;
#line 372
  activate_work_11(ldv_func_arg3, 2);
#line 374
  return (ldv_func_res);
}
}
#line 377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.o.c.prepared"
void ldv_flush_workqueue_118(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 380
  flush_workqueue(ldv_func_arg1);
#line 382
  call_and_disable_all_11(2);
#line 383
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.o.c.prepared"
bool ldv_queue_delayed_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 389
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 389
  ldv_func_res = tmp;
#line 391
  activate_work_11(& ldv_func_arg3->work, 2);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.o.c.prepared"
void ldv_free_netdev_120(struct net_device *dev ) 
{ 


  {
#line 399
  free_netdev(dev);
#line 401
  ldv_state_variable_28 = 0;
#line 402
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_vlan.o.c.prepared"
void ldv_free_netdev_121(struct net_device *dev ) 
{ 


  {
#line 407
  free_netdev(dev);
#line 409
  ldv_state_variable_28 = 0;
#line 410
  return;
}
}
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_134(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_136(struct workqueue_struct *ldv_func_arg1 ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 2399 "include/rdma/ib_verbs.h"
extern int ib_modify_cq(struct ib_cq * , u16  , u16  ) ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c"
static void ipoib_get_drvinfo(struct net_device *netdev , struct ethtool_drvinfo *drvinfo ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_device_attr *attr ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 42
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 42
  priv = (struct ipoib_dev_priv *)tmp;
#line 45
  tmp___0 = kmalloc(224UL, 208U);
#line 45
  attr = (struct ib_device_attr *)tmp___0;
#line 46
  if ((unsigned long )attr != (unsigned long )((struct ib_device_attr *)0)) {
#line 46
    tmp___1 = ib_query_device(priv->ca, attr);
#line 46
    if (tmp___1 == 0) {
#line 47
      snprintf((char *)(& drvinfo->fw_version), 32UL, "%d.%d.%d", (int )(attr->fw_ver >> 32),
               (int )(attr->fw_ver >> 16) & 65535, (int )attr->fw_ver & 65535);
    } else {

    }
  } else {

  }
#line 51
  kfree((void const   *)attr);
#line 53
  tmp___2 = dev_name((struct device  const  *)(priv->ca)->dma_device);
#line 53
  strlcpy((char *)(& drvinfo->bus_info), tmp___2, 32UL);
#line 56
  strlcpy((char *)(& drvinfo->version), (char const   *)(& ipoib_driver_version),
          32UL);
#line 59
  strlcpy((char *)(& drvinfo->driver), "ib_ipoib", 32UL);
#line 60
  return;
}
}
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c"
static int ipoib_get_coalesce(struct net_device *dev , struct ethtool_coalesce *coal ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 65
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 65
  priv = (struct ipoib_dev_priv *)tmp;
#line 67
  coal->rx_coalesce_usecs = (__u32 )priv->ethtool.coalesce_usecs;
#line 68
  coal->rx_max_coalesced_frames = (__u32 )priv->ethtool.max_coalesced_frames;
#line 70
  return (0);
}
}
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c"
static int ipoib_set_coalesce(struct net_device *dev , struct ethtool_coalesce *coal ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int ret ;

  {
#line 76
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 76
  priv = (struct ipoib_dev_priv *)tmp;
#line 83
  if (coal->rx_coalesce_usecs > 65535U || coal->rx_max_coalesced_frames > 65535U) {
#line 85
    return (-22);
  } else {

  }
#line 87
  ret = ib_modify_cq(priv->recv_cq, (int )((u16 )coal->rx_max_coalesced_frames), (int )((u16 )coal->rx_coalesce_usecs));
#line 89
  if (ret != 0 && ret != -38) {
#line 90
    printk("\f%s: failed modifying CQ (%d)\n", (char *)(& (priv->dev)->name), ret);
#line 91
    return (ret);
  } else {

  }
#line 94
  priv->ethtool.coalesce_usecs = (u16 )coal->rx_coalesce_usecs;
#line 95
  priv->ethtool.max_coalesced_frames = (u16 )coal->rx_max_coalesced_frames;
#line 97
  return (0);
}
}
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c"
static struct ethtool_ops  const  ipoib_ethtool_ops  = 
#line 100
     {0, 0, & ipoib_get_drvinfo, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ipoib_get_coalesce,
    & ipoib_set_coalesce, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c"
void ipoib_set_ethtool_ops(struct net_device *dev ) 
{ 


  {
#line 108
  dev->ethtool_ops = & ipoib_ethtool_ops;
#line 109
  return;
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.o.c.prepared"
void ldv_initialize_ethtool_ops_22(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 300
  tmp = ldv_init_zalloc(92UL);
#line 300
  ipoib_ethtool_ops_group0 = (struct ethtool_coalesce *)tmp;
#line 301
  tmp___0 = ldv_init_zalloc(3008UL);
#line 301
  ipoib_ethtool_ops_group1 = (struct net_device *)tmp___0;
#line 302
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.o.c.prepared"
void ldv_main_exported_22(void) 
{ 
  struct ethtool_drvinfo *ldvarg6 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 305
  tmp = ldv_init_zalloc(196UL);
#line 305
  ldvarg6 = (struct ethtool_drvinfo *)tmp;
#line 307
  tmp___0 = __VERIFIER_nondet_int();
#line 307
  switch (tmp___0) {
  case 0: ;
#line 310
  if (ldv_state_variable_22 == 1) {
#line 312
    ipoib_set_coalesce(ipoib_ethtool_ops_group1, ipoib_ethtool_ops_group0);
#line 314
    ldv_state_variable_22 = 1;
  } else {

  }
#line 317
  goto ldv_49711;
  case 1: ;
#line 320
  if (ldv_state_variable_22 == 1) {
#line 322
    ipoib_get_drvinfo(ipoib_ethtool_ops_group1, ldvarg6);
#line 324
    ldv_state_variable_22 = 1;
  } else {

  }
#line 327
  goto ldv_49711;
  case 2: ;
#line 330
  if (ldv_state_variable_22 == 1) {
#line 332
    ipoib_get_coalesce(ipoib_ethtool_ops_group1, ipoib_ethtool_ops_group0);
#line 334
    ldv_state_variable_22 = 1;
  } else {

  }
#line 337
  goto ldv_49711;
  default: 
#line 338
  ldv_stop();
  }
  ldv_49711: ;
#line 342
  return;
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.o.c.prepared"
bool ldv_queue_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 371
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 371
  ldv_func_res = tmp;
#line 373
  activate_work_11(ldv_func_arg3, 2);
#line 375
  return (ldv_func_res);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.o.c.prepared"
bool ldv_queue_delayed_work_on_134(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 382
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 382
  ldv_func_res = tmp;
#line 384
  activate_work_11(& ldv_func_arg3->work, 2);
#line 386
  return (ldv_func_res);
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.o.c.prepared"
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 393
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 393
  ldv_func_res = tmp;
#line 395
  activate_work_11(ldv_func_arg3, 2);
#line 397
  return (ldv_func_res);
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.o.c.prepared"
void ldv_flush_workqueue_136(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 403
  flush_workqueue(ldv_func_arg1);
#line 405
  call_and_disable_all_11(2);
#line 406
  return;
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.o.c.prepared"
bool ldv_queue_delayed_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 412
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 412
  ldv_func_res = tmp;
#line 414
  activate_work_11(& ldv_func_arg3->work, 2);
#line 416
  return (ldv_func_res);
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_147(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_148(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_151(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_150(struct workqueue_struct *ldv_func_arg1 ) ;
#line 2214 "include/linux/netdevice.h"
extern struct net_device *__dev_get_by_index(struct net * , int  ) ;
#line 253 "include/net/netlink.h"
extern int nla_put(struct sk_buff * , int  , int  , void const   * ) ;
#line 633 "include/net/netlink.h"
__inline static int nla_attr_size(int payload ) 
{ 


  {
#line 635
  return (payload + 4);
}
}
#line 642 "include/net/netlink.h"
__inline static int nla_total_size(int payload ) 
{ 
  int tmp ;

  {
#line 644
  tmp = nla_attr_size(payload);
#line 644
  return ((tmp + 3) & -4);
}
}
#line 669 "include/net/netlink.h"
__inline static void *nla_data(struct nlattr  const  *nla ) 
{ 


  {
#line 671
  return ((void *)nla + 4U);
}
}
#line 757 "include/net/netlink.h"
__inline static int nla_put_u16(struct sk_buff *skb , int attrtype , u16 value ) 
{ 
  int tmp ;

  {
#line 759
  tmp = nla_put(skb, attrtype, 2, (void const   *)(& value));
#line 759
  return (tmp);
}
}
#line 992 "include/net/netlink.h"
__inline static u32 nla_get_u32(struct nlattr  const  *nla ) 
{ 
  void *tmp ;

  {
#line 994
  tmp = nla_data(nla);
#line 994
  return (*((u32 *)tmp));
}
}
#line 1010 "include/net/netlink.h"
__inline static u16 nla_get_u16(struct nlattr  const  *nla ) 
{ 
  void *tmp ;

  {
#line 1012
  tmp = nla_data(nla);
#line 1012
  return (*((u16 *)tmp));
}
}
#line 103 "include/net/rtnetlink.h"
extern int rtnl_link_register(struct rtnl_link_ops * ) ;
#line 104
extern void rtnl_link_unregister(struct rtnl_link_ops * ) ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
static struct nla_policy  const  ipoib_policy[4U]  = {      {(unsigned short)0, (unsigned short)0}, 
        {2U, (unsigned short)0}, 
        {2U, (unsigned short)0}, 
        {2U, (unsigned short)0}};
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
static int ipoib_fill_info(struct sk_buff *skb , struct net_device  const  *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  u16 val ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 47
  tmp = netdev_priv(dev);
#line 47
  priv = (struct ipoib_dev_priv *)tmp;
#line 50
  tmp___0 = nla_put_u16(skb, 1, (int )priv->pkey);
#line 50
  if (tmp___0 != 0) {
#line 51
    goto nla_put_failure;
  } else {

  }
#line 53
  tmp___1 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->flags));
#line 53
  val = (u16 )tmp___1;
#line 54
  tmp___2 = nla_put_u16(skb, 2, (int )val);
#line 54
  if (tmp___2 != 0) {
#line 55
    goto nla_put_failure;
  } else {

  }
#line 57
  tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->flags));
#line 57
  val = (u16 )tmp___3;
#line 58
  tmp___4 = nla_put_u16(skb, 3, (int )val);
#line 58
  if (tmp___4 != 0) {
#line 59
    goto nla_put_failure;
  } else {

  }
#line 61
  return (0);
  nla_put_failure: ;
#line 64
  return (-90);
}
}
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
static int ipoib_changelink(struct net_device *dev , struct nlattr **tb , struct nlattr **data ) 
{ 
  u16 mode ;
  u16 umcast ;
  int ret ;

  {
#line 71
  ret = 0;
#line 73
  if ((unsigned long )*(data + 2UL) != (unsigned long )((struct nlattr *)0)) {
#line 74
    mode = nla_get_u16((struct nlattr  const  *)*(data + 2UL));
#line 75
    if ((unsigned int )mode == 0U) {
#line 76
      ret = ipoib_set_mode(dev, "datagram\n");
    } else
#line 77
    if ((unsigned int )mode == 1U) {
#line 78
      ret = ipoib_set_mode(dev, "connected\n");
    } else {
#line 80
      ret = -22;
    }
#line 82
    if (ret < 0) {
#line 83
      goto out_err;
    } else {

    }
  } else {

  }
#line 86
  if ((unsigned long )*(data + 3UL) != (unsigned long )((struct nlattr *)0)) {
#line 87
    umcast = nla_get_u16((struct nlattr  const  *)*(data + 3UL));
#line 88
    ipoib_set_umcast(dev, (int )umcast);
  } else {

  }
  out_err: ;
#line 92
  return (ret);
}
}
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
static int ipoib_new_child_link(struct net *src_net , struct net_device *dev , struct nlattr **tb ,
                                struct nlattr **data ) 
{ 
  struct net_device *pdev ;
  struct ipoib_dev_priv *ppriv ;
  u16 child_pkey ;
  int err ;
  u32 tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 103
  if ((unsigned long )*(tb + 5UL) == (unsigned long )((struct nlattr *)0)) {
#line 104
    return (-22);
  } else {

  }
#line 106
  tmp = nla_get_u32((struct nlattr  const  *)*(tb + 5UL));
#line 106
  pdev = __dev_get_by_index(src_net, (int )tmp);
#line 107
  if ((unsigned long )pdev == (unsigned long )((struct net_device *)0) || (unsigned int )pdev->type != 32U) {
#line 108
    return (-19);
  } else {

  }
#line 110
  tmp___0 = netdev_priv((struct net_device  const  *)pdev);
#line 110
  ppriv = (struct ipoib_dev_priv *)tmp___0;
#line 112
  tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& ppriv->flags));
#line 112
  if (tmp___1 != 0) {
#line 113
    printk("\f%s: child creation disallowed for child devices\n", (char *)(& (ppriv->dev)->name));
#line 114
    return (-22);
  } else {

  }
#line 117
  if ((unsigned long )data == (unsigned long )((struct nlattr **)0) || (unsigned long )*(data + 1UL) == (unsigned long )((struct nlattr *)0)) {
#line 118
    if (ipoib_debug_level > 0) {
#line 118
      printk("\017%s: no pkey specified, using parent pkey\n", (char *)(& (ppriv->dev)->name));
    } else {

    }
#line 119
    child_pkey = ppriv->pkey;
  } else {
#line 121
    child_pkey = nla_get_u16((struct nlattr  const  *)*(data + 1UL));
  }
#line 123
  if ((unsigned int )child_pkey == 0U || (unsigned int )child_pkey == 32768U) {
#line 124
    return (-22);
  } else {

  }
#line 130
  child_pkey = (u16 )((unsigned int )child_pkey | 32768U);
#line 132
  tmp___2 = netdev_priv((struct net_device  const  *)dev);
#line 132
  err = __ipoib_vlan_add(ppriv, (struct ipoib_dev_priv *)tmp___2, (int )child_pkey,
                         2);
#line 134
  if (err == 0 && (unsigned long )data != (unsigned long )((struct nlattr **)0)) {
#line 135
    err = ipoib_changelink(dev, tb, data);
  } else {

  }
#line 136
  return (err);
}
}
#line 139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
static void ipoib_unregister_child_dev(struct net_device *dev , struct list_head *head ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct ipoib_dev_priv *ppriv ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 143
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 143
  priv = (struct ipoib_dev_priv *)tmp;
#line 144
  tmp___0 = netdev_priv((struct net_device  const  *)priv->parent);
#line 144
  ppriv = (struct ipoib_dev_priv *)tmp___0;
#line 146
  down_write(& ppriv->vlan_rwsem);
#line 147
  unregister_netdevice_queue(dev, head);
#line 148
  list_del(& priv->list);
#line 149
  up_write(& ppriv->vlan_rwsem);
#line 150
  return;
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
static size_t ipoib_get_size(struct net_device  const  *dev ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 154
  tmp = nla_total_size(2);
#line 154
  tmp___0 = nla_total_size(2);
#line 154
  tmp___1 = nla_total_size(2);
#line 154
  return ((size_t )((tmp + tmp___0) + tmp___1));
}
}
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
static struct rtnl_link_ops ipoib_link_ops  = 
#line 159
     {{0, 0}, "ipoib", 5328UL, & ipoib_setup, 3, (struct nla_policy  const  *)(& ipoib_policy),
    0, & ipoib_new_child_link, & ipoib_changelink, & ipoib_unregister_child_dev, & ipoib_get_size,
    & ipoib_fill_info, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 172 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
int ipoib_netlink_init(void) 
{ 
  int tmp ;

  {
#line 174
  tmp = rtnl_link_register(& ipoib_link_ops);
#line 174
  return (tmp);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c"
void ipoib_netlink_fini(void) 
{ 


  {
#line 179
  rtnl_link_unregister(& ipoib_link_ops);
#line 180
  return;
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.o.c.prepared"
extern int ldv_release_21(void) ;
#line 299
extern int ldv_init_21(void) ;
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.o.c.prepared"
void ldv_initialize_rtnl_link_ops_21(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 303
  tmp = ldv_init_zalloc(3008UL);
#line 303
  ipoib_link_ops_group0 = (struct net_device  const  *)tmp;
#line 304
  tmp___0 = ldv_init_zalloc(3008UL);
#line 304
  ipoib_link_ops_group2 = (struct net_device *)tmp___0;
#line 305
  tmp___1 = ldv_init_zalloc(8UL);
#line 305
  ipoib_link_ops_group1 = (struct nlattr **)tmp___1;
#line 306
  tmp___2 = ldv_init_zalloc(8UL);
#line 306
  ipoib_link_ops_group3 = (struct nlattr **)tmp___2;
#line 307
  return;
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.o.c.prepared"
void ldv_main_exported_21(void) 
{ 
  struct sk_buff *ldvarg2 ;
  void *tmp ;
  struct net *ldvarg0 ;
  void *tmp___0 ;
  struct list_head *ldvarg1 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 310
  tmp = ldv_init_zalloc(232UL);
#line 310
  ldvarg2 = (struct sk_buff *)tmp;
#line 311
  tmp___0 = ldv_init_zalloc(7104UL);
#line 311
  ldvarg0 = (struct net *)tmp___0;
#line 312
  tmp___1 = ldv_init_zalloc(16UL);
#line 312
  ldvarg1 = (struct list_head *)tmp___1;
#line 314
  tmp___2 = __VERIFIER_nondet_int();
#line 314
  switch (tmp___2) {
  case 0: ;
#line 317
  if (ldv_state_variable_21 == 1) {
#line 319
    ipoib_fill_info(ldvarg2, ipoib_link_ops_group0);
#line 321
    ldv_state_variable_21 = 1;
  } else {

  }
#line 324
  if (ldv_state_variable_21 == 3) {
#line 326
    ipoib_fill_info(ldvarg2, ipoib_link_ops_group0);
#line 328
    ldv_state_variable_21 = 3;
  } else {

  }
#line 331
  if (ldv_state_variable_21 == 2) {
#line 333
    ipoib_fill_info(ldvarg2, ipoib_link_ops_group0);
#line 335
    ldv_state_variable_21 = 2;
  } else {

  }
#line 338
  goto ldv_49765;
  case 1: ;
#line 341
  if (ldv_state_variable_21 == 1) {
#line 343
    ipoib_get_size(ipoib_link_ops_group0);
#line 345
    ldv_state_variable_21 = 1;
  } else {

  }
#line 348
  if (ldv_state_variable_21 == 3) {
#line 350
    ipoib_get_size(ipoib_link_ops_group0);
#line 352
    ldv_state_variable_21 = 3;
  } else {

  }
#line 355
  if (ldv_state_variable_21 == 2) {
#line 357
    ipoib_get_size(ipoib_link_ops_group0);
#line 359
    ldv_state_variable_21 = 2;
  } else {

  }
#line 362
  goto ldv_49765;
  case 2: ;
#line 365
  if (ldv_state_variable_21 == 1) {
#line 367
    ipoib_setup(ipoib_link_ops_group2);
#line 369
    ldv_state_variable_21 = 2;
#line 370
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 373
  goto ldv_49765;
  case 3: ;
#line 376
  if (ldv_state_variable_21 == 1) {
#line 378
    ipoib_unregister_child_dev(ipoib_link_ops_group2, ldvarg1);
#line 380
    ldv_state_variable_21 = 1;
  } else {

  }
#line 383
  if (ldv_state_variable_21 == 3) {
#line 385
    ipoib_unregister_child_dev(ipoib_link_ops_group2, ldvarg1);
#line 387
    ldv_state_variable_21 = 3;
  } else {

  }
#line 390
  if (ldv_state_variable_21 == 2) {
#line 392
    ipoib_unregister_child_dev(ipoib_link_ops_group2, ldvarg1);
#line 394
    ldv_state_variable_21 = 2;
  } else {

  }
#line 397
  goto ldv_49765;
  case 4: ;
#line 400
  if (ldv_state_variable_21 == 1) {
#line 402
    ipoib_new_child_link(ldvarg0, ipoib_link_ops_group2, ipoib_link_ops_group1, ipoib_link_ops_group3);
#line 404
    ldv_state_variable_21 = 1;
  } else {

  }
#line 407
  if (ldv_state_variable_21 == 3) {
#line 409
    ipoib_new_child_link(ldvarg0, ipoib_link_ops_group2, ipoib_link_ops_group1, ipoib_link_ops_group3);
#line 411
    ldv_state_variable_21 = 3;
  } else {

  }
#line 414
  if (ldv_state_variable_21 == 2) {
#line 416
    ipoib_new_child_link(ldvarg0, ipoib_link_ops_group2, ipoib_link_ops_group1, ipoib_link_ops_group3);
#line 418
    ldv_state_variable_21 = 2;
  } else {

  }
#line 421
  goto ldv_49765;
  case 5: ;
#line 424
  if (ldv_state_variable_21 == 1) {
#line 426
    ipoib_changelink(ipoib_link_ops_group2, ipoib_link_ops_group1, ipoib_link_ops_group3);
#line 428
    ldv_state_variable_21 = 1;
  } else {

  }
#line 431
  if (ldv_state_variable_21 == 3) {
#line 433
    ipoib_changelink(ipoib_link_ops_group2, ipoib_link_ops_group1, ipoib_link_ops_group3);
#line 435
    ldv_state_variable_21 = 3;
  } else {

  }
#line 438
  if (ldv_state_variable_21 == 2) {
#line 440
    ipoib_changelink(ipoib_link_ops_group2, ipoib_link_ops_group1, ipoib_link_ops_group3);
#line 442
    ldv_state_variable_21 = 2;
  } else {

  }
#line 445
  goto ldv_49765;
  case 6: ;
#line 448
  if (ldv_state_variable_21 == 3) {
#line 450
    ldv_release_21();
#line 452
    ldv_state_variable_21 = 1;
#line 453
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 456
  if (ldv_state_variable_21 == 2) {
#line 458
    ldv_release_21();
#line 460
    ldv_state_variable_21 = 1;
#line 461
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 464
  goto ldv_49765;
  case 7: ;
#line 467
  if (ldv_state_variable_21 == 2) {
#line 469
    ldv_init_21();
#line 471
    ldv_state_variable_21 = 3;
  } else {

  }
#line 474
  goto ldv_49765;
  default: 
#line 475
  ldv_stop();
  }
  ldv_49765: ;
#line 479
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.o.c.prepared"
bool ldv_queue_work_on_147(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 508
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 508
  ldv_func_res = tmp;
#line 510
  activate_work_11(ldv_func_arg3, 2);
#line 512
  return (ldv_func_res);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.o.c.prepared"
bool ldv_queue_delayed_work_on_148(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 519
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 519
  ldv_func_res = tmp;
#line 521
  activate_work_11(& ldv_func_arg3->work, 2);
#line 523
  return (ldv_func_res);
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.o.c.prepared"
bool ldv_queue_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 530
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 530
  ldv_func_res = tmp;
#line 532
  activate_work_11(ldv_func_arg3, 2);
#line 534
  return (ldv_func_res);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.o.c.prepared"
void ldv_flush_workqueue_150(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 540
  flush_workqueue(ldv_func_arg1);
#line 542
  call_and_disable_all_11(2);
#line 543
  return;
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_netlink.o.c.prepared"
bool ldv_queue_delayed_work_on_151(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 549
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 549
  ldv_func_res = tmp;
#line 551
  activate_work_11(& ldv_func_arg3->work, 2);
#line 553
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 14 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 61 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 63
  __list_add(new, head, head->next);
#line 64
  return;
}
}
#line 143 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
#line 147
  return;
}
}
#line 154 "include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 156
  __list_del_entry(list);
#line 157
  list_add(list, head);
#line 158
  return;
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 463 "include/linux/rcupdate.h"
extern int rcu_read_lock_held(void) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_161(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_162(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_164(struct workqueue_struct *ldv_func_arg1 ) ;
#line 470
bool ldv_cancel_delayed_work_166(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___3(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_161(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work___2(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                            unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_162(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 322 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 325 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 327
  tmp = alloc_pages_current(gfp_mask, order);
#line 327
  return (tmp);
}
}
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_work_10(struct work_struct *work ) ;
#line 209
void call_and_disable_all_14(int state ) ;
#line 210
void call_and_disable_work_13(struct work_struct *work ) ;
#line 211
void activate_work_13(struct work_struct *work , int state ) ;
#line 213
void invoke_work_10(void) ;
#line 216
void disable_work_14(struct work_struct *work ) ;
#line 228
void call_and_disable_all_12(int state ) ;
#line 230
void invoke_work_14(void) ;
#line 234
void invoke_work_11(void) ;
#line 239
void call_and_disable_work_14(struct work_struct *work ) ;
#line 241
void disable_work_13(struct work_struct *work ) ;
#line 248
void invoke_work_12(void) ;
#line 250
void call_and_disable_work_12(struct work_struct *work ) ;
#line 256
void disable_work_12(struct work_struct *work ) ;
#line 267
void activate_work_12(struct work_struct *work , int state ) ;
#line 272
void invoke_work_13(void) ;
#line 278
void disable_work_10(struct work_struct *work ) ;
#line 284
void activate_work_10(struct work_struct *work , int state ) ;
#line 285
void call_and_disable_work_11(struct work_struct *work ) ;
#line 288
void activate_work_14(struct work_struct *work , int state ) ;
#line 291
void call_and_disable_all_10(int state ) ;
#line 294
void call_and_disable_all_13(int state ) ;
#line 400 "include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
#line 400
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
#line 400
  return (tmp);
}
}
#line 440 "include/linux/mm.h"
__inline static struct page *compound_head_by_tail(struct page *tail ) 
{ 
  struct page *head ;
  int tmp ;
  long tmp___0 ;

  {
#line 442
  head = tail->__annonCompField46.first_page;
#line 449
  __asm__  volatile   ("": : : "memory");
#line 450
  tmp = PageTail((struct page  const  *)tail);
#line 450
  tmp___0 = ldv__builtin_expect(tmp != 0, 1L);
#line 450
  if (tmp___0 != 0L) {
#line 451
    return (head);
  } else {

  }
#line 452
  return (tail);
}
}
#line 461 "include/linux/mm.h"
__inline static struct page *compound_head(struct page *page ) 
{ 
  struct page *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 463
  tmp___0 = PageTail((struct page  const  *)page);
#line 463
  tmp___1 = ldv__builtin_expect(tmp___0 != 0, 0L);
#line 463
  if (tmp___1 != 0L) {
#line 464
    tmp = compound_head_by_tail(page);
#line 464
    return (tmp);
  } else {

  }
#line 465
  return (page);
}
}
#line 59 "include/linux/dma-debug.h"
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 63
extern void debug_dma_sync_single_for_device(struct device * , dma_addr_t  , size_t  ,
                                             int  ) ;
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs___0(struct device *dev , void *ptr ,
                                                    size_t size , enum dma_data_direction dir ,
                                                    struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_25061: ;
#line 19
    goto ldv_25061;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs___0(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ,
                                                struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_25070: ;
#line 36
    goto ldv_25070;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 76 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page___0(struct device *dev , struct page *page ,
                                            size_t offset , size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 80
  tmp = get_dma_ops(dev);
#line 80
  ops = tmp;
#line 83
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 83
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 84
  tmp___1 = valid_dma_direction((int )dir);
#line 84
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 84
  if (tmp___2 != 0L) {
#line 84
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (84), "i" (12UL));
    ldv_25105: ;
#line 84
    goto ldv_25105;
  } else {

  }
#line 85
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
#line 86
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 88
  return (addr);
}
}
#line 91 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page___0(struct device *dev , dma_addr_t addr , size_t size ,
                                        enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 94
  tmp = get_dma_ops(dev);
#line 94
  ops = tmp;
#line 96
  tmp___0 = valid_dma_direction((int )dir);
#line 96
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 96
  if (tmp___1 != 0L) {
#line 96
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (96), "i" (12UL));
    ldv_25113: ;
#line 96
    goto ldv_25113;
  } else {

  }
#line 97
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 98
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
  } else {

  }
#line 99
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 100
  return;
}
}
#line 102 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 106
  tmp = get_dma_ops(dev);
#line 106
  ops = tmp;
#line 108
  tmp___0 = valid_dma_direction((int )dir);
#line 108
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 108
  if (tmp___1 != 0L) {
#line 108
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (108), "i" (12UL));
    ldv_25121: ;
#line 108
    goto ldv_25121;
  } else {

  }
#line 109
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
#line 110
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
  } else {

  }
#line 111
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
#line 112
  return;
}
}
#line 114 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 118
  tmp = get_dma_ops(dev);
#line 118
  ops = tmp;
#line 120
  tmp___0 = valid_dma_direction((int )dir);
#line 120
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 120
  if (tmp___1 != 0L) {
#line 120
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (120), "i" (12UL));
    ldv_25129: ;
#line 120
    goto ldv_25129;
  } else {

  }
#line 121
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
#line 122
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
  } else {

  }
#line 123
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
#line 124
  return;
}
}
#line 2216 "include/rdma/ib_verbs.h"
extern struct ib_srq *ib_create_srq(struct ib_pd * , struct ib_srq_init_attr * ) ;
#line 2248
extern int ib_destroy_srq(struct ib_srq * ) ;
#line 2257 "include/rdma/ib_verbs.h"
__inline static int ib_post_srq_recv(struct ib_srq *srq , struct ib_recv_wr *recv_wr ,
                                     struct ib_recv_wr **bad_recv_wr ) 
{ 
  int tmp ;

  {
#line 2261
  tmp = (*((srq->device)->post_srq_recv))(srq, recv_wr, bad_recv_wr);
#line 2261
  return (tmp);
}
}
#line 2515 "include/rdma/ib_verbs.h"
__inline static u64 ib_dma_map_single___0(struct ib_device *dev , void *cpu_addr ,
                                          size_t size , enum dma_data_direction direction ) 
{ 
  u64 tmp ;
  dma_addr_t tmp___0 ;

  {
#line 2519
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2520
    tmp = (*((dev->dma_ops)->map_single))(dev, cpu_addr, size, direction);
#line 2520
    return (tmp);
  } else {

  }
#line 2521
  tmp___0 = dma_map_single_attrs___0(dev->dma_device, cpu_addr, size, direction, (struct dma_attrs *)0);
#line 2521
  return (tmp___0);
}
}
#line 2531 "include/rdma/ib_verbs.h"
__inline static void ib_dma_unmap_single___0(struct ib_device *dev , u64 addr , size_t size ,
                                             enum dma_data_direction direction ) 
{ 


  {
#line 2535
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2536
    (*((dev->dma_ops)->unmap_single))(dev, addr, size, direction);
  } else {
#line 2538
    dma_unmap_single_attrs___0(dev->dma_device, addr, size, direction, (struct dma_attrs *)0);
  }
#line 2539
  return;
}
}
#line 2567 "include/rdma/ib_verbs.h"
__inline static u64 ib_dma_map_page___0(struct ib_device *dev , struct page *page ,
                                        unsigned long offset , size_t size , enum dma_data_direction direction ) 
{ 
  u64 tmp ;
  dma_addr_t tmp___0 ;

  {
#line 2573
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2574
    tmp = (*((dev->dma_ops)->map_page))(dev, page, offset, size, direction);
#line 2574
    return (tmp);
  } else {

  }
#line 2575
  tmp___0 = dma_map_page___0(dev->dma_device, page, offset, size, direction);
#line 2575
  return (tmp___0);
}
}
#line 2585 "include/rdma/ib_verbs.h"
__inline static void ib_dma_unmap_page___0(struct ib_device *dev , u64 addr , size_t size ,
                                           enum dma_data_direction direction ) 
{ 


  {
#line 2589
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2590
    (*((dev->dma_ops)->unmap_page))(dev, addr, size, direction);
  } else {
#line 2592
    dma_unmap_page___0(dev->dma_device, addr, size, direction);
  }
#line 2593
  return;
}
}
#line 2678 "include/rdma/ib_verbs.h"
__inline static void ib_dma_sync_single_for_cpu(struct ib_device *dev , u64 addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 


  {
#line 2683
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2684
    (*((dev->dma_ops)->sync_single_for_cpu))(dev, addr, size, dir);
  } else {
#line 2686
    dma_sync_single_for_cpu(dev->dma_device, addr, size, dir);
  }
#line 2687
  return;
}
}
#line 2696 "include/rdma/ib_verbs.h"
__inline static void ib_dma_sync_single_for_device(struct ib_device *dev , u64 addr ,
                                                   size_t size , enum dma_data_direction dir ) 
{ 


  {
#line 2701
  if ((unsigned long )dev->dma_ops != (unsigned long )((struct ib_dma_mapping_ops *)0)) {
#line 2702
    (*((dev->dma_ops)->sync_single_for_device))(dev, addr, size, dir);
  } else {
#line 2704
    dma_sync_single_for_device(dev->dma_device, addr, size, dir);
  }
#line 2705
  return;
}
}
#line 321 "include/rdma/ib_cm.h"
extern struct ib_cm_id *ib_create_cm_id(struct ib_device * , int (*)(struct ib_cm_id * ,
                                                                     struct ib_cm_event * ) ,
                                        void * ) ;
#line 331
extern void ib_destroy_cm_id(struct ib_cm_id * ) ;
#line 361
extern int ib_cm_listen(struct ib_cm_id * , __be64  , __be64  , struct ib_cm_compare_data * ) ;
#line 392
extern int ib_send_cm_req(struct ib_cm_id * , struct ib_cm_req_param * ) ;
#line 416
extern int ib_send_cm_rep(struct ib_cm_id * , struct ib_cm_rep_param * ) ;
#line 427
extern int ib_send_cm_rtu(struct ib_cm_id * , void const   * , u8  ) ;
#line 455
extern int ib_send_cm_drep(struct ib_cm_id * , void const   * , u8  ) ;
#line 487
extern int ib_send_cm_rej(struct ib_cm_id * , enum ib_cm_rej_reason  , void * , u8  ,
                          void const   * , u8  ) ;
#line 543
extern int ib_cm_init_qp_attr(struct ib_cm_id * , struct ib_qp_attr * , int * ) ;
#line 37 "include/linux/random.h"
extern u32 prandom_u32(void) ;
#line 235 "include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag , unsigned int size ) 
{ 


  {
#line 237
  frag->size = size;
#line 238
  return;
}
}
#line 718 "include/linux/skbuff.h"
__inline static struct dst_entry *skb_dst(struct sk_buff  const  *skb ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 723
  if ((int )skb->_skb_refdst & 1) {
#line 723
    tmp = rcu_read_lock_held();
#line 723
    if (tmp == 0) {
#line 723
      tmp___0 = rcu_read_lock_bh_held();
#line 723
      if (tmp___0 == 0) {
#line 723
        tmp___1 = 1;
      } else {
#line 723
        tmp___1 = 0;
      }
    } else {
#line 723
      tmp___1 = 0;
    }
  } else {
#line 723
    tmp___1 = 0;
  }
#line 723
  __ret_warn_on = tmp___1;
#line 723
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 723
  if (tmp___2 != 0L) {
#line 723
    warn_slowpath_null("include/linux/skbuff.h", 725);
  } else {

  }
#line 723
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 726
  return ((struct dst_entry *)((unsigned long )skb->_skb_refdst & 0xfffffffffffffffeUL));
}
}
#line 1599 "include/linux/skbuff.h"
__inline static void __skb_fill_page_desc(struct sk_buff *skb , int i , struct page *page ,
                                          int off , int size ) 
{ 
  skb_frag_t *frag ;
  unsigned char *tmp ;

  {
#line 1602
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1602
  frag = (skb_frag_t *)(& ((struct skb_shared_info *)tmp)->frags) + (unsigned long )i;
#line 1613
  frag->page.p = page;
#line 1614
  frag->page_offset = (__u32 )off;
#line 1615
  skb_frag_size_set(frag, (unsigned int )size);
#line 1617
  page = compound_head(page);
#line 1618
  if ((int )page->__annonCompField42.__annonCompField37.pfmemalloc && (unsigned long )page->__annonCompField36.mapping == (unsigned long )((struct address_space *)0)) {
#line 1619
    skb->pfmemalloc = 1U;
  } else {

  }
#line 1620
  return;
}
}
#line 1636 "include/linux/skbuff.h"
__inline static void skb_fill_page_desc(struct sk_buff *skb , int i , struct page *page ,
                                        int off , int size ) 
{ 
  unsigned char *tmp ;

  {
#line 1639
  __skb_fill_page_desc(skb, i, page, off, size);
#line 1640
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1640
  ((struct skb_shared_info *)tmp)->nr_frags = (unsigned int )((unsigned char )i) + 1U;
#line 1641
  return;
}
}
#line 2099 "include/linux/skbuff.h"
__inline static void skb_orphan___0(struct sk_buff *skb ) 
{ 
  long tmp ;

  {
#line 2101
  if ((unsigned long )skb->destructor != (unsigned long )((void (*)(struct sk_buff * ))0)) {
#line 2102
    (*(skb->destructor))(skb);
#line 2103
    skb->destructor = (void (*)(struct sk_buff * ))0;
#line 2104
    skb->sk = (struct sock *)0;
  } else {
#line 2106
    tmp = ldv__builtin_expect((unsigned long )skb->sk != (unsigned long )((struct sock *)0),
                           0L);
#line 2106
    if (tmp != 0L) {
#line 2106
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/skbuff.h"),
                           "i" (2106), "i" (12UL));
      ldv_35985: ;
#line 2106
      goto ldv_35985;
    } else {

    }
  }
#line 2108
  return;
}
}
#line 2790 "include/linux/skbuff.h"
__inline static void skb_copy_from_linear_data(struct sk_buff  const  *skb , void *to ,
                                               unsigned int const   len ) 
{ 


  {
#line 2794
  memcpy(to, (void const   *)skb->data, (size_t )len);
#line 2795
  return;
}
}
#line 2943 "include/linux/netdevice.h"
extern int netif_receive_skb_sk(struct sock * , struct sk_buff * ) ;
#line 2944 "include/linux/netdevice.h"
__inline static int netif_receive_skb(struct sk_buff *skb ) 
{ 
  int tmp ;

  {
#line 2946
  tmp = netif_receive_skb_sk(skb->sk, skb);
#line 2946
  return (tmp);
}
}
#line 3214 "include/linux/netdevice.h"
__inline static void netif_tx_lock___2(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3219
  spin_lock(& dev->tx_global_lock);
#line 3220
  __vpp_verify = (void const   *)0;
#line 3220
  switch (4UL) {
  case 1UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_46051;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_46051;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_46051;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 3220
  goto ldv_46051;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_46051: 
#line 3220
  pscr_ret__ = pfo_ret__;
#line 3220
  goto ldv_46057;
  case 2UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_46061;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_46061;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_46061;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 3220
  goto ldv_46061;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_46061: 
#line 3220
  pscr_ret__ = pfo_ret_____0;
#line 3220
  goto ldv_46057;
  case 4UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_46070;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_46070;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_46070;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 3220
  goto ldv_46070;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_46070: 
#line 3220
  pscr_ret__ = pfo_ret_____1;
#line 3220
  goto ldv_46057;
  case 8UL: ;
#line 3220
  switch (4UL) {
  case 1UL: 
#line 3220
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_46079;
  case 2UL: 
#line 3220
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_46079;
  case 4UL: 
#line 3220
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_46079;
  case 8UL: 
#line 3220
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 3220
  goto ldv_46079;
  default: 
#line 3220
  __bad_percpu_size();
  }
  ldv_46079: 
#line 3220
  pscr_ret__ = pfo_ret_____2;
#line 3220
  goto ldv_46057;
  default: 
#line 3220
  __bad_size_call_parameter();
#line 3220
  goto ldv_46057;
  }
  ldv_46057: 
#line 3220
  cpu = pscr_ret__;
#line 3221
  i = 0U;
#line 3221
  goto ldv_46089;
  ldv_46088: 
#line 3222
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3222
  txq = tmp;
#line 3230
  __netif_tx_lock(txq, cpu);
#line 3231
  set_bit(2L, (unsigned long volatile   *)(& txq->state));
#line 3232
  __netif_tx_unlock(txq);
#line 3221
  i = i + 1U;
  ldv_46089: ;
#line 3221
  if (dev->num_tx_queues > i) {
#line 3223
    goto ldv_46088;
  } else {

  }

#line 3228
  return;
}
}
#line 3236 "include/linux/netdevice.h"
__inline static void netif_tx_lock_bh___2(struct net_device *dev ) 
{ 


  {
#line 3238
  local_bh_disable();
#line 3239
  netif_tx_lock___2(dev);
#line 3240
  return;
}
}
#line 3242 "include/linux/netdevice.h"
__inline static void netif_tx_unlock___2(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 3246
  i = 0U;
#line 3246
  goto ldv_46100;
  ldv_46099: 
#line 3247
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 3247
  txq = tmp;
#line 3253
  clear_bit(2L, (unsigned long volatile   *)(& txq->state));
#line 3254
  netif_schedule_queue(txq);
#line 3246
  i = i + 1U;
  ldv_46100: ;
#line 3246
  if (dev->num_tx_queues > i) {
#line 3248
    goto ldv_46099;
  } else {

  }
#line 3256
  spin_unlock(& dev->tx_global_lock);
#line 3257
  return;
}
}
#line 3259 "include/linux/netdevice.h"
__inline static void netif_tx_unlock_bh___2(struct net_device *dev ) 
{ 


  {
#line 3261
  netif_tx_unlock___2(dev);
#line 3262
  local_bh_enable();
#line 3263
  return;
}
}
#line 42 "include/net/icmp.h"
extern void icmp_send(struct sk_buff * , int  , int  , __be32  ) ;
#line 15 "include/linux/icmpv6.h"
extern void icmpv6_send(struct sk_buff * , u8  , u8  , __u32  ) ;
#line 77 "include/linux/vmalloc.h"
extern void *__vmalloc(unsigned long  , gfp_t  , pgprot_t  ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
int ipoib_max_conn_qp  =    128;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int data_debug_level___0  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static struct ib_qp_attr ipoib_cm_err_attr  = 
#line 66
     {6, 0, 0, 0, 0U, 0U, 0U, 0U, 0, {0U, 0U, 0U, 0U, 0U}, {{{{(unsigned char)0, (unsigned char)0,
                                                             (unsigned char)0, (unsigned char)0,
                                                             (unsigned char)0, (unsigned char)0,
                                                             (unsigned char)0, (unsigned char)0,
                                                             (unsigned char)0, (unsigned char)0,
                                                             (unsigned char)0, (unsigned char)0,
                                                             (unsigned char)0, (unsigned char)0,
                                                             (unsigned char)0, (unsigned char)0}},
                                                           0U, (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0}, (unsigned short)0,
                                                          (unsigned char)0, (unsigned char)0,
                                                          (unsigned char)0, (unsigned char)0,
                                                          (unsigned char)0, {(unsigned char)0,
                                                                             (unsigned char)0,
                                                                             (unsigned char)0,
                                                                             (unsigned char)0,
                                                                             (unsigned char)0,
                                                                             (unsigned char)0},
                                                          (unsigned short)0}, {{{{(unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0}},
                                                                                0U,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                                                                               (unsigned short)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               (unsigned char)0,
                                                                               {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                                                                               (unsigned short)0},
    (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, (unsigned short)0, (unsigned short)0};
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static struct ib_send_wr ipoib_cm_rx_drain_wr  = 
#line 72
     {0, 4294967295ULL, 0, 0, 2, 0, {0U}, {.atomic = {0ULL, 0ULL, 0ULL, 0ULL, 0ULL,
                                                    0U}}, 0U};
#line 77
static int ipoib_cm_tx_handler(struct ib_cm_id *cm_id , struct ib_cm_event *event ) ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_dma_unmap_rx(struct ipoib_dev_priv *priv , int frags , u64 *mapping ) 
{ 
  int i ;

  {
#line 85
  ib_dma_unmap_single___0(priv->ca, *mapping, 4084UL, 2);
#line 87
  i = 0;
#line 87
  goto ldv_53064;
  ldv_53063: 
#line 88
  ib_dma_unmap_page___0(priv->ca, *(mapping + ((unsigned long )i + 1UL)), 4096UL,
                        2);
#line 87
  i = i + 1;
  ldv_53064: ;
#line 87
  if (i < frags) {
#line 89
    goto ldv_53063;
  } else {

  }

#line 94
  return;
}
}
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_post_receive_srq(struct net_device *dev , int id ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_recv_wr *bad_wr ;
  int i ;
  int ret ;
  long tmp___0 ;

  {
#line 93
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 93
  priv = (struct ipoib_dev_priv *)tmp;
#line 97
  priv->cm.rx_wr.wr_id = (u64 )((unsigned long )(id | 1073741824) | 2147483648UL);
#line 99
  i = 0;
#line 99
  goto ldv_53075;
  ldv_53074: 
#line 100
  priv->cm.rx_sge[i].addr = (priv->cm.srq_ring + (unsigned long )id)->mapping[i];
#line 99
  i = i + 1;
  ldv_53075: ;
#line 99
  if (priv->cm.num_frags > i) {
#line 101
    goto ldv_53074;
  } else {

  }
#line 102
  ret = ib_post_srq_recv(priv->cm.srq, & priv->cm.rx_wr, & bad_wr);
#line 103
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 103
  if (tmp___0 != 0L) {
#line 104
    printk("\f%s: post srq failed for buf %d (%d)\n", (char *)(& (priv->dev)->name),
           id, ret);
#line 105
    ipoib_cm_dma_unmap_rx(priv, priv->cm.num_frags + -1, (u64 *)(& (priv->cm.srq_ring + (unsigned long )id)->mapping));
#line 107
    dev_kfree_skb_any((priv->cm.srq_ring + (unsigned long )id)->skb);
#line 108
    (priv->cm.srq_ring + (unsigned long )id)->skb = (struct sk_buff *)0;
  } else {

  }
#line 111
  return (ret);
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_post_receive_nonsrq(struct net_device *dev , struct ipoib_cm_rx *rx ,
                                        struct ib_recv_wr *wr , struct ib_sge *sge ,
                                        int id ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_recv_wr *bad_wr ;
  int i ;
  int ret ;
  long tmp___0 ;

  {
#line 119
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 119
  priv = (struct ipoib_dev_priv *)tmp;
#line 123
  wr->wr_id = (u64 )((unsigned long )(id | 1073741824) | 2147483648UL);
#line 125
  i = 0;
#line 125
  goto ldv_53089;
  ldv_53088: 
#line 126
  (sge + (unsigned long )i)->addr = (rx->rx_ring + (unsigned long )id)->mapping[i];
#line 125
  i = i + 1;
  ldv_53089: ;
#line 125
  if (i <= 15) {
#line 127
    goto ldv_53088;
  } else {

  }
#line 128
  ret = ib_post_recv(rx->qp, wr, & bad_wr);
#line 129
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 129
  if (tmp___0 != 0L) {
#line 130
    printk("\f%s: post recv failed for buf %d (%d)\n", (char *)(& (priv->dev)->name),
           id, ret);
#line 131
    ipoib_cm_dma_unmap_rx(priv, 15, (u64 *)(& (rx->rx_ring + (unsigned long )id)->mapping));
#line 133
    dev_kfree_skb_any((rx->rx_ring + (unsigned long )id)->skb);
#line 134
    (rx->rx_ring + (unsigned long )id)->skb = (struct sk_buff *)0;
  } else {

  }
#line 137
  return (ret);
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static struct sk_buff *ipoib_cm_alloc_rx_skb(struct net_device *dev , struct ipoib_cm_rx_buf *rx_ring ,
                                             int id , int frags , u64 *mapping , gfp_t gfp ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct sk_buff *skb ;
  int i ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  struct page *page ;
  struct page *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
#line 146
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 146
  priv = (struct ipoib_dev_priv *)tmp;
#line 150
  skb = dev_alloc_skb(4096U);
#line 151
  tmp___0 = ldv__builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                             0L);
#line 151
  if (tmp___0 != 0L) {
#line 152
    return ((struct sk_buff *)0);
  } else {

  }
#line 158
  skb_reserve(skb, 12);
#line 160
  *mapping = ib_dma_map_single___0(priv->ca, (void *)skb->data, 4084UL, 2);
#line 162
  tmp___1 = ib_dma_mapping_error(priv->ca, *mapping);
#line 162
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 162
  if (tmp___2 != 0L) {
#line 163
    dev_kfree_skb_any(skb);
#line 164
    return ((struct sk_buff *)0);
  } else {

  }
#line 167
  i = 0;
#line 167
  goto ldv_53105;
  ldv_53104: 
#line 168
  tmp___3 = alloc_pages(gfp, 0U);
#line 168
  page = tmp___3;
#line 170
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 171
    goto partial_error;
  } else {

  }
#line 172
  skb_fill_page_desc(skb, i, page, 0, 4096);
#line 174
  *(mapping + ((unsigned long )i + 1UL)) = ib_dma_map_page___0(priv->ca, page, 0UL,
                                                               4096UL, 2);
#line 176
  tmp___4 = ib_dma_mapping_error(priv->ca, *(mapping + ((unsigned long )i + 1UL)));
#line 176
  tmp___5 = ldv__builtin_expect(tmp___4 != 0, 0L);
#line 176
  if (tmp___5 != 0L) {
#line 177
    goto partial_error;
  } else {

  }
#line 167
  i = i + 1;
  ldv_53105: ;
#line 167
  if (i < frags) {
#line 169
    goto ldv_53104;
  } else {

  }
#line 180
  (rx_ring + (unsigned long )id)->skb = skb;
#line 181
  return (skb);
  partial_error: 
#line 185
  ib_dma_unmap_single___0(priv->ca, *mapping, 4084UL, 2);
#line 187
  goto ldv_53108;
  ldv_53107: 
#line 188
  ib_dma_unmap_page___0(priv->ca, *(mapping + (unsigned long )i), 4096UL, 2);
#line 187
  i = i - 1;
  ldv_53108: ;
#line 187
  if (i > 0) {
#line 189
    goto ldv_53107;
  } else {

  }
#line 190
  dev_kfree_skb_any(skb);
#line 191
  return ((struct sk_buff *)0);
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_free_rx_ring(struct net_device *dev , struct ipoib_cm_rx_buf *rx_ring ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int i ;

  {
#line 197
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 197
  priv = (struct ipoib_dev_priv *)tmp;
#line 200
  i = 0;
#line 200
  goto ldv_53117;
  ldv_53116: ;
#line 201
  if ((unsigned long )(rx_ring + (unsigned long )i)->skb != (unsigned long )((struct sk_buff *)0)) {
#line 202
    ipoib_cm_dma_unmap_rx(priv, 15, (u64 *)(& (rx_ring + (unsigned long )i)->mapping));
#line 204
    dev_kfree_skb_any((rx_ring + (unsigned long )i)->skb);
  } else {

  }
#line 200
  i = i + 1;
  ldv_53117: ;
#line 200
  if (i < ipoib_recvq_size) {
#line 202
    goto ldv_53116;
  } else {

  }
#line 207
  vfree((void const   *)rx_ring);
#line 208
  return;
}
}
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_start_rx_drain(struct ipoib_dev_priv *priv ) 
{ 
  struct ib_send_wr *bad_wr ;
  struct ipoib_cm_rx *p ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;

  {
#line 217
  tmp = list_empty((struct list_head  const  *)(& priv->cm.rx_flush_list));
#line 217
  if (tmp != 0) {
#line 219
    return;
  } else {
#line 217
    tmp___0 = list_empty((struct list_head  const  *)(& priv->cm.rx_drain_list));
#line 217
    if (tmp___0 == 0) {
#line 219
      return;
    } else {

    }
  }
#line 225
  __mptr = (struct list_head  const  *)priv->cm.rx_flush_list.next;
#line 225
  p = (struct ipoib_cm_rx *)__mptr + 0xffffffffffffffe8UL;
#line 226
  tmp___1 = ib_post_send(p->qp, & ipoib_cm_rx_drain_wr, & bad_wr);
#line 226
  if (tmp___1 != 0) {
#line 227
    printk("\f%s: failed to post drain wr\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 229
  list_splice_init(& priv->cm.rx_flush_list, & priv->cm.rx_drain_list);
#line 230
  return;
}
}
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_rx_event_handler(struct ib_event *event , void *ctx ) 
{ 
  struct ipoib_cm_rx *p ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;

  {
#line 234
  p = (struct ipoib_cm_rx *)ctx;
#line 235
  tmp = netdev_priv((struct net_device  const  *)p->dev);
#line 235
  priv = (struct ipoib_dev_priv *)tmp;
#line 238
  if ((unsigned int )event->event != 16U) {
#line 239
    return;
  } else {

  }
#line 241
  tmp___0 = spinlock_check(& priv->lock);
#line 241
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 242
  list_move(& p->list, & priv->cm.rx_flush_list);
#line 243
  p->state = 2;
#line 244
  ipoib_cm_start_rx_drain(priv);
#line 245
  spin_unlock_irqrestore(& priv->lock, flags);
#line 246
  return;
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static struct ib_qp *ipoib_cm_create_rx_qp(struct net_device *dev , struct ipoib_cm_rx *p ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_qp_init_attr attr ;
  int tmp___0 ;
  struct ib_qp *tmp___1 ;

  {
#line 251
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 251
  priv = (struct ipoib_dev_priv *)tmp;
#line 252
  attr.event_handler = & ipoib_cm_rx_event_handler;
#line 252
  attr.qp_context = (void *)p;
#line 252
  attr.send_cq = priv->recv_cq;
#line 252
  attr.recv_cq = priv->recv_cq;
#line 252
  attr.srq = priv->cm.srq;
#line 252
  attr.xrcd = 0;
#line 252
  attr.cap.max_send_wr = 1U;
#line 252
  attr.cap.max_recv_wr = 0U;
#line 252
  attr.cap.max_send_sge = 1U;
#line 252
  attr.cap.max_recv_sge = 0U;
#line 252
  attr.cap.max_inline_data = 0U;
#line 252
  attr.sq_sig_type = 0;
#line 252
  attr.qp_type = 2;
#line 252
  attr.create_flags = 0;
#line 252
  attr.port_num = (unsigned char)0;
#line 264
  tmp___0 = ipoib_cm_has_srq(dev);
#line 264
  if (tmp___0 == 0) {
#line 265
    attr.cap.max_recv_wr = (u32 )ipoib_recvq_size;
#line 266
    attr.cap.max_recv_sge = 16U;
  } else {

  }
#line 269
  tmp___1 = ib_create_qp(priv->pd, & attr);
#line 269
  return (tmp___1);
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_modify_rx_qp(struct net_device *dev , struct ib_cm_id *cm_id ,
                                 struct ib_qp *qp , unsigned int psn ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_qp_attr qp_attr ;
  int qp_attr_mask ;
  int ret ;

  {
#line 276
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 276
  priv = (struct ipoib_dev_priv *)tmp;
#line 280
  qp_attr.qp_state = 1;
#line 281
  ret = ib_cm_init_qp_attr(cm_id, & qp_attr, & qp_attr_mask);
#line 282
  if (ret != 0) {
#line 283
    printk("\f%s: failed to init QP attr for INIT: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 284
    return (ret);
  } else {

  }
#line 286
  ret = ib_modify_qp(qp, & qp_attr, qp_attr_mask);
#line 287
  if (ret != 0) {
#line 288
    printk("\f%s: failed to modify QP to INIT: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 289
    return (ret);
  } else {

  }
#line 291
  qp_attr.qp_state = 2;
#line 292
  ret = ib_cm_init_qp_attr(cm_id, & qp_attr, & qp_attr_mask);
#line 293
  if (ret != 0) {
#line 294
    printk("\f%s: failed to init QP attr for RTR: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 295
    return (ret);
  } else {

  }
#line 297
  qp_attr.rq_psn = psn;
#line 298
  ret = ib_modify_qp(qp, & qp_attr, qp_attr_mask);
#line 299
  if (ret != 0) {
#line 300
    printk("\f%s: failed to modify QP to RTR: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 301
    return (ret);
  } else {

  }
#line 312
  qp_attr.qp_state = 3;
#line 313
  ret = ib_cm_init_qp_attr(cm_id, & qp_attr, & qp_attr_mask);
#line 314
  if (ret != 0) {
#line 315
    printk("\f%s: failed to init QP attr for RTS: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 316
    return (0);
  } else {

  }
#line 318
  ret = ib_modify_qp(qp, & qp_attr, qp_attr_mask);
#line 319
  if (ret != 0) {
#line 320
    printk("\f%s: failed to modify QP to RTS: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 321
    return (0);
  } else {

  }
#line 324
  return (0);
}
}
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_init_rx_wr(struct net_device *dev , struct ib_recv_wr *wr , struct ib_sge *sge ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int i ;

  {
#line 331
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 331
  priv = (struct ipoib_dev_priv *)tmp;
#line 334
  i = 0;
#line 334
  goto ldv_53160;
  ldv_53159: 
#line 335
  (sge + (unsigned long )i)->lkey = (priv->mr)->lkey;
#line 334
  i = i + 1;
  ldv_53160: ;
#line 334
  if (priv->cm.num_frags > i) {
#line 336
    goto ldv_53159;
  } else {

  }
#line 337
  sge->length = 4084U;
#line 338
  i = 1;
#line 338
  goto ldv_53163;
  ldv_53162: 
#line 339
  (sge + (unsigned long )i)->length = 4096U;
#line 338
  i = i + 1;
  ldv_53163: ;
#line 338
  if (priv->cm.num_frags > i) {
#line 340
    goto ldv_53162;
  } else {

  }
#line 341
  wr->next = (struct ib_recv_wr *)0;
#line 342
  wr->sg_list = sge;
#line 343
  wr->num_sge = priv->cm.num_frags;
#line 344
  return;
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_nonsrq_init_rx(struct net_device *dev , struct ib_cm_id *cm_id ,
                                   struct ipoib_cm_rx *rx ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct __anonstruct_t_397 *t ;
  int ret ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct sk_buff *tmp___2 ;

  {
#line 349
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 349
  priv = (struct ipoib_dev_priv *)tmp;
#line 357
  tmp___0 = vzalloc((unsigned long )ipoib_recvq_size * 136UL);
#line 357
  rx->rx_ring = (struct ipoib_cm_rx_buf *)tmp___0;
#line 358
  if ((unsigned long )rx->rx_ring == (unsigned long )((struct ipoib_cm_rx_buf *)0)) {
#line 359
    printk("\f%s: failed to allocate CM non-SRQ ring (%d entries)\n", (char *)(& (priv->ca)->name),
           ipoib_recvq_size);
#line 361
    return (-12);
  } else {

  }
#line 364
  tmp___1 = kmalloc(288UL, 208U);
#line 364
  t = (struct __anonstruct_399 *)tmp___1;
#line 365
  if ((unsigned long )t == (unsigned long )((struct __anonstruct_401 *)0)) {
#line 366
    ret = -12;
#line 367
    goto err_free;
  } else {

  }
#line 370
  ipoib_cm_init_rx_wr(dev, & t->wr, (struct ib_sge *)(& t->sge));
#line 372
  spin_lock_irq(& priv->lock);
#line 374
  if (priv->cm.nonsrq_conn_qp >= ipoib_max_conn_qp) {
#line 375
    spin_unlock_irq(& priv->lock);
#line 376
    ib_send_cm_rej(cm_id, 1, (void *)0, 0, (void const   *)0, 0);
#line 377
    ret = -22;
#line 378
    goto err_free;
  } else {
#line 380
    priv->cm.nonsrq_conn_qp = priv->cm.nonsrq_conn_qp + 1;
  }
#line 382
  spin_unlock_irq(& priv->lock);
#line 384
  i = 0;
#line 384
  goto ldv_53180;
  ldv_53179: 
#line 385
  tmp___2 = ipoib_cm_alloc_rx_skb(dev, rx->rx_ring, i, 15, (u64 *)(& (rx->rx_ring + (unsigned long )i)->mapping),
                                  208U);
#line 385
  if ((unsigned long )tmp___2 == (unsigned long )((struct sk_buff *)0)) {
#line 388
    printk("\f%s: failed to allocate receive buffer %d\n", (char *)(& (priv->dev)->name),
           i);
#line 389
    ret = -12;
#line 390
    goto err_count;
  } else {

  }
#line 392
  ret = ipoib_cm_post_receive_nonsrq(dev, rx, & t->wr, (struct ib_sge *)(& t->sge),
                                     i);
#line 393
  if (ret != 0) {
#line 394
    printk("\f%s: ipoib_cm_post_receive_nonsrq failed for buf %d\n", (char *)(& (priv->dev)->name),
           i);
#line 396
    ret = -5;
#line 397
    goto err_count;
  } else {

  }
#line 384
  i = i + 1;
  ldv_53180: ;
#line 384
  if (i < ipoib_recvq_size) {
#line 386
    goto ldv_53179;
  } else {

  }
#line 401
  rx->recv_count = ipoib_recvq_size;
#line 403
  kfree((void const   *)t);
#line 405
  return (0);
  err_count: 
#line 408
  spin_lock_irq(& priv->lock);
#line 409
  priv->cm.nonsrq_conn_qp = priv->cm.nonsrq_conn_qp - 1;
#line 410
  spin_unlock_irq(& priv->lock);
  err_free: 
#line 413
  kfree((void const   *)t);
#line 414
  ipoib_cm_free_rx_ring(dev, rx->rx_ring);
#line 416
  return (ret);
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_send_rep(struct net_device *dev , struct ib_cm_id *cm_id , struct ib_qp *qp ,
                             struct ib_cm_req_event_param *req , unsigned int psn ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_data data ;
  struct ib_cm_rep_param rep ;
  __u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 423
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 423
  priv = (struct ipoib_dev_priv *)tmp;
#line 424
  data.qpn = 0U;
#line 424
  data.mtu = 0U;
#line 425
  rep.qp_num = 0U;
#line 425
  rep.starting_psn = 0U;
#line 425
  rep.private_data = 0;
#line 425
  rep.private_data_len = (unsigned char)0;
#line 425
  rep.responder_resources = (unsigned char)0;
#line 425
  rep.initiator_depth = (unsigned char)0;
#line 425
  rep.failover_accepted = (unsigned char)0;
#line 425
  rep.flow_control = (unsigned char)0;
#line 425
  rep.rnr_retry_count = (unsigned char)0;
#line 425
  rep.srq = (unsigned char)0;
#line 427
  tmp___0 = __fswab32((priv->qp)->qp_num);
#line 427
  data.qpn = tmp___0;
#line 428
  data.mtu = 4110352384U;
#line 430
  rep.private_data = (void const   *)(& data);
#line 431
  rep.private_data_len = 8U;
#line 432
  rep.flow_control = 0U;
#line 433
  rep.rnr_retry_count = req->rnr_retry_count;
#line 434
  tmp___1 = ipoib_cm_has_srq(dev);
#line 434
  rep.srq = (u8 )tmp___1;
#line 435
  rep.qp_num = qp->qp_num;
#line 436
  rep.starting_psn = psn;
#line 437
  tmp___2 = ib_send_cm_rep(cm_id, & rep);
#line 437
  return (tmp___2);
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_req_handler(struct ib_cm_id *cm_id , struct ib_cm_event *event ) 
{ 
  struct net_device *dev ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_rx *p ;
  unsigned int psn ;
  int ret ;
  void *tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 442
  dev = (struct net_device *)cm_id->context;
#line 443
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 443
  priv = (struct ipoib_dev_priv *)tmp;
#line 448
  if (ipoib_debug_level > 0) {
#line 448
    printk("\017%s: REQ arrived\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 449
  tmp___0 = kzalloc(64UL, 208U);
#line 449
  p = (struct ipoib_cm_rx *)tmp___0;
#line 450
  if ((unsigned long )p == (unsigned long )((struct ipoib_cm_rx *)0)) {
#line 451
    return (-12);
  } else {

  }
#line 452
  p->dev = dev;
#line 453
  p->id = cm_id;
#line 454
  cm_id->context = (void *)p;
#line 455
  p->state = 0;
#line 456
  p->jiffies = jiffies;
#line 457
  INIT_LIST_HEAD(& p->list);
#line 459
  p->qp = ipoib_cm_create_rx_qp(dev, p);
#line 460
  tmp___2 = IS_ERR((void const   *)p->qp);
#line 460
  if ((int )tmp___2) {
#line 461
    tmp___1 = PTR_ERR((void const   *)p->qp);
#line 461
    ret = (int )tmp___1;
#line 462
    goto err_qp;
  } else {

  }
#line 465
  tmp___3 = prandom_u32();
#line 465
  psn = tmp___3 & 16777215U;
#line 466
  ret = ipoib_cm_modify_rx_qp(dev, cm_id, p->qp, psn);
#line 467
  if (ret != 0) {
#line 468
    goto err_modify;
  } else {

  }
#line 470
  tmp___4 = ipoib_cm_has_srq(dev);
#line 470
  if (tmp___4 == 0) {
#line 471
    ret = ipoib_cm_nonsrq_init_rx(dev, cm_id, p);
#line 472
    if (ret != 0) {
#line 473
      goto err_modify;
    } else {

    }
  } else {

  }
#line 476
  spin_lock_irq(& priv->lock);
#line 477
  queue_delayed_work___2(priv->wq, & priv->cm.stale_task, 192000UL);
#line 481
  p->jiffies = jiffies;
#line 482
  if ((unsigned int )p->state == 0U) {
#line 483
    list_move(& p->list, & priv->cm.passive_ids);
  } else {

  }
#line 484
  spin_unlock_irq(& priv->lock);
#line 486
  ret = ipoib_cm_send_rep(dev, cm_id, p->qp, & event->param.req_rcvd, psn);
#line 487
  if (ret != 0) {
#line 488
    printk("\f%s: failed to send REP: %d\n", (char *)(& (priv->dev)->name), ret);
#line 489
    tmp___5 = ib_modify_qp(p->qp, & ipoib_cm_err_attr, 1);
#line 489
    if (tmp___5 != 0) {
#line 490
      printk("\f%s: unable to move qp to error state\n", (char *)(& (priv->dev)->name));
    } else {

    }
  } else {

  }
#line 492
  return (0);
  err_modify: 
#line 495
  ib_destroy_qp(p->qp);
  err_qp: 
#line 497
  kfree((void const   *)p);
#line 498
  return (ret);
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_rx_handler(struct ib_cm_id *cm_id , struct ib_cm_event *event ) 
{ 
  struct ipoib_cm_rx *p ;
  struct ipoib_dev_priv *priv ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 507
  switch ((unsigned int )event->event) {
  case 1U: 
#line 509
  tmp = ipoib_cm_req_handler(cm_id, event);
#line 509
  return (tmp);
  case 7U: 
#line 511
  p = (struct ipoib_cm_rx *)cm_id->context;
#line 512
  ib_send_cm_drep(cm_id, (void const   *)0, 0);
  case 11U: 
#line 515
  p = (struct ipoib_cm_rx *)cm_id->context;
#line 516
  tmp___0 = netdev_priv((struct net_device  const  *)p->dev);
#line 516
  priv = (struct ipoib_dev_priv *)tmp___0;
#line 517
  tmp___1 = ib_modify_qp(p->qp, & ipoib_cm_err_attr, 1);
#line 517
  if (tmp___1 != 0) {
#line 518
    printk("\f%s: unable to move qp to error state\n", (char *)(& (priv->dev)->name));
  } else {

  }
  default: ;
#line 521
  return (0);
  }
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void skb_put_frags(struct sk_buff *skb , unsigned int hdr_space , unsigned int length ,
                          struct sk_buff *toskb ) 
{ 
  int i ;
  int num_frags ;
  unsigned int size ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned char *tmp ;
  skb_frag_t *frag ;
  unsigned char *tmp___0 ;
  struct page *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned int _min1___0 ;
  unsigned int _min2___0 ;

  {
#line 532
  _min1 = length;
#line 532
  _min2 = hdr_space;
#line 532
  size = _min1 < _min2 ? _min1 : _min2;
#line 533
  skb->tail = skb->tail + size;
#line 534
  skb->len = skb->len + size;
#line 535
  length = length - size;
#line 537
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 537
  num_frags = (int )((struct skb_shared_info *)tmp)->nr_frags;
#line 538
  i = 0;
#line 538
  goto ldv_53230;
  ldv_53229: 
#line 539
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 539
  frag = (skb_frag_t *)(& ((struct skb_shared_info *)tmp___0)->frags) + (unsigned long )i;
#line 541
  if (length == 0U) {
#line 543
    tmp___1 = skb_frag_page((skb_frag_t const   *)frag);
#line 543
    skb_fill_page_desc(toskb, i, tmp___1, 0, 4096);
#line 545
    tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 545
    ((struct skb_shared_info *)tmp___2)->nr_frags = (unsigned char )((int )((struct skb_shared_info *)tmp___2)->nr_frags - 1);
  } else {
#line 547
    _min1___0 = length;
#line 547
    _min2___0 = 4096U;
#line 547
    size = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 549
    skb_frag_size_set(frag, size);
#line 550
    skb->data_len = skb->data_len + size;
#line 551
    skb->truesize = skb->truesize + size;
#line 552
    skb->len = skb->len + size;
#line 553
    length = length - size;
  }
#line 538
  i = i + 1;
  ldv_53230: ;
#line 538
  if (i < num_frags) {
#line 540
    goto ldv_53229;
  } else {

  }

#line 545
  return;
}
}
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
void ipoib_cm_handle_rx_wc(struct net_device *dev , struct ib_wc *wc ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_rx_buf *rx_ring ;
  unsigned int wr_id ;
  struct sk_buff *skb ;
  struct sk_buff *newskb ;
  struct ipoib_cm_rx *p ;
  unsigned long flags ;
  u64 mapping[16U] ;
  int frags ;
  int has_srq ;
  struct sk_buff *small_skb ;
  raw_spinlock_t *tmp___0 ;
  long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  long tmp___3 ;
  raw_spinlock_t *tmp___4 ;
  long tmp___5 ;
  int dlen ;
  u32 _min1 ;
  unsigned int _min2 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
#line 560
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 560
  priv = (struct ipoib_dev_priv *)tmp;
#line 562
  wr_id = (unsigned int )wc->wr_id & 1073741823U;
#line 571
  if (data_debug_level___0 > 0) {
#line 571
    printk("\017%s: cm recv completion: id %d, status: %d\n", (char *)(& (priv->dev)->name),
           wr_id, (unsigned int )wc->status);
  } else {

  }
#line 574
  tmp___1 = ldv__builtin_expect((unsigned int )ipoib_recvq_size <= wr_id, 0L);
#line 574
  if (tmp___1 != 0L) {
#line 575
    if (wr_id == 1073741823U) {
#line 576
      tmp___0 = spinlock_check(& priv->lock);
#line 576
      flags = _raw_spin_lock_irqsave(tmp___0);
#line 577
      list_splice_init(& priv->cm.rx_drain_list, & priv->cm.rx_reap_list);
#line 578
      ipoib_cm_start_rx_drain(priv);
#line 579
      queue_work___3(priv->wq, & priv->cm.rx_reap_task);
#line 580
      spin_unlock_irqrestore(& priv->lock, flags);
    } else {
#line 582
      printk("\f%s: cm recv completion event with wrid %d (> %d)\n", (char *)(& (priv->dev)->name),
             wr_id, ipoib_recvq_size);
    }
#line 584
    return;
  } else {

  }
#line 587
  p = (struct ipoib_cm_rx *)(wc->qp)->qp_context;
#line 589
  has_srq = ipoib_cm_has_srq(dev);
#line 590
  rx_ring = has_srq != 0 ? priv->cm.srq_ring : p->rx_ring;
#line 592
  skb = (rx_ring + (unsigned long )wr_id)->skb;
#line 594
  tmp___3 = ldv__builtin_expect((unsigned int )wc->status != 0U, 0L);
#line 594
  if (tmp___3 != 0L) {
#line 595
    if (ipoib_debug_level > 0) {
#line 595
      printk("\017%s: cm recv error (status=%d, wrid=%d vend_err %x)\n", (char *)(& (priv->dev)->name),
             (unsigned int )wc->status, wr_id, wc->vendor_err);
    } else {

    }
#line 598
    dev->stats.rx_dropped = dev->stats.rx_dropped + 1UL;
#line 599
    if (has_srq != 0) {
#line 600
      goto repost;
    } else {
#line 602
      p->recv_count = p->recv_count - 1;
#line 602
      if (p->recv_count == 0) {
#line 603
        tmp___2 = spinlock_check(& priv->lock);
#line 603
        flags = _raw_spin_lock_irqsave(tmp___2);
#line 604
        list_move(& p->list, & priv->cm.rx_reap_list);
#line 605
        spin_unlock_irqrestore(& priv->lock, flags);
#line 606
        queue_work___3(priv->wq, & priv->cm.rx_reap_task);
      } else {

      }
#line 608
      return;
    }
  } else {

  }
#line 612
  tmp___5 = ldv__builtin_expect((wr_id & 3U) == 0U, 0L);
#line 612
  if (tmp___5 != 0L) {
#line 613
    if ((unsigned long )p != (unsigned long )((struct ipoib_cm_rx *)0) && (long )(((unsigned long )jiffies - p->jiffies) - 64000UL) >= 0L) {
#line 614
      tmp___4 = spinlock_check(& priv->lock);
#line 614
      flags = _raw_spin_lock_irqsave(tmp___4);
#line 615
      p->jiffies = jiffies;
#line 618
      if ((unsigned int )p->state == 0U) {
#line 619
        list_move(& p->list, & priv->cm.passive_ids);
      } else {

      }
#line 620
      spin_unlock_irqrestore(& priv->lock, flags);
    } else {

    }
  } else {

  }
#line 624
  if (wc->byte_len <= 255U) {
#line 625
    dlen = (int )wc->byte_len;
#line 627
    small_skb = dev_alloc_skb((unsigned int )(dlen + 12));
#line 628
    if ((unsigned long )small_skb != (unsigned long )((struct sk_buff *)0)) {
#line 629
      skb_reserve(small_skb, 12);
#line 630
      ib_dma_sync_single_for_cpu(priv->ca, (rx_ring + (unsigned long )wr_id)->mapping[0],
                                 (size_t )dlen, 2);
#line 632
      skb_copy_from_linear_data((struct sk_buff  const  *)skb, (void *)small_skb->data,
                                (unsigned int const   )dlen);
#line 633
      ib_dma_sync_single_for_device(priv->ca, (rx_ring + (unsigned long )wr_id)->mapping[0],
                                    (size_t )dlen, 2);
#line 635
      skb_put(small_skb, (unsigned int )dlen);
#line 636
      skb = small_skb;
#line 637
      goto copied;
    } else {

    }
  } else {

  }
#line 641
  _min1 = wc->byte_len;
#line 641
  _min2 = 4084U;
#line 641
  frags = (int )(((unsigned long )((wc->byte_len - (_min1 < _min2 ? _min1 : _min2)) + 4095U) & 4294963200UL) / 4096UL);
#line 644
  newskb = ipoib_cm_alloc_rx_skb(dev, rx_ring, (int )wr_id, frags, (u64 *)(& mapping),
                                 32U);
#line 646
  tmp___6 = ldv__builtin_expect((unsigned long )newskb == (unsigned long )((struct sk_buff *)0),
                             0L);
#line 646
  if (tmp___6 != 0L) {
#line 651
    if (ipoib_debug_level > 0) {
#line 651
      printk("\017%s: failed to allocate receive buffer %d\n", (char *)(& (priv->dev)->name),
             wr_id);
    } else {

    }
#line 652
    dev->stats.rx_dropped = dev->stats.rx_dropped + 1UL;
#line 653
    goto repost;
  } else {

  }
#line 656
  ipoib_cm_dma_unmap_rx(priv, frags, (u64 *)(& (rx_ring + (unsigned long )wr_id)->mapping));
#line 657
  memcpy((void *)(& (rx_ring + (unsigned long )wr_id)->mapping), (void const   *)(& mapping),
           (unsigned long )(frags + 1) * 8UL);
#line 659
  if (data_debug_level___0 > 0) {
#line 659
    printk("\017%s: received %d bytes, SLID 0x%04x\n", (char *)(& (priv->dev)->name),
           wc->byte_len, (int )wc->slid);
  } else {

  }
#line 662
  skb_put_frags(skb, 4084U, wc->byte_len, newskb);
  copied: 
#line 665
  skb->protocol = ((struct ipoib_header *)skb->data)->proto;
#line 666
  skb_reset_mac_header(skb);
#line 667
  skb_pull(skb, 4U);
#line 669
  dev->stats.rx_packets = dev->stats.rx_packets + 1UL;
#line 670
  dev->stats.rx_bytes = dev->stats.rx_bytes + (unsigned long )skb->len;
#line 672
  skb->dev = dev;
#line 674
  skb->pkt_type = 0U;
#line 675
  netif_receive_skb(skb);
  repost: ;
#line 678
  if (has_srq != 0) {
#line 679
    tmp___7 = ipoib_cm_post_receive_srq(dev, (int )wr_id);
#line 679
    tmp___8 = ldv__builtin_expect(tmp___7 != 0, 0L);
#line 679
    if (tmp___8 != 0L) {
#line 680
      printk("\f%s: ipoib_cm_post_receive_srq failed for buf %d\n", (char *)(& (priv->dev)->name),
             wr_id);
    } else {

    }
  } else {
#line 683
    tmp___9 = ipoib_cm_post_receive_nonsrq(dev, p, & priv->cm.rx_wr, (struct ib_sge *)(& priv->cm.rx_sge),
                                           (int )wr_id);
#line 683
    tmp___10 = ldv__builtin_expect(tmp___9 != 0, 0L);
#line 683
    if (tmp___10 != 0L) {
#line 687
      p->recv_count = p->recv_count - 1;
#line 688
      printk("\f%s: ipoib_cm_post_receive_nonsrq failed for buf %d\n", (char *)(& (priv->dev)->name),
             wr_id);
    } else {

    }
  }
#line 690
  return;
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
__inline static int post_send___0(struct ipoib_dev_priv *priv , struct ipoib_cm_tx *tx ,
                                  unsigned int wr_id , u64 addr , int len ) 
{ 
  struct ib_send_wr *bad_wr ;
  int tmp ;

  {
#line 701
  priv->tx_sge[0].addr = addr;
#line 702
  priv->tx_sge[0].length = (u32 )len;
#line 704
  priv->tx_wr.num_sge = 1;
#line 705
  priv->tx_wr.wr_id = (u64 )(wr_id | 1073741824U);
#line 707
  tmp = ib_post_send(tx->qp, & priv->tx_wr, & bad_wr);
#line 707
  return (tmp);
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
void ipoib_cm_send(struct net_device *dev , struct sk_buff *skb , struct ipoib_cm_tx *tx ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_tx_buf *tx_req ;
  u64 addr ;
  int rc ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 712
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 712
  priv = (struct ipoib_dev_priv *)tmp;
#line 717
  tmp___0 = ldv__builtin_expect(skb->len > tx->mtu, 0L);
#line 717
  if (tmp___0 != 0L) {
#line 718
    printk("\f%s: packet len %d (> %d) too long to send, dropping\n", (char *)(& (priv->dev)->name),
           skb->len, tx->mtu);
#line 720
    dev->stats.tx_dropped = dev->stats.tx_dropped + 1UL;
#line 721
    dev->stats.tx_errors = dev->stats.tx_errors + 1UL;
#line 722
    ipoib_cm_skb_too_long(dev, skb, tx->mtu - 4U);
#line 723
    return;
  } else {

  }
#line 726
  if (data_debug_level___0 > 0) {
#line 726
    printk("\017%s: sending packet: head 0x%x length %d connection 0x%x\n", (char *)(& (priv->dev)->name),
           tx->tx_head, skb->len, (tx->qp)->qp_num);
  } else {

  }
#line 736
  tx_req = tx->tx_ring + (unsigned long )(tx->tx_head & (unsigned int )(ipoib_sendq_size + -1));
#line 737
  tx_req->skb = skb;
#line 738
  addr = ib_dma_map_single___0(priv->ca, (void *)skb->data, (size_t )skb->len, 1);
#line 739
  tmp___1 = ib_dma_mapping_error(priv->ca, addr);
#line 739
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 739
  if (tmp___2 != 0L) {
#line 740
    dev->stats.tx_errors = dev->stats.tx_errors + 1UL;
#line 741
    dev_kfree_skb_any(skb);
#line 742
    return;
  } else {

  }
#line 745
  tx_req->mapping = addr;
#line 747
  skb_orphan___0(skb);
#line 748
  skb_dst_drop(skb);
#line 750
  rc = post_send___0(priv, tx, tx->tx_head & (unsigned int )(ipoib_sendq_size + -1),
                     addr, (int )skb->len);
#line 752
  tmp___3 = ldv__builtin_expect(rc != 0, 0L);
#line 752
  if (tmp___3 != 0L) {
#line 753
    printk("\f%s: post_send failed, error %d\n", (char *)(& (priv->dev)->name), rc);
#line 754
    dev->stats.tx_errors = dev->stats.tx_errors + 1UL;
#line 755
    ib_dma_unmap_single___0(priv->ca, addr, (size_t )skb->len, 1);
#line 756
    dev_kfree_skb_any(skb);
  } else {
#line 758
    dev->trans_start = jiffies;
#line 759
    tx->tx_head = tx->tx_head + 1U;
#line 761
    priv->tx_outstanding = priv->tx_outstanding + 1U;
#line 761
    if (priv->tx_outstanding == (unsigned int )ipoib_sendq_size) {
#line 762
      if (ipoib_debug_level > 0) {
#line 762
        printk("\017%s: TX ring 0x%x full, stopping kernel net queue\n", (char *)(& (priv->dev)->name),
               (tx->qp)->qp_num);
      } else {

      }
#line 764
      netif_stop_queue(dev);
#line 765
      rc = ib_req_notify_cq(priv->send_cq, 6);
#line 767
      if (rc < 0) {
#line 768
        printk("\f%s: request notify on send CQ failed\n", (char *)(& (priv->dev)->name));
      } else
#line 769
      if (rc != 0) {
#line 770
        ipoib_send_comp_handler(priv->send_cq, (void *)dev);
      } else {

      }
    } else {

    }
  }
#line 773
  return;
}
}
#line 775 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
void ipoib_cm_handle_tx_wc(struct net_device *dev , struct ib_wc *wc ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_tx *tx ;
  unsigned int wr_id ;
  struct ipoib_cm_tx_buf *tx_req ;
  unsigned long flags ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  struct ipoib_neigh *neigh ;
  raw_spinlock_t *tmp___4 ;
  int tmp___5 ;

  {
#line 777
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 777
  priv = (struct ipoib_dev_priv *)tmp;
#line 778
  tx = (struct ipoib_cm_tx *)(wc->qp)->qp_context;
#line 779
  wr_id = (unsigned int )wc->wr_id & 3221225471U;
#line 783
  if (data_debug_level___0 > 0) {
#line 783
    printk("\017%s: cm send completion: id %d, status: %d\n", (char *)(& (priv->dev)->name),
           wr_id, (unsigned int )wc->status);
  } else {

  }
#line 786
  tmp___0 = ldv__builtin_expect((unsigned int )ipoib_sendq_size <= wr_id, 0L);
#line 786
  if (tmp___0 != 0L) {
#line 787
    printk("\f%s: cm send completion event with wrid %d (> %d)\n", (char *)(& (priv->dev)->name),
           wr_id, ipoib_sendq_size);
#line 789
    return;
  } else {

  }
#line 792
  tx_req = tx->tx_ring + (unsigned long )wr_id;
#line 794
  ib_dma_unmap_single___0(priv->ca, tx_req->mapping, (size_t )(tx_req->skb)->len,
                          1);
#line 797
  dev->stats.tx_packets = dev->stats.tx_packets + 1UL;
#line 798
  dev->stats.tx_bytes = dev->stats.tx_bytes + (unsigned long )(tx_req->skb)->len;
#line 800
  dev_kfree_skb_any(tx_req->skb);
#line 802
  netif_tx_lock___2(dev);
#line 804
  tx->tx_tail = tx->tx_tail + 1U;
#line 805
  priv->tx_outstanding = priv->tx_outstanding - 1U;
#line 805
  tmp___1 = ldv__builtin_expect(priv->tx_outstanding == (unsigned int )(ipoib_sendq_size >> 1),
                             0L);
#line 805
  if (tmp___1 != 0L) {
#line 805
    tmp___2 = netif_queue_stopped((struct net_device  const  *)dev);
#line 805
    if ((int )tmp___2) {
#line 805
      tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->flags));
#line 805
      if (tmp___3 != 0) {
#line 808
        netif_wake_queue(dev);
      } else {

      }
    } else {

    }
  } else {

  }
#line 810
  if ((unsigned int )wc->status != 0U && (unsigned int )wc->status != 5U) {
#line 814
    if (ipoib_debug_level > 0) {
#line 814
      printk("\017%s: failed cm send event (status=%d, wrid=%d vend_err %x)\n", (char *)(& (priv->dev)->name),
             (unsigned int )wc->status, wr_id, wc->vendor_err);
    } else {

    }
#line 818
    tmp___4 = spinlock_check(& priv->lock);
#line 818
    flags = _raw_spin_lock_irqsave(tmp___4);
#line 819
    neigh = tx->neigh;
#line 821
    if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 822
      neigh->cm = (struct ipoib_cm_tx *)0;
#line 823
      ipoib_neigh_free(neigh);
#line 825
      tx->neigh = (struct ipoib_neigh *)0;
    } else {

    }
#line 828
    tmp___5 = test_and_clear_bit(1L, (unsigned long volatile   *)(& tx->flags));
#line 828
    if (tmp___5 != 0) {
#line 829
      list_move(& tx->list, & priv->cm.reap_list);
#line 830
      queue_work___3(priv->wq, & priv->cm.reap_task);
    } else {

    }
#line 833
    clear_bit(0L, (unsigned long volatile   *)(& tx->flags));
#line 835
    spin_unlock_irqrestore(& priv->lock, flags);
  } else {

  }
#line 838
  netif_tx_unlock___2(dev);
#line 839
  return;
}
}
#line 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
int ipoib_cm_dev_open(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int ret ;
  long tmp___0 ;
  bool tmp___1 ;
  __u64 tmp___2 ;

  {
#line 843
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 843
  priv = (struct ipoib_dev_priv *)tmp;
#line 846
  if ((int )((signed char )*(dev->dev_addr)) >= 0) {
#line 847
    return (0);
  } else {

  }
#line 849
  priv->cm.id = ib_create_cm_id(priv->ca, & ipoib_cm_rx_handler, (void *)dev);
#line 850
  tmp___1 = IS_ERR((void const   *)priv->cm.id);
#line 850
  if ((int )tmp___1) {
#line 851
    printk("\f%s: failed to create CM ID\n", (char *)(& (priv->ca)->name));
#line 852
    tmp___0 = PTR_ERR((void const   *)priv->cm.id);
#line 852
    ret = (int )tmp___0;
#line 853
    goto err_cm;
  } else {

  }
#line 856
  tmp___2 = __fswab64((unsigned long long )(priv->qp)->qp_num | 1152921504606846976ULL);
#line 856
  ret = ib_cm_listen(priv->cm.id, tmp___2, 0ULL, (struct ib_cm_compare_data *)0);
#line 858
  if (ret != 0) {
#line 859
    printk("\f%s: failed to listen on ID 0x%llx\n", (char *)(& (priv->ca)->name),
           (unsigned long long )(priv->qp)->qp_num | 1152921504606846976ULL);
#line 861
    goto err_listen;
  } else {

  }
#line 864
  return (0);
  err_listen: 
#line 867
  ib_destroy_cm_id(priv->cm.id);
  err_cm: 
#line 869
  priv->cm.id = (struct ib_cm_id *)0;
#line 870
  return (ret);
}
}
#line 873 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_free_rx_reap_list(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_rx *rx ;
  struct ipoib_cm_rx *n ;
  struct list_head list ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 875
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 875
  priv = (struct ipoib_dev_priv *)tmp;
#line 877
  list.next = & list;
#line 877
  list.prev = & list;
#line 879
  spin_lock_irq(& priv->lock);
#line 880
  list_splice_init(& priv->cm.rx_reap_list, & list);
#line 881
  spin_unlock_irq(& priv->lock);
#line 883
  __mptr = (struct list_head  const  *)list.next;
#line 883
  rx = (struct ipoib_cm_rx *)__mptr + 0xffffffffffffffe8UL;
#line 883
  __mptr___0 = (struct list_head  const  *)rx->list.next;
#line 883
  n = (struct ipoib_cm_rx *)__mptr___0 + 0xffffffffffffffe8UL;
#line 883
  goto ldv_53325;
  ldv_53324: 
#line 884
  ib_destroy_cm_id(rx->id);
#line 885
  ib_destroy_qp(rx->qp);
#line 886
  tmp___0 = ipoib_cm_has_srq(dev);
#line 886
  if (tmp___0 == 0) {
#line 887
    ipoib_cm_free_rx_ring(priv->dev, rx->rx_ring);
#line 888
    spin_lock_irq(& priv->lock);
#line 889
    priv->cm.nonsrq_conn_qp = priv->cm.nonsrq_conn_qp - 1;
#line 890
    spin_unlock_irq(& priv->lock);
  } else {

  }
#line 892
  kfree((void const   *)rx);
#line 883
  rx = n;
#line 883
  __mptr___1 = (struct list_head  const  *)n->list.next;
#line 883
  n = (struct ipoib_cm_rx *)__mptr___1 + 0xffffffffffffffe8UL;
  ldv_53325: ;
#line 883
  if ((unsigned long )(& rx->list) != (unsigned long )(& list)) {
#line 885
    goto ldv_53324;
  } else {

  }

#line 890
  return;
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
void ipoib_cm_dev_stop(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_rx *p ;
  unsigned long begin ;
  int ret ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 898
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 898
  priv = (struct ipoib_dev_priv *)tmp;
#line 903
  if ((int )((signed char )*(dev->dev_addr)) >= 0 || (unsigned long )priv->cm.id == (unsigned long )((struct ib_cm_id *)0)) {
#line 904
    return;
  } else {

  }
#line 906
  ib_destroy_cm_id(priv->cm.id);
#line 907
  priv->cm.id = (struct ib_cm_id *)0;
#line 909
  spin_lock_irq(& priv->lock);
#line 910
  goto ldv_53337;
  ldv_53336: 
#line 911
  __mptr = (struct list_head  const  *)priv->cm.passive_ids.next;
#line 911
  p = (struct ipoib_cm_rx *)__mptr + 0xffffffffffffffe8UL;
#line 912
  list_move(& p->list, & priv->cm.rx_error_list);
#line 913
  p->state = 1;
#line 914
  spin_unlock_irq(& priv->lock);
#line 915
  ret = ib_modify_qp(p->qp, & ipoib_cm_err_attr, 1);
#line 916
  if (ret != 0) {
#line 917
    printk("\f%s: unable to move qp to error state: %d\n", (char *)(& (priv->dev)->name),
           ret);
  } else {

  }
#line 918
  spin_lock_irq(& priv->lock);
  ldv_53337: 
#line 910
  tmp___0 = list_empty((struct list_head  const  *)(& priv->cm.passive_ids));
#line 910
  if (tmp___0 == 0) {
#line 912
    goto ldv_53336;
  } else {

  }
#line 922
  begin = jiffies;
#line 924
  goto ldv_53347;
  ldv_53346: ;
#line 927
  if ((long )((begin - (unsigned long )jiffies) + 1250UL) < 0L) {
#line 928
    printk("\f%s: RX drain timing out\n", (char *)(& (priv->dev)->name));
#line 933
    list_splice_init(& priv->cm.rx_flush_list, & priv->cm.rx_reap_list);
#line 935
    list_splice_init(& priv->cm.rx_error_list, & priv->cm.rx_reap_list);
#line 937
    list_splice_init(& priv->cm.rx_drain_list, & priv->cm.rx_reap_list);
#line 939
    goto ldv_53345;
  } else {

  }
#line 941
  spin_unlock_irq(& priv->lock);
#line 942
  msleep(1U);
#line 943
  ipoib_drain_cq(dev);
#line 944
  spin_lock_irq(& priv->lock);
  ldv_53347: 
#line 924
  tmp___1 = list_empty((struct list_head  const  *)(& priv->cm.rx_error_list));
#line 924
  if (tmp___1 == 0) {
#line 928
    goto ldv_53346;
  } else {
#line 924
    tmp___2 = list_empty((struct list_head  const  *)(& priv->cm.rx_flush_list));
#line 924
    if (tmp___2 == 0) {
#line 928
      goto ldv_53346;
    } else {
#line 924
      tmp___3 = list_empty((struct list_head  const  *)(& priv->cm.rx_drain_list));
#line 924
      if (tmp___3 == 0) {
#line 928
        goto ldv_53346;
      } else {
#line 931
        goto ldv_53345;
      }
    }
  }
  ldv_53345: 
#line 947
  spin_unlock_irq(& priv->lock);
#line 949
  ipoib_cm_free_rx_reap_list(dev);
#line 951
  ldv_cancel_delayed_work_166(& priv->cm.stale_task);
#line 952
  return;
}
}
#line 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_rep_handler(struct ib_cm_id *cm_id , struct ib_cm_event *event ) 
{ 
  struct ipoib_cm_tx *p ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_data *data ;
  struct sk_buff_head skqueue ;
  struct ib_qp_attr qp_attr ;
  int qp_attr_mask ;
  int ret ;
  struct sk_buff *skb ;
  __u32 tmp___0 ;
  int tmp___1 ;

  {
#line 956
  p = (struct ipoib_cm_tx *)cm_id->context;
#line 957
  tmp = netdev_priv((struct net_device  const  *)p->dev);
#line 957
  priv = (struct ipoib_dev_priv *)tmp;
#line 958
  data = (struct ipoib_cm_data *)event->private_data;
#line 964
  tmp___0 = __fswab32(data->mtu);
#line 964
  p->mtu = tmp___0;
#line 966
  if (p->mtu <= 4U) {
#line 967
    printk("\f%s: Rejecting connection: mtu %d <= %d\n", (char *)(& (priv->dev)->name),
           p->mtu, 4);
#line 969
    return (-22);
  } else {

  }
#line 972
  qp_attr.qp_state = 2;
#line 973
  ret = ib_cm_init_qp_attr(cm_id, & qp_attr, & qp_attr_mask);
#line 974
  if (ret != 0) {
#line 975
    printk("\f%s: failed to init QP attr for RTR: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 976
    return (ret);
  } else {

  }
#line 979
  qp_attr.rq_psn = 0U;
#line 980
  ret = ib_modify_qp(p->qp, & qp_attr, qp_attr_mask);
#line 981
  if (ret != 0) {
#line 982
    printk("\f%s: failed to modify QP to RTR: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 983
    return (ret);
  } else {

  }
#line 986
  qp_attr.qp_state = 3;
#line 987
  ret = ib_cm_init_qp_attr(cm_id, & qp_attr, & qp_attr_mask);
#line 988
  if (ret != 0) {
#line 989
    printk("\f%s: failed to init QP attr for RTS: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 990
    return (ret);
  } else {

  }
#line 992
  ret = ib_modify_qp(p->qp, & qp_attr, qp_attr_mask);
#line 993
  if (ret != 0) {
#line 994
    printk("\f%s: failed to modify QP to RTS: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 995
    return (ret);
  } else {

  }
#line 998
  skb_queue_head_init(& skqueue);
#line 1000
  spin_lock_irq(& priv->lock);
#line 1001
  set_bit(0L, (unsigned long volatile   *)(& p->flags));
#line 1002
  if ((unsigned long )p->neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 1003
    goto ldv_53361;
    ldv_53360: 
#line 1004
    __skb_queue_tail(& skqueue, skb);
    ldv_53361: 
#line 1003
    skb = __skb_dequeue(& (p->neigh)->queue);
#line 1003
    if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1005
      goto ldv_53360;
    } else {

    }

  } else {

  }
#line 1005
  spin_unlock_irq(& priv->lock);
#line 1007
  goto ldv_53364;
  ldv_53363: 
#line 1008
  skb->dev = p->dev;
#line 1009
  tmp___1 = dev_queue_xmit(skb);
#line 1009
  if (tmp___1 != 0) {
#line 1010
    printk("\f%s: dev_queue_xmit failed to requeue packet\n", (char *)(& (priv->dev)->name));
  } else {

  }
  ldv_53364: 
#line 1007
  skb = __skb_dequeue(& skqueue);
#line 1007
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1009
    goto ldv_53363;
  } else {

  }
#line 1014
  ret = ib_send_cm_rtu(cm_id, (void const   *)0, 0);
#line 1015
  if (ret != 0) {
#line 1016
    printk("\f%s: failed to send RTU: %d\n", (char *)(& (priv->dev)->name), ret);
#line 1017
    return (ret);
  } else {

  }
#line 1019
  return (0);
}
}
#line 1022 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static struct ib_qp *ipoib_cm_create_tx_qp(struct net_device *dev , struct ipoib_cm_tx *tx ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_qp_init_attr attr ;
  struct ib_qp *tx_qp ;
  long tmp___0 ;

  {
#line 1024
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1024
  priv = (struct ipoib_dev_priv *)tmp;
#line 1025
  attr.event_handler = 0;
#line 1025
  attr.qp_context = (void *)tx;
#line 1025
  attr.send_cq = priv->recv_cq;
#line 1025
  attr.recv_cq = priv->recv_cq;
#line 1025
  attr.srq = priv->cm.srq;
#line 1025
  attr.xrcd = 0;
#line 1025
  attr.cap.max_send_wr = (unsigned int )ipoib_sendq_size;
#line 1025
  attr.cap.max_recv_wr = 0U;
#line 1025
  attr.cap.max_send_sge = 1U;
#line 1025
  attr.cap.max_recv_sge = 0U;
#line 1025
  attr.cap.max_inline_data = 0U;
#line 1025
  attr.sq_sig_type = 0;
#line 1025
  attr.qp_type = 2;
#line 1025
  attr.create_flags = 128;
#line 1025
  attr.port_num = (unsigned char)0;
#line 1039
  tx_qp = ib_create_qp(priv->pd, & attr);
#line 1040
  tmp___0 = PTR_ERR((void const   *)tx_qp);
#line 1040
  if (tmp___0 == -22L) {
#line 1041
    printk("\f%s: can\'t use GFP_NOIO for QPs on device %s, using GFP_KERNEL\n", (char *)(& (priv->dev)->name),
           (char *)(& (priv->ca)->name));
#line 1043
    attr.create_flags = (enum ib_qp_create_flags )((int )attr.create_flags & -129);
#line 1044
    tx_qp = ib_create_qp(priv->pd, & attr);
  } else {

  }
#line 1046
  return (tx_qp);
}
}
#line 1049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_send_req(struct net_device *dev , struct ib_cm_id *id , struct ib_qp *qp ,
                             u32 qpn , struct ib_sa_path_rec *pathrec ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_data data ;
  struct ib_cm_req_param req ;
  __u32 tmp___0 ;
  __u64 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1054
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1054
  priv = (struct ipoib_dev_priv *)tmp;
#line 1055
  data.qpn = 0U;
#line 1055
  data.mtu = 0U;
#line 1056
  req.primary_path = 0;
#line 1056
  req.alternate_path = 0;
#line 1056
  req.service_id = 0ULL;
#line 1056
  req.qp_num = 0U;
#line 1056
  req.qp_type = 0;
#line 1056
  req.starting_psn = 0U;
#line 1056
  req.private_data = 0;
#line 1056
  req.private_data_len = (unsigned char)0;
#line 1056
  req.peer_to_peer = (unsigned char)0;
#line 1056
  req.responder_resources = (unsigned char)0;
#line 1056
  req.initiator_depth = (unsigned char)0;
#line 1056
  req.remote_cm_response_timeout = (unsigned char)0;
#line 1056
  req.flow_control = (unsigned char)0;
#line 1056
  req.local_cm_response_timeout = (unsigned char)0;
#line 1056
  req.retry_count = (unsigned char)0;
#line 1056
  req.rnr_retry_count = (unsigned char)0;
#line 1056
  req.max_cm_retries = (unsigned char)0;
#line 1056
  req.srq = (unsigned char)0;
#line 1058
  tmp___0 = __fswab32((priv->qp)->qp_num);
#line 1058
  data.qpn = tmp___0;
#line 1059
  data.mtu = 4110352384U;
#line 1061
  req.primary_path = pathrec;
#line 1062
  req.alternate_path = (struct ib_sa_path_rec *)0;
#line 1063
  tmp___1 = __fswab64((unsigned long long )qpn | 1152921504606846976ULL);
#line 1063
  req.service_id = tmp___1;
#line 1064
  req.qp_num = qp->qp_num;
#line 1065
  req.qp_type = qp->qp_type;
#line 1066
  req.private_data = (void const   *)(& data);
#line 1067
  req.private_data_len = 8U;
#line 1068
  req.flow_control = 0U;
#line 1070
  req.starting_psn = 0U;
#line 1076
  req.responder_resources = 4U;
#line 1077
  req.remote_cm_response_timeout = 20U;
#line 1078
  req.local_cm_response_timeout = 20U;
#line 1079
  req.retry_count = 0U;
#line 1080
  req.rnr_retry_count = 0U;
#line 1081
  req.max_cm_retries = 15U;
#line 1082
  tmp___2 = ipoib_cm_has_srq(dev);
#line 1082
  req.srq = (u8 )tmp___2;
#line 1083
  tmp___3 = ib_send_cm_req(id, & req);
#line 1083
  return (tmp___3);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_modify_tx_init(struct net_device *dev , struct ib_cm_id *cm_id ,
                                   struct ib_qp *qp ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_qp_attr qp_attr ;
  int qp_attr_mask ;
  int ret ;

  {
#line 1089
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1089
  priv = (struct ipoib_dev_priv *)tmp;
#line 1092
  ret = ib_find_pkey(priv->ca, (int )priv->port, (int )priv->pkey, & qp_attr.pkey_index);
#line 1093
  if (ret != 0) {
#line 1094
    printk("\f%s: pkey 0x%x not found: %d\n", (char *)(& (priv->dev)->name), (int )priv->pkey,
           ret);
#line 1095
    return (ret);
  } else {

  }
#line 1098
  qp_attr.qp_state = 1;
#line 1099
  qp_attr.qp_access_flags = 1;
#line 1100
  qp_attr.port_num = priv->port;
#line 1101
  qp_attr_mask = 57;
#line 1103
  ret = ib_modify_qp(qp, & qp_attr, qp_attr_mask);
#line 1104
  if (ret != 0) {
#line 1105
    printk("\f%s: failed to modify tx QP to INIT: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 1106
    return (ret);
  } else {

  }
#line 1108
  return (0);
}
}
#line 1111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_tx_init(struct ipoib_cm_tx *p , u32 qpn , struct ib_sa_path_rec *pathrec ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int ret ;
  pgprot_t __constr_expr_0 ;
  void *tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;

  {
#line 1114
  tmp = netdev_priv((struct net_device  const  *)p->dev);
#line 1114
  priv = (struct ipoib_dev_priv *)tmp;
#line 1117
  __constr_expr_0.pgprot = 0x8000000000000163UL;
#line 1117
  tmp___0 = __vmalloc((unsigned long )ipoib_sendq_size * 16UL, 16U, __constr_expr_0);
#line 1117
  p->tx_ring = (struct ipoib_cm_tx_buf *)tmp___0;
#line 1119
  if ((unsigned long )p->tx_ring == (unsigned long )((struct ipoib_cm_tx_buf *)0)) {
#line 1120
    printk("\f%s: failed to allocate tx ring\n", (char *)(& (priv->dev)->name));
#line 1121
    ret = -12;
#line 1122
    goto err_tx;
  } else {

  }
#line 1124
  memset((void *)p->tx_ring, 0, (unsigned long )ipoib_sendq_size * 16UL);
#line 1126
  p->qp = ipoib_cm_create_tx_qp(p->dev, p);
#line 1127
  tmp___2 = IS_ERR((void const   *)p->qp);
#line 1127
  if ((int )tmp___2) {
#line 1128
    tmp___1 = PTR_ERR((void const   *)p->qp);
#line 1128
    ret = (int )tmp___1;
#line 1129
    printk("\f%s: failed to allocate tx qp: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 1130
    goto err_qp;
  } else {

  }
#line 1133
  p->id = ib_create_cm_id(priv->ca, & ipoib_cm_tx_handler, (void *)p);
#line 1134
  tmp___4 = IS_ERR((void const   *)p->id);
#line 1134
  if ((int )tmp___4) {
#line 1135
    tmp___3 = PTR_ERR((void const   *)p->id);
#line 1135
    ret = (int )tmp___3;
#line 1136
    printk("\f%s: failed to create tx cm id: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 1137
    goto err_id;
  } else {

  }
#line 1140
  ret = ipoib_cm_modify_tx_init(p->dev, p->id, p->qp);
#line 1141
  if (ret != 0) {
#line 1142
    printk("\f%s: failed to modify tx qp to rtr: %d\n", (char *)(& (priv->dev)->name),
           ret);
#line 1143
    goto err_modify;
  } else {

  }
#line 1146
  ret = ipoib_cm_send_req(p->dev, p->id, p->qp, qpn, pathrec);
#line 1147
  if (ret != 0) {
#line 1148
    printk("\f%s: failed to send cm req: %d\n", (char *)(& (priv->dev)->name), ret);
#line 1149
    goto err_send_cm;
  } else {

  }
#line 1152
  if (ipoib_debug_level > 0) {
#line 1152
    printk("\017%s: Request connection 0x%x for gid %pI6 qpn 0x%x\n", (char *)(& (priv->dev)->name),
           (p->qp)->qp_num, (u8 *)(& pathrec->dgid.raw), qpn);
  } else {

  }
#line 1155
  return (0);
  err_send_cm: ;
  err_modify: 
#line 1159
  ib_destroy_cm_id(p->id);
  err_id: 
#line 1161
  p->id = (struct ib_cm_id *)0;
#line 1162
  ib_destroy_qp(p->qp);
  err_qp: 
#line 1164
  p->qp = (struct ib_qp *)0;
#line 1165
  vfree((void const   *)p->tx_ring);
  err_tx: ;
#line 1167
  return (ret);
}
}
#line 1170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_tx_destroy(struct ipoib_cm_tx *p ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_tx_buf *tx_req ;
  unsigned long begin ;
  long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 1172
  tmp = netdev_priv((struct net_device  const  *)p->dev);
#line 1172
  priv = (struct ipoib_dev_priv *)tmp;
#line 1176
  if (ipoib_debug_level > 0) {
#line 1176
    printk("\017%s: Destroy active connection 0x%x head 0x%x tail 0x%x\n", (char *)(& (priv->dev)->name),
           (unsigned long )p->qp != (unsigned long )((struct ib_qp *)0) ? (p->qp)->qp_num : 0U,
           p->tx_head, p->tx_tail);
  } else {

  }
#line 1179
  if ((unsigned long )p->id != (unsigned long )((struct ib_cm_id *)0)) {
#line 1180
    ib_destroy_cm_id(p->id);
  } else {

  }
#line 1182
  if ((unsigned long )p->tx_ring != (unsigned long )((struct ipoib_cm_tx_buf *)0)) {
#line 1184
    begin = jiffies;
#line 1185
    goto ldv_53419;
    ldv_53418: ;
#line 1186
    if ((long )((begin - (unsigned long )jiffies) + 1250UL) < 0L) {
#line 1187
      printk("\f%s: timing out; %d sends not completed\n", (char *)(& (priv->dev)->name),
             p->tx_head - p->tx_tail);
#line 1189
      goto timeout;
    } else {

    }
#line 1192
    msleep(1U);
    ldv_53419: ;
#line 1185
    if ((int )p->tx_tail - (int )p->tx_head < 0) {
#line 1187
      goto ldv_53418;
    } else {

    }

  } else {

  }
  timeout: ;
#line 1198
  goto ldv_53422;
  ldv_53421: 
#line 1199
  tx_req = p->tx_ring + (unsigned long )(p->tx_tail & (unsigned int )(ipoib_sendq_size + -1));
#line 1200
  ib_dma_unmap_single___0(priv->ca, tx_req->mapping, (size_t )(tx_req->skb)->len,
                          1);
#line 1202
  dev_kfree_skb_any(tx_req->skb);
#line 1203
  p->tx_tail = p->tx_tail + 1U;
#line 1204
  netif_tx_lock_bh___2(p->dev);
#line 1205
  priv->tx_outstanding = priv->tx_outstanding - 1U;
#line 1205
  tmp___0 = ldv__builtin_expect(priv->tx_outstanding == (unsigned int )(ipoib_sendq_size >> 1),
                             0L);
#line 1205
  if (tmp___0 != 0L) {
#line 1205
    tmp___1 = netif_queue_stopped((struct net_device  const  *)p->dev);
#line 1205
    if ((int )tmp___1) {
#line 1205
      tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->flags));
#line 1205
      if (tmp___2 != 0) {
#line 1208
        netif_wake_queue(p->dev);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1209
  netif_tx_unlock_bh___2(p->dev);
  ldv_53422: ;
#line 1198
  if ((int )p->tx_tail - (int )p->tx_head < 0) {
#line 1200
    goto ldv_53421;
  } else {

  }

#line 1212
  if ((unsigned long )p->qp != (unsigned long )((struct ib_qp *)0)) {
#line 1213
    ib_destroy_qp(p->qp);
  } else {

  }
#line 1215
  vfree((void const   *)p->tx_ring);
#line 1216
  kfree((void const   *)p);
#line 1217
  return;
}
}
#line 1219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static int ipoib_cm_tx_handler(struct ib_cm_id *cm_id , struct ib_cm_event *event ) 
{ 
  struct ipoib_cm_tx *tx ;
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct net_device *dev ;
  struct ipoib_neigh *neigh ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
#line 1222
  tx = (struct ipoib_cm_tx *)cm_id->context;
#line 1223
  tmp = netdev_priv((struct net_device  const  *)tx->dev);
#line 1223
  priv = (struct ipoib_dev_priv *)tmp;
#line 1224
  dev = priv->dev;
#line 1229
  switch ((unsigned int )event->event) {
  case 7U: ;
#line 1231
  if (ipoib_debug_level > 0) {
#line 1231
    printk("\017%s: DREQ received.\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 1232
  ib_send_cm_drep(cm_id, (void const   *)0, 0);
#line 1233
  goto ldv_53435;
  case 3U: ;
#line 1235
  if (ipoib_debug_level > 0) {
#line 1235
    printk("\017%s: REP received.\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 1236
  ret = ipoib_cm_rep_handler(cm_id, event);
#line 1237
  if (ret != 0) {
#line 1238
    ib_send_cm_rej(cm_id, 28, (void *)0, 0, (void const   *)0, 0);
  } else {

  }
#line 1240
  goto ldv_53435;
  case 0U: ;
  case 11U: ;
  case 9U: ;
#line 1244
  if (ipoib_debug_level > 0) {
#line 1244
    printk("\017%s: CM error %d.\n", (char *)(& (priv->dev)->name), (unsigned int )event->event);
  } else {

  }
#line 1245
  netif_tx_lock_bh___2(dev);
#line 1246
  tmp___0 = spinlock_check(& priv->lock);
#line 1246
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1247
  neigh = tx->neigh;
#line 1249
  if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 1250
    neigh->cm = (struct ipoib_cm_tx *)0;
#line 1251
    ipoib_neigh_free(neigh);
#line 1253
    tx->neigh = (struct ipoib_neigh *)0;
  } else {

  }
#line 1256
  tmp___1 = test_and_clear_bit(1L, (unsigned long volatile   *)(& tx->flags));
#line 1256
  if (tmp___1 != 0) {
#line 1257
    list_move(& tx->list, & priv->cm.reap_list);
#line 1258
    queue_work___3(priv->wq, & priv->cm.reap_task);
  } else {

  }
#line 1261
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1262
  netif_tx_unlock_bh___2(dev);
#line 1263
  goto ldv_53435;
  default: ;
#line 1265
  goto ldv_53435;
  }
  ldv_53435: ;
#line 1268
  return (0);
}
}
#line 1271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
struct ipoib_cm_tx *ipoib_cm_create_tx(struct net_device *dev , struct ipoib_path *path ,
                                       struct ipoib_neigh *neigh ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ipoib_cm_tx *tx ;
  void *tmp___0 ;

  {
#line 1274
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1274
  priv = (struct ipoib_dev_priv *)tmp;
#line 1277
  tmp___0 = kzalloc(88UL, 32U);
#line 1277
  tx = (struct ipoib_cm_tx *)tmp___0;
#line 1278
  if ((unsigned long )tx == (unsigned long )((struct ipoib_cm_tx *)0)) {
#line 1279
    return ((struct ipoib_cm_tx *)0);
  } else {

  }
#line 1281
  neigh->cm = tx;
#line 1282
  tx->neigh = neigh;
#line 1283
  tx->path = path;
#line 1284
  tx->dev = dev;
#line 1285
  list_add(& tx->list, & priv->cm.start_list);
#line 1286
  set_bit(1L, (unsigned long volatile   *)(& tx->flags));
#line 1287
  queue_work___3(priv->wq, & priv->cm.start_task);
#line 1288
  return (tx);
}
}
#line 1291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
void ipoib_cm_destroy_tx(struct ipoib_cm_tx *tx ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
#line 1293
  tmp = netdev_priv((struct net_device  const  *)tx->dev);
#line 1293
  priv = (struct ipoib_dev_priv *)tmp;
#line 1295
  tmp___1 = test_and_clear_bit(1L, (unsigned long volatile   *)(& tx->flags));
#line 1295
  if (tmp___1 != 0) {
#line 1296
    tmp___0 = spinlock_check(& priv->lock);
#line 1296
    flags = _raw_spin_lock_irqsave(tmp___0);
#line 1297
    list_move(& tx->list, & priv->cm.reap_list);
#line 1298
    queue_work___3(priv->wq, & priv->cm.reap_task);
#line 1299
    if (ipoib_debug_level > 0) {
#line 1299
      printk("\017%s: Reap connection for gid %pI6\n", (char *)(& (priv->dev)->name),
             (u8 *)(& (tx->neigh)->daddr) + 4UL);
    } else {

    }
#line 1301
    tx->neigh = (struct ipoib_neigh *)0;
#line 1302
    spin_unlock_irqrestore(& priv->lock, flags);
  } else {

  }
#line 1304
  return;
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_tx_start(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct net_device *dev ;
  struct ipoib_neigh *neigh ;
  struct ipoib_cm_tx *p ;
  unsigned long flags ;
  int ret ;
  struct ib_sa_path_rec pathrec ;
  u32 qpn ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr___0 ;
  __u32 tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;

  {
#line 1308
  __mptr = (struct work_struct  const  *)work;
#line 1308
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff0a8UL;
#line 1310
  dev = priv->dev;
#line 1319
  netif_tx_lock_bh___2(dev);
#line 1320
  tmp = spinlock_check(& priv->lock);
#line 1320
  flags = _raw_spin_lock_irqsave(tmp);
#line 1322
  goto ldv_53481;
  ldv_53480: 
#line 1323
  __mptr___0 = (struct list_head  const  *)priv->cm.start_list.next;
#line 1323
  p = (struct ipoib_cm_tx *)__mptr___0 + 0xfffffffffffffff0UL;
#line 1324
  list_del_init(& p->list);
#line 1325
  neigh = p->neigh;
#line 1326
  tmp___0 = __be32_to_cpup((__be32 const   *)(& neigh->daddr));
#line 1326
  qpn = tmp___0 & 16777215U;
#line 1327
  memcpy((void *)(& pathrec), (void const   *)(& (p->path)->pathrec), 88UL);
#line 1329
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1330
  netif_tx_unlock_bh___2(dev);
#line 1332
  ret = ipoib_cm_tx_init(p, qpn, & pathrec);
#line 1334
  netif_tx_lock_bh___2(dev);
#line 1335
  tmp___1 = spinlock_check(& priv->lock);
#line 1335
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 1337
  if (ret != 0) {
#line 1338
    neigh = p->neigh;
#line 1339
    if ((unsigned long )neigh != (unsigned long )((struct ipoib_neigh *)0)) {
#line 1340
      neigh->cm = (struct ipoib_cm_tx *)0;
#line 1341
      ipoib_neigh_free(neigh);
    } else {

    }
#line 1343
    list_del(& p->list);
#line 1344
    kfree((void const   *)p);
  } else {

  }
  ldv_53481: 
#line 1322
  tmp___2 = list_empty((struct list_head  const  *)(& priv->cm.start_list));
#line 1322
  if (tmp___2 == 0) {
#line 1324
    goto ldv_53480;
  } else {

  }
#line 1348
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1349
  netif_tx_unlock_bh___2(dev);
#line 1350
  return;
}
}
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_tx_reap(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct net_device *dev ;
  struct ipoib_cm_tx *p ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr___0 ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
#line 1354
  __mptr = (struct work_struct  const  *)work;
#line 1354
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff058UL;
#line 1356
  dev = priv->dev;
#line 1360
  netif_tx_lock_bh___2(dev);
#line 1361
  tmp = spinlock_check(& priv->lock);
#line 1361
  flags = _raw_spin_lock_irqsave(tmp);
#line 1363
  goto ldv_53501;
  ldv_53500: 
#line 1364
  __mptr___0 = (struct list_head  const  *)priv->cm.reap_list.next;
#line 1364
  p = (struct ipoib_cm_tx *)__mptr___0 + 0xfffffffffffffff0UL;
#line 1365
  list_del(& p->list);
#line 1366
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1367
  netif_tx_unlock_bh___2(dev);
#line 1368
  ipoib_cm_tx_destroy(p);
#line 1369
  netif_tx_lock_bh___2(dev);
#line 1370
  tmp___0 = spinlock_check(& priv->lock);
#line 1370
  flags = _raw_spin_lock_irqsave(tmp___0);
  ldv_53501: 
#line 1363
  tmp___1 = list_empty((struct list_head  const  *)(& priv->cm.reap_list));
#line 1363
  if (tmp___1 == 0) {
#line 1365
    goto ldv_53500;
  } else {

  }
#line 1373
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1374
  netif_tx_unlock_bh___2(dev);
#line 1375
  return;
}
}
#line 1377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_skb_reap(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct net_device *dev ;
  struct sk_buff *skb ;
  unsigned long flags ;
  unsigned int mtu ;
  raw_spinlock_t *tmp ;
  __u32 tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 1379
  __mptr = (struct work_struct  const  *)work;
#line 1379
  priv = (struct ipoib_dev_priv *)__mptr + 0xfffffffffffff008UL;
#line 1381
  dev = priv->dev;
#line 1384
  mtu = priv->mcast_mtu;
#line 1386
  netif_tx_lock_bh___2(dev);
#line 1387
  tmp = spinlock_check(& priv->lock);
#line 1387
  flags = _raw_spin_lock_irqsave(tmp);
#line 1389
  goto ldv_53520;
  ldv_53519: 
#line 1390
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1391
  netif_tx_unlock_bh___2(dev);
#line 1393
  if ((unsigned int )skb->protocol == 8U) {
#line 1394
    tmp___0 = __fswab32(mtu);
#line 1394
    icmp_send(skb, 3, 4, tmp___0);
  } else
#line 1396
  if ((unsigned int )skb->protocol == 56710U) {
#line 1397
    icmpv6_send(skb, 2, 0, mtu);
  } else {

  }
#line 1399
  dev_kfree_skb_any(skb);
#line 1401
  netif_tx_lock_bh___2(dev);
#line 1402
  tmp___1 = spinlock_check(& priv->lock);
#line 1402
  flags = _raw_spin_lock_irqsave(tmp___1);
  ldv_53520: 
#line 1389
  skb = skb_dequeue(& priv->cm.skb_queue);
#line 1389
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1391
    goto ldv_53519;
  } else {

  }
#line 1405
  spin_unlock_irqrestore(& priv->lock, flags);
#line 1406
  netif_tx_unlock_bh___2(dev);
#line 1407
  return;
}
}
#line 1409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
void ipoib_cm_skb_too_long(struct net_device *dev , struct sk_buff *skb , unsigned int mtu ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int e ;
  int tmp___0 ;
  struct dst_entry *tmp___1 ;
  struct dst_entry *tmp___2 ;
  struct dst_entry *tmp___3 ;

  {
#line 1412
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1412
  priv = (struct ipoib_dev_priv *)tmp;
#line 1413
  tmp___0 = skb_queue_empty((struct sk_buff_head  const  *)(& priv->cm.skb_queue));
#line 1413
  e = tmp___0;
#line 1415
  tmp___3 = skb_dst((struct sk_buff  const  *)skb);
#line 1415
  if ((unsigned long )tmp___3 != (unsigned long )((struct dst_entry *)0)) {
#line 1416
    tmp___1 = skb_dst((struct sk_buff  const  *)skb);
#line 1416
    tmp___2 = skb_dst((struct sk_buff  const  *)skb);
#line 1416
    (*((tmp___1->ops)->update_pmtu))(tmp___2, (struct sock *)0, skb, mtu);
  } else {

  }
#line 1418
  skb_queue_tail(& priv->cm.skb_queue, skb);
#line 1419
  if (e != 0) {
#line 1420
    queue_work___3(priv->wq, & priv->cm.skb_task);
  } else {

  }
#line 1421
  return;
}
}
#line 1423 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_rx_reap(struct work_struct *work ) 
{ 
  struct work_struct  const  *__mptr ;

  {
#line 1425
  __mptr = (struct work_struct  const  *)work;
#line 1425
  ipoib_cm_free_rx_reap_list(((struct ipoib_dev_priv *)__mptr + 0xffffffffffffefb8UL)->dev);
#line 1427
  return;
}
}
#line 1429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_stale_task(struct work_struct *work ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct ipoib_cm_rx *p ;
  int ret ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1431
  __mptr = (struct work_struct  const  *)work;
#line 1431
  priv = (struct ipoib_dev_priv *)__mptr + 0xffffffffffffef68UL;
#line 1436
  spin_lock_irq(& priv->lock);
#line 1437
  goto ldv_53552;
  ldv_53551: 
#line 1440
  __mptr___0 = (struct list_head  const  *)priv->cm.passive_ids.prev;
#line 1440
  p = (struct ipoib_cm_rx *)__mptr___0 + 0xffffffffffffffe8UL;
#line 1441
  if ((long )((p->jiffies - (unsigned long )jiffies) + 128000UL) >= 0L) {
#line 1442
    goto ldv_53550;
  } else {

  }
#line 1443
  list_move(& p->list, & priv->cm.rx_error_list);
#line 1444
  p->state = 1;
#line 1445
  spin_unlock_irq(& priv->lock);
#line 1446
  ret = ib_modify_qp(p->qp, & ipoib_cm_err_attr, 1);
#line 1447
  if (ret != 0) {
#line 1448
    printk("\f%s: unable to move qp to error state: %d\n", (char *)(& (priv->dev)->name),
           ret);
  } else {

  }
#line 1449
  spin_lock_irq(& priv->lock);
  ldv_53552: 
#line 1437
  tmp = list_empty((struct list_head  const  *)(& priv->cm.passive_ids));
#line 1437
  if (tmp == 0) {
#line 1439
    goto ldv_53551;
  } else {

  }
  ldv_53550: 
#line 1452
  tmp___0 = list_empty((struct list_head  const  *)(& priv->cm.passive_ids));
#line 1452
  if (tmp___0 == 0) {
#line 1453
    queue_delayed_work___2(priv->wq, & priv->cm.stale_task, 192000UL);
  } else {

  }
#line 1455
  spin_unlock_irq(& priv->lock);
#line 1456
  return;
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static ssize_t show_mode(struct device *d , struct device_attribute *attr , char *buf ) 
{ 
  struct ipoib_dev_priv *priv ;
  struct device  const  *__mptr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1462
  __mptr = (struct device  const  *)d;
#line 1462
  tmp = netdev_priv((struct net_device  const  *)((struct net_device *)__mptr + 0xfffffffffffffaa0UL));
#line 1462
  priv = (struct ipoib_dev_priv *)tmp;
#line 1464
  tmp___2 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->flags));
#line 1464
  if (tmp___2 != 0) {
#line 1465
    tmp___0 = sprintf(buf, "connected\n");
#line 1465
    return ((ssize_t )tmp___0);
  } else {
#line 1467
    tmp___1 = sprintf(buf, "datagram\n");
#line 1467
    return ((ssize_t )tmp___1);
  }
}
}
#line 1470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static ssize_t set_mode(struct device *d , struct device_attribute *attr , char const   *buf ,
                        size_t count ) 
{ 
  struct net_device *dev ;
  struct device  const  *__mptr ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 1473
  __mptr = (struct device  const  *)d;
#line 1473
  dev = (struct net_device *)__mptr + 0xfffffffffffffaa0UL;
#line 1476
  tmp___0 = rtnl_trylock();
#line 1476
  if (tmp___0 == 0) {
#line 1477
    tmp = restart_syscall();
#line 1477
    return ((ssize_t )tmp);
  } else {

  }
#line 1479
  ret = ipoib_set_mode(dev, buf);
#line 1481
  rtnl_unlock();
#line 1483
  if (ret == 0) {
#line 1484
    return ((ssize_t )count);
  } else {

  }
#line 1486
  return ((ssize_t )ret);
}
}
#line 1489 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static struct device_attribute dev_attr_mode  =    {{"mode", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                  {(char)0}, {(char)0}, {(char)0}}}}, & show_mode,
    & set_mode};
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
int ipoib_cm_add_mode_attr(struct net_device *dev ) 
{ 
  int tmp ;

  {
#line 1493
  tmp = device_create_file(& dev->dev, (struct device_attribute  const  *)(& dev_attr_mode));
#line 1493
  return (tmp);
}
}
#line 1496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
static void ipoib_cm_create_srq(struct net_device *dev , int max_sge ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  struct ib_srq_init_attr srq_init_attr ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  void *tmp___3 ;

  {
#line 1498
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1498
  priv = (struct ipoib_dev_priv *)tmp;
#line 1499
  srq_init_attr.event_handler = 0;
#line 1499
  srq_init_attr.srq_context = 0;
#line 1499
  srq_init_attr.attr.max_wr = (unsigned int )ipoib_recvq_size;
#line 1499
  srq_init_attr.attr.max_sge = (unsigned int )max_sge;
#line 1499
  srq_init_attr.attr.srq_limit = 0U;
#line 1499
  srq_init_attr.srq_type = 0;
#line 1499
  srq_init_attr.ext.xrc.xrcd = 0;
#line 1499
  srq_init_attr.ext.xrc.cq = 0;
#line 1507
  priv->cm.srq = ib_create_srq(priv->pd, & srq_init_attr);
#line 1508
  tmp___2 = IS_ERR((void const   *)priv->cm.srq);
#line 1508
  if ((int )tmp___2) {
#line 1509
    tmp___1 = PTR_ERR((void const   *)priv->cm.srq);
#line 1509
    if (tmp___1 != -38L) {
#line 1510
      tmp___0 = PTR_ERR((void const   *)priv->cm.srq);
#line 1510
      printk("\f%s: failed to allocate SRQ, error %ld\n", (char *)(& (priv->ca)->name),
             tmp___0);
    } else {

    }
#line 1512
    priv->cm.srq = (struct ib_srq *)0;
#line 1513
    return;
  } else {

  }
#line 1516
  tmp___3 = vzalloc((unsigned long )ipoib_recvq_size * 136UL);
#line 1516
  priv->cm.srq_ring = (struct ipoib_cm_rx_buf *)tmp___3;
#line 1517
  if ((unsigned long )priv->cm.srq_ring == (unsigned long )((struct ipoib_cm_rx_buf *)0)) {
#line 1518
    printk("\f%s: failed to allocate CM SRQ ring (%d entries)\n", (char *)(& (priv->ca)->name),
           ipoib_recvq_size);
#line 1520
    ib_destroy_srq(priv->cm.srq);
#line 1521
    priv->cm.srq = (struct ib_srq *)0;
#line 1522
    return;
  } else {

  }
#line 1524
  return;
}
}
#line 1527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
int ipoib_cm_dev_init(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int i ;
  int ret ;
  struct ib_device_attr attr ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___2 ;
  atomic_long_t __constr_expr_3 ;
  struct lock_class_key __key___3 ;
  atomic_long_t __constr_expr_4 ;
  struct lock_class_key __key___4 ;
  int __min1 ;
  int __min2 ;
  int tmp___0 ;
  struct sk_buff *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1529
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1529
  priv = (struct ipoib_dev_priv *)tmp;
#line 1533
  INIT_LIST_HEAD(& priv->cm.passive_ids);
#line 1534
  INIT_LIST_HEAD(& priv->cm.reap_list);
#line 1535
  INIT_LIST_HEAD(& priv->cm.start_list);
#line 1536
  INIT_LIST_HEAD(& priv->cm.rx_error_list);
#line 1537
  INIT_LIST_HEAD(& priv->cm.rx_flush_list);
#line 1538
  INIT_LIST_HEAD(& priv->cm.rx_drain_list);
#line 1539
  INIT_LIST_HEAD(& priv->cm.rx_reap_list);
#line 1540
  __init_work(& priv->cm.start_task, 0);
#line 1540
  __constr_expr_0.counter = 137438953408L;
#line 1540
  priv->cm.start_task.data = __constr_expr_0;
#line 1540
  lockdep_init_map(& priv->cm.start_task.lockdep_map, "(&priv->cm.start_task)", & __key,
                   0);
#line 1540
  INIT_LIST_HEAD(& priv->cm.start_task.entry);
#line 1540
  priv->cm.start_task.func = & ipoib_cm_tx_start;
#line 1541
  __init_work(& priv->cm.reap_task, 0);
#line 1541
  __constr_expr_1.counter = 137438953408L;
#line 1541
  priv->cm.reap_task.data = __constr_expr_1;
#line 1541
  lockdep_init_map(& priv->cm.reap_task.lockdep_map, "(&priv->cm.reap_task)", & __key___0,
                   0);
#line 1541
  INIT_LIST_HEAD(& priv->cm.reap_task.entry);
#line 1541
  priv->cm.reap_task.func = & ipoib_cm_tx_reap;
#line 1542
  __init_work(& priv->cm.skb_task, 0);
#line 1542
  __constr_expr_2.counter = 137438953408L;
#line 1542
  priv->cm.skb_task.data = __constr_expr_2;
#line 1542
  lockdep_init_map(& priv->cm.skb_task.lockdep_map, "(&priv->cm.skb_task)", & __key___1,
                   0);
#line 1542
  INIT_LIST_HEAD(& priv->cm.skb_task.entry);
#line 1542
  priv->cm.skb_task.func = & ipoib_cm_skb_reap;
#line 1543
  __init_work(& priv->cm.rx_reap_task, 0);
#line 1543
  __constr_expr_3.counter = 137438953408L;
#line 1543
  priv->cm.rx_reap_task.data = __constr_expr_3;
#line 1543
  lockdep_init_map(& priv->cm.rx_reap_task.lockdep_map, "(&priv->cm.rx_reap_task)",
                   & __key___2, 0);
#line 1543
  INIT_LIST_HEAD(& priv->cm.rx_reap_task.entry);
#line 1543
  priv->cm.rx_reap_task.func = & ipoib_cm_rx_reap;
#line 1544
  __init_work(& priv->cm.stale_task.work, 0);
#line 1544
  __constr_expr_4.counter = 137438953408L;
#line 1544
  priv->cm.stale_task.work.data = __constr_expr_4;
#line 1544
  lockdep_init_map(& priv->cm.stale_task.work.lockdep_map, "(&(&priv->cm.stale_task)->work)",
                   & __key___3, 0);
#line 1544
  INIT_LIST_HEAD(& priv->cm.stale_task.work.entry);
#line 1544
  priv->cm.stale_task.work.func = & ipoib_cm_stale_task;
#line 1544
  init_timer_key(& priv->cm.stale_task.timer, 2097152U, "(&(&priv->cm.stale_task)->timer)",
                 & __key___4);
#line 1544
  priv->cm.stale_task.timer.function = & delayed_work_timer_fn;
#line 1544
  priv->cm.stale_task.timer.data = (unsigned long )(& priv->cm.stale_task);
#line 1546
  skb_queue_head_init(& priv->cm.skb_queue);
#line 1548
  ret = ib_query_device(priv->ca, & attr);
#line 1549
  if (ret != 0) {
#line 1550
    printk("\fib_query_device() failed with %d\n", ret);
#line 1551
    return (ret);
  } else {

  }
#line 1554
  if (ipoib_debug_level > 0) {
#line 1554
    printk("\017%s: max_srq_sge=%d\n", (char *)(& (priv->dev)->name), attr.max_srq_sge);
  } else {

  }
#line 1556
  __min1 = 16;
#line 1556
  __min2 = attr.max_srq_sge;
#line 1556
  attr.max_srq_sge = __min1 < __min2 ? __min1 : __min2;
#line 1557
  ipoib_cm_create_srq(dev, attr.max_srq_sge);
#line 1558
  tmp___0 = ipoib_cm_has_srq(dev);
#line 1558
  if (tmp___0 != 0) {
#line 1559
    priv->cm.max_cm_mtu = (int )((unsigned int )((unsigned long )attr.max_srq_sge) * 4096U - 16U);
#line 1560
    priv->cm.num_frags = attr.max_srq_sge;
#line 1561
    if (ipoib_debug_level > 0) {
#line 1561
      printk("\017%s: max_cm_mtu = 0x%x, num_frags=%d\n", (char *)(& (priv->dev)->name),
             priv->cm.max_cm_mtu, priv->cm.num_frags);
    } else {

    }
  } else {
#line 1564
    priv->cm.max_cm_mtu = 65520;
#line 1565
    priv->cm.num_frags = 16;
  }
#line 1568
  ipoib_cm_init_rx_wr(dev, & priv->cm.rx_wr, (struct ib_sge *)(& priv->cm.rx_sge));
#line 1570
  tmp___3 = ipoib_cm_has_srq(dev);
#line 1570
  if (tmp___3 != 0) {
#line 1571
    i = 0;
#line 1571
    goto ldv_53615;
    ldv_53614: 
#line 1572
    tmp___1 = ipoib_cm_alloc_rx_skb(dev, priv->cm.srq_ring, i, priv->cm.num_frags + -1,
                                    (u64 *)(& (priv->cm.srq_ring + (unsigned long )i)->mapping),
                                    208U);
#line 1572
    if ((unsigned long )tmp___1 == (unsigned long )((struct sk_buff *)0)) {
#line 1576
      printk("\f%s: failed to allocate receive buffer %d\n", (char *)(& (priv->dev)->name),
             i);
#line 1578
      ipoib_cm_dev_cleanup(dev);
#line 1579
      return (-12);
    } else {

    }
#line 1582
    tmp___2 = ipoib_cm_post_receive_srq(dev, i);
#line 1582
    if (tmp___2 != 0) {
#line 1583
      printk("\f%s: ipoib_cm_post_receive_srq failed for buf %d\n", (char *)(& (priv->dev)->name),
             i);
#line 1585
      ipoib_cm_dev_cleanup(dev);
#line 1586
      return (-5);
    } else {

    }
#line 1571
    i = i + 1;
    ldv_53615: ;
#line 1571
    if (i < ipoib_recvq_size) {
#line 1573
      goto ldv_53614;
    } else {

    }

  } else {

  }
#line 1591
  *((priv->dev)->dev_addr) = 128U;
#line 1592
  return (0);
}
}
#line 1595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.c"
void ipoib_cm_dev_cleanup(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  int ret ;

  {
#line 1597
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1597
  priv = (struct ipoib_dev_priv *)tmp;
#line 1600
  if ((unsigned long )priv->cm.srq == (unsigned long )((struct ib_srq *)0)) {
#line 1601
    return;
  } else {

  }
#line 1603
  if (ipoib_debug_level > 0) {
#line 1603
    printk("\017%s: Cleanup ipoib connected mode.\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 1605
  ret = ib_destroy_srq(priv->cm.srq);
#line 1606
  if (ret != 0) {
#line 1607
    printk("\f%s: ib_destroy_srq failed: %d\n", (char *)(& (priv->dev)->name), ret);
  } else {

  }
#line 1609
  priv->cm.srq = (struct ib_srq *)0;
#line 1610
  if ((unsigned long )priv->cm.srq_ring == (unsigned long )((struct ipoib_cm_rx_buf *)0)) {
#line 1611
    return;
  } else {

  }
#line 1613
  ipoib_cm_free_rx_ring(dev, priv->cm.srq_ring);
#line 1614
  priv->cm.srq_ring = (struct ipoib_cm_rx_buf *)0;
#line 1615
  return;
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_work_10(struct work_struct *work ) 
{ 


  {
#line 302
  if ((ldv_work_10_0 == 2 || ldv_work_10_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_0) {
#line 304
    ipoib_cm_tx_start(work);
#line 305
    ldv_work_10_0 = 1;
#line 306
    return;
  } else {

  }
#line 308
  if ((ldv_work_10_1 == 2 || ldv_work_10_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_1) {
#line 310
    ipoib_cm_tx_start(work);
#line 311
    ldv_work_10_1 = 1;
#line 312
    return;
  } else {

  }
#line 314
  if ((ldv_work_10_2 == 2 || ldv_work_10_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_2) {
#line 316
    ipoib_cm_tx_start(work);
#line 317
    ldv_work_10_2 = 1;
#line 318
    return;
  } else {

  }
#line 320
  if ((ldv_work_10_3 == 2 || ldv_work_10_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_3) {
#line 322
    ipoib_cm_tx_start(work);
#line 323
    ldv_work_10_3 = 1;
#line 324
    return;
  } else {

  }
#line 326
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_all_14(int state ) 
{ 


  {
#line 331
  if (ldv_work_14_0 == state) {
#line 332
    call_and_disable_work_14(ldv_work_struct_14_0);
  } else {

  }
#line 333
  if (ldv_work_14_1 == state) {
#line 334
    call_and_disable_work_14(ldv_work_struct_14_1);
  } else {

  }
#line 335
  if (ldv_work_14_2 == state) {
#line 336
    call_and_disable_work_14(ldv_work_struct_14_2);
  } else {

  }
#line 337
  if (ldv_work_14_3 == state) {
#line 338
    call_and_disable_work_14(ldv_work_struct_14_3);
  } else {

  }
#line 339
  return;
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_work_13(struct work_struct *work ) 
{ 


  {
#line 345
  if ((ldv_work_13_0 == 2 || ldv_work_13_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_0) {
#line 347
    ipoib_cm_rx_reap(work);
#line 348
    ldv_work_13_0 = 1;
#line 349
    return;
  } else {

  }
#line 351
  if ((ldv_work_13_1 == 2 || ldv_work_13_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_1) {
#line 353
    ipoib_cm_rx_reap(work);
#line 354
    ldv_work_13_1 = 1;
#line 355
    return;
  } else {

  }
#line 357
  if ((ldv_work_13_2 == 2 || ldv_work_13_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_2) {
#line 359
    ipoib_cm_rx_reap(work);
#line 360
    ldv_work_13_2 = 1;
#line 361
    return;
  } else {

  }
#line 363
  if ((ldv_work_13_3 == 2 || ldv_work_13_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_3) {
#line 365
    ipoib_cm_rx_reap(work);
#line 366
    ldv_work_13_3 = 1;
#line 367
    return;
  } else {

  }
#line 369
  return;
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void activate_work_13(struct work_struct *work , int state ) 
{ 


  {
#line 373
  if (ldv_work_13_0 == 0) {
#line 374
    ldv_work_struct_13_0 = work;
#line 375
    ldv_work_13_0 = state;
#line 376
    return;
  } else {

  }
#line 379
  if (ldv_work_13_1 == 0) {
#line 380
    ldv_work_struct_13_1 = work;
#line 381
    ldv_work_13_1 = state;
#line 382
    return;
  } else {

  }
#line 385
  if (ldv_work_13_2 == 0) {
#line 386
    ldv_work_struct_13_2 = work;
#line 387
    ldv_work_13_2 = state;
#line 388
    return;
  } else {

  }
#line 391
  if (ldv_work_13_3 == 0) {
#line 392
    ldv_work_struct_13_3 = work;
#line 393
    ldv_work_13_3 = state;
#line 394
    return;
  } else {

  }
#line 396
  return;
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void invoke_work_10(void) 
{ 
  int tmp ;

  {
#line 401
  tmp = __VERIFIER_nondet_int();
#line 401
  switch (tmp) {
  case 0: ;
#line 403
  if (ldv_work_10_0 == 2 || ldv_work_10_0 == 3) {
#line 404
    ldv_work_10_0 = 4;
#line 405
    ipoib_cm_tx_start(ldv_work_struct_10_0);
#line 406
    ldv_work_10_0 = 1;
  } else {

  }
#line 409
  goto ldv_53645;
  case 1: ;
#line 411
  if (ldv_work_10_1 == 2 || ldv_work_10_1 == 3) {
#line 412
    ldv_work_10_1 = 4;
#line 413
    ipoib_cm_tx_start(ldv_work_struct_10_0);
#line 414
    ldv_work_10_1 = 1;
  } else {

  }
#line 417
  goto ldv_53645;
  case 2: ;
#line 419
  if (ldv_work_10_2 == 2 || ldv_work_10_2 == 3) {
#line 420
    ldv_work_10_2 = 4;
#line 421
    ipoib_cm_tx_start(ldv_work_struct_10_0);
#line 422
    ldv_work_10_2 = 1;
  } else {

  }
#line 425
  goto ldv_53645;
  case 3: ;
#line 427
  if (ldv_work_10_3 == 2 || ldv_work_10_3 == 3) {
#line 428
    ldv_work_10_3 = 4;
#line 429
    ipoib_cm_tx_start(ldv_work_struct_10_0);
#line 430
    ldv_work_10_3 = 1;
  } else {

  }
#line 433
  goto ldv_53645;
  default: 
#line 434
  ldv_stop();
  }
  ldv_53645: ;
#line 436
  return;
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void disable_work_14(struct work_struct *work ) 
{ 


  {
#line 442
  if ((ldv_work_14_0 == 3 || ldv_work_14_0 == 2) && (unsigned long )ldv_work_struct_14_0 == (unsigned long )work) {
#line 444
    ldv_work_14_0 = 1;
  } else {

  }
#line 446
  if ((ldv_work_14_1 == 3 || ldv_work_14_1 == 2) && (unsigned long )ldv_work_struct_14_1 == (unsigned long )work) {
#line 448
    ldv_work_14_1 = 1;
  } else {

  }
#line 450
  if ((ldv_work_14_2 == 3 || ldv_work_14_2 == 2) && (unsigned long )ldv_work_struct_14_2 == (unsigned long )work) {
#line 452
    ldv_work_14_2 = 1;
  } else {

  }
#line 454
  if ((ldv_work_14_3 == 3 || ldv_work_14_3 == 2) && (unsigned long )ldv_work_struct_14_3 == (unsigned long )work) {
#line 456
    ldv_work_14_3 = 1;
  } else {

  }
#line 457
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_all_11(int state ) 
{ 


  {
#line 463
  if (ldv_work_11_0 == state) {
#line 464
    call_and_disable_work_11(ldv_work_struct_11_0);
  } else {

  }
#line 465
  if (ldv_work_11_1 == state) {
#line 466
    call_and_disable_work_11(ldv_work_struct_11_1);
  } else {

  }
#line 467
  if (ldv_work_11_2 == state) {
#line 468
    call_and_disable_work_11(ldv_work_struct_11_2);
  } else {

  }
#line 469
  if (ldv_work_11_3 == state) {
#line 470
    call_and_disable_work_11(ldv_work_struct_11_3);
  } else {

  }
#line 471
  return;
}
}
#line 474 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void ldv_initialize_device_attribute_20(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 475
  tmp = ldv_init_zalloc(48UL);
#line 475
  dev_attr_mode_group0 = (struct device_attribute *)tmp;
#line 476
  tmp___0 = ldv_init_zalloc(1416UL);
#line 476
  dev_attr_mode_group1 = (struct device *)tmp___0;
#line 477
  return;
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void work_init_14(void) 
{ 


  {
#line 480
  ldv_work_14_0 = 0;
#line 481
  ldv_work_14_1 = 0;
#line 482
  ldv_work_14_2 = 0;
#line 483
  ldv_work_14_3 = 0;
#line 484
  return;
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_all_12(int state ) 
{ 


  {
#line 489
  if (ldv_work_12_0 == state) {
#line 490
    call_and_disable_work_12(ldv_work_struct_12_0);
  } else {

  }
#line 491
  if (ldv_work_12_1 == state) {
#line 492
    call_and_disable_work_12(ldv_work_struct_12_1);
  } else {

  }
#line 493
  if (ldv_work_12_2 == state) {
#line 494
    call_and_disable_work_12(ldv_work_struct_12_2);
  } else {

  }
#line 495
  if (ldv_work_12_3 == state) {
#line 496
    call_and_disable_work_12(ldv_work_struct_12_3);
  } else {

  }
#line 497
  return;
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void invoke_work_14(void) 
{ 
  int tmp ;

  {
#line 502
  tmp = __VERIFIER_nondet_int();
#line 502
  switch (tmp) {
  case 0: ;
#line 504
  if (ldv_work_14_0 == 2 || ldv_work_14_0 == 3) {
#line 505
    ldv_work_14_0 = 4;
#line 506
    ipoib_cm_stale_task(ldv_work_struct_14_0);
#line 507
    ldv_work_14_0 = 1;
  } else {

  }
#line 510
  goto ldv_53671;
  case 1: ;
#line 512
  if (ldv_work_14_1 == 2 || ldv_work_14_1 == 3) {
#line 513
    ldv_work_14_1 = 4;
#line 514
    ipoib_cm_stale_task(ldv_work_struct_14_0);
#line 515
    ldv_work_14_1 = 1;
  } else {

  }
#line 518
  goto ldv_53671;
  case 2: ;
#line 520
  if (ldv_work_14_2 == 2 || ldv_work_14_2 == 3) {
#line 521
    ldv_work_14_2 = 4;
#line 522
    ipoib_cm_stale_task(ldv_work_struct_14_0);
#line 523
    ldv_work_14_2 = 1;
  } else {

  }
#line 526
  goto ldv_53671;
  case 3: ;
#line 528
  if (ldv_work_14_3 == 2 || ldv_work_14_3 == 3) {
#line 529
    ldv_work_14_3 = 4;
#line 530
    ipoib_cm_stale_task(ldv_work_struct_14_0);
#line 531
    ldv_work_14_3 = 1;
  } else {

  }
#line 534
  goto ldv_53671;
  default: 
#line 535
  ldv_stop();
  }
  ldv_53671: ;
#line 537
  return;
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void work_init_10(void) 
{ 


  {
#line 542
  ldv_work_10_0 = 0;
#line 543
  ldv_work_10_1 = 0;
#line 544
  ldv_work_10_2 = 0;
#line 545
  ldv_work_10_3 = 0;
#line 546
  return;
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void invoke_work_11(void) 
{ 
  int tmp ;

  {
#line 551
  tmp = __VERIFIER_nondet_int();
#line 551
  switch (tmp) {
  case 0: ;
#line 553
  if (ldv_work_11_0 == 2 || ldv_work_11_0 == 3) {
#line 554
    ldv_work_11_0 = 4;
#line 555
    ipoib_cm_tx_reap(ldv_work_struct_11_0);
#line 556
    ldv_work_11_0 = 1;
  } else {

  }
#line 559
  goto ldv_53685;
  case 1: ;
#line 561
  if (ldv_work_11_1 == 2 || ldv_work_11_1 == 3) {
#line 562
    ldv_work_11_1 = 4;
#line 563
    ipoib_cm_tx_reap(ldv_work_struct_11_0);
#line 564
    ldv_work_11_1 = 1;
  } else {

  }
#line 567
  goto ldv_53685;
  case 2: ;
#line 569
  if (ldv_work_11_2 == 2 || ldv_work_11_2 == 3) {
#line 570
    ldv_work_11_2 = 4;
#line 571
    ipoib_cm_tx_reap(ldv_work_struct_11_0);
#line 572
    ldv_work_11_2 = 1;
  } else {

  }
#line 575
  goto ldv_53685;
  case 3: ;
#line 577
  if (ldv_work_11_3 == 2 || ldv_work_11_3 == 3) {
#line 578
    ldv_work_11_3 = 4;
#line 579
    ipoib_cm_tx_reap(ldv_work_struct_11_0);
#line 580
    ldv_work_11_3 = 1;
  } else {

  }
#line 583
  goto ldv_53685;
  default: 
#line 584
  ldv_stop();
  }
  ldv_53685: ;
#line 586
  return;
}
}
#line 590 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void work_init_13(void) 
{ 


  {
#line 591
  ldv_work_13_0 = 0;
#line 592
  ldv_work_13_1 = 0;
#line 593
  ldv_work_13_2 = 0;
#line 594
  ldv_work_13_3 = 0;
#line 595
  return;
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_work_14(struct work_struct *work ) 
{ 


  {
#line 601
  if ((ldv_work_14_0 == 2 || ldv_work_14_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_0) {
#line 603
    ipoib_cm_stale_task(work);
#line 604
    ldv_work_14_0 = 1;
#line 605
    return;
  } else {

  }
#line 607
  if ((ldv_work_14_1 == 2 || ldv_work_14_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_1) {
#line 609
    ipoib_cm_stale_task(work);
#line 610
    ldv_work_14_1 = 1;
#line 611
    return;
  } else {

  }
#line 613
  if ((ldv_work_14_2 == 2 || ldv_work_14_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_2) {
#line 615
    ipoib_cm_stale_task(work);
#line 616
    ldv_work_14_2 = 1;
#line 617
    return;
  } else {

  }
#line 619
  if ((ldv_work_14_3 == 2 || ldv_work_14_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_3) {
#line 621
    ipoib_cm_stale_task(work);
#line 622
    ldv_work_14_3 = 1;
#line 623
    return;
  } else {

  }
#line 625
  return;
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void disable_work_13(struct work_struct *work ) 
{ 


  {
#line 630
  if ((ldv_work_13_0 == 3 || ldv_work_13_0 == 2) && (unsigned long )ldv_work_struct_13_0 == (unsigned long )work) {
#line 632
    ldv_work_13_0 = 1;
  } else {

  }
#line 634
  if ((ldv_work_13_1 == 3 || ldv_work_13_1 == 2) && (unsigned long )ldv_work_struct_13_1 == (unsigned long )work) {
#line 636
    ldv_work_13_1 = 1;
  } else {

  }
#line 638
  if ((ldv_work_13_2 == 3 || ldv_work_13_2 == 2) && (unsigned long )ldv_work_struct_13_2 == (unsigned long )work) {
#line 640
    ldv_work_13_2 = 1;
  } else {

  }
#line 642
  if ((ldv_work_13_3 == 3 || ldv_work_13_3 == 2) && (unsigned long )ldv_work_struct_13_3 == (unsigned long )work) {
#line 644
    ldv_work_13_3 = 1;
  } else {

  }
#line 645
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void invoke_work_12(void) 
{ 
  int tmp ;

  {
#line 651
  tmp = __VERIFIER_nondet_int();
#line 651
  switch (tmp) {
  case 0: ;
#line 653
  if (ldv_work_12_0 == 2 || ldv_work_12_0 == 3) {
#line 654
    ldv_work_12_0 = 4;
#line 655
    ipoib_cm_skb_reap(ldv_work_struct_12_0);
#line 656
    ldv_work_12_0 = 1;
  } else {

  }
#line 659
  goto ldv_53707;
  case 1: ;
#line 661
  if (ldv_work_12_1 == 2 || ldv_work_12_1 == 3) {
#line 662
    ldv_work_12_1 = 4;
#line 663
    ipoib_cm_skb_reap(ldv_work_struct_12_0);
#line 664
    ldv_work_12_1 = 1;
  } else {

  }
#line 667
  goto ldv_53707;
  case 2: ;
#line 669
  if (ldv_work_12_2 == 2 || ldv_work_12_2 == 3) {
#line 670
    ldv_work_12_2 = 4;
#line 671
    ipoib_cm_skb_reap(ldv_work_struct_12_0);
#line 672
    ldv_work_12_2 = 1;
  } else {

  }
#line 675
  goto ldv_53707;
  case 3: ;
#line 677
  if (ldv_work_12_3 == 2 || ldv_work_12_3 == 3) {
#line 678
    ldv_work_12_3 = 4;
#line 679
    ipoib_cm_skb_reap(ldv_work_struct_12_0);
#line 680
    ldv_work_12_3 = 1;
  } else {

  }
#line 683
  goto ldv_53707;
  default: 
#line 684
  ldv_stop();
  }
  ldv_53707: ;
#line 686
  return;
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_work_12(struct work_struct *work ) 
{ 


  {
#line 693
  if ((ldv_work_12_0 == 2 || ldv_work_12_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_0) {
#line 695
    ipoib_cm_skb_reap(work);
#line 696
    ldv_work_12_0 = 1;
#line 697
    return;
  } else {

  }
#line 699
  if ((ldv_work_12_1 == 2 || ldv_work_12_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_1) {
#line 701
    ipoib_cm_skb_reap(work);
#line 702
    ldv_work_12_1 = 1;
#line 703
    return;
  } else {

  }
#line 705
  if ((ldv_work_12_2 == 2 || ldv_work_12_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_2) {
#line 707
    ipoib_cm_skb_reap(work);
#line 708
    ldv_work_12_2 = 1;
#line 709
    return;
  } else {

  }
#line 711
  if ((ldv_work_12_3 == 2 || ldv_work_12_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_3) {
#line 713
    ipoib_cm_skb_reap(work);
#line 714
    ldv_work_12_3 = 1;
#line 715
    return;
  } else {

  }
#line 717
  return;
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void work_init_11(void) 
{ 


  {
#line 721
  ldv_work_11_0 = 0;
#line 722
  ldv_work_11_1 = 0;
#line 723
  ldv_work_11_2 = 0;
#line 724
  ldv_work_11_3 = 0;
#line 725
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void activate_work_11(struct work_struct *work , int state ) 
{ 


  {
#line 729
  if (ldv_work_11_0 == 0) {
#line 730
    ldv_work_struct_11_0 = work;
#line 731
    ldv_work_11_0 = state;
#line 732
    return;
  } else {

  }
#line 735
  if (ldv_work_11_1 == 0) {
#line 736
    ldv_work_struct_11_1 = work;
#line 737
    ldv_work_11_1 = state;
#line 738
    return;
  } else {

  }
#line 741
  if (ldv_work_11_2 == 0) {
#line 742
    ldv_work_struct_11_2 = work;
#line 743
    ldv_work_11_2 = state;
#line 744
    return;
  } else {

  }
#line 747
  if (ldv_work_11_3 == 0) {
#line 748
    ldv_work_struct_11_3 = work;
#line 749
    ldv_work_11_3 = state;
#line 750
    return;
  } else {

  }
#line 752
  return;
}
}
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void disable_work_11(struct work_struct *work ) 
{ 


  {
#line 757
  if ((ldv_work_11_0 == 3 || ldv_work_11_0 == 2) && (unsigned long )ldv_work_struct_11_0 == (unsigned long )work) {
#line 759
    ldv_work_11_0 = 1;
  } else {

  }
#line 761
  if ((ldv_work_11_1 == 3 || ldv_work_11_1 == 2) && (unsigned long )ldv_work_struct_11_1 == (unsigned long )work) {
#line 763
    ldv_work_11_1 = 1;
  } else {

  }
#line 765
  if ((ldv_work_11_2 == 3 || ldv_work_11_2 == 2) && (unsigned long )ldv_work_struct_11_2 == (unsigned long )work) {
#line 767
    ldv_work_11_2 = 1;
  } else {

  }
#line 769
  if ((ldv_work_11_3 == 3 || ldv_work_11_3 == 2) && (unsigned long )ldv_work_struct_11_3 == (unsigned long )work) {
#line 771
    ldv_work_11_3 = 1;
  } else {

  }
#line 772
  return;
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void disable_work_12(struct work_struct *work ) 
{ 


  {
#line 778
  if ((ldv_work_12_0 == 3 || ldv_work_12_0 == 2) && (unsigned long )ldv_work_struct_12_0 == (unsigned long )work) {
#line 780
    ldv_work_12_0 = 1;
  } else {

  }
#line 782
  if ((ldv_work_12_1 == 3 || ldv_work_12_1 == 2) && (unsigned long )ldv_work_struct_12_1 == (unsigned long )work) {
#line 784
    ldv_work_12_1 = 1;
  } else {

  }
#line 786
  if ((ldv_work_12_2 == 3 || ldv_work_12_2 == 2) && (unsigned long )ldv_work_struct_12_2 == (unsigned long )work) {
#line 788
    ldv_work_12_2 = 1;
  } else {

  }
#line 790
  if ((ldv_work_12_3 == 3 || ldv_work_12_3 == 2) && (unsigned long )ldv_work_struct_12_3 == (unsigned long )work) {
#line 792
    ldv_work_12_3 = 1;
  } else {

  }
#line 793
  return;
}
}
#line 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void activate_work_12(struct work_struct *work , int state ) 
{ 


  {
#line 798
  if (ldv_work_12_0 == 0) {
#line 799
    ldv_work_struct_12_0 = work;
#line 800
    ldv_work_12_0 = state;
#line 801
    return;
  } else {

  }
#line 804
  if (ldv_work_12_1 == 0) {
#line 805
    ldv_work_struct_12_1 = work;
#line 806
    ldv_work_12_1 = state;
#line 807
    return;
  } else {

  }
#line 810
  if (ldv_work_12_2 == 0) {
#line 811
    ldv_work_struct_12_2 = work;
#line 812
    ldv_work_12_2 = state;
#line 813
    return;
  } else {

  }
#line 816
  if (ldv_work_12_3 == 0) {
#line 817
    ldv_work_struct_12_3 = work;
#line 818
    ldv_work_12_3 = state;
#line 819
    return;
  } else {

  }
#line 821
  return;
}
}
#line 824 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void invoke_work_13(void) 
{ 
  int tmp ;

  {
#line 826
  tmp = __VERIFIER_nondet_int();
#line 826
  switch (tmp) {
  case 0: ;
#line 828
  if (ldv_work_13_0 == 2 || ldv_work_13_0 == 3) {
#line 829
    ldv_work_13_0 = 4;
#line 830
    ipoib_cm_rx_reap(ldv_work_struct_13_0);
#line 831
    ldv_work_13_0 = 1;
  } else {

  }
#line 834
  goto ldv_53740;
  case 1: ;
#line 836
  if (ldv_work_13_1 == 2 || ldv_work_13_1 == 3) {
#line 837
    ldv_work_13_1 = 4;
#line 838
    ipoib_cm_rx_reap(ldv_work_struct_13_0);
#line 839
    ldv_work_13_1 = 1;
  } else {

  }
#line 842
  goto ldv_53740;
  case 2: ;
#line 844
  if (ldv_work_13_2 == 2 || ldv_work_13_2 == 3) {
#line 845
    ldv_work_13_2 = 4;
#line 846
    ipoib_cm_rx_reap(ldv_work_struct_13_0);
#line 847
    ldv_work_13_2 = 1;
  } else {

  }
#line 850
  goto ldv_53740;
  case 3: ;
#line 852
  if (ldv_work_13_3 == 2 || ldv_work_13_3 == 3) {
#line 853
    ldv_work_13_3 = 4;
#line 854
    ipoib_cm_rx_reap(ldv_work_struct_13_0);
#line 855
    ldv_work_13_3 = 1;
  } else {

  }
#line 858
  goto ldv_53740;
  default: 
#line 859
  ldv_stop();
  }
  ldv_53740: ;
#line 861
  return;
}
}
#line 865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void disable_work_10(struct work_struct *work ) 
{ 


  {
#line 867
  if ((ldv_work_10_0 == 3 || ldv_work_10_0 == 2) && (unsigned long )ldv_work_struct_10_0 == (unsigned long )work) {
#line 869
    ldv_work_10_0 = 1;
  } else {

  }
#line 871
  if ((ldv_work_10_1 == 3 || ldv_work_10_1 == 2) && (unsigned long )ldv_work_struct_10_1 == (unsigned long )work) {
#line 873
    ldv_work_10_1 = 1;
  } else {

  }
#line 875
  if ((ldv_work_10_2 == 3 || ldv_work_10_2 == 2) && (unsigned long )ldv_work_struct_10_2 == (unsigned long )work) {
#line 877
    ldv_work_10_2 = 1;
  } else {

  }
#line 879
  if ((ldv_work_10_3 == 3 || ldv_work_10_3 == 2) && (unsigned long )ldv_work_struct_10_3 == (unsigned long )work) {
#line 881
    ldv_work_10_3 = 1;
  } else {

  }
#line 882
  return;
}
}
#line 886 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void work_init_12(void) 
{ 


  {
#line 887
  ldv_work_12_0 = 0;
#line 888
  ldv_work_12_1 = 0;
#line 889
  ldv_work_12_2 = 0;
#line 890
  ldv_work_12_3 = 0;
#line 891
  return;
}
}
#line 894 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void activate_work_10(struct work_struct *work , int state ) 
{ 


  {
#line 895
  if (ldv_work_10_0 == 0) {
#line 896
    ldv_work_struct_10_0 = work;
#line 897
    ldv_work_10_0 = state;
#line 898
    return;
  } else {

  }
#line 901
  if (ldv_work_10_1 == 0) {
#line 902
    ldv_work_struct_10_1 = work;
#line 903
    ldv_work_10_1 = state;
#line 904
    return;
  } else {

  }
#line 907
  if (ldv_work_10_2 == 0) {
#line 908
    ldv_work_struct_10_2 = work;
#line 909
    ldv_work_10_2 = state;
#line 910
    return;
  } else {

  }
#line 913
  if (ldv_work_10_3 == 0) {
#line 914
    ldv_work_struct_10_3 = work;
#line 915
    ldv_work_10_3 = state;
#line 916
    return;
  } else {

  }
#line 918
  return;
}
}
#line 921 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_work_11(struct work_struct *work ) 
{ 


  {
#line 924
  if ((ldv_work_11_0 == 2 || ldv_work_11_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_0) {
#line 926
    ipoib_cm_tx_reap(work);
#line 927
    ldv_work_11_0 = 1;
#line 928
    return;
  } else {

  }
#line 930
  if ((ldv_work_11_1 == 2 || ldv_work_11_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_1) {
#line 932
    ipoib_cm_tx_reap(work);
#line 933
    ldv_work_11_1 = 1;
#line 934
    return;
  } else {

  }
#line 936
  if ((ldv_work_11_2 == 2 || ldv_work_11_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_2) {
#line 938
    ipoib_cm_tx_reap(work);
#line 939
    ldv_work_11_2 = 1;
#line 940
    return;
  } else {

  }
#line 942
  if ((ldv_work_11_3 == 2 || ldv_work_11_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_3) {
#line 944
    ipoib_cm_tx_reap(work);
#line 945
    ldv_work_11_3 = 1;
#line 946
    return;
  } else {

  }
#line 948
  return;
}
}
#line 951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void activate_work_14(struct work_struct *work , int state ) 
{ 


  {
#line 952
  if (ldv_work_14_0 == 0) {
#line 953
    ldv_work_struct_14_0 = work;
#line 954
    ldv_work_14_0 = state;
#line 955
    return;
  } else {

  }
#line 958
  if (ldv_work_14_1 == 0) {
#line 959
    ldv_work_struct_14_1 = work;
#line 960
    ldv_work_14_1 = state;
#line 961
    return;
  } else {

  }
#line 964
  if (ldv_work_14_2 == 0) {
#line 965
    ldv_work_struct_14_2 = work;
#line 966
    ldv_work_14_2 = state;
#line 967
    return;
  } else {

  }
#line 970
  if (ldv_work_14_3 == 0) {
#line 971
    ldv_work_struct_14_3 = work;
#line 972
    ldv_work_14_3 = state;
#line 973
    return;
  } else {

  }
#line 975
  return;
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_all_10(int state ) 
{ 


  {
#line 980
  if (ldv_work_10_0 == state) {
#line 981
    call_and_disable_work_10(ldv_work_struct_10_0);
  } else {

  }
#line 982
  if (ldv_work_10_1 == state) {
#line 983
    call_and_disable_work_10(ldv_work_struct_10_1);
  } else {

  }
#line 984
  if (ldv_work_10_2 == state) {
#line 985
    call_and_disable_work_10(ldv_work_struct_10_2);
  } else {

  }
#line 986
  if (ldv_work_10_3 == state) {
#line 987
    call_and_disable_work_10(ldv_work_struct_10_3);
  } else {

  }
#line 988
  return;
}
}
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void call_and_disable_all_13(int state ) 
{ 


  {
#line 993
  if (ldv_work_13_0 == state) {
#line 994
    call_and_disable_work_13(ldv_work_struct_13_0);
  } else {

  }
#line 995
  if (ldv_work_13_1 == state) {
#line 996
    call_and_disable_work_13(ldv_work_struct_13_1);
  } else {

  }
#line 997
  if (ldv_work_13_2 == state) {
#line 998
    call_and_disable_work_13(ldv_work_struct_13_2);
  } else {

  }
#line 999
  if (ldv_work_13_3 == state) {
#line 1000
    call_and_disable_work_13(ldv_work_struct_13_3);
  } else {

  }
#line 1001
  return;
}
}
#line 1009 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void ldv_main_exported_20(void) 
{ 
  size_t ldvarg38 ;
  char *ldvarg37 ;
  void *tmp ;
  char *ldvarg39 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1011
  tmp = ldv_init_zalloc(1UL);
#line 1011
  ldvarg37 = (char *)tmp;
#line 1012
  tmp___0 = ldv_init_zalloc(1UL);
#line 1012
  ldvarg39 = (char *)tmp___0;
#line 1010
  ldv_memset((void *)(& ldvarg38), 0, 8UL);
#line 1014
  tmp___1 = __VERIFIER_nondet_int();
#line 1014
  switch (tmp___1) {
  case 0: ;
#line 1017
  if (ldv_state_variable_20 == 1) {
#line 1019
    set_mode(dev_attr_mode_group1, dev_attr_mode_group0, (char const   *)ldvarg39,
             ldvarg38);
#line 1021
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1024
  goto ldv_53777;
  case 1: ;
#line 1027
  if (ldv_state_variable_20 == 1) {
#line 1029
    show_mode(dev_attr_mode_group1, dev_attr_mode_group0, ldvarg37);
#line 1031
    ldv_state_variable_20 = 1;
  } else {

  }
#line 1034
  goto ldv_53777;
  default: 
#line 1035
  ldv_stop();
  }
  ldv_53777: ;
#line 1039
  return;
}
}
#line 1064 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
bool ldv_queue_work_on_161(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1068
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1068
  ldv_func_res = tmp;
#line 1070
  activate_work_11(ldv_func_arg3, 2);
#line 1072
  return (ldv_func_res);
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
bool ldv_queue_delayed_work_on_162(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1079
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1079
  ldv_func_res = tmp;
#line 1081
  activate_work_11(& ldv_func_arg3->work, 2);
#line 1083
  return (ldv_func_res);
}
}
#line 1086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
bool ldv_queue_work_on_163(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1090
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1090
  ldv_func_res = tmp;
#line 1092
  activate_work_11(ldv_func_arg3, 2);
#line 1094
  return (ldv_func_res);
}
}
#line 1097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
void ldv_flush_workqueue_164(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1100
  flush_workqueue(ldv_func_arg1);
#line 1102
  call_and_disable_all_11(2);
#line 1103
  return;
}
}
#line 1105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
bool ldv_queue_delayed_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1109
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1109
  ldv_func_res = tmp;
#line 1111
  activate_work_11(& ldv_func_arg3->work, 2);
#line 1113
  return (ldv_func_res);
}
}
#line 1116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_cm.o.c.prepared"
bool ldv_cancel_delayed_work_166(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  bool tmp ;

  {
#line 1120
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 1120
  ldv_func_res = tmp;
#line 1122
  disable_work_11(& ldv_func_arg1->work);
#line 1124
  return (ldv_func_res);
}
}
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_177(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_179(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_178(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_181(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_180(struct workqueue_struct *ldv_func_arg1 ) ;
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_seq_operations_19(void) ;
#line 282
void ldv_seq_operations_17(void) ;
#line 113 "include/linux/seq_file.h"
extern int seq_open(struct file * , struct seq_operations  const  * ) ;
#line 116
int ldv_seq_open_182(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) ;
#line 120
int ldv_seq_open_183(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) ;
#line 122
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 123
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 124
extern int seq_release(struct inode * , struct file * ) ;
#line 127
int ldv_seq_release_184(struct inode *ldv_func_arg1 , struct file *ldv_func_arg2 ) ;
#line 131
int ldv_seq_release_185(struct inode *ldv_func_arg1 , struct file *ldv_func_arg2 ) ;
#line 134
extern int seq_putc(struct seq_file * , char  ) ;
#line 138
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 49 "include/linux/debugfs.h"
extern struct dentry *debugfs_create_file(char const   * , umode_t  , struct dentry * ,
                                          void * , struct file_operations  const  * ) ;
#line 58
extern struct dentry *debugfs_create_dir(char const   * , struct dentry * ) ;
#line 68
extern void debugfs_remove(struct dentry * ) ;
#line 557 "include/rdma/ib_verbs.h"
extern int ib_rate_to_mbps(enum ib_rate  ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static struct dentry *ipoib_root  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static void format_gid(union ib_gid *gid , char *buf ) 
{ 
  int i ;
  int n ;
  __u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 50
  n = 0;
#line 50
  i = 0;
#line 50
  goto ldv_49847;
  ldv_49846: 
#line 51
  tmp = __fswab16((int )*((__be16 *)(& gid->raw) + (unsigned long )i));
#line 51
  tmp___0 = sprintf(buf + (unsigned long )n, "%x", (int )tmp);
#line 51
  n = tmp___0 + n;
#line 53
  if (i <= 6) {
#line 54
    tmp___1 = n;
#line 54
    n = n + 1;
#line 54
    *(buf + (unsigned long )tmp___1) = 58;
  } else {

  }
#line 50
  i = i + 1;
  ldv_49847: ;
#line 50
  if (i <= 7) {
#line 52
    goto ldv_49846;
  } else {

  }

#line 57
  return;
}
}
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static void *ipoib_mcg_seq_start(struct seq_file *file , loff_t *pos ) 
{ 
  struct ipoib_mcast_iter *iter ;
  loff_t n ;
  int tmp ;
  loff_t tmp___0 ;

  {
#line 61
  n = *pos;
#line 63
  iter = ipoib_mcast_iter_init((struct net_device *)file->private);
#line 64
  if ((unsigned long )iter == (unsigned long )((struct ipoib_mcast_iter *)0)) {
#line 65
    return ((void *)0);
  } else {

  }
#line 67
  goto ldv_49856;
  ldv_49855: 
#line 68
  tmp = ipoib_mcast_iter_next(iter);
#line 68
  if (tmp != 0) {
#line 69
    kfree((void const   *)iter);
#line 70
    return ((void *)0);
  } else {

  }
  ldv_49856: 
#line 67
  tmp___0 = n;
#line 67
  n = n - 1LL;
#line 67
  if (tmp___0 != 0LL) {
#line 69
    goto ldv_49855;
  } else {

  }

#line 74
  return ((void *)iter);
}
}
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static void *ipoib_mcg_seq_next(struct seq_file *file , void *iter_ptr , loff_t *pos ) 
{ 
  struct ipoib_mcast_iter *iter ;
  int tmp ;

  {
#line 80
  iter = (struct ipoib_mcast_iter *)iter_ptr;
#line 82
  *pos = *pos + 1LL;
#line 84
  tmp = ipoib_mcast_iter_next(iter);
#line 84
  if (tmp != 0) {
#line 85
    kfree((void const   *)iter);
#line 86
    return ((void *)0);
  } else {

  }
#line 89
  return ((void *)iter);
}
}
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static void ipoib_mcg_seq_stop(struct seq_file *file , void *iter_ptr ) 
{ 


  {
#line 94
  return;
}
}
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static int ipoib_mcg_seq_show(struct seq_file *file , void *iter_ptr ) 
{ 
  struct ipoib_mcast_iter *iter ;
  char gid_buf[40U] ;
  union ib_gid mgid ;
  unsigned long created ;
  unsigned int queuelen ;
  unsigned int complete___0 ;
  unsigned int send_only ;

  {
#line 99
  iter = (struct ipoib_mcast_iter *)iter_ptr;
#line 105
  if ((unsigned long )iter == (unsigned long )((struct ipoib_mcast_iter *)0)) {
#line 106
    return (0);
  } else {

  }
#line 108
  ipoib_mcast_iter_read(iter, & mgid, & created, & queuelen, & complete___0, & send_only);
#line 111
  format_gid(& mgid, (char *)(& gid_buf));
#line 113
  seq_printf(file, "GID: %s\n  created: %10ld\n  queuelen: %9d\n  complete: %9s\n  send_only: %8s\n\n",
             (char *)(& gid_buf), created, queuelen, complete___0 != 0U ? (char *)"yes" : (char *)"no",
             send_only != 0U ? (char *)"yes" : (char *)"no");
#line 124
  return (0);
}
}
#line 127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static struct seq_operations  const  ipoib_mcg_seq_ops  =    {& ipoib_mcg_seq_start, & ipoib_mcg_seq_stop, & ipoib_mcg_seq_next, & ipoib_mcg_seq_show};
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static int ipoib_mcg_open(struct inode *inode , struct file *file ) 
{ 
  struct seq_file *seq ;
  int ret ;

  {
#line 139
  ret = ldv_seq_open_182(file, & ipoib_mcg_seq_ops);
#line 140
  if (ret != 0) {
#line 141
    return (ret);
  } else {

  }
#line 143
  seq = (struct seq_file *)file->private_data;
#line 144
  seq->private = inode->i_private;
#line 146
  return (0);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static struct file_operations  const  ipoib_mcg_fops  = 
#line 149
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ipoib_mcg_open,
    0, & seq_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 157 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static void *ipoib_path_seq_start(struct seq_file *file , loff_t *pos ) 
{ 
  struct ipoib_path_iter *iter ;
  loff_t n ;
  int tmp ;
  loff_t tmp___0 ;

  {
#line 160
  n = *pos;
#line 162
  iter = ipoib_path_iter_init((struct net_device *)file->private);
#line 163
  if ((unsigned long )iter == (unsigned long )((struct ipoib_path_iter *)0)) {
#line 164
    return ((void *)0);
  } else {

  }
#line 166
  goto ldv_49894;
  ldv_49893: 
#line 167
  tmp = ipoib_path_iter_next(iter);
#line 167
  if (tmp != 0) {
#line 168
    kfree((void const   *)iter);
#line 169
    return ((void *)0);
  } else {

  }
  ldv_49894: 
#line 166
  tmp___0 = n;
#line 166
  n = n - 1LL;
#line 166
  if (tmp___0 != 0LL) {
#line 168
    goto ldv_49893;
  } else {

  }

#line 173
  return ((void *)iter);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static void *ipoib_path_seq_next(struct seq_file *file , void *iter_ptr , loff_t *pos ) 
{ 
  struct ipoib_path_iter *iter ;
  int tmp ;

  {
#line 179
  iter = (struct ipoib_path_iter *)iter_ptr;
#line 181
  *pos = *pos + 1LL;
#line 183
  tmp = ipoib_path_iter_next(iter);
#line 183
  if (tmp != 0) {
#line 184
    kfree((void const   *)iter);
#line 185
    return ((void *)0);
  } else {

  }
#line 188
  return ((void *)iter);
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static void ipoib_path_seq_stop(struct seq_file *file , void *iter_ptr ) 
{ 


  {
#line 193
  return;
}
}
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static int ipoib_path_seq_show(struct seq_file *file , void *iter_ptr ) 
{ 
  struct ipoib_path_iter *iter ;
  char gid_buf[40U] ;
  struct ipoib_path path ;
  int rate ;
  __u16 tmp ;

  {
#line 198
  iter = (struct ipoib_path_iter *)iter_ptr;
#line 203
  if ((unsigned long )iter == (unsigned long )((struct ipoib_path_iter *)0)) {
#line 204
    return (0);
  } else {

  }
#line 206
  ipoib_path_iter_read(iter, & path);
#line 208
  format_gid(& path.pathrec.dgid, (char *)(& gid_buf));
#line 210
  seq_printf(file, "GID: %s\n  complete: %6s\n", (char *)(& gid_buf), (unsigned int )path.pathrec.dlid != 0U ? (char *)"yes" : (char *)"no");
#line 215
  if ((unsigned int )path.pathrec.dlid != 0U) {
#line 216
    rate = ib_rate_to_mbps((enum ib_rate )path.pathrec.rate);
#line 218
    tmp = __fswab16((int )path.pathrec.dlid);
#line 218
    seq_printf(file, "  DLID:     0x%04x\n  SL: %12d\n  rate: %8d.%d Gb/sec\n", (int )tmp,
               (int )path.pathrec.sl, rate / 1000, rate % 1000);
  } else {

  }
#line 227
  seq_putc(file, 10);
#line 229
  return (0);
}
}
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static struct seq_operations  const  ipoib_path_seq_ops  =    {& ipoib_path_seq_start, & ipoib_path_seq_stop, & ipoib_path_seq_next, & ipoib_path_seq_show};
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static int ipoib_path_open(struct inode *inode , struct file *file ) 
{ 
  struct seq_file *seq ;
  int ret ;

  {
#line 244
  ret = ldv_seq_open_183(file, & ipoib_path_seq_ops);
#line 245
  if (ret != 0) {
#line 246
    return (ret);
  } else {

  }
#line 248
  seq = (struct seq_file *)file->private_data;
#line 249
  seq->private = inode->i_private;
#line 251
  return (0);
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
static struct file_operations  const  ipoib_path_fops  = 
#line 254
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ipoib_path_open,
    0, & seq_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
void ipoib_create_debug_files(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;
  char name[22U] ;

  {
#line 264
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 264
  priv = (struct ipoib_dev_priv *)tmp;
#line 267
  snprintf((char *)(& name), 22UL, "%s_mcg", (char *)(& dev->name));
#line 268
  priv->mcg_dentry = debugfs_create_file((char const   *)(& name), 33060, ipoib_root,
                                         (void *)dev, & ipoib_mcg_fops);
#line 270
  if ((unsigned long )priv->mcg_dentry == (unsigned long )((struct dentry *)0)) {
#line 271
    printk("\f%s: failed to create mcg debug file\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 273
  snprintf((char *)(& name), 22UL, "%s_path", (char *)(& dev->name));
#line 274
  priv->path_dentry = debugfs_create_file((char const   *)(& name), 33060, ipoib_root,
                                          (void *)dev, & ipoib_path_fops);
#line 276
  if ((unsigned long )priv->path_dentry == (unsigned long )((struct dentry *)0)) {
#line 277
    printk("\f%s: failed to create path debug file\n", (char *)(& (priv->dev)->name));
  } else {

  }
#line 278
  return;
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
void ipoib_delete_debug_files(struct net_device *dev ) 
{ 
  struct ipoib_dev_priv *priv ;
  void *tmp ;

  {
#line 282
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 282
  priv = (struct ipoib_dev_priv *)tmp;
#line 284
  debugfs_remove(priv->mcg_dentry);
#line 285
  debugfs_remove(priv->path_dentry);
#line 286
  return;
}
}
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
int ipoib_register_debugfs(void) 
{ 


  {
#line 290
  ipoib_root = debugfs_create_dir("ipoib", (struct dentry *)0);
#line 291
  return ((unsigned long )ipoib_root != (unsigned long )((struct dentry *)0) ? 0 : -12);
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
void ipoib_unregister_debugfs(void) 
{ 


  {
#line 296
  debugfs_remove(ipoib_root);
#line 297
  return;
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
void *ldv_retval_0  ;
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
int ldv_retval_4  ;
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
void *ldv_retval_1  ;
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
void *ldv_retval_8  ;
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
int ldv_retval_2  ;
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.c"
void *ldv_retval_7  ;
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_file_operations_16(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 307
  tmp = ldv_init_zalloc(1000UL);
#line 307
  ipoib_path_fops_group1 = (struct inode *)tmp;
#line 308
  tmp___0 = ldv_init_zalloc(504UL);
#line 308
  ipoib_path_fops_group2 = (struct file *)tmp___0;
#line 309
  return;
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_seq_operations_19(void) 
{ 
  void *tmp ;

  {
#line 313
  tmp = ldv_init_zalloc(256UL);
#line 313
  ipoib_mcg_seq_ops_group1 = (struct seq_file *)tmp;
#line 314
  return;
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_seq_operations_17(void) 
{ 
  void *tmp ;

  {
#line 318
  tmp = ldv_init_zalloc(256UL);
#line 318
  ipoib_path_seq_ops_group1 = (struct seq_file *)tmp;
#line 319
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_file_operations_18(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 323
  tmp = ldv_init_zalloc(1000UL);
#line 323
  ipoib_mcg_fops_group1 = (struct inode *)tmp;
#line 324
  tmp___0 = ldv_init_zalloc(504UL);
#line 324
  ipoib_mcg_fops_group2 = (struct file *)tmp___0;
#line 325
  return;
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_main_exported_18(void) 
{ 
  loff_t *ldvarg9 ;
  void *tmp ;
  size_t ldvarg10 ;
  int ldvarg7 ;
  char *ldvarg11 ;
  void *tmp___0 ;
  loff_t ldvarg8 ;
  int tmp___1 ;

  {
#line 329
  tmp = ldv_init_zalloc(8UL);
#line 329
  ldvarg9 = (loff_t *)tmp;
#line 332
  tmp___0 = ldv_init_zalloc(1UL);
#line 332
  ldvarg11 = (char *)tmp___0;
#line 330
  ldv_memset((void *)(& ldvarg10), 0, 8UL);
#line 331
  ldv_memset((void *)(& ldvarg7), 0, 4UL);
#line 333
  ldv_memset((void *)(& ldvarg8), 0, 8UL);
#line 335
  tmp___1 = __VERIFIER_nondet_int();
#line 335
  switch (tmp___1) {
  case 0: ;
#line 338
  if (ldv_state_variable_18 == 2) {
#line 340
    seq_read(ipoib_mcg_fops_group2, ldvarg11, ldvarg10, ldvarg9);
#line 342
    ldv_state_variable_18 = 2;
  } else {

  }
#line 345
  goto ldv_49964;
  case 1: ;
#line 348
  if (ldv_state_variable_18 == 1) {
#line 350
    ldv_retval_2 = ipoib_mcg_open(ipoib_mcg_fops_group1, ipoib_mcg_fops_group2);
#line 351
    if (ldv_retval_2 == 0) {
#line 352
      ldv_state_variable_18 = 2;
#line 353
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 357
  goto ldv_49964;
  case 2: ;
#line 360
  if (ldv_state_variable_18 == 2) {
#line 362
    ldv_seq_release_184(ipoib_mcg_fops_group1, ipoib_mcg_fops_group2);
#line 363
    ldv_state_variable_18 = 1;
#line 364
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 367
  goto ldv_49964;
  case 3: ;
#line 370
  if (ldv_state_variable_18 == 2) {
#line 372
    seq_lseek(ipoib_mcg_fops_group2, ldvarg8, ldvarg7);
#line 374
    ldv_state_variable_18 = 2;
  } else {

  }
#line 377
  goto ldv_49964;
  default: 
#line 378
  ldv_stop();
  }
  ldv_49964: ;
#line 382
  return;
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_main_exported_19(void) 
{ 
  int tmp ;

  {
#line 386
  tmp = __VERIFIER_nondet_int();
#line 386
  switch (tmp) {
  case 0: ;
#line 389
  if (ldv_state_variable_19 == 1) {
#line 391
    ldv_retval_8 = ipoib_mcg_seq_start(ipoib_mcg_seq_ops_group1, ipoib_mcg_seq_ops_group3);
#line 392
    if ((unsigned long )ldv_retval_8 != (unsigned long )((void *)0)) {
#line 393
      ldv_state_variable_19 = 3;
#line 394
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 396
    if ((unsigned long )ldv_retval_8 == (unsigned long )((void *)0)) {
#line 397
      ldv_state_variable_19 = 2;
#line 398
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 402
  goto ldv_49973;
  case 1: ;
#line 405
  if (ldv_state_variable_19 == 3) {
#line 407
    ipoib_mcg_seq_stop(ipoib_mcg_seq_ops_group1, ipoib_mcg_seq_ops_group2);
#line 408
    ldv_state_variable_19 = 1;
#line 409
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 412
  if (ldv_state_variable_19 == 2) {
#line 414
    ipoib_mcg_seq_stop(ipoib_mcg_seq_ops_group1, ipoib_mcg_seq_ops_group2);
#line 415
    ldv_state_variable_19 = 1;
#line 416
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 419
  goto ldv_49973;
  case 2: ;
#line 422
  if (ldv_state_variable_19 == 2) {
#line 424
    ipoib_mcg_seq_show(ipoib_mcg_seq_ops_group1, (void *)ipoib_mcg_seq_ops_group3);
#line 426
    ldv_state_variable_19 = 2;
  } else {

  }
#line 429
  goto ldv_49973;
  case 3: ;
#line 432
  if (ldv_state_variable_19 == 2) {
#line 434
    ldv_retval_7 = ipoib_mcg_seq_next(ipoib_mcg_seq_ops_group1, ipoib_mcg_seq_ops_group2,
                                      ipoib_mcg_seq_ops_group3);
#line 435
    if ((unsigned long )ldv_retval_7 != (unsigned long )((void *)0)) {
#line 436
      ldv_state_variable_19 = 3;
#line 437
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 439
    if ((unsigned long )ldv_retval_7 == (unsigned long )((void *)0)) {
#line 440
      ldv_state_variable_19 = 2;
#line 441
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 445
  goto ldv_49973;
  default: 
#line 446
  ldv_stop();
  }
  ldv_49973: ;
#line 450
  return;
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_main_exported_16(void) 
{ 
  int ldvarg15 ;
  loff_t ldvarg16 ;
  char *ldvarg19 ;
  void *tmp ;
  loff_t *ldvarg17 ;
  void *tmp___0 ;
  size_t ldvarg18 ;
  int tmp___1 ;

  {
#line 455
  tmp = ldv_init_zalloc(1UL);
#line 455
  ldvarg19 = (char *)tmp;
#line 456
  tmp___0 = ldv_init_zalloc(8UL);
#line 456
  ldvarg17 = (loff_t *)tmp___0;
#line 453
  ldv_memset((void *)(& ldvarg15), 0, 4UL);
#line 454
  ldv_memset((void *)(& ldvarg16), 0, 8UL);
#line 457
  ldv_memset((void *)(& ldvarg18), 0, 8UL);
#line 459
  tmp___1 = __VERIFIER_nondet_int();
#line 459
  switch (tmp___1) {
  case 0: ;
#line 462
  if (ldv_state_variable_16 == 2) {
#line 464
    seq_read(ipoib_path_fops_group2, ldvarg19, ldvarg18, ldvarg17);
#line 466
    ldv_state_variable_16 = 2;
  } else {

  }
#line 469
  goto ldv_49987;
  case 1: ;
#line 472
  if (ldv_state_variable_16 == 1) {
#line 474
    ldv_retval_4 = ipoib_path_open(ipoib_path_fops_group1, ipoib_path_fops_group2);
#line 475
    if (ldv_retval_4 == 0) {
#line 476
      ldv_state_variable_16 = 2;
#line 477
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 481
  goto ldv_49987;
  case 2: ;
#line 484
  if (ldv_state_variable_16 == 2) {
#line 486
    ldv_seq_release_185(ipoib_path_fops_group1, ipoib_path_fops_group2);
#line 487
    ldv_state_variable_16 = 1;
#line 488
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 491
  goto ldv_49987;
  case 3: ;
#line 494
  if (ldv_state_variable_16 == 2) {
#line 496
    seq_lseek(ipoib_path_fops_group2, ldvarg16, ldvarg15);
#line 498
    ldv_state_variable_16 = 2;
  } else {

  }
#line 501
  goto ldv_49987;
  default: 
#line 502
  ldv_stop();
  }
  ldv_49987: ;
#line 506
  return;
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_main_exported_17(void) 
{ 
  int tmp ;

  {
#line 510
  tmp = __VERIFIER_nondet_int();
#line 510
  switch (tmp) {
  case 0: ;
#line 513
  if (ldv_state_variable_17 == 1) {
#line 515
    ldv_retval_1 = ipoib_path_seq_start(ipoib_path_seq_ops_group1, ipoib_path_seq_ops_group3);
#line 516
    if ((unsigned long )ldv_retval_1 == (unsigned long )((void *)0)) {
#line 517
      ldv_state_variable_17 = 3;
#line 518
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 520
    if ((unsigned long )ldv_retval_1 != (unsigned long )((void *)0)) {
#line 521
      ldv_state_variable_17 = 2;
#line 522
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 526
  goto ldv_49996;
  case 1: ;
#line 529
  if (ldv_state_variable_17 == 3) {
#line 531
    ipoib_path_seq_stop(ipoib_path_seq_ops_group1, ipoib_path_seq_ops_group2);
#line 532
    ldv_state_variable_17 = 1;
#line 533
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 536
  if (ldv_state_variable_17 == 2) {
#line 538
    ipoib_path_seq_stop(ipoib_path_seq_ops_group1, ipoib_path_seq_ops_group2);
#line 539
    ldv_state_variable_17 = 1;
#line 540
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 543
  goto ldv_49996;
  case 2: ;
#line 546
  if (ldv_state_variable_17 == 3) {
#line 548
    ipoib_path_seq_show(ipoib_path_seq_ops_group1, (void *)ipoib_path_seq_ops_group3);
#line 550
    ldv_state_variable_17 = 3;
  } else {

  }
#line 553
  goto ldv_49996;
  case 3: ;
#line 556
  if (ldv_state_variable_17 == 3) {
#line 558
    ldv_retval_0 = ipoib_path_seq_next(ipoib_path_seq_ops_group1, ipoib_path_seq_ops_group2,
                                       ipoib_path_seq_ops_group3);
#line 559
    if ((unsigned long )ldv_retval_0 == (unsigned long )((void *)0)) {
#line 560
      ldv_state_variable_17 = 3;
#line 561
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 563
    if ((unsigned long )ldv_retval_0 != (unsigned long )((void *)0)) {
#line 564
      ldv_state_variable_17 = 2;
#line 565
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 569
  goto ldv_49996;
  default: 
#line 570
  ldv_stop();
  }
  ldv_49996: ;
#line 574
  return;
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
bool ldv_queue_work_on_177(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 603
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 603
  ldv_func_res = tmp;
#line 605
  activate_work_11(ldv_func_arg3, 2);
#line 607
  return (ldv_func_res);
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
bool ldv_queue_delayed_work_on_178(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 614
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 614
  ldv_func_res = tmp;
#line 616
  activate_work_11(& ldv_func_arg3->work, 2);
#line 618
  return (ldv_func_res);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
bool ldv_queue_work_on_179(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 625
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 625
  ldv_func_res = tmp;
#line 627
  activate_work_11(ldv_func_arg3, 2);
#line 629
  return (ldv_func_res);
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
void ldv_flush_workqueue_180(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 635
  flush_workqueue(ldv_func_arg1);
#line 637
  call_and_disable_all_11(2);
#line 638
  return;
}
}
#line 640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
bool ldv_queue_delayed_work_on_181(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 644
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 644
  ldv_func_res = tmp;
#line 646
  activate_work_11(& ldv_func_arg3->work, 2);
#line 648
  return (ldv_func_res);
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
int ldv_seq_open_182(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 655
  tmp = seq_open(ldv_func_arg1, ldv_func_arg2);
#line 655
  ldv_func_res = tmp;
#line 657
  if (ldv_func_res == 0) {
#line 658
    ldv_state_variable_17 = 1;
#line 659
    ldv_seq_operations_17();
  } else {

  }
#line 663
  return (ldv_func_res);
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
int ldv_seq_open_183(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 670
  tmp = seq_open(ldv_func_arg1, ldv_func_arg2);
#line 670
  ldv_func_res = tmp;
#line 672
  if (ldv_func_res == 0) {
#line 673
    ldv_state_variable_17 = 1;
#line 674
    ldv_seq_operations_17();
  } else {

  }
#line 678
  return (ldv_func_res);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
int ldv_seq_release_184(struct inode *ldv_func_arg1 , struct file *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 685
  tmp = seq_release(ldv_func_arg1, ldv_func_arg2);
#line 685
  ldv_func_res = tmp;
#line 687
  ldv_state_variable_17 = 0;
#line 689
  return (ldv_func_res);
}
}
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/dscv/ri/08_1a/drivers/infiniband/ulp/ipoib/ipoib_fs.o.c.prepared"
int ldv_seq_release_185(struct inode *ldv_func_arg1 , struct file *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 696
  tmp = seq_release(ldv_func_arg1, ldv_func_arg2);
#line 696
  ldv_func_res = tmp;
#line 698
  ldv_state_variable_17 = 0;
#line 700
  return (ldv_func_res);
}
}
#line 8 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *memset(void * , int  , size_t  ) ;
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 7 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_module_refcounter  =    1;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_get(struct module *module ) 
{ 


  {
#line 13
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 15
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
#line 16
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
#line 25
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 28
    module_get_succeeded = ldv_undef_int();
#line 30
    if (module_get_succeeded == 1) {
#line 32
      ldv_module_refcounter = ldv_module_refcounter + 1;
#line 34
      return (1);
    } else {
#line 39
      return (0);
    }
  } else {

  }
#line 41
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put(struct module *module ) 
{ 


  {
#line 48
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 50
    if (ldv_module_refcounter <= 1) {
#line 50
      ldv_error();
    } else {

    }
#line 52
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put_and_exit(void) 
{ 


  {
#line 59
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
#line 61
  goto LDV_STOP;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
unsigned int ldv_module_refcount(void) 
{ 


  {
#line 68
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/4829/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 75
  if (ldv_module_refcounter != 1) {
#line 75
    ldv_error();
  } else {

  }
#line 79
  return;
}
}
