extern void __VERIFIER_error() __attribute__ ((__noreturn__));

/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is false */

#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 86 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 87 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 19 "include/linux/types.h"
typedef __u32 nlink_t;
#line 20 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 55 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/alternative.h"
struct module;
#line 310 "include/linux/printk.h"
struct file_operations;
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 23 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 24
struct pt_regs;
#line 386 "include/linux/kernel.h"
struct pid;
#line 14 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2024_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2024_8 ldv_2024 ;
};
#line 27 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2031_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2031_10 ldv_2031 ;
};
#line 33 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 18 "include/linux/lockdep.h"
struct mm_struct;
#line 58 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2096_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2111_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2112_11 {
   struct __anonstruct_ldv_2096_12 ldv_2096 ;
   struct __anonstruct_ldv_2111_13 ldv_2111 ;
};
#line 59 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2112_11 ldv_2112 ;
};
#line 13 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 212 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 214 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 214 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 302
struct page;
#line 302 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 310
struct file;
#line 325
struct seq_file;
#line 355
struct thread_struct;
#line 357
struct cpumask;
#line 127 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2767_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2767_18 ldv_2767 ;
};
#line 97 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 648 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 166 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 298 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 316 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5125_23 {
   u64 rip ;
   u64 rdp ;
};
#line 316 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5131_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 316 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5132_22 {
   struct __anonstruct_ldv_5125_23 ldv_5125 ;
   struct __anonstruct_ldv_5131_24 ldv_5131 ;
};
#line 316 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5141_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 316 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5132_22 ldv_5132 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5141_25 ldv_5141 ;
};
#line 350 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 371 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 376 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 382 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 388 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 396 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 443
struct kmem_cache;
#line 444
struct perf_event;
#line 445 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 574 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_5960_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_5961_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5960_29 ldv_5960 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_5961_28 ldv_5961 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 40 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef uint32_t uint32;
#line 42 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef int32_t int32;
#line 286 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGuestPtr {
   uint32 gmrId ;
   uint32 offset ;
};
#line 291 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGuestPtr SVGAGuestPtr;
#line 292 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_ldv_6463_32 {
   unsigned char bitsPerPixel ;
   unsigned char colorDepth ;
   unsigned short reserved ;
};
#line 292 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
union __anonunion_ldv_6465_31 {
   struct __anonstruct_ldv_6463_32 ldv_6463 ;
   uint32 value ;
};
#line 292 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGMRImageFormat {
   union __anonunion_ldv_6465_31 ldv_6465 ;
};
#line 325 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGMRImageFormat SVGAGMRImageFormat;
#line 370 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGASignedRect {
   int32 left ;
   int32 top ;
   int32 right ;
   int32 bottom ;
};
#line 391 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGASignedRect SVGASignedRect;
#line 1331 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDefineGMRFB_40 {
   SVGAGuestPtr ptr ;
   uint32 bytesPerLine ;
   SVGAGMRImageFormat format ;
};
#line 1331 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDefineGMRFB_40 SVGAFifoCmdDefineGMRFB;
#line 612 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum ldv_9149 {
    SVGA3D_RT_DEPTH = 0,
    SVGA3D_RT_STENCIL = 1,
    SVGA3D_RT_COLOR0 = 2,
    SVGA3D_RT_COLOR1 = 3,
    SVGA3D_RT_COLOR2 = 4,
    SVGA3D_RT_COLOR3 = 5,
    SVGA3D_RT_COLOR4 = 6,
    SVGA3D_RT_COLOR5 = 7,
    SVGA3D_RT_COLOR6 = 8,
    SVGA3D_RT_COLOR7 = 9,
    SVGA3D_RT_MAX = 10,
    SVGA3D_RT_INVALID = 4294967295U
} ;
#line 626 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9149 SVGA3dRenderTargetType;
#line 703 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef int SVGA3dTextureStateName;
#line 763 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef int SVGA3dTextureFilter;
#line 804
enum ldv_9174 {
    SVGA3D_DECLUSAGE_POSITION = 0,
    SVGA3D_DECLUSAGE_BLENDWEIGHT = 1,
    SVGA3D_DECLUSAGE_BLENDINDICES = 2,
    SVGA3D_DECLUSAGE_NORMAL = 3,
    SVGA3D_DECLUSAGE_PSIZE = 4,
    SVGA3D_DECLUSAGE_TEXCOORD = 5,
    SVGA3D_DECLUSAGE_TANGENT = 6,
    SVGA3D_DECLUSAGE_BINORMAL = 7,
    SVGA3D_DECLUSAGE_TESSFACTOR = 8,
    SVGA3D_DECLUSAGE_POSITIONT = 9,
    SVGA3D_DECLUSAGE_COLOR = 10,
    SVGA3D_DECLUSAGE_FOG = 11,
    SVGA3D_DECLUSAGE_DEPTH = 12,
    SVGA3D_DECLUSAGE_SAMPLE = 13,
    SVGA3D_DECLUSAGE_MAX = 14
} ;
#line 843 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9174 SVGA3dDeclUsage;
#line 844
enum ldv_9176 {
    SVGA3D_DECLMETHOD_DEFAULT = 0,
    SVGA3D_DECLMETHOD_PARTIALU = 1,
    SVGA3D_DECLMETHOD_PARTIALV = 2,
    SVGA3D_DECLMETHOD_CROSSUV = 3,
    SVGA3D_DECLMETHOD_UV = 4,
    SVGA3D_DECLMETHOD_LOOKUP = 5,
    SVGA3D_DECLMETHOD_LOOKUPPRESAMPLED = 6
} ;
#line 853 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9176 SVGA3dDeclMethod;
#line 854
enum ldv_9178 {
    SVGA3D_DECLTYPE_FLOAT1 = 0,
    SVGA3D_DECLTYPE_FLOAT2 = 1,
    SVGA3D_DECLTYPE_FLOAT3 = 2,
    SVGA3D_DECLTYPE_FLOAT4 = 3,
    SVGA3D_DECLTYPE_D3DCOLOR = 4,
    SVGA3D_DECLTYPE_UBYTE4 = 5,
    SVGA3D_DECLTYPE_SHORT2 = 6,
    SVGA3D_DECLTYPE_SHORT4 = 7,
    SVGA3D_DECLTYPE_UBYTE4N = 8,
    SVGA3D_DECLTYPE_SHORT2N = 9,
    SVGA3D_DECLTYPE_SHORT4N = 10,
    SVGA3D_DECLTYPE_USHORT2N = 11,
    SVGA3D_DECLTYPE_USHORT4N = 12,
    SVGA3D_DECLTYPE_UDEC3 = 13,
    SVGA3D_DECLTYPE_DEC3N = 14,
    SVGA3D_DECLTYPE_FLOAT16_2 = 15,
    SVGA3D_DECLTYPE_FLOAT16_4 = 16,
    SVGA3D_DECLTYPE_MAX = 17
} ;
#line 874 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9178 SVGA3dDeclType;
#line 903
enum ldv_9184 {
    SVGA3D_PRIMITIVE_INVALID = 0,
    SVGA3D_PRIMITIVE_TRIANGLELIST = 1,
    SVGA3D_PRIMITIVE_POINTLIST = 2,
    SVGA3D_PRIMITIVE_LINELIST = 3,
    SVGA3D_PRIMITIVE_LINESTRIP = 4,
    SVGA3D_PRIMITIVE_TRIANGLESTRIP = 5,
    SVGA3D_PRIMITIVE_TRIANGLEFAN = 6,
    SVGA3D_PRIMITIVE_MAX = 7
} ;
#line 913 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9184 SVGA3dPrimitiveType;
#line 958
enum ldv_9194 {
    SVGA3D_SHADERTYPE_VS = 1,
    SVGA3D_SHADERTYPE_PS = 2,
    SVGA3D_SHADERTYPE_MAX = 3
} ;
#line 963 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9194 SVGA3dShaderType;
#line 977 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef int SVGA3dStretchBltMode;
#line 978
enum ldv_9200 {
    SVGA3D_QUERYTYPE_OCCLUSION = 0,
    SVGA3D_QUERYTYPE_MAX = 1
} ;
#line 982 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9200 SVGA3dQueryType;
#line 994 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef int SVGA3dTransferType;
#line 1077 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dSurfaceImageId {
   uint32 sid ;
   uint32 face ;
   uint32 mipmap ;
};
#line 1088 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dSurfaceImageId SVGA3dSurfaceImageId;
#line 1089 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
#line 1110 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dGuestImage SVGA3dGuestImage;
#line 1124 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdHeader_60 {
   uint32 id ;
   uint32 size ;
};
#line 1124 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdHeader_60 SVGA3dCmdHeader;
#line 1269 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dBox_70 {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
};
#line 1269 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dBox_70 SVGA3dBox;
#line 1300 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdPresent_73 {
   uint32 sid ;
};
#line 1300 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdPresent_73 SVGA3dCmdPresent;
#line 1322 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSetRenderTarget_77 {
   uint32 cid ;
   SVGA3dRenderTargetType type ;
   SVGA3dSurfaceImageId target ;
};
#line 1322 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSetRenderTarget_77 SVGA3dCmdSetRenderTarget;
#line 1329 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceCopy_78 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
};
#line 1329 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceCopy_78 SVGA3dCmdSurfaceCopy;
#line 1338 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_79 {
   SVGA3dSurfaceImageId src ;
   SVGA3dSurfaceImageId dest ;
   SVGA3dBox boxSrc ;
   SVGA3dBox boxDest ;
   SVGA3dStretchBltMode mode ;
};
#line 1338 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceStretchBlt_79 SVGA3dCmdSurfaceStretchBlt;
#line 1378 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceDMA_81 {
   SVGA3dGuestImage guest ;
   SVGA3dSurfaceImageId host ;
   SVGA3dTransferType transfer ;
};
#line 1378 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceDMA_81 SVGA3dCmdSurfaceDMA;
#line 1444 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dArrayRangeHint_83 {
   uint32 first ;
   uint32 last ;
};
#line 1444 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dArrayRangeHint_83 SVGA3dArrayRangeHint;
#line 1462 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dArray_84 {
   uint32 surfaceId ;
   uint32 offset ;
   uint32 stride ;
};
#line 1462 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dArray_84 SVGA3dArray;
#line 1476 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dVertexArrayIdentity_85 {
   SVGA3dDeclType type ;
   SVGA3dDeclMethod method ;
   SVGA3dDeclUsage usage ;
   uint32 usageIndex ;
};
#line 1476 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dVertexArrayIdentity_85 SVGA3dVertexArrayIdentity;
#line 1483 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dVertexDecl_86 {
   SVGA3dVertexArrayIdentity identity ;
   SVGA3dArray array ;
   SVGA3dArrayRangeHint rangeHint ;
};
#line 1483 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dVertexDecl_86 SVGA3dVertexDecl;
#line 1533 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dPrimitiveRange_87 {
   SVGA3dPrimitiveType primType ;
   uint32 primitiveCount ;
   SVGA3dArray indexArray ;
   uint32 indexWidth ;
   int32 indexBias ;
};
#line 1533 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dPrimitiveRange_87 SVGA3dPrimitiveRange;
#line 1553 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDrawPrimitives_88 {
   uint32 cid ;
   uint32 numVertexDecls ;
   uint32 numRanges ;
};
#line 1553 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDrawPrimitives_88 SVGA3dCmdDrawPrimitives;
#line 1563 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
union __anonunion_ldv_7545_90 {
   uint32 value ;
   float floatValue ;
};
#line 1563 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dTextureState_89 {
   uint32 stage ;
   SVGA3dTextureStateName name ;
   union __anonunion_ldv_7545_90 ldv_7545 ;
};
#line 1563 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dTextureState_89 SVGA3dTextureState;
#line 1668 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSetShader_105 {
   uint32 cid ;
   SVGA3dShaderType type ;
   uint32 shid ;
};
#line 1668 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSetShader_105 SVGA3dCmdSetShader;
#line 1674 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdBeginQuery_106 {
   uint32 cid ;
   SVGA3dQueryType type ;
};
#line 1674 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdBeginQuery_106 SVGA3dCmdBeginQuery;
#line 1681 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdEndQuery_107 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
#line 1681 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdEndQuery_107 SVGA3dCmdEndQuery;
#line 1688 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdWaitForQuery_108 {
   uint32 cid ;
   SVGA3dQueryType type ;
   SVGAGuestPtr guestResult ;
};
#line 1688 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdWaitForQuery_108 SVGA3dCmdWaitForQuery;
#line 1743 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_111 {
   SVGA3dSurfaceImageId srcImage ;
   SVGASignedRect srcRect ;
   uint32 destScreenId ;
   SVGASignedRect destRect ;
};
#line 1743 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdBlitSurfaceToScreen_111 SVGA3dCmdBlitSurfaceToScreen;
#line 65 "include/linux/miscdevice.h"
struct timespec;
#line 32 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 37 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 254 "include/linux/seqlock.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 214 "include/linux/rcupdate.h"
struct notifier_block;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_8966_120 {
   u32 hash ;
   u32 len ;
};
#line 117 "include/linux/rculist_bl.h"
union __anonunion_ldv_8968_119 {
   struct __anonstruct_ldv_8966_120 ldv_8966 ;
   u64 hash_len ;
};
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   union __anonunion_ldv_8968_119 ldv_8968 ;
   unsigned char const   *name ;
};
#line 87 "include/linux/dcache.h"
struct inode;
#line 87
struct dentry_operations;
#line 87
struct super_block;
#line 87 "include/linux/dcache.h"
union __anonunion_d_u_121 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 87 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_121 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 138 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 411 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 133 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 197 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 380 "include/linux/radix-tree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 83
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 90
struct pid_namespace;
#line 90 "include/linux/rbtree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/fiemap.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 42
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 48
struct rw_semaphore;
#line 49 "include/linux/shrinker.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 72 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 182 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 15 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 314 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 353
struct tvec_base;
#line 354 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 50 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 96 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   int cpu ;
};
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 557 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_187 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_187 nodemask_t;
#line 135 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_188 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_188 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 56 "include/uapi/linux/fs.h"
struct export_operations;
#line 58
struct iovec;
#line 59
struct kiocb;
#line 60
struct kobject;
#line 61
struct pipe_inode_info;
#line 62
struct poll_table_struct;
#line 63
struct kstatfs;
#line 64
struct cred;
#line 65
struct swap_info_struct;
#line 65 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 241 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 36 "include/linux/projid.h"
typedef projid_t kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_14211_215 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_14211_215 ldv_14211 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 332 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 378 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 409
struct address_space;
#line 410
struct writeback_control;
#line 340 "include/linux/fs.h"
union __anonunion_arg_217 {
   char *buf ;
   void *data ;
};
#line 340 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_216 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_217 arg ;
   int error ;
};
#line 340 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_216 read_descriptor_t;
#line 343 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 402
struct backing_dev_info;
#line 403 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 424
struct request_queue;
#line 425
struct hd_struct;
#line 425
struct gendisk;
#line 425 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 497
struct posix_acl;
#line 498
struct inode_operations;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_14647_218 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 498 "include/linux/fs.h"
union __anonunion_ldv_14667_219 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 498
struct file_lock;
#line 498
struct cdev;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_14683_220 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 498 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_14647_218 ldv_14647 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_14667_219 ldv_14667 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_14683_220 ldv_14683 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 726 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 734 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 757 "include/linux/fs.h"
union __anonunion_f_u_221 {
   struct list_head fu_list ;
   struct callback_head fu_rcuhead ;
};
#line 757 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_221 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 900
struct files_struct;
#line 900 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 901 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 906 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 923
struct nlm_lockowner;
#line 924 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_223 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_222 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_223 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_222 fl_u ;
};
#line 1010 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1216 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1232
struct file_system_type;
#line 1232
struct super_operations;
#line 1232
struct xattr_handler;
#line 1232
struct mtd_info;
#line 1232 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1469 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1508 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1545 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
};
#line 1588 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1801 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 303 "include/linux/srcu.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 398 "include/linux/gfp.h"
struct mem_cgroup;
#line 137 "include/linux/slab.h"
struct __anonstruct_ldv_17625_225 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 137 "include/linux/slab.h"
union __anonunion_ldv_17626_224 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_17625_225 ldv_17625 ;
};
#line 137 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_17626_224 ldv_17626 ;
};
#line 235
struct sock;
#line 236
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 242 "include/linux/slab.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 194 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 54 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 65 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 75 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 50 "include/linux/proc_fs.h"
typedef int read_proc_t(char * , char ** , off_t  , int  , int * , void * );
#line 52 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file * , char const   * , unsigned long  , void * );
#line 53 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[] ;
};
#line 125
struct tty_driver;
#line 261
struct nsproxy;
#line 24 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_226 {
   unsigned long sig[1U] ;
};
#line 24 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_226 sigset_t;
#line 25
struct siginfo;
#line 17 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 22 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 124 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 34 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_228 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_229 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_230 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_231 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_232 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_233 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_234 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_227 {
   int _pad[28U] ;
   struct __anonstruct__kill_228 _kill ;
   struct __anonstruct__timer_229 _timer ;
   struct __anonstruct__rt_230 _rt ;
   struct __anonstruct__sigchld_231 _sigchld ;
   struct __anonstruct__sigfault_232 _sigfault ;
   struct __anonstruct__sigpoll_233 _sigpoll ;
   struct __anonstruct__sigsys_234 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_227 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 11 "include/linux/signal.h"
struct user_struct;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 73 "include/linux/file.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 23 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 53 "include/linux/device.h"
struct device_attribute;
#line 53
struct driver_attribute;
#line 53 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 127
struct device_type;
#line 184
struct of_device_id;
#line 184
struct acpi_device_id;
#line 184 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 249 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 303
struct class_attribute;
#line 303 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 398 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 451 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 478 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 577 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 587 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 592
struct dma_coherent_mem;
#line 592 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
};
#line 720 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 13 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 191 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[16U] ;
   kernel_ulong_t driver_data ;
};
#line 225 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 502 "include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 610
struct mfd_cell;
#line 611 "include/linux/mod_devicetable.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 69 "include/linux/io.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 17
struct hotplug_slot;
#line 17 "include/linux/irqreturn.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 95 "include/linux/pci.h"
typedef int pci_power_t;
#line 122 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 123
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 148 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 165 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 208
struct pcie_link_state;
#line 209
struct pci_vpd;
#line 210
struct pci_sriov;
#line 211
struct pci_ats;
#line 212
struct pci_driver;
#line 212 "include/linux/pci.h"
union __anonunion_ldv_20197_238 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 212 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_20197_238 ldv_20197 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 401
struct pci_ops;
#line 401 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 492 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 513 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 526 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 536 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 566 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1070 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 42 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 48 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 55
struct uprobe;
#line 55 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 69 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 88 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21226_240 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_21236_244 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21238_243 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_21236_244 ldv_21236 ;
   int units ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_21240_242 {
   union __anonunion_ldv_21238_243 ldv_21238 ;
   atomic_t _count ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21241_241 {
   unsigned long counters ;
   struct __anonstruct_ldv_21240_242 ldv_21240 ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_21242_239 {
   union __anonunion_ldv_21226_240 ldv_21226 ;
   union __anonunion_ldv_21241_241 ldv_21241 ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_21249_246 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 112
struct slab;
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21253_245 {
   struct list_head lru ;
   struct __anonstruct_ldv_21249_246 ldv_21249 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_21258_247 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 112 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_21242_239 ldv_21242 ;
   union __anonunion_ldv_21253_245 ldv_21253 ;
   union __anonunion_ldv_21258_247 ldv_21258 ;
   unsigned long debug_flags ;
   int _last_nid ;
};
#line 179 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 219 "include/linux/mm_types.h"
struct __anonstruct_linear_249 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 219 "include/linux/mm_types.h"
union __anonunion_shared_248 {
   struct __anonstruct_linear_249 linear ;
   struct list_head nonlinear ;
};
#line 219
struct anon_vma;
#line 219
struct vm_operations_struct;
#line 219
struct mempolicy;
#line 219 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_248 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 291 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 297 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 310 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 323
struct linux_binfmt;
#line 323
struct mmu_notifier_mm;
#line 323 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 157 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 181 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 34 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 273 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 1843 "include/linux/pci.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 23 "include/linux/sem.h"
struct sem_undo_list;
#line 23 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 32 "include/linux/sem.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 44 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 80 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/seccomp.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 460 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct signal_struct;
#line 36
struct key_type;
#line 38
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_27075_263 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_27084_264 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_265 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_266 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_27075_263 ldv_27075 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_27084_264 ldv_27084 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_265 type_data ;
   union __anonunion_payload_266 payload ;
};
#line 323
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct thread_group_cred;
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 345
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 121 "include/linux/sched.h"
struct cfs_rq;
#line 122
struct task_group;
#line 357
struct kioctx;
#line 358 "include/linux/sched.h"
union __anonunion_ki_obj_267 {
   void *user ;
   struct task_struct *tsk ;
};
#line 358
struct eventfd_ctx;
#line 358 "include/linux/sched.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_267 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 161 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 181 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct callback_head callback_head ;
};
#line 378 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 430 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 438 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 445 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 457 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 477 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 513
struct autogroup;
#line 514
struct tty_struct;
#line 514
struct taskstats;
#line 514
struct tty_audit_buf;
#line 514 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 690 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 734
struct reclaim_state;
#line 735 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 750 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1051
struct rq;
#line 1052 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*migrate_task_rq)(struct task_struct * , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1119 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1124 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1136 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1171 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1206
struct rt_rq;
#line 1206 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1229 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1600
struct css_set;
#line 1600
struct compat_robust_list_head;
#line 1600 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
};
#line 39 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 275 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 279 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 106 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mtrr.h"
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
#line 111 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mtrr.h"
struct agp_version {
   u16 major ;
   u16 minor ;
};
#line 44 "include/linux/agp_backend.h"
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 58
struct agp_bridge_data;
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 74 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
typedef unsigned int drm_magic_t;
#line 75 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
#line 110 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_hw_lock {
   unsigned int volatile   lock ;
   char padding[60U] ;
};
#line 139 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_unique {
   size_t unique_len ;
   char *unique ;
};
#line 173
enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5,
    _DRM_GEM = 6
} ;
#line 183
enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128
} ;
#line 234
enum drm_stat_type {
    _DRM_STAT_LOCK = 0,
    _DRM_STAT_OPENS = 1,
    _DRM_STAT_CLOSES = 2,
    _DRM_STAT_IOCTLS = 3,
    _DRM_STAT_LOCKS = 4,
    _DRM_STAT_UNLOCKS = 5,
    _DRM_STAT_VALUE = 6,
    _DRM_STAT_BYTE = 7,
    _DRM_STAT_COUNT = 8,
    _DRM_STAT_IRQ = 9,
    _DRM_STAT_PRIMARY = 10,
    _DRM_STAT_SECONDARY = 11,
    _DRM_STAT_DMA = 12,
    _DRM_STAT_SPECIAL = 13,
    _DRM_STAT_MISSED = 14
} ;
#line 450 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_irq_busid {
   int irq ;
   int busnum ;
   int devnum ;
   int funcnum ;
};
#line 575 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_set_version {
   int drm_di_major ;
   int drm_di_minor ;
   int drm_dd_major ;
   int drm_dd_minor ;
};
#line 288 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_mode.h"
struct drm_mode_fb_cmd2 {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pixel_format ;
   __u32 flags ;
   __u32 handles[4U] ;
   __u32 pitches[4U] ;
   __u32 offsets[4U] ;
};
#line 433 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_mode.h"
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
#line 462 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_mode.h"
struct drm_event {
   __u32 type ;
   __u32 length ;
};
#line 763 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm.h"
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
#line 79 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_sarea.h"
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[64U] ;
   int count ;
   int layer ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/idr.h"
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
#line 154
struct drm_file;
#line 155
struct drm_device;
#line 54 "include/linux/delay.h"
struct drm_hash_item {
   struct hlist_node head ;
   unsigned long key ;
};
#line 46 "include/drm/drm_hashtab.h"
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
#line 63 "include/drm/drm_hashtab.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   void *private ;
};
#line 34 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 173
struct drm_mm;
#line 173 "include/linux/seq_file.h"
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned char hole_follows : 1 ;
   unsigned char scanned_block : 1 ;
   unsigned char scanned_prev_free : 1 ;
   unsigned char scanned_next_free : 1 ;
   unsigned char scanned_preceeds_hole : 1 ;
   unsigned char allocated : 1 ;
   unsigned long color ;
   unsigned long start ;
   unsigned long size ;
   struct drm_mm *mm ;
};
#line 58 "include/drm/drm_mm.h"
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   struct list_head unused_nodes ;
   int num_unused ;
   spinlock_t unused_lock ;
   unsigned char scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_color ;
   unsigned long scan_size ;
   unsigned long scan_hit_start ;
   unsigned int scan_hit_size ;
   unsigned int scanned_blocks ;
   unsigned long scan_start ;
   unsigned long scan_end ;
   struct drm_mm_node *prev_scanned_node ;
   void (*color_adjust)(struct drm_mm_node * , unsigned long  , unsigned long * ,
                        unsigned long * ) ;
};
#line 296 "include/drm/drmP.h"
typedef int drm_ioctl_t(struct drm_device * , void * , struct drm_file * );
#line 300 "include/drm/drmP.h"
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   unsigned int cmd_drv ;
};
#line 346 "include/drm/drmP.h"
struct drm_buf {
   int idx ;
   int total ;
   int order ;
   int used ;
   unsigned long offset ;
   void *address ;
   unsigned long bus_address ;
   struct drm_buf *next ;
   int volatile   waiting ;
   int volatile   pending ;
   struct drm_file *file_priv ;
   int context ;
   int while_locked ;
   int list ;
   int dev_priv_size ;
   void *dev_private ;
};
#line 378 "include/drm/drmP.h"
struct drm_freelist {
   int initialized ;
   atomic_t count ;
   struct drm_buf *next ;
   wait_queue_head_t waiting ;
   int low_mark ;
   int high_mark ;
   atomic_t wfh ;
   spinlock_t lock ;
};
#line 390 "include/drm/drmP.h"
struct drm_dma_handle {
   dma_addr_t busaddr ;
   void *vaddr ;
   size_t size ;
};
#line 396 "include/drm/drmP.h"
struct drm_buf_entry {
   int buf_size ;
   int buf_count ;
   struct drm_buf *buflist ;
   int seg_count ;
   int page_order ;
   struct drm_dma_handle **seglist ;
   struct drm_freelist freelist ;
};
#line 410 "include/drm/drmP.h"
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event * ) ;
};
#line 420 "include/drm/drmP.h"
struct drm_prime_file_private {
   struct list_head head ;
   struct mutex lock ;
};
#line 426
struct drm_minor;
#line 426
struct drm_master;
#line 426 "include/drm/drmP.h"
struct drm_file {
   int authenticated ;
   struct pid *pid ;
   kuid_t uid ;
   drm_magic_t magic ;
   unsigned long ioctl_count ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   int is_master ;
   struct drm_master *master ;
   struct list_head fbs ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
   struct drm_prime_file_private prime ;
};
#line 474 "include/drm/drmP.h"
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
#line 496 "include/drm/drmP.h"
struct drm_device_dma {
   struct drm_buf_entry bufs[23U] ;
   int buf_count ;
   struct drm_buf **buflist ;
   int seg_count ;
   int page_count ;
   unsigned long *pagelist ;
   unsigned long byte_count ;
   int flags ;
};
#line 521 "include/drm/drmP.h"
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
#line 539 "include/drm/drmP.h"
struct drm_sg_mem {
   unsigned long handle ;
   void *virtual ;
   int pages ;
   struct page **pagelist ;
   dma_addr_t *busaddr ;
};
#line 550 "include/drm/drmP.h"
struct drm_sigdata {
   int context ;
   struct drm_hw_lock *lock ;
};
#line 555 "include/drm/drmP.h"
struct drm_local_map {
   resource_size_t offset ;
   unsigned long size ;
   enum drm_map_type type ;
   enum drm_map_flags flags ;
   void *handle ;
   int mtrr ;
};
#line 571 "include/drm/drmP.h"
struct drm_map_list {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct drm_local_map *map ;
   uint64_t user_token ;
   struct drm_master *master ;
   struct drm_mm_node *file_offset_node ;
};
#line 619
struct dma_buf;
#line 619
struct dma_buf_attachment;
#line 619 "include/drm/drmP.h"
struct drm_gem_object {
   struct kref refcount ;
   atomic_t handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_map_list map_list ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   void *driver_private ;
   struct dma_buf *export_dma_buf ;
   struct dma_buf_attachment *import_attach ;
};
#line 30 "include/linux/of.h"
typedef u32 phandle;
#line 32 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
#line 41 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
#line 6 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned char cc_t;
#line 7 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned int speed_t;
#line 8 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
typedef unsigned int tcflag_t;
#line 30 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/termbits.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 93 "include/asm-generic/termios.h"
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
#line 27 "include/linux/export.h"
struct serial_icounter_struct;
#line 28 "include/linux/export.h"
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int  ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const   * , int  ) ;
   int (*put_char)(struct tty_struct * , unsigned char  ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int  ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int  ) ;
   void (*send_xchar)(struct tty_struct * , char  ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int  , unsigned int  ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int  , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int  ) ;
   void (*poll_put_char)(struct tty_driver * , int  , char  ) ;
   struct file_operations  const  *proc_fops ;
};
#line 288 "include/linux/tty_driver.h"
struct tty_port;
#line 288 "include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev *cdevs ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   unsigned int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   unsigned long flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct tty_port **ports ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations  const  *ops ;
   struct list_head tty_drivers ;
};
#line 48 "include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec ts_real ;
};
#line 124 "include/linux/pps_kernel.h"
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t  ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const   * ,
                    size_t  ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  , struct pps_event_time * ) ;
   struct module *owner ;
   int refcount ;
};
#line 154 "include/linux/tty_ldisc.h"
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   atomic_t users ;
   wait_queue_head_t wq_idle ;
};
#line 160 "include/linux/tty_ldisc.h"
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0U] ;
};
#line 42 "include/linux/tty.h"
struct tty_bufhead {
   struct work_struct work ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
#line 62 "include/linux/tty.h"
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int  ) ;
   void (*shutdown)(struct tty_port * ) ;
   void (*drop)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
#line 189 "include/linux/tty.h"
struct tty_port {
   struct tty_bufhead buf ;
   struct tty_struct *tty ;
   struct tty_struct *itty ;
   struct tty_port_operations  const  *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned long iflags ;
   unsigned char console : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
#line 216 "include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations  const  *ops ;
   int index ;
   struct mutex ldisc_mutex ;
   struct tty_ldisc *ldisc ;
   struct mutex atomic_write_lock ;
   struct mutex legacy_mutex ;
   struct mutex termios_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios termios ;
   struct ktermios termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned char closing : 1 ;
   unsigned short minimum_to_wake ;
   unsigned char *write_buf ;
   int write_cnt ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
#line 91 "include/uapi/linux/serial.h"
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9U] ;
};
#line 779 "include/linux/fb.h"
struct drm_mode_set;
#line 780
struct drm_framebuffer;
#line 781
struct drm_object_properties;
#line 782 "include/linux/fb.h"
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
   struct drm_object_properties *properties ;
};
#line 57 "include/drm/drm_crtc.h"
struct drm_object_properties {
   int count ;
   uint32_t ids[24U] ;
   uint64_t values[24U] ;
};
#line 64
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
#line 105 "include/drm/drm_crtc.h"
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32U] ;
   enum drm_mode_status status ;
   unsigned int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int clock_index ;
   int synth_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int private_size ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
};
#line 180
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
#line 186
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
#line 195 "include/drm/drm_crtc.h"
struct drm_display_info {
   char name[32U] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   u8 cea_rev ;
};
#line 220 "include/drm/drm_crtc.h"
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer * ) ;
   int (*create_handle)(struct drm_framebuffer * , struct drm_file * , unsigned int * ) ;
   int (*dirty)(struct drm_framebuffer * , struct drm_file * , unsigned int  , unsigned int  ,
                struct drm_clip_rect * , unsigned int  ) ;
};
#line 241 "include/drm/drm_crtc.h"
struct drm_framebuffer {
   struct drm_device *dev ;
   struct kref refcount ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs  const  *funcs ;
   unsigned int pitches[4U] ;
   unsigned int offsets[4U] ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   uint32_t pixel_format ;
   struct list_head filp_head ;
   void *helper_private ;
};
#line 273 "include/drm/drm_crtc.h"
struct drm_property_blob {
   struct drm_mode_object base ;
   struct list_head head ;
   unsigned int length ;
   unsigned char data[] ;
};
#line 286 "include/drm/drm_crtc.h"
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32U] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct list_head enum_blob_list ;
};
#line 297
struct drm_crtc;
#line 298
struct drm_connector;
#line 299
struct drm_encoder;
#line 300
struct drm_pending_vblank_event;
#line 302 "include/drm/drm_crtc.h"
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc * ) ;
   void (*restore)(struct drm_crtc * ) ;
   void (*reset)(struct drm_crtc * ) ;
   int (*cursor_set)(struct drm_crtc * , struct drm_file * , uint32_t  , uint32_t  ,
                     uint32_t  ) ;
   int (*cursor_move)(struct drm_crtc * , int  , int  ) ;
   void (*gamma_set)(struct drm_crtc * , u16 * , u16 * , u16 * , uint32_t  , uint32_t  ) ;
   void (*destroy)(struct drm_crtc * ) ;
   int (*set_config)(struct drm_mode_set * ) ;
   int (*page_flip)(struct drm_crtc * , struct drm_framebuffer * , struct drm_pending_vblank_event * ) ;
   int (*set_property)(struct drm_crtc * , struct drm_property * , uint64_t  ) ;
};
#line 362 "include/drm/drm_crtc.h"
struct drm_crtc {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer *fb ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   bool invert_dimensions ;
   int x ;
   int y ;
   struct drm_crtc_funcs  const  *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   s64 framedur_ns ;
   s64 linedur_ns ;
   s64 pixeldur_ns ;
   void *helper_private ;
   struct drm_object_properties properties ;
};
#line 425 "include/drm/drm_crtc.h"
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector * , int  ) ;
   void (*save)(struct drm_connector * ) ;
   void (*restore)(struct drm_connector * ) ;
   void (*reset)(struct drm_connector * ) ;
   enum drm_connector_status (*detect)(struct drm_connector * , bool  ) ;
   int (*fill_modes)(struct drm_connector * , uint32_t  , uint32_t  ) ;
   int (*set_property)(struct drm_connector * , struct drm_property * , uint64_t  ) ;
   void (*destroy)(struct drm_connector * ) ;
   void (*force)(struct drm_connector * ) ;
};
#line 463 "include/drm/drm_crtc.h"
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder * ) ;
   void (*destroy)(struct drm_encoder * ) ;
};
#line 475 "include/drm/drm_crtc.h"
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_encoder_funcs  const  *funcs ;
   void *helper_private ;
};
#line 508
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
#line 515 "include/drm/drm_crtc.h"
struct drm_connector {
   struct drm_device *dev ;
   struct device kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   struct list_head modes ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs  const  *funcs ;
   struct list_head user_modes ;
   struct drm_property_blob *edid_blob_ptr ;
   struct drm_object_properties properties ;
   uint8_t polled ;
   int dpms ;
   void *helper_private ;
   enum drm_connector_force force ;
   uint32_t encoder_ids[3U] ;
   struct drm_encoder *encoder ;
   uint8_t eld[128U] ;
   bool dvi_dual ;
   int max_tmds_clock ;
   bool latency_present[2U] ;
   int video_latency[2U] ;
   int audio_latency[2U] ;
   int null_edid_counter ;
   unsigned int bad_edid_counter ;
};
#line 676 "include/drm/drm_crtc.h"
struct drm_mode_set {
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
#line 704 "include/drm/drm_crtc.h"
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device * , struct drm_file * ,
                                        struct drm_mode_fb_cmd2 * ) ;
   void (*output_poll_changed)(struct drm_device * ) ;
};
#line 719 "include/drm/drm_crtc.h"
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t *id_list ;
};
#line 741 "include/drm/drm_crtc.h"
struct drm_mode_config {
   struct mutex mutex ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_plane ;
   struct list_head plane_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs  const  *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   bool poll_running ;
   struct delayed_work output_poll_work ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *dithering_mode_property ;
   struct drm_property *dirty_info_property ;
   uint32_t preferred_depth ;
   uint32_t prefer_shadow ;
};
#line 1076 "include/drm/drm_crtc.h"
struct drm_master {
   struct kref refcount ;
   struct list_head head ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   int unique_size ;
   int blocked ;
   struct drm_open_hash magiclist ;
   struct list_head magicfree ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
#line 705 "include/drm/drmP.h"
struct drm_bus {
   int bus_type ;
   int (*get_irq)(struct drm_device * ) ;
   char const   *(*get_name)(struct drm_device * ) ;
   int (*set_busid)(struct drm_device * , struct drm_master * ) ;
   int (*set_unique)(struct drm_device * , struct drm_master * , struct drm_unique * ) ;
   int (*irq_by_busid)(struct drm_device * , struct drm_irq_busid * ) ;
   int (*agp_init)(struct drm_device * ) ;
};
#line 732
struct usb_driver;
#line 732 "include/drm/drmP.h"
union __anonunion_kdriver_286 {
   struct pci_driver *pci ;
   struct platform_device *platform_device ;
   struct usb_driver *usb ;
};
#line 732 "include/drm/drmP.h"
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long  ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file * ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t  ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device * , void * , struct drm_file * ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device * , int  ) ;
   u32 (*get_vblank_counter)(struct drm_device * , int  ) ;
   int (*enable_vblank)(struct drm_device * , int  ) ;
   void (*disable_vblank)(struct drm_device * , int  ) ;
   int (*device_is_agp)(struct drm_device * ) ;
   int (*get_scanout_position)(struct drm_device * , int  , int * , int * ) ;
   int (*get_vblank_timestamp)(struct drm_device * , int  , int * , struct timeval * ,
                               unsigned int  ) ;
   irqreturn_t (*irq_handler)(int  , void * ) ;
   void (*irq_preinstall)(struct drm_device * ) ;
   int (*irq_postinstall)(struct drm_device * ) ;
   void (*irq_uninstall)(struct drm_device * ) ;
   void (*set_version)(struct drm_device * , struct drm_set_version * ) ;
   int (*master_create)(struct drm_device * , struct drm_master * ) ;
   void (*master_destroy)(struct drm_device * , struct drm_master * ) ;
   int (*master_set)(struct drm_device * , struct drm_file * , bool  ) ;
   void (*master_drop)(struct drm_device * , struct drm_file * , bool  ) ;
   int (*debugfs_init)(struct drm_minor * ) ;
   void (*debugfs_cleanup)(struct drm_minor * ) ;
   int (*gem_init_object)(struct drm_gem_object * ) ;
   void (*gem_free_object)(struct drm_gem_object * ) ;
   int (*gem_open_object)(struct drm_gem_object * , struct drm_file * ) ;
   void (*gem_close_object)(struct drm_gem_object * , struct drm_file * ) ;
   int (*prime_handle_to_fd)(struct drm_device * , struct drm_file * , uint32_t  ,
                             uint32_t  , int * ) ;
   int (*prime_fd_to_handle)(struct drm_device * , struct drm_file * , int  , uint32_t * ) ;
   struct dma_buf *(*gem_prime_export)(struct drm_device * , struct drm_gem_object * ,
                                       int  ) ;
   struct drm_gem_object *(*gem_prime_import)(struct drm_device * , struct dma_buf * ) ;
   void (*vgaarb_irq)(struct drm_device * , bool  ) ;
   int (*dumb_create)(struct drm_file * , struct drm_device * , struct drm_mode_create_dumb * ) ;
   int (*dumb_map_offset)(struct drm_file * , struct drm_device * , uint32_t  , uint64_t * ) ;
   int (*dumb_destroy)(struct drm_file * , struct drm_device * , uint32_t  ) ;
   struct vm_operations_struct  const  *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc *ioctls ;
   int num_ioctls ;
   struct file_operations  const  *fops ;
   union __anonunion_kdriver_286 kdriver ;
   struct drm_bus *bus ;
   struct list_head device_list ;
};
#line 988 "include/drm/drmP.h"
struct drm_info_list {
   char const   *name ;
   int (*show)(struct seq_file * , void * ) ;
   u32 driver_features ;
   void *data ;
};
#line 999 "include/drm/drmP.h"
struct drm_info_node {
   struct list_head list ;
   struct drm_minor *minor ;
   struct drm_info_list *info_ent ;
   struct dentry *dent ;
};
#line 1009 "include/drm/drmP.h"
struct drm_minor {
   int index ;
   int type ;
   dev_t device ;
   struct device kdev ;
   struct drm_device *dev ;
   struct proc_dir_entry *proc_root ;
   struct drm_info_node proc_nodes ;
   struct dentry *debugfs_root ;
   struct list_head debugfs_list ;
   struct mutex debugfs_lock ;
   struct drm_master *master ;
   struct list_head master_list ;
   struct drm_mode_group mode_group ;
};
#line 1046 "include/drm/drmP.h"
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
#line 1053
struct usb_device;
#line 1053 "include/drm/drmP.h"
struct drm_device {
   struct list_head driver_item ;
   char *devname ;
   int if_version ;
   spinlock_t count_lock ;
   struct mutex struct_mutex ;
   int open_count ;
   atomic_t ioctl_count ;
   atomic_t vma_count ;
   int buf_use ;
   atomic_t buf_alloc ;
   unsigned long counters ;
   enum drm_stat_type types[15U] ;
   atomic_t counts[15U] ;
   struct list_head filelist ;
   struct list_head maplist ;
   int map_count ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   int ctx_count ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   struct drm_device_dma *dma ;
   int irq_enabled ;
   long volatile   context_flag ;
   long volatile   interrupt_flag ;
   long volatile   dma_flag ;
   wait_queue_head_t context_wait ;
   int last_checked ;
   int last_context ;
   unsigned long last_switch ;
   struct work_struct work ;
   int vblank_disable_allowed ;
   wait_queue_head_t *vbl_queue ;
   atomic_t *_vblank_count ;
   struct timeval *_vblank_time ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   atomic_t *vblank_refcount ;
   u32 *last_vblank ;
   int *vblank_enabled ;
   int *vblank_inmodeset ;
   u32 *last_vblank_wait ;
   struct timer_list vblank_disable_timer ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   cycles_t ctx_start ;
   cycles_t lck_start ;
   struct fasync_struct *buf_async ;
   wait_queue_head_t buf_readers ;
   wait_queue_head_t buf_writers ;
   struct drm_agp_head *agp ;
   struct device *dev ;
   struct pci_dev *pdev ;
   int pci_vendor ;
   int pci_device ;
   struct platform_device *platformdev ;
   struct usb_device *usbdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   void *dev_private ;
   void *mm_private ;
   struct address_space *dev_mapping ;
   struct drm_sigdata sigdata ;
   sigset_t sigmask ;
   struct drm_driver *driver ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_mode_config mode_config ;
   spinlock_t object_name_lock ;
   struct idr object_name_idr ;
   int switch_power_state ;
   atomic_t unplugged ;
};
#line 1619
enum drm_global_types {
    DRM_GLOBAL_TTM_MEM = 0,
    DRM_GLOBAL_TTM_BO = 1,
    DRM_GLOBAL_TTM_OBJECT = 2,
    DRM_GLOBAL_NUM = 3
} ;
#line 1626 "include/drm/drmP.h"
struct drm_global_reference {
   enum drm_global_types global_type ;
   size_t size ;
   void *object ;
   int (*init)(struct drm_global_reference * ) ;
   void (*release)(struct drm_global_reference * ) ;
};
#line 177 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_size {
   uint32_t width ;
   uint32_t height ;
   uint32_t depth ;
   uint32_t pad64 ;
};
#line 237 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_execbuf_arg {
   uint64_t commands ;
   uint32_t command_size ;
   uint32_t throttle_us ;
   uint64_t fence_rep ;
   uint32_t version ;
   uint32_t flags ;
};
#line 286 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_rep {
   uint32_t handle ;
   uint32_t mask ;
   uint32_t seqno ;
   uint32_t passed_seqno ;
   uint32_t pad64 ;
   int32_t error ;
};
#line 789 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 55 "include/linux/prio_heap.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 53 "include/linux/xattr.h"
struct simple_xattrs {
   struct list_head head ;
   spinlock_t lock ;
};
#line 98
struct cgroupfs_root;
#line 100
struct cgroup;
#line 101
struct css_id;
#line 62 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
   struct work_struct dput_work ;
};
#line 140 "include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   int id ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroupfs_root *root ;
   struct cgroup *top_cgroup ;
   struct list_head css_sets ;
   struct list_head allcg_node ;
   struct list_head cft_q_node ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct callback_head callback_head ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
   struct simple_xattrs xattrs ;
};
#line 214 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct callback_head callback_head ;
};
#line 108 "include/linux/swap.h"
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
#line 116 "include/linux/swap.h"
struct swap_extent {
   struct list_head list ;
   unsigned long start_page ;
   unsigned long nr_pages ;
   sector_t start_block ;
};
#line 150 "include/linux/swap.h"
struct swap_info_struct {
   unsigned long flags ;
   short prio ;
   signed char type ;
   signed char next ;
   unsigned int max ;
   unsigned char *swap_map ;
   unsigned int lowest_bit ;
   unsigned int highest_bit ;
   unsigned int pages ;
   unsigned int inuse_pages ;
   unsigned int cluster_next ;
   unsigned int cluster_nr ;
   unsigned int lowest_alloc ;
   unsigned int highest_alloc ;
   struct swap_extent *curr_swap_extent ;
   struct swap_extent first_swap_extent ;
   struct block_device *bdev ;
   struct file *swap_file ;
   unsigned int old_block_size ;
   unsigned long *frontswap_map ;
   atomic_t frontswap_pages ;
};
#line 461 "include/linux/suspend.h"
struct ttm_bo_device;
#line 462 "include/linux/suspend.h"
struct ttm_placement {
   unsigned int fpfn ;
   unsigned int lpfn ;
   unsigned int num_placement ;
   uint32_t const   *placement ;
   unsigned int num_busy_placement ;
   uint32_t const   *busy_placement ;
};
#line 68 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bus_placement {
   void *addr ;
   unsigned long base ;
   unsigned long size ;
   unsigned long offset ;
   bool is_iomem ;
   bool io_reserved_vm ;
   uint64_t io_reserved_count ;
};
#line 91 "include/drm/ttm/ttm_bo_api.h"
struct ttm_mem_reg {
   void *mm_node ;
   unsigned long start ;
   unsigned long size ;
   unsigned long num_pages ;
   uint32_t page_alignment ;
   uint32_t mem_type ;
   uint32_t placement ;
   struct ttm_bus_placement bus ;
};
#line 117
enum ttm_bo_type {
    ttm_bo_type_device = 0,
    ttm_bo_type_kernel = 1,
    ttm_bo_type_sg = 2
} ;
#line 123
struct ttm_tt;
#line 124
struct ttm_bo_global;
#line 124 "include/drm/ttm/ttm_bo_api.h"
struct ttm_buffer_object {
   struct ttm_bo_global *glob ;
   struct ttm_bo_device *bdev ;
   enum ttm_bo_type type ;
   void (*destroy)(struct ttm_buffer_object * ) ;
   unsigned long num_pages ;
   uint64_t addr_space_offset ;
   size_t acc_size ;
   struct kref kref ;
   struct kref list_kref ;
   wait_queue_head_t event_queue ;
   struct ttm_mem_reg mem ;
   struct file *persistent_swap_storage ;
   struct ttm_tt *ttm ;
   bool evicted ;
   atomic_t cpu_writers ;
   struct list_head lru ;
   struct list_head ddestroy ;
   struct list_head swap ;
   struct list_head io_reserve_lru ;
   uint32_t val_seq ;
   bool seq_valid ;
   atomic_t reserved ;
   void *sync_obj ;
   unsigned long priv_flags ;
   struct rb_node vm_rb ;
   struct drm_mm_node *vm_node ;
   unsigned long offset ;
   uint32_t cur_placement ;
   struct sg_table *sg ;
};
#line 741 "include/drm/ttm/ttm_bo_api.h"
struct ttm_mem_shrink {
   int (*do_shrink)(struct ttm_mem_shrink * ) ;
};
#line 52 "include/drm/ttm/ttm_memory.h"
struct ttm_mem_zone;
#line 53 "include/drm/ttm/ttm_memory.h"
struct ttm_mem_global {
   struct kobject kobj ;
   struct ttm_mem_shrink *shrink ;
   struct workqueue_struct *swap_queue ;
   struct work_struct work ;
   spinlock_t lock ;
   struct ttm_mem_zone *zones[2U] ;
   unsigned int num_zones ;
   struct ttm_mem_zone *zone_kernel ;
   struct ttm_mem_zone *zone_dma32 ;
};
#line 39 "include/drm/ttm/ttm_module.h"
struct ttm_backend_func {
   int (*bind)(struct ttm_tt * , struct ttm_mem_reg * ) ;
   int (*unbind)(struct ttm_tt * ) ;
   void (*destroy)(struct ttm_tt * ) ;
};
#line 76 "include/drm/ttm/ttm_bo_driver.h"
enum ttm_caching_state {
    tt_uncached = 0,
    tt_wc = 1,
    tt_cached = 2
} ;
#line 88 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_tt {
   struct ttm_bo_device *bdev ;
   struct ttm_backend_func *func ;
   struct page *dummy_read_page ;
   struct page **pages ;
   uint32_t page_flags ;
   unsigned long num_pages ;
   struct sg_table *sg ;
   struct ttm_bo_global *glob ;
   struct file *swap_storage ;
   enum ttm_caching_state caching_state ;
   int state ;
};
#line 145
struct ttm_mem_type_manager;
#line 146 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_mem_type_manager_func {
   int (*init)(struct ttm_mem_type_manager * , unsigned long  ) ;
   int (*takedown)(struct ttm_mem_type_manager * ) ;
   int (*get_node)(struct ttm_mem_type_manager * , struct ttm_buffer_object * , struct ttm_placement * ,
                   struct ttm_mem_reg * ) ;
   void (*put_node)(struct ttm_mem_type_manager * , struct ttm_mem_reg * ) ;
   void (*debug)(struct ttm_mem_type_manager * , char const   * ) ;
};
#line 233 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_mem_type_manager {
   struct ttm_bo_device *bdev ;
   bool has_type ;
   bool use_type ;
   uint32_t flags ;
   unsigned long gpu_offset ;
   uint64_t size ;
   uint32_t available_caching ;
   uint32_t default_caching ;
   struct ttm_mem_type_manager_func  const  *func ;
   void *priv ;
   struct mutex io_reserve_mutex ;
   bool use_io_reserve_lru ;
   bool io_reserve_fastpath ;
   struct list_head io_reserve_lru ;
   struct list_head lru ;
};
#line 296 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_driver {
   struct ttm_tt *(*ttm_tt_create)(struct ttm_bo_device * , unsigned long  , uint32_t  ,
                                   struct page * ) ;
   int (*ttm_tt_populate)(struct ttm_tt * ) ;
   void (*ttm_tt_unpopulate)(struct ttm_tt * ) ;
   int (*invalidate_caches)(struct ttm_bo_device * , uint32_t  ) ;
   int (*init_mem_type)(struct ttm_bo_device * , uint32_t  , struct ttm_mem_type_manager * ) ;
   void (*evict_flags)(struct ttm_buffer_object * , struct ttm_placement * ) ;
   int (*move)(struct ttm_buffer_object * , bool  , bool  , bool  , struct ttm_mem_reg * ) ;
   int (*verify_access)(struct ttm_buffer_object * , struct file * ) ;
   bool (*sync_obj_signaled)(void * ) ;
   int (*sync_obj_wait)(void * , bool  , bool  ) ;
   int (*sync_obj_flush)(void * ) ;
   void (*sync_obj_unref)(void ** ) ;
   void *(*sync_obj_ref)(void * ) ;
   void (*move_notify)(struct ttm_buffer_object * , struct ttm_mem_reg * ) ;
   int (*fault_reserve_notify)(struct ttm_buffer_object * ) ;
   void (*swap_notify)(struct ttm_buffer_object * ) ;
   int (*io_mem_reserve)(struct ttm_bo_device * , struct ttm_mem_reg * ) ;
   void (*io_mem_free)(struct ttm_bo_device * , struct ttm_mem_reg * ) ;
};
#line 454 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_global_ref {
   struct drm_global_reference ref ;
   struct ttm_mem_global *mem_glob ;
};
#line 463 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_global {
   struct kobject kobj ;
   struct ttm_mem_global *mem_glob ;
   struct page *dummy_read_page ;
   struct ttm_mem_shrink shrink ;
   struct mutex device_list_mutex ;
   spinlock_t lru_lock ;
   struct list_head device_list ;
   struct list_head swap_lru ;
   atomic_t bo_count ;
};
#line 506 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_bo_device {
   struct list_head device_list ;
   struct ttm_bo_global *glob ;
   struct ttm_bo_driver *driver ;
   rwlock_t vm_lock ;
   struct ttm_mem_type_manager man[8U] ;
   spinlock_t fence_lock ;
   struct rb_root addr_space_rb ;
   struct drm_mm addr_space_mm ;
   struct list_head ddestroy ;
   uint32_t val_seq ;
   struct address_space *dev_mapping ;
   struct delayed_work wq ;
   bool need_dma32 ;
};
#line 1009
enum ttm_ref_type {
    TTM_REF_USAGE = 0,
    TTM_REF_SYNCCPU_READ = 1,
    TTM_REF_SYNCCPU_WRITE = 2,
    TTM_REF_NUM = 3
} ;
#line 1016
enum ttm_object_type {
    ttm_fence_type = 0,
    ttm_buffer_type = 1,
    ttm_lock_type = 2,
    ttm_driver_type0 = 256,
    ttm_driver_type1 = 257,
    ttm_driver_type2 = 258,
    ttm_driver_type3 = 259,
    ttm_driver_type4 = 260,
    ttm_driver_type5 = 261
} ;
#line 1028
struct ttm_object_file;
#line 1029
struct ttm_object_device;
#line 1030 "include/drm/ttm/ttm_bo_driver.h"
struct ttm_base_object {
   struct callback_head rhead ;
   struct drm_hash_item hash ;
   enum ttm_object_type object_type ;
   bool shareable ;
   struct ttm_object_file *tfile ;
   struct kref refcount ;
   void (*refcount_release)(struct ttm_base_object ** ) ;
   void (*ref_obj_release)(struct ttm_base_object * , enum ttm_ref_type  ) ;
};
#line 272 "include/drm/ttm/ttm_object.h"
struct ttm_lock {
   struct ttm_base_object base ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
   int32_t rw ;
   uint32_t flags ;
   bool kill_takers ;
   int signal ;
   struct ttm_object_file *vt_holder ;
};
#line 246 "include/drm/ttm/ttm_lock.h"
struct ttm_validate_buffer {
   struct list_head head ;
   struct ttm_buffer_object *bo ;
   bool reserved ;
   bool removed ;
   int put_count ;
   void *old_sync_obj ;
};
#line 108 "include/drm/ttm/ttm_execbuf_util.h"
struct vmw_private;
#line 109
struct vmw_fence_manager;
#line 51 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_obj {
   struct kref kref ;
   u32 seqno ;
   struct vmw_fence_manager *fman ;
   struct list_head head ;
   uint32_t signaled ;
   uint32_t signal_mask ;
   struct list_head seq_passed_actions ;
   void (*destroy)(struct vmw_fence_obj * ) ;
   wait_queue_head_t queue ;
};
#line 115 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fpriv {
   struct drm_master *locked_master ;
   struct ttm_object_file *tfile ;
   struct list_head fence_events ;
};
#line 67 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_dma_buffer {
   struct ttm_buffer_object base ;
   struct list_head res_list ;
};
#line 72 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_validate_buffer {
   struct ttm_validate_buffer base ;
   struct drm_hash_item hash ;
};
#line 86
struct vmw_res_func;
#line 87 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource {
   struct kref kref ;
   struct vmw_private *dev_priv ;
   int id ;
   bool avail ;
   unsigned long backup_size ;
   bool res_dirty ;
   bool backup_dirty ;
   struct vmw_dma_buffer *backup ;
   unsigned long backup_offset ;
   struct vmw_res_func  const  *func ;
   struct list_head lru_head ;
   struct list_head mob_head ;
   void (*res_free)(struct vmw_resource * ) ;
   void (*hw_destroy)(struct vmw_resource * ) ;
};
#line 104
enum vmw_res_type {
    vmw_res_context = 0,
    vmw_res_surface = 1,
    vmw_res_stream = 2,
    vmw_res_max = 3
} ;
#line 111 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_cursor_snooper {
   struct drm_crtc *crtc ;
   size_t age ;
   uint32_t *image ;
};
#line 118
struct vmw_surface_offset;
#line 119 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_surface {
   struct vmw_resource res ;
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6U] ;
   struct drm_vmw_size base_size ;
   struct drm_vmw_size *sizes ;
   uint32_t num_sizes ;
   bool scanout ;
   struct vmw_cursor_snooper snooper ;
   struct vmw_surface_offset *offsets ;
   SVGA3dTextureFilter autogen_filter ;
   uint32_t multisample_count ;
};
#line 136 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_marker_queue {
   struct list_head head ;
   struct timespec lag ;
   struct timespec lag_time ;
   spinlock_t lock ;
};
#line 143 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fifo_state {
   unsigned long reserved_size ;
   __le32 *dynamic_buffer ;
   __le32 *static_buffer ;
   unsigned long static_buffer_size ;
   bool using_bounce_buffer ;
   uint32_t capabilities ;
   struct mutex fifo_mutex ;
   struct rw_semaphore rwsem ;
   struct vmw_marker_queue marker_queue ;
};
#line 155 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_relocation {
   SVGAGuestPtr *location ;
   uint32_t index ;
};
#line 160
struct vmw_resource_val_node;
#line 160 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_res_cache_entry {
   bool valid ;
   uint32_t handle ;
   struct vmw_resource *res ;
   struct vmw_resource_val_node *node ;
};
#line 179 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_sw_context {
   struct drm_open_hash res_ht ;
   bool res_ht_initialized ;
   bool kernel ;
   struct ttm_object_file *tfile ;
   struct list_head validate_nodes ;
   struct vmw_relocation relocs[2048U] ;
   uint32_t cur_reloc ;
   struct vmw_validate_buffer val_bufs[2048U] ;
   uint32_t cur_val_buf ;
   uint32_t *cmd_bounce ;
   uint32_t cmd_bounce_size ;
   struct list_head resource_list ;
   uint32_t fence_flags ;
   struct ttm_buffer_object *cur_query_bo ;
   struct list_head res_relocations ;
   uint32_t *buf_start ;
   struct vmw_res_cache_entry res_cache[3U] ;
   struct vmw_resource *last_query_ctx ;
   bool needs_post_query_barrier ;
   struct vmw_resource *error_resource ;
};
#line 202
struct vmw_legacy_display;
#line 203
struct vmw_overlay;
#line 204 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_master {
   struct ttm_lock lock ;
   struct mutex fb_surf_mutex ;
   struct list_head fb_surf ;
};
#line 211 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_vga_topology_state {
   uint32_t width ;
   uint32_t height ;
   uint32_t primary ;
   uint32_t pos_x ;
   uint32_t pos_y ;
};
#line 219
struct vmw_screen_object_display;
#line 219 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_private {
   struct ttm_bo_device bdev ;
   struct ttm_bo_global_ref bo_global_ref ;
   struct drm_global_reference mem_global_ref ;
   struct vmw_fifo_state fifo ;
   struct drm_device *dev ;
   unsigned long vmw_chipset ;
   unsigned int io_start ;
   uint32_t vram_start ;
   uint32_t vram_size ;
   uint32_t mmio_start ;
   uint32_t mmio_size ;
   uint32_t fb_max_width ;
   uint32_t fb_max_height ;
   uint32_t initial_width ;
   uint32_t initial_height ;
   __le32 *mmio_virt ;
   int mmio_mtrr ;
   uint32_t capabilities ;
   uint32_t max_gmr_descriptors ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t memory_size ;
   bool has_gmr ;
   struct mutex hw_mutex ;
   struct vmw_vga_topology_state vga_save[16U] ;
   uint32_t vga_width ;
   uint32_t vga_height ;
   uint32_t vga_bpp ;
   uint32_t vga_bpl ;
   uint32_t vga_pitchlock ;
   uint32_t num_displays ;
   void *fb_info ;
   struct vmw_legacy_display *ldu_priv ;
   struct vmw_screen_object_display *sou_priv ;
   struct vmw_overlay *overlay_priv ;
   rwlock_t resource_lock ;
   struct idr res_idr[3U] ;
   struct mutex init_mutex ;
   struct ttm_object_device *tdev ;
   atomic_t marker_seq ;
   wait_queue_head_t fence_queue ;
   wait_queue_head_t fifo_queue ;
   int fence_queue_waiters ;
   int goal_queue_waiters ;
   atomic_t fifo_queue_waiters ;
   uint32_t last_read_seqno ;
   spinlock_t irq_lock ;
   struct vmw_fence_manager *fman ;
   uint32_t irq_mask ;
   uint32_t traces_state ;
   uint32_t enable_state ;
   uint32_t config_done_state ;
   struct vmw_sw_context ctx ;
   struct mutex cmdbuf_mutex ;
   bool stealth ;
   bool is_opened ;
   bool enable_fb ;
   struct vmw_master *active_master ;
   struct vmw_master fbdev_master ;
   struct notifier_block pm_nb ;
   bool suspended ;
   struct mutex release_mutex ;
   uint32_t num_3d_resources ;
   struct ttm_buffer_object *dummy_query_bo ;
   struct ttm_buffer_object *pinned_bo ;
   uint32_t query_cid ;
   uint32_t query_cid_valid ;
   bool dummy_query_bo_pinned ;
   struct list_head res_lru[3U] ;
   uint32_t used_memory_size ;
};
#line 413
struct vmw_user_resource_conv;
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource_relocation {
   struct list_head head ;
   struct vmw_resource  const  *res ;
   unsigned long offset ;
};
#line 200 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_resource_val_node {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct vmw_resource *res ;
   struct vmw_dma_buffer *new_backup ;
   unsigned long new_backup_offset ;
   bool first_usage ;
   bool no_buffer_needed ;
};
#line 588 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_cid_cmd {
   SVGA3dCmdHeader header ;
   __le32 cid ;
};
#line 602 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSetRenderTarget body ;
};
#line 623 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceCopy body ;
};
#line 644 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceStretchBlt body ;
};
#line 665 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 686 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_sid_cmd___3 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdPresent body ;
};
#line 895 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_begin_query_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBeginQuery q ;
};
#line 922 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_query_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdEndQuery q ;
};
#line 957 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_query_cmd___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery q ;
};
#line 984 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_dma_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA dma ;
};
#line 1017 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_draw_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDrawPrimitives body ;
};
#line 1112 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct __anonstruct_cmd_291 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1112 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct __anonstruct_294 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1135 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
struct vmw_set_shader_cmd {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSetShader body ;
};
#line 1196 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int (*vmw_cmd_func)(struct vmw_private * , struct vmw_sw_context * , SVGA3dCmdHeader * );
#line 1959 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int ldv_func_ret_type___2;
#line 2071 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
typedef int ldv_func_ret_type___13;
#line 233 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/special_insns.h"
struct exec_domain;
#line 26 "include/linux/personality.h"
struct map_segment;
#line 26 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 586 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
#line 586 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
#line 185 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
struct svga_guest_mem_descriptor {
   __le32 ppn ;
   __le32 num_pages ;
};
#line 1498 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDefineGMR2_45 {
   uint32 gmrId ;
   uint32 numPages ;
};
#line 1498 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDefineGMR2_45 SVGAFifoCmdDefineGMR2;
#line 1499
enum ldv_9094 {
    SVGA_REMAP_GMR2_PPN32 = 0,
    SVGA_REMAP_GMR2_VIA_GMR = 1,
    SVGA_REMAP_GMR2_PPN64 = 2,
    SVGA_REMAP_GMR2_SINGLE_PPN = 4
} ;
#line 1534 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef enum ldv_9094 SVGARemapGMR2Flags;
#line 1550 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdRemapGMR2_46 {
   uint32 gmrId ;
   SVGARemapGMR2Flags flags ;
   uint32 offsetPages ;
   uint32 numPages ;
};
#line 1550 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdRemapGMR2_46 SVGAFifoCmdRemapGMR2;
#line 66 "include/linux/miscdevice.h"
struct compat_timespec;
#line 67 "include/linux/miscdevice.h"
struct __anonstruct_futex_115 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 67 "include/linux/miscdevice.h"
struct __anonstruct_nanosleep_116 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 67
struct pollfd;
#line 67 "include/linux/miscdevice.h"
struct __anonstruct_poll_117 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 67 "include/linux/miscdevice.h"
union __anonunion_ldv_7780_114 {
   struct __anonstruct_futex_115 futex ;
   struct __anonstruct_nanosleep_116 nanosleep ;
   struct __anonstruct_poll_117 poll ;
};
#line 67 "include/linux/miscdevice.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion_ldv_7780_114 ldv_7780 ;
};
#line 52 "include/linux/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 18 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 45 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 108 "include/linux/agp_backend.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 278 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/drm_mode.h"
struct drm_mode_fb_cmd {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pitch ;
   __u32 bpp ;
   __u32 depth ;
   __u32 handle ;
};
#line 392 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGASignedPoint {
   int32 x ;
   int32 y ;
};
#line 397 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGASignedPoint SVGASignedPoint;
#line 1028 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdUpdate {
   uint32 x ;
   uint32 y ;
   uint32 width ;
   uint32 height ;
};
#line 1066 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdUpdate SVGAFifoCmdUpdate;
#line 1117 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdDefineAlphaCursor {
   uint32 id ;
   uint32 hotspotX ;
   uint32 hotspotY ;
   uint32 width ;
   uint32 height ;
};
#line 1140 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdDefineAlphaCursor SVGAFifoCmdDefineAlphaCursor;
#line 1368 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_214 {
   SVGASignedPoint srcOrigin ;
   SVGASignedRect destRect ;
   uint32 destScreenId ;
};
#line 1368 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdBlitGMRFBToScreen_214 SVGAFifoCmdBlitGMRFBToScreen;
#line 1416 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_215 {
   SVGASignedPoint destOrigin ;
   SVGASignedRect srcRect ;
   uint32 srcScreenId ;
};
#line 1416 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdBlitScreenToGMRFB_215 SVGAFifoCmdBlitScreenToGMRFB;
#line 69 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum SVGA3dSurfaceFormat {
    SVGA3D_FORMAT_INVALID = 0,
    SVGA3D_X8R8G8B8 = 1,
    SVGA3D_A8R8G8B8 = 2,
    SVGA3D_R5G6B5 = 3,
    SVGA3D_X1R5G5B5 = 4,
    SVGA3D_A1R5G5B5 = 5,
    SVGA3D_A4R4G4B4 = 6,
    SVGA3D_Z_D32 = 7,
    SVGA3D_Z_D16 = 8,
    SVGA3D_Z_D24S8 = 9,
    SVGA3D_Z_D15S1 = 10,
    SVGA3D_LUMINANCE8 = 11,
    SVGA3D_LUMINANCE4_ALPHA4 = 12,
    SVGA3D_LUMINANCE16 = 13,
    SVGA3D_LUMINANCE8_ALPHA8 = 14,
    SVGA3D_DXT1 = 15,
    SVGA3D_DXT2 = 16,
    SVGA3D_DXT3 = 17,
    SVGA3D_DXT4 = 18,
    SVGA3D_DXT5 = 19,
    SVGA3D_BUMPU8V8 = 20,
    SVGA3D_BUMPL6V5U5 = 21,
    SVGA3D_BUMPX8L8V8U8 = 22,
    SVGA3D_BUMPL8V8U8 = 23,
    SVGA3D_ARGB_S10E5 = 24,
    SVGA3D_ARGB_S23E8 = 25,
    SVGA3D_A2R10G10B10 = 26,
    SVGA3D_V8U8 = 27,
    SVGA3D_Q8W8V8U8 = 28,
    SVGA3D_CxV8U8 = 29,
    SVGA3D_X8L8V8U8 = 30,
    SVGA3D_A2W10V10U10 = 31,
    SVGA3D_ALPHA8 = 32,
    SVGA3D_R_S10E5 = 33,
    SVGA3D_R_S23E8 = 34,
    SVGA3D_RG_S10E5 = 35,
    SVGA3D_RG_S23E8 = 36,
    SVGA3D_BUFFER = 37,
    SVGA3D_Z_D24X8 = 38,
    SVGA3D_V16U16 = 39,
    SVGA3D_G16R16 = 40,
    SVGA3D_A16B16G16R16 = 41,
    SVGA3D_UYVY = 42,
    SVGA3D_YUY2 = 43,
    SVGA3D_NV12 = 44,
    SVGA3D_AYUV = 45,
    SVGA3D_BC4_UNORM = 108,
    SVGA3D_BC5_UNORM = 111,
    SVGA3D_Z_DF16 = 118,
    SVGA3D_Z_DF24 = 119,
    SVGA3D_Z_D24S8_INT = 120,
    SVGA3D_FORMAT_MAX = 121
} ;
#line 1239 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct SVGA3dCopyBox {
   uint32 x ;
   uint32 y ;
   uint32 z ;
   uint32 w ;
   uint32 h ;
   uint32 d ;
   uint32 srcx ;
   uint32 srcy ;
   uint32 srcz ;
};
#line 1251 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct SVGA3dCopyBox SVGA3dCopyBox;
#line 406 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_rect {
   int32_t x ;
   int32_t y ;
   uint32_t w ;
   uint32_t h ;
};
#line 470 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_cursor_bypass_arg {
   uint32_t flags ;
   uint32_t crtc_id ;
   int32_t xpos ;
   int32_t ypos ;
   int32_t xhot ;
   int32_t yhot ;
};
#line 766 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_update_layout_arg {
   uint32_t num_outputs ;
   uint32_t pad64 ;
   uint64_t rects ;
};
#line 283 "include/drm/ttm/ttm_bo_api.h"
struct ttm_bo_kmap_obj {
   void *virtual ;
   struct page *page ;
   int bo_kmap_type ;
   struct ttm_buffer_object *bo ;
};
#line 117 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_framebuffer;
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_framebuffer {
   struct drm_framebuffer base ;
   int (*pin)(struct vmw_framebuffer * ) ;
   int (*unpin)(struct vmw_framebuffer * ) ;
   bool dmabuf ;
   struct ttm_base_object *user_obj ;
   uint32_t user_handle ;
};
#line 71 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_display_unit {
   struct drm_crtc crtc ;
   struct drm_encoder encoder ;
   struct drm_connector connector ;
   struct vmw_surface *cursor_surface ;
   struct vmw_dma_buffer *cursor_dmabuf ;
   size_t cursor_age ;
   int cursor_x ;
   int cursor_y ;
   int hotspot_x ;
   int hotspot_y ;
   unsigned int unit ;
   unsigned int pref_width ;
   unsigned int pref_height ;
   bool pref_active ;
   struct drm_display_mode *pref_mode ;
   int gui_x ;
   int gui_y ;
   bool is_implicit ;
};
#line 163 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_clip_rect {
   int x1 ;
   int x2 ;
   int y1 ;
   int y2 ;
};
#line 247 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_291___0 {
   u32 cmd ;
   SVGAFifoCmdDefineAlphaCursor cursor ;
};
#line 254 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_293 {
   u32 cmd ;
   SVGAFifoCmdDefineAlphaCursor cursor ;
};
#line 538 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct vmw_framebuffer_surface {
   struct vmw_framebuffer base ;
   struct vmw_surface *surface ;
   struct vmw_dma_buffer *buffer ;
   struct list_head head ;
   struct drm_master *master ;
};
#line 593 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_295 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 613 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_297 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 872 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct vmw_framebuffer_dmabuf {
   struct vmw_framebuffer base ;
   struct vmw_dma_buffer *buffer ;
};
#line 909 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_299 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 912 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_301 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 942 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_303 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 952 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_305 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 992 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_blits_307 {
   uint32_t header ;
   SVGAFifoCmdBlitGMRFBToScreen body ;
};
#line 999 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_309 {
   uint32_t header ;
   SVGAFifoCmdBlitGMRFBToScreen body ;
};
#line 1357 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_311 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 1377 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_313 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdBlitSurfaceToScreen body ;
};
#line 1491 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_cmd_315 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1495 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_blits_317 {
   uint32_t header ;
   SVGAFifoCmdBlitScreenToGMRFB body ;
};
#line 1509 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_319 {
   uint32_t header ;
   SVGAFifoCmdDefineGMRFB body ;
};
#line 1524 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct __anonstruct_321 {
   uint32_t header ;
   SVGAFifoCmdBlitScreenToGMRFB body ;
};
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 153 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 195 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 214 "include/linux/kobject.h"
struct kernel_param;
#line 215 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 47 "include/linux/moduleparam.h"
struct kparam_string;
#line 47
struct kparam_array;
#line 47 "include/linux/moduleparam.h"
union __anonunion_ldv_14165_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 47 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_14165_134 ldv_14165 ;
};
#line 59 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 65 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 457 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 210 "include/linux/jump_label.h"
struct tracepoint;
#line 211 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 201
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 207 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 222
struct module_sect_attrs;
#line 222
struct module_notes_attrs;
#line 222
struct ftrace_event_call;
#line 222 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 72 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 983 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
enum ldv_27213 {
    SVGA3D_QUERYSTATE_PENDING = 0,
    SVGA3D_QUERYSTATE_SUCCEEDED = 1,
    SVGA3D_QUERYSTATE_FAILED = 2,
    SVGA3D_QUERYSTATE_NEW = 3
} ;
#line 989 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_27213 SVGA3dQueryState;
#line 1697 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
union __anonunion_ldv_38564_288 {
   uint32 result32 ;
};
#line 1697 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dQueryResult_287 {
   uint32 totalSize ;
   SVGA3dQueryState state ;
   union __anonunion_ldv_38564_288 ldv_38564 ;
};
#line 1697 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dQueryResult_287 SVGA3dQueryResult;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 322 "include/linux/kgdb.h"
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
#line 176 "include/uapi/linux/fb.h"
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
#line 192 "include/uapi/linux/fb.h"
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
#line 279 "include/uapi/linux/fb.h"
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
#line 335 "include/uapi/linux/fb.h"
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
#line 348 "include/uapi/linux/fb.h"
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
#line 357 "include/uapi/linux/fb.h"
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char const   *data ;
   struct fb_cmap cmap ;
};
#line 369 "include/uapi/linux/fb.h"
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
#line 385 "include/uapi/linux/fb.h"
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char const   *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
#line 399
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
#line 406
struct backlight_device;
#line 407
struct fb_info;
#line 408 "include/uapi/linux/fb.h"
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
#line 59 "include/linux/backlight.h"
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
#line 78 "include/linux/backlight.h"
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops  const  *ops ;
   struct notifier_block fb_notif ;
   struct device dev ;
};
#line 145 "include/linux/backlight.h"
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
#line 58 "include/linux/fb.h"
struct fb_videomode;
#line 58 "include/linux/fb.h"
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   unsigned char gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
#line 167 "include/linux/fb.h"
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
#line 178 "include/linux/fb.h"
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info * , void * , void * , unsigned int  ) ;
   void (*readio)(struct fb_info * , void * , void * , unsigned int  ) ;
};
#line 207 "include/linux/fb.h"
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info * ) ;
   void (*deferred_io)(struct fb_info * , struct list_head * ) ;
};
#line 218 "include/linux/fb.h"
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info * , int  ) ;
   int (*fb_release)(struct fb_info * , int  ) ;
   ssize_t (*fb_read)(struct fb_info * , char * , size_t  , loff_t * ) ;
   ssize_t (*fb_write)(struct fb_info * , char const   * , size_t  , loff_t * ) ;
   int (*fb_check_var)(struct fb_var_screeninfo * , struct fb_info * ) ;
   int (*fb_set_par)(struct fb_info * ) ;
   int (*fb_setcolreg)(unsigned int  , unsigned int  , unsigned int  , unsigned int  ,
                       unsigned int  , struct fb_info * ) ;
   int (*fb_setcmap)(struct fb_cmap * , struct fb_info * ) ;
   int (*fb_blank)(int  , struct fb_info * ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo * , struct fb_info * ) ;
   void (*fb_fillrect)(struct fb_info * , struct fb_fillrect  const  * ) ;
   void (*fb_copyarea)(struct fb_info * , struct fb_copyarea  const  * ) ;
   void (*fb_imageblit)(struct fb_info * , struct fb_image  const  * ) ;
   int (*fb_cursor)(struct fb_info * , struct fb_cursor * ) ;
   void (*fb_rotate)(struct fb_info * , int  ) ;
   int (*fb_sync)(struct fb_info * ) ;
   int (*fb_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_compat_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_mmap)(struct fb_info * , struct vm_area_struct * ) ;
   void (*fb_get_caps)(struct fb_info * , struct fb_blit_caps * , struct fb_var_screeninfo * ) ;
   void (*fb_destroy)(struct fb_info * ) ;
   int (*fb_debug_enter)(struct fb_info * ) ;
   int (*fb_debug_leave)(struct fb_info * ) ;
};
#line 306 "include/linux/fb.h"
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 const   *data ;
};
#line 322 "include/linux/fb.h"
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
#line 334 "include/linux/fb.h"
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
#line 343 "include/linux/fb.h"
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
#line 354 "include/linux/fb.h"
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
#line 363 "include/linux/fb.h"
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info * , struct fb_tilemap * ) ;
   void (*fb_tilecopy)(struct fb_info * , struct fb_tilearea * ) ;
   void (*fb_tilefill)(struct fb_info * , struct fb_tilerect * ) ;
   void (*fb_tileblit)(struct fb_info * , struct fb_tileblit * ) ;
   void (*fb_tilecursor)(struct fb_info * , struct fb_tilecursor * ) ;
   int (*fb_get_tilemax)(struct fb_info * ) ;
};
#line 382 "include/linux/fb.h"
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
#line 501 "include/linux/fb.h"
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
#line 502 "include/linux/fb.h"
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
};
#line 751 "include/linux/fb.h"
struct fb_videomode {
   char const   *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct __anonstruct_dirty_290 {
   spinlock_t lock ;
   bool active ;
   unsigned int x1 ;
   unsigned int y1 ;
   unsigned int x2 ;
   unsigned int y2 ;
};
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fb_par {
   struct vmw_private *vmw_priv ;
   void *vmalloc ;
   struct vmw_dma_buffer *vmw_bo ;
   struct ttm_bo_kmap_obj map ;
   u32 pseudo_palette[17U] ;
   unsigned int depth ;
   unsigned int bpp ;
   unsigned int max_width ;
   unsigned int max_height ;
   void *bo_ptr ;
   unsigned int bo_size ;
   bool bo_iowrite ;
   struct __anonstruct_dirty_290 dirty ;
};
#line 372 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct __anonstruct_cmd_292 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 399 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct __anonstruct_294___0 {
   uint32_t header ;
   SVGAFifoCmdUpdate body ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 1777 "include/drm/drmP.h"
struct drm_vmw_getparam_arg {
   uint64_t value ;
   uint32_t param ;
   uint32_t pad64 ;
};
#line 520 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_get_3d_cap_arg {
   uint64_t buffer ;
   uint32_t max_size ;
   uint32_t pad64 ;
};
#line 704 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_present_arg {
   uint32_t fb_id ;
   uint32_t sid ;
   int32_t dest_x ;
   int32_t dest_y ;
   uint64_t clips_ptr ;
   uint32_t num_clips ;
   uint32_t pad64 ;
};
#line 739 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_present_readback_arg {
   uint32_t fb_id ;
   uint32_t num_clips ;
   uint64_t clips_ptr ;
   uint64_t fence_rep ;
};
#line 654 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
typedef int ldv_func_ret_type___15;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 320 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_alloc_dmabuf_req {
   uint32_t size ;
   uint32_t pad64 ;
};
#line 351 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_dmabuf_rep {
   uint64_t map_handle ;
   uint32_t handle ;
   uint32_t cur_gmr_id ;
   uint32_t cur_gmr_offset ;
   uint32_t pad64 ;
};
#line 372 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
union drm_vmw_alloc_dmabuf_arg {
   struct drm_vmw_alloc_dmabuf_req req ;
   struct drm_vmw_dmabuf_rep rep ;
};
#line 386 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_unref_dmabuf_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
#line 501 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_stream_arg {
   uint32_t stream_id ;
   uint32_t pad64 ;
};
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_user_resource_conv {
   enum ttm_object_type object_type ;
   struct vmw_resource *(*base_obj_to_res)(struct ttm_base_object * ) ;
   void (*res_free)(struct vmw_resource * ) ;
};
#line 43 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct vmw_res_func {
   enum vmw_res_type res_type ;
   bool needs_backup ;
   char const   *type_name ;
   struct ttm_placement *backup_placement ;
   bool may_evict ;
   int (*create)(struct vmw_resource * ) ;
   int (*destroy)(struct vmw_resource * ) ;
   int (*bind)(struct vmw_resource * , struct ttm_validate_buffer * ) ;
   int (*unbind)(struct vmw_resource * , bool  , struct ttm_validate_buffer * ) ;
};
#line 83 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct vmw_user_dma_buffer {
   struct ttm_base_object base ;
   struct vmw_dma_buffer dma ;
};
#line 197 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_stream {
   struct vmw_resource res ;
   uint32_t stream_id ;
};
#line 202 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_user_stream {
   struct ttm_base_object base ;
   struct vmw_stream stream ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 294 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct vmw_ttm_tt {
   struct ttm_tt ttm ;
   struct vmw_private *dev_priv ;
   int gmr_id ;
};
#line 45 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_reg.h"
struct svga_fifo_cmd_fence {
   __le32 fence ;
};
#line 11 "include/linux/wait.h"
struct __wait_queue;
#line 11 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 14 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 695 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
struct __anonstruct_cmd_291___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery body ;
};
#line 697 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
struct __anonstruct_293___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdWaitForQuery body ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 163 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_legacy_display {
   struct list_head active ;
   unsigned int num_active ;
   unsigned int last_num_active ;
   struct vmw_framebuffer *fb ;
};
#line 199 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct vmw_legacy_display_unit {
   struct vmw_display_unit base ;
   struct list_head active ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 1210 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAFifoCmdEscape {
   uint32 nsid ;
   uint32 size ;
};
#line 1228 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAFifoCmdEscape SVGAFifoCmdEscape;
#line 432 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_control_stream_arg {
   uint32_t stream_id ;
   uint32_t enabled ;
   uint32_t flags ;
   uint32_t color_key ;
   uint32_t handle ;
   uint32_t offset ;
   int32_t format ;
   uint32_t size ;
   uint32_t width ;
   uint32_t height ;
   uint32_t pitch[3U] ;
   uint32_t pad64 ;
   struct drm_vmw_rect src ;
   struct drm_vmw_rect dst ;
};
#line 51 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct __anonstruct_header_290 {
   uint32 cmdType ;
   uint32 streamId ;
};
#line 51 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct __anonstruct_items_291 {
   uint32 registerId ;
   uint32 value ;
};
#line 51 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct SVGAEscapeVideoSetRegs {
   struct __anonstruct_header_290 header ;
   struct __anonstruct_items_291 items[1U] ;
};
#line 76 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
typedef struct SVGAEscapeVideoSetRegs SVGAEscapeVideoSetRegs;
#line 77 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
struct SVGAEscapeVideoFlush {
   uint32 cmdType ;
   uint32 streamId ;
};
#line 82 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_overlay.h"
typedef struct SVGAEscapeVideoFlush SVGAEscapeVideoFlush;
#line 88 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_escape.h"
struct vmw_stream___0 {
   struct vmw_dma_buffer *buf ;
   bool claimed ;
   bool paused ;
   struct drm_vmw_control_stream_arg saved ;
};
#line 198 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_overlay {
   struct mutex mutex ;
   struct vmw_stream___0 stream[1U] ;
};
#line 215 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_escape_header {
   uint32_t cmd ;
   SVGAFifoCmdEscape body ;
};
#line 220 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct vmw_escape_video_flush {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoFlush flush ;
};
#line 265 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_header_304 {
   uint32_t cmdType ;
   uint32_t streamId ;
};
#line 265 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_cmds_303 {
   struct vmw_escape_header escape ;
   struct __anonstruct_header_304 header ;
};
#line 269 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_items_306 {
   uint32_t registerId ;
   uint32_t value ;
};
#line 279 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_header_310 {
   uint32_t cmdType ;
   uint32_t streamId ;
};
#line 279 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_309___0 {
   struct vmw_escape_header escape ;
   struct __anonstruct_header_310 header ;
};
#line 284 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_312 {
   uint32_t registerId ;
   uint32_t value ;
};
#line 345 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_cmds_314 {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoSetRegs body ;
   struct vmw_escape_video_flush flush ;
};
#line 349 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
struct __anonstruct_316 {
   struct vmw_escape_header escape ;
   SVGAEscapeVideoSetRegs body ;
   struct vmw_escape_video_flush flush ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_marker {
   struct list_head head ;
   uint32_t seqno ;
   struct timespec submitted ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 116 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 133 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmwgfx_gmrid_man {
   spinlock_t lock ;
   struct ida gmr_ida ;
   uint32_t max_gmr_ids ;
   uint32_t max_gmr_pages ;
   uint32_t used_gmr_pages ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 552 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_wait_arg {
   uint32_t handle ;
   int32_t cookie_valid ;
   uint64_t kernel_cookie ;
   uint64_t timeout_us ;
   int32_t lazy ;
   int32_t flags ;
   int32_t wait_options ;
   int32_t pad64 ;
};
#line 608 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_signaled_arg {
   uint32_t handle ;
   uint32_t flags ;
   int32_t signaled ;
   uint32_t passed_seqno ;
   uint32_t signaled_flags ;
   uint32_t pad64 ;
};
#line 637 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_arg {
   uint32_t handle ;
   uint32_t pad64 ;
};
#line 659 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_event_fence {
   struct drm_event base ;
   uint64_t user_data ;
   uint32_t tv_sec ;
   uint32_t tv_usec ;
};
#line 682 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_fence_event_arg {
   uint64_t fence_rep ;
   uint64_t user_data ;
   uint32_t handle ;
   uint32_t flags ;
};
#line 110 "include/drm/ttm/ttm_execbuf_util.h"
enum vmw_action_type {
    VMW_ACTION_EVENT = 0,
    VMW_ACTION_MAX = 1
} ;
#line 115 "include/drm/ttm/ttm_execbuf_util.h"
struct vmw_fence_action {
   struct list_head head ;
   enum vmw_action_type type ;
   void (*seq_passed)(struct vmw_fence_action * ) ;
   void (*cleanup)(struct vmw_fence_action * ) ;
};
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_fence_manager {
   int num_fence_objects ;
   struct vmw_private *dev_priv ;
   spinlock_t lock ;
   struct list_head fence_list ;
   struct work_struct work ;
   u32 user_fence_size ;
   u32 fence_size ;
   u32 event_fence_action_size ;
   bool fifo_down ;
   struct list_head cleanup_list ;
   uint32_t pending_actions[1U] ;
   struct mutex goal_irq_mutex ;
   bool goal_irq_on ;
   bool seqno_valid ;
};
#line 201 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_user_fence {
   struct ttm_base_object base ;
   struct vmw_fence_obj fence ;
};
#line 207 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_event_fence_action {
   struct vmw_fence_action action ;
   struct list_head fpriv_head ;
   struct drm_pending_event *event ;
   struct vmw_fence_obj *fence ;
   struct drm_device *dev ;
   uint32_t *tv_sec ;
   uint32_t *tv_usec ;
};
#line 1142 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_event_fence_pending {
   struct drm_pending_event base ;
   struct drm_vmw_event_fence event ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 326 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAGuestImage {
   SVGAGuestPtr ptr ;
   uint32 pitch ;
};
#line 347 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAGuestImage SVGAGuestImage;
#line 908 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_size_208 {
   uint32 width ;
   uint32 height ;
};
#line 908 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_root_209 {
   int32 x ;
   int32 y ;
};
#line 908 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct SVGAScreenObject {
   uint32 structSize ;
   uint32 id ;
   uint32 flags ;
   struct __anonstruct_size_208 size ;
   struct __anonstruct_root_209 root ;
   SVGAGuestImage backingStore ;
   uint32 cloneCount ;
};
#line 987 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct SVGAScreenObject SVGAScreenObject;
#line 1276 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
struct __anonstruct_SVGAFifoCmdDestroyScreen_212 {
   uint32 screenId ;
};
#line 1276 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_reg.h"
typedef struct __anonstruct_SVGAFifoCmdDestroyScreen_212 SVGAFifoCmdDestroyScreen;
#line 163 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
struct vmw_screen_object_display {
   unsigned int num_implicit ;
   struct vmw_framebuffer *implicit_fb ;
};
#line 196 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct vmw_screen_object_unit {
   struct vmw_display_unit base ;
   unsigned long buffer_size ;
   struct vmw_dma_buffer *buffer ;
   bool defined ;
   bool active_implicit ;
};
#line 268 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_294 {
   uint32_t cmdType ;
};
#line 268 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_cmd_293 {
   struct __anonstruct_header_294 header ;
   SVGAScreenObject obj ;
};
#line 273 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_298 {
   uint32_t cmdType ;
};
#line 273 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_297___0 {
   struct __anonstruct_header_298 header ;
   SVGAScreenObject obj ;
};
#line 321 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_303 {
   uint32_t cmdType ;
};
#line 321 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_cmd_302 {
   struct __anonstruct_header_303 header ;
   SVGAFifoCmdDestroyScreen body ;
};
#line 328 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_header_307 {
   uint32_t cmdType ;
};
#line 328 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct __anonstruct_306 {
   struct __anonstruct_header_307 header ;
   SVGAFifoCmdDestroyScreen body ;
};
#line 1213 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDefineContext_66 {
   uint32 cid ;
};
#line 1213 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDefineContext_66 SVGA3dCmdDefineContext;
#line 1218 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDestroyContext_67 {
   uint32 cid ;
};
#line 1218 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDestroyContext_67 SVGA3dCmdDestroyContext;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 93 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_context_arg {
   int32_t cid ;
   uint32_t pad64 ;
};
#line 83 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct vmw_user_context {
   struct ttm_base_object base ;
   struct vmw_resource res ;
};
#line 229 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct __anonstruct_cmd_291___2 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroyContext body ;
};
#line 233 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct __anonstruct_293___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroyContext body ;
};
#line 257 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct __anonstruct_cmd_295___0 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineContext body ;
};
#line 273 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct __anonstruct_297___1 {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineContext body ;
};
#line 41 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga_types.h"
typedef uint8_t uint8;
#line 171 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum SVGA3dSurfaceFormat SVGA3dSurfaceFormat;
#line 1136 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSize_61 {
   uint32 width ;
   uint32 height ;
   uint32 depth ;
};
#line 1136 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSize_61 SVGA3dSize;
#line 1137
enum ldv_9212 {
    SVGA3D_SURFACE_CUBEMAP = 1,
    SVGA3D_SURFACE_HINT_STATIC = 2,
    SVGA3D_SURFACE_HINT_DYNAMIC = 4,
    SVGA3D_SURFACE_HINT_INDEXBUFFER = 8,
    SVGA3D_SURFACE_HINT_VERTEXBUFFER = 16,
    SVGA3D_SURFACE_HINT_TEXTURE = 32,
    SVGA3D_SURFACE_HINT_RENDERTARGET = 64,
    SVGA3D_SURFACE_HINT_DEPTHSTENCIL = 128,
    SVGA3D_SURFACE_HINT_WRITEONLY = 256,
    SVGA3D_SURFACE_MASKABLE_ANTIALIAS = 512,
    SVGA3D_SURFACE_AUTOGENMIPMAPS = 1024
} ;
#line 1150 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef enum ldv_9212 SVGA3dSurfaceFlags;
#line 1155 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSurfaceFace_62 {
   uint32 numMipLevels ;
};
#line 1155 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSurfaceFace_62 SVGA3dSurfaceFace;
#line 1178 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDefineSurface_63 {
   uint32 sid ;
   SVGA3dSurfaceFlags surfaceFlags ;
   SVGA3dSurfaceFormat format ;
   SVGA3dSurfaceFace face[6U] ;
};
#line 1178 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDefineSurface_63 SVGA3dCmdDefineSurface;
#line 1208 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdDestroySurface_65 {
   uint32 sid ;
};
#line 1208 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdDestroySurface_65 SVGA3dCmdDestroySurface;
#line 1360 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dSurfaceDMAFlags_80 {
   unsigned char discard : 1 ;
   unsigned char unsynchronized : 1 ;
   unsigned int reserved : 30 ;
};
#line 1360 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dSurfaceDMAFlags_80 SVGA3dSurfaceDMAFlags;
#line 1412 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_82 {
   uint32 suffixSize ;
   uint32 maximumOffset ;
   SVGA3dSurfaceDMAFlags flags ;
};
#line 1412 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_reg.h"
typedef struct __anonstruct_SVGA3dCmdSurfaceDMASuffix_82 SVGA3dCmdSurfaceDMASuffix;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 115 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_surface_create_req {
   uint32_t flags ;
   uint32_t format ;
   uint32_t mip_levels[6U] ;
   uint64_t size_addr ;
   int32_t shareable ;
   int32_t scanout ;
};
#line 162 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
struct drm_vmw_surface_arg {
   int32_t sid ;
   uint32_t pad64 ;
};
#line 195 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
union drm_vmw_surface_create_arg {
   struct drm_vmw_surface_arg rep ;
   struct drm_vmw_surface_create_req req ;
};
#line 209 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/drm/vmwgfx_drm.h"
union drm_vmw_surface_reference_arg {
   struct drm_vmw_surface_create_req rep ;
   struct drm_vmw_surface_arg req ;
};
#line 83 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
enum svga3d_block_desc {
    SVGA3DBLOCKDESC_NONE = 0,
    SVGA3DBLOCKDESC_BLUE = 1,
    SVGA3DBLOCKDESC_U = 1,
    SVGA3DBLOCKDESC_UV_VIDEO = 128,
    SVGA3DBLOCKDESC_GREEN = 2,
    SVGA3DBLOCKDESC_V = 2,
    SVGA3DBLOCKDESC_STENCIL = 2,
    SVGA3DBLOCKDESC_RED = 4,
    SVGA3DBLOCKDESC_W = 4,
    SVGA3DBLOCKDESC_LUMINANCE = 4,
    SVGA3DBLOCKDESC_Y = 4,
    SVGA3DBLOCKDESC_DEPTH = 4,
    SVGA3DBLOCKDESC_ALPHA = 8,
    SVGA3DBLOCKDESC_Q = 8,
    SVGA3DBLOCKDESC_BUFFER = 16,
    SVGA3DBLOCKDESC_COMPRESSED = 32,
    SVGA3DBLOCKDESC_IEEE_FP = 64,
    SVGA3DBLOCKDESC_PLANAR_YUV = 256,
    SVGA3DBLOCKDESC_U_VIDEO = 512,
    SVGA3DBLOCKDESC_V_VIDEO = 1024,
    SVGA3DBLOCKDESC_EXP = 2048,
    SVGA3DBLOCKDESC_SRGB = 4096,
    SVGA3DBLOCKDESC_2PLANAR_YUV = 8192,
    SVGA3DBLOCKDESC_3PLANAR_YUV = 16384,
    SVGA3DBLOCKDESC_RG = 6,
    SVGA3DBLOCKDESC_RGB = 7,
    SVGA3DBLOCKDESC_RGB_SRGB = 4103,
    SVGA3DBLOCKDESC_RGBA = 15,
    SVGA3DBLOCKDESC_RGBA_SRGB = 4111,
    SVGA3DBLOCKDESC_UV = 3,
    SVGA3DBLOCKDESC_UVL = 7,
    SVGA3DBLOCKDESC_UVW = 7,
    SVGA3DBLOCKDESC_UVWA = 15,
    SVGA3DBLOCKDESC_UVWQ = 15,
    SVGA3DBLOCKDESC_LA = 12,
    SVGA3DBLOCKDESC_R_FP = 68,
    SVGA3DBLOCKDESC_RG_FP = 70,
    SVGA3DBLOCKDESC_RGB_FP = 71,
    SVGA3DBLOCKDESC_RGBA_FP = 79,
    SVGA3DBLOCKDESC_DS = 6,
    SVGA3DBLOCKDESC_YUV = 132,
    SVGA3DBLOCKDESC_AYUV = 1548,
    SVGA3DBLOCKDESC_RGBE = 2055,
    SVGA3DBLOCKDESC_COMPRESSED_SRGB = 4128,
    SVGA3DBLOCKDESC_NV12 = 8448,
    SVGA3DBLOCKDESC_YV12 = 16640
} ;
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40675_292 {
   uint8 blue ;
   uint8 u ;
   uint8 uv_video ;
   uint8 u_video ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40681_293 {
   uint8 green ;
   uint8 v ;
   uint8 stencil ;
   uint8 v_video ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40689_294 {
   uint8 red ;
   uint8 w ;
   uint8 luminance ;
   uint8 y ;
   uint8 depth ;
   uint8 data ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40694_295 {
   uint8 alpha ;
   uint8 q ;
   uint8 exp ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct __anonstruct_ldv_40695_291 {
   union __anonunion_ldv_40675_292 ldv_40675 ;
   union __anonunion_ldv_40681_293 ldv_40681 ;
   union __anonunion_ldv_40689_294 ldv_40689 ;
   union __anonunion_ldv_40694_295 ldv_40694 ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct __anonstruct_bit_depth_290 {
   u32 total ;
   struct __anonstruct_ldv_40695_291 ldv_40695 ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40704_298 {
   uint8 blue ;
   uint8 u ;
   uint8 uv_video ;
   uint8 u_video ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40710_299 {
   uint8 green ;
   uint8 v ;
   uint8 stencil ;
   uint8 v_video ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40718_300 {
   uint8 red ;
   uint8 w ;
   uint8 luminance ;
   uint8 y ;
   uint8 depth ;
   uint8 data ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
union __anonunion_ldv_40723_301 {
   uint8 alpha ;
   uint8 q ;
   uint8 exp ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct __anonstruct_ldv_40724_297 {
   union __anonunion_ldv_40704_298 ldv_40704 ;
   union __anonunion_ldv_40710_299 ldv_40710 ;
   union __anonunion_ldv_40718_300 ldv_40718 ;
   union __anonunion_ldv_40723_301 ldv_40723 ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct __anonstruct_bit_offset_296 {
   struct __anonstruct_ldv_40724_297 ldv_40724 ;
};
#line 132 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
struct svga3d_surface_desc {
   enum svga3d_block_desc block_desc ;
   struct drm_vmw_size block_size ;
   u32 bytes_per_block ;
   u32 pitch_bytes_per_block ;
   struct __anonstruct_bit_depth_290 bit_depth ;
   struct __anonstruct_bit_offset_296 bit_offset ;
};
#line 910 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
struct vmw_user_surface {
   struct ttm_base_object base ;
   struct vmw_surface srf ;
   uint32_t size ;
   uint32_t backup_handle ;
};
#line 199 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_surface_offset {
   uint32_t face ;
   uint32_t mip ;
   uint32_t bo_offset ;
};
#line 247 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_surface_dma {
   SVGA3dCmdHeader header ;
   SVGA3dCmdSurfaceDMA body ;
   SVGA3dCopyBox cb ;
   SVGA3dCmdSurfaceDMASuffix suffix ;
};
#line 258 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_surface_define {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDefineSurface body ;
};
#line 266 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_surface_destroy {
   SVGA3dCmdHeader header ;
   SVGA3dCmdDestroySurface body ;
};
#line 1 "<compiler builtins>"
#line 1
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 119 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 177
extern void dump_stack(void) ;
#line 197 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 112
extern void list_del(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 273 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;

  {
#line 277
  first = list->next;
#line 278
  last = list->prev;
#line 280
  first->prev = prev;
#line 281
  prev->next = first;
#line 283
  last->next = next;
#line 284
  next->prev = last;
#line 285
  return;
}
}
#line 318 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
#line 321
  tmp = list_empty((struct list_head  const  *)list);
#line 321
  if (tmp == 0) {
#line 322
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 323
    INIT_LIST_HEAD(list);
  } else {

  }
#line 325
  return;
}
}
#line 55 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 71
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 23 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 

  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 93 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 

  {
#line 95
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 168 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 171
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) ;
#line 173
extern void mutex_unlock(struct mutex * ) ;
#line 176
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) ;
#line 5 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
extern int mutex_lock_interruptible(struct mutex * ) ;
#line 8
int ldv_mutex_lock_interruptible_15(struct mutex *ldv_func_arg1 ) ;
#line 11
extern void mutex_lock(struct mutex * ) ;
#line 14
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1 ) ;
#line 40
int ldv_mutex_lock_interruptible_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) ;
#line 43
void ldv_mutex_lock_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) ;
#line 47
void ldv_mutex_unlock_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) ;
#line 51
void ldv_mutex_lock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) ;
#line 55
void ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) ;
#line 91
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 95
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 103
void ldv_mutex_unlock_lock_of_fb_info(struct mutex *lock ) ;
#line 107
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 108
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 111
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 131
void ldv_mutex_lock_pm_mutex(struct mutex *lock ) ;
#line 135
void ldv_mutex_unlock_pm_mutex(struct mutex *lock ) ;
#line 147
void ldv_mutex_lock_struct_mutex_of_drm_device(struct mutex *lock ) ;
#line 151
void ldv_mutex_unlock_struct_mutex_of_drm_device(struct mutex *lock ) ;
#line 155
void ldv_mutex_lock_update_lock_of_backlight_device(struct mutex *lock ) ;
#line 159
void ldv_mutex_unlock_update_lock_of_backlight_device(struct mutex *lock ) ;
#line 210 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 54 "include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 66
extern void vfree(void const   * ) ;
#line 232 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 40 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
#line 42
  tmp = atomic_read((atomic_t const   *)(& kref->refcount));
#line 42
  __ret_warn_on = tmp == 0;
#line 42
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 42
  if (tmp___0 != 0L) {
#line 42
    warn_slowpath_null("include/linux/kref.h", 42);
  } else {

  }
#line 42
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 43
  atomic_inc(& kref->refcount);
#line 44
  return;
}
}
#line 224 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 274 "include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ void *tmp___2 ;

  {
#line 289
  tmp___2 = __kmalloc(size, flags);
#line 289
  return (tmp___2);
}
}
#line 422 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 424
  tmp = kmalloc(size, flags | 32768U);
#line 424
  return (tmp);
}
}
#line 49 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 51
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 55 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 59
  tmp = __builtin_object_size((void const   *)to, 0);
#line 59
  sz = (int )tmp;
#line 61
  might_fault();
#line 62
  tmp___1 = ldv__builtin_expect(sz == -1, 1L);
#line 62
  if (tmp___1 != 0L) {
#line 63
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 62
    tmp___2 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 62
    if (tmp___2 != 0L) {
#line 63
      n = _copy_from_user(to, from, (unsigned int )n);
    } else {
#line 66
      __ret_warn_on = 1;
#line 66
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 66
      if (tmp___0 != 0L) {
#line 66
        warn_slowpath_fmt("/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h",
                          66, "Buffer overflow detected!\n");
      } else {

      }
#line 66
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
    }
  }
#line 68
  return (n);
}
}
#line 72 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ unsigned long tmp ;

  {
#line 74
  might_fault();
#line 76
  tmp = _copy_to_user(dst, src, size);
#line 76
  return ((int )tmp);
}
}
#line 52 "include/drm/drm_hashtab.h"
extern int drm_ht_create(struct drm_open_hash * , unsigned int  ) ;
#line 53
extern int drm_ht_insert_item(struct drm_open_hash * , struct drm_hash_item * ) ;
#line 57
extern int drm_ht_find_item(struct drm_open_hash * , unsigned long  , struct drm_hash_item ** ) ;
#line 61
extern int drm_ht_remove_item(struct drm_open_hash * , struct drm_hash_item * ) ;
#line 134 "include/drm/drmP.h"
extern int drm_err(char const   * , char const   *  , ...) ;
#line 312 "include/drm/ttm/ttm_bo_api.h"
__inline static struct ttm_buffer_object *ttm_bo_reference(struct ttm_buffer_object *bo ) 
{ 

  {
#line 314
  kref_get(& bo->kref);
#line 315
  return (bo);
}
}
#line 350
extern int ttm_bo_validate(struct ttm_buffer_object * , struct ttm_placement * , bool  ,
                           bool  ) ;
#line 362
extern void ttm_bo_unref(struct ttm_buffer_object ** ) ;
#line 218 "include/drm/ttm/ttm_object.h"
extern int ttm_ref_object_base_unref(struct ttm_object_file * , unsigned long  , enum ttm_ref_type  ) ;
#line 96 "include/drm/ttm/ttm_lock.h"
extern void ttm_read_unlock(struct ttm_lock * ) ;
#line 108
extern int ttm_read_lock(struct ttm_lock * , bool  ) ;
#line 66 "include/drm/ttm/ttm_execbuf_util.h"
extern void ttm_eu_backoff_reservation(struct list_head * ) ;
#line 93
extern int ttm_eu_reserve_buffers(struct list_head * ) ;
#line 107
extern void ttm_eu_fence_buffer_objects(struct list_head * , void * ) ;
#line 70 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) ;
#line 80
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) ;
#line 86
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) ;
#line 91
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) ;
#line 364 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_surface *vmw_res_to_srf(struct vmw_resource *res ) 
{ struct vmw_resource  const  *__mptr ;

  {
#line 366
  __mptr = (struct vmw_resource  const  *)res;
#line 366
  return ((struct vmw_surface *)__mptr);
}
}
#line 369 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_private *vmw_priv(struct drm_device *dev ) 
{ 

  {
#line 371
  return ((struct vmw_private *)dev->dev_private);
}
}
#line 374 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_fpriv *vmw_fpriv(struct drm_file *file_priv ) 
{ 

  {
#line 376
  return ((struct vmw_fpriv *)file_priv->driver_priv);
}
}
#line 379 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_master *vmw_master(struct drm_master *master ) 
{ 

  {
#line 381
  return ((struct vmw_master *)master->driver_priv);
}
}
#line 418
struct vmw_user_resource_conv  const  *user_surface_converter ;
#line 419
struct vmw_user_resource_conv  const  *user_context_converter ;
#line 422
void vmw_resource_unreference(struct vmw_resource **p_res ) ;
#line 423
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) ;
#line 424
int vmw_resource_validate(struct vmw_resource *res ) ;
#line 425
int vmw_resource_reserve(struct vmw_resource *res , bool no_backup ) ;
#line 440
int vmw_user_resource_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                    uint32_t handle , struct vmw_user_resource_conv  const  *converter ,
                                    struct vmw_resource **p_res ) ;
#line 473
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) ;
#line 483
void vmw_resource_unreserve(struct vmw_resource *res , struct vmw_dma_buffer *new_backup ,
                            unsigned long new_backup_offset ) ;
#line 513
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) ;
#line 540
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) ;
#line 541
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) ;
#line 542
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) ;
#line 547
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) ;
#line 562
struct ttm_placement vmw_vram_placement ;
#line 565
struct ttm_placement vmw_vram_gmr_placement ;
#line 577
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 579
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) ;
#line 588
void __vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , struct vmw_fence_obj *fence ) ;
#line 590
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv ) ;
#line 592
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) ;
#line 596
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) ;
#line 617
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) ;
#line 623
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) ;
#line 641
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) ;
#line 663
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) ;
#line 664
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) ;
#line 745 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_dmabuf_unreference(struct vmw_dma_buffer **buf ) 
{ struct vmw_dma_buffer *tmp_buf ;
  struct ttm_buffer_object *bo ;

  {
#line 747
  tmp_buf = *buf;
#line 749
  *buf = 0;
#line 750
  if ((unsigned long )tmp_buf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 751
    bo = & tmp_buf->base;
#line 753
    ttm_bo_unref(& bo);
  } else {

  }
#line 755
  return;
}
}
#line 232 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_list_unreserve(struct list_head *list , bool backoff ) 
{ struct vmw_resource_val_node *val ;
  struct list_head  const  *__mptr ;
  struct vmw_resource *res ;
  struct vmw_dma_buffer *new_backup ;
  struct vmw_dma_buffer *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 237
  __mptr = (struct list_head  const  *)list->next;
#line 237
  val = (struct vmw_resource_val_node *)__mptr;
#line 237
  goto ldv_40614;
  ldv_40613: 
#line 238
  res = val->res;
#line 239
  if ((int )backoff) {
#line 239
    tmp = 0;
  } else {
#line 239
    tmp = val->new_backup;
  }
#line 239
  new_backup = tmp;
#line 242
  vmw_resource_unreserve(res, new_backup, val->new_backup_offset);
#line 244
  vmw_dmabuf_unreference(& val->new_backup);
#line 237
  __mptr___0 = (struct list_head  const  *)val->head.next;
#line 237
  val = (struct vmw_resource_val_node *)__mptr___0;
  ldv_40614: ;
#line 237
  if ((unsigned long )(& val->head) != (unsigned long )list) {
#line 238
    goto ldv_40613;
  } else {
#line 240
    goto ldv_40615;
  }
  ldv_40615: ;
#line 242
  return;
}
}
#line 258 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resource_val_add(struct vmw_sw_context *sw_context , struct vmw_resource *res ,
                                struct vmw_resource_val_node **p_node ) 
{ struct vmw_resource_val_node *node ;
  struct drm_hash_item *hash ;
  int ret ;
  struct drm_hash_item  const  *__mptr ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 266
  tmp___0 = drm_ht_find_item(& sw_context->res_ht, (unsigned long )res, & hash);
#line 266
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 1L);
#line 266
  if (tmp___1 != 0L) {
#line 268
    __mptr = (struct drm_hash_item  const  *)hash;
#line 268
    node = (struct vmw_resource_val_node *)__mptr + 0xfffffffffffffff0UL;
#line 269
    node->first_usage = 0;
#line 270
    tmp = ldv__builtin_expect((unsigned long )p_node != (unsigned long )((struct vmw_resource_val_node **)0),
                           0L);
#line 270
    if (tmp != 0L) {
#line 271
      *p_node = node;
    } else {

    }
#line 272
    return (0);
  } else {

  }
#line 275
  tmp___2 = kzalloc(72UL, 208U);
#line 275
  node = (struct vmw_resource_val_node *)tmp___2;
#line 276
  tmp___3 = ldv__builtin_expect((unsigned long )node == (unsigned long )((struct vmw_resource_val_node *)0),
                             0L);
#line 276
  if (tmp___3 != 0L) {
#line 277
    drm_err("vmw_resource_val_add", "Failed to allocate a resource validation entry.\n");
#line 279
    return (-12);
  } else {

  }
#line 282
  node->hash.key = (unsigned long )res;
#line 283
  ret = drm_ht_insert_item(& sw_context->res_ht, & node->hash);
#line 284
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 284
  if (tmp___4 != 0L) {
#line 285
    drm_err("vmw_resource_val_add", "Failed to initialize a resource validation entry.\n");
#line 287
    kfree((void const   *)node);
#line 288
    return (ret);
  } else {

  }
#line 290
  list_add_tail(& node->head, & sw_context->resource_list);
#line 291
  node->res = vmw_resource_reference(res);
#line 292
  node->first_usage = 1;
#line 294
  tmp___5 = ldv__builtin_expect((unsigned long )p_node != (unsigned long )((struct vmw_resource_val_node **)0),
                             0L);
#line 294
  if (tmp___5 != 0L) {
#line 295
    *p_node = node;
  } else {

  }
#line 297
  return (0);
}
}
#line 308 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resource_relocation_add(struct list_head *list , struct vmw_resource  const  *res ,
                                       unsigned long offset ) 
{ struct vmw_resource_relocation *rel ;
  void *tmp ;
  long tmp___0 ;

  {
#line 314
  tmp = kmalloc(32UL, 208U);
#line 314
  rel = (struct vmw_resource_relocation *)tmp;
#line 315
  tmp___0 = ldv__builtin_expect((unsigned long )rel == (unsigned long )((struct vmw_resource_relocation *)0),
                             0L);
#line 315
  if (tmp___0 != 0L) {
#line 316
    drm_err("vmw_resource_relocation_add", "Failed to allocate a resource relocation.\n");
#line 317
    return (-12);
  } else {

  }
#line 320
  rel->res = res;
#line 321
  rel->offset = offset;
#line 322
  list_add_tail(& rel->head, list);
#line 324
  return (0);
}
}
#line 332 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_relocations_free(struct list_head *list ) 
{ struct vmw_resource_relocation *rel ;
  struct vmw_resource_relocation *n ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 336
  __mptr = (struct list_head  const  *)list->next;
#line 336
  rel = (struct vmw_resource_relocation *)__mptr;
#line 336
  __mptr___0 = (struct list_head  const  *)rel->head.next;
#line 336
  n = (struct vmw_resource_relocation *)__mptr___0;
#line 336
  goto ldv_40646;
  ldv_40645: 
#line 337
  list_del(& rel->head);
#line 338
  kfree((void const   *)rel);
#line 336
  rel = n;
#line 336
  __mptr___1 = (struct list_head  const  *)n->head.next;
#line 336
  n = (struct vmw_resource_relocation *)__mptr___1;
  ldv_40646: ;
#line 336
  if ((unsigned long )(& rel->head) != (unsigned long )list) {
#line 337
    goto ldv_40645;
  } else {
#line 339
    goto ldv_40647;
  }
  ldv_40647: ;
#line 341
  return;
}
}
#line 351 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_relocations_apply(uint32_t *cb , struct list_head *list ) 
{ struct vmw_resource_relocation *rel ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 356
  __mptr = (struct list_head  const  *)list->next;
#line 356
  rel = (struct vmw_resource_relocation *)__mptr;
#line 356
  goto ldv_40658;
  ldv_40657: 
#line 357
  *(cb + rel->offset) = (uint32_t )(rel->res)->id;
#line 356
  __mptr___0 = (struct list_head  const  *)rel->head.next;
#line 356
  rel = (struct vmw_resource_relocation *)__mptr___0;
  ldv_40658: ;
#line 356
  if ((unsigned long )(& rel->head) != (unsigned long )list) {
#line 357
    goto ldv_40657;
  } else {
#line 359
    goto ldv_40659;
  }
  ldv_40659: ;
#line 361
  return;
}
}
#line 360 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_invalid(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                           SVGA3dCmdHeader *header ) 
{ bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 364
  tmp___2 = capable(21);
#line 364
  if ((int )tmp___2 != 0) {
#line 364
    tmp___0 = capable(21);
#line 364
    tmp___1 = (int )tmp___0;
  } else {
#line 364
    tmp___1 = -22;
  }
#line 364
  return (tmp___1);
}
}
#line 367 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_ok(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                      SVGA3dCmdHeader *header ) 
{ 

  {
#line 371
  return (0);
}
}
#line 385 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_bo_to_validate_list(struct vmw_sw_context *sw_context , struct ttm_buffer_object *bo ,
                                   uint32_t *p_val_node ) 
{ uint32_t val_node ;
  struct vmw_validate_buffer *vval_buf ;
  struct ttm_validate_buffer *val_buf ;
  struct drm_hash_item *hash ;
  int ret ;
  struct drm_hash_item  const  *__mptr ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 395
  tmp___1 = drm_ht_find_item(& sw_context->res_ht, (unsigned long )bo, & hash);
#line 395
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 1L);
#line 395
  if (tmp___2 != 0L) {
#line 397
    __mptr = (struct drm_hash_item  const  *)hash;
#line 397
    vval_buf = (struct vmw_validate_buffer *)__mptr + 0xffffffffffffffd8UL;
#line 399
    val_buf = & vval_buf->base;
#line 400
    val_node = (uint32_t )(((long )vval_buf - (long )(& sw_context->val_bufs)) / 64L);
  } else {
#line 402
    val_node = sw_context->cur_val_buf;
#line 403
    tmp = ldv__builtin_expect(val_node > 2047U, 0L);
#line 403
    if (tmp != 0L) {
#line 404
      drm_err("vmw_bo_to_validate_list", "Max number of DMA buffers per submission exceeded.\n");
#line 406
      return (-22);
    } else {

    }
#line 408
    vval_buf = (struct vmw_validate_buffer *)(& sw_context->val_bufs) + (unsigned long )val_node;
#line 409
    vval_buf->hash.key = (unsigned long )bo;
#line 410
    ret = drm_ht_insert_item(& sw_context->res_ht, & vval_buf->hash);
#line 411
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 411
    if (tmp___0 != 0L) {
#line 412
      drm_err("vmw_bo_to_validate_list", "Failed to initialize a buffer validation entry.\n");
#line 414
      return (ret);
    } else {

    }
#line 416
    sw_context->cur_val_buf = sw_context->cur_val_buf + 1U;
#line 417
    val_buf = & vval_buf->base;
#line 418
    val_buf->bo = ttm_bo_reference(bo);
#line 419
    val_buf->reserved = 0;
#line 420
    list_add_tail(& val_buf->head, & sw_context->validate_nodes);
  }
#line 423
  sw_context->fence_flags = sw_context->fence_flags | 1U;
#line 425
  if ((unsigned long )p_val_node != (unsigned long )((uint32_t *)0)) {
#line 426
    *p_val_node = val_node;
  } else {

  }
#line 428
  return (0);
}
}
#line 441 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resources_reserve(struct vmw_sw_context *sw_context ) 
{ struct vmw_resource_val_node *val ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct vmw_resource *res ;
  long tmp ;
  struct ttm_buffer_object *bo ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 446
  __mptr = (struct list_head  const  *)sw_context->resource_list.next;
#line 446
  val = (struct vmw_resource_val_node *)__mptr;
#line 446
  goto ldv_40695;
  ldv_40694: 
#line 447
  res = val->res;
#line 449
  ret = vmw_resource_reserve(res, (int )val->no_buffer_needed);
#line 450
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 450
  if (tmp != 0L) {
#line 451
    return (ret);
  } else {

  }
#line 453
  if ((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 454
    bo = & (res->backup)->base;
#line 456
    ret = vmw_bo_to_validate_list(sw_context, bo, 0);
#line 459
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 459
    if (tmp___0 != 0L) {
#line 460
      return (ret);
    } else {

    }
  } else {

  }
#line 446
  __mptr___0 = (struct list_head  const  *)val->head.next;
#line 446
  val = (struct vmw_resource_val_node *)__mptr___0;
  ldv_40695: ;
#line 446
  if ((unsigned long )(& val->head) != (unsigned long )(& sw_context->resource_list)) {
#line 447
    goto ldv_40694;
  } else {
#line 449
    goto ldv_40696;
  }
  ldv_40696: ;
#line 463
  return (0);
}
}
#line 475 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resources_validate(struct vmw_sw_context *sw_context ) 
{ struct vmw_resource_val_node *val ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct vmw_resource *res ;
  long tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 480
  __mptr = (struct list_head  const  *)sw_context->resource_list.next;
#line 480
  val = (struct vmw_resource_val_node *)__mptr;
#line 480
  goto ldv_40709;
  ldv_40708: 
#line 481
  res = val->res;
#line 483
  ret = vmw_resource_validate(res);
#line 484
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 484
  if (tmp != 0L) {
#line 485
    if (ret != -512) {
#line 486
      drm_err("vmw_resources_validate", "Failed to validate resource.\n");
    } else {

    }
#line 487
    return (ret);
  } else {

  }
#line 480
  __mptr___0 = (struct list_head  const  *)val->head.next;
#line 480
  val = (struct vmw_resource_val_node *)__mptr___0;
  ldv_40709: ;
#line 480
  if ((unsigned long )(& val->head) != (unsigned long )(& sw_context->resource_list)) {
#line 481
    goto ldv_40708;
  } else {
#line 483
    goto ldv_40710;
  }
  ldv_40710: ;
#line 490
  return (0);
}
}
#line 504 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_res_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             enum vmw_res_type res_type , struct vmw_user_resource_conv  const  *converter ,
                             uint32_t *id , struct vmw_resource_val_node **p_val ) 
{ struct vmw_res_cache_entry *rcache ;
  struct vmw_resource *res ;
  struct vmw_resource_val_node *node ;
  int ret ;
  struct vmw_resource  const  *res___0 ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 511
  rcache = (struct vmw_res_cache_entry *)(& sw_context->res_cache) + (unsigned long )res_type;
#line 517
  if (*id == 4294967295U) {
#line 518
    return (0);
  } else {

  }
#line 525
  tmp___0 = ldv__builtin_expect((long )rcache->valid, 1L);
#line 525
  if (tmp___0 != 0L) {
#line 525
    tmp___1 = ldv__builtin_expect(*id == rcache->handle, 1L);
#line 525
    if (tmp___1 != 0L) {
#line 526
      res___0 = (struct vmw_resource  const  *)rcache->res;
#line 528
      (rcache->node)->first_usage = 0;
#line 529
      if ((unsigned long )p_val != (unsigned long )((struct vmw_resource_val_node **)0)) {
#line 530
        *p_val = rcache->node;
      } else {

      }
#line 532
      tmp = vmw_resource_relocation_add(& sw_context->res_relocations, res___0, (unsigned long )(((long )id - (long )sw_context->buf_start) / 4L));
#line 532
      return (tmp);
    } else {

    }
  } else {

  }
#line 537
  ret = vmw_user_resource_lookup_handle(dev_priv, sw_context->tfile, *id, converter,
                                        & res);
#line 542
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 542
  if (tmp___2 != 0L) {
#line 543
    drm_err("vmw_cmd_res_check", "Could not find or use resource 0x%08x.\n", *id);
#line 545
    dump_stack();
#line 546
    return (ret);
  } else {

  }
#line 549
  rcache->valid = 1;
#line 550
  rcache->res = res;
#line 551
  rcache->handle = *id;
#line 553
  ret = vmw_resource_relocation_add(& sw_context->res_relocations, (struct vmw_resource  const  *)res,
                                    (unsigned long )(((long )id - (long )sw_context->buf_start) / 4L));
#line 556
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 556
  if (tmp___3 != 0L) {
#line 557
    goto out_no_reloc;
  } else {

  }
#line 559
  ret = vmw_resource_val_add(sw_context, res, & node);
#line 560
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 560
  if (tmp___4 != 0L) {
#line 561
    goto out_no_reloc;
  } else {

  }
#line 563
  rcache->node = node;
#line 564
  if ((unsigned long )p_val != (unsigned long )((struct vmw_resource_val_node **)0)) {
#line 565
    *p_val = node;
  } else {

  }
#line 566
  vmw_resource_unreference(& res);
#line 567
  return (0);
  out_no_reloc: 
#line 570
  tmp___5 = ldv__builtin_expect((unsigned long )sw_context->error_resource != (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 570
  if (tmp___5 != 0L) {
#line 570
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                         "i" (570), "i" (12UL));
    ldv_40726: ;
#line 570
    goto ldv_40726;
  } else {

  }
#line 571
  sw_context->error_resource = res;
#line 573
  return (ret);
}
}
#line 586 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_cid_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ struct vmw_cid_cmd *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  int tmp ;

  {
#line 595
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 595
  cmd = (struct vmw_cid_cmd *)__mptr;
#line 596
  tmp = vmw_cmd_res_check(dev_priv, sw_context, 0, user_context_converter, & cmd->cid,
                          0);
#line 596
  return (tmp);
}
}
#line 600 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_set_render_target_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                           SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd *cmd ;
  int ret ;
  long tmp ;
  SVGA3dCmdHeader const   *__mptr ;

  {
#line 610
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 611
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 611
  if (tmp != 0L) {
#line 612
    return (ret);
  } else {

  }
#line 614
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 614
  cmd = (struct vmw_sid_cmd *)__mptr;
#line 615
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.target.sid,
                          0);
#line 618
  return (ret);
}
}
#line 621 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_surface_copy_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___0 *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 631
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 631
  cmd = (struct vmw_sid_cmd___0 *)__mptr;
#line 632
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.src.sid,
                          0);
#line 635
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 635
  if (tmp != 0L) {
#line 636
    return (ret);
  } else {

  }
#line 637
  tmp___0 = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.dest.sid,
                              0);
#line 637
  return (tmp___0);
}
}
#line 642 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_stretch_blt_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                     SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___1 *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 652
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 652
  cmd = (struct vmw_sid_cmd___1 *)__mptr;
#line 653
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.src.sid,
                          0);
#line 656
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 656
  if (tmp != 0L) {
#line 657
    return (ret);
  } else {

  }
#line 658
  tmp___0 = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.dest.sid,
                              0);
#line 658
  return (tmp___0);
}
}
#line 663 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_blt_surf_screen_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                         SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___2 *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 672
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 672
  cmd = (struct vmw_sid_cmd___2 *)__mptr;
#line 674
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 674
  if (tmp != 0L) {
#line 675
    drm_err("vmw_cmd_blt_surf_screen_check", "Kernel only SVGA3d command: %u.\n",
            cmd->header.id);
#line 676
    return (-1);
  } else {

  }
#line 679
  tmp___0 = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.srcImage.sid,
                              0);
#line 679
  return (tmp___0);
}
}
#line 684 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_present_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                 SVGA3dCmdHeader *header ) 
{ struct vmw_sid_cmd___3 *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 694
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 694
  cmd = (struct vmw_sid_cmd___3 *)__mptr;
#line 696
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 696
  if (tmp != 0L) {
#line 697
    drm_err("vmw_cmd_present_check", "Kernel only SVGA3d command: %u.\n", cmd->header.id);
#line 698
    return (-1);
  } else {

  }
#line 701
  tmp___0 = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->body.sid,
                              0);
#line 701
  return (tmp___0);
}
}
#line 719 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_query_bo_switch_prepare(struct vmw_private *dev_priv , struct ttm_buffer_object *new_query_bo ,
                                       struct vmw_sw_context *sw_context ) 
{ struct vmw_res_cache_entry *ctx_entry ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 723
  ctx_entry = (struct vmw_res_cache_entry *)(& sw_context->res_cache);
#line 727
  tmp = ldv__builtin_expect((long )(! ctx_entry->valid), 0L);
#line 727
  if (tmp != 0L) {
#line 727
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                         "i" (727), "i" (12UL));
    ldv_40805: ;
#line 727
    goto ldv_40805;
  } else {

  }
#line 728
  sw_context->last_query_ctx = ctx_entry->res;
#line 730
  tmp___4 = ldv__builtin_expect((unsigned long )sw_context->cur_query_bo != (unsigned long )new_query_bo,
                             0L);
#line 730
  if (tmp___4 != 0L) {
#line 732
    tmp___0 = ldv__builtin_expect(new_query_bo->num_pages > 4UL, 0L);
#line 732
    if (tmp___0 != 0L) {
#line 733
      drm_err("vmw_query_bo_switch_prepare", "Query buffer too large.\n");
#line 734
      return (-22);
    } else {

    }
#line 737
    tmp___2 = ldv__builtin_expect((unsigned long )sw_context->cur_query_bo != (unsigned long )((struct ttm_buffer_object *)0),
                               0L);
#line 737
    if (tmp___2 != 0L) {
#line 738
      sw_context->needs_post_query_barrier = 1;
#line 739
      ret = vmw_bo_to_validate_list(sw_context, sw_context->cur_query_bo, 0);
#line 742
      tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 742
      if (tmp___1 != 0L) {
#line 743
        return (ret);
      } else {

      }
    } else {

    }
#line 745
    sw_context->cur_query_bo = new_query_bo;
#line 747
    ret = vmw_bo_to_validate_list(sw_context, dev_priv->dummy_query_bo, 0);
#line 750
    tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 750
    if (tmp___3 != 0L) {
#line 751
      return (ret);
    } else {

    }
  } else {

  }
#line 755
  return (0);
}
}
#line 776 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_query_bo_switch_commit(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ struct vmw_res_cache_entry *ctx_entry ;
  struct vmw_resource *ctx ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 784
  if ((int )sw_context->needs_post_query_barrier) {
#line 785
    ctx_entry = (struct vmw_res_cache_entry *)(& sw_context->res_cache);
#line 790
    tmp = ldv__builtin_expect((long )(! ctx_entry->valid), 0L);
#line 790
    if (tmp != 0L) {
#line 790
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (790), "i" (12UL));
      ldv_40814: ;
#line 790
      goto ldv_40814;
    } else {

    }
#line 791
    ctx = ctx_entry->res;
#line 793
    ret = vmw_fifo_emit_dummy_query(dev_priv, (uint32_t )ctx->id);
#line 795
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 795
    if (tmp___0 != 0L) {
#line 796
      drm_err("vmw_query_bo_switch_commit", "Out of fifo space for dummy query.\n");
    } else {

    }
  } else {

  }
#line 799
  if ((unsigned long )dev_priv->pinned_bo != (unsigned long )sw_context->cur_query_bo) {
#line 800
    if ((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 801
      vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 802
      ttm_bo_unref(& dev_priv->pinned_bo);
    } else {

    }
#line 805
    if (! sw_context->needs_post_query_barrier) {
#line 806
      vmw_bo_pin(sw_context->cur_query_bo, 1);
#line 814
      vmw_bo_pin(dev_priv->dummy_query_bo, 1);
#line 815
      dev_priv->dummy_query_bo_pinned = 1;
#line 817
      tmp___1 = ldv__builtin_expect((unsigned long )sw_context->last_query_ctx == (unsigned long )((struct vmw_resource *)0),
                                 0L);
#line 817
      if (tmp___1 != 0L) {
#line 817
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                             "i" (817), "i" (12UL));
        ldv_40816: ;
#line 817
        goto ldv_40816;
      } else {

      }
#line 818
      dev_priv->query_cid = (uint32_t )(sw_context->last_query_ctx)->id;
#line 819
      dev_priv->query_cid_valid = 1U;
#line 820
      dev_priv->pinned_bo = ttm_bo_reference(sw_context->cur_query_bo);
    } else {

    }
  } else {

  }
#line 824
  return;
}
}
#line 845 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_translate_guest_ptr(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                   SVGAGuestPtr *ptr , struct vmw_dma_buffer **vmw_bo_p ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct ttm_buffer_object *bo ;
  uint32_t handle ;
  struct vmw_relocation *reloc ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  long tmp___2 ;

  {
#line 850
  vmw_bo = 0;
#line 852
  handle = ptr->gmrId;
#line 856
  ret = vmw_user_dmabuf_lookup(sw_context->tfile, handle, & vmw_bo);
#line 857
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 857
  if (tmp != 0L) {
#line 858
    drm_err("vmw_translate_guest_ptr", "Could not find or use GMR region.\n");
#line 859
    return (-22);
  } else {

  }
#line 861
  bo = & vmw_bo->base;
#line 863
  tmp___0 = ldv__builtin_expect(sw_context->cur_reloc > 2047U, 0L);
#line 863
  if (tmp___0 != 0L) {
#line 864
    drm_err("vmw_translate_guest_ptr", "Max number relocations per submission exceeded\n");
#line 866
    ret = -22;
#line 867
    goto out_no_reloc;
  } else {

  }
#line 870
  tmp___1 = sw_context->cur_reloc;
#line 870
  sw_context->cur_reloc = sw_context->cur_reloc + 1U;
#line 870
  reloc = (struct vmw_relocation *)(& sw_context->relocs) + (unsigned long )tmp___1;
#line 871
  reloc->location = ptr;
#line 873
  ret = vmw_bo_to_validate_list(sw_context, bo, & reloc->index);
#line 874
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 874
  if (tmp___2 != 0L) {
#line 875
    goto out_no_reloc;
  } else {

  }
#line 877
  *vmw_bo_p = vmw_bo;
#line 878
  return (0);
  out_no_reloc: 
#line 881
  vmw_dmabuf_unreference(& vmw_bo);
#line 882
  vmw_bo_p = 0;
#line 883
  return (ret);
}
}
#line 893 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_begin_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                               SVGA3dCmdHeader *header ) 
{ struct vmw_begin_query_cmd *cmd ;
  SVGA3dCmdHeader const   *__mptr ;
  int tmp ;

  {
#line 902
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 902
  cmd = (struct vmw_begin_query_cmd *)__mptr;
#line 905
  tmp = vmw_cmd_res_check(dev_priv, sw_context, 0, user_context_converter, & cmd->q.cid,
                          0);
#line 905
  return (tmp);
}
}
#line 917 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_end_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;

  {
#line 928
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 928
  cmd = (struct vmw_query_cmd *)__mptr;
#line 929
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 930
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 930
  if (tmp != 0L) {
#line 931
    return (ret);
  } else {

  }
#line 933
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->q.guestResult, & vmw_bo);
#line 936
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 936
  if (tmp___0 != 0L) {
#line 937
    return (ret);
  } else {

  }
#line 939
  ret = vmw_query_bo_switch_prepare(dev_priv, & vmw_bo->base, sw_context);
#line 941
  vmw_dmabuf_unreference(& vmw_bo);
#line 942
  return (ret);
}
}
#line 952 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_wait_query(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                              SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_query_cmd___0 *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;

  {
#line 963
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 963
  cmd = (struct vmw_query_cmd___0 *)__mptr;
#line 964
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 965
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 965
  if (tmp != 0L) {
#line 966
    return (ret);
  } else {

  }
#line 968
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->q.guestResult, & vmw_bo);
#line 971
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 971
  if (tmp___0 != 0L) {
#line 972
    return (ret);
  } else {

  }
#line 974
  vmw_dmabuf_unreference(& vmw_bo);
#line 975
  return (0);
}
}
#line 978 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_dma(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                       SVGA3dCmdHeader *header ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_surface *srf ;
  struct vmw_dma_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 982
  vmw_bo = 0;
#line 983
  srf = 0;
#line 990
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 990
  cmd = (struct vmw_dma_cmd *)__mptr;
#line 991
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->dma.guest.ptr, & vmw_bo);
#line 994
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 994
  if (tmp != 0L) {
#line 995
    return (ret);
  } else {

  }
#line 997
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cmd->dma.host.sid,
                          0);
#line 1000
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1000
  if (tmp___1 != 0L) {
#line 1001
    tmp___0 = ldv__builtin_expect(ret != -512, 0L);
#line 1001
    if (tmp___0 != 0L) {
#line 1002
      drm_err("vmw_cmd_dma", "could not find surface for DMA.\n");
    } else {

    }
#line 1003
    goto out_no_surface;
  } else {

  }
#line 1006
  srf = vmw_res_to_srf(sw_context->res_cache[1].res);
#line 1008
  vmw_kms_cursor_snoop(srf, sw_context->tfile, & vmw_bo->base, header);
  out_no_surface: 
#line 1011
  vmw_dmabuf_unreference(& vmw_bo);
#line 1012
  return (ret);
}
}
#line 1015 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_draw(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                        SVGA3dCmdHeader *header ) 
{ struct vmw_draw_cmd *cmd ;
  SVGA3dVertexDecl *decl ;
  SVGA3dPrimitiveRange *range ;
  uint32_t i ;
  uint32_t maxnum ;
  int ret ;
  long tmp ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1023
  decl = (SVGA3dVertexDecl *)((unsigned long )header + 20UL);
#line 1030
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 1031
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1031
  if (tmp != 0L) {
#line 1032
    return (ret);
  } else {

  }
#line 1034
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 1034
  cmd = (struct vmw_draw_cmd *)__mptr;
#line 1035
  maxnum = (uint32_t )(((unsigned long )header->size - 12UL) / 36UL);
#line 1037
  tmp___0 = ldv__builtin_expect(cmd->body.numVertexDecls > maxnum, 0L);
#line 1037
  if (tmp___0 != 0L) {
#line 1038
    drm_err("vmw_cmd_draw", "Illegal number of vertex declarations.\n");
#line 1039
    return (-22);
  } else {

  }
#line 1042
  i = 0U;
#line 1042
  goto ldv_40901;
  ldv_40900: 
#line 1043
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & decl->array.surfaceId,
                          0);
#line 1046
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1046
  if (tmp___1 != 0L) {
#line 1047
    return (ret);
  } else {

  }
#line 1042
  i = i + 1U;
#line 1042
  decl = decl + 1;
  ldv_40901: ;
#line 1042
  if (cmd->body.numVertexDecls > i) {
#line 1043
    goto ldv_40900;
  } else {
#line 1045
    goto ldv_40902;
  }
  ldv_40902: 
#line 1050
  maxnum = (uint32_t )((((unsigned long )header->size - (unsigned long )cmd->body.numVertexDecls * 36UL) - 12UL) / 28UL);
#line 1052
  tmp___2 = ldv__builtin_expect(cmd->body.numRanges > maxnum, 0L);
#line 1052
  if (tmp___2 != 0L) {
#line 1053
    drm_err("vmw_cmd_draw", "Illegal number of index ranges.\n");
#line 1054
    return (-22);
  } else {

  }
#line 1057
  range = (SVGA3dPrimitiveRange *)decl;
#line 1058
  i = 0U;
#line 1058
  goto ldv_40904;
  ldv_40903: 
#line 1059
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & range->indexArray.surfaceId,
                          0);
#line 1062
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1062
  if (tmp___3 != 0L) {
#line 1063
    return (ret);
  } else {

  }
#line 1058
  i = i + 1U;
#line 1058
  range = range + 1;
  ldv_40904: ;
#line 1058
  if (cmd->body.numRanges > i) {
#line 1059
    goto ldv_40903;
  } else {
#line 1061
    goto ldv_40905;
  }
  ldv_40905: ;
#line 1065
  return (0);
}
}
#line 1069 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_tex_state(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             SVGA3dCmdHeader *header ) 
{ SVGA3dTextureState *last_state ;
  SVGA3dTextureState *cur_state ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1078
  last_state = (SVGA3dTextureState *)(((unsigned long )header->size + (unsigned long )header) + 8UL);
#line 1080
  cur_state = (SVGA3dTextureState *)((unsigned long )header + 12UL);
#line 1084
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 1085
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1085
  if (tmp != 0L) {
#line 1086
    return (ret);
  } else {

  }
#line 1088
  goto ldv_40919;
  ldv_40918: 
#line 1089
  tmp___0 = ldv__builtin_expect((unsigned int )cur_state->name != 1U, 1L);
#line 1089
  if (tmp___0 != 0L) {
#line 1090
    goto ldv_40917;
  } else {

  }
#line 1092
  ret = vmw_cmd_res_check(dev_priv, sw_context, 1, user_surface_converter, & cur_state->ldv_7545.value,
                          0);
#line 1095
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1095
  if (tmp___1 != 0L) {
#line 1096
    return (ret);
  } else {

  }
  ldv_40917: 
#line 1088
  cur_state = cur_state + 1;
  ldv_40919: ;
#line 1088
  if ((unsigned long )cur_state < (unsigned long )last_state) {
#line 1089
    goto ldv_40918;
  } else {
#line 1091
    goto ldv_40920;
  }
  ldv_40920: ;
#line 1099
  return (0);
}
}
#line 1102 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_define_gmrfb(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                      void *buf ) 
{ struct vmw_dma_buffer *vmw_bo ;
  int ret ;
  struct __anonstruct_cmd_291 *cmd ;
  long tmp ;

  {
#line 1112
  cmd = (struct __anonstruct_294 *)buf;
#line 1114
  ret = vmw_translate_guest_ptr(dev_priv, sw_context, & cmd->body.ptr, & vmw_bo);
#line 1117
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1117
  if (tmp != 0L) {
#line 1118
    return (ret);
  } else {

  }
#line 1120
  vmw_dmabuf_unreference(& vmw_bo);
#line 1122
  return (ret);
}
}
#line 1133 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_set_shader(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                              SVGA3dCmdHeader *header ) 
{ struct vmw_set_shader_cmd *cmd ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;

  {
#line 1143
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 1143
  cmd = (struct vmw_set_shader_cmd *)__mptr;
#line 1146
  ret = vmw_cmd_cid_check(dev_priv, sw_context, header);
#line 1147
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1147
  if (tmp != 0L) {
#line 1148
    return (ret);
  } else {

  }
#line 1150
  return (0);
}
}
#line 1153 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_not_3d(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                                void *buf , uint32_t *size ) 
{ uint32_t size_remaining ;
  uint32_t cmd_id ;
  long tmp ;
  int tmp___0 ;

  {
#line 1157
  size_remaining = *size;
#line 1160
  cmd_id = *((uint32_t *)buf);
#line 1161
  switch (cmd_id) {
  case 1: 
#line 1163
  *size = 20U;
#line 1164
  goto ldv_40953;
  case 36: 
#line 1166
  *size = 20U;
#line 1167
  goto ldv_40953;
  case 37: 
#line 1169
  *size = 32U;
#line 1170
  goto ldv_40953;
  case 38: 
#line 1172
  *size = 32U;
#line 1173
  goto ldv_40953;
  default: 
#line 1175
  drm_err("vmw_cmd_check_not_3d", "Unsupported SVGA command: %u.\n", cmd_id);
#line 1176
  return (-22);
  }
  ldv_40953: ;
#line 1179
  if (*size > size_remaining) {
#line 1180
    drm_err("vmw_cmd_check_not_3d", "Invalid SVGA command (size mismatch): %u.\n",
            cmd_id);
#line 1182
    return (-22);
  } else {

  }
#line 1185
  tmp = ldv__builtin_expect((long )(! sw_context->kernel), 0L);
#line 1185
  if (tmp != 0L) {
#line 1186
    drm_err("vmw_cmd_check_not_3d", "Kernel only SVGA command: %u.\n", cmd_id);
#line 1187
    return (-1);
  } else {

  }
#line 1190
  if (cmd_id == 36U) {
#line 1191
    tmp___0 = vmw_cmd_check_define_gmrfb(dev_priv, sw_context, buf);
#line 1191
    return (tmp___0);
  } else {

  }
#line 1193
  return (0);
}
}
#line 1203 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static vmw_cmd_func vmw_cmd_funcs[1082U]  = 
#line 1203
  {      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_surface_copy_check,      & vmw_cmd_stretch_blt_check, 
        & vmw_cmd_dma,      & vmw_cmd_invalid,      & vmw_cmd_invalid,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_set_render_target_check,      & vmw_cmd_tex_state, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_cid_check,      & vmw_cmd_present_check,      & vmw_cmd_cid_check, 
        & vmw_cmd_cid_check,      & vmw_cmd_set_shader,      & vmw_cmd_cid_check,      & vmw_cmd_draw, 
        & vmw_cmd_cid_check,      & vmw_cmd_begin_query,      & vmw_cmd_end_query,      & vmw_cmd_wait_query, 
        & vmw_cmd_ok,      & vmw_cmd_blt_surf_screen_check,      & vmw_cmd_invalid,      & vmw_cmd_invalid, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        & vmw_cmd_invalid,      & vmw_cmd_invalid};
#line 1242 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                         void *buf , uint32_t *size ) 
{ uint32_t cmd_id ;
  uint32_t size_remaining ;
  SVGA3dCmdHeader *header ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1247
  size_remaining = *size;
#line 1248
  header = (SVGA3dCmdHeader *)buf;
#line 1251
  cmd_id = *((uint32_t *)buf);
#line 1253
  tmp___0 = ldv__builtin_expect(cmd_id <= 42U, 0L);
#line 1253
  if (tmp___0 != 0L) {
#line 1254
    tmp = vmw_cmd_check_not_3d(dev_priv, sw_context, buf, size);
#line 1254
    return (tmp);
  } else {

  }
#line 1257
  cmd_id = header->id;
#line 1258
  *size = header->size + 8U;
#line 1260
  cmd_id = cmd_id - 1040U;
#line 1261
  tmp___1 = ldv__builtin_expect(*size > size_remaining, 0L);
#line 1261
  if (tmp___1 != 0L) {
#line 1262
    goto out_err;
  } else {

  }
#line 1264
  tmp___2 = ldv__builtin_expect(cmd_id > 41U, 0L);
#line 1264
  if (tmp___2 != 0L) {
#line 1265
    goto out_err;
  } else {

  }
#line 1267
  ret = (*(vmw_cmd_funcs[cmd_id]))(dev_priv, sw_context, header);
#line 1268
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1268
  if (tmp___3 != 0L) {
#line 1269
    goto out_err;
  } else {

  }
#line 1271
  return (0);
  out_err: 
#line 1273
  drm_err("vmw_cmd_check", "Illegal / Invalid SVGA3D command: %d\n", cmd_id + 1040U);
#line 1275
  return (-22);
}
}
#line 1278 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_cmd_check_all(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ,
                             void *buf , uint32_t size ) 
{ int32_t cur_size ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 1283
  cur_size = (int32_t )size;
#line 1286
  sw_context->buf_start = (uint32_t *)buf;
#line 1288
  goto ldv_40985;
  ldv_40984: 
#line 1289
  size = (uint32_t )cur_size;
#line 1290
  ret = vmw_cmd_check(dev_priv, sw_context, buf, & size);
#line 1291
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1291
  if (tmp != 0L) {
#line 1292
    return (ret);
  } else {

  }
#line 1293
  buf = (void *)((unsigned long )size + (unsigned long )buf);
#line 1294
  cur_size = (int32_t )((uint32_t )cur_size - size);
  ldv_40985: ;
#line 1288
  if (cur_size > 0) {
#line 1289
    goto ldv_40984;
  } else {
#line 1291
    goto ldv_40986;
  }
  ldv_40986: 
#line 1297
  tmp___0 = ldv__builtin_expect(cur_size != 0, 0L);
#line 1297
  if (tmp___0 != 0L) {
#line 1298
    drm_err("vmw_cmd_check_all", "Command verifier out of sync.\n");
#line 1299
    return (-22);
  } else {

  }
#line 1302
  return (0);
}
}
#line 1305 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_free_relocations(struct vmw_sw_context *sw_context ) 
{ 

  {
#line 1307
  sw_context->cur_reloc = 0U;
#line 1308
  return;
}
}
#line 1310 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_apply_relocations(struct vmw_sw_context *sw_context ) 
{ uint32_t i ;
  struct vmw_relocation *reloc ;
  struct ttm_validate_buffer *validate ;
  struct ttm_buffer_object *bo ;

  {
#line 1317
  i = 0U;
#line 1317
  goto ldv_41004;
  ldv_41003: 
#line 1318
  reloc = (struct vmw_relocation *)(& sw_context->relocs) + (unsigned long )i;
#line 1319
  validate = & sw_context->val_bufs[reloc->index].base;
#line 1320
  bo = validate->bo;
#line 1321
  switch (bo->mem.mem_type) {
  case 2: 
#line 1323
  (reloc->location)->offset = (reloc->location)->offset + (uint32 )bo->offset;
#line 1324
  (reloc->location)->gmrId = 4294967294U;
#line 1325
  goto ldv_40999;
  case 3: 
#line 1327
  (reloc->location)->gmrId = (uint32 )bo->mem.start;
#line 1328
  goto ldv_40999;
  default: 
#line 1330
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                       "i" (1330), "i" (12UL));
  ldv_41002: ;
#line 1330
  goto ldv_41002;
  }
  ldv_40999: 
#line 1317
  i = i + 1U;
  ldv_41004: ;
#line 1317
  if (sw_context->cur_reloc > i) {
#line 1318
    goto ldv_41003;
  } else {
#line 1320
    goto ldv_41005;
  }
  ldv_41005: 
#line 1333
  vmw_free_relocations(sw_context);
#line 1334
  return;
}
}
#line 1342 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_resource_list_unreference(struct list_head *list ) 
{ struct vmw_resource_val_node *val ;
  struct vmw_resource_val_node *val_next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1350
  __mptr = (struct list_head  const  *)list->next;
#line 1350
  val = (struct vmw_resource_val_node *)__mptr;
#line 1350
  __mptr___0 = (struct list_head  const  *)val->head.next;
#line 1350
  val_next = (struct vmw_resource_val_node *)__mptr___0;
#line 1350
  goto ldv_41018;
  ldv_41017: 
#line 1351
  list_del_init(& val->head);
#line 1352
  vmw_resource_unreference(& val->res);
#line 1353
  kfree((void const   *)val);
#line 1350
  val = val_next;
#line 1350
  __mptr___1 = (struct list_head  const  *)val_next->head.next;
#line 1350
  val_next = (struct vmw_resource_val_node *)__mptr___1;
  ldv_41018: ;
#line 1350
  if ((unsigned long )(& val->head) != (unsigned long )list) {
#line 1351
    goto ldv_41017;
  } else {
#line 1353
    goto ldv_41019;
  }
  ldv_41019: ;
#line 1355
  return;
}
}
#line 1357 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_clear_validations(struct vmw_sw_context *sw_context ) 
{ struct vmw_validate_buffer *entry ;
  struct vmw_validate_buffer *next ;
  struct vmw_resource_val_node *val ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 1365
  __mptr = (struct list_head  const  *)sw_context->validate_nodes.next;
#line 1365
  entry = (struct vmw_validate_buffer *)__mptr;
#line 1365
  __mptr___0 = (struct list_head  const  *)entry->base.head.next;
#line 1365
  next = (struct vmw_validate_buffer *)__mptr___0;
#line 1365
  goto ldv_41033;
  ldv_41032: 
#line 1367
  list_del(& entry->base.head);
#line 1368
  ttm_bo_unref(& entry->base.bo);
#line 1369
  drm_ht_remove_item(& sw_context->res_ht, & entry->hash);
#line 1370
  sw_context->cur_val_buf = sw_context->cur_val_buf - 1U;
#line 1365
  entry = next;
#line 1365
  __mptr___1 = (struct list_head  const  *)next->base.head.next;
#line 1365
  next = (struct vmw_validate_buffer *)__mptr___1;
  ldv_41033: ;
#line 1365
  if ((unsigned long )(& entry->base.head) != (unsigned long )(& sw_context->validate_nodes)) {
#line 1366
    goto ldv_41032;
  } else {
#line 1368
    goto ldv_41034;
  }
  ldv_41034: 
#line 1372
  tmp = ldv__builtin_expect(sw_context->cur_val_buf != 0U, 0L);
#line 1372
  if (tmp != 0L) {
#line 1372
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                         "i" (1372), "i" (12UL));
    ldv_41035: ;
#line 1372
    goto ldv_41035;
  } else {

  }
#line 1374
  __mptr___2 = (struct list_head  const  *)sw_context->resource_list.next;
#line 1374
  val = (struct vmw_resource_val_node *)__mptr___2;
#line 1374
  goto ldv_41041;
  ldv_41040: 
#line 1375
  drm_ht_remove_item(& sw_context->res_ht, & val->hash);
#line 1374
  __mptr___3 = (struct list_head  const  *)val->head.next;
#line 1374
  val = (struct vmw_resource_val_node *)__mptr___3;
  ldv_41041: ;
#line 1374
  if ((unsigned long )(& val->head) != (unsigned long )(& sw_context->resource_list)) {
#line 1375
    goto ldv_41040;
  } else {
#line 1377
    goto ldv_41042;
  }
  ldv_41042: ;
#line 1379
  return;
}
}
#line 1378 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_validate_single_buffer(struct vmw_private *dev_priv , struct ttm_buffer_object *bo ) 
{ int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 1388
  if ((unsigned long )dev_priv->pinned_bo == (unsigned long )bo || ((unsigned long )dev_priv->dummy_query_bo == (unsigned long )bo && (int )dev_priv->dummy_query_bo_pinned)) {
#line 1391
    return (0);
  } else {

  }
#line 1400
  ret = ttm_bo_validate(bo, & vmw_vram_gmr_placement, 1, 0);
#line 1401
  tmp = ldv__builtin_expect(ret == 0, 1L);
#line 1401
  if (tmp != 0L) {
#line 1402
    return (ret);
  } else {
#line 1401
    tmp___0 = ldv__builtin_expect(ret == -512, 1L);
#line 1401
    if (tmp___0 != 0L) {
#line 1402
      return (ret);
    } else {

    }
  }
#line 1409
  printk("\016[drm] Falling through to VRAM.\n");
#line 1410
  ret = ttm_bo_validate(bo, & vmw_vram_placement, 1, 0);
#line 1411
  return (ret);
}
}
#line 1415 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_validate_buffers(struct vmw_private *dev_priv , struct vmw_sw_context *sw_context ) 
{ struct vmw_validate_buffer *entry ;
  int ret ;
  struct list_head  const  *__mptr ;
  long tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1421
  __mptr = (struct list_head  const  *)sw_context->validate_nodes.next;
#line 1421
  entry = (struct vmw_validate_buffer *)__mptr;
#line 1421
  goto ldv_41059;
  ldv_41058: 
#line 1422
  ret = vmw_validate_single_buffer(dev_priv, entry->base.bo);
#line 1423
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1423
  if (tmp != 0L) {
#line 1424
    return (ret);
  } else {

  }
#line 1421
  __mptr___0 = (struct list_head  const  *)entry->base.head.next;
#line 1421
  entry = (struct vmw_validate_buffer *)__mptr___0;
  ldv_41059: ;
#line 1421
  if ((unsigned long )(& entry->base.head) != (unsigned long )(& sw_context->validate_nodes)) {
#line 1422
    goto ldv_41058;
  } else {
#line 1424
    goto ldv_41060;
  }
  ldv_41060: ;
#line 1426
  return (0);
}
}
#line 1429 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static int vmw_resize_cmd_bounce(struct vmw_sw_context *sw_context , uint32_t size ) 
{ long tmp ;
  void *tmp___0 ;

  {
#line 1432
  tmp = ldv__builtin_expect(sw_context->cmd_bounce_size >= size, 1L);
#line 1432
  if (tmp != 0L) {
#line 1433
    return (0);
  } else {

  }
#line 1435
  if (sw_context->cmd_bounce_size == 0U) {
#line 1436
    sw_context->cmd_bounce_size = 32768U;
  } else {

  }
#line 1438
  goto ldv_41066;
  ldv_41065: 
#line 1439
  sw_context->cmd_bounce_size = ((sw_context->cmd_bounce_size + (sw_context->cmd_bounce_size >> 1)) + 4095U) & 4294963200U;
  ldv_41066: ;
#line 1438
  if (sw_context->cmd_bounce_size < size) {
#line 1439
    goto ldv_41065;
  } else {
#line 1441
    goto ldv_41067;
  }
  ldv_41067: ;
#line 1444
  if ((unsigned long )sw_context->cmd_bounce != (unsigned long )((uint32_t *)0)) {
#line 1445
    vfree((void const   *)sw_context->cmd_bounce);
  } else {

  }
#line 1447
  tmp___0 = vmalloc((unsigned long )sw_context->cmd_bounce_size);
#line 1447
  sw_context->cmd_bounce = (uint32_t *)tmp___0;
#line 1449
  if ((unsigned long )sw_context->cmd_bounce == (unsigned long )((uint32_t *)0)) {
#line 1450
    drm_err("vmw_resize_cmd_bounce", "Failed to allocate command bounce buffer.\n");
#line 1451
    sw_context->cmd_bounce_size = 0U;
#line 1452
    return (-12);
  } else {

  }
#line 1455
  return (0);
}
}
#line 1469 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_fence_commands(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_fence_obj **p_fence , uint32_t *p_handle ) 
{ uint32_t sequence ;
  int ret ;
  bool synced ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1476
  synced = 0;
#line 1479
  tmp = ldv__builtin_expect((unsigned long )p_handle != (unsigned long )((uint32_t *)0),
                         0L);
#line 1479
  if (tmp != 0L) {
#line 1479
    tmp___0 = ldv__builtin_expect((unsigned long )file_priv == (unsigned long )((struct drm_file *)0),
                               0L);
#line 1479
    if (tmp___0 != 0L) {
#line 1479
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (1479), "i" (12UL));
      ldv_41078: ;
#line 1479
      goto ldv_41078;
    } else {

    }
  } else {

  }
#line 1481
  ret = vmw_fifo_send_fence(dev_priv, & sequence);
#line 1482
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1482
  if (tmp___1 != 0L) {
#line 1483
    drm_err("vmw_execbuf_fence_commands", "Fence submission error. Syncing.\n");
#line 1484
    synced = 1;
  } else {

  }
#line 1487
  if ((unsigned long )p_handle != (unsigned long )((uint32_t *)0)) {
#line 1488
    ret = vmw_user_fence_create(file_priv, dev_priv->fman, sequence, 1U, p_fence,
                                p_handle);
  } else {
#line 1493
    ret = vmw_fence_create(dev_priv->fman, sequence, 1U, p_fence);
  }
#line 1497
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1497
  if (tmp___2 != 0L) {
#line 1497
    tmp___3 = ldv__builtin_expect((long )(! synced), 0L);
#line 1497
    if (tmp___3 != 0L) {
#line 1498
      vmw_fallback_wait(dev_priv, 0, 0, sequence, 0, 1250UL);
#line 1501
      *p_fence = 0;
    } else {

    }
  } else {

  }
#line 1504
  return (0);
}
}
#line 1528 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv , struct vmw_fpriv *vmw_fp ,
                                 int ret , struct drm_vmw_fence_rep *user_fence_rep ,
                                 struct vmw_fence_obj *fence , uint32_t fence_handle ) 
{ struct drm_vmw_fence_rep fence_rep ;
  long tmp ;
  long tmp___0 ;

  {
#line 1537
  if ((unsigned long )user_fence_rep == (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1538
    return;
  } else {

  }
#line 1540
  memset((void *)(& fence_rep), 0, 24UL);
#line 1542
  fence_rep.error = ret;
#line 1543
  if (ret == 0) {
#line 1544
    tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                           0L);
#line 1544
    if (tmp != 0L) {
#line 1544
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (1544), "i" (12UL));
      ldv_41089: ;
#line 1544
      goto ldv_41089;
    } else {

    }
#line 1546
    fence_rep.handle = fence_handle;
#line 1547
    fence_rep.seqno = fence->seqno;
#line 1548
    vmw_update_seqno(dev_priv, & dev_priv->fifo);
#line 1549
    fence_rep.passed_seqno = dev_priv->last_read_seqno;
  } else {

  }
#line 1557
  ret = copy_to_user((void *)user_fence_rep, (void const   *)(& fence_rep), 24U);
#line 1564
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1564
  if (tmp___0 != 0L && fence_rep.error == 0) {
#line 1565
    ttm_ref_object_base_unref(vmw_fp->tfile, (unsigned long )fence_handle, 0);
#line 1567
    drm_err("vmw_execbuf_copy_fence_user", "Fence copy error. Syncing.\n");
#line 1568
    vmw_fence_obj_wait(fence, fence->signal_mask, 0, 0, 1250UL);
  } else {

  }
#line 1570
  return;
}
}
#line 1574 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_process(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                        void *user_commands , void *kernel_commands , uint32_t command_size ,
                        uint64_t throttle_us , struct drm_vmw_fence_rep *user_fence_rep ,
                        struct vmw_fence_obj **out_fence ) 
{ struct vmw_sw_context *sw_context ;
  struct vmw_fence_obj *fence ;
  struct vmw_resource *error_resource ;
  struct list_head resource_list ;
  uint32_t handle ;
  void *cmd ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  unsigned long tmp___1 ;
  long tmp___2 ;
  struct vmw_fpriv *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  size_t __len ;
  void *__ret ;
  uint32_t *tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  struct vmw_fpriv *tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;

  {
#line 1583
  sw_context = & dev_priv->ctx;
#line 1584
  fence = 0;
#line 1591
  ret = ldv_mutex_lock_interruptible_15(& dev_priv->cmdbuf_mutex);
#line 1592
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1592
  if (tmp != 0L) {
#line 1593
    return (-512);
  } else {

  }
#line 1595
  if ((unsigned long )kernel_commands == (unsigned long )((void *)0)) {
#line 1596
    sw_context->kernel = 0;
#line 1598
    ret = vmw_resize_cmd_bounce(sw_context, command_size);
#line 1599
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1599
    if (tmp___0 != 0L) {
#line 1600
      goto out_unlock;
    } else {

    }
#line 1603
    tmp___1 = copy_from_user((void *)sw_context->cmd_bounce, (void const   *)user_commands,
                             (unsigned long )command_size);
#line 1603
    ret = (int )tmp___1;
#line 1606
    tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1606
    if (tmp___2 != 0L) {
#line 1607
      ret = -14;
#line 1608
      drm_err("vmw_execbuf_process", "Failed copying commands.\n");
#line 1609
      goto out_unlock;
    } else {

    }
#line 1611
    kernel_commands = (void *)sw_context->cmd_bounce;
  } else {
#line 1613
    sw_context->kernel = 1;
  }
#line 1615
  tmp___3 = vmw_fpriv(file_priv);
#line 1615
  sw_context->tfile = tmp___3->tfile;
#line 1616
  sw_context->cur_reloc = 0U;
#line 1617
  sw_context->cur_val_buf = 0U;
#line 1618
  sw_context->fence_flags = 0U;
#line 1619
  INIT_LIST_HEAD(& sw_context->resource_list);
#line 1620
  sw_context->cur_query_bo = dev_priv->pinned_bo;
#line 1621
  sw_context->last_query_ctx = 0;
#line 1622
  sw_context->needs_post_query_barrier = 0;
#line 1623
  memset((void *)(& sw_context->res_cache), 0, 72UL);
#line 1624
  INIT_LIST_HEAD(& sw_context->validate_nodes);
#line 1625
  INIT_LIST_HEAD(& sw_context->res_relocations);
#line 1626
  if (! sw_context->res_ht_initialized) {
#line 1627
    ret = drm_ht_create(& sw_context->res_ht, 12U);
#line 1628
    tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 1628
    if (tmp___4 != 0L) {
#line 1629
      goto out_unlock;
    } else {

    }
#line 1630
    sw_context->res_ht_initialized = 1;
  } else {

  }
#line 1633
  INIT_LIST_HEAD(& resource_list);
#line 1634
  ret = vmw_cmd_check_all(dev_priv, sw_context, kernel_commands, command_size);
#line 1636
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1636
  if (tmp___5 != 0L) {
#line 1637
    goto out_err;
  } else {

  }
#line 1639
  ret = vmw_resources_reserve(sw_context);
#line 1640
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 1640
  if (tmp___6 != 0L) {
#line 1641
    goto out_err;
  } else {

  }
#line 1643
  ret = ttm_eu_reserve_buffers(& sw_context->validate_nodes);
#line 1644
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 1644
  if (tmp___7 != 0L) {
#line 1645
    goto out_err;
  } else {

  }
#line 1647
  ret = vmw_validate_buffers(dev_priv, sw_context);
#line 1648
  tmp___8 = ldv__builtin_expect(ret != 0, 0L);
#line 1648
  if (tmp___8 != 0L) {
#line 1649
    goto out_err;
  } else {

  }
#line 1651
  ret = vmw_resources_validate(sw_context);
#line 1652
  tmp___9 = ldv__builtin_expect(ret != 0, 0L);
#line 1652
  if (tmp___9 != 0L) {
#line 1653
    goto out_err;
  } else {

  }
#line 1655
  if (throttle_us != 0ULL) {
#line 1656
    ret = vmw_wait_lag(dev_priv, & dev_priv->fifo.marker_queue, (uint32_t )throttle_us);
#line 1659
    tmp___10 = ldv__builtin_expect(ret != 0, 0L);
#line 1659
    if (tmp___10 != 0L) {
#line 1660
      goto out_err;
    } else {

    }
  } else {

  }
#line 1663
  cmd = vmw_fifo_reserve(dev_priv, command_size);
#line 1664
  tmp___11 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((void *)0),
                              0L);
#line 1664
  if (tmp___11 != 0L) {
#line 1665
    drm_err("vmw_execbuf_process", "Failed reserving fifo space for commands.\n");
#line 1666
    ret = -12;
#line 1667
    goto out_err;
  } else {

  }
#line 1670
  vmw_apply_relocations(sw_context);
#line 1671
  __len = (size_t )command_size;
#line 1671
  __ret = __builtin_memcpy(cmd, (void const   *)kernel_commands, __len);
#line 1673
  vmw_resource_relocations_apply((uint32_t *)cmd, & sw_context->res_relocations);
#line 1674
  vmw_resource_relocations_free(& sw_context->res_relocations);
#line 1676
  vmw_fifo_commit(dev_priv, command_size);
#line 1678
  vmw_query_bo_switch_commit(dev_priv, sw_context);
#line 1679
  if ((unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1679
    tmp___12 = & handle;
  } else {
#line 1679
    tmp___12 = 0;
  }
#line 1679
  ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, tmp___12);
#line 1688
  if (ret != 0) {
#line 1689
    drm_err("vmw_execbuf_process", "Fence submission error. Syncing.\n");
  } else {

  }
#line 1691
  vmw_resource_list_unreserve(& sw_context->resource_list, 0);
#line 1692
  ttm_eu_fence_buffer_objects(& sw_context->validate_nodes, (void *)fence);
#line 1695
  tmp___13 = ldv__builtin_expect((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0),
                              0L);
#line 1695
  if (tmp___13 != 0L) {
#line 1695
    tmp___14 = ldv__builtin_expect(dev_priv->query_cid_valid == 0U, 0L);
#line 1695
    if (tmp___14 != 0L) {
#line 1697
      __vmw_execbuf_release_pinned_bo(dev_priv, fence);
    } else {

    }
  } else {

  }
#line 1699
  vmw_clear_validations(sw_context);
#line 1700
  tmp___15 = vmw_fpriv(file_priv);
#line 1700
  vmw_execbuf_copy_fence_user(dev_priv, tmp___15, ret, user_fence_rep, fence, handle);
#line 1704
  tmp___17 = ldv__builtin_expect((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0),
                              0L);
#line 1704
  if (tmp___17 != 0L) {
#line 1705
    *out_fence = fence;
#line 1706
    fence = 0;
  } else {
#line 1707
    tmp___16 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                                1L);
#line 1707
    if (tmp___16 != 0L) {
#line 1708
      vmw_fence_obj_unreference(& fence);
    } else {

    }
  }
#line 1711
  list_splice_init(& sw_context->resource_list, & resource_list);
#line 1712
  ldv_mutex_unlock_16(& dev_priv->cmdbuf_mutex);
#line 1718
  vmw_resource_list_unreference(& resource_list);
#line 1720
  return (0);
  out_err: 
#line 1723
  vmw_resource_relocations_free(& sw_context->res_relocations);
#line 1724
  vmw_free_relocations(sw_context);
#line 1725
  ttm_eu_backoff_reservation(& sw_context->validate_nodes);
#line 1726
  vmw_resource_list_unreserve(& sw_context->resource_list, 1);
#line 1727
  vmw_clear_validations(sw_context);
#line 1728
  tmp___18 = ldv__builtin_expect((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0),
                              0L);
#line 1728
  if (tmp___18 != 0L) {
#line 1728
    tmp___19 = ldv__builtin_expect(dev_priv->query_cid_valid == 0U, 0L);
#line 1728
    if (tmp___19 != 0L) {
#line 1730
      __vmw_execbuf_release_pinned_bo(dev_priv, 0);
    } else {

    }
  } else {

  }
  out_unlock: 
#line 1732
  list_splice_init(& sw_context->resource_list, & resource_list);
#line 1733
  error_resource = sw_context->error_resource;
#line 1734
  sw_context->error_resource = 0;
#line 1735
  ldv_mutex_unlock_17(& dev_priv->cmdbuf_mutex);
#line 1741
  vmw_resource_list_unreference(& resource_list);
#line 1742
  tmp___20 = ldv__builtin_expect((unsigned long )error_resource != (unsigned long )((struct vmw_resource *)0),
                              0L);
#line 1742
  if (tmp___20 != 0L) {
#line 1743
    vmw_resource_unreference(& error_resource);
  } else {

  }
#line 1745
  return (ret);
}
}
#line 1757 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
static void vmw_execbuf_unpin_panic(struct vmw_private *dev_priv ) 
{ 

  {
#line 1759
  drm_err("vmw_execbuf_unpin_panic", "Can\'t unpin query buffer. Trying to recover.\n");
#line 1761
  vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 2500UL);
#line 1762
  vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 1763
  vmw_bo_pin(dev_priv->dummy_query_bo, 0);
#line 1764
  dev_priv->dummy_query_bo_pinned = 0;
#line 1765
  return;
}
}
#line 1792 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void __vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv , struct vmw_fence_obj *fence ) 
{ int ret ;
  struct list_head validate_list ;
  struct ttm_validate_buffer pinned_val ;
  struct ttm_validate_buffer query_val ;
  struct vmw_fence_obj *lfence ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1795
  ret = 0;
#line 1798
  lfence = 0;
#line 1800
  if ((unsigned long )dev_priv->pinned_bo == (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1801
    goto out_unlock;
  } else {

  }
#line 1803
  INIT_LIST_HEAD(& validate_list);
#line 1805
  pinned_val.bo = ttm_bo_reference(dev_priv->pinned_bo);
#line 1806
  list_add_tail(& pinned_val.head, & validate_list);
#line 1808
  query_val.bo = ttm_bo_reference(dev_priv->dummy_query_bo);
#line 1809
  list_add_tail(& query_val.head, & validate_list);
  ldv_41128: 
#line 1812
  ret = ttm_eu_reserve_buffers(& validate_list);
#line 1813
  if (ret == -512) {
#line 1814
    goto ldv_41128;
  } else {
#line 1816
    goto ldv_41129;
  }
  ldv_41129: 
#line 1815
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1815
  if (tmp != 0L) {
#line 1816
    vmw_execbuf_unpin_panic(dev_priv);
#line 1817
    goto out_no_reserve;
  } else {

  }
#line 1820
  if (dev_priv->query_cid_valid != 0U) {
#line 1821
    tmp___0 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                               0L);
#line 1821
    if (tmp___0 != 0L) {
#line 1821
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"),
                           "i" (1821), "i" (12UL));
      ldv_41131: ;
#line 1821
      goto ldv_41131;
    } else {

    }
#line 1822
    ret = vmw_fifo_emit_dummy_query(dev_priv, dev_priv->query_cid);
#line 1823
    tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1823
    if (tmp___1 != 0L) {
#line 1824
      vmw_execbuf_unpin_panic(dev_priv);
#line 1825
      goto out_no_emit;
    } else {

    }
#line 1827
    dev_priv->query_cid_valid = 0U;
  } else {

  }
#line 1830
  vmw_bo_pin(dev_priv->pinned_bo, 0);
#line 1831
  vmw_bo_pin(dev_priv->dummy_query_bo, 0);
#line 1832
  dev_priv->dummy_query_bo_pinned = 0;
#line 1834
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1835
    vmw_execbuf_fence_commands(0, dev_priv, & lfence, 0);
#line 1837
    fence = lfence;
  } else {

  }
#line 1839
  ttm_eu_fence_buffer_objects(& validate_list, (void *)fence);
#line 1840
  if ((unsigned long )lfence != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1841
    vmw_fence_obj_unreference(& lfence);
  } else {

  }
#line 1843
  ttm_bo_unref(& query_val.bo);
#line 1844
  ttm_bo_unref(& pinned_val.bo);
#line 1845
  ttm_bo_unref(& dev_priv->pinned_bo);
  out_unlock: ;
#line 1848
  return;
  out_no_emit: 
#line 1851
  ttm_eu_backoff_reservation(& validate_list);
  out_no_reserve: 
#line 1853
  ttm_bo_unref(& query_val.bo);
#line 1854
  ttm_bo_unref(& pinned_val.bo);
#line 1855
  ttm_bo_unref(& dev_priv->pinned_bo);
#line 1856
  return;
}
}
#line 1876 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void vmw_execbuf_release_pinned_bo(struct vmw_private *dev_priv ) 
{ 

  {
#line 1878
  ldv_mutex_lock_18(& dev_priv->cmdbuf_mutex);
#line 1879
  if (dev_priv->query_cid_valid != 0U) {
#line 1880
    __vmw_execbuf_release_pinned_bo(dev_priv, 0);
  } else {

  }
#line 1881
  ldv_mutex_unlock_19(& dev_priv->cmdbuf_mutex);
#line 1882
  return;
}
}
#line 1885 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int vmw_execbuf_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_execbuf_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  int ret ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1888
  tmp = vmw_priv(dev);
#line 1888
  dev_priv = tmp;
#line 1889
  arg = (struct drm_vmw_execbuf_arg *)data;
#line 1890
  tmp___0 = vmw_master(file_priv->master);
#line 1890
  vmaster = tmp___0;
#line 1900
  tmp___1 = ldv__builtin_expect(arg->version != 1U, 0L);
#line 1900
  if (tmp___1 != 0L) {
#line 1901
    drm_err("vmw_execbuf_ioctl", "Incorrect execbuf version.\n");
#line 1902
    drm_err("vmw_execbuf_ioctl", "You\'re running outdated experimental vmwgfx user-space drivers.");
#line 1904
    return (-22);
  } else {

  }
#line 1907
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1908
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1908
  if (tmp___2 != 0L) {
#line 1909
    return (ret);
  } else {

  }
#line 1911
  ret = vmw_execbuf_process(file_priv, dev_priv, (void *)arg->commands, 0, arg->command_size,
                            (uint64_t )arg->throttle_us, (struct drm_vmw_fence_rep *)arg->fence_rep,
                            0);
#line 1917
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1917
  if (tmp___3 != 0L) {
#line 1918
    goto out_unlock;
  } else {

  }
#line 1920
  vmw_kms_cursor_post_execbuf(dev_priv);
  out_unlock: 
#line 1923
  ttm_read_unlock(& vmaster->lock);
#line 1924
  return (ret);
}
}
#line 1927 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1932
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1934
  mutex_lock(ldv_func_arg1);
#line 1935
  return;
}
}
#line 1937 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1942
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1944
  mutex_unlock(ldv_func_arg1);
#line 1945
  return;
}
}
#line 1947 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1952
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1954
  mutex_lock(ldv_func_arg1);
#line 1955
  return;
}
}
#line 1957 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1962
  tmp = mutex_trylock(ldv_func_arg1);
#line 1962
  ldv_func_res = tmp;
#line 1964
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1964
  return (tmp___0);
#line 1966
  return (ldv_func_res);
}
}
#line 1969 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1974
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1976
  mutex_unlock(ldv_func_arg1);
#line 1977
  return;
}
}
#line 1979 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1984
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1986
  mutex_lock(ldv_func_arg1);
#line 1987
  return;
}
}
#line 1989 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1994
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1996
  mutex_unlock(ldv_func_arg1);
#line 1997
  return;
}
}
#line 1999 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2004
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 2006
  mutex_lock(ldv_func_arg1);
#line 2007
  return;
}
}
#line 2009 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2014
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 2016
  mutex_unlock(ldv_func_arg1);
#line 2017
  return;
}
}
#line 2019 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2024
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 2026
  mutex_unlock(ldv_func_arg1);
#line 2027
  return;
}
}
#line 2029 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2034
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 2036
  mutex_lock(ldv_func_arg1);
#line 2037
  return;
}
}
#line 2039 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2044
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 2046
  mutex_unlock(ldv_func_arg1);
#line 2047
  return;
}
}
#line 2049 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2054
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 2056
  mutex_lock(ldv_func_arg1);
#line 2057
  return;
}
}
#line 2059 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2064
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 2066
  mutex_unlock(ldv_func_arg1);
#line 2067
  return;
}
}
#line 2069 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
int ldv_mutex_lock_interruptible_15(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2074
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 2074
  ldv_func_res = tmp;
#line 2076
  tmp___0 = ldv_mutex_lock_interruptible_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 2076
  return (tmp___0);
#line 2078
  return (ldv_func_res);
}
}
#line 2081 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2086
  ldv_mutex_unlock_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 2088
  mutex_unlock(ldv_func_arg1);
#line 2089
  return;
}
}
#line 2091 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2096
  ldv_mutex_unlock_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 2098
  mutex_unlock(ldv_func_arg1);
#line 2099
  return;
}
}
#line 2101 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2106
  ldv_mutex_lock_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 2108
  mutex_lock(ldv_func_arg1);
#line 2109
  return;
}
}
#line 2111 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c.prepared"
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2116
  ldv_mutex_unlock_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 2118
  mutex_unlock(ldv_func_arg1);
#line 2119
  return;
}
}
#line 88 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 34 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_42(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_40(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_45(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_47(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_48(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_52(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_54(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_56(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_41(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_44(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_46(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_53(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_55(struct mutex *ldv_func_arg1 ) ;
#line 83
void ldv_mutex_lock_hw_mutex_of_vmw_private(struct mutex *lock ) ;
#line 87
void ldv_mutex_unlock_hw_mutex_of_vmw_private(struct mutex *lock ) ;
#line 206 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/thread_info.h"
extern unsigned long kernel_stack ;
#line 208 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
#line 211
  switch (8UL) {
  case 1: 
#line 211
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_7803;
  case 2: 
#line 211
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_7803;
  case 4: 
#line 211
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_7803;
  case 8: 
#line 211
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_7803;
  default: 
#line 211
  __bad_percpu_size();
  }
  ldv_7803: 
#line 211
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
#line 213
  return (ti);
}
}
#line 310 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 

  {
#line 310
  __asm__  volatile   ("outl %0, %w1": : "a" (value), "Nd" (port));
#line 311
  return;
}
}
#line 329 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 332 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ struct page *tmp ;

  {
#line 334
  tmp = alloc_pages_current(gfp_mask, order);
#line 334
  return (tmp);
}
}
#line 365
extern void __free_pages(struct page * , unsigned int  ) ;
#line 771 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 

  {
#line 773
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 80L) << 12) + 0xffff880000000000UL));
}
}
#line 16 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ struct thread_info *tmp ;

  {
#line 18
  tmp = current_thread_info();
#line 18
  tmp->preempt_count = tmp->preempt_count + 1;
#line 23
  __asm__  volatile   ("": : : "memory");
#line 24
  return;
}
}
#line 26 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ struct thread_info *tmp ;

  {
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  tmp = current_thread_info();
#line 33
  tmp->preempt_count = tmp->preempt_count + -1;
#line 37
  __asm__  volatile   ("": : : "memory");
#line 38
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ void *tmp ;

  {
#line 68
  pagefault_disable();
#line 69
  tmp = lowmem_page_address((struct page  const  *)page);
#line 69
  return (tmp);
}
}
#line 73 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 

  {
#line 75
  pagefault_enable();
#line 76
  return;
}
}
#line 384 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_write(struct vmw_private *dev_priv , unsigned int offset ,
                               uint32_t value ) 
{ 

  {
#line 387
  outl(offset, (int )dev_priv->io_start);
#line 388
  outl(value, (int )(dev_priv->io_start + 1U));
#line 389
  return;
}
}
#line 408
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) ;
#line 412
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) ;
#line 186 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static int vmw_gmr2_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                         int gmr_id ) 
{ SVGAFifoCmdDefineGMR2 define_cmd ;
  SVGAFifoCmdRemapGMR2 remap_cmd ;
  uint32_t define_size ;
  uint32_t remap_size ;
  uint32_t *cmd ;
  uint32_t *cmd_orig ;
  uint32_t i ;
  void *tmp ;
  long tmp___0 ;
  uint32_t *tmp___1 ;
  size_t __len ;
  void *__ret ;
  uint32_t *tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct page **tmp___4 ;

  {
#line 193
  define_size = 12U;
#line 194
  remap_size = (uint32_t )(num_pages + 2UL) * 8U + 4U;
#line 199
  tmp = vmw_fifo_reserve(dev_priv, define_size + remap_size);
#line 199
  cmd = (uint32_t *)tmp;
#line 199
  cmd_orig = cmd;
#line 200
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint32_t *)0),
                             0L);
#line 200
  if (tmp___0 != 0L) {
#line 201
    return (-12);
  } else {

  }
#line 203
  define_cmd.gmrId = (uint32 )gmr_id;
#line 204
  define_cmd.numPages = (uint32 )num_pages;
#line 206
  remap_cmd.gmrId = (uint32 )gmr_id;
#line 207
  remap_cmd.flags = 2;
#line 209
  remap_cmd.offsetPages = 0U;
#line 210
  remap_cmd.numPages = (uint32 )num_pages;
#line 212
  tmp___1 = cmd;
#line 212
  cmd = cmd + 1;
#line 212
  *tmp___1 = 41U;
#line 213
  __len = 8UL;
#line 213
  if (__len > 63UL) {
#line 213
    __ret = __memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  } else {
#line 213
    __ret = __builtin_memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  }
#line 214
  cmd = cmd + 2UL;
#line 216
  tmp___2 = cmd;
#line 216
  cmd = cmd + 1;
#line 216
  *tmp___2 = 42U;
#line 217
  __len___0 = 16UL;
#line 217
  if (__len___0 > 63UL) {
#line 217
    __ret___0 = __memcpy((void *)cmd, (void const   *)(& remap_cmd), __len___0);
  } else {
#line 217
    __ret___0 = __builtin_memcpy((void *)cmd, (void const   *)(& remap_cmd), __len___0);
  }
#line 218
  cmd = cmd + 4UL;
#line 220
  i = 0U;
#line 220
  goto ldv_40607;
  ldv_40606: 
#line 224
  tmp___4 = pages;
#line 224
  pages = pages + 1;
#line 224
  *((uint64_t *)cmd) = (uint64_t )(((long )*tmp___4 + 24189255811072L) / 80L);
#line 226
  cmd = cmd + 2UL;
#line 220
  i = i + 1U;
  ldv_40607: ;
#line 220
  if ((unsigned long )i < num_pages) {
#line 221
    goto ldv_40606;
  } else {
#line 223
    goto ldv_40608;
  }
  ldv_40608: 
#line 229
  vmw_fifo_commit(dev_priv, define_size + remap_size);
#line 231
  return (0);
}
}
#line 234 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static void vmw_gmr2_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ SVGAFifoCmdDefineGMR2 define_cmd ;
  uint32_t define_size ;
  uint32_t *cmd ;
  void *tmp ;
  long tmp___0 ;
  uint32_t *tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 238
  define_size = 12U;
#line 241
  tmp = vmw_fifo_reserve(dev_priv, define_size);
#line 241
  cmd = (uint32_t *)tmp;
#line 242
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint32_t *)0),
                             0L);
#line 242
  if (tmp___0 != 0L) {
#line 243
    drm_err("vmw_gmr2_unbind", "GMR2 unbind failed.\n");
#line 244
    return;
  } else {

  }
#line 246
  define_cmd.gmrId = (uint32 )gmr_id;
#line 247
  define_cmd.numPages = 0U;
#line 249
  tmp___1 = cmd;
#line 249
  cmd = cmd + 1;
#line 249
  *tmp___1 = 41U;
#line 250
  __len = 8UL;
#line 250
  if (__len > 63UL) {
#line 250
    __ret = __memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  } else {
#line 250
    __ret = __builtin_memcpy((void *)cmd, (void const   *)(& define_cmd), __len);
  }
#line 252
  vmw_fifo_commit(dev_priv, define_size);
#line 253
  return;
}
}
#line 260 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static int vmw_gmr_build_descriptors(struct list_head *desc_pages , struct page **pages ,
                                     unsigned long num_pages ) 
{ struct page *page ;
  struct page *next ;
  struct svga_guest_mem_descriptor *page_virtual ;
  struct svga_guest_mem_descriptor *desc_virtual ;
  unsigned int desc_per_page ;
  unsigned long prev_pfn ;
  unsigned long pfn ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 265
  page_virtual = 0;
#line 266
  desc_virtual = 0;
#line 272
  desc_per_page = 511U;
#line 275
  goto ldv_40639;
  ldv_40638: 
#line 276
  page = alloc_pages(2U, 0U);
#line 277
  tmp = ldv__builtin_expect((unsigned long )page == (unsigned long )((struct page *)0),
                         0L);
#line 277
  if (tmp != 0L) {
#line 278
    ret = -12;
#line 279
    goto out_err;
  } else {

  }
#line 282
  list_add_tail(& page->ldv_21253.lru, desc_pages);
#line 289
  tmp___0 = ldv__builtin_expect((unsigned long )page_virtual != (unsigned long )((struct svga_guest_mem_descriptor *)0),
                             1L);
#line 289
  if (tmp___0 != 0L) {
#line 290
    desc_virtual->ppn = (__le32 )(((long )page + 24189255811072L) / 80L);
#line 291
    __kunmap_atomic((void *)page_virtual);
  } else {

  }
#line 294
  tmp___1 = kmap_atomic(page);
#line 294
  page_virtual = (struct svga_guest_mem_descriptor *)tmp___1;
#line 295
  desc_virtual = page_virtual + 0xffffffffffffffffUL;
#line 296
  prev_pfn = 0xffffffffffffffffUL;
#line 298
  goto ldv_40637;
  ldv_40636: 
#line 299
  pfn = (unsigned long )(((long )*pages + 24189255811072L) / 80L);
#line 301
  if (prev_pfn + 1UL != pfn) {
#line 303
    if (((long )desc_virtual - (long )page_virtual) / 8L == (long )(desc_per_page - 1U)) {
#line 305
      goto ldv_40634;
    } else {

    }
#line 307
    desc_virtual = desc_virtual + 1;
#line 307
    desc_virtual->ppn = (unsigned int )pfn;
#line 308
    desc_virtual->num_pages = 1U;
  } else {
#line 310
    tmp___2 = desc_virtual->num_pages;
#line 312
    desc_virtual->num_pages = tmp___2 + 1U;
  }
#line 314
  prev_pfn = pfn;
#line 315
  num_pages = num_pages - 1UL;
#line 316
  pages = pages + 1;
  ldv_40637: 
#line 298
  tmp___3 = ldv__builtin_expect(num_pages != 0UL, 1L);
#line 298
  if (tmp___3 != 0L) {
#line 299
    goto ldv_40636;
  } else {
#line 301
    goto ldv_40634;
  }
  ldv_40634: 
#line 319
  desc_virtual = desc_virtual + 1;
#line 319
  desc_virtual->ppn = 0U;
#line 320
  desc_virtual->num_pages = 0U;
  ldv_40639: 
#line 275
  tmp___4 = ldv__builtin_expect(num_pages != 0UL, 1L);
#line 275
  if (tmp___4 != 0L) {
#line 276
    goto ldv_40638;
  } else {
#line 278
    goto ldv_40640;
  }
  ldv_40640: 
#line 323
  tmp___5 = ldv__builtin_expect((unsigned long )page_virtual != (unsigned long )((struct svga_guest_mem_descriptor *)0),
                             1L);
#line 323
  if (tmp___5 != 0L) {
#line 324
    __kunmap_atomic((void *)page_virtual);
  } else {

  }
#line 326
  return (0);
  out_err: 
#line 328
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 328
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 328
  __mptr___0 = (struct list_head  const  *)page->ldv_21253.lru.next;
#line 328
  next = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
#line 328
  goto ldv_40648;
  ldv_40647: 
#line 329
  list_del_init(& page->ldv_21253.lru);
#line 330
  __free_pages(page, 0U);
#line 328
  page = next;
#line 328
  __mptr___1 = (struct list_head  const  *)next->ldv_21253.lru.next;
#line 328
  next = (struct page *)__mptr___1 + 0xffffffffffffffe0UL;
  ldv_40648: ;
#line 328
  if ((unsigned long )(& page->ldv_21253.lru) != (unsigned long )desc_pages) {
#line 329
    goto ldv_40647;
  } else {
#line 331
    goto ldv_40649;
  }
  ldv_40649: ;
#line 332
  return (ret);
}
}
#line 335 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
__inline static void vmw_gmr_free_descriptors(struct list_head *desc_pages ) 
{ struct page *page ;
  struct page *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 339
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 339
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 339
  __mptr___0 = (struct list_head  const  *)page->ldv_21253.lru.next;
#line 339
  next = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
#line 339
  goto ldv_40662;
  ldv_40661: 
#line 340
  list_del_init(& page->ldv_21253.lru);
#line 341
  __free_pages(page, 0U);
#line 339
  page = next;
#line 339
  __mptr___1 = (struct list_head  const  *)next->ldv_21253.lru.next;
#line 339
  next = (struct page *)__mptr___1 + 0xffffffffffffffe0UL;
  ldv_40662: ;
#line 339
  if ((unsigned long )(& page->ldv_21253.lru) != (unsigned long )desc_pages) {
#line 340
    goto ldv_40661;
  } else {
#line 342
    goto ldv_40663;
  }
  ldv_40663: ;
#line 344
  return;
}
}
#line 345 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static void vmw_gmr_fire_descriptors(struct vmw_private *dev_priv , int gmr_id , struct list_head *desc_pages ) 
{ struct page *page ;
  int tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;

  {
#line 350
  tmp = list_empty((struct list_head  const  *)desc_pages);
#line 350
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 350
  if (tmp___0 != 0L) {
#line 351
    return;
  } else {

  }
#line 353
  __mptr = (struct list_head  const  *)desc_pages->next;
#line 353
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 355
  ldv_mutex_lock_53(& dev_priv->hw_mutex);
#line 357
  vmw_write(dev_priv, 41U, (uint32_t )gmr_id);
#line 358
  __asm__  volatile   ("sfence": : : "memory");
#line 359
  vmw_write(dev_priv, 42U, (uint32_t )(((long )page + 24189255811072L) / 80L));
#line 360
  __asm__  volatile   ("mfence": : : "memory");
#line 362
  ldv_mutex_unlock_54(& dev_priv->hw_mutex);
#line 363
  return;
}
}
#line 371 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
static unsigned long vmw_gmr_count_descriptors(struct page **pages , unsigned long num_pages ) 
{ unsigned long prev_pfn ;
  unsigned long pfn ;
  unsigned long descriptors ;
  struct page **tmp ;
  unsigned long tmp___0 ;

  {
#line 374
  prev_pfn = 0xffffffffffffffffUL;
#line 376
  descriptors = 0UL;
#line 378
  goto ldv_40680;
  ldv_40679: 
#line 379
  tmp = pages;
#line 379
  pages = pages + 1;
#line 379
  pfn = (unsigned long )(((long )*tmp + 24189255811072L) / 80L);
#line 380
  if (prev_pfn + 1UL != pfn) {
#line 381
    descriptors = descriptors + 1UL;
  } else {

  }
#line 382
  prev_pfn = pfn;
  ldv_40680: 
#line 378
  tmp___0 = num_pages;
#line 378
  num_pages = num_pages - 1UL;
#line 378
  if (tmp___0 != 0UL) {
#line 379
    goto ldv_40679;
  } else {
#line 381
    goto ldv_40681;
  }
  ldv_40681: ;
#line 385
  return (descriptors);
}
}
#line 388 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
int vmw_gmr_bind(struct vmw_private *dev_priv , struct page **pages , unsigned long num_pages ,
                 int gmr_id ) 
{ struct list_head desc_pages ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;

  {
#line 396
  tmp___0 = ldv__builtin_expect((dev_priv->capabilities & 4194304U) != 0U, 1L);
#line 396
  if (tmp___0 != 0L) {
#line 397
    tmp = vmw_gmr2_bind(dev_priv, pages, num_pages, gmr_id);
#line 397
    return (tmp);
  } else {

  }
#line 399
  tmp___1 = ldv__builtin_expect((dev_priv->capabilities & 1048576U) == 0U, 0L);
#line 399
  if (tmp___1 != 0L) {
#line 400
    return (-22);
  } else {

  }
#line 402
  tmp___2 = vmw_gmr_count_descriptors(pages, num_pages);
#line 402
  if (tmp___2 > (unsigned long )dev_priv->max_gmr_descriptors) {
#line 404
    return (-22);
  } else {

  }
#line 406
  INIT_LIST_HEAD(& desc_pages);
#line 408
  ret = vmw_gmr_build_descriptors(& desc_pages, pages, num_pages);
#line 409
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 409
  if (tmp___3 != 0L) {
#line 410
    return (ret);
  } else {

  }
#line 412
  vmw_gmr_fire_descriptors(dev_priv, gmr_id, & desc_pages);
#line 413
  vmw_gmr_free_descriptors(& desc_pages);
#line 415
  return (0);
}
}
#line 419 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void vmw_gmr_unbind(struct vmw_private *dev_priv , int gmr_id ) 
{ long tmp ;

  {
#line 421
  tmp = ldv__builtin_expect((dev_priv->capabilities & 4194304U) != 0U, 1L);
#line 421
  if (tmp != 0L) {
#line 422
    vmw_gmr2_unbind(dev_priv, gmr_id);
#line 423
    return;
  } else {

  }
#line 426
  ldv_mutex_lock_55(& dev_priv->hw_mutex);
#line 427
  vmw_write(dev_priv, 41U, (uint32_t )gmr_id);
#line 428
  __asm__  volatile   ("sfence": : : "memory");
#line 429
  vmw_write(dev_priv, 42U, 0U);
#line 430
  __asm__  volatile   ("mfence": : : "memory");
#line 431
  ldv_mutex_unlock_56(& dev_priv->hw_mutex);
#line 432
  return;
}
}
#line 434 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 439
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 441
  mutex_lock(ldv_func_arg1);
#line 442
  return;
}
}
#line 444 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_40(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 449
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 451
  mutex_unlock(ldv_func_arg1);
#line 452
  return;
}
}
#line 454 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_41(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 459
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 461
  mutex_lock(ldv_func_arg1);
#line 462
  return;
}
}
#line 464 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
int ldv_mutex_trylock_42(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 469
  tmp = mutex_trylock(ldv_func_arg1);
#line 469
  ldv_func_res = tmp;
#line 471
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 471
  return (tmp___0);
#line 473
  return (ldv_func_res);
}
}
#line 476 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 481
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 483
  mutex_unlock(ldv_func_arg1);
#line 484
  return;
}
}
#line 486 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_44(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 491
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 493
  mutex_lock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_45(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 501
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 503
  mutex_unlock(ldv_func_arg1);
#line 504
  return;
}
}
#line 506 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_46(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 511
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 513
  mutex_lock(ldv_func_arg1);
#line 514
  return;
}
}
#line 516 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_47(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 521
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 523
  mutex_unlock(ldv_func_arg1);
#line 524
  return;
}
}
#line 526 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_48(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 531
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 533
  mutex_unlock(ldv_func_arg1);
#line 534
  return;
}
}
#line 536 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 541
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 543
  mutex_lock(ldv_func_arg1);
#line 544
  return;
}
}
#line 546 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 551
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 553
  mutex_unlock(ldv_func_arg1);
#line 554
  return;
}
}
#line 556 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 561
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 563
  mutex_lock(ldv_func_arg1);
#line 564
  return;
}
}
#line 566 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_52(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 571
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 573
  mutex_unlock(ldv_func_arg1);
#line 574
  return;
}
}
#line 576 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_53(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 581
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 583
  mutex_lock(ldv_func_arg1);
#line 584
  return;
}
}
#line 586 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_54(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 591
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 593
  mutex_unlock(ldv_func_arg1);
#line 594
  return;
}
}
#line 596 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_lock_55(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 601
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 603
  mutex_lock(ldv_func_arg1);
#line 604
  return;
}
}
#line 606 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmr.c.prepared"
void ldv_mutex_unlock_56(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 611
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 613
  mutex_unlock(ldv_func_arg1);
#line 614
  return;
}
}
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
#line 62
  __list_add(new, head, head->next);
#line 63
  return;
}
}
#line 153 "include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
#line 155
  __list_del_entry(list);
#line 156
  list_add(list, head);
#line 157
  return;
}
}
#line 22 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 

  {
#line 24
  return ((void *)error);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_78(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_79(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_84(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_86(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_99(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_75(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_80(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_82(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_85(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_87(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_98(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) ;
#line 75
void ldv_mutex_lock_fb_surf_mutex_of_vmw_master(struct mutex *lock ) ;
#line 79
void ldv_mutex_unlock_fb_surf_mutex_of_vmw_master(struct mutex *lock ) ;
#line 131
void ldv_mutex_lock_mutex_of_drm_mode_config(struct mutex *lock ) ;
#line 135
void ldv_mutex_unlock_mutex_of_drm_mode_config(struct mutex *lock ) ;
#line 181
int ldv_state_variable_20 ;
#line 183
int ldv_state_variable_19 ;
#line 187
int ldv_state_variable_21 ;
#line 193
int ref_cnt ;
#line 195
extern int __VERIFIER_nondet_int(void) ;
#line 31 "include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 310 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ unsigned int value ;

  {
#line 310
  __asm__  volatile   ("inl %w1, %0": "=a" (value): "Nd" (port));
#line 310
  return (value);
}
}
#line 314 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 316
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 317
    return (0);
  } else {

  }
#line 318
  tmp = __kmalloc(n * size, flags);
#line 318
  return (tmp);
}
}
#line 327 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 329
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 329
  return (tmp);
}
}
#line 129 "include/drm/drmP.h"
extern void drm_ut_debug_printk(unsigned int  , char const   * , char const   * ,
                                char const   *  , ...) ;
#line 848 "include/drm/drm_crtc.h"
extern void drm_crtc_cleanup(struct drm_crtc * ) ;
#line 855
extern void drm_connector_cleanup(struct drm_connector * ) ;
#line 872
extern void drm_encoder_cleanup(struct drm_encoder * ) ;
#line 886
extern void drm_mode_probed_add(struct drm_connector * , struct drm_display_mode * ) ;
#line 889
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device * , struct drm_display_mode  const  * ) ;
#line 892
extern void drm_mode_config_init(struct drm_device * ) ;
#line 894
extern void drm_mode_config_cleanup(struct drm_device * ) ;
#line 907
extern void drm_mode_destroy(struct drm_device * , struct drm_display_mode * ) ;
#line 917
extern int drm_mode_vrefresh(struct drm_display_mode  const  * ) ;
#line 920
extern void drm_mode_connector_list_update(struct drm_connector * ) ;
#line 932
extern int drm_framebuffer_init(struct drm_device * , struct drm_framebuffer * , struct drm_framebuffer_funcs  const  * ) ;
#line 938
extern void drm_framebuffer_cleanup(struct drm_framebuffer * ) ;
#line 977
extern struct drm_mode_object *drm_mode_object_find(struct drm_device * , uint32_t  ,
                                                    uint32_t  ) ;
#line 1070
extern void drm_fb_get_bpp_depth(uint32_t  , unsigned int * , int * ) ;
#line 1498 "include/drm/drmP.h"
extern struct drm_master *drm_master_get(struct drm_master * ) ;
#line 1499
extern void drm_master_put(struct drm_master ** ) ;
#line 636 "include/drm/ttm/ttm_bo_api.h"
__inline static void *ttm_kmap_obj_virtual(struct ttm_bo_kmap_obj *map , bool *is_iomem ) 
{ 

  {
#line 639
  *is_iomem = ((unsigned int )map->bo_kmap_type & 128U) != 0U;
#line 640
  return (map->virtual);
}
}
#line 660
extern int ttm_bo_kmap(struct ttm_buffer_object * , unsigned long  , unsigned long  ,
                       struct ttm_bo_kmap_obj * ) ;
#line 671
extern void ttm_bo_kunmap(struct ttm_bo_kmap_obj * ) ;
#line 829 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_bo_reserve(struct ttm_buffer_object * , bool  , bool  , bool  , uint32_t  ) ;
#line 870
extern void ttm_bo_unreserve(struct ttm_buffer_object * ) ;
#line 171 "include/drm/ttm/ttm_object.h"
extern struct ttm_base_object *ttm_base_object_lookup(struct ttm_object_file * , uint32_t  ) ;
#line 183
extern void ttm_base_object_unref(struct ttm_base_object ** ) ;
#line 114 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) ;
#line 391 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static uint32_t vmw_read(struct vmw_private *dev_priv , unsigned int offset ) 
{ uint32_t val ;

  {
#line 396
  outl(offset, (int )dev_priv->io_start);
#line 397
  val = inl((int )(dev_priv->io_start + 1U));
#line 398
  return (val);
}
}
#line 435
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) ;
#line 505
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) ;
#line 508
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) ;
#line 546
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) ;
#line 657
int vmw_kms_init(struct vmw_private *dev_priv ) ;
#line 658
int vmw_kms_close(struct vmw_private *dev_priv ) ;
#line 659
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) ;
#line 660
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) ;
#line 661
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 668
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) ;
#line 672
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) ;
#line 675
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) ;
#line 676
int vmw_enable_vblank(struct drm_device *dev , int crtc ) ;
#line 677
void vmw_disable_vblank(struct drm_device *dev , int crtc ) ;
#line 678
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) ;
#line 685
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) ;
#line 691
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 713
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) ;
#line 714
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) ;
#line 730 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static void vmw_surface_unreference(struct vmw_surface **srf ) 
{ struct vmw_surface *tmp_srf ;
  struct vmw_resource *res ;

  {
#line 732
  tmp_srf = *srf;
#line 733
  res = & tmp_srf->res;
#line 734
  *srf = 0;
#line 736
  vmw_resource_unreference(& res);
#line 737
  return;
}
}
#line 739 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_surface *vmw_surface_reference(struct vmw_surface *srf ) 
{ 

  {
#line 741
  vmw_resource_reference(& srf->res);
#line 742
  return (srf);
}
}
#line 757 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct vmw_dma_buffer *vmw_dmabuf_reference(struct vmw_dma_buffer *buf ) 
{ struct ttm_buffer_object *tmp ;

  {
#line 759
  tmp = ttm_bo_reference(& buf->base);
#line 759
  if ((unsigned long )tmp != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 760
    return (buf);
  } else {

  }
#line 761
  return (0);
}
}
#line 63 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h"
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) ;
#line 66
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) ;
#line 70
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) ;
#line 123
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) ;
#line 124
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) ;
#line 127
void vmw_du_crtc_save(struct drm_crtc *crtc ) ;
#line 128
void vmw_du_crtc_restore(struct drm_crtc *crtc ) ;
#line 129
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) ;
#line 132
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) ;
#line 134
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) ;
#line 135
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) ;
#line 136
void vmw_du_connector_save(struct drm_connector *connector ) ;
#line 137
void vmw_du_connector_restore(struct drm_connector *connector ) ;
#line 139
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) ;
#line 140
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) ;
#line 142
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) ;
#line 150
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) ;
#line 151
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) ;
#line 156
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) ;
#line 157
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) ;
#line 160
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
#line 162
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) ;
#line 196 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_clip_cliprects(struct drm_clip_rect *rects , int num_rects , struct vmw_clip_rect clip ,
                        SVGASignedRect *out_rects , int *out_num ) 
{ int i ;
  int k ;
  int x1 ;
  int __max1 ;
  int __max2 ;
  int tmp ;
  int y1 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___0 ;
  int x2 ;
  int __min1 ;
  int __min2 ;
  int tmp___1 ;
  int y2 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___2 ;

  {
#line 204
  i = 0;
#line 204
  k = 0;
#line 204
  goto ldv_40888;
  ldv_40887: 
#line 205
  __max1 = clip.x1;
#line 205
  __max2 = (int )(rects + (unsigned long )i)->x1;
#line 205
  if (__max1 > __max2) {
#line 205
    tmp = __max1;
  } else {
#line 205
    tmp = __max2;
  }
#line 205
  x1 = tmp;
#line 206
  __max1___0 = clip.y1;
#line 206
  __max2___0 = (int )(rects + (unsigned long )i)->y1;
#line 206
  if (__max1___0 > __max2___0) {
#line 206
    tmp___0 = __max1___0;
  } else {
#line 206
    tmp___0 = __max2___0;
  }
#line 206
  y1 = tmp___0;
#line 207
  __min1 = clip.x2;
#line 207
  __min2 = (int )(rects + (unsigned long )i)->x2;
#line 207
  if (__min1 < __min2) {
#line 207
    tmp___1 = __min1;
  } else {
#line 207
    tmp___1 = __min2;
  }
#line 207
  x2 = tmp___1;
#line 208
  __min1___0 = clip.y2;
#line 208
  __min2___0 = (int )(rects + (unsigned long )i)->y2;
#line 208
  if (__min1___0 < __min2___0) {
#line 208
    tmp___2 = __min1___0;
  } else {
#line 208
    tmp___2 = __min2___0;
  }
#line 208
  y2 = tmp___2;
#line 210
  if (x1 >= x2) {
#line 211
    goto ldv_40886;
  } else {

  }
#line 212
  if (y1 >= y2) {
#line 213
    goto ldv_40886;
  } else {

  }
#line 215
  (out_rects + (unsigned long )k)->left = x1;
#line 216
  (out_rects + (unsigned long )k)->top = y1;
#line 217
  (out_rects + (unsigned long )k)->right = x2;
#line 218
  (out_rects + (unsigned long )k)->bottom = y2;
#line 219
  k = k + 1;
  ldv_40886: 
#line 204
  i = i + 1;
  ldv_40888: ;
#line 204
  if (i < num_rects) {
#line 205
    goto ldv_40887;
  } else {
#line 207
    goto ldv_40889;
  }
  ldv_40889: 
#line 222
  *out_num = k;
#line 223
  return;
}
}
#line 225 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_display_unit_cleanup(struct vmw_display_unit *du ) 
{ 

  {
#line 227
  if ((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0)) {
#line 228
    vmw_surface_unreference(& du->cursor_surface);
  } else {

  }
#line 229
  if ((unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 230
    vmw_dmabuf_unreference(& du->cursor_dmabuf);
  } else {

  }
#line 231
  drm_crtc_cleanup(& du->crtc);
#line 232
  drm_encoder_cleanup(& du->encoder);
#line 233
  drm_connector_cleanup(& du->connector);
#line 234
  return;
}
}
#line 240 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_cursor_update_image(struct vmw_private *dev_priv , u32 *image , u32 width ,
                            u32 height , u32 hotspotX , u32 hotspotY ) 
{ struct __anonstruct_cmd_291___0 *cmd ;
  u32 image_size ;
  u32 cmd_size ;
  void *tmp ;
  long tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 248
  image_size = (width * height) * 4U;
#line 249
  cmd_size = image_size + 24U;
#line 251
  if ((unsigned long )image == (unsigned long )((u32 *)0)) {
#line 252
    return (-22);
  } else {

  }
#line 254
  tmp = vmw_fifo_reserve(dev_priv, cmd_size);
#line 254
  cmd = (struct __anonstruct_293 *)tmp;
#line 255
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_291___0 *)0),
                             0L);
#line 255
  if (tmp___0 != 0L) {
#line 256
    drm_err("vmw_cursor_update_image", "Fifo reserve failed.\n");
#line 257
    return (-12);
  } else {

  }
#line 260
  memset((void *)cmd, 0, 24UL);
#line 262
  __len = (size_t )image_size;
#line 262
  __ret = __builtin_memcpy((void *)cmd + 1U, (void const   *)image, __len);
#line 264
  cmd->cmd = 22U;
#line 265
  cmd->cursor.id = 0U;
#line 266
  cmd->cursor.width = width;
#line 267
  cmd->cursor.height = height;
#line 268
  cmd->cursor.hotspotX = hotspotX;
#line 269
  cmd->cursor.hotspotY = hotspotY;
#line 271
  vmw_fifo_commit(dev_priv, cmd_size);
#line 273
  return (0);
}
}
#line 276 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                             u32 width , u32 height , u32 hotspotX , u32 hotspotY ) 
{ struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  void *virtual ;
  bool dummy ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 288
  kmap_offset = 0UL;
#line 289
  kmap_num = ((unsigned long )((width * height) * 4U) + 4095UL) >> 12;
#line 291
  ret = ttm_bo_reserve(& dmabuf->base, 1, 0, 0, 0U);
#line 292
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 292
  if (tmp != 0L) {
#line 293
    drm_err("vmw_cursor_update_dmabuf", "reserve failed\n");
#line 294
    return (-22);
  } else {

  }
#line 297
  ret = ttm_bo_kmap(& dmabuf->base, kmap_offset, kmap_num, & map);
#line 298
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 298
  if (tmp___0 != 0L) {
#line 299
    goto err_unreserve;
  } else {

  }
#line 301
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
#line 302
  ret = vmw_cursor_update_image(dev_priv, (u32 *)virtual, width, height, hotspotX,
                                hotspotY);
#line 305
  ttm_bo_kunmap(& map);
  err_unreserve: 
#line 307
  ttm_bo_unreserve(& dmabuf->base);
#line 309
  return (ret);
}
}
#line 313 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_cursor_update_position(struct vmw_private *dev_priv , bool show , int x ,
                                int y ) 
{ __le32 *fifo_mem ;
  uint32_t count ;

  {
#line 316
  fifo_mem = dev_priv->mmio_virt;
#line 319
  iowrite32((u32 )show, (void *)fifo_mem + 9U);
#line 320
  iowrite32((u32 )x, (void *)fifo_mem + 10U);
#line 321
  iowrite32((u32 )y, (void *)fifo_mem + 11U);
#line 322
  count = ioread32((void *)fifo_mem + 12U);
#line 323
  count = count + 1U;
#line 323
  iowrite32(count, (void *)fifo_mem + 12U);
#line 324
  return;
}
}
#line 326 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv , uint32_t handle ,
                           uint32_t width , uint32_t height ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_display_unit *du ;
  struct drm_crtc  const  *__mptr ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *dmabuf ;
  int ret ;

  {
#line 329
  tmp = vmw_priv(crtc->dev);
#line 329
  dev_priv = tmp;
#line 330
  tmp___0 = vmw_fpriv(file_priv);
#line 330
  tfile = tmp___0->tfile;
#line 331
  __mptr = (struct drm_crtc  const  *)crtc;
#line 331
  du = (struct vmw_display_unit *)__mptr;
#line 332
  surface = 0;
#line 333
  dmabuf = 0;
#line 337
  if (handle != 0U && (width != 64U || height != 64U)) {
#line 338
    return (-22);
  } else {

  }
#line 340
  if (handle != 0U) {
#line 341
    ret = vmw_user_lookup_handle(dev_priv, tfile, handle, & surface, & dmabuf);
#line 343
    if (ret != 0) {
#line 344
      drm_err("vmw_du_crtc_cursor_set", "failed to find surface or dmabuf: %i\n",
              ret);
#line 345
      return (-22);
    } else {

    }
  } else {

  }
#line 350
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0) && (unsigned long )surface->snooper.image == (unsigned long )((uint32_t *)0)) {
#line 351
    drm_err("vmw_du_crtc_cursor_set", "surface not suitable for cursor\n");
#line 352
    vmw_surface_unreference(& surface);
#line 353
    return (-22);
  } else {

  }
#line 357
  if ((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0)) {
#line 358
    (du->cursor_surface)->snooper.crtc = 0;
#line 359
    vmw_surface_unreference(& du->cursor_surface);
  } else {

  }
#line 361
  if ((unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 362
    vmw_dmabuf_unreference(& du->cursor_dmabuf);
  } else {

  }
#line 365
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 367
    du->cursor_surface = surface;
#line 369
    (du->cursor_surface)->snooper.crtc = crtc;
#line 370
    du->cursor_age = (du->cursor_surface)->snooper.age;
#line 371
    vmw_cursor_update_image(dev_priv, surface->snooper.image, 64U, 64U, (u32 )du->hotspot_x,
                            (u32 )du->hotspot_y);
  } else
#line 373
  if ((unsigned long )dmabuf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 375
    du->cursor_dmabuf = dmabuf;
#line 377
    ret = vmw_cursor_update_dmabuf(dev_priv, dmabuf, width, height, (u32 )du->hotspot_x,
                                   (u32 )du->hotspot_y);
  } else {
#line 380
    vmw_cursor_update_position(dev_priv, 0, 0, 0);
#line 381
    return (0);
  }
#line 384
  vmw_cursor_update_position(dev_priv, 1, du->cursor_x + du->hotspot_x, du->cursor_y + du->hotspot_y);
#line 388
  return (0);
}
}
#line 391 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_display_unit *du ;
  struct drm_crtc  const  *__mptr ;
  bool shown ;

  {
#line 393
  tmp = vmw_priv(crtc->dev);
#line 393
  dev_priv = tmp;
#line 394
  __mptr = (struct drm_crtc  const  *)crtc;
#line 394
  du = (struct vmw_display_unit *)__mptr;
#line 395
  shown = (bool )((unsigned long )du->cursor_surface != (unsigned long )((struct vmw_surface *)0) || (unsigned long )du->cursor_dmabuf != (unsigned long )((struct vmw_dma_buffer *)0));
#line 397
  du->cursor_x = crtc->x + x;
#line 398
  du->cursor_y = crtc->y + y;
#line 400
  vmw_cursor_update_position(dev_priv, (int )shown, du->cursor_x + du->hotspot_x,
                             du->cursor_y + du->hotspot_y);
#line 404
  return (0);
}
}
#line 407 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_kms_cursor_snoop(struct vmw_surface *srf , struct ttm_object_file *tfile ,
                          struct ttm_buffer_object *bo , SVGA3dCmdHeader *header ) 
{ struct ttm_bo_kmap_obj map ;
  unsigned long kmap_offset ;
  unsigned long kmap_num ;
  SVGA3dCopyBox *box ;
  unsigned int box_count ;
  void *virtual ;
  bool dummy ;
  struct vmw_dma_cmd *cmd ;
  int i ;
  int ret ;
  SVGA3dCmdHeader const   *__mptr ;
  long tmp ;
  long tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 425
  __mptr = (SVGA3dCmdHeader const   *)header;
#line 425
  cmd = (struct vmw_dma_cmd *)__mptr;
#line 428
  if ((unsigned long )srf->snooper.image == (unsigned long )((uint32_t *)0)) {
#line 429
    return;
  } else {

  }
#line 431
  if (cmd->dma.host.face != 0U || cmd->dma.host.mipmap != 0U) {
#line 432
    drm_err("vmw_kms_cursor_snoop", "face and mipmap for cursors should never != 0\n");
#line 433
    return;
  } else {

  }
#line 436
  if (cmd->header.size <= 63U) {
#line 437
    drm_err("vmw_kms_cursor_snoop", "at least one full copy box must be given\n");
#line 438
    return;
  } else {

  }
#line 441
  box = (SVGA3dCopyBox *)cmd + 1U;
#line 442
  box_count = (unsigned int )(((unsigned long )cmd->header.size - 28UL) / 36UL);
#line 445
  if (((((((((cmd->dma.guest.ptr.offset & 4095U) != 0U || box->x != 0U) || box->y != 0U) || box->z != 0U) || box->srcx != 0U) || box->srcy != 0U) || box->srcz != 0U) || box->d != 1U) || box_count != 1U) {
#line 452
    drm_err("vmw_kms_cursor_snoop", "Cant snoop dma request for cursor!\n");
#line 453
    drm_err("vmw_kms_cursor_snoop", "(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",
            box->srcx, box->srcy, box->srcz, box->x, box->y, box->z, box->w, box->h,
            box->d, box_count, cmd->dma.guest.ptr.offset);
#line 458
    return;
  } else {

  }
#line 461
  kmap_offset = (unsigned long )(cmd->dma.guest.ptr.offset >> 12);
#line 462
  kmap_num = 4UL;
#line 464
  ret = ttm_bo_reserve(bo, 1, 0, 0, 0U);
#line 465
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 465
  if (tmp != 0L) {
#line 466
    drm_err("vmw_kms_cursor_snoop", "reserve failed\n");
#line 467
    return;
  } else {

  }
#line 470
  ret = ttm_bo_kmap(bo, kmap_offset, kmap_num, & map);
#line 471
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 471
  if (tmp___0 != 0L) {
#line 472
    goto err_unreserve;
  } else {

  }
#line 474
  virtual = ttm_kmap_obj_virtual(& map, & dummy);
#line 476
  if (box->w == 64U && cmd->dma.guest.pitch == 256U) {
#line 477
    __len = 16384UL;
#line 477
    if (__len > 63UL) {
#line 477
      __ret = __memcpy((void *)srf->snooper.image, (void const   *)virtual, __len);
    } else {
#line 477
      __ret = __builtin_memcpy((void *)srf->snooper.image, (void const   *)virtual,
                               __len);
    }
  } else {
#line 480
    i = 0;
#line 480
    goto ldv_40991;
    ldv_40990: 
#line 481
    __len___0 = (size_t )(box->w * 4U);
#line 481
    __ret___0 = __builtin_memcpy((void *)srf->snooper.image + (unsigned long )(i * 64),
                                 (void const   *)virtual + (unsigned long )(cmd->dma.guest.pitch * (uint32 )i),
                                 __len___0);
#line 480
    i = i + 1;
    ldv_40991: ;
#line 480
    if ((uint32 )i < box->h) {
#line 481
      goto ldv_40990;
    } else {
#line 483
      goto ldv_40992;
    }
    ldv_40992: ;
  }
#line 486
  srf->snooper.age = srf->snooper.age + 1UL;
#line 497
  ttm_bo_kunmap(& map);
  err_unreserve: 
#line 499
  ttm_bo_unreserve(bo);
#line 500
  return;
}
}
#line 502 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_crtc *crtc ;
  struct list_head  const  *__mptr ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 504
  dev = dev_priv->dev;
#line 508
  ldv_mutex_lock_89(& dev->mode_config.mutex);
#line 510
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 510
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 510
  goto ldv_41007;
  ldv_41006: 
#line 511
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 511
  du = (struct vmw_display_unit *)__mptr___0;
#line 512
  if ((unsigned long )du->cursor_surface == (unsigned long )((struct vmw_surface *)0) || du->cursor_age == (du->cursor_surface)->snooper.age) {
#line 514
    goto ldv_41005;
  } else {

  }
#line 516
  du->cursor_age = (du->cursor_surface)->snooper.age;
#line 517
  vmw_cursor_update_image(dev_priv, (du->cursor_surface)->snooper.image, 64U, 64U,
                          (u32 )du->hotspot_x, (u32 )du->hotspot_y);
  ldv_41005: 
#line 510
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 510
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_41007: ;
#line 510
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 511
    goto ldv_41006;
  } else {
#line 513
    goto ldv_41008;
  }
  ldv_41008: 
#line 522
  ldv_mutex_unlock_90(& dev->mode_config.mutex);
#line 523
  return;
}
}
#line 529 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                  unsigned int *handle ) 
{ 

  {
#line 533
  if ((unsigned long )handle != (unsigned long )((unsigned int *)0)) {
#line 534
    *handle = 0U;
  } else {

  }
#line 536
  return (0);
}
}
#line 554 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer ) 
{ struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer  const  *__mptr ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp ;

  {
#line 557
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 557
  vfbs = (struct vmw_framebuffer_surface *)__mptr;
#line 558
  tmp = vmw_master(vfbs->master);
#line 558
  vmaster = tmp;
#line 561
  ldv_mutex_lock_91(& vmaster->fb_surf_mutex);
#line 562
  list_del(& vfbs->head);
#line 563
  ldv_mutex_unlock_92(& vmaster->fb_surf_mutex);
#line 565
  drm_master_put(& vfbs->master);
#line 566
  drm_framebuffer_cleanup(framebuffer);
#line 567
  vmw_surface_unreference(& vfbs->surface);
#line 568
  ttm_base_object_unref(& vfbs->base.user_obj);
#line 570
  kfree((void const   *)vfbs);
#line 571
  return;
}
}
#line 573 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_surface_dirty_sou(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                struct vmw_framebuffer *framebuffer , unsigned int flags ,
                                unsigned int color , struct drm_clip_rect *clips ,
                                unsigned int num_clips , int inc , struct vmw_fence_obj **out_fence ) 
{ struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *clips_ptr ;
  struct drm_clip_rect *tmp ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_295 *cmd ;
  SVGASignedRect *blits ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  int __min1 ;
  int __min2 ;
  int tmp___7 ;
  int __max1 ;
  int __max2 ;
  int tmp___8 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___9 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___10 ;
  struct vmw_display_unit *unit ;
  struct vmw_clip_rect clip ;
  int num ;
  long tmp___11 ;

  {
#line 587
  ret = 0;
#line 596
  num_units = 0;
#line 597
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 597
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 597
  goto ldv_41063;
  ldv_41062: ;
#line 599
  if ((unsigned long )crtc->fb != (unsigned long )(& framebuffer->base)) {
#line 600
    goto ldv_41059;
  } else {

  }
#line 601
  tmp___0 = num_units;
#line 601
  num_units = num_units + 1;
#line 601
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 601
  units[tmp___0] = (struct vmw_display_unit *)__mptr___0;
  ldv_41059: 
#line 597
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 597
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_41063: ;
#line 597
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 598
    goto ldv_41062;
  } else {
#line 600
    goto ldv_41064;
  }
  ldv_41064: 
#line 604
  tmp___1 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 604
  if (tmp___1 != 0L) {
#line 604
    goto _L;
  } else {
#line 604
    tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 604
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
#line 604
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (604), "i" (12UL));
      ldv_41065: ;
#line 604
      goto ldv_41065;
    } else {

    }
  }
#line 606
  tmp___3 = kzalloc((unsigned long )num_clips * 8UL, 208U);
#line 606
  tmp = (struct drm_clip_rect *)tmp___3;
#line 607
  tmp___4 = ldv__builtin_expect((unsigned long )tmp == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 607
  if (tmp___4 != 0L) {
#line 608
    drm_err("do_surface_dirty_sou", "Temporary cliprect memory alloc failed.\n");
#line 609
    return (-12);
  } else {

  }
#line 612
  fifo_size = (unsigned long )num_clips * 16UL + 56UL;
#line 613
  tmp___5 = kzalloc(fifo_size, 208U);
#line 613
  cmd = (struct __anonstruct_297 *)tmp___5;
#line 614
  tmp___6 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_295 *)0),
                             0L);
#line 614
  if (tmp___6 != 0L) {
#line 615
    drm_err("do_surface_dirty_sou", "Temporary fifo memory alloc failed.\n");
#line 616
    ret = -12;
#line 617
    goto out_free_tmp;
  } else {

  }
#line 621
  blits = (SVGASignedRect *)cmd + 1U;
#line 624
  left = (int )clips->x1;
#line 625
  right = (int )clips->x2;
#line 626
  top = (int )clips->y1;
#line 627
  bottom = (int )clips->y2;
#line 630
  i = 1;
#line 630
  clips_ptr = clips + (unsigned long )inc;
#line 630
  goto ldv_41081;
  ldv_41080: 
#line 632
  __min1 = left;
#line 632
  __min2 = (int )clips_ptr->x1;
#line 632
  if (__min1 < __min2) {
#line 632
    tmp___7 = __min1;
  } else {
#line 632
    tmp___7 = __min2;
  }
#line 632
  left = tmp___7;
#line 633
  __max1 = right;
#line 633
  __max2 = (int )clips_ptr->x2;
#line 633
  if (__max1 > __max2) {
#line 633
    tmp___8 = __max1;
  } else {
#line 633
    tmp___8 = __max2;
  }
#line 633
  right = tmp___8;
#line 634
  __min1___0 = top;
#line 634
  __min2___0 = (int )clips_ptr->y1;
#line 634
  if (__min1___0 < __min2___0) {
#line 634
    tmp___9 = __min1___0;
  } else {
#line 634
    tmp___9 = __min2___0;
  }
#line 634
  top = tmp___9;
#line 635
  __max1___0 = bottom;
#line 635
  __max2___0 = (int )clips_ptr->y2;
#line 635
  if (__max1___0 > __max2___0) {
#line 635
    tmp___10 = __max1___0;
  } else {
#line 635
    tmp___10 = __max2___0;
  }
#line 635
  bottom = tmp___10;
#line 631
  i = i + 1;
#line 631
  clips_ptr = clips_ptr + (unsigned long )inc;
  ldv_41081: ;
#line 630
  if ((unsigned int )i < num_clips) {
#line 632
    goto ldv_41080;
  } else {
#line 634
    goto ldv_41082;
  }
  ldv_41082: 
#line 639
  cmd->header.id = 1069U;
#line 640
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 642
  cmd->body.srcRect.left = left;
#line 643
  cmd->body.srcRect.right = right;
#line 644
  cmd->body.srcRect.top = top;
#line 645
  cmd->body.srcRect.bottom = bottom;
#line 647
  clips_ptr = clips;
#line 648
  i = 0;
#line 648
  goto ldv_41084;
  ldv_41083: 
#line 649
  (tmp + (unsigned long )i)->x1 = (int )clips_ptr->x1 - (int )((unsigned short )left);
#line 650
  (tmp + (unsigned long )i)->x2 = (int )clips_ptr->x2 - (int )((unsigned short )left);
#line 651
  (tmp + (unsigned long )i)->y1 = (int )clips_ptr->y1 - (int )((unsigned short )top);
#line 652
  (tmp + (unsigned long )i)->y2 = (int )clips_ptr->y2 - (int )((unsigned short )top);
#line 648
  i = i + 1;
#line 648
  clips_ptr = clips_ptr + (unsigned long )inc;
  ldv_41084: ;
#line 648
  if ((unsigned int )i < num_clips) {
#line 649
    goto ldv_41083;
  } else {
#line 651
    goto ldv_41085;
  }
  ldv_41085: 
#line 656
  i = 0;
#line 656
  goto ldv_41092;
  ldv_41091: 
#line 657
  unit = units[i];
#line 661
  clip.x1 = left - unit->crtc.x;
#line 662
  clip.y1 = top - unit->crtc.y;
#line 663
  clip.x2 = right - unit->crtc.x;
#line 664
  clip.y2 = bottom - unit->crtc.y;
#line 667
  if (((clip.x1 >= unit->crtc.mode.hdisplay || clip.y1 >= unit->crtc.mode.vdisplay) || clip.x2 <= 0) || clip.y2 <= 0) {
#line 670
    goto ldv_41089;
  } else {

  }
#line 676
  cmd->body.destRect.left = clip.x1;
#line 677
  cmd->body.destRect.right = clip.x2;
#line 678
  cmd->body.destRect.top = clip.y1;
#line 679
  cmd->body.destRect.bottom = clip.y2;
#line 682
  clip.x2 = unit->crtc.mode.hdisplay - clip.x1;
#line 683
  clip.y2 = unit->crtc.mode.vdisplay - clip.y1;
#line 684
  clip.x1 = - clip.x1;
#line 685
  clip.y1 = - clip.y1;
#line 688
  cmd->body.srcImage.sid = framebuffer->user_handle;
#line 689
  cmd->body.destScreenId = unit->unit;
#line 692
  vmw_clip_cliprects(tmp, (int )num_clips, clip, blits, & num);
#line 695
  if (num == 0) {
#line 696
    goto ldv_41089;
  } else {

  }
#line 699
  if ((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0) && (unsigned long )*out_fence != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 700
    vmw_fence_obj_unreference(out_fence);
  } else {

  }
#line 703
  fifo_size = (unsigned long )num * 16UL + 56UL;
#line 704
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 705
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, out_fence);
#line 708
  tmp___11 = ldv__builtin_expect(ret != 0, 0L);
#line 708
  if (tmp___11 != 0L) {
#line 709
    goto ldv_41090;
  } else {

  }
  ldv_41089: 
#line 656
  i = i + 1;
  ldv_41092: ;
#line 656
  if (i < num_units) {
#line 657
    goto ldv_41091;
  } else {
#line 659
    goto ldv_41090;
  }
  ldv_41090: 
#line 713
  kfree((void const   *)cmd);
  out_free_tmp: 
#line 715
  kfree((void const   *)tmp);
#line 717
  return (ret);
}
}
#line 720 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_surface_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                  unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                  unsigned int num_clips ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct vmw_framebuffer_surface *vfbs ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int inc ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 726
  tmp = vmw_priv(framebuffer->dev);
#line 726
  dev_priv = tmp;
#line 727
  tmp___0 = vmw_master(file_priv->master);
#line 727
  vmaster = tmp___0;
#line 729
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 729
  vfbs = (struct vmw_framebuffer_surface *)__mptr;
#line 731
  inc = 1;
#line 733
  tmp___1 = ldv__builtin_expect((unsigned long )vfbs->master != (unsigned long )file_priv->master,
                             0L);
#line 733
  if (tmp___1 != 0L) {
#line 734
    return (-22);
  } else {

  }
#line 737
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 738
    return (-22);
  } else {

  }
#line 740
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 741
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 741
  if (tmp___2 != 0L) {
#line 742
    return (ret);
  } else {

  }
#line 744
  if (num_clips == 0U) {
#line 745
    num_clips = 1U;
#line 746
    clips = & norect;
#line 747
    norect.y1 = 0U;
#line 747
    norect.x1 = norect.y1;
#line 748
    norect.x2 = (unsigned short )framebuffer->width;
#line 749
    norect.y2 = (unsigned short )framebuffer->height;
  } else
#line 750
  if ((int )flags & 1) {
#line 751
    num_clips = num_clips / 2U;
#line 752
    inc = 2;
  } else {

  }
#line 755
  ret = do_surface_dirty_sou(dev_priv, file_priv, & vfbs->base, flags, color, clips,
                             num_clips, inc, 0);
#line 759
  ttm_read_unlock(& vmaster->lock);
#line 760
  return (0);
}
}
#line 763 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer_funcs vmw_framebuffer_surface_funcs  =    {& vmw_framebuffer_surface_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_surface_dirty};
#line 769 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv , struct drm_file *file_priv ,
                                           struct vmw_surface *surface , struct vmw_framebuffer **out ,
                                           struct drm_mode_fb_cmd  const  *mode_cmd ) 
{ struct drm_device *dev ;
  struct vmw_framebuffer_surface *vfbs ;
  enum SVGA3dSurfaceFormat format ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  struct vmw_surface *tmp___11 ;

  {
#line 777
  dev = dev_priv->dev;
#line 780
  tmp = vmw_master(file_priv->master);
#line 780
  vmaster = tmp;
#line 784
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 785
    return (-38);
  } else {

  }
#line 792
  tmp___0 = ldv__builtin_expect((long )(! surface->scanout), 0L);
#line 792
  if (tmp___0 != 0L) {
#line 793
    return (-22);
  } else {

  }
#line 795
  tmp___1 = ldv__builtin_expect(surface->mip_levels[0] != 1U, 0L);
#line 795
  if (tmp___1 != 0L) {
#line 795
    tmp___3 = 1;
  } else {
#line 795
    tmp___2 = ldv__builtin_expect(surface->num_sizes != 1U, 0L);
#line 795
    if (tmp___2 != 0L) {
#line 795
      tmp___3 = 1;
    } else {
#line 795
      tmp___3 = 0;
    }
  }
#line 795
  if (tmp___3 != 0) {
#line 795
    tmp___5 = 1;
  } else {
#line 795
    tmp___4 = ldv__builtin_expect((surface->sizes)->width < (uint32_t )mode_cmd->width,
                               0L);
#line 795
    if (tmp___4 != 0L) {
#line 795
      tmp___5 = 1;
    } else {
#line 795
      tmp___5 = 0;
    }
  }
#line 795
  if (tmp___5 != 0) {
#line 795
    tmp___7 = 1;
  } else {
#line 795
    tmp___6 = ldv__builtin_expect((surface->sizes)->height < (uint32_t )mode_cmd->height,
                               0L);
#line 795
    if (tmp___6 != 0L) {
#line 795
      tmp___7 = 1;
    } else {
#line 795
      tmp___7 = 0;
    }
  }
#line 795
  if (tmp___7 != 0) {
#line 800
    drm_err("vmw_kms_new_framebuffer_surface", "Incompatible surface dimensions for requested mode.\n");
#line 802
    return (-22);
  } else {
#line 795
    tmp___8 = ldv__builtin_expect((surface->sizes)->depth != 1U, 0L);
#line 795
    if (tmp___8 != 0L) {
#line 800
      drm_err("vmw_kms_new_framebuffer_surface", "Incompatible surface dimensions for requested mode.\n");
#line 802
      return (-22);
    } else {

    }
  }
#line 805
  switch (mode_cmd->depth) {
  case 32: 
#line 807
  format = 2;
#line 808
  goto ldv_41124;
  case 24: 
#line 810
  format = 1;
#line 811
  goto ldv_41124;
  case 16: 
#line 813
  format = 3;
#line 814
  goto ldv_41124;
  case 15: 
#line 816
  format = 5;
#line 817
  goto ldv_41124;
  case 8: 
#line 819
  format = 11;
#line 820
  goto ldv_41124;
  default: 
#line 822
  drm_err("vmw_kms_new_framebuffer_surface", "Invalid color depth: %d\n", mode_cmd->depth);
#line 823
  return (-22);
  }
  ldv_41124: 
#line 826
  tmp___9 = ldv__builtin_expect(surface->format != (unsigned int )format, 0L);
#line 826
  if (tmp___9 != 0L) {
#line 827
    drm_err("vmw_kms_new_framebuffer_surface", "Invalid surface format for requested mode.\n");
#line 828
    return (-22);
  } else {

  }
#line 831
  tmp___10 = kzalloc(216UL, 208U);
#line 831
  vfbs = (struct vmw_framebuffer_surface *)tmp___10;
#line 832
  if ((unsigned long )vfbs == (unsigned long )((struct vmw_framebuffer_surface *)0)) {
#line 833
    ret = -12;
#line 834
    goto out_err1;
  } else {

  }
#line 837
  ret = drm_framebuffer_init(dev, & vfbs->base.base, (struct drm_framebuffer_funcs  const  *)(& vmw_framebuffer_surface_funcs));
#line 839
  if (ret != 0) {
#line 840
    goto out_err2;
  } else {

  }
#line 842
  tmp___11 = vmw_surface_reference(surface);
#line 842
  if ((unsigned long )tmp___11 == (unsigned long )((struct vmw_surface *)0)) {
#line 843
    drm_err("vmw_kms_new_framebuffer_surface", "failed to reference surface %p\n",
            surface);
#line 844
    goto out_err3;
  } else {

  }
#line 848
  vfbs->base.base.bits_per_pixel = (int )mode_cmd->bpp;
#line 849
  vfbs->base.base.pitches[0] = mode_cmd->pitch;
#line 850
  vfbs->base.base.depth = mode_cmd->depth;
#line 851
  vfbs->base.base.width = mode_cmd->width;
#line 852
  vfbs->base.base.height = mode_cmd->height;
#line 853
  vfbs->surface = surface;
#line 854
  vfbs->base.user_handle = mode_cmd->handle;
#line 855
  vfbs->master = drm_master_get(file_priv->master);
#line 857
  ldv_mutex_lock_93(& vmaster->fb_surf_mutex);
#line 858
  list_add_tail(& vfbs->head, & vmaster->fb_surf);
#line 859
  ldv_mutex_unlock_94(& vmaster->fb_surf_mutex);
#line 861
  *out = & vfbs->base;
#line 863
  return (0);
  out_err3: 
#line 866
  drm_framebuffer_cleanup(& vfbs->base.base);
  out_err2: 
#line 868
  kfree((void const   *)vfbs);
  out_err1: ;
#line 870
  return (ret);
}
}
#line 885 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_framebuffer_dmabuf_destroy(struct drm_framebuffer *framebuffer ) 
{ struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;

  {
#line 888
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 888
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 890
  drm_framebuffer_cleanup(framebuffer);
#line 891
  vmw_dmabuf_unreference(& vfbd->buffer);
#line 892
  ttm_base_object_unref(& vfbd->base.user_obj);
#line 894
  kfree((void const   *)vfbd);
#line 895
  return;
}
}
#line 897 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_dirty_ldu(struct vmw_private *dev_priv , struct vmw_framebuffer *framebuffer ,
                               unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment ) 
{ size_t fifo_size ;
  int i ;
  struct __anonstruct_cmd_299 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 911
  fifo_size = (unsigned long )num_clips * 20UL;
#line 912
  tmp = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 912
  cmd = (struct __anonstruct_301 *)tmp;
#line 913
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_299 *)0),
                             0L);
#line 913
  if (tmp___0 != 0L) {
#line 914
    drm_err("do_dmabuf_dirty_ldu", "Fifo reserve failed.\n");
#line 915
    return (-12);
  } else {

  }
#line 918
  memset((void *)cmd, 0, fifo_size);
#line 919
  i = 0;
#line 919
  goto ldv_41159;
  ldv_41158: 
#line 920
  (cmd + (unsigned long )i)->header = 1U;
#line 921
  (cmd + (unsigned long )i)->body.x = (unsigned int )clips->x1;
#line 922
  (cmd + (unsigned long )i)->body.y = (unsigned int )clips->y1;
#line 923
  (cmd + (unsigned long )i)->body.width = (unsigned int )((int )clips->x2 - (int )clips->x1);
#line 924
  (cmd + (unsigned long )i)->body.height = (unsigned int )((int )clips->y2 - (int )clips->y1);
#line 919
  i = i + 1;
#line 919
  clips = clips + (unsigned long )increment;
  ldv_41159: ;
#line 919
  if ((unsigned int )i < num_clips) {
#line 920
    goto ldv_41158;
  } else {
#line 922
    goto ldv_41160;
  }
  ldv_41160: 
#line 927
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 928
  return (0);
}
}
#line 931 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_define_gmrfb(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                                  struct vmw_framebuffer *framebuffer ) 
{ int depth ;
  size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_303 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 935
  depth = (int )framebuffer->base.depth;
#line 948
  if (depth == 32) {
#line 949
    depth = 24;
  } else {

  }
#line 951
  fifo_size = 20UL;
#line 952
  tmp = kmalloc(fifo_size, 208U);
#line 952
  cmd = (struct __anonstruct_305 *)tmp;
#line 953
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_303 *)0),
                             0L);
#line 953
  if (tmp___0 != 0L) {
#line 954
    drm_err("do_dmabuf_define_gmrfb", "Failed to allocate temporary cmd buffer.\n");
#line 955
    return (-12);
  } else {

  }
#line 958
  memset((void *)cmd, 0, fifo_size);
#line 959
  cmd->header = 36U;
#line 960
  cmd->body.format.ldv_6465.ldv_6463.bitsPerPixel = (unsigned char )framebuffer->base.bits_per_pixel;
#line 961
  cmd->body.format.ldv_6465.ldv_6463.colorDepth = (unsigned char )depth;
#line 962
  cmd->body.format.ldv_6465.ldv_6463.reserved = 0U;
#line 963
  cmd->body.bytesPerLine = framebuffer->base.pitches[0];
#line 964
  cmd->body.ptr.gmrId = framebuffer->user_handle;
#line 965
  cmd->body.ptr.offset = 0U;
#line 967
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, 0);
#line 970
  kfree((void const   *)cmd);
#line 972
  return (ret);
}
}
#line 975 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int do_dmabuf_dirty_sou(struct drm_file *file_priv , struct vmw_private *dev_priv ,
                               struct vmw_framebuffer *framebuffer , unsigned int flags ,
                               unsigned int color , struct drm_clip_rect *clips ,
                               unsigned int num_clips , int increment , struct vmw_fence_obj **out_fence ) 
{ struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *clips_ptr ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  struct __anonstruct_blits_307 *blits ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct list_head  const  *__mptr ;
  int tmp___2 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct vmw_display_unit *unit ;
  int hit_num ;
  int clip_x1 ;
  int clip_y1 ;
  int clip_x2 ;
  int clip_y2 ;
  int move_x ;
  int move_y ;
  int __min1 ;
  int __min2 ;
  int tmp___3 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___4 ;
  int __min1___1 ;
  int __min2___1 ;
  int tmp___5 ;
  int __min1___2 ;
  int __min2___2 ;
  int tmp___6 ;
  long tmp___7 ;

  {
#line 994
  ret = do_dmabuf_define_gmrfb(file_priv, dev_priv, framebuffer);
#line 995
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 995
  if (tmp != 0L) {
#line 996
    return (ret);
  } else {

  }
#line 998
  fifo_size = (unsigned long )num_clips * 32UL;
#line 999
  tmp___0 = kmalloc(fifo_size, 208U);
#line 999
  blits = (struct __anonstruct_309 *)tmp___0;
#line 1000
  tmp___1 = ldv__builtin_expect((unsigned long )blits == (unsigned long )((struct __anonstruct_blits_307 *)0),
                             0L);
#line 1000
  if (tmp___1 != 0L) {
#line 1001
    drm_err("do_dmabuf_dirty_sou", "Failed to allocate temporary cmd buffer.\n");
#line 1002
    return (-12);
  } else {

  }
#line 1005
  num_units = 0;
#line 1006
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 1006
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 1006
  goto ldv_41206;
  ldv_41205: ;
#line 1007
  if ((unsigned long )crtc->fb != (unsigned long )(& framebuffer->base)) {
#line 1008
    goto ldv_41202;
  } else {

  }
#line 1009
  tmp___2 = num_units;
#line 1009
  num_units = num_units + 1;
#line 1009
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1009
  units[tmp___2] = (struct vmw_display_unit *)__mptr___0;
  ldv_41202: 
#line 1006
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 1006
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_41206: ;
#line 1006
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 1007
    goto ldv_41205;
  } else {
#line 1009
    goto ldv_41207;
  }
  ldv_41207: 
#line 1012
  k = 0;
#line 1012
  goto ldv_41235;
  ldv_41234: 
#line 1013
  unit = units[k];
#line 1014
  hit_num = 0;
#line 1016
  clips_ptr = clips;
#line 1017
  i = 0;
#line 1017
  goto ldv_41230;
  ldv_41229: 
#line 1018
  clip_x1 = (int )clips_ptr->x1 - unit->crtc.x;
#line 1019
  clip_y1 = (int )clips_ptr->y1 - unit->crtc.y;
#line 1020
  clip_x2 = (int )clips_ptr->x2 - unit->crtc.x;
#line 1021
  clip_y2 = (int )clips_ptr->y2 - unit->crtc.y;
#line 1025
  if (((unit->crtc.mode.hdisplay <= clip_x1 || unit->crtc.mode.vdisplay <= clip_y1) || clip_x2 <= 0) || clip_y2 <= 0) {
#line 1028
    goto ldv_41216;
  } else {

  }
#line 1031
  __min1 = clip_x2;
#line 1031
  __min2 = unit->crtc.mode.hdisplay;
#line 1031
  if (__min1 < __min2) {
#line 1031
    tmp___3 = __min1;
  } else {
#line 1031
    tmp___3 = __min2;
  }
#line 1031
  clip_x2 = tmp___3;
#line 1032
  __min1___0 = clip_y2;
#line 1032
  __min2___0 = unit->crtc.mode.vdisplay;
#line 1032
  if (__min1___0 < __min2___0) {
#line 1032
    tmp___4 = __min1___0;
  } else {
#line 1032
    tmp___4 = __min2___0;
  }
#line 1032
  clip_y2 = tmp___4;
#line 1035
  __min1___1 = clip_x1;
#line 1035
  __min2___1 = 0;
#line 1035
  if (__min1___1 < __min2___1) {
#line 1035
    tmp___5 = __min1___1;
  } else {
#line 1035
    tmp___5 = __min2___1;
  }
#line 1035
  move_x = tmp___5;
#line 1036
  __min1___2 = clip_y1;
#line 1036
  __min2___2 = 0;
#line 1036
  if (__min1___2 < __min2___2) {
#line 1036
    tmp___6 = __min1___2;
  } else {
#line 1036
    tmp___6 = __min2___2;
  }
#line 1036
  move_y = tmp___6;
#line 1039
  (blits + (unsigned long )hit_num)->header = 37U;
#line 1040
  (blits + (unsigned long )hit_num)->body.destScreenId = unit->unit;
#line 1041
  (blits + (unsigned long )hit_num)->body.srcOrigin.x = (int )clips_ptr->x1 - move_x;
#line 1042
  (blits + (unsigned long )hit_num)->body.srcOrigin.y = (int )clips_ptr->y1 - move_y;
#line 1043
  (blits + (unsigned long )hit_num)->body.destRect.left = clip_x1 - move_x;
#line 1044
  (blits + (unsigned long )hit_num)->body.destRect.top = clip_y1 - move_y;
#line 1045
  (blits + (unsigned long )hit_num)->body.destRect.right = clip_x2;
#line 1046
  (blits + (unsigned long )hit_num)->body.destRect.bottom = clip_y2;
#line 1047
  hit_num = hit_num + 1;
  ldv_41216: 
#line 1017
  i = i + 1;
#line 1017
  clips_ptr = clips_ptr + (unsigned long )increment;
  ldv_41230: ;
#line 1017
  if ((unsigned int )i < num_clips) {
#line 1018
    goto ldv_41229;
  } else {
#line 1020
    goto ldv_41231;
  }
  ldv_41231: ;
#line 1051
  if (hit_num == 0) {
#line 1052
    goto ldv_41232;
  } else {

  }
#line 1055
  if ((unsigned long )out_fence != (unsigned long )((struct vmw_fence_obj **)0) && (unsigned long )*out_fence != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1056
    vmw_fence_obj_unreference(out_fence);
  } else {

  }
#line 1058
  fifo_size = (unsigned long )hit_num * 32UL;
#line 1059
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)blits, (uint32_t )fifo_size,
                            0ULL, 0, out_fence);
#line 1062
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 1062
  if (tmp___7 != 0L) {
#line 1063
    goto ldv_41233;
  } else {

  }
  ldv_41232: 
#line 1012
  k = k + 1;
  ldv_41235: ;
#line 1012
  if (k < num_units) {
#line 1013
    goto ldv_41234;
  } else {
#line 1015
    goto ldv_41233;
  }
  ldv_41233: 
#line 1066
  kfree((void const   *)blits);
#line 1068
  return (ret);
}
}
#line 1071 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_framebuffer_dmabuf_dirty(struct drm_framebuffer *framebuffer , struct drm_file *file_priv ,
                                 unsigned int flags , unsigned int color , struct drm_clip_rect *clips ,
                                 unsigned int num_clips ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_clip_rect norect ;
  int ret ;
  int increment ;
  long tmp___1 ;

  {
#line 1077
  tmp = vmw_priv(framebuffer->dev);
#line 1077
  dev_priv = tmp;
#line 1078
  tmp___0 = vmw_master(file_priv->master);
#line 1078
  vmaster = tmp___0;
#line 1080
  __mptr = (struct drm_framebuffer  const  *)framebuffer;
#line 1080
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1082
  increment = 1;
#line 1084
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 1085
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1085
  if (tmp___1 != 0L) {
#line 1086
    return (ret);
  } else {

  }
#line 1088
  if (num_clips == 0U) {
#line 1089
    num_clips = 1U;
#line 1090
    clips = & norect;
#line 1091
    norect.y1 = 0U;
#line 1091
    norect.x1 = norect.y1;
#line 1092
    norect.x2 = (unsigned short )framebuffer->width;
#line 1093
    norect.y2 = (unsigned short )framebuffer->height;
  } else
#line 1094
  if ((int )flags & 1) {
#line 1095
    num_clips = num_clips / 2U;
#line 1096
    increment = 2;
  } else {

  }
#line 1099
  if ((unsigned long )dev_priv->ldu_priv != (unsigned long )((struct vmw_legacy_display *)0)) {
#line 1100
    ret = do_dmabuf_dirty_ldu(dev_priv, & vfbd->base, flags, color, clips, num_clips,
                              increment);
  } else {
#line 1104
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, & vfbd->base, flags, color, clips,
                              num_clips, increment, 0);
  }
#line 1109
  ttm_read_unlock(& vmaster->lock);
#line 1110
  return (ret);
}
}
#line 1113 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer_funcs vmw_framebuffer_dmabuf_funcs  =    {& vmw_framebuffer_dmabuf_destroy, & vmw_framebuffer_create_handle, & vmw_framebuffer_dmabuf_dirty};
#line 1122 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_framebuffer_dmabuf_pin(struct vmw_framebuffer *vfb ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  int ret ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
#line 1124
  tmp = vmw_priv(vfb->base.dev);
#line 1124
  dev_priv = tmp;
#line 1126
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1126
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1130
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0),
                             0L);
#line 1130
  if (tmp___0 != 0L) {
#line 1130
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1130), "i" (12UL));
    ldv_41261: ;
#line 1130
    goto ldv_41261;
  } else {

  }
#line 1132
  vmw_overlay_pause_all(dev_priv);
#line 1134
  ret = vmw_dmabuf_to_start_of_vram(dev_priv, vfbd->buffer, 1, 0);
#line 1136
  vmw_overlay_resume_all(dev_priv);
#line 1138
  __ret_warn_on = ret != 0;
#line 1138
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1138
  if (tmp___1 != 0L) {
#line 1138
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared",
                       1138);
  } else {

  }
#line 1138
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1140
  return (0);
}
}
#line 1143 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_framebuffer_dmabuf_unpin(struct vmw_framebuffer *vfb ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  int __ret_warn_on ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1145
  tmp = vmw_priv(vfb->base.dev);
#line 1145
  dev_priv = tmp;
#line 1147
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1147
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1149
  if ((unsigned long )vfbd->buffer == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1150
    __ret_warn_on = (unsigned long )vfbd->buffer == (unsigned long )((struct vmw_dma_buffer *)0);
#line 1150
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1150
    if (tmp___0 != 0L) {
#line 1150
      warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared",
                         1150);
    } else {

    }
#line 1150
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1151
    return (0);
  } else {

  }
#line 1154
  tmp___1 = vmw_dmabuf_unpin(dev_priv, vfbd->buffer, 0);
#line 1154
  return (tmp___1);
}
}
#line 1157 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static int vmw_kms_new_framebuffer_dmabuf(struct vmw_private *dev_priv , struct vmw_dma_buffer *dmabuf ,
                                          struct vmw_framebuffer **out , struct drm_mode_fb_cmd  const  *mode_cmd ) 
{ struct drm_device *dev ;
  struct vmw_framebuffer_dmabuf *vfbd ;
  unsigned int requested_size ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  struct vmw_dma_buffer *tmp___1 ;

  {
#line 1164
  dev = dev_priv->dev;
#line 1169
  requested_size = (unsigned int )mode_cmd->height * (unsigned int )mode_cmd->pitch;
#line 1170
  tmp = ldv__builtin_expect((unsigned long )requested_size > dmabuf->base.num_pages * 4096UL,
                         0L);
#line 1170
  if (tmp != 0L) {
#line 1171
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Screen buffer object size is too small for requested mode.\n");
#line 1173
    return (-22);
  } else {

  }
#line 1177
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1178
    switch (mode_cmd->depth) {
    case 32: ;
    case 24: ;
#line 1182
    if ((unsigned int )mode_cmd->bpp == 32U) {
#line 1183
      goto ldv_41286;
    } else {

    }
#line 1185
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
            mode_cmd->depth, mode_cmd->bpp);
#line 1187
    return (-22);
    case 16: ;
    case 15: ;
#line 1191
    if ((unsigned int )mode_cmd->bpp == 16U) {
#line 1192
      goto ldv_41286;
    } else {

    }
#line 1194
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth/bbp: %d %d\n",
            mode_cmd->depth, mode_cmd->bpp);
#line 1196
    return (-22);
    default: 
#line 1198
    drm_err("vmw_kms_new_framebuffer_dmabuf", "Invalid color depth: %d\n", mode_cmd->depth);
#line 1199
    return (-22);
    }
    ldv_41286: ;
  } else {

  }
#line 1203
  tmp___0 = kzalloc(184UL, 208U);
#line 1203
  vfbd = (struct vmw_framebuffer_dmabuf *)tmp___0;
#line 1204
  if ((unsigned long )vfbd == (unsigned long )((struct vmw_framebuffer_dmabuf *)0)) {
#line 1205
    ret = -12;
#line 1206
    goto out_err1;
  } else {

  }
#line 1209
  ret = drm_framebuffer_init(dev, & vfbd->base.base, (struct drm_framebuffer_funcs  const  *)(& vmw_framebuffer_dmabuf_funcs));
#line 1211
  if (ret != 0) {
#line 1212
    goto out_err2;
  } else {

  }
#line 1214
  tmp___1 = vmw_dmabuf_reference(dmabuf);
#line 1214
  if ((unsigned long )tmp___1 == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1215
    drm_err("vmw_kms_new_framebuffer_dmabuf", "failed to reference dmabuf %p\n", dmabuf);
#line 1216
    goto out_err3;
  } else {

  }
#line 1219
  vfbd->base.base.bits_per_pixel = (int )mode_cmd->bpp;
#line 1220
  vfbd->base.base.pitches[0] = mode_cmd->pitch;
#line 1221
  vfbd->base.base.depth = mode_cmd->depth;
#line 1222
  vfbd->base.base.width = mode_cmd->width;
#line 1223
  vfbd->base.base.height = mode_cmd->height;
#line 1224
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1225
    vfbd->base.pin = & vmw_framebuffer_dmabuf_pin;
#line 1226
    vfbd->base.unpin = & vmw_framebuffer_dmabuf_unpin;
  } else {

  }
#line 1228
  vfbd->base.dmabuf = 1;
#line 1229
  vfbd->buffer = dmabuf;
#line 1230
  vfbd->base.user_handle = mode_cmd->handle;
#line 1231
  *out = & vfbd->base;
#line 1233
  return (0);
  out_err3: 
#line 1236
  drm_framebuffer_cleanup(& vfbd->base.base);
  out_err2: 
#line 1238
  kfree((void const   *)vfbd);
  out_err1: ;
#line 1240
  return (ret);
}
}
#line 1247 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev , struct drm_file *file_priv ,
                                                 struct drm_mode_fb_cmd2 *mode_cmd2 ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_framebuffer *vfb ;
  struct vmw_surface *surface ;
  struct vmw_dma_buffer *bo ;
  struct ttm_base_object *user_obj ;
  struct drm_mode_fb_cmd mode_cmd ;
  int ret ;
  void *tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;

  {
#line 1251
  tmp = vmw_priv(dev);
#line 1251
  dev_priv = tmp;
#line 1252
  tmp___0 = vmw_fpriv(file_priv);
#line 1252
  tfile = tmp___0->tfile;
#line 1253
  vfb = 0;
#line 1254
  surface = 0;
#line 1255
  bo = 0;
#line 1260
  mode_cmd.width = mode_cmd2->width;
#line 1261
  mode_cmd.height = mode_cmd2->height;
#line 1262
  mode_cmd.pitch = mode_cmd2->pitches[0];
#line 1263
  mode_cmd.handle = mode_cmd2->handles[0];
#line 1264
  drm_fb_get_bpp_depth(mode_cmd2->pixel_format, & mode_cmd.depth, (int *)(& mode_cmd.bpp));
#line 1273
  tmp___2 = vmw_kms_validate_mode_vram(dev_priv, mode_cmd.pitch, mode_cmd.height);
#line 1273
  if (tmp___2) {
#line 1273
    tmp___3 = 0;
  } else {
#line 1273
    tmp___3 = 1;
  }
#line 1273
  if (tmp___3) {
#line 1276
    drm_err("vmw_kms_fb_create", "VRAM size is too small for requested mode.\n");
#line 1277
    tmp___1 = ERR_PTR(-12L);
#line 1277
    return ((struct drm_framebuffer *)tmp___1);
  } else {

  }
#line 1289
  user_obj = ttm_base_object_lookup(tfile, mode_cmd.handle);
#line 1290
  tmp___5 = ldv__builtin_expect((unsigned long )user_obj == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 1290
  if (tmp___5 != 0L) {
#line 1291
    drm_err("vmw_kms_fb_create", "Could not locate requested kms frame buffer.\n");
#line 1292
    tmp___4 = ERR_PTR(-2L);
#line 1292
    return ((struct drm_framebuffer *)tmp___4);
  } else {

  }
#line 1300
  ret = vmw_user_lookup_handle(dev_priv, tfile, mode_cmd.handle, & surface, & bo);
#line 1303
  if (ret != 0) {
#line 1304
    goto err_out;
  } else {

  }
#line 1307
  if ((unsigned long )bo != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1308
    ret = vmw_kms_new_framebuffer_dmabuf(dev_priv, bo, & vfb, (struct drm_mode_fb_cmd  const  *)(& mode_cmd));
  } else
#line 1310
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 1311
    ret = vmw_kms_new_framebuffer_surface(dev_priv, file_priv, surface, & vfb, (struct drm_mode_fb_cmd  const  *)(& mode_cmd));
  } else {
#line 1314
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1314), "i" (12UL));
    ldv_41308: ;
#line 1314
    goto ldv_41308;
  }
  err_out: ;
#line 1318
  if ((unsigned long )bo != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1319
    vmw_dmabuf_unreference(& bo);
  } else {

  }
#line 1320
  if ((unsigned long )surface != (unsigned long )((struct vmw_surface *)0)) {
#line 1321
    vmw_surface_unreference(& surface);
  } else {

  }
#line 1323
  if (ret != 0) {
#line 1324
    drm_err("vmw_kms_fb_create", "failed to create vmw_framebuffer: %i\n", ret);
#line 1325
    ttm_base_object_unref(& user_obj);
#line 1326
    tmp___6 = ERR_PTR((long )ret);
#line 1326
    return ((struct drm_framebuffer *)tmp___6);
  } else {
#line 1328
    vfb->user_obj = user_obj;
  }
#line 1330
  return (& vfb->base);
}
}
#line 1333 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_mode_config_funcs  const  vmw_kms_funcs  =    {& vmw_kms_fb_create, 0};
#line 1337 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_present(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                    struct vmw_surface *surface , uint32_t sid , int32_t destX , int32_t destY ,
                    struct drm_vmw_rect *clips , uint32_t num_clips ) 
{ struct vmw_display_unit *units[8U] ;
  struct drm_clip_rect *tmp ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int num_units ;
  int ret ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  struct __anonstruct_cmd_311 *cmd ;
  SVGASignedRect *blits ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  int __min1 ;
  int __min2 ;
  int tmp___8 ;
  int __max1 ;
  int __max2 ;
  int tmp___9 ;
  int __min1___0 ;
  int __min2___0 ;
  int tmp___10 ;
  int __max1___0 ;
  int __max2___0 ;
  int tmp___11 ;
  struct vmw_display_unit *unit ;
  struct vmw_clip_rect clip ;
  int num ;
  long tmp___12 ;

  {
#line 1351
  ret = 0;
#line 1360
  num_units = 0;
#line 1361
  __mptr = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 1361
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 1361
  goto ldv_41346;
  ldv_41345: ;
#line 1362
  if ((unsigned long )crtc->fb != (unsigned long )(& vfb->base)) {
#line 1363
    goto ldv_41342;
  } else {

  }
#line 1364
  tmp___0 = num_units;
#line 1364
  num_units = num_units + 1;
#line 1364
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1364
  units[tmp___0] = (struct vmw_display_unit *)__mptr___0;
  ldv_41342: 
#line 1361
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 1361
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_41346: ;
#line 1361
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 1362
    goto ldv_41345;
  } else {
#line 1364
    goto ldv_41347;
  }
  ldv_41347: 
#line 1367
  tmp___1 = ldv__builtin_expect((unsigned long )surface == (unsigned long )((struct vmw_surface *)0),
                             0L);
#line 1367
  if (tmp___1 != 0L) {
#line 1367
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1367), "i" (12UL));
    ldv_41348: ;
#line 1367
    goto ldv_41348;
  } else {

  }
#line 1368
  tmp___2 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 1368
  if (tmp___2 != 0L) {
#line 1368
    goto _L;
  } else {
#line 1368
    tmp___3 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 1368
    if (tmp___3 != 0L) {
      _L: /* CIL Label */ 
#line 1368
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (1368), "i" (12UL));
      ldv_41349: ;
#line 1368
      goto ldv_41349;
    } else {

    }
  }
#line 1370
  tmp___4 = kzalloc((unsigned long )num_clips * 8UL, 208U);
#line 1370
  tmp = (struct drm_clip_rect *)tmp___4;
#line 1371
  tmp___5 = ldv__builtin_expect((unsigned long )tmp == (unsigned long )((struct drm_clip_rect *)0),
                             0L);
#line 1371
  if (tmp___5 != 0L) {
#line 1372
    drm_err("vmw_kms_present", "Temporary cliprect memory alloc failed.\n");
#line 1373
    return (-12);
  } else {

  }
#line 1376
  fifo_size = (unsigned long )num_clips * 16UL + 56UL;
#line 1377
  tmp___6 = kmalloc(fifo_size, 208U);
#line 1377
  cmd = (struct __anonstruct_313 *)tmp___6;
#line 1378
  tmp___7 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_311 *)0),
                             0L);
#line 1378
  if (tmp___7 != 0L) {
#line 1379
    drm_err("vmw_kms_present", "Failed to allocate temporary fifo memory.\n");
#line 1380
    ret = -12;
#line 1381
    goto out_free_tmp;
  } else {

  }
#line 1384
  left = clips->x;
#line 1385
  right = (int )((uint32_t )clips->x + clips->w);
#line 1386
  top = clips->y;
#line 1387
  bottom = (int )((uint32_t )clips->y + clips->h);
#line 1389
  i = 1;
#line 1389
  goto ldv_41365;
  ldv_41364: 
#line 1390
  __min1 = left;
#line 1390
  __min2 = (clips + (unsigned long )i)->x;
#line 1390
  if (__min1 < __min2) {
#line 1390
    tmp___8 = __min1;
  } else {
#line 1390
    tmp___8 = __min2;
  }
#line 1390
  left = tmp___8;
#line 1391
  __max1 = right;
#line 1391
  __max2 = (int )((uint32_t )(clips + (unsigned long )i)->x + (clips + (unsigned long )i)->w);
#line 1391
  if (__max1 > __max2) {
#line 1391
    tmp___9 = __max1;
  } else {
#line 1391
    tmp___9 = __max2;
  }
#line 1391
  right = tmp___9;
#line 1392
  __min1___0 = top;
#line 1392
  __min2___0 = (clips + (unsigned long )i)->y;
#line 1392
  if (__min1___0 < __min2___0) {
#line 1392
    tmp___10 = __min1___0;
  } else {
#line 1392
    tmp___10 = __min2___0;
  }
#line 1392
  top = tmp___10;
#line 1393
  __max1___0 = bottom;
#line 1393
  __max2___0 = (int )((uint32_t )(clips + (unsigned long )i)->y + (clips + (unsigned long )i)->h);
#line 1393
  if (__max1___0 > __max2___0) {
#line 1393
    tmp___11 = __max1___0;
  } else {
#line 1393
    tmp___11 = __max2___0;
  }
#line 1393
  bottom = tmp___11;
#line 1389
  i = i + 1;
  ldv_41365: ;
#line 1389
  if ((uint32_t )i < num_clips) {
#line 1390
    goto ldv_41364;
  } else {
#line 1392
    goto ldv_41366;
  }
  ldv_41366: 
#line 1397
  memset((void *)cmd, 0, fifo_size);
#line 1398
  cmd->header.id = 1069U;
#line 1400
  blits = (SVGASignedRect *)cmd + 1U;
#line 1402
  cmd->body.srcRect.left = left;
#line 1403
  cmd->body.srcRect.right = right;
#line 1404
  cmd->body.srcRect.top = top;
#line 1405
  cmd->body.srcRect.bottom = bottom;
#line 1407
  i = 0;
#line 1407
  goto ldv_41368;
  ldv_41367: 
#line 1408
  (tmp + (unsigned long )i)->x1 = (int )((unsigned short )(clips + (unsigned long )i)->x) - (int )((unsigned short )left);
#line 1409
  (tmp + (unsigned long )i)->x2 = ((int )((unsigned short )(clips + (unsigned long )i)->x) + (int )((unsigned short )(clips + (unsigned long )i)->w)) - (int )((unsigned short )left);
#line 1410
  (tmp + (unsigned long )i)->y1 = (int )((unsigned short )(clips + (unsigned long )i)->y) - (int )((unsigned short )top);
#line 1411
  (tmp + (unsigned long )i)->y2 = ((int )((unsigned short )(clips + (unsigned long )i)->y) + (int )((unsigned short )(clips + (unsigned long )i)->h)) - (int )((unsigned short )top);
#line 1407
  i = i + 1;
  ldv_41368: ;
#line 1407
  if ((uint32_t )i < num_clips) {
#line 1408
    goto ldv_41367;
  } else {
#line 1410
    goto ldv_41369;
  }
  ldv_41369: 
#line 1414
  k = 0;
#line 1414
  goto ldv_41376;
  ldv_41375: 
#line 1415
  unit = units[k];
#line 1419
  clip.x1 = (left + destX) - unit->crtc.x;
#line 1420
  clip.y1 = (top + destY) - unit->crtc.y;
#line 1421
  clip.x2 = (right + destX) - unit->crtc.x;
#line 1422
  clip.y2 = (bottom + destY) - unit->crtc.y;
#line 1425
  if (((clip.x1 >= unit->crtc.mode.hdisplay || clip.y1 >= unit->crtc.mode.vdisplay) || clip.x2 <= 0) || clip.y2 <= 0) {
#line 1428
    goto ldv_41373;
  } else {

  }
#line 1434
  cmd->body.destRect.left = clip.x1;
#line 1435
  cmd->body.destRect.right = clip.x2;
#line 1436
  cmd->body.destRect.top = clip.y1;
#line 1437
  cmd->body.destRect.bottom = clip.y2;
#line 1440
  clip.x2 = unit->crtc.mode.hdisplay - clip.x1;
#line 1441
  clip.y2 = unit->crtc.mode.vdisplay - clip.y1;
#line 1442
  clip.x1 = - clip.x1;
#line 1443
  clip.y1 = - clip.y1;
#line 1446
  cmd->body.srcImage.sid = sid;
#line 1447
  cmd->body.destScreenId = unit->unit;
#line 1450
  vmw_clip_cliprects(tmp, (int )num_clips, clip, blits, & num);
#line 1453
  if (num == 0) {
#line 1454
    goto ldv_41373;
  } else {

  }
#line 1457
  fifo_size = (unsigned long )num * 16UL + 56UL;
#line 1458
  cmd->header.size = (unsigned int )fifo_size - 8U;
#line 1459
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, 0, 0);
#line 1462
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 1462
  if (tmp___12 != 0L) {
#line 1463
    goto ldv_41374;
  } else {

  }
  ldv_41373: 
#line 1414
  k = k + 1;
  ldv_41376: ;
#line 1414
  if (k < num_units) {
#line 1415
    goto ldv_41375;
  } else {
#line 1417
    goto ldv_41374;
  }
  ldv_41374: 
#line 1466
  kfree((void const   *)cmd);
  out_free_tmp: 
#line 1468
  kfree((void const   *)tmp);
#line 1470
  return (ret);
}
}
#line 1473 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_readback(struct vmw_private *dev_priv , struct drm_file *file_priv , struct vmw_framebuffer *vfb ,
                     struct drm_vmw_fence_rep *user_fence_rep , struct drm_vmw_rect *clips ,
                     uint32_t num_clips ) 
{ struct vmw_framebuffer_dmabuf *vfbd ;
  struct drm_framebuffer  const  *__mptr ;
  struct vmw_dma_buffer *dmabuf ;
  struct vmw_display_unit *units[8U] ;
  struct drm_crtc *crtc ;
  size_t fifo_size ;
  int i ;
  int k ;
  int ret ;
  int num_units ;
  int blits_pos ;
  struct __anonstruct_cmd_315 *cmd ;
  struct __anonstruct_blits_317 *blits ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  struct drm_crtc  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  struct drm_vmw_rect *c ;
  int clip_x1 ;
  int clip_x2 ;
  int clip_y1 ;
  int clip_y2 ;
  int dest_x ;
  int dest_y ;
  int _max1 ;
  int _max2 ;
  int tmp___5 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___6 ;
  int _min1 ;
  int _min2 ;
  int tmp___7 ;
  int _min1___0 ;
  int _min2___0 ;
  int tmp___8 ;

  {
#line 1481
  __mptr = (struct drm_framebuffer  const  *)(& vfb->base);
#line 1481
  vfbd = (struct vmw_framebuffer_dmabuf *)__mptr;
#line 1482
  dmabuf = vfbd->buffer;
#line 1497
  num_units = 0;
#line 1498
  __mptr___0 = (struct list_head  const  *)(dev_priv->dev)->mode_config.crtc_list.next;
#line 1498
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
#line 1498
  goto ldv_41413;
  ldv_41412: ;
#line 1499
  if ((unsigned long )crtc->fb != (unsigned long )(& vfb->base)) {
#line 1500
    goto ldv_41409;
  } else {

  }
#line 1501
  tmp = num_units;
#line 1501
  num_units = num_units + 1;
#line 1501
  __mptr___1 = (struct drm_crtc  const  *)crtc;
#line 1501
  units[tmp] = (struct vmw_display_unit *)__mptr___1;
  ldv_41409: 
#line 1498
  __mptr___2 = (struct list_head  const  *)crtc->head.next;
#line 1498
  crtc = (struct drm_crtc *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_41413: ;
#line 1498
  if ((unsigned long )(& crtc->head) != (unsigned long )(& (dev_priv->dev)->mode_config.crtc_list)) {
#line 1499
    goto ldv_41412;
  } else {
#line 1501
    goto ldv_41414;
  }
  ldv_41414: 
#line 1504
  tmp___0 = ldv__builtin_expect((unsigned long )dmabuf == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 1504
  if (tmp___0 != 0L) {
#line 1504
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                         "i" (1504), "i" (12UL));
    ldv_41415: ;
#line 1504
    goto ldv_41415;
  } else {

  }
#line 1505
  tmp___1 = ldv__builtin_expect((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 1505
  if (tmp___1 != 0L) {
#line 1505
    goto _L;
  } else {
#line 1505
    tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 1505
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
#line 1505
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"),
                           "i" (1505), "i" (12UL));
      ldv_41416: ;
#line 1505
      goto ldv_41416;
    } else {

    }
  }
#line 1508
  fifo_size = ((unsigned long )num_clips * (unsigned long )num_units) * 32UL + 20UL;
#line 1509
  tmp___3 = kmalloc(fifo_size, 208U);
#line 1509
  cmd = (struct __anonstruct_319 *)tmp___3;
#line 1510
  tmp___4 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_315 *)0),
                             0L);
#line 1510
  if (tmp___4 != 0L) {
#line 1511
    drm_err("vmw_kms_readback", "Failed to allocate temporary fifo memory.\n");
#line 1512
    return (-12);
  } else {

  }
#line 1515
  memset((void *)cmd, 0, fifo_size);
#line 1516
  cmd->header = 36U;
#line 1517
  cmd->body.format.ldv_6465.ldv_6463.bitsPerPixel = (unsigned char )vfb->base.bits_per_pixel;
#line 1518
  cmd->body.format.ldv_6465.ldv_6463.colorDepth = (unsigned char )vfb->base.depth;
#line 1519
  cmd->body.format.ldv_6465.ldv_6463.reserved = 0U;
#line 1520
  cmd->body.bytesPerLine = vfb->base.pitches[0];
#line 1521
  cmd->body.ptr.gmrId = vfb->user_handle;
#line 1522
  cmd->body.ptr.offset = 0U;
#line 1524
  blits = (struct __anonstruct_321 *)cmd + 1U;
#line 1525
  blits_pos = 0;
#line 1526
  i = 0;
#line 1526
  goto ldv_41442;
  ldv_41441: 
#line 1527
  c = clips;
#line 1528
  k = 0;
#line 1528
  goto ldv_41439;
  ldv_41438: 
#line 1530
  clip_x1 = c->x - (units[i])->crtc.x;
#line 1531
  clip_x2 = (int )((uint32_t )(c->x - (units[i])->crtc.x) + c->w);
#line 1532
  clip_y1 = c->y - (units[i])->crtc.y;
#line 1533
  clip_y2 = (int )((uint32_t )(c->y - (units[i])->crtc.y) + c->h);
#line 1534
  dest_x = c->x;
#line 1535
  dest_y = c->y;
#line 1540
  if (clip_x1 < 0) {
#line 1541
    dest_x = dest_x - clip_x1;
  } else {

  }
#line 1542
  if (clip_y1 < 0) {
#line 1543
    dest_y = dest_y - clip_y1;
  } else {

  }
#line 1546
  _max1 = clip_x1;
#line 1546
  _max2 = 0;
#line 1546
  if (_max1 > _max2) {
#line 1546
    tmp___5 = _max1;
  } else {
#line 1546
    tmp___5 = _max2;
  }
#line 1546
  clip_x1 = tmp___5;
#line 1547
  _max1___0 = clip_y1;
#line 1547
  _max2___0 = 0;
#line 1547
  if (_max1___0 > _max2___0) {
#line 1547
    tmp___6 = _max1___0;
  } else {
#line 1547
    tmp___6 = _max2___0;
  }
#line 1547
  clip_y1 = tmp___6;
#line 1548
  _min1 = clip_x2;
#line 1548
  _min2 = (units[i])->crtc.mode.hdisplay;
#line 1548
  if (_min1 < _min2) {
#line 1548
    tmp___7 = _min1;
  } else {
#line 1548
    tmp___7 = _min2;
  }
#line 1548
  clip_x2 = tmp___7;
#line 1549
  _min1___0 = clip_y2;
#line 1549
  _min2___0 = (units[i])->crtc.mode.vdisplay;
#line 1549
  if (_min1___0 < _min2___0) {
#line 1549
    tmp___8 = _min1___0;
  } else {
#line 1549
    tmp___8 = _min2___0;
  }
#line 1549
  clip_y2 = tmp___8;
#line 1552
  if ((((units[i])->crtc.mode.hdisplay <= clip_x1 || (units[i])->crtc.mode.vdisplay <= clip_y1) || clip_x2 <= 0) || clip_y2 <= 0) {
#line 1555
    goto ldv_41437;
  } else {

  }
#line 1557
  (blits + (unsigned long )blits_pos)->header = 38U;
#line 1558
  (blits + (unsigned long )blits_pos)->body.srcScreenId = (units[i])->unit;
#line 1559
  (blits + (unsigned long )blits_pos)->body.destOrigin.x = dest_x;
#line 1560
  (blits + (unsigned long )blits_pos)->body.destOrigin.y = dest_y;
#line 1562
  (blits + (unsigned long )blits_pos)->body.srcRect.left = clip_x1;
#line 1563
  (blits + (unsigned long )blits_pos)->body.srcRect.top = clip_y1;
#line 1564
  (blits + (unsigned long )blits_pos)->body.srcRect.right = clip_x2;
#line 1565
  (blits + (unsigned long )blits_pos)->body.srcRect.bottom = clip_y2;
#line 1566
  blits_pos = blits_pos + 1;
  ldv_41437: 
#line 1528
  k = k + 1;
#line 1528
  c = c + 1;
  ldv_41439: ;
#line 1528
  if ((uint32_t )k < num_clips) {
#line 1529
    goto ldv_41438;
  } else {
#line 1531
    goto ldv_41440;
  }
  ldv_41440: 
#line 1526
  i = i + 1;
  ldv_41442: ;
#line 1526
  if (i < num_units) {
#line 1527
    goto ldv_41441;
  } else {
#line 1529
    goto ldv_41443;
  }
  ldv_41443: 
#line 1570
  fifo_size = (unsigned long )blits_pos * 32UL + 20UL;
#line 1572
  ret = vmw_execbuf_process(file_priv, dev_priv, 0, (void *)cmd, (uint32_t )fifo_size,
                            0ULL, user_fence_rep, 0);
#line 1575
  kfree((void const   *)cmd);
#line 1577
  return (ret);
}
}
#line 1580 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_init(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int ret ;

  {
#line 1582
  dev = dev_priv->dev;
#line 1585
  drm_mode_config_init(dev);
#line 1586
  dev->mode_config.funcs = & vmw_kms_funcs;
#line 1587
  dev->mode_config.min_width = 1;
#line 1588
  dev->mode_config.min_height = 1;
#line 1590
  dev->mode_config.max_width = 8192;
#line 1591
  dev->mode_config.max_height = 8192;
#line 1593
  ret = vmw_kms_init_screen_object_display(dev_priv);
#line 1594
  if (ret != 0) {
#line 1595
    vmw_kms_init_legacy_display_system(dev_priv);
  } else {

  }
#line 1597
  return (0);
}
}
#line 1600 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_close(struct vmw_private *dev_priv ) 
{ 

  {
#line 1607
  drm_mode_config_cleanup(dev_priv->dev);
#line 1608
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1609
    vmw_kms_close_screen_object_display(dev_priv);
  } else {
#line 1611
    vmw_kms_close_legacy_display_system(dev_priv);
  }
#line 1612
  return (0);
}
}
#line 1615 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_cursor_bypass_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_cursor_bypass_arg *arg ;
  struct vmw_display_unit *du ;
  struct drm_mode_object *obj ;
  struct drm_crtc *crtc ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct drm_mode_object  const  *__mptr___2 ;
  struct drm_crtc  const  *__mptr___3 ;

  {
#line 1618
  arg = (struct drm_vmw_cursor_bypass_arg *)data;
#line 1622
  ret = 0;
#line 1625
  ldv_mutex_lock_95(& dev->mode_config.mutex);
#line 1626
  if ((int )arg->flags & 1) {
#line 1628
    __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 1628
    crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 1628
    goto ldv_41469;
    ldv_41468: 
#line 1629
    __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1629
    du = (struct vmw_display_unit *)__mptr___0;
#line 1630
    du->hotspot_x = arg->xhot;
#line 1631
    du->hotspot_y = arg->yhot;
#line 1628
    __mptr___1 = (struct list_head  const  *)crtc->head.next;
#line 1628
    crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
    ldv_41469: ;
#line 1628
    if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 1629
      goto ldv_41468;
    } else {
#line 1631
      goto ldv_41470;
    }
    ldv_41470: 
#line 1634
    ldv_mutex_unlock_96(& dev->mode_config.mutex);
#line 1635
    return (0);
  } else {

  }
#line 1638
  obj = drm_mode_object_find(dev, arg->crtc_id, 3435973836U);
#line 1639
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 1640
    ret = -22;
#line 1641
    goto out;
  } else {

  }
#line 1644
  __mptr___2 = (struct drm_mode_object  const  *)obj;
#line 1644
  crtc = (struct drm_crtc *)__mptr___2 + 0xffffffffffffffe8UL;
#line 1645
  __mptr___3 = (struct drm_crtc  const  *)crtc;
#line 1645
  du = (struct vmw_display_unit *)__mptr___3;
#line 1647
  du->hotspot_x = arg->xhot;
#line 1648
  du->hotspot_y = arg->yhot;
  out: 
#line 1651
  ldv_mutex_unlock_97(& dev->mode_config.mutex);
#line 1653
  return (ret);
}
}
#line 1656 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_write_svga(struct vmw_private *vmw_priv___0 , unsigned int width , unsigned int height ,
                       unsigned int pitch , unsigned int bpp , unsigned int depth ) 
{ bool tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 1660
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1661
    vmw_write(vmw_priv___0, 32U, pitch);
  } else {
#line 1662
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1662
    if ((int )tmp) {
#line 1663
      iowrite32(pitch, (void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1664
  vmw_write(vmw_priv___0, 2U, width);
#line 1665
  vmw_write(vmw_priv___0, 3U, height);
#line 1666
  vmw_write(vmw_priv___0, 7U, bpp);
#line 1668
  tmp___1 = vmw_read(vmw_priv___0, 6U);
#line 1668
  if (tmp___1 != depth) {
#line 1669
    tmp___0 = vmw_read(vmw_priv___0, 6U);
#line 1669
    drm_err("vmw_kms_write_svga", "Invalid depth %u for %u bpp, host expects %u\n",
            depth, bpp, tmp___0);
#line 1671
    return (-22);
  } else {

  }
#line 1674
  return (0);
}
}
#line 1677 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_save_vga(struct vmw_private *vmw_priv___0 ) 
{ struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp ;

  {
#line 1682
  vmw_priv___0->vga_width = vmw_read(vmw_priv___0, 2U);
#line 1683
  vmw_priv___0->vga_height = vmw_read(vmw_priv___0, 3U);
#line 1684
  vmw_priv___0->vga_bpp = vmw_read(vmw_priv___0, 7U);
#line 1685
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1686
    vmw_priv___0->vga_pitchlock = vmw_read(vmw_priv___0, 32U);
  } else {
#line 1688
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1688
    if ((int )tmp) {
#line 1689
      vmw_priv___0->vga_pitchlock = ioread32((void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1692
  if ((vmw_priv___0->capabilities & 524288U) == 0U) {
#line 1693
    return (0);
  } else {

  }
#line 1695
  vmw_priv___0->num_displays = vmw_read(vmw_priv___0, 34U);
#line 1698
  if (vmw_priv___0->num_displays == 0U) {
#line 1699
    vmw_priv___0->num_displays = 1U;
  } else {

  }
#line 1701
  i = 0U;
#line 1701
  goto ldv_41491;
  ldv_41490: 
#line 1702
  save = (struct vmw_vga_topology_state *)(& vmw_priv___0->vga_save) + (unsigned long )i;
#line 1703
  vmw_write(vmw_priv___0, 35U, i);
#line 1704
  save->primary = vmw_read(vmw_priv___0, 36U);
#line 1705
  save->pos_x = vmw_read(vmw_priv___0, 37U);
#line 1706
  save->pos_y = vmw_read(vmw_priv___0, 38U);
#line 1707
  save->width = vmw_read(vmw_priv___0, 39U);
#line 1708
  save->height = vmw_read(vmw_priv___0, 40U);
#line 1709
  vmw_write(vmw_priv___0, 35U, 4294967295U);
#line 1710
  if (((i == 0U && vmw_priv___0->num_displays == 1U) && save->width == 0U) && save->height == 0U) {
#line 1718
    save->width = vmw_priv___0->vga_width - save->pos_x;
#line 1719
    save->height = vmw_priv___0->vga_height - save->pos_y;
  } else {

  }
#line 1701
  i = i + 1U;
  ldv_41491: ;
#line 1701
  if (vmw_priv___0->num_displays > i) {
#line 1702
    goto ldv_41490;
  } else {
#line 1704
    goto ldv_41492;
  }
  ldv_41492: ;
#line 1723
  return (0);
}
}
#line 1726 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_restore_vga(struct vmw_private *vmw_priv___0 ) 
{ struct vmw_vga_topology_state *save ;
  uint32_t i ;
  bool tmp ;

  {
#line 1731
  vmw_write(vmw_priv___0, 2U, vmw_priv___0->vga_width);
#line 1732
  vmw_write(vmw_priv___0, 3U, vmw_priv___0->vga_height);
#line 1733
  vmw_write(vmw_priv___0, 7U, vmw_priv___0->vga_bpp);
#line 1734
  if ((vmw_priv___0->capabilities & 131072U) != 0U) {
#line 1735
    vmw_write(vmw_priv___0, 32U, vmw_priv___0->vga_pitchlock);
  } else {
#line 1737
    tmp = vmw_fifo_have_pitchlock(vmw_priv___0);
#line 1737
    if ((int )tmp) {
#line 1738
      iowrite32(vmw_priv___0->vga_pitchlock, (void *)vmw_priv___0->mmio_virt + 8U);
    } else {

    }
  }
#line 1741
  if ((vmw_priv___0->capabilities & 524288U) == 0U) {
#line 1742
    return (0);
  } else {

  }
#line 1744
  i = 0U;
#line 1744
  goto ldv_41499;
  ldv_41498: 
#line 1745
  save = (struct vmw_vga_topology_state *)(& vmw_priv___0->vga_save) + (unsigned long )i;
#line 1746
  vmw_write(vmw_priv___0, 35U, i);
#line 1747
  vmw_write(vmw_priv___0, 36U, save->primary);
#line 1748
  vmw_write(vmw_priv___0, 37U, save->pos_x);
#line 1749
  vmw_write(vmw_priv___0, 38U, save->pos_y);
#line 1750
  vmw_write(vmw_priv___0, 39U, save->width);
#line 1751
  vmw_write(vmw_priv___0, 40U, save->height);
#line 1752
  vmw_write(vmw_priv___0, 35U, 4294967295U);
#line 1744
  i = i + 1U;
  ldv_41499: ;
#line 1744
  if (vmw_priv___0->num_displays > i) {
#line 1745
    goto ldv_41498;
  } else {
#line 1747
    goto ldv_41500;
  }
  ldv_41500: ;
#line 1755
  return (0);
}
}
#line 1758 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
bool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv , uint32_t pitch , uint32_t height ) 
{ 

  {
#line 1762
  return ((unsigned long long )pitch * (unsigned long long )height < (unsigned long long )dev_priv->vram_size);
}
}
#line 1769 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
u32 vmw_get_vblank_counter(struct drm_device *dev , int crtc ) 
{ 

  {
#line 1771
  return (0U);
}
}
#line 1777 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_enable_vblank(struct drm_device *dev , int crtc ) 
{ 

  {
#line 1779
  return (-38);
}
}
#line 1785 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_disable_vblank(struct drm_device *dev , int crtc ) 
{ 

  {
#line 1787
  return;
}
}
#line 1794 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_update_layout(struct vmw_private *dev_priv , unsigned int num , struct drm_vmw_rect *rects ) 
{ struct drm_device *dev ;
  struct vmw_display_unit *du ;
  struct drm_connector *con ;
  struct list_head  const  *__mptr ;
  struct drm_connector  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1797
  dev = dev_priv->dev;
#line 1801
  ldv_mutex_lock_98(& dev->mode_config.mutex);
#line 1815
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
#line 1815
  con = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
#line 1815
  goto ldv_41533;
  ldv_41532: 
#line 1816
  __mptr___0 = (struct drm_connector  const  *)con;
#line 1816
  du = (struct vmw_display_unit *)__mptr___0 + 0xfffffffffffffc58UL;
#line 1817
  if (du->unit < num) {
#line 1818
    du->pref_width = (rects + (unsigned long )du->unit)->w;
#line 1819
    du->pref_height = (rects + (unsigned long )du->unit)->h;
#line 1820
    du->pref_active = 1;
#line 1821
    du->gui_x = (rects + (unsigned long )du->unit)->x;
#line 1822
    du->gui_y = (rects + (unsigned long )du->unit)->y;
  } else {
#line 1824
    du->pref_width = 800U;
#line 1825
    du->pref_height = 600U;
#line 1826
    du->pref_active = 0;
  }
#line 1828
  con->status = vmw_du_connector_detect(con, 1);
#line 1815
  __mptr___1 = (struct list_head  const  *)con->head.next;
#line 1815
  con = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  ldv_41533: ;
#line 1815
  if ((unsigned long )(& con->head) != (unsigned long )(& dev->mode_config.connector_list)) {
#line 1816
    goto ldv_41532;
  } else {
#line 1818
    goto ldv_41534;
  }
  ldv_41534: 
#line 1831
  ldv_mutex_unlock_99(& dev->mode_config.mutex);
#line 1833
  return (0);
}
}
#line 1836 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_page_flip(struct drm_crtc *crtc , struct drm_framebuffer *fb , struct drm_pending_vblank_event *event ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_framebuffer *old_fb ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_file *file_priv ;
  struct vmw_fence_obj *fence ;
  struct drm_clip_rect clips ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;
  struct drm_crtc  const  *__mptr___0 ;

  {
#line 1840
  tmp = vmw_priv(crtc->dev);
#line 1840
  dev_priv = tmp;
#line 1841
  old_fb = crtc->fb;
#line 1842
  __mptr = (struct drm_framebuffer  const  *)fb;
#line 1842
  vfb = (struct vmw_framebuffer *)__mptr;
#line 1844
  fence = 0;
#line 1848
  if ((unsigned long )event == (unsigned long )((struct drm_pending_vblank_event *)0)) {
#line 1849
    return (-22);
  } else {

  }
#line 1852
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 1853
    return (-38);
  } else {

  }
#line 1855
  file_priv = event->base.file_priv;
#line 1856
  tmp___0 = vmw_kms_screen_object_flippable(dev_priv, crtc);
#line 1856
  if (tmp___0) {
#line 1856
    tmp___1 = 0;
  } else {
#line 1856
    tmp___1 = 1;
  }
#line 1856
  if (tmp___1) {
#line 1857
    return (-22);
  } else {

  }
#line 1859
  crtc->fb = fb;
#line 1862
  clips.y1 = 0U;
#line 1862
  clips.x1 = clips.y1;
#line 1863
  clips.x2 = (unsigned short )fb->width;
#line 1864
  clips.y2 = (unsigned short )fb->height;
#line 1866
  if ((int )vfb->dmabuf) {
#line 1867
    ret = do_dmabuf_dirty_sou(file_priv, dev_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
  } else {
#line 1870
    ret = do_surface_dirty_sou(dev_priv, file_priv, vfb, 0U, 0U, & clips, 1U, 1, & fence);
  }
#line 1874
  if (ret != 0) {
#line 1875
    goto out_no_fence;
  } else {

  }
#line 1876
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1877
    ret = -22;
#line 1878
    goto out_no_fence;
  } else {

  }
#line 1881
  ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, & event->event.tv_sec,
                                     & event->event.tv_usec, 1);
#line 1891
  vmw_fence_obj_unreference(& fence);
#line 1893
  __mptr___0 = (struct drm_crtc  const  *)crtc;
#line 1893
  if ((int )((struct vmw_display_unit *)__mptr___0)->is_implicit) {
#line 1894
    vmw_kms_screen_object_update_implicit_fb(dev_priv, crtc);
  } else {

  }
#line 1896
  return (ret);
  out_no_fence: 
#line 1899
  crtc->fb = old_fb;
#line 1900
  return (ret);
}
}
#line 1904 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_save(struct drm_crtc *crtc ) 
{ 

  {
#line 1906
  return;
}
}
#line 1908 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_restore(struct drm_crtc *crtc ) 
{ 

  {
#line 1910
  return;
}
}
#line 1912 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_crtc_gamma_set(struct drm_crtc *crtc , u16 *r , u16 *g , u16 *b , uint32_t start ,
                           uint32_t size ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  int i ;

  {
#line 1916
  tmp = vmw_priv(crtc->dev);
#line 1916
  dev_priv = tmp;
#line 1919
  i = 0;
#line 1919
  goto ldv_41570;
  ldv_41569: 
#line 1920
  drm_ut_debug_printk(1U, "drm", "vmw_du_crtc_gamma_set", "%d r/g/b = 0x%04x / 0x%04x / 0x%04x\n",
                      i, (int )*(r + (unsigned long )i), (int )*(g + (unsigned long )i),
                      (int )*(b + (unsigned long )i));
#line 1922
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1024), (uint32_t )((int )*(r + (unsigned long )i) >> 8));
#line 1923
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1025), (uint32_t )((int )*(g + (unsigned long )i) >> 8));
#line 1924
  vmw_write(dev_priv, (unsigned int )(i * 3 + 1026), (uint32_t )((int )*(b + (unsigned long )i) >> 8));
#line 1919
  i = i + 1;
  ldv_41570: ;
#line 1919
  if ((uint32_t )i < size) {
#line 1920
    goto ldv_41569;
  } else {
#line 1922
    goto ldv_41571;
  }
  ldv_41571: ;
#line 1924
  return;
}
}
#line 1928 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_dpms(struct drm_connector *connector , int mode ) 
{ 

  {
#line 1930
  return;
}
}
#line 1932 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_save(struct drm_connector *connector ) 
{ 

  {
#line 1934
  return;
}
}
#line 1936 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void vmw_du_connector_restore(struct drm_connector *connector ) 
{ 

  {
#line 1938
  return;
}
}
#line 1941 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
enum drm_connector_status vmw_du_connector_detect(struct drm_connector *connector ,
                                                  bool force ) 
{ uint32_t num_displays ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_display_unit *du ;
  struct drm_connector  const  *__mptr ;
  int tmp___0 ;
  struct drm_connector  const  *__mptr___1 ;

  {
#line 1944
  dev = connector->dev;
#line 1945
  tmp = vmw_priv(dev);
#line 1945
  dev_priv = tmp;
#line 1946
  __mptr = (struct drm_connector  const  *)connector;
#line 1946
  du = (struct vmw_display_unit *)__mptr + 0xfffffffffffffc58UL;
#line 1948
  ldv_mutex_lock_100(& dev_priv->hw_mutex);
#line 1949
  num_displays = vmw_read(dev_priv, 31U);
#line 1950
  ldv_mutex_unlock_101(& dev_priv->hw_mutex);
#line 1952
  __mptr___1 = (struct drm_connector  const  *)connector;
#line 1952
  if (((struct vmw_display_unit *)__mptr___1 + 0xfffffffffffffc58UL)->unit < num_displays && (int )du->pref_active) {
#line 1952
    tmp___0 = 1;
  } else {
#line 1952
    tmp___0 = 2;
  }
#line 1952
  return (tmp___0);
}
}
#line 1957 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static struct drm_display_mode vmw_kms_connector_builtin[19U]  = 
#line 1957
  {      {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 25175, 640, 656, 752, 800, 0, 480, 489, 492, 525, 0, 10U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '0', '0', 'x', '6', '0', '0', '\000'}, 0,
      64U, 40000, 800, 840, 968, 1056, 0, 600, 601, 605, 628, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '7', '6', '8', '\000'},
      0, 64U, 65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806, 0, 10U, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '1', '5', '2', 'x', '8', '6', '4', '\000'},
      0, 64U, 108000, 1152, 1216, 1344, 1600, 0, 864, 865, 868, 900, 0, 5U, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '7', '6', '8', '\000'},
      0, 64U, 79500, 1280, 1344, 1472, 1664, 0, 768, 771, 778, 798, 0, 6U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '8', '0', '0', '\000'},
      0, 64U, 83500, 1280, 1352, 1480, 1680, 0, 800, 803, 809, 831, 0, 9U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '9', '6', '0', '\000'},
      0, 64U, 108000, 1280, 1376, 1488, 1800, 0, 960, 961, 964, 1000, 0, 5U, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '1', '0', '2', '4',
                                     '\000'}, 0, 64U, 108000, 1280, 1328, 1440, 1688,
      0, 1024, 1025, 1028, 1066, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '3', '6', '0', 'x', '7', '6', '8', '\000'},
      0, 64U, 85500, 1360, 1424, 1536, 1792, 0, 768, 771, 777, 795, 0, 5U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '4', '0', '0', 'x', '1', '0', '5', '0',
                                     '\000'}, 0, 64U, 121750, 1400, 1488, 1632, 1864,
      0, 1050, 1053, 1057, 1089, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '4', '4', '0', 'x', '9', '0', '0', '\000'},
      0, 64U, 106500, 1440, 1520, 1672, 1904, 0, 900, 903, 909, 934, 0, 6U, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '6', '0', '0', 'x', '1', '2', '0', '0',
                                     '\000'}, 0, 64U, 162000, 1600, 1664, 1856, 2160,
      0, 1200, 1201, 1204, 1250, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '6', '8', '0', 'x', '1', '0', '5', '0',
                                     '\000'}, 0, 64U, 146250, 1680, 1784, 1960, 2240,
      0, 1050, 1053, 1059, 1089, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '7', '9', '2', 'x', '1', '3', '4', '4',
                                     '\000'}, 0, 64U, 204750, 1792, 1920, 2120, 2448,
      0, 1344, 1345, 1348, 1394, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '8', '5', '6', 'x', '1', '3', '9', '2',
                                     '\000'}, 0, 64U, 218250, 1856, 1952, 2176, 2528,
      0, 1392, 1393, 1396, 1439, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '9', '2', '0', 'x', '1', '2', '0', '0',
                                     '\000'}, 0, 64U, 193250, 1920, 2056, 2256, 2592,
      0, 1200, 1203, 1209, 1245, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '9', '2', '0', 'x', '1', '4', '4', '0',
                                     '\000'}, 0, 64U, 234000, 1920, 2048, 2256, 2600,
      0, 1440, 1441, 1444, 1500, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'2', '5', '6', '0', 'x', '1', '6', '0', '0',
                                     '\000'}, 0, 64U, 348500, 2560, 2752, 3032, 3504,
      0, 1600, 1603, 1609, 1658, 0, 6U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'\000'}, 0, 0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
#line 2041 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
static void vmw_guess_mode_timing(struct drm_display_mode *mode ) 
{ 

  {
#line 2043
  mode->hsync_start = mode->hdisplay + 50;
#line 2044
  mode->hsync_end = mode->hsync_start + 50;
#line 2045
  mode->htotal = mode->hsync_end + 50;
#line 2047
  mode->vsync_start = mode->vdisplay + 50;
#line 2048
  mode->vsync_end = mode->vsync_start + 50;
#line 2049
  mode->vtotal = mode->vsync_end + 50;
#line 2051
  mode->clock = (int )((((unsigned int )mode->htotal * (unsigned int )mode->vtotal) / 100U) * 6U);
#line 2052
  mode->vrefresh = drm_mode_vrefresh((struct drm_display_mode  const  *)mode);
#line 2053
  return;
}
}
#line 2056 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_connector_fill_modes(struct drm_connector *connector , uint32_t max_width ,
                                uint32_t max_height ) 
{ struct vmw_display_unit *du ;
  struct drm_connector  const  *__mptr ;
  struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *bmode ;
  struct drm_display_mode prefmode ;
  int i ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 2059
  __mptr = (struct drm_connector  const  *)connector;
#line 2059
  du = (struct vmw_display_unit *)__mptr + 0xfffffffffffffc58UL;
#line 2060
  dev = connector->dev;
#line 2061
  tmp = vmw_priv(dev);
#line 2061
  dev_priv = tmp;
#line 2062
  mode = 0;
#line 2064
  prefmode.head.next = 0;
#line 2064
  prefmode.head.prev = 0;
#line 2064
  prefmode.base.id = 0U;
#line 2064
  prefmode.base.type = 3739147998U;
#line 2064
  prefmode.base.properties = 0;
#line 2064
  prefmode.name[0] = 'p';
#line 2064
  prefmode.name[1] = 'r';
#line 2064
  prefmode.name[2] = 'e';
#line 2064
  prefmode.name[3] = 'f';
#line 2064
  prefmode.name[4] = 'e';
#line 2064
  prefmode.name[5] = 'r';
#line 2064
  prefmode.name[6] = 'r';
#line 2064
  prefmode.name[7] = 'e';
#line 2064
  prefmode.name[8] = 'd';
#line 2064
  prefmode.name[9] = '\000';
#line 2064
  prefmode.status = 0;
#line 2064
  prefmode.type = 72U;
#line 2064
  prefmode.clock = 0;
#line 2064
  prefmode.hdisplay = 0;
#line 2064
  prefmode.hsync_start = 0;
#line 2064
  prefmode.hsync_end = 0;
#line 2064
  prefmode.htotal = 0;
#line 2064
  prefmode.hskew = 0;
#line 2064
  prefmode.vdisplay = 0;
#line 2064
  prefmode.vsync_start = 0;
#line 2064
  prefmode.vsync_end = 0;
#line 2064
  prefmode.vtotal = 0;
#line 2064
  prefmode.vscan = 0;
#line 2064
  prefmode.flags = 6U;
#line 2064
  prefmode.width_mm = 0;
#line 2064
  prefmode.height_mm = 0;
#line 2064
  prefmode.clock_index = 0;
#line 2064
  prefmode.synth_clock = 0;
#line 2064
  prefmode.crtc_hdisplay = 0;
#line 2064
  prefmode.crtc_hblank_start = 0;
#line 2064
  prefmode.crtc_hblank_end = 0;
#line 2064
  prefmode.crtc_hsync_start = 0;
#line 2064
  prefmode.crtc_hsync_end = 0;
#line 2064
  prefmode.crtc_htotal = 0;
#line 2064
  prefmode.crtc_hskew = 0;
#line 2064
  prefmode.crtc_vdisplay = 0;
#line 2064
  prefmode.crtc_vblank_start = 0;
#line 2064
  prefmode.crtc_vblank_end = 0;
#line 2064
  prefmode.crtc_vsync_start = 0;
#line 2064
  prefmode.crtc_vsync_end = 0;
#line 2064
  prefmode.crtc_vtotal = 0;
#line 2064
  prefmode.private_size = 0;
#line 2064
  prefmode.private = 0;
#line 2064
  prefmode.private_flags = 0;
#line 2064
  prefmode.vrefresh = 0;
#line 2064
  prefmode.hsync = 0;
#line 2073
  mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)(& prefmode));
#line 2074
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 2075
    return (0);
  } else {

  }
#line 2076
  mode->hdisplay = (int )du->pref_width;
#line 2077
  mode->vdisplay = (int )du->pref_height;
#line 2078
  vmw_guess_mode_timing(mode);
#line 2080
  tmp___0 = vmw_kms_validate_mode_vram(dev_priv, (uint32_t )(mode->hdisplay * 2),
                                       (uint32_t )mode->vdisplay);
#line 2080
  if ((int )tmp___0) {
#line 2082
    drm_mode_probed_add(connector, mode);
  } else {
#line 2084
    drm_mode_destroy(dev, mode);
#line 2085
    mode = 0;
  }
#line 2088
  if ((unsigned long )du->pref_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 2089
    list_del_init(& (du->pref_mode)->head);
#line 2090
    drm_mode_destroy(dev, du->pref_mode);
  } else {

  }
#line 2094
  du->pref_mode = mode;
#line 2097
  i = 0;
#line 2097
  goto ldv_41614;
  ldv_41613: 
#line 2098
  bmode = (struct drm_display_mode *)(& vmw_kms_connector_builtin) + (unsigned long )i;
#line 2099
  if ((uint32_t )bmode->hdisplay > max_width || (uint32_t )bmode->vdisplay > max_height) {
#line 2101
    goto ldv_41612;
  } else {

  }
#line 2103
  tmp___1 = vmw_kms_validate_mode_vram(dev_priv, (uint32_t )(bmode->hdisplay * 2),
                                       (uint32_t )bmode->vdisplay);
#line 2103
  if (tmp___1) {
#line 2103
    tmp___2 = 0;
  } else {
#line 2103
    tmp___2 = 1;
  }
#line 2103
  if (tmp___2) {
#line 2105
    goto ldv_41612;
  } else {

  }
#line 2107
  mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)bmode);
#line 2108
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
#line 2109
    return (0);
  } else {

  }
#line 2110
  mode->vrefresh = drm_mode_vrefresh((struct drm_display_mode  const  *)mode);
#line 2112
  drm_mode_probed_add(connector, mode);
  ldv_41612: 
#line 2097
  i = i + 1;
  ldv_41614: ;
#line 2097
  if (vmw_kms_connector_builtin[i].type != 0U) {
#line 2098
    goto ldv_41613;
  } else {
#line 2100
    goto ldv_41615;
  }
  ldv_41615: ;
#line 2116
  if ((unsigned long )du->pref_mode != (unsigned long )((struct drm_display_mode *)0)) {
#line 2117
    list_move(& (du->pref_mode)->head, & connector->probed_modes);
  } else {

  }
#line 2119
  drm_mode_connector_list_update(connector);
#line 2121
  return (1);
}
}
#line 2124 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_du_connector_set_property(struct drm_connector *connector , struct drm_property *property ,
                                  uint64_t val ) 
{ 

  {
#line 2128
  return (0);
}
}
#line 2132 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int vmw_kms_update_layout_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_update_layout_arg *arg ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  void *user_rects ;
  struct drm_vmw_rect *rects ;
  unsigned int rects_size ;
  int ret ;
  int i ;
  struct drm_mode_config *mode_config ;
  long tmp___1 ;
  struct drm_vmw_rect def_rect ;
  void *tmp___2 ;
  long tmp___3 ;
  unsigned long tmp___4 ;
  long tmp___5 ;

  {
#line 2135
  tmp = vmw_priv(dev);
#line 2135
  dev_priv = tmp;
#line 2136
  arg = (struct drm_vmw_update_layout_arg *)data;
#line 2138
  tmp___0 = vmw_master(file_priv->master);
#line 2138
  vmaster = tmp___0;
#line 2144
  mode_config = & dev->mode_config;
#line 2146
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 2147
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 2147
  if (tmp___1 != 0L) {
#line 2148
    return (ret);
  } else {

  }
#line 2150
  if (arg->num_outputs == 0U) {
#line 2151
    def_rect.x = 0;
#line 2151
    def_rect.y = 0;
#line 2151
    def_rect.w = 800U;
#line 2151
    def_rect.h = 600U;
#line 2152
    vmw_du_update_layout(dev_priv, 1U, & def_rect);
#line 2153
    goto out_unlock;
  } else {

  }
#line 2156
  rects_size = arg->num_outputs * 16U;
#line 2157
  tmp___2 = kcalloc((size_t )arg->num_outputs, 16UL, 208U);
#line 2157
  rects = (struct drm_vmw_rect *)tmp___2;
#line 2159
  tmp___3 = ldv__builtin_expect((unsigned long )rects == (unsigned long )((struct drm_vmw_rect *)0),
                             0L);
#line 2159
  if (tmp___3 != 0L) {
#line 2160
    ret = -12;
#line 2161
    goto out_unlock;
  } else {

  }
#line 2164
  user_rects = (void *)arg->rects;
#line 2165
  tmp___4 = copy_from_user((void *)rects, (void const   *)user_rects, (unsigned long )rects_size);
#line 2165
  ret = (int )tmp___4;
#line 2166
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 2166
  if (tmp___5 != 0L) {
#line 2167
    drm_err("vmw_kms_update_layout_ioctl", "Failed to get rects.\n");
#line 2168
    ret = -14;
#line 2169
    goto out_free;
  } else {

  }
#line 2172
  i = 0;
#line 2172
  goto ldv_41640;
  ldv_41639: ;
#line 2173
  if ((((rects + (unsigned long )i)->x < 0 || (rects + (unsigned long )i)->y < 0) || (uint32_t )(rects + (unsigned long )i)->x + (rects + (unsigned long )i)->w > (uint32_t )mode_config->max_width) || (uint32_t )(rects + (unsigned long )i)->y + (rects + (unsigned long )i)->h > (uint32_t )mode_config->max_height) {
#line 2177
    drm_err("vmw_kms_update_layout_ioctl", "Invalid GUI layout.\n");
#line 2178
    ret = -22;
#line 2179
    goto out_free;
  } else {

  }
#line 2172
  i = i + 1;
  ldv_41640: ;
#line 2172
  if ((uint32_t )i < arg->num_outputs) {
#line 2173
    goto ldv_41639;
  } else {
#line 2175
    goto ldv_41641;
  }
  ldv_41641: 
#line 2183
  vmw_du_update_layout(dev_priv, arg->num_outputs, rects);
  out_free: 
#line 2186
  kfree((void const   *)rects);
  out_unlock: 
#line 2188
  ttm_read_unlock(& vmaster->lock);
#line 2189
  return (ret);
}
}
#line 2191 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
unsigned int ldvarg18  ;
#line 2192 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_file *vmw_framebuffer_surface_funcs_group0  ;
#line 2193 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_file *ldvarg104  ;
#line 2194 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
unsigned int ldvarg84  ;
#line 2195 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_framebuffer *vmw_framebuffer_dmabuf_funcs_group1  ;
#line 2196 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_clip_rect *ldvarg86  ;
#line 2197 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_device *ldvarg102  ;
#line 2198 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_mode_fb_cmd2 *ldvarg103  ;
#line 2199 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
unsigned int ldvarg83  ;
#line 2200 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
unsigned int ldvarg85  ;
#line 2201
extern int ldv_vmw_framebuffer_surface_funcs_probe_21(void) ;
#line 2202 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_file *vmw_framebuffer_dmabuf_funcs_group0  ;
#line 2203 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_framebuffer *vmw_framebuffer_surface_funcs_group1  ;
#line 2204 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
unsigned int *ldvarg15  ;
#line 2205 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
unsigned int ldvarg16  ;
#line 2206 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
unsigned int ldvarg17  ;
#line 2207
extern int ldv_vmw_framebuffer_dmabuf_funcs_probe_20(void) ;
#line 2208 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
struct drm_clip_rect *ldvarg19  ;
#line 2209 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
unsigned int *ldvarg82  ;
#line 2211 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_main_exported_21(void) 
{ int tmp ;

  {
#line 2213
  tmp = __VERIFIER_nondet_int();
#line 2213
  switch (tmp) {
  case 0: ;
#line 2216
  if (ldv_state_variable_21 == 2) {
#line 2218
    vmw_framebuffer_surface_destroy(vmw_framebuffer_surface_funcs_group1);
#line 2220
    ldv_state_variable_21 = 1;
#line 2221
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2224
  goto ldv_41667;
  case 1: ;
#line 2227
  if (ldv_state_variable_21 == 1) {
#line 2229
    vmw_framebuffer_surface_dirty(vmw_framebuffer_surface_funcs_group1, vmw_framebuffer_surface_funcs_group0,
                                  ldvarg18, ldvarg17, ldvarg19, ldvarg16);
#line 2231
    ldv_state_variable_21 = 1;
  } else {

  }
#line 2234
  if (ldv_state_variable_21 == 2) {
#line 2236
    vmw_framebuffer_surface_dirty(vmw_framebuffer_surface_funcs_group1, vmw_framebuffer_surface_funcs_group0,
                                  ldvarg18, ldvarg17, ldvarg19, ldvarg16);
#line 2238
    ldv_state_variable_21 = 2;
  } else {

  }
#line 2241
  goto ldv_41667;
  case 2: ;
#line 2244
  if (ldv_state_variable_21 == 1) {
#line 2246
    vmw_framebuffer_create_handle(vmw_framebuffer_surface_funcs_group1, vmw_framebuffer_surface_funcs_group0,
                                  ldvarg15);
#line 2248
    ldv_state_variable_21 = 1;
  } else {

  }
#line 2251
  if (ldv_state_variable_21 == 2) {
#line 2253
    vmw_framebuffer_create_handle(vmw_framebuffer_surface_funcs_group1, vmw_framebuffer_surface_funcs_group0,
                                  ldvarg15);
#line 2255
    ldv_state_variable_21 = 2;
  } else {

  }
#line 2258
  goto ldv_41667;
  case 3: ;
#line 2261
  if (ldv_state_variable_21 == 1) {
#line 2263
    ldv_vmw_framebuffer_surface_funcs_probe_21();
#line 2265
    ldv_state_variable_21 = 2;
#line 2266
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2269
  goto ldv_41667;
  default: ;
#line 2270
  goto ldv_41667;
  }
  ldv_41667: ;
#line 2274
  return;
}
}
#line 2276 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_main_exported_19(void) 
{ int tmp ;

  {
#line 2278
  tmp = __VERIFIER_nondet_int();
#line 2278
  switch (tmp) {
  case 0: ;
#line 2281
  if (ldv_state_variable_19 == 1) {
#line 2283
    vmw_kms_fb_create(ldvarg102, ldvarg104, ldvarg103);
#line 2285
    ldv_state_variable_19 = 1;
  } else {

  }
#line 2288
  goto ldv_41676;
  default: ;
#line 2289
  goto ldv_41676;
  }
  ldv_41676: ;
#line 2293
  return;
}
}
#line 2295 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_main_exported_20(void) 
{ int tmp ;

  {
#line 2297
  tmp = __VERIFIER_nondet_int();
#line 2297
  switch (tmp) {
  case 0: ;
#line 2300
  if (ldv_state_variable_20 == 2) {
#line 2302
    vmw_framebuffer_dmabuf_destroy(vmw_framebuffer_dmabuf_funcs_group1);
#line 2304
    ldv_state_variable_20 = 1;
#line 2305
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 2308
  goto ldv_41682;
  case 1: ;
#line 2311
  if (ldv_state_variable_20 == 1) {
#line 2313
    vmw_framebuffer_dmabuf_dirty(vmw_framebuffer_dmabuf_funcs_group1, vmw_framebuffer_dmabuf_funcs_group0,
                                 ldvarg85, ldvarg84, ldvarg86, ldvarg83);
#line 2315
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2318
  if (ldv_state_variable_20 == 2) {
#line 2320
    vmw_framebuffer_dmabuf_dirty(vmw_framebuffer_dmabuf_funcs_group1, vmw_framebuffer_dmabuf_funcs_group0,
                                 ldvarg85, ldvarg84, ldvarg86, ldvarg83);
#line 2322
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2325
  goto ldv_41682;
  case 2: ;
#line 2328
  if (ldv_state_variable_20 == 1) {
#line 2330
    vmw_framebuffer_create_handle(vmw_framebuffer_dmabuf_funcs_group1, vmw_framebuffer_dmabuf_funcs_group0,
                                  ldvarg82);
#line 2332
    ldv_state_variable_20 = 1;
  } else {

  }
#line 2335
  if (ldv_state_variable_20 == 2) {
#line 2337
    vmw_framebuffer_create_handle(vmw_framebuffer_dmabuf_funcs_group1, vmw_framebuffer_dmabuf_funcs_group0,
                                  ldvarg82);
#line 2339
    ldv_state_variable_20 = 2;
  } else {

  }
#line 2342
  goto ldv_41682;
  case 3: ;
#line 2345
  if (ldv_state_variable_20 == 1) {
#line 2347
    ldv_vmw_framebuffer_dmabuf_funcs_probe_20();
#line 2349
    ldv_state_variable_20 = 2;
#line 2350
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 2353
  goto ldv_41682;
  default: ;
#line 2354
  goto ldv_41682;
  }
  ldv_41682: ;
#line 2358
  return;
}
}
#line 2359 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_75(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2364
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2366
  mutex_lock(ldv_func_arg1);
#line 2367
  return;
}
}
#line 2369 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_76(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2374
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2376
  mutex_unlock(ldv_func_arg1);
#line 2377
  return;
}
}
#line 2379 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2384
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 2386
  mutex_lock(ldv_func_arg1);
#line 2387
  return;
}
}
#line 2389 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
int ldv_mutex_trylock_78(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2394
  tmp = mutex_trylock(ldv_func_arg1);
#line 2394
  ldv_func_res = tmp;
#line 2396
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 2396
  return (tmp___0);
#line 2398
  return (ldv_func_res);
}
}
#line 2401 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_79(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2406
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 2408
  mutex_unlock(ldv_func_arg1);
#line 2409
  return;
}
}
#line 2411 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_80(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2416
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 2418
  mutex_lock(ldv_func_arg1);
#line 2419
  return;
}
}
#line 2421 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2426
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 2428
  mutex_unlock(ldv_func_arg1);
#line 2429
  return;
}
}
#line 2431 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_82(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2436
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 2438
  mutex_lock(ldv_func_arg1);
#line 2439
  return;
}
}
#line 2441 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2446
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 2448
  mutex_unlock(ldv_func_arg1);
#line 2449
  return;
}
}
#line 2451 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_84(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2456
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 2458
  mutex_unlock(ldv_func_arg1);
#line 2459
  return;
}
}
#line 2461 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_85(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2466
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 2468
  mutex_lock(ldv_func_arg1);
#line 2469
  return;
}
}
#line 2471 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_86(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2476
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 2478
  mutex_unlock(ldv_func_arg1);
#line 2479
  return;
}
}
#line 2481 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_87(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2486
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 2488
  mutex_lock(ldv_func_arg1);
#line 2489
  return;
}
}
#line 2491 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2496
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 2498
  mutex_unlock(ldv_func_arg1);
#line 2499
  return;
}
}
#line 2501 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_89(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2506
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 2508
  mutex_lock(ldv_func_arg1);
#line 2509
  return;
}
}
#line 2511 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2516
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 2518
  mutex_unlock(ldv_func_arg1);
#line 2519
  return;
}
}
#line 2521 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_91(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2526
  ldv_mutex_lock_fb_surf_mutex_of_vmw_master(ldv_func_arg1);
#line 2528
  mutex_lock(ldv_func_arg1);
#line 2529
  return;
}
}
#line 2531 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2536
  ldv_mutex_unlock_fb_surf_mutex_of_vmw_master(ldv_func_arg1);
#line 2538
  mutex_unlock(ldv_func_arg1);
#line 2539
  return;
}
}
#line 2541 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2546
  ldv_mutex_lock_fb_surf_mutex_of_vmw_master(ldv_func_arg1);
#line 2548
  mutex_lock(ldv_func_arg1);
#line 2549
  return;
}
}
#line 2551 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2556
  ldv_mutex_unlock_fb_surf_mutex_of_vmw_master(ldv_func_arg1);
#line 2558
  mutex_unlock(ldv_func_arg1);
#line 2559
  return;
}
}
#line 2561 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2566
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 2568
  mutex_lock(ldv_func_arg1);
#line 2569
  return;
}
}
#line 2571 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2576
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 2578
  mutex_unlock(ldv_func_arg1);
#line 2579
  return;
}
}
#line 2581 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2586
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 2588
  mutex_unlock(ldv_func_arg1);
#line 2589
  return;
}
}
#line 2591 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_98(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2596
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 2598
  mutex_lock(ldv_func_arg1);
#line 2599
  return;
}
}
#line 2601 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_99(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2606
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 2608
  mutex_unlock(ldv_func_arg1);
#line 2609
  return;
}
}
#line 2611 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2616
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2618
  mutex_lock(ldv_func_arg1);
#line 2619
  return;
}
}
#line 2621 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c.prepared"
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2626
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2628
  mutex_unlock(ldv_func_arg1);
#line 2629
  return;
}
}
#line 35 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 

  {
#line 37
  v->counter = i;
#line 38
  return;
}
}
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 171
int ldv_mutex_trylock_132(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_135(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_152(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) ;
#line 232
void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) ;
#line 236
void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) ;
#line 240
void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_134(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_136(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_141(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_143(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_144(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_148(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_151(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) ;
#line 58
void ldv_mutex_lock_156(struct mutex *ldv_func_arg1 ) ;
#line 62
void ldv_mutex_lock_158(struct mutex *ldv_func_arg1 ) ;
#line 66
void ldv_mutex_lock_160(struct mutex *ldv_func_arg1 ) ;
#line 167
void ldv_mutex_lock_release_mutex_of_vmw_private(struct mutex *lock ) ;
#line 171
void ldv_mutex_unlock_release_mutex_of_vmw_private(struct mutex *lock ) ;
#line 189 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_8  ;
#line 190 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_17  ;
#line 191 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_18  ;
#line 192 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_15  ;
#line 193 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_20  ;
#line 194 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_10  ;
#line 195 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_19  ;
#line 196 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_6  ;
#line 197 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_0  ;
#line 198 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_9  ;
#line 199 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_21  ;
#line 200 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_5  ;
#line 201 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_16  ;
#line 202 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_3  ;
#line 203 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_13  ;
#line 204 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_2  ;
#line 205 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ref_cnt  ;
#line 206 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_12  ;
#line 208 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_1  ;
#line 209 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_7  ;
#line 210 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_4  ;
#line 211 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_14  ;
#line 212 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_state_variable_11  ;
#line 18 "include/linux/rwlock.h"
extern void __rwlock_init(rwlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 283 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 

  {
#line 285
  _raw_spin_lock(& lock->ldv_5961.rlock);
#line 286
  return;
}
}
#line 323 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 

  {
#line 325
  _raw_spin_unlock(& lock->ldv_5961.rlock);
#line 326
  return;
}
}
#line 63 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 187 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
extern void iounmap(void volatile   * ) ;
#line 317
extern void *ioremap_wc(resource_size_t  , unsigned long  ) ;
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 2397 "include/linux/fs.h"
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 845 "include/linux/device.h"
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 858 "include/linux/pci.h"
extern int pci_enable_device(struct pci_dev * ) ;
#line 875
extern void pci_disable_device(struct pci_dev * ) ;
#line 878
extern void pci_set_master(struct pci_dev * ) ;
#line 917
extern int pci_save_state(struct pci_dev * ) ;
#line 918
extern void pci_restore_state(struct pci_dev * ) ;
#line 924
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 987
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 989
extern void pci_release_regions(struct pci_dev * ) ;
#line 990
extern int pci_request_region(struct pci_dev * , int  , char const   * ) ;
#line 992
extern void pci_release_region(struct pci_dev * , int  ) ;
#line 1445 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;

  {
#line 1447
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1447
  return (tmp);
}
}
#line 34 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mtrr.h"
extern int mtrr_add(unsigned long  , unsigned long  , unsigned int  , bool  ) ;
#line 38
extern int mtrr_del(int  , unsigned long  , unsigned long  ) ;
#line 114 "include/linux/idr.h"
extern void idr_destroy(struct idr * ) ;
#line 115
extern void idr_init(struct idr * ) ;
#line 62 "include/drm/drm_hashtab.h"
extern void drm_ht_remove(struct drm_open_hash * ) ;
#line 1236 "include/drm/drmP.h"
__inline static int drm_mtrr_add(unsigned long offset , unsigned long size , unsigned int flags ) 
{ int tmp ;

  {
#line 1239
  tmp = mtrr_add(offset, size, flags, 1);
#line 1239
  return (tmp);
}
}
#line 1242 "include/drm/drmP.h"
__inline static int drm_mtrr_del(int handle , unsigned long offset , unsigned long size ,
                                 unsigned int flags ) 
{ int tmp ;

  {
#line 1245
  tmp = mtrr_del(handle, offset, size);
#line 1245
  return (tmp);
}
}
#line 1284
extern long drm_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1286
extern long drm_compat_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1292
extern int drm_open(struct inode * , struct file * ) ;
#line 1294
extern int drm_fasync(int  , struct file * , int  ) ;
#line 1297
extern int drm_release(struct inode * , struct file * ) ;
#line 1424
extern int drm_irq_install(struct drm_device * ) ;
#line 1425
extern int drm_irq_uninstall(struct drm_device * ) ;
#line 1501
extern void drm_put_dev(struct drm_device * ) ;
#line 1751
extern int drm_pci_init(struct drm_driver * , struct pci_driver * ) ;
#line 1752
extern void drm_pci_exit(struct drm_driver * , struct pci_driver * ) ;
#line 1753
extern int drm_get_pci_dev(struct pci_dev * , struct pci_device_id  const  * , struct drm_driver * ) ;
#line 346 "include/linux/suspend.h"
extern int register_pm_notifier(struct notifier_block * ) ;
#line 347
extern int unregister_pm_notifier(struct notifier_block * ) ;
#line 332 "include/drm/ttm/ttm_bo_api.h"
extern int ttm_bo_wait(struct ttm_buffer_object * , bool  , bool  , bool  ) ;
#line 533
extern int ttm_bo_create(struct ttm_bo_device * , unsigned long  , enum ttm_bo_type  ,
                         struct ttm_placement * , uint32_t  , bool  , struct file * ,
                         struct ttm_buffer_object ** ) ;
#line 572
extern int ttm_bo_init_mm(struct ttm_bo_device * , unsigned int  , unsigned long  ) ;
#line 601
extern int ttm_bo_clean_mm(struct ttm_bo_device * , unsigned int  ) ;
#line 622
extern int ttm_bo_evict_mm(struct ttm_bo_device * , unsigned int  ) ;
#line 726
extern void ttm_bo_swapout_all(struct ttm_bo_device * ) ;
#line 731 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_bo_device_release(struct ttm_bo_device * ) ;
#line 747
extern int ttm_bo_device_init(struct ttm_bo_device * , struct ttm_bo_global * , struct ttm_bo_driver * ,
                              uint64_t  , bool  ) ;
#line 231 "include/drm/ttm/ttm_object.h"
extern struct ttm_object_file *ttm_object_file_init(struct ttm_object_device * , unsigned int  ) ;
#line 246
extern void ttm_object_file_release(struct ttm_object_file ** ) ;
#line 257
extern struct ttm_object_device *ttm_object_device_init(struct ttm_mem_global * ,
                                                        unsigned int  ) ;
#line 271
extern void ttm_object_device_release(struct ttm_object_device ** ) ;
#line 87 "include/drm/ttm/ttm_lock.h"
extern void ttm_lock_init(struct ttm_lock * ) ;
#line 164
extern void ttm_suspend_lock(struct ttm_lock * ) ;
#line 173
extern void ttm_suspend_unlock(struct ttm_lock * ) ;
#line 187
extern int ttm_vt_lock(struct ttm_lock * , bool  , struct ttm_object_file * ) ;
#line 199
extern int ttm_vt_unlock(struct ttm_lock * ) ;
#line 239 "include/drm/ttm/ttm_lock.h"
__inline static void ttm_lock_set_kill(struct ttm_lock *lock , bool val , int signal ) 
{ 

  {
#line 242
  lock->kill_takers = val;
#line 243
  if ((int )val) {
#line 244
    lock->signal = signal;
  } else {

  }
#line 245
  return;
}
}
#line 66 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) ;
#line 68
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) ;
#line 98
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) ;
#line 100
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) ;
#line 102
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 105
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 108
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 110
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 112
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) ;
#line 401 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) ;
#line 402
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) ;
#line 427
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 429
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 447
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 449
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 451
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 466
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 468
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 475
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 477
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 490
void vmw_resource_evict_all(struct vmw_private *dev_priv ) ;
#line 519
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 521
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 523
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 525
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 527
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) ;
#line 529
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) ;
#line 536
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
#line 538
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) ;
#line 554
int vmw_ttm_global_init(struct vmw_private *dev_priv ) ;
#line 555
void vmw_ttm_global_release(struct vmw_private *dev_priv ) ;
#line 556
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) ;
#line 564
struct ttm_placement vmw_vram_sys_placement ;
#line 570
struct ttm_bo_driver vmw_bo_driver ;
#line 608
irqreturn_t vmw_irq_handler(int irq , void *arg ) ;
#line 612
void vmw_irq_preinstall(struct drm_device *dev ) ;
#line 613
int vmw_irq_postinstall(struct drm_device *dev ) ;
#line 614
void vmw_irq_uninstall(struct drm_device *dev ) ;
#line 648
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) ;
#line 649
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) ;
#line 651
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) ;
#line 694
int vmw_dumb_create(struct drm_file *file_priv , struct drm_device *dev , struct drm_mode_create_dumb *args ) ;
#line 698
int vmw_dumb_map_offset(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ,
                        uint64_t *offset ) ;
#line 701
int vmw_dumb_destroy(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ) ;
#line 708
int vmw_overlay_init(struct vmw_private *dev_priv ) ;
#line 709
int vmw_overlay_close(struct vmw_private *dev_priv ) ;
#line 710
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
#line 280 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct drm_ioctl_desc vmw_ioctls[21U]  = 
#line 280 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
  {      {0U, 17, & vmw_getparam_ioctl, 3222299712U}, 
        {1U, 17, & vmw_dmabuf_alloc_ioctl, 3222824001U}, 
        {2U, 17, & vmw_dmabuf_unref_ioctl, 1074291778U}, 
        {3U, 26, & vmw_kms_cursor_bypass_ioctl, 1075340355U}, 
        {4U, 26, & vmw_overlay_ioctl, 1079534660U}, 
        {5U, 26, & vmw_stream_claim_ioctl, 2148033605U}, 
        {6U, 26, & vmw_stream_unref_ioctl, 1074291782U}, 
        {7U, 17, & vmw_context_define_ioctl, 2148033607U}, 
        {8U, 17, & vmw_context_destroy_ioctl, 1074291784U}, 
        {9U, 17, & vmw_surface_define_ioctl, 3224396873U}, 
        {10U, 17, & vmw_surface_destroy_ioctl, 1074291786U}, 
        {11U, 17, & vmw_surface_reference_ioctl, 3224396875U}, 
        {12U, 17, & vmw_execbuf_ioctl, 1075864652U}, 
        {13U, 17, & vmw_get_cap_3d_ioctl, 1074816077U}, 
        {14U, 17, & vmw_fence_obj_wait_ioctl, 3223872590U}, 
        {15U, 17, & vmw_fence_obj_signaled_ioctl, 3222824015U}, 
        {16U, 17, & vmw_fence_obj_unref_ioctl, 1074291792U}, 
        {17U, 17, & vmw_fence_event_ioctl, 1075340369U}, 
        {18U, 19, & vmw_present_ioctl, 1075864658U}, 
        {19U, 19, & vmw_present_readback_ioctl, 1075340371U}, 
        {20U, 18, & vmw_kms_update_layout_ioctl, 1074816084U}};
#line 334 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct pci_device_id vmw_pci_id_list[2U]  = {      {5549U, 1029U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 338 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 340 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int enable_fbdev  =    1;
#line 342
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) ;
#line 343
static void vmw_master_init(struct vmw_master *vmaster ) ;
#line 344
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) ;
#line 350 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_print_capabilities(uint32_t capabilities ) 
{ 

  {
#line 352
  printk("\016[drm] Capabilities:\n");
#line 353
  if ((capabilities & 2U) != 0U) {
#line 354
    printk("\016[drm]   Rect copy.\n");
  } else {

  }
#line 355
  if ((capabilities & 32U) != 0U) {
#line 356
    printk("\016[drm]   Cursor.\n");
  } else {

  }
#line 357
  if ((capabilities & 64U) != 0U) {
#line 358
    printk("\016[drm]   Cursor bypass.\n");
  } else {

  }
#line 359
  if ((capabilities & 128U) != 0U) {
#line 360
    printk("\016[drm]   Cursor bypass 2.\n");
  } else {

  }
#line 361
  if ((capabilities & 256U) != 0U) {
#line 362
    printk("\016[drm]   8bit emulation.\n");
  } else {

  }
#line 363
  if ((capabilities & 512U) != 0U) {
#line 364
    printk("\016[drm]   Alpha cursor.\n");
  } else {

  }
#line 365
  if ((capabilities & 16384U) != 0U) {
#line 366
    printk("\016[drm]   3D.\n");
  } else {

  }
#line 367
  if ((capabilities & 32768U) != 0U) {
#line 368
    printk("\016[drm]   Extended Fifo.\n");
  } else {

  }
#line 369
  if ((capabilities & 65536U) != 0U) {
#line 370
    printk("\016[drm]   Multimon.\n");
  } else {

  }
#line 371
  if ((capabilities & 131072U) != 0U) {
#line 372
    printk("\016[drm]   Pitchlock.\n");
  } else {

  }
#line 373
  if ((capabilities & 262144U) != 0U) {
#line 374
    printk("\016[drm]   Irq mask.\n");
  } else {

  }
#line 375
  if ((capabilities & 524288U) != 0U) {
#line 376
    printk("\016[drm]   Display Topology.\n");
  } else {

  }
#line 377
  if ((capabilities & 1048576U) != 0U) {
#line 378
    printk("\016[drm]   GMR.\n");
  } else {

  }
#line 379
  if ((capabilities & 2097152U) != 0U) {
#line 380
    printk("\016[drm]   Traces.\n");
  } else {

  }
#line 381
  if ((capabilities & 4194304U) != 0U) {
#line 382
    printk("\016[drm]   GMR2.\n");
  } else {

  }
#line 383
  if ((capabilities & 8388608U) != 0U) {
#line 384
    printk("\016[drm]   Screen Object 2.\n");
  } else {

  }
#line 385
  return;
}
}
#line 401 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_dummy_query_bo_prepare(struct vmw_private *dev_priv ) 
{ struct ttm_bo_kmap_obj map ;
  SVGA3dQueryResult volatile   *result ;
  bool dummy ;
  int ret ;
  struct ttm_bo_device *bdev ;
  struct ttm_buffer_object *bo ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 407
  bdev = & dev_priv->bdev;
#line 408
  bo = dev_priv->dummy_query_bo;
#line 410
  ttm_bo_reserve(bo, 0, 0, 0, 0U);
#line 411
  spin_lock(& bdev->fence_lock);
#line 412
  ret = ttm_bo_wait(bo, 0, 0, 0);
#line 413
  spin_unlock(& bdev->fence_lock);
#line 414
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 414
  if (tmp != 0L) {
#line 415
    vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 2500UL);
  } else {

  }
#line 418
  ret = ttm_bo_kmap(bo, 0UL, 1UL, & map);
#line 419
  tmp___1 = ldv__builtin_expect(ret == 0, 1L);
#line 419
  if (tmp___1 != 0L) {
#line 420
    tmp___0 = ttm_kmap_obj_virtual(& map, & dummy);
#line 420
    result = (SVGA3dQueryResult volatile   *)tmp___0;
#line 421
    result->totalSize = 12U;
#line 422
    result->state = 0;
#line 423
    result->ldv_38564.result32 = 255U;
#line 424
    ttm_bo_kunmap(& map);
  } else {
#line 426
    drm_err("vmw_dummy_query_bo_prepare", "Dummy query buffer map failed.\n");
  }
#line 427
  ttm_bo_unreserve(bo);
#line 428
  return;
}
}
#line 442 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_dummy_query_bo_create(struct vmw_private *dev_priv ) 
{ int tmp ;

  {
#line 444
  tmp = ttm_bo_create(& dev_priv->bdev, 4096UL, 0, & vmw_vram_sys_placement, 0U, 0,
                      0, & dev_priv->dummy_query_bo);
#line 444
  return (tmp);
}
}
#line 453 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_request_device(struct vmw_private *dev_priv ) 
{ int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 457
  ret = vmw_fifo_init(dev_priv, & dev_priv->fifo);
#line 458
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 458
  if (tmp != 0L) {
#line 459
    drm_err("vmw_request_device", "Unable to initialize FIFO.\n");
#line 460
    return (ret);
  } else {

  }
#line 462
  vmw_fence_fifo_up(dev_priv->fman);
#line 463
  ret = vmw_dummy_query_bo_create(dev_priv);
#line 464
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 464
  if (tmp___0 != 0L) {
#line 465
    goto out_no_query_bo;
  } else {

  }
#line 466
  vmw_dummy_query_bo_prepare(dev_priv);
#line 468
  return (0);
  out_no_query_bo: 
#line 471
  vmw_fence_fifo_down(dev_priv->fman);
#line 472
  vmw_fifo_release(dev_priv, & dev_priv->fifo);
#line 473
  return (ret);
}
}
#line 476 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_release_device(struct vmw_private *dev_priv ) 
{ long tmp ;

  {
#line 483
  tmp = ldv__builtin_expect((unsigned long )dev_priv->pinned_bo != (unsigned long )((struct ttm_buffer_object *)0),
                         0L);
#line 483
  if (tmp != 0L) {
#line 483
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                         "i" (483), "i" (12UL));
    ldv_41484: ;
#line 483
    goto ldv_41484;
  } else {

  }
#line 485
  ttm_bo_unref(& dev_priv->dummy_query_bo);
#line 486
  vmw_fence_fifo_down(dev_priv->fman);
#line 487
  vmw_fifo_release(dev_priv, & dev_priv->fifo);
#line 488
  return;
}
}
#line 496 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int vmw_3d_resource_inc(struct vmw_private *dev_priv , bool unhide_svga ) 
{ int ret ;
  long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  long tmp___2 ;

  {
#line 499
  ret = 0;
#line 501
  ldv_mutex_lock_143(& dev_priv->release_mutex);
#line 502
  tmp___1 = dev_priv->num_3d_resources;
#line 502
  dev_priv->num_3d_resources = dev_priv->num_3d_resources + 1U;
#line 502
  tmp___2 = ldv__builtin_expect(tmp___1 == 0U, 0L);
#line 502
  if (tmp___2 != 0L) {
#line 503
    ret = vmw_request_device(dev_priv);
#line 504
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 504
    if (tmp != 0L) {
#line 505
      dev_priv->num_3d_resources = dev_priv->num_3d_resources - 1U;
    } else {

    }
  } else
#line 506
  if ((int )unhide_svga) {
#line 507
    ldv_mutex_lock_144(& dev_priv->hw_mutex);
#line 508
    tmp___0 = vmw_read(dev_priv, 1U);
#line 508
    vmw_write(dev_priv, 1U, tmp___0 & 4294967293U);
#line 511
    ldv_mutex_unlock_145(& dev_priv->hw_mutex);
  } else {

  }
#line 514
  ldv_mutex_unlock_146(& dev_priv->release_mutex);
#line 515
  return (ret);
}
}
#line 526 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void vmw_3d_resource_dec(struct vmw_private *dev_priv , bool hide_svga ) 
{ int32_t n3d ;
  uint32_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 531
  ldv_mutex_lock_147(& dev_priv->release_mutex);
#line 532
  dev_priv->num_3d_resources = dev_priv->num_3d_resources - 1U;
#line 532
  tmp___0 = ldv__builtin_expect(dev_priv->num_3d_resources == 0U, 0L);
#line 532
  if (tmp___0 != 0L) {
#line 533
    vmw_release_device(dev_priv);
  } else
#line 534
  if ((int )hide_svga) {
#line 535
    ldv_mutex_lock_148(& dev_priv->hw_mutex);
#line 536
    tmp = vmw_read(dev_priv, 1U);
#line 536
    vmw_write(dev_priv, 1U, tmp | 2U);
#line 539
    ldv_mutex_unlock_149(& dev_priv->hw_mutex);
  } else {

  }
#line 542
  n3d = (int )dev_priv->num_3d_resources;
#line 543
  ldv_mutex_unlock_150(& dev_priv->release_mutex);
#line 545
  tmp___1 = ldv__builtin_expect(n3d < 0, 0L);
#line 545
  if (tmp___1 != 0L) {
#line 545
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                         "i" (545), "i" (12UL));
    ldv_41495: ;
#line 545
    goto ldv_41495;
  } else {

  }
#line 547
  return;
}
}
#line 557 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_get_initial_size(struct vmw_private *dev_priv ) 
{ uint32_t width ;
  uint32_t height ;
  uint32_t __max1 ;
  uint32_t __max2 ;
  uint32_t tmp ;
  uint32_t __max1___0 ;
  uint32_t __max2___0 ;
  uint32_t tmp___0 ;

  {
#line 562
  width = vmw_read(dev_priv, 2U);
#line 563
  height = vmw_read(dev_priv, 3U);
#line 565
  __max1 = width;
#line 565
  __max2 = 800U;
#line 565
  if (__max1 > __max2) {
#line 565
    tmp = __max1;
  } else {
#line 565
    tmp = __max2;
  }
#line 565
  width = tmp;
#line 566
  __max1___0 = height;
#line 566
  __max2___0 = 600U;
#line 566
  if (__max1___0 > __max2___0) {
#line 566
    tmp___0 = __max1___0;
  } else {
#line 566
    tmp___0 = __max2___0;
  }
#line 566
  height = tmp___0;
#line 568
  if (dev_priv->fb_max_width < width || dev_priv->fb_max_height < height) {
#line 575
    width = 800U;
#line 576
    height = 600U;
  } else {

  }
#line 579
  dev_priv->initial_width = width;
#line 580
  dev_priv->initial_height = height;
#line 581
  return;
}
}
#line 583 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_load(struct drm_device *dev , unsigned long chipset ) 
{ struct vmw_private *dev_priv ;
  int ret ;
  uint32_t svga_id ;
  enum vmw_res_type i ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;

  {
#line 590
  tmp = kzalloc(169840UL, 208U);
#line 590
  dev_priv = (struct vmw_private *)tmp;
#line 591
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv == (unsigned long )((struct vmw_private *)0),
                             0L);
#line 591
  if (tmp___0 != 0L) {
#line 592
    drm_err("vmw_driver_load", "Failed allocating a device private struct.\n");
#line 593
    return (-12);
  } else {

  }
#line 596
  pci_set_master(dev->pdev);
#line 598
  dev_priv->dev = dev;
#line 599
  dev_priv->vmw_chipset = chipset;
#line 600
  dev_priv->last_read_seqno = 4294967196U;
#line 601
  __mutex_init(& dev_priv->hw_mutex, "&dev_priv->hw_mutex", & __key);
#line 602
  __mutex_init(& dev_priv->cmdbuf_mutex, "&dev_priv->cmdbuf_mutex", & __key___0);
#line 603
  __mutex_init(& dev_priv->release_mutex, "&dev_priv->release_mutex", & __key___1);
#line 604
  __rwlock_init(& dev_priv->resource_lock, "&dev_priv->resource_lock", & __key___2);
#line 606
  i = 0;
#line 606
  goto ldv_41521;
  ldv_41520: 
#line 607
  idr_init((struct idr *)(& dev_priv->res_idr) + (unsigned long )i);
#line 608
  INIT_LIST_HEAD((struct list_head *)(& dev_priv->res_lru) + (unsigned long )i);
#line 606
  i = (enum vmw_res_type )((unsigned int )i + 1U);
  ldv_41521: ;
#line 606
  if ((unsigned int )i <= 2U) {
#line 607
    goto ldv_41520;
  } else {
#line 609
    goto ldv_41522;
  }
  ldv_41522: 
#line 611
  __mutex_init(& dev_priv->init_mutex, "&dev_priv->init_mutex", & __key___3);
#line 612
  __init_waitqueue_head(& dev_priv->fence_queue, "&dev_priv->fence_queue", & __key___4);
#line 613
  __init_waitqueue_head(& dev_priv->fifo_queue, "&dev_priv->fifo_queue", & __key___5);
#line 614
  dev_priv->fence_queue_waiters = 0;
#line 615
  atomic_set(& dev_priv->fifo_queue_waiters, 0);
#line 617
  dev_priv->used_memory_size = 0U;
#line 619
  dev_priv->io_start = (unsigned int )(dev->pdev)->resource[0].start;
#line 620
  dev_priv->vram_start = (uint32_t )(dev->pdev)->resource[1].start;
#line 621
  dev_priv->mmio_start = (uint32_t )(dev->pdev)->resource[2].start;
#line 623
  dev_priv->enable_fb = enable_fbdev != 0;
#line 625
  ldv_mutex_lock_151(& dev_priv->hw_mutex);
#line 627
  vmw_write(dev_priv, 0U, 2415919106U);
#line 628
  svga_id = vmw_read(dev_priv, 0U);
#line 629
  if (svga_id != 2415919106U) {
#line 630
    ret = -38;
#line 631
    drm_err("vmw_driver_load", "Unsupported SVGA ID 0x%x\n", svga_id);
#line 632
    ldv_mutex_unlock_152(& dev_priv->hw_mutex);
#line 633
    goto out_err0;
  } else {

  }
#line 636
  dev_priv->capabilities = vmw_read(dev_priv, 17U);
#line 638
  dev_priv->vram_size = vmw_read(dev_priv, 15U);
#line 639
  dev_priv->mmio_size = vmw_read(dev_priv, 19U);
#line 640
  dev_priv->fb_max_width = vmw_read(dev_priv, 4U);
#line 641
  dev_priv->fb_max_height = vmw_read(dev_priv, 5U);
#line 643
  vmw_get_initial_size(dev_priv);
#line 645
  if ((dev_priv->capabilities & 1048576U) != 0U) {
#line 646
    dev_priv->max_gmr_descriptors = vmw_read(dev_priv, 44U);
#line 649
    dev_priv->max_gmr_ids = vmw_read(dev_priv, 43U);
  } else {

  }
#line 652
  if ((dev_priv->capabilities & 4194304U) != 0U) {
#line 653
    dev_priv->max_gmr_pages = vmw_read(dev_priv, 46U);
#line 655
    dev_priv->memory_size = vmw_read(dev_priv, 47U);
#line 657
    dev_priv->memory_size = dev_priv->memory_size - dev_priv->vram_size;
  } else {
#line 663
    dev_priv->memory_size = 536870912U;
  }
#line 666
  ldv_mutex_unlock_153(& dev_priv->hw_mutex);
#line 668
  vmw_print_capabilities(dev_priv->capabilities);
#line 670
  if ((dev_priv->capabilities & 1048576U) != 0U) {
#line 671
    printk("\016[drm] Max GMR ids is %u\n", dev_priv->max_gmr_ids);
#line 673
    printk("\016[drm] Max GMR descriptors is %u\n", dev_priv->max_gmr_descriptors);
  } else {

  }
#line 676
  if ((dev_priv->capabilities & 4194304U) != 0U) {
#line 677
    printk("\016[drm] Max number of GMR pages is %u\n", dev_priv->max_gmr_pages);
#line 679
    printk("\016[drm] Max dedicated hypervisor surface memory is %u kiB\n", dev_priv->memory_size / 1024U);
  } else {

  }
#line 682
  printk("\016[drm] VRAM at 0x%08x size is %u kiB\n", dev_priv->vram_start, dev_priv->vram_size / 1024U);
#line 684
  printk("\016[drm] MMIO at 0x%08x size is %u kiB\n", dev_priv->mmio_start, dev_priv->mmio_size / 1024U);
#line 687
  ret = vmw_ttm_global_init(dev_priv);
#line 688
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 688
  if (tmp___1 != 0L) {
#line 689
    goto out_err0;
  } else {

  }
#line 692
  vmw_master_init(& dev_priv->fbdev_master);
#line 693
  ttm_lock_set_kill(& dev_priv->fbdev_master.lock, 0, 15);
#line 694
  dev_priv->active_master = & dev_priv->fbdev_master;
#line 697
  ret = ttm_bo_device_init(& dev_priv->bdev, (struct ttm_bo_global *)dev_priv->bo_global_ref.ref.object,
                           & vmw_bo_driver, 1048576ULL, 0);
#line 701
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 701
  if (tmp___2 != 0L) {
#line 702
    drm_err("vmw_driver_load", "Failed initializing TTM buffer object driver.\n");
#line 703
    goto out_err1;
  } else {

  }
#line 706
  ret = ttm_bo_init_mm(& dev_priv->bdev, 2U, (unsigned long )(dev_priv->vram_size >> 12));
#line 708
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 708
  if (tmp___3 != 0L) {
#line 709
    drm_err("vmw_driver_load", "Failed initializing memory manager for VRAM.\n");
#line 710
    goto out_err2;
  } else {

  }
#line 713
  dev_priv->has_gmr = 1;
#line 714
  tmp___4 = ttm_bo_init_mm(& dev_priv->bdev, 3U, (unsigned long )dev_priv->max_gmr_ids);
#line 714
  if (tmp___4 != 0) {
#line 716
    printk("\016[drm] No GMR memory available. Graphics memory resources are very limited.\n");
#line 718
    dev_priv->has_gmr = 0;
  } else {

  }
#line 721
  dev_priv->mmio_mtrr = drm_mtrr_add((unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
                                     1U);
#line 724
  tmp___5 = ioremap_wc((resource_size_t )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size);
#line 724
  dev_priv->mmio_virt = (__le32 *)tmp___5;
#line 727
  tmp___6 = ldv__builtin_expect((unsigned long )dev_priv->mmio_virt == (unsigned long )((__le32 *)0),
                             0L);
#line 727
  if (tmp___6 != 0L) {
#line 728
    ret = -12;
#line 729
    drm_err("vmw_driver_load", "Failed mapping MMIO.\n");
#line 730
    goto out_err3;
  } else {

  }
#line 734
  if ((dev_priv->capabilities & 524288U) == 0U && (dev_priv->capabilities & 131072U) == 0U) {
#line 734
    tmp___7 = vmw_fifo_have_pitchlock(dev_priv);
#line 734
    if (tmp___7) {
#line 734
      tmp___8 = 0;
    } else {
#line 734
      tmp___8 = 1;
    }
#line 734
    if (tmp___8) {
#line 737
      ret = -38;
#line 738
      drm_err("vmw_driver_load", "Hardware has no pitchlock\n");
#line 739
      goto out_err4;
    } else {

    }
  } else {

  }
#line 742
  dev_priv->tdev = ttm_object_device_init((struct ttm_mem_global *)dev_priv->mem_global_ref.object,
                                          12U);
#line 745
  tmp___9 = ldv__builtin_expect((unsigned long )dev_priv->tdev == (unsigned long )((struct ttm_object_device *)0),
                             0L);
#line 745
  if (tmp___9 != 0L) {
#line 746
    drm_err("vmw_driver_load", "Unable to initialize TTM object management.\n");
#line 747
    ret = -12;
#line 748
    goto out_err4;
  } else {

  }
#line 751
  dev->dev_private = (void *)dev_priv;
#line 753
  ret = pci_request_regions(dev->pdev, "vmwgfx probe");
#line 754
  dev_priv->stealth = ret != 0;
#line 755
  if ((int )dev_priv->stealth) {
#line 760
    printk("\016[drm] It appears like vesafb is loaded. Ignore above error if any.\n");
#line 762
    ret = pci_request_region(dev->pdev, 2, "vmwgfx stealth probe");
#line 763
    tmp___10 = ldv__builtin_expect(ret != 0, 0L);
#line 763
    if (tmp___10 != 0L) {
#line 764
      drm_err("vmw_driver_load", "Failed reserving the SVGA MMIO resource.\n");
#line 765
      goto out_no_device;
    } else {

    }
  } else {

  }
#line 769
  if ((dev_priv->capabilities & 262144U) != 0U) {
#line 770
    ret = drm_irq_install(dev);
#line 771
    if (ret != 0) {
#line 772
      drm_err("vmw_driver_load", "Failed installing irq: %d\n", ret);
#line 773
      goto out_no_irq;
    } else {

    }
  } else {

  }
#line 777
  dev_priv->fman = vmw_fence_manager_init(dev_priv);
#line 778
  tmp___11 = ldv__builtin_expect((unsigned long )dev_priv->fman == (unsigned long )((struct vmw_fence_manager *)0),
                              0L);
#line 778
  if (tmp___11 != 0L) {
#line 779
    goto out_no_fman;
  } else {

  }
#line 781
  vmw_kms_save_vga(dev_priv);
#line 784
  ret = vmw_kms_init(dev_priv);
#line 785
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 785
  if (tmp___12 != 0L) {
#line 786
    goto out_no_kms;
  } else {

  }
#line 787
  vmw_overlay_init(dev_priv);
#line 789
  if ((int )dev_priv->enable_fb) {
#line 790
    ret = vmw_3d_resource_inc(dev_priv, 1);
#line 791
    tmp___13 = ldv__builtin_expect(ret != 0, 0L);
#line 791
    if (tmp___13 != 0L) {
#line 792
      goto out_no_fifo;
    } else {

    }
#line 793
    vmw_fb_init(dev_priv);
  } else {

  }
#line 796
  dev_priv->pm_nb.notifier_call = & vmwgfx_pm_notifier;
#line 797
  register_pm_notifier(& dev_priv->pm_nb);
#line 799
  return (0);
  out_no_fifo: 
#line 802
  vmw_overlay_close(dev_priv);
#line 803
  vmw_kms_close(dev_priv);
  out_no_kms: 
#line 805
  vmw_kms_restore_vga(dev_priv);
#line 806
  vmw_fence_manager_takedown(dev_priv->fman);
  out_no_fman: ;
#line 808
  if ((dev_priv->capabilities & 262144U) != 0U) {
#line 809
    drm_irq_uninstall(dev_priv->dev);
  } else {

  }
  out_no_irq: ;
#line 811
  if ((int )dev_priv->stealth) {
#line 812
    pci_release_region(dev->pdev, 2);
  } else {
#line 814
    pci_release_regions(dev->pdev);
  }
  out_no_device: 
#line 816
  ttm_object_device_release(& dev_priv->tdev);
  out_err4: 
#line 818
  iounmap((void volatile   *)dev_priv->mmio_virt);
  out_err3: 
#line 820
  drm_mtrr_del(dev_priv->mmio_mtrr, (unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
               1U);
#line 822
  if ((int )dev_priv->has_gmr) {
#line 823
    ttm_bo_clean_mm(& dev_priv->bdev, 3U);
  } else {

  }
#line 824
  ttm_bo_clean_mm(& dev_priv->bdev, 2U);
  out_err2: 
#line 826
  ttm_bo_device_release(& dev_priv->bdev);
  out_err1: 
#line 828
  vmw_ttm_global_release(dev_priv);
  out_err0: 
#line 830
  i = 0;
#line 830
  goto ldv_41537;
  ldv_41536: 
#line 831
  idr_destroy((struct idr *)(& dev_priv->res_idr) + (unsigned long )i);
#line 830
  i = (enum vmw_res_type )((unsigned int )i + 1U);
  ldv_41537: ;
#line 830
  if ((unsigned int )i <= 2U) {
#line 831
    goto ldv_41536;
  } else {
#line 833
    goto ldv_41538;
  }
  ldv_41538: 
#line 833
  kfree((void const   *)dev_priv);
#line 834
  return (ret);
}
}
#line 837 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_unload(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  enum vmw_res_type i ;

  {
#line 839
  tmp = vmw_priv(dev);
#line 839
  dev_priv = tmp;
#line 842
  unregister_pm_notifier(& dev_priv->pm_nb);
#line 844
  if ((int )dev_priv->ctx.res_ht_initialized) {
#line 845
    drm_ht_remove(& dev_priv->ctx.res_ht);
  } else {

  }
#line 846
  if ((unsigned long )dev_priv->ctx.cmd_bounce != (unsigned long )((uint32_t *)0)) {
#line 847
    vfree((void const   *)dev_priv->ctx.cmd_bounce);
  } else {

  }
#line 848
  if ((int )dev_priv->enable_fb) {
#line 849
    vmw_fb_close(dev_priv);
#line 850
    vmw_kms_restore_vga(dev_priv);
#line 851
    vmw_3d_resource_dec(dev_priv, 0);
  } else {

  }
#line 853
  vmw_kms_close(dev_priv);
#line 854
  vmw_overlay_close(dev_priv);
#line 855
  vmw_fence_manager_takedown(dev_priv->fman);
#line 856
  if ((dev_priv->capabilities & 262144U) != 0U) {
#line 857
    drm_irq_uninstall(dev_priv->dev);
  } else {

  }
#line 858
  if ((int )dev_priv->stealth) {
#line 859
    pci_release_region(dev->pdev, 2);
  } else {
#line 861
    pci_release_regions(dev->pdev);
  }
#line 863
  ttm_object_device_release(& dev_priv->tdev);
#line 864
  iounmap((void volatile   *)dev_priv->mmio_virt);
#line 865
  drm_mtrr_del(dev_priv->mmio_mtrr, (unsigned long )dev_priv->mmio_start, (unsigned long )dev_priv->mmio_size,
               1U);
#line 867
  if ((int )dev_priv->has_gmr) {
#line 868
    ttm_bo_clean_mm(& dev_priv->bdev, 3U);
  } else {

  }
#line 869
  ttm_bo_clean_mm(& dev_priv->bdev, 2U);
#line 870
  ttm_bo_device_release(& dev_priv->bdev);
#line 871
  vmw_ttm_global_release(dev_priv);
#line 873
  i = 0;
#line 873
  goto ldv_41545;
  ldv_41544: 
#line 874
  idr_destroy((struct idr *)(& dev_priv->res_idr) + (unsigned long )i);
#line 873
  i = (enum vmw_res_type )((unsigned int )i + 1U);
  ldv_41545: ;
#line 873
  if ((unsigned int )i <= 2U) {
#line 874
    goto ldv_41544;
  } else {
#line 876
    goto ldv_41546;
  }
  ldv_41546: 
#line 876
  kfree((void const   *)dev_priv);
#line 878
  return (0);
}
}
#line 881 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_preclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 884
  tmp = vmw_fpriv(file_priv);
#line 884
  vmw_fp = tmp;
#line 885
  tmp___0 = vmw_priv(dev);
#line 885
  dev_priv = tmp___0;
#line 887
  vmw_event_fence_fpriv_gone(dev_priv->fman, & vmw_fp->fence_events);
#line 888
  return;
}
}
#line 890 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_postclose(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_fpriv *vmw_fp ;

  {
#line 895
  vmw_fp = vmw_fpriv(file_priv);
#line 896
  ttm_object_file_release(& vmw_fp->tfile);
#line 897
  if ((unsigned long )vmw_fp->locked_master != (unsigned long )((struct drm_master *)0)) {
#line 898
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 899
  kfree((void const   *)vmw_fp);
#line 900
  return;
}
}
#line 902 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_driver_open(struct drm_device *dev , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  int ret ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 904
  tmp = vmw_priv(dev);
#line 904
  dev_priv = tmp;
#line 906
  ret = -12;
#line 908
  tmp___0 = kzalloc(32UL, 208U);
#line 908
  vmw_fp = (struct vmw_fpriv *)tmp___0;
#line 909
  tmp___1 = ldv__builtin_expect((unsigned long )vmw_fp == (unsigned long )((struct vmw_fpriv *)0),
                             0L);
#line 909
  if (tmp___1 != 0L) {
#line 910
    return (ret);
  } else {

  }
#line 912
  INIT_LIST_HEAD(& vmw_fp->fence_events);
#line 913
  vmw_fp->tfile = ttm_object_file_init(dev_priv->tdev, 10U);
#line 914
  tmp___2 = ldv__builtin_expect((unsigned long )vmw_fp->tfile == (unsigned long )((struct ttm_object_file *)0),
                             0L);
#line 914
  if (tmp___2 != 0L) {
#line 915
    goto out_no_tfile;
  } else {

  }
#line 917
  file_priv->driver_priv = (void *)vmw_fp;
#line 918
  dev_priv->bdev.dev_mapping = dev->dev_mapping;
#line 920
  return (0);
  out_no_tfile: 
#line 923
  kfree((void const   *)vmw_fp);
#line 924
  return (ret);
}
}
#line 927 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static long vmw_unlocked_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) 
{ struct drm_file *file_priv ;
  struct drm_device *dev ;
  unsigned int nr ;
  struct drm_ioctl_desc *ioctl ;
  long tmp ;
  long tmp___0 ;

  {
#line 930
  file_priv = (struct drm_file *)filp->private_data;
#line 931
  dev = (file_priv->minor)->dev;
#line 932
  nr = cmd & 255U;
#line 938
  if ((nr > 63U && nr <= 159U) && (unsigned int )((dev->driver)->num_ioctls + 64) > nr) {
#line 940
    ioctl = (struct drm_ioctl_desc *)(& vmw_ioctls) + (unsigned long )(nr - 64U);
#line 943
    tmp = ldv__builtin_expect(ioctl->cmd_drv != cmd, 0L);
#line 943
    if (tmp != 0L) {
#line 944
      drm_err("vmw_unlocked_ioctl", "Invalid command format, ioctl %d\n", nr - 64U);
#line 946
      return (-22L);
    } else {

    }
  } else {

  }
#line 950
  tmp___0 = drm_ioctl(filp, cmd, arg);
#line 950
  return (tmp___0);
}
}
#line 953 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_firstopen(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;

  {
#line 955
  tmp = vmw_priv(dev);
#line 955
  dev_priv = tmp;
#line 956
  dev_priv->is_opened = 1;
#line 958
  return (0);
}
}
#line 961 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_lastclose(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_crtc *crtc ;
  struct drm_mode_set set ;
  int ret ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 963
  tmp = vmw_priv(dev);
#line 963
  dev_priv = tmp;
#line 972
  if (! dev_priv->is_opened) {
#line 973
    return;
  } else {

  }
#line 975
  dev_priv->is_opened = 0;
#line 976
  set.x = 0U;
#line 977
  set.y = 0U;
#line 978
  set.fb = 0;
#line 979
  set.mode = 0;
#line 980
  set.connectors = 0;
#line 981
  set.num_connectors = 0UL;
#line 983
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
#line 983
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
#line 983
  goto ldv_41594;
  ldv_41593: 
#line 984
  set.crtc = crtc;
#line 985
  ret = (*((crtc->funcs)->set_config))(& set);
#line 986
  __ret_warn_on = ret != 0;
#line 986
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 986
  if (tmp___0 != 0L) {
#line 986
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared",
                       986);
  } else {

  }
#line 986
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 983
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
#line 983
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_41594: ;
#line 983
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
#line 984
    goto ldv_41593;
  } else {
#line 986
    goto ldv_41595;
  }
  ldv_41595: ;
#line 988
  return;
}
}
#line 991 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_init(struct vmw_master *vmaster ) 
{ struct lock_class_key __key ;

  {
#line 993
  ttm_lock_init(& vmaster->lock);
#line 994
  INIT_LIST_HEAD(& vmaster->fb_surf);
#line 995
  __mutex_init(& vmaster->fb_surf_mutex, "&vmaster->fb_surf_mutex", & __key);
#line 997
  return;
}
}
#line 998 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_master_create(struct drm_device *dev , struct drm_master *master ) 
{ struct vmw_master *vmaster ;
  void *tmp ;
  long tmp___0 ;

  {
#line 1003
  tmp = kzalloc(448UL, 208U);
#line 1003
  vmaster = (struct vmw_master *)tmp;
#line 1004
  tmp___0 = ldv__builtin_expect((unsigned long )vmaster == (unsigned long )((struct vmw_master *)0),
                             0L);
#line 1004
  if (tmp___0 != 0L) {
#line 1005
    return (-12);
  } else {

  }
#line 1007
  vmw_master_init(vmaster);
#line 1008
  ttm_lock_set_kill(& vmaster->lock, 1, 15);
#line 1009
  master->driver_priv = (void *)vmaster;
#line 1011
  return (0);
}
}
#line 1014 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_destroy(struct drm_device *dev , struct drm_master *master ) 
{ struct vmw_master *vmaster ;
  struct vmw_master *tmp ;

  {
#line 1017
  tmp = vmw_master(master);
#line 1017
  vmaster = tmp;
#line 1019
  master->driver_priv = 0;
#line 1020
  kfree((void const   *)vmaster);
#line 1021
  return;
}
}
#line 1024 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_master_set(struct drm_device *dev , struct drm_file *file_priv , bool from_open ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_master *active ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  int ret ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 1028
  tmp = vmw_priv(dev);
#line 1028
  dev_priv = tmp;
#line 1029
  tmp___0 = vmw_fpriv(file_priv);
#line 1029
  vmw_fp = tmp___0;
#line 1030
  active = dev_priv->active_master;
#line 1031
  tmp___1 = vmw_master(file_priv->master);
#line 1031
  vmaster = tmp___1;
#line 1032
  ret = 0;
#line 1034
  if (! dev_priv->enable_fb) {
#line 1035
    ret = vmw_3d_resource_inc(dev_priv, 1);
#line 1036
    tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1036
    if (tmp___2 != 0L) {
#line 1037
      return (ret);
    } else {

    }
#line 1038
    vmw_kms_save_vga(dev_priv);
#line 1039
    ldv_mutex_lock_154(& dev_priv->hw_mutex);
#line 1040
    vmw_write(dev_priv, 45U, 0U);
#line 1041
    ldv_mutex_unlock_155(& dev_priv->hw_mutex);
  } else {

  }
#line 1044
  if ((unsigned long )active != (unsigned long )((struct vmw_master *)0)) {
#line 1045
    tmp___3 = ldv__builtin_expect((unsigned long )(& dev_priv->fbdev_master) != (unsigned long )active,
                               0L);
#line 1045
    if (tmp___3 != 0L) {
#line 1045
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                           "i" (1045), "i" (12UL));
      ldv_41620: ;
#line 1045
      goto ldv_41620;
    } else {

    }
#line 1046
    ret = ttm_vt_lock(& active->lock, 0, vmw_fp->tfile);
#line 1047
    tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 1047
    if (tmp___4 != 0L) {
#line 1048
      goto out_no_active_lock;
    } else {

    }
#line 1050
    ttm_lock_set_kill(& active->lock, 1, 15);
#line 1051
    ret = ttm_bo_evict_mm(& dev_priv->bdev, 2U);
#line 1052
    tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1052
    if (tmp___5 != 0L) {
#line 1053
      drm_err("vmw_master_set", "Unable to clean VRAM on master drop.\n");
    } else {

    }
#line 1057
    dev_priv->active_master = 0;
  } else {

  }
#line 1060
  ttm_lock_set_kill(& vmaster->lock, 0, 15);
#line 1061
  if (! from_open) {
#line 1062
    ttm_vt_unlock(& vmaster->lock);
#line 1063
    tmp___6 = ldv__builtin_expect((unsigned long )vmw_fp->locked_master != (unsigned long )file_priv->master,
                               0L);
#line 1063
    if (tmp___6 != 0L) {
#line 1063
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"),
                           "i" (1063), "i" (12UL));
      ldv_41623: ;
#line 1063
      goto ldv_41623;
    } else {

    }
#line 1064
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 1067
  dev_priv->active_master = vmaster;
#line 1069
  return (0);
  out_no_active_lock: ;
#line 1072
  if (! dev_priv->enable_fb) {
#line 1073
    vmw_kms_restore_vga(dev_priv);
#line 1074
    vmw_3d_resource_dec(dev_priv, 1);
#line 1075
    ldv_mutex_lock_156(& dev_priv->hw_mutex);
#line 1076
    vmw_write(dev_priv, 45U, 1U);
#line 1077
    ldv_mutex_unlock_157(& dev_priv->hw_mutex);
  } else {

  }
#line 1079
  return (ret);
}
}
#line 1082 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_master_drop(struct drm_device *dev , struct drm_file *file_priv ,
                            bool from_release ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  int ret ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1086
  tmp = vmw_priv(dev);
#line 1086
  dev_priv = tmp;
#line 1087
  tmp___0 = vmw_fpriv(file_priv);
#line 1087
  vmw_fp = tmp___0;
#line 1088
  tmp___1 = vmw_master(file_priv->master);
#line 1088
  vmaster = tmp___1;
#line 1096
  vmw_fp->locked_master = drm_master_get(file_priv->master);
#line 1097
  ret = ttm_vt_lock(& vmaster->lock, 0, vmw_fp->tfile);
#line 1098
  vmw_execbuf_release_pinned_bo(dev_priv);
#line 1100
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1100
  if (tmp___2 != 0L) {
#line 1101
    drm_err("vmw_master_drop", "Unable to lock TTM at VT switch.\n");
#line 1102
    drm_master_put(& vmw_fp->locked_master);
  } else {

  }
#line 1105
  ttm_lock_set_kill(& vmaster->lock, 1, 15);
#line 1107
  if (! dev_priv->enable_fb) {
#line 1108
    ret = ttm_bo_evict_mm(& dev_priv->bdev, 2U);
#line 1109
    tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1109
    if (tmp___3 != 0L) {
#line 1110
      drm_err("vmw_master_drop", "Unable to clean VRAM on master drop.\n");
    } else {

    }
#line 1111
    vmw_kms_restore_vga(dev_priv);
#line 1112
    vmw_3d_resource_dec(dev_priv, 1);
#line 1113
    ldv_mutex_lock_158(& dev_priv->hw_mutex);
#line 1114
    vmw_write(dev_priv, 45U, 1U);
#line 1115
    ldv_mutex_unlock_159(& dev_priv->hw_mutex);
  } else {

  }
#line 1118
  dev_priv->active_master = & dev_priv->fbdev_master;
#line 1119
  ttm_lock_set_kill(& dev_priv->fbdev_master.lock, 0, 15);
#line 1120
  ttm_vt_unlock(& dev_priv->fbdev_master.lock);
#line 1122
  if ((int )dev_priv->enable_fb) {
#line 1123
    vmw_fb_on(dev_priv);
  } else {

  }
#line 1124
  return;
}
}
#line 1127 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_remove(struct pci_dev *pdev ) 
{ struct drm_device *dev ;
  void *tmp ;

  {
#line 1129
  tmp = pci_get_drvdata(pdev);
#line 1129
  dev = (struct drm_device *)tmp;
#line 1131
  drm_put_dev(dev);
#line 1132
  return;
}
}
#line 1134 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmwgfx_pm_notifier(struct notifier_block *nb , unsigned long val , void *ptr ) 
{ struct vmw_private *dev_priv ;
  struct notifier_block  const  *__mptr ;
  struct vmw_master *vmaster ;

  {
#line 1138
  __mptr = (struct notifier_block  const  *)nb;
#line 1138
  dev_priv = (struct vmw_private *)__mptr + 0xfffffffffffd69b8UL;
#line 1139
  vmaster = dev_priv->active_master;
#line 1141
  switch (val) {
  case 1: ;
  case 3: 
#line 1144
  ttm_suspend_lock(& vmaster->lock);
#line 1150
  vmw_execbuf_release_pinned_bo(dev_priv);
#line 1151
  vmw_resource_evict_all(dev_priv);
#line 1152
  ttm_bo_swapout_all(& dev_priv->bdev);
#line 1154
  goto ldv_41649;
  case 2: ;
  case 4: ;
  case 6: 
#line 1158
  ttm_suspend_unlock(& vmaster->lock);
#line 1160
  goto ldv_41649;
  case 5: ;
#line 1162
  goto ldv_41649;
  default: ;
#line 1164
  goto ldv_41649;
  }
  ldv_41649: ;
#line 1166
  return (0);
}
}
#line 1173 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pci_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1175
  tmp = pci_get_drvdata(pdev);
#line 1175
  dev = (struct drm_device *)tmp;
#line 1176
  tmp___0 = vmw_priv(dev);
#line 1176
  dev_priv = tmp___0;
#line 1178
  if (dev_priv->num_3d_resources != 0U) {
#line 1179
    printk("\016[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
#line 1181
    return (-16);
  } else {

  }
#line 1184
  pci_save_state(pdev);
#line 1185
  pci_disable_device(pdev);
#line 1186
  pci_set_power_state(pdev, 3);
#line 1187
  return (0);
}
}
#line 1190 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pci_resume(struct pci_dev *pdev ) 
{ int tmp ;

  {
#line 1192
  pci_set_power_state(pdev, 0);
#line 1193
  pci_restore_state(pdev);
#line 1194
  tmp = pci_enable_device(pdev);
#line 1194
  return (tmp);
}
}
#line 1197 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_suspend(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct pm_message dummy ;
  int tmp ;

  {
#line 1199
  __mptr = (struct device  const  *)kdev;
#line 1199
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 1202
  dummy.event = 0;
#line 1204
  tmp = vmw_pci_suspend(pdev, dummy);
#line 1204
  return (tmp);
}
}
#line 1207 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_resume(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 1209
  __mptr = (struct device  const  *)kdev;
#line 1209
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 1211
  tmp = vmw_pci_resume(pdev);
#line 1211
  return (tmp);
}
}
#line 1214 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_pm_prepare(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1216
  __mptr = (struct device  const  *)kdev;
#line 1216
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 1217
  tmp = pci_get_drvdata(pdev);
#line 1217
  dev = (struct drm_device *)tmp;
#line 1218
  tmp___0 = vmw_priv(dev);
#line 1218
  dev_priv = tmp___0;
#line 1224
  dev_priv->suspended = 1;
#line 1225
  if ((int )dev_priv->enable_fb) {
#line 1226
    vmw_3d_resource_dec(dev_priv, 1);
  } else {

  }
#line 1228
  if (dev_priv->num_3d_resources != 0U) {
#line 1230
    printk("\016[drm] Can\'t suspend or hibernate while 3D resources are active.\n");
#line 1233
    if ((int )dev_priv->enable_fb) {
#line 1234
      vmw_3d_resource_inc(dev_priv, 1);
    } else {

    }
#line 1235
    dev_priv->suspended = 0;
#line 1236
    return (-16);
  } else {

  }
#line 1239
  return (0);
}
}
#line 1242 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmw_pm_complete(struct device *kdev ) 
{ struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;

  {
#line 1244
  __mptr = (struct device  const  *)kdev;
#line 1244
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 1245
  tmp = pci_get_drvdata(pdev);
#line 1245
  dev = (struct drm_device *)tmp;
#line 1246
  tmp___0 = vmw_priv(dev);
#line 1246
  dev_priv = tmp___0;
#line 1248
  ldv_mutex_lock_160(& dev_priv->hw_mutex);
#line 1249
  vmw_write(dev_priv, 0U, 2415919106U);
#line 1250
  vmw_read(dev_priv, 0U);
#line 1251
  ldv_mutex_unlock_161(& dev_priv->hw_mutex);
#line 1257
  if ((int )dev_priv->enable_fb) {
#line 1258
    vmw_3d_resource_inc(dev_priv, 0);
  } else {

  }
#line 1260
  dev_priv->suspended = 0;
#line 1261
  return;
}
}
#line 1263 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct dev_pm_ops  const  vmw_pm_ops  = 
#line 1263
     {& vmw_pm_prepare, & vmw_pm_complete, & vmw_pm_suspend, & vmw_pm_resume, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1270 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct file_operations  const  vmwgfx_driver_fops  = 
#line 1270
     {& __this_module, & noop_llseek, & vmw_fops_read, 0, 0, 0, 0, & vmw_fops_poll,
    & vmw_unlocked_ioctl, & drm_compat_ioctl, & vmw_mmap, & drm_open, 0, & drm_release,
    0, 0, & drm_fasync, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 1285 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct drm_driver driver  = 
#line 1285
     {& vmw_driver_load, & vmw_firstopen, & vmw_driver_open, & vmw_preclose, & vmw_postclose,
    & vmw_lastclose, & vmw_driver_unload, 0, 0, 0, 0, 0, & vmw_get_vblank_counter,
    & vmw_enable_vblank, & vmw_disable_vblank, 0, 0, 0, & vmw_irq_handler, & vmw_irq_preinstall,
    & vmw_irq_postinstall, & vmw_irq_uninstall, 0, & vmw_master_create, & vmw_master_destroy,
    & vmw_master_set, & vmw_master_drop, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vmw_dumb_create,
    & vmw_dumb_map_offset, & vmw_dumb_destroy, 0, 2, 4, 0, (char *)"vmwgfx", (char *)"Linux drm driver for VMware graphics devices",
    (char *)"20120209", 8384U, 0, (struct drm_ioctl_desc *)(& vmw_ioctls), 21, & vmwgfx_driver_fops,
    {0}, 0, {0, 0}};
#line 1323 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static struct pci_driver vmw_pci_driver  = 
#line 1323
     {{0, 0}, "vmwgfx", (struct pci_device_id  const  *)(& vmw_pci_id_list), & vmw_probe,
    & vmw_remove, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0,
                                        0, & vmw_pm_ops, 0}, {{{{{{0U}}, 0U, 0U, 0,
                                                                 {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0}}};
#line 1333 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmw_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ int tmp ;

  {
#line 1335
  tmp = drm_get_pci_dev(pdev, ent, & driver);
#line 1335
  return (tmp);
}
}
#line 1338 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static int vmwgfx_init(void) 
{ int ret ;

  {
#line 1341
  ret = drm_pci_init(& driver, & vmw_pci_driver);
#line 1342
  if (ret != 0) {
#line 1343
    drm_err("vmwgfx_init", "Failed initializing DRM.\n");
  } else {

  }
#line 1344
  return (ret);
}
}
#line 1347 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
static void vmwgfx_exit(void) 
{ 

  {
#line 1349
  drm_pci_exit(& driver, & vmw_pci_driver);
#line 1350
  return;
}
}
#line 1362 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
bool ldvarg51  ;
#line 1363 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct file *ldvarg32  ;
#line 1364 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldvarg43  ;
#line 1365 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct device *vmw_pm_ops_group1  ;
#line 1366 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_2  ;
#line 1367 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
bool ldvarg50  ;
#line 1368 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void *ldvarg46  ;
#line 1369 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct drm_device *driver_group2  ;
#line 1370 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_5  ;
#line 1371 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
loff_t *ldvarg37  ;
#line 1372 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_11  ;
#line 1373 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
uint32_t ldvarg53  ;
#line 1374 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_1  ;
#line 1375 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct vm_area_struct *ldvarg29  ;
#line 1376 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldvarg44  ;
#line 1377 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
unsigned long ldvarg24  ;
#line 1378 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
unsigned long ldvarg35  ;
#line 1379 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
size_t ldvarg38  ;
#line 1380 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct file *ldvarg33  ;
#line 1381 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
uint32_t ldvarg48  ;
#line 1382
extern int ldv_vmw_pm_ops_resume_noirq_18(void) ;
#line 1383 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct pci_device_id *ldvarg89  ;
#line 1384
void ldv_check_final_state(void) ;
#line 1385 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_8  ;
#line 1386 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct poll_table_struct *ldvarg34  ;
#line 1387 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct file *ldvarg28  ;
#line 1388 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct drm_mode_create_dumb *ldvarg47  ;
#line 1389 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct drm_file *driver_group0  ;
#line 1390 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_7  ;
#line 1391 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
char *ldvarg39  ;
#line 1392
extern int ldv_driver_release_16(void) ;
#line 1393 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldvarg31  ;
#line 1394 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
unsigned long ldvarg49  ;
#line 1395 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct file *vmwgfx_driver_fops_group2  ;
#line 1396
extern int ldv_vmw_pm_ops_resume_early_18(void) ;
#line 1397 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct pci_dev *vmw_pci_driver_group0  ;
#line 1398
void ldv_initialize(void) ;
#line 1399 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct inode *vmwgfx_driver_fops_group1  ;
#line 1400 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_6  ;
#line 1401 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
unsigned int ldvarg36  ;
#line 1402
extern int ldv_vmw_pm_ops_suspend_late_18(void) ;
#line 1403 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldvarg45  ;
#line 1404 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
loff_t ldvarg27  ;
#line 1405 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldvarg26  ;
#line 1406 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
struct drm_master *driver_group1  ;
#line 1407 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_10  ;
#line 1408 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_9  ;
#line 1409 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldvarg30  ;
#line 1410 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldvarg54  ;
#line 1411 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
unsigned int ldvarg25  ;
#line 1412 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_4  ;
#line 1413
extern int ldv_vmw_pm_ops_suspend_noirq_18(void) ;
#line 1414 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
uint64_t *ldvarg52  ;
#line 1415 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_retval_3  ;
#line 1418
void ldv_main_exported_7(void) ;
#line 1419
void ldv_main_exported_8(void) ;
#line 1420
void ldv_main_exported_10(void) ;
#line 1421
void ldv_main_exported_9(void) ;
#line 1422
void ldv_main_exported_6(void) ;
#line 1423
void ldv_main_exported_4(void) ;
#line 1424
void ldv_main_exported_5(void) ;
#line 1430
void ldv_main_exported_13(void) ;
#line 1431
void ldv_main_exported_14(void) ;
#line 1432
void ldv_main_exported_11(void) ;
#line 1433
void ldv_main_exported_12(void) ;
#line 1434
void ldv_main_exported_1(void) ;
#line 1435
void ldv_main_exported_2(void) ;
#line 1439
void ldv_main_exported_3(void) ;
#line 1443 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void main(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1444
  ldv_initialize();
#line 1446
  ldv_state_variable_11 = 0;
#line 1447
  ldv_state_variable_21 = 0;
#line 1448
  ldv_state_variable_7 = 0;
#line 1449
  ldv_state_variable_17 = 0;
#line 1450
  ldv_state_variable_2 = 0;
#line 1451
  ldv_state_variable_1 = 0;
#line 1452
  ldv_state_variable_18 = 0;
#line 1453
  ref_cnt = 0;
#line 1454
  ldv_state_variable_0 = 1;
#line 1455
  ldv_state_variable_16 = 0;
#line 1456
  ldv_state_variable_13 = 0;
#line 1457
  ldv_state_variable_6 = 0;
#line 1458
  ldv_state_variable_3 = 0;
#line 1459
  ldv_state_variable_9 = 0;
#line 1460
  ldv_state_variable_12 = 0;
#line 1461
  ldv_state_variable_20 = 0;
#line 1462
  ldv_state_variable_14 = 0;
#line 1463
  ldv_state_variable_15 = 0;
#line 1464
  ldv_state_variable_8 = 0;
#line 1465
  ldv_state_variable_4 = 0;
#line 1466
  ldv_state_variable_19 = 0;
#line 1467
  ldv_state_variable_10 = 0;
#line 1468
  ldv_state_variable_5 = 0;
  ldv_41911: 
#line 1470
  tmp = __VERIFIER_nondet_int();
#line 1470
  switch (tmp) {
  case 0: ;
#line 1474
  if (ldv_state_variable_11 != 0) {
#line 1475
    ldv_main_exported_11();
  } else {

  }
#line 1478
  goto ldv_41834;
  case 1: ;
#line 1482
  if (ldv_state_variable_21 != 0) {
#line 1483
    ldv_main_exported_21();
  } else {

  }
#line 1486
  goto ldv_41834;
  case 2: ;
#line 1490
  if (ldv_state_variable_7 != 0) {
#line 1491
    ldv_main_exported_7();
  } else {

  }
#line 1494
  goto ldv_41834;
  case 3: ;
#line 1498
  if (ldv_state_variable_17 != 0) {
#line 1499
    tmp___0 = __VERIFIER_nondet_int();
#line 1499
    switch (tmp___0) {
    case 0: ;
#line 1502
    if (ldv_state_variable_17 == 2) {
#line 1504
      vmw_fops_read(vmwgfx_driver_fops_group2, ldvarg39, ldvarg38, ldvarg37);
#line 1506
      ldv_state_variable_17 = 2;
    } else {

    }
#line 1509
    goto ldv_41839;
    case 1: ;
#line 1512
    if (ldv_state_variable_17 == 2) {
#line 1514
      drm_compat_ioctl(vmwgfx_driver_fops_group2, ldvarg36, ldvarg35);
#line 1516
      ldv_state_variable_17 = 2;
    } else {

    }
#line 1519
    goto ldv_41839;
    case 2: ;
#line 1522
    if (ldv_state_variable_17 == 1) {
#line 1524
      vmw_fops_poll(ldvarg33, ldvarg34);
#line 1526
      ldv_state_variable_17 = 1;
    } else {

    }
#line 1529
    if (ldv_state_variable_17 == 2) {
#line 1531
      vmw_fops_poll(ldvarg33, ldvarg34);
#line 1533
      ldv_state_variable_17 = 2;
    } else {

    }
#line 1536
    goto ldv_41839;
    case 3: ;
#line 1539
    if (ldv_state_variable_17 == 1) {
#line 1541
      drm_fasync(ldvarg30, ldvarg32, ldvarg31);
#line 1543
      ldv_state_variable_17 = 1;
    } else {

    }
#line 1546
    if (ldv_state_variable_17 == 2) {
#line 1548
      drm_fasync(ldvarg30, ldvarg32, ldvarg31);
#line 1550
      ldv_state_variable_17 = 2;
    } else {

    }
#line 1553
    goto ldv_41839;
    case 4: ;
#line 1556
    if (ldv_state_variable_17 == 1) {
#line 1558
      ldv_retval_1 = drm_open(vmwgfx_driver_fops_group1, vmwgfx_driver_fops_group2);
#line 1559
      if (ldv_retval_1 == 0) {
#line 1560
        ldv_state_variable_17 = 2;
#line 1561
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1565
    goto ldv_41839;
    case 5: ;
#line 1568
    if (ldv_state_variable_17 == 1) {
#line 1570
      vmw_mmap(ldvarg28, ldvarg29);
#line 1572
      ldv_state_variable_17 = 1;
    } else {

    }
#line 1575
    if (ldv_state_variable_17 == 2) {
#line 1577
      vmw_mmap(ldvarg28, ldvarg29);
#line 1579
      ldv_state_variable_17 = 2;
    } else {

    }
#line 1582
    goto ldv_41839;
    case 6: ;
#line 1585
    if (ldv_state_variable_17 == 2) {
#line 1587
      drm_release(vmwgfx_driver_fops_group1, vmwgfx_driver_fops_group2);
#line 1588
      ldv_state_variable_17 = 1;
#line 1589
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1592
    goto ldv_41839;
    case 7: ;
#line 1595
    if (ldv_state_variable_17 == 2) {
#line 1597
      noop_llseek(vmwgfx_driver_fops_group2, ldvarg27, ldvarg26);
#line 1599
      ldv_state_variable_17 = 2;
    } else {

    }
#line 1602
    goto ldv_41839;
    case 8: ;
#line 1605
    if (ldv_state_variable_17 == 2) {
#line 1607
      vmw_unlocked_ioctl(vmwgfx_driver_fops_group2, ldvarg25, ldvarg24);
#line 1609
      ldv_state_variable_17 = 2;
    } else {

    }
#line 1612
    goto ldv_41839;
    default: ;
#line 1613
    goto ldv_41839;
    }
    ldv_41839: ;
  } else {

  }
#line 1617
  goto ldv_41834;
  case 4: ;
#line 1621
  if (ldv_state_variable_2 != 0) {
#line 1622
    ldv_main_exported_2();
  } else {

  }
#line 1625
  goto ldv_41834;
  case 5: ;
#line 1629
  if (ldv_state_variable_1 != 0) {
#line 1630
    ldv_main_exported_1();
  } else {

  }
#line 1633
  goto ldv_41834;
  case 6: ;
#line 1637
  if (ldv_state_variable_18 != 0) {
#line 1638
    tmp___1 = __VERIFIER_nondet_int();
#line 1638
    switch (tmp___1) {
    case 0: ;
#line 1641
    if (ldv_state_variable_18 == 7) {
#line 1643
      vmw_pm_complete(vmw_pm_ops_group1);
#line 1644
      ldv_state_variable_18 = 1;
#line 1645
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1648
    goto ldv_41853;
    case 1: ;
#line 1651
    if (ldv_state_variable_18 == 1) {
#line 1653
      ldv_retval_8 = vmw_pm_prepare(vmw_pm_ops_group1);
#line 1654
      if (ldv_retval_8 == 0) {
#line 1655
        ldv_state_variable_18 = 2;
#line 1656
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1660
    goto ldv_41853;
    case 2: ;
#line 1663
    if (ldv_state_variable_18 == 2) {
#line 1665
      ldv_retval_7 = vmw_pm_suspend(vmw_pm_ops_group1);
#line 1666
      if (ldv_retval_7 == 0) {
#line 1667
        ldv_state_variable_18 = 3;
      } else {

      }
    } else {

    }
#line 1671
    goto ldv_41853;
    case 3: ;
#line 1674
    if (ldv_state_variable_18 == 6) {
#line 1676
      ldv_retval_6 = vmw_pm_resume(vmw_pm_ops_group1);
#line 1677
      if (ldv_retval_6 == 0) {
#line 1678
        ldv_state_variable_18 = 7;
      } else {

      }
    } else {

    }
#line 1682
    goto ldv_41853;
    case 4: ;
#line 1685
    if (ldv_state_variable_18 == 3) {
#line 1687
      ldv_retval_5 = ldv_vmw_pm_ops_suspend_late_18();
#line 1688
      if (ldv_retval_5 == 0) {
#line 1689
        ldv_state_variable_18 = 4;
      } else {

      }
    } else {

    }
#line 1693
    goto ldv_41853;
    case 5: ;
#line 1696
    if (ldv_state_variable_18 == 4) {
#line 1698
      ldv_retval_4 = ldv_vmw_pm_ops_resume_early_18();
#line 1699
      if (ldv_retval_4 == 0) {
#line 1700
        ldv_state_variable_18 = 6;
      } else {

      }
    } else {

    }
#line 1704
    goto ldv_41853;
    case 6: ;
#line 1707
    if (ldv_state_variable_18 == 5) {
#line 1709
      ldv_retval_3 = ldv_vmw_pm_ops_resume_noirq_18();
#line 1710
      if (ldv_retval_3 == 0) {
#line 1711
        ldv_state_variable_18 = 6;
      } else {

      }
    } else {

    }
#line 1715
    goto ldv_41853;
    case 7: ;
#line 1718
    if (ldv_state_variable_18 == 3) {
#line 1720
      ldv_retval_2 = ldv_vmw_pm_ops_suspend_noirq_18();
#line 1721
      if (ldv_retval_2 == 0) {
#line 1722
        ldv_state_variable_18 = 5;
      } else {

      }
    } else {

    }
#line 1726
    goto ldv_41853;
    default: ;
#line 1727
    goto ldv_41853;
    }
    ldv_41853: ;
  } else {

  }
#line 1731
  goto ldv_41834;
  case 7: ;
#line 1735
  if (ldv_state_variable_0 != 0) {
#line 1736
    tmp___2 = __VERIFIER_nondet_int();
#line 1736
    switch (tmp___2) {
    case 0: ;
#line 1739
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 1741
      vmwgfx_exit();
#line 1742
      ldv_state_variable_0 = 3;
#line 1743
      goto ldv_final;
    } else {

    }
#line 1746
    goto ldv_41865;
    case 1: ;
#line 1749
    if (ldv_state_variable_0 == 1) {
#line 1751
      ldv_retval_9 = vmwgfx_init();
#line 1752
      if (ldv_retval_9 != 0) {
#line 1753
        ldv_state_variable_0 = 3;
#line 1754
        goto ldv_final;
      } else {

      }
#line 1757
      if (ldv_retval_9 == 0) {
#line 1758
        ldv_state_variable_0 = 2;
#line 1759
        ldv_state_variable_5 = 1;
#line 1760
        ldv_state_variable_10 = 1;
#line 1761
        ldv_state_variable_19 = 1;
#line 1762
        ldv_state_variable_4 = 1;
#line 1763
        ldv_state_variable_8 = 1;
#line 1764
        ldv_state_variable_15 = 1;
#line 1765
        ldv_state_variable_14 = 1;
#line 1766
        ldv_state_variable_20 = 1;
#line 1767
        ldv_state_variable_12 = 1;
#line 1768
        ldv_state_variable_9 = 1;
#line 1769
        ldv_state_variable_3 = 1;
#line 1770
        ldv_state_variable_6 = 1;
#line 1771
        ldv_state_variable_13 = 1;
#line 1772
        ldv_state_variable_16 = 1;
#line 1773
        ldv_state_variable_18 = 1;
#line 1774
        ldv_state_variable_1 = 1;
#line 1775
        ldv_state_variable_2 = 1;
#line 1776
        ldv_state_variable_17 = 1;
#line 1777
        ldv_state_variable_7 = 1;
#line 1778
        ldv_state_variable_21 = 1;
#line 1779
        ldv_state_variable_11 = 1;
      } else {

      }
    } else {

    }
#line 1783
    goto ldv_41865;
    default: ;
#line 1784
    goto ldv_41865;
    }
    ldv_41865: ;
  } else {

  }
#line 1788
  goto ldv_41834;
  case 8: ;
#line 1792
  if (ldv_state_variable_16 != 0) {
#line 1793
    tmp___3 = __VERIFIER_nondet_int();
#line 1793
    switch (tmp___3) {
    case 0: ;
#line 1796
    if (ldv_state_variable_16 == 1) {
#line 1798
      vmw_lastclose(driver_group2);
#line 1800
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1803
    if (ldv_state_variable_16 == 2) {
#line 1805
      vmw_lastclose(driver_group2);
#line 1807
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1810
    goto ldv_41870;
    case 1: ;
#line 1813
    if (ldv_state_variable_16 == 1) {
#line 1815
      vmw_get_vblank_counter(driver_group2, ldvarg54);
#line 1817
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1820
    if (ldv_state_variable_16 == 2) {
#line 1822
      vmw_get_vblank_counter(driver_group2, ldvarg54);
#line 1824
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1827
    goto ldv_41870;
    case 2: ;
#line 1830
    if (ldv_state_variable_16 == 1) {
#line 1832
      vmw_dumb_map_offset(driver_group0, driver_group2, ldvarg53, ldvarg52);
#line 1834
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1837
    if (ldv_state_variable_16 == 2) {
#line 1839
      vmw_dumb_map_offset(driver_group0, driver_group2, ldvarg53, ldvarg52);
#line 1841
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1844
    goto ldv_41870;
    case 3: ;
#line 1847
    if (ldv_state_variable_16 == 1) {
#line 1849
      vmw_master_set(driver_group2, driver_group0, (int )ldvarg51);
#line 1851
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1854
    if (ldv_state_variable_16 == 2) {
#line 1856
      vmw_master_set(driver_group2, driver_group0, (int )ldvarg51);
#line 1858
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1861
    goto ldv_41870;
    case 4: ;
#line 1864
    if (ldv_state_variable_16 == 1) {
#line 1866
      vmw_firstopen(driver_group2);
#line 1868
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1871
    if (ldv_state_variable_16 == 2) {
#line 1873
      vmw_firstopen(driver_group2);
#line 1875
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1878
    goto ldv_41870;
    case 5: ;
#line 1881
    if (ldv_state_variable_16 == 1) {
#line 1883
      ldv_retval_10 = vmw_driver_open(driver_group2, driver_group0);
#line 1885
      if (ldv_retval_10 == 0) {
#line 1886
        ldv_state_variable_16 = 2;
#line 1887
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1891
    goto ldv_41870;
    case 6: ;
#line 1894
    if (ldv_state_variable_16 == 1) {
#line 1896
      vmw_master_drop(driver_group2, driver_group0, (int )ldvarg50);
#line 1898
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1901
    if (ldv_state_variable_16 == 2) {
#line 1903
      vmw_master_drop(driver_group2, driver_group0, (int )ldvarg50);
#line 1905
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1908
    goto ldv_41870;
    case 7: ;
#line 1911
    if (ldv_state_variable_16 == 1) {
#line 1913
      vmw_master_destroy(driver_group2, driver_group1);
#line 1915
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1918
    if (ldv_state_variable_16 == 2) {
#line 1920
      vmw_master_destroy(driver_group2, driver_group1);
#line 1922
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1925
    goto ldv_41870;
    case 8: ;
#line 1928
    if (ldv_state_variable_16 == 1) {
#line 1930
      vmw_driver_unload(driver_group2);
#line 1932
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1935
    if (ldv_state_variable_16 == 2) {
#line 1937
      vmw_driver_unload(driver_group2);
#line 1939
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1942
    goto ldv_41870;
    case 9: ;
#line 1945
    if (ldv_state_variable_16 == 1) {
#line 1947
      vmw_irq_preinstall(driver_group2);
#line 1949
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1952
    if (ldv_state_variable_16 == 2) {
#line 1954
      vmw_irq_preinstall(driver_group2);
#line 1956
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1959
    goto ldv_41870;
    case 10: ;
#line 1962
    if (ldv_state_variable_16 == 1) {
#line 1964
      vmw_driver_load(driver_group2, ldvarg49);
#line 1966
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1969
    if (ldv_state_variable_16 == 2) {
#line 1971
      vmw_driver_load(driver_group2, ldvarg49);
#line 1973
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1976
    goto ldv_41870;
    case 11: ;
#line 1979
    if (ldv_state_variable_16 == 1) {
#line 1981
      vmw_irq_uninstall(driver_group2);
#line 1983
      ldv_state_variable_16 = 1;
    } else {

    }
#line 1986
    if (ldv_state_variable_16 == 2) {
#line 1988
      vmw_irq_uninstall(driver_group2);
#line 1990
      ldv_state_variable_16 = 2;
    } else {

    }
#line 1993
    goto ldv_41870;
    case 12: ;
#line 1996
    if (ldv_state_variable_16 == 1) {
#line 1998
      vmw_dumb_destroy(driver_group0, driver_group2, ldvarg48);
#line 2000
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2003
    if (ldv_state_variable_16 == 2) {
#line 2005
      vmw_dumb_destroy(driver_group0, driver_group2, ldvarg48);
#line 2007
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2010
    goto ldv_41870;
    case 13: ;
#line 2013
    if (ldv_state_variable_16 == 1) {
#line 2015
      vmw_master_create(driver_group2, driver_group1);
#line 2017
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2020
    if (ldv_state_variable_16 == 2) {
#line 2022
      vmw_master_create(driver_group2, driver_group1);
#line 2024
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2027
    goto ldv_41870;
    case 14: ;
#line 2030
    if (ldv_state_variable_16 == 1) {
#line 2032
      vmw_postclose(driver_group2, driver_group0);
#line 2034
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2037
    if (ldv_state_variable_16 == 2) {
#line 2039
      vmw_postclose(driver_group2, driver_group0);
#line 2041
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2044
    goto ldv_41870;
    case 15: ;
#line 2047
    if (ldv_state_variable_16 == 1) {
#line 2049
      vmw_irq_postinstall(driver_group2);
#line 2051
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2054
    if (ldv_state_variable_16 == 2) {
#line 2056
      vmw_irq_postinstall(driver_group2);
#line 2058
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2061
    goto ldv_41870;
    case 16: ;
#line 2064
    if (ldv_state_variable_16 == 1) {
#line 2066
      vmw_dumb_create(driver_group0, driver_group2, ldvarg47);
#line 2068
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2071
    if (ldv_state_variable_16 == 2) {
#line 2073
      vmw_dumb_create(driver_group0, driver_group2, ldvarg47);
#line 2075
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2078
    goto ldv_41870;
    case 17: ;
#line 2081
    if (ldv_state_variable_16 == 1) {
#line 2083
      vmw_irq_handler(ldvarg45, ldvarg46);
#line 2085
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2088
    if (ldv_state_variable_16 == 2) {
#line 2090
      vmw_irq_handler(ldvarg45, ldvarg46);
#line 2092
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2095
    goto ldv_41870;
    case 18: ;
#line 2098
    if (ldv_state_variable_16 == 1) {
#line 2100
      vmw_enable_vblank(driver_group2, ldvarg44);
#line 2102
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2105
    if (ldv_state_variable_16 == 2) {
#line 2107
      vmw_enable_vblank(driver_group2, ldvarg44);
#line 2109
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2112
    goto ldv_41870;
    case 19: ;
#line 2115
    if (ldv_state_variable_16 == 1) {
#line 2117
      vmw_preclose(driver_group2, driver_group0);
#line 2119
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2122
    if (ldv_state_variable_16 == 2) {
#line 2124
      vmw_preclose(driver_group2, driver_group0);
#line 2126
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2129
    goto ldv_41870;
    case 20: ;
#line 2132
    if (ldv_state_variable_16 == 1) {
#line 2134
      vmw_disable_vblank(driver_group2, ldvarg43);
#line 2136
      ldv_state_variable_16 = 1;
    } else {

    }
#line 2139
    if (ldv_state_variable_16 == 2) {
#line 2141
      vmw_disable_vblank(driver_group2, ldvarg43);
#line 2143
      ldv_state_variable_16 = 2;
    } else {

    }
#line 2146
    goto ldv_41870;
    case 21: ;
#line 2149
    if (ldv_state_variable_16 == 2) {
#line 2151
      ldv_driver_release_16();
#line 2153
      ldv_state_variable_16 = 1;
#line 2154
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2157
    goto ldv_41870;
    default: ;
#line 2158
    goto ldv_41870;
    }
    ldv_41870: ;
  } else {

  }
#line 2162
  goto ldv_41834;
  case 9: ;
#line 2166
  if (ldv_state_variable_13 != 0) {
#line 2167
    ldv_main_exported_13();
  } else {

  }
#line 2170
  goto ldv_41834;
  case 10: ;
#line 2174
  if (ldv_state_variable_6 != 0) {
#line 2175
    ldv_main_exported_6();
  } else {

  }
#line 2178
  goto ldv_41834;
  case 11: ;
#line 2182
  if (ldv_state_variable_3 != 0) {
#line 2183
    ldv_main_exported_3();
  } else {

  }
#line 2186
  goto ldv_41834;
  case 12: ;
#line 2190
  if (ldv_state_variable_9 != 0) {
#line 2191
    ldv_main_exported_9();
  } else {

  }
#line 2194
  goto ldv_41834;
  case 13: ;
#line 2198
  if (ldv_state_variable_12 != 0) {
#line 2199
    ldv_main_exported_12();
  } else {

  }
#line 2202
  goto ldv_41834;
  case 14: ;
#line 2206
  if (ldv_state_variable_20 != 0) {
#line 2207
    ldv_main_exported_20();
  } else {

  }
#line 2210
  goto ldv_41834;
  case 15: ;
#line 2214
  if (ldv_state_variable_14 != 0) {
#line 2215
    ldv_main_exported_14();
  } else {

  }
#line 2218
  goto ldv_41834;
  case 16: ;
#line 2222
  if (ldv_state_variable_15 != 0) {
#line 2223
    tmp___4 = __VERIFIER_nondet_int();
#line 2223
    switch (tmp___4) {
    case 0: ;
#line 2226
    if (ldv_state_variable_15 == 1) {
#line 2228
      ldv_retval_11 = vmw_probe(vmw_pci_driver_group0, (struct pci_device_id  const  *)ldvarg89);
#line 2230
      if (ldv_retval_11 == 0) {
#line 2231
        ldv_state_variable_15 = 2;
#line 2232
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 2236
    goto ldv_41902;
    case 1: ;
#line 2239
    if (ldv_state_variable_15 == 2) {
#line 2241
      vmw_remove(vmw_pci_driver_group0);
#line 2243
      ldv_state_variable_15 = 1;
#line 2244
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 2247
    goto ldv_41902;
    default: ;
#line 2248
    goto ldv_41902;
    }
    ldv_41902: ;
  } else {

  }
#line 2252
  goto ldv_41834;
  case 17: ;
#line 2256
  if (ldv_state_variable_8 != 0) {
#line 2257
    ldv_main_exported_8();
  } else {

  }
#line 2260
  goto ldv_41834;
  case 18: ;
#line 2264
  if (ldv_state_variable_4 != 0) {
#line 2265
    ldv_main_exported_4();
  } else {

  }
#line 2268
  goto ldv_41834;
  case 19: ;
#line 2272
  if (ldv_state_variable_19 != 0) {
#line 2273
    ldv_main_exported_19();
  } else {

  }
#line 2276
  goto ldv_41834;
  case 20: ;
#line 2280
  if (ldv_state_variable_10 != 0) {
#line 2281
    ldv_main_exported_10();
  } else {

  }
#line 2284
  goto ldv_41834;
  case 21: ;
#line 2288
  if (ldv_state_variable_5 != 0) {
#line 2289
    ldv_main_exported_5();
  } else {

  }
#line 2292
  goto ldv_41834;
  default: ;
#line 2293
  goto ldv_41834;
  }
  ldv_41834: ;
#line 2295
  goto ldv_41911;
  ldv_final: 
#line 2297
  ldv_check_final_state();
#line 2298
  return;
}
}
#line 2301 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2306
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2308
  mutex_lock(ldv_func_arg1);
#line 2309
  return;
}
}
#line 2311 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2316
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2318
  mutex_unlock(ldv_func_arg1);
#line 2319
  return;
}
}
#line 2321 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2326
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 2328
  mutex_lock(ldv_func_arg1);
#line 2329
  return;
}
}
#line 2331 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
int ldv_mutex_trylock_132(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2336
  tmp = mutex_trylock(ldv_func_arg1);
#line 2336
  ldv_func_res = tmp;
#line 2338
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 2338
  return (tmp___0);
#line 2340
  return (ldv_func_res);
}
}
#line 2343 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_133(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2348
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 2350
  mutex_unlock(ldv_func_arg1);
#line 2351
  return;
}
}
#line 2353 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_134(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2358
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 2360
  mutex_lock(ldv_func_arg1);
#line 2361
  return;
}
}
#line 2363 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_135(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2368
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 2370
  mutex_unlock(ldv_func_arg1);
#line 2371
  return;
}
}
#line 2373 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_136(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2378
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 2380
  mutex_lock(ldv_func_arg1);
#line 2381
  return;
}
}
#line 2383 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_137(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2388
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 2390
  mutex_unlock(ldv_func_arg1);
#line 2391
  return;
}
}
#line 2393 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2398
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 2400
  mutex_unlock(ldv_func_arg1);
#line 2401
  return;
}
}
#line 2403 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2408
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 2410
  mutex_lock(ldv_func_arg1);
#line 2411
  return;
}
}
#line 2413 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2418
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 2420
  mutex_unlock(ldv_func_arg1);
#line 2421
  return;
}
}
#line 2423 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_141(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2428
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 2430
  mutex_lock(ldv_func_arg1);
#line 2431
  return;
}
}
#line 2433 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2438
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 2440
  mutex_unlock(ldv_func_arg1);
#line 2441
  return;
}
}
#line 2443 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_143(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2448
  ldv_mutex_lock_release_mutex_of_vmw_private(ldv_func_arg1);
#line 2450
  mutex_lock(ldv_func_arg1);
#line 2451
  return;
}
}
#line 2453 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_144(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2458
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2460
  mutex_lock(ldv_func_arg1);
#line 2461
  return;
}
}
#line 2463 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2468
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2470
  mutex_unlock(ldv_func_arg1);
#line 2471
  return;
}
}
#line 2473 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2478
  ldv_mutex_unlock_release_mutex_of_vmw_private(ldv_func_arg1);
#line 2480
  mutex_unlock(ldv_func_arg1);
#line 2481
  return;
}
}
#line 2483 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2488
  ldv_mutex_lock_release_mutex_of_vmw_private(ldv_func_arg1);
#line 2490
  mutex_lock(ldv_func_arg1);
#line 2491
  return;
}
}
#line 2493 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_148(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2498
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2500
  mutex_lock(ldv_func_arg1);
#line 2501
  return;
}
}
#line 2503 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_149(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2508
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2510
  mutex_unlock(ldv_func_arg1);
#line 2511
  return;
}
}
#line 2513 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2518
  ldv_mutex_unlock_release_mutex_of_vmw_private(ldv_func_arg1);
#line 2520
  mutex_unlock(ldv_func_arg1);
#line 2521
  return;
}
}
#line 2523 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_151(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2528
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2530
  mutex_lock(ldv_func_arg1);
#line 2531
  return;
}
}
#line 2533 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_152(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2538
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2540
  mutex_unlock(ldv_func_arg1);
#line 2541
  return;
}
}
#line 2543 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2548
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2550
  mutex_unlock(ldv_func_arg1);
#line 2551
  return;
}
}
#line 2553 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2558
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2560
  mutex_lock(ldv_func_arg1);
#line 2561
  return;
}
}
#line 2563 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2568
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2570
  mutex_unlock(ldv_func_arg1);
#line 2571
  return;
}
}
#line 2573 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_156(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2578
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2580
  mutex_lock(ldv_func_arg1);
#line 2581
  return;
}
}
#line 2583 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2588
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2590
  mutex_unlock(ldv_func_arg1);
#line 2591
  return;
}
}
#line 2593 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_158(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2598
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2600
  mutex_lock(ldv_func_arg1);
#line 2601
  return;
}
}
#line 2603 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_159(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2608
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2610
  mutex_unlock(ldv_func_arg1);
#line 2611
  return;
}
}
#line 2613 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_lock_160(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2618
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2620
  mutex_lock(ldv_func_arg1);
#line 2621
  return;
}
}
#line 2623 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c.prepared"
void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 2628
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 2630
  mutex_unlock(ldv_func_arg1);
#line 2631
  return;
}
}
#line 62 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_198(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_196(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_208(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_195(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_197(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_205(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_207(struct mutex *ldv_func_arg1 ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 32 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 

  {
#line 274
  return (& lock->ldv_5961.rlock);
}
}
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 

  {
#line 340
  _raw_spin_unlock_irqrestore(& lock->ldv_5961.rlock, flags);
#line 341
  return;
}
}
#line 412 "include/linux/workqueue.h"
extern bool schedule_delayed_work(struct delayed_work * , unsigned long  ) ;
#line 422
extern bool flush_delayed_work(struct delayed_work * ) ;
#line 504 "include/linux/fb.h"
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num ) 
{ struct apertures_struct *a ;
  void *tmp ;

  {
#line 505
  tmp = kzalloc((unsigned long )max_num * 16UL + 8UL, 208U);
#line 505
  a = (struct apertures_struct *)tmp;
#line 507
  if ((unsigned long )a == (unsigned long )((struct apertures_struct *)0)) {
#line 508
    return (0);
  } else {

  }
#line 509
  a->count = max_num;
#line 510
  return (a);
}
}
#line 594
extern void cfb_fillrect(struct fb_info * , struct fb_fillrect  const  * ) ;
#line 595
extern void cfb_copyarea(struct fb_info * , struct fb_copyarea  const  * ) ;
#line 596
extern void cfb_imageblit(struct fb_info * , struct fb_image  const  * ) ;
#line 609
extern int register_framebuffer(struct fb_info * ) ;
#line 610
extern int unregister_framebuffer(struct fb_info * ) ;
#line 653
extern void fb_deferred_io_init(struct fb_info * ) ;
#line 657
extern void fb_deferred_io_cleanup(struct fb_info * ) ;
#line 681
extern struct fb_info *framebuffer_alloc(size_t  , struct device * ) ;
#line 682
extern void framebuffer_release(struct fb_info * ) ;
#line 134 "include/drm/ttm/ttm_lock.h"
extern void ttm_write_unlock(struct ttm_lock * ) ;
#line 146
extern int ttm_write_lock(struct ttm_lock * , bool  ) ;
#line 458 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) ;
#line 459
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object * ) ) ;
#line 563
struct ttm_placement vmw_vram_ne_placement ;
#line 650
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) ;
#line 712
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) ;
#line 221 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_setcolreg(unsigned int regno , unsigned int red , unsigned int green ,
                            unsigned int blue , unsigned int transp , struct fb_info *info ) 
{ struct vmw_fb_par *par ;
  u32 *pal ;

  {
#line 225
  par = (struct vmw_fb_par *)info->par;
#line 226
  pal = (u32 *)(& par->pseudo_palette);
#line 228
  if (regno > 15U) {
#line 229
    drm_err("vmw_fb_setcolreg", "Bad regno %u.\n", regno);
#line 230
    return (1);
  } else {

  }
#line 233
  switch (par->depth) {
  case 24: ;
  case 32: 
#line 236
  *(pal + (unsigned long )regno) = (((red & 65280U) << 8) | (green & 65280U)) | ((blue & 65280U) >> 8);
#line 239
  goto ldv_40605;
  default: 
#line 241
  drm_err("vmw_fb_setcolreg", "Bad depth %u, bpp %u.\n", par->depth, par->bpp);
#line 242
  return (1);
  }
  ldv_40605: ;
#line 245
  return (0);
}
}
#line 248 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_check_var(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ int depth ;
  struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 251
  depth = (int )var->bits_per_pixel;
#line 252
  par = (struct vmw_fb_par *)info->par;
#line 253
  vmw_priv___0 = par->vmw_priv;
#line 255
  switch (var->bits_per_pixel) {
  case 32: ;
#line 257
  if (var->transp.length != 0U) {
#line 257
    depth = 32;
  } else {
#line 257
    depth = 24;
  }
#line 258
  goto ldv_40615;
  default: 
#line 260
  drm_err("vmw_fb_check_var", "Bad bpp %u.\n", var->bits_per_pixel);
#line 261
  return (-22);
  }
  ldv_40615: ;
#line 264
  switch (depth) {
  case 24: 
#line 266
  var->red.offset = 16U;
#line 267
  var->green.offset = 8U;
#line 268
  var->blue.offset = 0U;
#line 269
  var->red.length = 8U;
#line 270
  var->green.length = 8U;
#line 271
  var->blue.length = 8U;
#line 272
  var->transp.length = 0U;
#line 273
  var->transp.offset = 0U;
#line 274
  goto ldv_40619;
  case 32: 
#line 276
  var->red.offset = 16U;
#line 277
  var->green.offset = 8U;
#line 278
  var->blue.offset = 0U;
#line 279
  var->red.length = 8U;
#line 280
  var->green.length = 8U;
#line 281
  var->blue.length = 8U;
#line 282
  var->transp.length = 8U;
#line 283
  var->transp.offset = 24U;
#line 284
  goto ldv_40619;
  default: 
#line 286
  drm_err("vmw_fb_check_var", "Bad depth %u.\n", depth);
#line 287
  return (-22);
  }
  ldv_40619: ;
#line 290
  if ((vmw_priv___0->capabilities & 524288U) == 0U && (var->xoffset != 0U || var->yoffset != 0U)) {
#line 292
    drm_err("vmw_fb_check_var", "Can not handle panning without display topology\n");
#line 293
    return (-22);
  } else {

  }
#line 296
  if (var->xoffset + var->xres > par->max_width || var->yoffset + var->yres > par->max_height) {
#line 298
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
#line 299
    return (-22);
  } else {

  }
#line 302
  tmp = vmw_kms_validate_mode_vram(vmw_priv___0, info->fix.line_length, var->yoffset + var->yres);
#line 302
  if (tmp) {
#line 302
    tmp___0 = 0;
  } else {
#line 302
    tmp___0 = 1;
  }
#line 302
  if (tmp___0) {
#line 305
    drm_err("vmw_fb_check_var", "Requested geom can not fit in framebuffer\n");
#line 306
    return (-22);
  } else {

  }
#line 309
  return (0);
}
}
#line 312 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_set_par(struct fb_info *info ) 
{ struct vmw_fb_par *par ;
  struct vmw_private *vmw_priv___0 ;
  int ret ;
  int __ret_warn_on ;
  uint32_t tmp ;
  long tmp___0 ;

  {
#line 314
  par = (struct vmw_fb_par *)info->par;
#line 315
  vmw_priv___0 = par->vmw_priv;
#line 318
  ret = vmw_kms_write_svga(vmw_priv___0, info->var.xres, info->var.yres, info->fix.line_length,
                           par->bpp, par->depth);
#line 321
  if (ret != 0) {
#line 322
    return (ret);
  } else {

  }
#line 324
  if ((vmw_priv___0->capabilities & 524288U) != 0U) {
#line 326
    vmw_write(vmw_priv___0, 34U, 1U);
#line 327
    vmw_write(vmw_priv___0, 35U, 0U);
#line 328
    vmw_write(vmw_priv___0, 36U, 1U);
#line 329
    vmw_write(vmw_priv___0, 37U, info->var.xoffset);
#line 330
    vmw_write(vmw_priv___0, 38U, info->var.yoffset);
#line 331
    vmw_write(vmw_priv___0, 39U, info->var.xres);
#line 332
    vmw_write(vmw_priv___0, 40U, info->var.yres);
#line 333
    vmw_write(vmw_priv___0, 35U, 4294967295U);
  } else {

  }
#line 339
  tmp = vmw_read(vmw_priv___0, 14U);
#line 339
  __ret_warn_on = tmp != 0U;
#line 339
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 339
  if (tmp___0 != 0L) {
#line 339
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared",
                       339);
  } else {

  }
#line 339
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 341
  return (0);
}
}
#line 344 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_pan_display(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ 

  {
#line 347
  return (0);
}
}
#line 350 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_blank(int blank , struct fb_info *info ) 
{ 

  {
#line 352
  return (0);
}
}
#line 359 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_dirty_flush(struct vmw_fb_par *par ) 
{ struct vmw_private *vmw_priv___0 ;
  struct fb_info *info ;
  int stride ;
  int *src ;
  __le32 *vram_mem ;
  unsigned long flags ;
  unsigned int x ;
  unsigned int y ;
  unsigned int w ;
  unsigned int h ;
  int i ;
  int k ;
  struct __anonstruct_cmd_292 *cmd ;
  raw_spinlock_t *tmp ;
  unsigned int _min1 ;
  __u32 _min2 ;
  unsigned int tmp___0 ;
  unsigned int _min1___0 ;
  __u32 _min2___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;

  {
#line 361
  vmw_priv___0 = par->vmw_priv;
#line 362
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 363
  stride = (int )(info->fix.line_length / 4U);
#line 364
  src = (int *)info->screen_base;
#line 365
  vram_mem = (__le32 *)par->bo_ptr;
#line 374
  if ((int )vmw_priv___0->suspended) {
#line 375
    return;
  } else {

  }
#line 377
  tmp = spinlock_check(& par->dirty.lock);
#line 377
  flags = _raw_spin_lock_irqsave(tmp);
#line 378
  if (! par->dirty.active) {
#line 379
    spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 380
    return;
  } else {

  }
#line 382
  x = par->dirty.x1;
#line 383
  y = par->dirty.y1;
#line 384
  _min1 = par->dirty.x2;
#line 384
  _min2 = info->var.xres;
#line 384
  if (_min1 < _min2) {
#line 384
    tmp___0 = _min1;
  } else {
#line 384
    tmp___0 = _min2;
  }
#line 384
  w = tmp___0 - x;
#line 385
  _min1___0 = par->dirty.y2;
#line 385
  _min2___0 = info->var.yres;
#line 385
  if (_min1___0 < _min2___0) {
#line 385
    tmp___1 = _min1___0;
  } else {
#line 385
    tmp___1 = _min2___0;
  }
#line 385
  h = tmp___1 - y;
#line 386
  tmp___2 = 0U;
#line 386
  par->dirty.x2 = tmp___2;
#line 386
  par->dirty.x1 = tmp___2;
#line 387
  tmp___3 = 0U;
#line 387
  par->dirty.y2 = tmp___3;
#line 387
  par->dirty.y1 = tmp___3;
#line 388
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 390
  i = (int )(y * (unsigned int )stride);
#line 390
  goto ldv_40670;
  ldv_40669: 
#line 391
  k = (int )((unsigned int )i + x);
#line 391
  goto ldv_40667;
  ldv_40666: 
#line 392
  iowrite32((u32 )*(src + (unsigned long )k), (void *)vram_mem + (unsigned long )k);
#line 391
  k = k + 1;
  ldv_40667: ;
#line 391
  if ((unsigned int )k < ((unsigned int )i + x) + w && (__u32 )k < info->fix.smem_len / 4U) {
#line 392
    goto ldv_40666;
  } else {
#line 394
    goto ldv_40668;
  }
  ldv_40668: 
#line 390
  i = i + stride;
  ldv_40670: ;
#line 390
  if ((__u32 )i < info->fix.smem_len / 4U) {
#line 391
    goto ldv_40669;
  } else {
#line 393
    goto ldv_40671;
  }
  ldv_40671: 
#line 399
  tmp___4 = vmw_fifo_reserve(vmw_priv___0, 20U);
#line 399
  cmd = (struct __anonstruct_294___0 *)tmp___4;
#line 400
  tmp___5 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_292 *)0),
                             0L);
#line 400
  if (tmp___5 != 0L) {
#line 401
    drm_err("vmw_fb_dirty_flush", "Fifo reserve failed.\n");
#line 402
    return;
  } else {

  }
#line 405
  cmd->header = 1U;
#line 406
  cmd->body.x = x;
#line 407
  cmd->body.y = y;
#line 408
  cmd->body.width = w;
#line 409
  cmd->body.height = h;
#line 410
  vmw_fifo_commit(vmw_priv___0, 20U);
#line 411
  return;
}
}
#line 413 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_dirty_mark(struct vmw_fb_par *par , unsigned int x1 , unsigned int y1 ,
                              unsigned int width , unsigned int height ) 
{ struct fb_info *info ;
  unsigned long flags ;
  unsigned int x2 ;
  unsigned int y2 ;
  raw_spinlock_t *tmp ;

  {
#line 417
  info = (struct fb_info *)(par->vmw_priv)->fb_info;
#line 419
  x2 = x1 + width;
#line 420
  y2 = y1 + height;
#line 422
  tmp = spinlock_check(& par->dirty.lock);
#line 422
  flags = _raw_spin_lock_irqsave(tmp);
#line 423
  if (par->dirty.x1 == par->dirty.x2) {
#line 424
    par->dirty.x1 = x1;
#line 425
    par->dirty.y1 = y1;
#line 426
    par->dirty.x2 = x2;
#line 427
    par->dirty.y2 = y2;
#line 430
    if ((int )par->dirty.active) {
#line 431
      schedule_delayed_work(& info->deferred_work, 8UL);
    } else {

    }
  } else {
#line 433
    if (par->dirty.x1 > x1) {
#line 434
      par->dirty.x1 = x1;
    } else {

    }
#line 435
    if (par->dirty.y1 > y1) {
#line 436
      par->dirty.y1 = y1;
    } else {

    }
#line 437
    if (par->dirty.x2 < x2) {
#line 438
      par->dirty.x2 = x2;
    } else {

    }
#line 439
    if (par->dirty.y2 < y2) {
#line 440
      par->dirty.y2 = y2;
    } else {

    }
  }
#line 442
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 443
  return;
}
}
#line 445 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_deferred_io(struct fb_info *info , struct list_head *pagelist ) 
{ struct vmw_fb_par *par ;
  unsigned long start ;
  unsigned long end ;
  unsigned long min ;
  unsigned long max ;
  unsigned long flags ;
  struct page *page ;
  int y1 ;
  int y2 ;
  struct list_head  const  *__mptr ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 448
  par = (struct vmw_fb_par *)info->par;
#line 454
  min = 0xffffffffffffffffUL;
#line 455
  max = 0UL;
#line 456
  __mptr = (struct list_head  const  *)pagelist->next;
#line 456
  page = (struct page *)__mptr + 0xffffffffffffffe0UL;
#line 456
  goto ldv_40711;
  ldv_40710: 
#line 457
  start = page->ldv_21242.ldv_21226.index << 12;
#line 458
  end = start + 4095UL;
#line 459
  _min1 = min;
#line 459
  _min2 = start;
#line 459
  if (_min1 < _min2) {
#line 459
    tmp = _min1;
  } else {
#line 459
    tmp = _min2;
  }
#line 459
  min = tmp;
#line 460
  _max1 = max;
#line 460
  _max2 = end;
#line 460
  if (_max1 > _max2) {
#line 460
    tmp___0 = _max1;
  } else {
#line 460
    tmp___0 = _max2;
  }
#line 460
  max = tmp___0;
#line 456
  __mptr___0 = (struct list_head  const  *)page->ldv_21253.lru.next;
#line 456
  page = (struct page *)__mptr___0 + 0xffffffffffffffe0UL;
  ldv_40711: ;
#line 456
  if ((unsigned long )(& page->ldv_21253.lru) != (unsigned long )pagelist) {
#line 457
    goto ldv_40710;
  } else {
#line 459
    goto ldv_40712;
  }
  ldv_40712: ;
#line 463
  if (min < max) {
#line 464
    y1 = (int )(min / (unsigned long )info->fix.line_length);
#line 465
    y2 = (int )((unsigned int )(max / (unsigned long )info->fix.line_length) + 1U);
#line 467
    tmp___1 = spinlock_check(& par->dirty.lock);
#line 467
    flags = _raw_spin_lock_irqsave(tmp___1);
#line 468
    par->dirty.x1 = 0U;
#line 469
    par->dirty.y1 = (unsigned int )y1;
#line 470
    par->dirty.x2 = info->var.xres;
#line 471
    par->dirty.y2 = (unsigned int )y2;
#line 472
    spin_unlock_irqrestore(& par->dirty.lock, flags);
  } else {

  }
#line 475
  vmw_fb_dirty_flush(par);
#line 476
  return;
}
}
#line 478 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_deferred_io vmw_defio  =    {8UL, {{0}, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
    {0, 0}, 0, & vmw_deferred_io};
#line 487 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_fillrect(struct fb_info *info , struct fb_fillrect  const  *rect ) 
{ 

  {
#line 489
  cfb_fillrect(info, rect);
#line 490
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, rect->dx, rect->dy, rect->width,
                    rect->height);
#line 492
  return;
}
}
#line 494 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) 
{ 

  {
#line 496
  cfb_copyarea(info, region);
#line 497
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, region->dx, region->dy, region->width,
                    region->height);
#line 499
  return;
}
}
#line 501 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static void vmw_fb_imageblit(struct fb_info *info , struct fb_image  const  *image ) 
{ 

  {
#line 503
  cfb_imageblit(info, image);
#line 504
  vmw_fb_dirty_mark((struct vmw_fb_par *)info->par, image->dx, image->dy, image->width,
                    image->height);
#line 506
  return;
}
}
#line 512 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static struct fb_ops vmw_fb_ops  = 
#line 512
     {& __this_module, 0, 0, 0, 0, & vmw_fb_check_var, & vmw_fb_set_par, & vmw_fb_setcolreg,
    0, & vmw_fb_blank, & vmw_fb_pan_display, & vmw_fb_fillrect, & vmw_fb_copyarea,
    & vmw_fb_imageblit, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 524 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
static int vmw_fb_create_bo(struct vmw_private *vmw_priv___0 , size_t size , struct vmw_dma_buffer **out ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct ttm_placement ne_placement ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 528
  ne_placement = vmw_vram_ne_placement;
#line 531
  ne_placement.lpfn = (unsigned int )((size + 4095UL) >> 12);
#line 534
  ret = ttm_write_lock(& vmw_priv___0->fbdev_master.lock, 0);
#line 535
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 535
  if (tmp != 0L) {
#line 536
    return (ret);
  } else {

  }
#line 538
  tmp___0 = kmalloc(440UL, 208U);
#line 538
  vmw_bo = (struct vmw_dma_buffer *)tmp___0;
#line 539
  if ((unsigned long )vmw_bo == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 540
    goto err_unlock;
  } else {

  }
#line 542
  ret = vmw_dmabuf_init(vmw_priv___0, vmw_bo, size, & ne_placement, 0, & vmw_dmabuf_bo_free);
#line 546
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 546
  if (tmp___1 != 0L) {
#line 547
    goto err_unlock;
  } else {

  }
#line 549
  *out = vmw_bo;
#line 551
  ttm_write_unlock(& vmw_priv___0->fbdev_master.lock);
#line 553
  return (0);
  err_unlock: 
#line 556
  ttm_write_unlock(& vmw_priv___0->fbdev_master.lock);
#line 557
  return (ret);
}
}
#line 560 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_init(struct vmw_private *vmw_priv___0 ) 
{ struct device *device ;
  struct vmw_fb_par *par ;
  struct fb_info *info ;
  unsigned int initial_width ;
  unsigned int initial_height ;
  unsigned int fb_width ;
  unsigned int fb_height ;
  unsigned int fb_bpp ;
  unsigned int fb_depth ;
  unsigned int fb_offset ;
  unsigned int fb_pitch ;
  unsigned int fb_size ;
  int ret ;
  uint32_t _min1 ;
  unsigned int _min2 ;
  unsigned int tmp ;
  uint32_t _min1___0 ;
  unsigned int _min2___0 ;
  unsigned int tmp___0 ;
  uint32_t _min1___1 ;
  unsigned int _min2___1 ;
  unsigned int tmp___1 ;
  uint32_t _min1___2 ;
  unsigned int _min2___2 ;
  unsigned int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  struct lock_class_key __key ;
  long tmp___8 ;

  {
#line 562
  device = & ((vmw_priv___0->dev)->pdev)->dev;
#line 570
  fb_bpp = 32U;
#line 571
  fb_depth = 24U;
#line 574
  _min1 = vmw_priv___0->fb_max_width;
#line 574
  _min2 = 2048U;
#line 574
  if (_min1 < _min2) {
#line 574
    tmp = _min1;
  } else {
#line 574
    tmp = _min2;
  }
#line 574
  fb_width = tmp;
#line 575
  _min1___0 = vmw_priv___0->fb_max_height;
#line 575
  _min2___0 = 2048U;
#line 575
  if (_min1___0 < _min2___0) {
#line 575
    tmp___0 = _min1___0;
  } else {
#line 575
    tmp___0 = _min2___0;
  }
#line 575
  fb_height = tmp___0;
#line 577
  _min1___1 = vmw_priv___0->initial_width;
#line 577
  _min2___1 = fb_width;
#line 577
  if (_min1___1 < _min2___1) {
#line 577
    tmp___1 = _min1___1;
  } else {
#line 577
    tmp___1 = _min2___1;
  }
#line 577
  initial_width = tmp___1;
#line 578
  _min1___2 = vmw_priv___0->initial_height;
#line 578
  _min2___2 = fb_height;
#line 578
  if (_min1___2 < _min2___2) {
#line 578
    tmp___2 = _min1___2;
  } else {
#line 578
    tmp___2 = _min2___2;
  }
#line 578
  initial_height = tmp___2;
#line 580
  fb_pitch = (fb_width * fb_bpp) / 8U;
#line 581
  fb_size = fb_pitch * fb_height;
#line 582
  fb_offset = vmw_read(vmw_priv___0, 14U);
#line 584
  info = framebuffer_alloc(256UL, device);
#line 585
  if ((unsigned long )info == (unsigned long )((struct fb_info *)0)) {
#line 586
    return (-12);
  } else {

  }
#line 591
  vmw_priv___0->fb_info = (void *)info;
#line 592
  par = (struct vmw_fb_par *)info->par;
#line 593
  par->vmw_priv = vmw_priv___0;
#line 594
  par->depth = fb_depth;
#line 595
  par->bpp = fb_bpp;
#line 596
  par->vmalloc = 0;
#line 597
  par->max_width = fb_width;
#line 598
  par->max_height = fb_height;
#line 603
  par->vmalloc = vmalloc((unsigned long )fb_size);
#line 604
  tmp___3 = ldv__builtin_expect((unsigned long )par->vmalloc == (unsigned long )((void *)0),
                             0L);
#line 604
  if (tmp___3 != 0L) {
#line 605
    ret = -12;
#line 606
    goto err_free;
  } else {

  }
#line 609
  ret = vmw_fb_create_bo(vmw_priv___0, (size_t )fb_size, & par->vmw_bo);
#line 610
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 610
  if (tmp___4 != 0L) {
#line 611
    goto err_free;
  } else {

  }
#line 613
  ret = ttm_bo_kmap(& (par->vmw_bo)->base, 0UL, (par->vmw_bo)->base.num_pages, & par->map);
#line 617
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 617
  if (tmp___5 != 0L) {
#line 618
    goto err_unref;
  } else {

  }
#line 619
  par->bo_ptr = ttm_kmap_obj_virtual(& par->map, & par->bo_iowrite);
#line 620
  par->bo_size = fb_size;
#line 625
  strcpy((char *)(& info->fix.id), "svgadrmfb");
#line 626
  info->fix.type = 0U;
#line 627
  info->fix.visual = 2U;
#line 628
  info->fix.type_aux = 0U;
#line 629
  info->fix.xpanstep = 1U;
#line 630
  info->fix.ypanstep = 1U;
#line 631
  info->fix.ywrapstep = 0U;
#line 632
  info->fix.accel = 0U;
#line 633
  info->fix.line_length = fb_pitch;
#line 635
  info->fix.smem_start = 0UL;
#line 636
  info->fix.smem_len = fb_size;
#line 638
  info->pseudo_palette = (void *)(& par->pseudo_palette);
#line 639
  info->screen_base = (char *)par->vmalloc;
#line 640
  info->screen_size = (unsigned long )fb_size;
#line 642
  info->flags = 1;
#line 643
  info->fbops = & vmw_fb_ops;
#line 646
  info->var.red.offset = 16U;
#line 647
  info->var.green.offset = 8U;
#line 648
  info->var.blue.offset = 0U;
#line 649
  info->var.red.length = 8U;
#line 650
  info->var.green.length = 8U;
#line 651
  info->var.blue.length = 8U;
#line 652
  info->var.transp.offset = 0U;
#line 653
  info->var.transp.length = 0U;
#line 655
  info->var.xres_virtual = fb_width;
#line 656
  info->var.yres_virtual = fb_height;
#line 657
  info->var.bits_per_pixel = par->bpp;
#line 658
  info->var.xoffset = 0U;
#line 659
  info->var.yoffset = 0U;
#line 660
  info->var.activate = 0U;
#line 661
  info->var.height = 4294967295U;
#line 662
  info->var.width = 4294967295U;
#line 664
  info->var.xres = initial_width;
#line 665
  info->var.yres = initial_height;
#line 669
  info->apertures = alloc_apertures(1U);
#line 670
  if ((unsigned long )info->apertures == (unsigned long )((struct apertures_struct *)0)) {
#line 671
    ret = -12;
#line 672
    goto err_aper;
  } else {

  }
#line 674
  (info->apertures)->ranges[0].base = (resource_size_t )vmw_priv___0->vram_start;
#line 675
  (info->apertures)->ranges[0].size = (resource_size_t )vmw_priv___0->vram_size;
#line 680
  tmp___6 = 0U;
#line 680
  par->dirty.x2 = tmp___6;
#line 680
  par->dirty.x1 = tmp___6;
#line 681
  tmp___7 = 0U;
#line 681
  par->dirty.y2 = tmp___7;
#line 681
  par->dirty.y1 = tmp___7;
#line 682
  par->dirty.active = 1;
#line 683
  spinlock_check(& par->dirty.lock);
#line 683
  __raw_spin_lock_init(& par->dirty.lock.ldv_5961.rlock, "&(&par->dirty.lock)->rlock",
                       & __key);
#line 684
  info->fbdefio = & vmw_defio;
#line 685
  fb_deferred_io_init(info);
#line 687
  ret = register_framebuffer(info);
#line 688
  tmp___8 = ldv__builtin_expect(ret != 0, 0L);
#line 688
  if (tmp___8 != 0L) {
#line 689
    goto err_defio;
  } else {

  }
#line 691
  return (0);
  err_defio: 
#line 694
  fb_deferred_io_cleanup(info);
  err_aper: 
#line 696
  ttm_bo_kunmap(& par->map);
  err_unref: 
#line 698
  ttm_bo_unref((struct ttm_buffer_object **)(& par->vmw_bo));
  err_free: 
#line 700
  vfree((void const   *)par->vmalloc);
#line 701
  framebuffer_release(info);
#line 702
  vmw_priv___0->fb_info = 0;
#line 704
  return (ret);
}
}
#line 707 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_close(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  struct ttm_buffer_object *bo ;

  {
#line 713
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 714
    return (0);
  } else {

  }
#line 716
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 717
  par = (struct vmw_fb_par *)info->par;
#line 718
  bo = & (par->vmw_bo)->base;
#line 719
  par->vmw_bo = 0;
#line 722
  fb_deferred_io_cleanup(info);
#line 723
  unregister_framebuffer(info);
#line 725
  ttm_bo_kunmap(& par->map);
#line 726
  ttm_bo_unref(& bo);
#line 728
  vfree((void const   *)par->vmalloc);
#line 729
  framebuffer_release(info);
#line 731
  return (0);
}
}
#line 734 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_off(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 740
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 741
    return (-22);
  } else {

  }
#line 743
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 744
  par = (struct vmw_fb_par *)info->par;
#line 746
  tmp = spinlock_check(& par->dirty.lock);
#line 746
  flags = _raw_spin_lock_irqsave(tmp);
#line 747
  par->dirty.active = 0;
#line 748
  spin_unlock_irqrestore(& par->dirty.lock, flags);
#line 750
  flush_delayed_work(& info->deferred_work);
#line 752
  par->bo_ptr = 0;
#line 753
  ttm_bo_kunmap(& par->map);
#line 755
  vmw_dmabuf_unpin(vmw_priv___0, par->vmw_bo, 0);
#line 757
  return (0);
}
}
#line 760 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int vmw_fb_on(struct vmw_private *vmw_priv___0 ) 
{ struct fb_info *info ;
  struct vmw_fb_par *par ;
  unsigned long flags ;
  bool dummy ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 768
  if ((unsigned long )vmw_priv___0->fb_info == (unsigned long )((void *)0)) {
#line 769
    return (-22);
  } else {

  }
#line 771
  info = (struct fb_info *)vmw_priv___0->fb_info;
#line 772
  par = (struct vmw_fb_par *)info->par;
#line 775
  if ((unsigned long )par->bo_ptr != (unsigned long )((void *)0)) {
#line 776
    return (0);
  } else {

  }
#line 779
  vmw_overlay_stop_all(vmw_priv___0);
#line 781
  ret = vmw_dmabuf_to_start_of_vram(vmw_priv___0, par->vmw_bo, 1, 0);
#line 782
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 782
  if (tmp != 0L) {
#line 783
    drm_err("vmw_fb_on", "could not move buffer to start of VRAM\n");
#line 784
    goto err_no_buffer;
  } else {

  }
#line 787
  ret = ttm_bo_kmap(& (par->vmw_bo)->base, 0UL, (par->vmw_bo)->base.num_pages, & par->map);
#line 791
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 791
  if (tmp___0 != 0L) {
#line 791
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"),
                         "i" (791), "i" (12UL));
    ldv_40797: ;
#line 791
    goto ldv_40797;
  } else {

  }
#line 792
  par->bo_ptr = ttm_kmap_obj_virtual(& par->map, & dummy);
#line 794
  tmp___1 = spinlock_check(& par->dirty.lock);
#line 794
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 795
  par->dirty.active = 1;
#line 796
  spin_unlock_irqrestore(& par->dirty.lock, flags);
  err_no_buffer: 
#line 799
  vmw_fb_set_par(info);
#line 801
  vmw_fb_dirty_mark(par, 0U, 0U, info->var.xres, info->var.yres);
#line 805
  schedule_delayed_work(& info->deferred_work, 0UL);
#line 807
  return (0);
}
}
#line 809 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
unsigned int ldvarg63  ;
#line 810 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct list_head *ldvarg88  ;
#line 811 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
unsigned int ldvarg60  ;
#line 812 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_info *ldvarg87  ;
#line 813 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
unsigned int ldvarg59  ;
#line 814 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_copyarea *ldvarg56  ;
#line 815 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
unsigned int ldvarg62  ;
#line 816 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_fillrect *ldvarg57  ;
#line 817 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int ldvarg58  ;
#line 818 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
unsigned int ldvarg61  ;
#line 819 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_var_screeninfo *vmw_fb_ops_group0  ;
#line 820 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_image *ldvarg55  ;
#line 821 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
struct fb_info *vmw_fb_ops_group1  ;
#line 823 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_main_exported_13(void) 
{ int tmp ;

  {
#line 825
  tmp = __VERIFIER_nondet_int();
#line 825
  switch (tmp) {
  case 0: ;
#line 828
  if (ldv_state_variable_13 == 1) {
#line 830
    vmw_fb_pan_display(vmw_fb_ops_group0, vmw_fb_ops_group1);
#line 832
    ldv_state_variable_13 = 1;
  } else {

  }
#line 835
  goto ldv_40818;
  case 1: ;
#line 838
  if (ldv_state_variable_13 == 1) {
#line 840
    vmw_fb_setcolreg(ldvarg60, ldvarg62, ldvarg61, ldvarg59, ldvarg63, vmw_fb_ops_group1);
#line 842
    ldv_state_variable_13 = 1;
  } else {

  }
#line 845
  goto ldv_40818;
  case 2: ;
#line 848
  if (ldv_state_variable_13 == 1) {
#line 850
    vmw_fb_blank(ldvarg58, vmw_fb_ops_group1);
#line 852
    ldv_state_variable_13 = 1;
  } else {

  }
#line 855
  goto ldv_40818;
  case 3: ;
#line 858
  if (ldv_state_variable_13 == 1) {
#line 860
    vmw_fb_check_var(vmw_fb_ops_group0, vmw_fb_ops_group1);
#line 862
    ldv_state_variable_13 = 1;
  } else {

  }
#line 865
  goto ldv_40818;
  case 4: ;
#line 868
  if (ldv_state_variable_13 == 1) {
#line 870
    vmw_fb_fillrect(vmw_fb_ops_group1, (struct fb_fillrect  const  *)ldvarg57);
#line 872
    ldv_state_variable_13 = 1;
  } else {

  }
#line 875
  goto ldv_40818;
  case 5: ;
#line 878
  if (ldv_state_variable_13 == 1) {
#line 880
    vmw_fb_copyarea(vmw_fb_ops_group1, (struct fb_copyarea  const  *)ldvarg56);
#line 882
    ldv_state_variable_13 = 1;
  } else {

  }
#line 885
  goto ldv_40818;
  case 6: ;
#line 888
  if (ldv_state_variable_13 == 1) {
#line 890
    vmw_fb_imageblit(vmw_fb_ops_group1, (struct fb_image  const  *)ldvarg55);
#line 892
    ldv_state_variable_13 = 1;
  } else {

  }
#line 895
  goto ldv_40818;
  case 7: ;
#line 898
  if (ldv_state_variable_13 == 1) {
#line 900
    vmw_fb_set_par(vmw_fb_ops_group1);
#line 902
    ldv_state_variable_13 = 1;
  } else {

  }
#line 905
  goto ldv_40818;
  default: ;
#line 906
  goto ldv_40818;
  }
  ldv_40818: ;
#line 910
  return;
}
}
#line 912 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_main_exported_14(void) 
{ int tmp ;

  {
#line 914
  tmp = __VERIFIER_nondet_int();
#line 914
  switch (tmp) {
  case 0: ;
#line 917
  if (ldv_state_variable_14 == 1) {
#line 919
    vmw_deferred_io(ldvarg87, ldvarg88);
#line 921
    ldv_state_variable_14 = 1;
  } else {

  }
#line 924
  goto ldv_40831;
  default: ;
#line 925
  goto ldv_40831;
  }
  ldv_40831: ;
#line 929
  return;
}
}
#line 930 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_195(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 935
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 937
  mutex_lock(ldv_func_arg1);
#line 938
  return;
}
}
#line 940 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_196(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 945
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 947
  mutex_unlock(ldv_func_arg1);
#line 948
  return;
}
}
#line 950 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_197(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 955
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 957
  mutex_lock(ldv_func_arg1);
#line 958
  return;
}
}
#line 960 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
int ldv_mutex_trylock_198(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 965
  tmp = mutex_trylock(ldv_func_arg1);
#line 965
  ldv_func_res = tmp;
#line 967
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 967
  return (tmp___0);
#line 969
  return (ldv_func_res);
}
}
#line 972 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 977
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 979
  mutex_unlock(ldv_func_arg1);
#line 980
  return;
}
}
#line 982 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 987
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 989
  mutex_lock(ldv_func_arg1);
#line 990
  return;
}
}
#line 992 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 997
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 999
  mutex_unlock(ldv_func_arg1);
#line 1000
  return;
}
}
#line 1002 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1007
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1009
  mutex_lock(ldv_func_arg1);
#line 1010
  return;
}
}
#line 1012 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1017
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1019
  mutex_unlock(ldv_func_arg1);
#line 1020
  return;
}
}
#line 1022 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1027
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 1029
  mutex_unlock(ldv_func_arg1);
#line 1030
  return;
}
}
#line 1032 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_205(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1037
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1039
  mutex_lock(ldv_func_arg1);
#line 1040
  return;
}
}
#line 1042 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1047
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1049
  mutex_unlock(ldv_func_arg1);
#line 1050
  return;
}
}
#line 1052 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_lock_207(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1057
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1059
  mutex_lock(ldv_func_arg1);
#line 1060
  return;
}
}
#line 1062 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c.prepared"
void ldv_mutex_unlock_208(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1067
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1069
  mutex_unlock(ldv_func_arg1);
#line 1070
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_226(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_224(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_227(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_231(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_232(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_234(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_236(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_238(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_240(struct mutex *ldv_func_arg1 ) ;
#line 8 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_237(struct mutex *ldv_func_arg1 ) ;
#line 12
int ldv_mutex_lock_interruptible_239(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_223(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_225(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_228(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_230(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_233(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_235(struct mutex *ldv_func_arg1 ) ;
#line 112
int ldv_mutex_lock_interruptible_mutex_of_drm_mode_config(struct mutex *lock ) ;
#line 209 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ size_t __len ;
  void *__ret ;

  {
#line 211
  __len = count;
#line 211
  __ret = __builtin_memcpy(dst, (void const   *)src, __len);
#line 213
  return;
}
}
#line 1295 "include/drm/drmP.h"
extern ssize_t drm_read(struct file * , char * , size_t  , loff_t * ) ;
#line 1304
extern unsigned int drm_poll(struct file * , struct poll_table_struct * ) ;
#line 544 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) ;
#line 545
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) ;
#line 717
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) ;
#line 718
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) ;
#line 184 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_getparam_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_getparam_arg *param ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  __le32 *fifo_mem ;
  struct vmw_fifo_state  const  *fifo ;
  unsigned long tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 187
  tmp = vmw_priv(dev);
#line 187
  dev_priv = tmp;
#line 188
  param = (struct drm_vmw_getparam_arg *)data;
#line 191
  switch (param->param) {
  case 0: 
#line 193
  tmp___0 = vmw_overlay_num_overlays(dev_priv);
#line 193
  param->value = (uint64_t )tmp___0;
#line 194
  goto ldv_40828;
  case 1: 
#line 196
  tmp___1 = vmw_overlay_num_free_overlays(dev_priv);
#line 196
  param->value = (uint64_t )tmp___1;
#line 197
  goto ldv_40828;
  case 2: 
#line 199
  tmp___2 = vmw_fifo_have_3d(dev_priv);
#line 199
  param->value = (uint64_t )tmp___2;
#line 200
  goto ldv_40828;
  case 3: 
#line 202
  param->value = (uint64_t )dev_priv->capabilities;
#line 203
  goto ldv_40828;
  case 4: 
#line 205
  param->value = (uint64_t )dev_priv->fifo.capabilities;
#line 206
  goto ldv_40828;
  case 5: 
#line 208
  param->value = (uint64_t )dev_priv->vram_size;
#line 209
  goto ldv_40828;
  case 6: 
#line 212
  fifo_mem = dev_priv->mmio_virt;
#line 213
  fifo = (struct vmw_fifo_state  const  *)(& dev_priv->fifo);
#line 215
  if (((unsigned int )fifo->capabilities & 256U) != 0U) {
#line 215
    tmp___3 = 17UL;
  } else {
#line 215
    tmp___3 = 7UL;
  }
#line 215
  tmp___4 = ioread32((void *)(fifo_mem + tmp___3));
#line 215
  param->value = (uint64_t )tmp___4;
#line 221
  goto ldv_40828;
  default: 
#line 224
  drm_err("vmw_getparam_ioctl", "Illegal vmwgfx get param request: %d\n", param->param);
#line 226
  return (-22);
  }
  ldv_40828: ;
#line 229
  return (0);
}
}
#line 233 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_get_cap_3d_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_get_3d_cap_arg *arg ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t size ;
  __le32 *fifo_mem ;
  void *buffer ;
  void *bounce ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 236
  arg = (struct drm_vmw_get_3d_cap_arg *)data;
#line 238
  tmp = vmw_priv(dev);
#line 238
  dev_priv = tmp;
#line 241
  buffer = (void *)arg->buffer;
#line 245
  tmp___0 = ldv__builtin_expect(arg->pad64 != 0U, 0L);
#line 245
  if (tmp___0 != 0L) {
#line 246
    drm_err("vmw_get_cap_3d_ioctl", "Illegal GET_3D_CAP argument.\n");
#line 247
    return (-22);
  } else {

  }
#line 250
  size = 1024U;
#line 252
  if (arg->max_size < size) {
#line 253
    size = arg->max_size;
  } else {

  }
#line 255
  bounce = vmalloc((unsigned long )size);
#line 256
  tmp___1 = ldv__builtin_expect((unsigned long )bounce == (unsigned long )((void *)0),
                             0L);
#line 256
  if (tmp___1 != 0L) {
#line 257
    drm_err("vmw_get_cap_3d_ioctl", "Failed to allocate bounce buffer for 3D caps.\n");
#line 258
    return (-12);
  } else {

  }
#line 261
  fifo_mem = dev_priv->mmio_virt;
#line 262
  memcpy_fromio(bounce, (void const volatile   *)fifo_mem + 32U, (size_t )size);
#line 264
  ret = copy_to_user(buffer, (void const   *)bounce, size);
#line 265
  if (ret != 0) {
#line 266
    ret = -14;
  } else {

  }
#line 267
  vfree((void const   *)bounce);
#line 269
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 269
  if (tmp___2 != 0L) {
#line 270
    drm_err("vmw_get_cap_3d_ioctl", "Failed to report 3D caps info.\n");
  } else {

  }
#line 272
  return (ret);
}
}
#line 275 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_present_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  struct drm_vmw_present_arg *arg ;
  struct vmw_surface *surface ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___1 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  struct vmw_resource *res ;
  uint32_t num_clips ;
  int ret ;
  long tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;
  long tmp___5 ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_mode_object  const  *__mptr___0 ;
  long tmp___6 ;

  {
#line 278
  tmp = vmw_fpriv(file_priv);
#line 278
  tfile = tmp->tfile;
#line 279
  tmp___0 = vmw_priv(dev);
#line 279
  dev_priv = tmp___0;
#line 280
  arg = (struct drm_vmw_present_arg *)data;
#line 283
  tmp___1 = vmw_master(file_priv->master);
#line 283
  vmaster = tmp___1;
#line 285
  clips = 0;
#line 292
  num_clips = arg->num_clips;
#line 293
  clips_ptr = (struct drm_vmw_rect *)arg->clips_ptr;
#line 295
  tmp___2 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 295
  if (tmp___2 != 0L) {
#line 296
    return (0);
  } else {

  }
#line 298
  if ((unsigned long )clips_ptr == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 299
    drm_err("vmw_present_ioctl", "Variable clips_ptr must be specified.\n");
#line 300
    ret = -22;
#line 301
    goto out_clips;
  } else {

  }
#line 304
  tmp___3 = kcalloc((size_t )num_clips, 16UL, 208U);
#line 304
  clips = (struct drm_vmw_rect *)tmp___3;
#line 305
  if ((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 306
    drm_err("vmw_present_ioctl", "Failed to allocate clip rect list.\n");
#line 307
    ret = -12;
#line 308
    goto out_clips;
  } else {

  }
#line 311
  tmp___4 = copy_from_user((void *)clips, (void const   *)clips_ptr, (unsigned long )num_clips * 16UL);
#line 311
  ret = (int )tmp___4;
#line 312
  if (ret != 0) {
#line 313
    drm_err("vmw_present_ioctl", "Failed to copy clip rects from userspace.\n");
#line 314
    ret = -14;
#line 315
    goto out_no_copy;
  } else {

  }
#line 318
  ret = ldv_mutex_lock_interruptible_237(& dev->mode_config.mutex);
#line 319
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 319
  if (tmp___5 != 0L) {
#line 320
    ret = -512;
#line 321
    goto out_no_mode_mutex;
  } else {

  }
#line 324
  obj = drm_mode_object_find(dev, arg->fb_id, 4227595259U);
#line 325
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 326
    drm_err("vmw_present_ioctl", "Invalid framebuffer id.\n");
#line 327
    ret = -22;
#line 328
    goto out_no_fb;
  } else {

  }
#line 330
  __mptr___0 = (struct drm_mode_object  const  *)obj;
#line 330
  __mptr = (struct drm_framebuffer  const  *)((struct drm_framebuffer *)__mptr___0 + 0xffffffffffffffe0UL);
#line 330
  vfb = (struct vmw_framebuffer *)__mptr;
#line 332
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 333
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 333
  if (tmp___6 != 0L) {
#line 334
    goto out_no_ttm_lock;
  } else {

  }
#line 336
  ret = vmw_user_resource_lookup_handle(dev_priv, tfile, arg->sid, user_surface_converter,
                                        & res);
#line 339
  if (ret != 0) {
#line 340
    goto out_no_surface;
  } else {

  }
#line 342
  surface = vmw_res_to_srf(res);
#line 343
  ret = vmw_kms_present(dev_priv, file_priv, vfb, surface, arg->sid, arg->dest_x,
                        arg->dest_y, clips, num_clips);
#line 349
  vmw_surface_unreference(& surface);
  out_no_surface: 
#line 352
  ttm_read_unlock(& vmaster->lock);
  out_no_ttm_lock: ;
  out_no_fb: 
#line 355
  ldv_mutex_unlock_238(& dev->mode_config.mutex);
  out_no_mode_mutex: ;
  out_no_copy: 
#line 358
  kfree((void const   *)clips);
  out_clips: ;
#line 360
  return (ret);
}
}
#line 363 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int vmw_present_readback_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_present_readback_arg *arg ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct drm_vmw_rect *clips_ptr ;
  struct drm_vmw_rect *clips ;
  struct drm_mode_object *obj ;
  struct vmw_framebuffer *vfb ;
  uint32_t num_clips ;
  int ret ;
  long tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  long tmp___4 ;
  struct drm_framebuffer  const  *__mptr ;
  struct drm_mode_object  const  *__mptr___0 ;
  long tmp___5 ;

  {
#line 366
  tmp = vmw_priv(dev);
#line 366
  dev_priv = tmp;
#line 367
  arg = (struct drm_vmw_present_readback_arg *)data;
#line 369
  user_fence_rep = (struct drm_vmw_fence_rep *)arg->fence_rep;
#line 372
  tmp___0 = vmw_master(file_priv->master);
#line 372
  vmaster = tmp___0;
#line 374
  clips = 0;
#line 380
  num_clips = arg->num_clips;
#line 381
  clips_ptr = (struct drm_vmw_rect *)arg->clips_ptr;
#line 383
  tmp___1 = ldv__builtin_expect(num_clips == 0U, 0L);
#line 383
  if (tmp___1 != 0L) {
#line 384
    return (0);
  } else {

  }
#line 386
  if ((unsigned long )clips_ptr == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 387
    drm_err("vmw_present_readback_ioctl", "Argument clips_ptr must be specified.\n");
#line 388
    ret = -22;
#line 389
    goto out_clips;
  } else {

  }
#line 392
  tmp___2 = kcalloc((size_t )num_clips, 16UL, 208U);
#line 392
  clips = (struct drm_vmw_rect *)tmp___2;
#line 393
  if ((unsigned long )clips == (unsigned long )((struct drm_vmw_rect *)0)) {
#line 394
    drm_err("vmw_present_readback_ioctl", "Failed to allocate clip rect list.\n");
#line 395
    ret = -12;
#line 396
    goto out_clips;
  } else {

  }
#line 399
  tmp___3 = copy_from_user((void *)clips, (void const   *)clips_ptr, (unsigned long )num_clips * 16UL);
#line 399
  ret = (int )tmp___3;
#line 400
  if (ret != 0) {
#line 401
    drm_err("vmw_present_readback_ioctl", "Failed to copy clip rects from userspace.\n");
#line 402
    ret = -14;
#line 403
    goto out_no_copy;
  } else {

  }
#line 406
  ret = ldv_mutex_lock_interruptible_239(& dev->mode_config.mutex);
#line 407
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 407
  if (tmp___4 != 0L) {
#line 408
    ret = -512;
#line 409
    goto out_no_mode_mutex;
  } else {

  }
#line 412
  obj = drm_mode_object_find(dev, arg->fb_id, 4227595259U);
#line 413
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
#line 414
    drm_err("vmw_present_readback_ioctl", "Invalid framebuffer id.\n");
#line 415
    ret = -22;
#line 416
    goto out_no_fb;
  } else {

  }
#line 419
  __mptr___0 = (struct drm_mode_object  const  *)obj;
#line 419
  __mptr = (struct drm_framebuffer  const  *)((struct drm_framebuffer *)__mptr___0 + 0xffffffffffffffe0UL);
#line 419
  vfb = (struct vmw_framebuffer *)__mptr;
#line 420
  if (! vfb->dmabuf) {
#line 421
    drm_err("vmw_present_readback_ioctl", "Framebuffer not dmabuf backed.\n");
#line 422
    ret = -22;
#line 423
    goto out_no_fb;
  } else {

  }
#line 426
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 427
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 427
  if (tmp___5 != 0L) {
#line 428
    goto out_no_ttm_lock;
  } else {

  }
#line 430
  ret = vmw_kms_readback(dev_priv, file_priv, vfb, user_fence_rep, clips, num_clips);
#line 434
  ttm_read_unlock(& vmaster->lock);
  out_no_ttm_lock: ;
  out_no_fb: 
#line 437
  ldv_mutex_unlock_240(& dev->mode_config.mutex);
  out_no_mode_mutex: ;
  out_no_copy: 
#line 440
  kfree((void const   *)clips);
  out_clips: ;
#line 442
  return (ret);
}
}
#line 455 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
unsigned int vmw_fops_poll(struct file *filp , struct poll_table_struct *wait ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  unsigned int tmp___0 ;

  {
#line 457
  file_priv = (struct drm_file *)filp->private_data;
#line 458
  tmp = vmw_priv((file_priv->minor)->dev);
#line 458
  dev_priv = tmp;
#line 461
  vmw_fifo_ping_host(dev_priv, 1U);
#line 462
  tmp___0 = drm_poll(filp, wait);
#line 462
  return (tmp___0);
}
}
#line 477 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
ssize_t vmw_fops_read(struct file *filp , char *buffer , size_t count , loff_t *offset ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  ssize_t tmp___0 ;

  {
#line 480
  file_priv = (struct drm_file *)filp->private_data;
#line 481
  tmp = vmw_priv((file_priv->minor)->dev);
#line 481
  dev_priv = tmp;
#line 484
  vmw_fifo_ping_host(dev_priv, 1U);
#line 485
  tmp___0 = drm_read(filp, buffer, count, offset);
#line 485
  return (tmp___0);
}
}
#line 488 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_223(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 493
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 495
  mutex_lock(ldv_func_arg1);
#line 496
  return;
}
}
#line 498 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_224(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 503
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 505
  mutex_unlock(ldv_func_arg1);
#line 506
  return;
}
}
#line 508 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_225(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 513
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 515
  mutex_lock(ldv_func_arg1);
#line 516
  return;
}
}
#line 518 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_trylock_226(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 523
  tmp = mutex_trylock(ldv_func_arg1);
#line 523
  ldv_func_res = tmp;
#line 525
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 525
  return (tmp___0);
#line 527
  return (ldv_func_res);
}
}
#line 530 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_227(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 535
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 537
  mutex_unlock(ldv_func_arg1);
#line 538
  return;
}
}
#line 540 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_228(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 545
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 547
  mutex_lock(ldv_func_arg1);
#line 548
  return;
}
}
#line 550 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_229(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 555
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 557
  mutex_unlock(ldv_func_arg1);
#line 558
  return;
}
}
#line 560 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_230(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 565
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 567
  mutex_lock(ldv_func_arg1);
#line 568
  return;
}
}
#line 570 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_231(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 575
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 577
  mutex_unlock(ldv_func_arg1);
#line 578
  return;
}
}
#line 580 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_232(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 585
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 587
  mutex_unlock(ldv_func_arg1);
#line 588
  return;
}
}
#line 590 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_233(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 595
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 597
  mutex_lock(ldv_func_arg1);
#line 598
  return;
}
}
#line 600 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_234(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 605
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 607
  mutex_unlock(ldv_func_arg1);
#line 608
  return;
}
}
#line 610 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_lock_235(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 615
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 617
  mutex_lock(ldv_func_arg1);
#line 618
  return;
}
}
#line 620 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_236(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 625
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 627
  mutex_unlock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_237(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 635
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 635
  ldv_func_res = tmp;
#line 637
  tmp___0 = ldv_mutex_lock_interruptible_mutex_of_drm_mode_config(ldv_func_arg1);
#line 637
  return (tmp___0);
#line 639
  return (ldv_func_res);
}
}
#line 642 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_238(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 647
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 649
  mutex_unlock(ldv_func_arg1);
#line 650
  return;
}
}
#line 652 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
int ldv_mutex_lock_interruptible_239(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 657
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 657
  ldv_func_res = tmp;
#line 659
  tmp___0 = ldv_mutex_lock_interruptible_mutex_of_drm_mode_config(ldv_func_arg1);
#line 659
  return (tmp___0);
#line 661
  return (ldv_func_res);
}
}
#line 664 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c.prepared"
void ldv_mutex_unlock_240(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 669
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
#line 671
  mutex_unlock(ldv_func_arg1);
#line 672
  return;
}
}
#line 77 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ unsigned char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2,%0; sete %1": "+m" (v->counter),
                       "=qm" (c): "ir" (i): "memory");
#line 84
  return ((int )c);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_262(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_260(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_268(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_272(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_261(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_269(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) ;
#line 18 "include/linux/rwlock_api_smp.h"
extern void _raw_read_lock(rwlock_t * ) ;
#line 19
extern void _raw_write_lock(rwlock_t * ) ;
#line 30
extern void _raw_read_unlock(rwlock_t * ) ;
#line 31
extern void _raw_write_unlock(rwlock_t * ) ;
#line 52 "include/linux/rcutree.h"
extern void kfree_call_rcu(struct callback_head * , void (*)(struct callback_head * ) ) ;
#line 31 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 

  {
#line 33
  atomic_set(& kref->refcount, 1);
#line 34
  return;
}
}
#line 64 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 67
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 67
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 67
  if (tmp != 0L) {
#line 67
    warn_slowpath_null("include/linux/kref.h", 67);
  } else {

  }
#line 67
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 69
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 69
  if (tmp___0 != 0) {
#line 70
    (*release)(kref);
#line 71
    return (1);
  } else {

  }
#line 73
  return (0);
}
}
#line 93 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ int tmp ;

  {
#line 95
  tmp = kref_sub(kref, 1U, release);
#line 95
  return (tmp);
}
}
#line 104 "include/linux/idr.h"
extern void *idr_find(struct idr * , int  ) ;
#line 105
extern int idr_pre_get(struct idr * , gfp_t  ) ;
#line 107
extern int idr_get_new_above(struct idr * , void * , int  , int * ) ;
#line 112
extern void idr_remove(struct idr * , int  ) ;
#line 454 "include/drm/ttm/ttm_bo_api.h"
extern size_t ttm_bo_acc_size(struct ttm_bo_device * , unsigned long  , unsigned int  ) ;
#line 495
extern int ttm_bo_init(struct ttm_bo_device * , struct ttm_buffer_object * , unsigned long  ,
                       enum ttm_bo_type  , struct ttm_placement * , uint32_t  , bool  ,
                       struct file * , size_t  , struct sg_table * , void (*)(struct ttm_buffer_object * ) ) ;
#line 148 "include/drm/ttm/ttm_memory.h"
extern int ttm_mem_global_alloc(struct ttm_mem_global * , uint64_t  , bool  , bool  ) ;
#line 150
extern void ttm_mem_global_free(struct ttm_mem_global * , uint64_t  ) ;
#line 157
extern size_t ttm_round_pot(size_t  ) ;
#line 149 "include/drm/ttm/ttm_object.h"
extern int ttm_base_object_init(struct ttm_object_file * , struct ttm_base_object * ,
                                bool  , enum ttm_object_type  , void (*)(struct ttm_base_object ** ) ,
                                void (*)(struct ttm_base_object * , enum ttm_ref_type  ) ) ;
#line 204
extern int ttm_ref_object_add(struct ttm_object_file * , struct ttm_base_object * ,
                              enum ttm_ref_type  , bool * ) ;
#line 426 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
bool vmw_resource_needs_backup(struct vmw_resource  const  *res ) ;
#line 464
int vmw_user_dmabuf_verify_access(struct ttm_buffer_object *bo , struct ttm_object_file *tfile ) ;
#line 479
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) ;
#line 486
void vmw_resource_move_notify(struct ttm_buffer_object *bo , struct ttm_mem_reg *mem ) ;
#line 488
void vmw_fence_single_bo(struct ttm_buffer_object *bo , struct vmw_fence_obj *fence ) ;
#line 715
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) ;
#line 716
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) ;
#line 764 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
__inline static struct ttm_mem_global *vmw_mem_glob(struct vmw_private *dev_priv ) 
{ 

  {
#line 766
  return ((struct ttm_mem_global *)dev_priv->mem_global_ref.object);
}
}
#line 76 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_resource_priv.h"
int vmw_resource_alloc_id(struct vmw_resource *res ) ;
#line 77
void vmw_resource_release_id(struct vmw_resource *res ) ;
#line 78
int vmw_resource_init(struct vmw_private *dev_priv , struct vmw_resource *res , bool delay_id ,
                      void (*res_free)(struct vmw_resource * ) , struct vmw_res_func  const  *func ) ;
#line 82
void vmw_resource_activate(struct vmw_resource *res , void (*hw_destroy)(struct vmw_resource * ) ) ;
#line 209 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static uint64_t vmw_user_stream_size  ;
#line 211 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static struct vmw_res_func  const  vmw_stream_func  = 
#line 211
     {2, 0, "video streams", 0, 0, 0, 0, 0, 0};
#line 224 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static struct vmw_dma_buffer *vmw_dma_buffer(struct ttm_buffer_object *bo ) 
{ struct ttm_buffer_object  const  *__mptr ;

  {
#line 226
  __mptr = (struct ttm_buffer_object  const  *)bo;
#line 226
  return ((struct vmw_dma_buffer *)__mptr);
}
}
#line 230 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
__inline static struct vmw_user_dma_buffer *vmw_user_dma_buffer(struct ttm_buffer_object *bo ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp ;
  struct vmw_dma_buffer  const  *__mptr ;

  {
#line 232
  tmp = vmw_dma_buffer(bo);
#line 232
  vmw_bo = tmp;
#line 233
  __mptr = (struct vmw_dma_buffer  const  *)vmw_bo;
#line 233
  return ((struct vmw_user_dma_buffer *)__mptr + 0xffffffffffffffb0UL);
}
}
#line 236 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_resource *vmw_resource_reference(struct vmw_resource *res ) 
{ 

  {
#line 238
  kref_get(& res->kref);
#line 239
  return (res);
}
}
#line 250 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_release_id(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct idr *idr ;

  {
#line 252
  dev_priv = res->dev_priv;
#line 253
  idr = (struct idr *)(& dev_priv->res_idr) + (unsigned long )(res->func)->res_type;
#line 255
  _raw_write_lock(& dev_priv->resource_lock);
#line 256
  if (res->id != -1) {
#line 257
    idr_remove(idr, res->id);
  } else {

  }
#line 258
  res->id = -1;
#line 259
  _raw_write_unlock(& dev_priv->resource_lock);
#line 260
  return;
}
}
#line 262 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_resource_release(struct kref *kref ) 
{ struct vmw_resource *res ;
  struct kref  const  *__mptr ;
  struct vmw_private *dev_priv ;
  int id ;
  struct idr *idr ;
  struct ttm_buffer_object *bo ;
  struct ttm_validate_buffer val_buf ;
  int tmp ;
  long tmp___0 ;

  {
#line 265
  __mptr = (struct kref  const  *)kref;
#line 265
  res = (struct vmw_resource *)__mptr;
#line 266
  dev_priv = res->dev_priv;
#line 268
  idr = (struct idr *)(& dev_priv->res_idr) + (unsigned long )(res->func)->res_type;
#line 270
  res->avail = 0;
#line 271
  list_del_init(& res->lru_head);
#line 272
  _raw_write_unlock(& dev_priv->resource_lock);
#line 273
  if ((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 274
    bo = & (res->backup)->base;
#line 276
    ttm_bo_reserve(bo, 0, 0, 0, 0U);
#line 277
    tmp = list_empty((struct list_head  const  *)(& res->mob_head));
#line 277
    if (tmp == 0 && (unsigned long )(res->func)->unbind != (unsigned long )((int (*/* const  */)(struct vmw_resource * ,
                                                                                                 bool  ,
                                                                                                 struct ttm_validate_buffer * ))0)) {
#line 281
      val_buf.bo = bo;
#line 282
      (*((res->func)->unbind))(res, 0, & val_buf);
    } else {

    }
#line 284
    res->backup_dirty = 0;
#line 285
    list_del_init(& res->mob_head);
#line 286
    ttm_bo_unreserve(bo);
#line 287
    vmw_dmabuf_unreference(& res->backup);
  } else {

  }
#line 290
  tmp___0 = ldv__builtin_expect((unsigned long )res->hw_destroy != (unsigned long )((void (*)(struct vmw_resource * ))0),
                             1L);
#line 290
  if (tmp___0 != 0L) {
#line 291
    (*(res->hw_destroy))(res);
  } else {

  }
#line 293
  id = res->id;
#line 294
  if ((unsigned long )res->res_free != (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 295
    (*(res->res_free))(res);
  } else {
#line 297
    kfree((void const   *)res);
  }
#line 299
  _raw_write_lock(& dev_priv->resource_lock);
#line 301
  if (id != -1) {
#line 302
    idr_remove(idr, id);
  } else {

  }
#line 303
  return;
}
}
#line 305 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_unreference(struct vmw_resource **p_res ) 
{ struct vmw_resource *res ;
  struct vmw_private *dev_priv ;

  {
#line 307
  res = *p_res;
#line 308
  dev_priv = res->dev_priv;
#line 310
  *p_res = 0;
#line 311
  _raw_write_lock(& dev_priv->resource_lock);
#line 312
  kref_put(& res->kref, & vmw_resource_release);
#line 313
  _raw_write_unlock(& dev_priv->resource_lock);
#line 314
  return;
}
}
#line 325 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_alloc_id(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  int ret ;
  struct idr *idr ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 327
  dev_priv = res->dev_priv;
#line 329
  idr = (struct idr *)(& dev_priv->res_idr) + (unsigned long )(res->func)->res_type;
#line 331
  tmp = ldv__builtin_expect(res->id != -1, 0L);
#line 331
  if (tmp != 0L) {
#line 331
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (331), "i" (12UL));
    ldv_40670: ;
#line 331
    goto ldv_40670;
  } else {

  }
  ldv_40671: 
#line 334
  tmp___0 = idr_pre_get(idr, 208U);
#line 334
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 334
  if (tmp___1 != 0L) {
#line 335
    return (-12);
  } else {

  }
#line 337
  _raw_write_lock(& dev_priv->resource_lock);
#line 338
  ret = idr_get_new_above(idr, (void *)res, 1, & res->id);
#line 339
  _raw_write_unlock(& dev_priv->resource_lock);
#line 341
  if (ret == -11) {
#line 342
    goto ldv_40671;
  } else {
#line 344
    goto ldv_40672;
  }
  ldv_40672: ;
#line 343
  return (ret);
}
}
#line 357 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_init(struct vmw_private *dev_priv , struct vmw_resource *res , bool delay_id ,
                      void (*res_free)(struct vmw_resource * ) , struct vmw_res_func  const  *func ) 
{ int tmp ;

  {
#line 362
  kref_init(& res->kref);
#line 363
  res->hw_destroy = 0;
#line 364
  res->res_free = res_free;
#line 365
  res->avail = 0;
#line 366
  res->dev_priv = dev_priv;
#line 367
  res->func = func;
#line 368
  INIT_LIST_HEAD(& res->lru_head);
#line 369
  INIT_LIST_HEAD(& res->mob_head);
#line 370
  res->id = -1;
#line 371
  res->backup = 0;
#line 372
  res->backup_offset = 0UL;
#line 373
  res->backup_dirty = 0;
#line 374
  res->res_dirty = 0;
#line 375
  if ((int )delay_id) {
#line 376
    return (0);
  } else {
#line 378
    tmp = vmw_resource_alloc_id(res);
#line 378
    return (tmp);
  }
}
}
#line 393 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_activate(struct vmw_resource *res , void (*hw_destroy)(struct vmw_resource * ) ) 
{ struct vmw_private *dev_priv ;

  {
#line 396
  dev_priv = res->dev_priv;
#line 398
  _raw_write_lock(& dev_priv->resource_lock);
#line 399
  res->avail = 1;
#line 400
  res->hw_destroy = hw_destroy;
#line 401
  _raw_write_unlock(& dev_priv->resource_lock);
#line 402
  return;
}
}
#line 404 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
struct vmw_resource *vmw_resource_lookup(struct vmw_private *dev_priv , struct idr *idr ,
                                         int id ) 
{ struct vmw_resource *res ;
  void *tmp ;
  long tmp___0 ;

  {
#line 409
  _raw_read_lock(& dev_priv->resource_lock);
#line 410
  tmp = idr_find(idr, id);
#line 410
  res = (struct vmw_resource *)tmp;
#line 411
  if ((unsigned long )res != (unsigned long )((struct vmw_resource *)0) && (int )res->avail) {
#line 412
    kref_get(& res->kref);
  } else {
#line 414
    res = 0;
  }
#line 415
  _raw_read_unlock(& dev_priv->resource_lock);
#line 417
  tmp___0 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 417
  if (tmp___0 != 0L) {
#line 418
    return (0);
  } else {

  }
#line 420
  return (res);
}
}
#line 437 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_resource_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                                    uint32_t handle , struct vmw_user_resource_conv  const  *converter ,
                                    struct vmw_resource **p_res ) 
{ struct ttm_base_object *base ;
  struct vmw_resource *res ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 446
  ret = -22;
#line 448
  base = ttm_base_object_lookup(tfile, handle);
#line 449
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 449
  if (tmp != 0L) {
#line 450
    return (-22);
  } else {

  }
#line 452
  tmp___0 = ldv__builtin_expect((unsigned int )base->object_type != (unsigned int )converter->object_type,
                             0L);
#line 452
  if (tmp___0 != 0L) {
#line 453
    goto out_bad_resource;
  } else {

  }
#line 455
  res = (*(converter->base_obj_to_res))(base);
#line 457
  _raw_read_lock(& dev_priv->resource_lock);
#line 458
  if (! res->avail || (unsigned long )res->res_free != (unsigned long )((void (*)(struct vmw_resource * ))converter->res_free)) {
#line 459
    _raw_read_unlock(& dev_priv->resource_lock);
#line 460
    goto out_bad_resource;
  } else {

  }
#line 463
  kref_get(& res->kref);
#line 464
  _raw_read_unlock(& dev_priv->resource_lock);
#line 466
  *p_res = res;
#line 467
  ret = 0;
  out_bad_resource: 
#line 470
  ttm_base_object_unref(& base);
#line 472
  return (ret);
}
}
#line 480 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_lookup_handle(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t handle , struct vmw_surface **out_surf , struct vmw_dma_buffer **out_buf ) 
{ struct vmw_resource *res ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 489
  tmp = ldv__builtin_expect((unsigned long )*out_surf != (unsigned long )((struct vmw_surface *)0),
                         0L);
#line 489
  if (tmp != 0L) {
#line 489
    goto _L;
  } else {
#line 489
    tmp___0 = ldv__builtin_expect((unsigned long )*out_buf != (unsigned long )((struct vmw_dma_buffer *)0),
                               0L);
#line 489
    if (tmp___0 != 0L) {
      _L: /* CIL Label */ 
#line 489
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                           "i" (489), "i" (12UL));
      ldv_40713: ;
#line 489
      goto ldv_40713;
    } else {

    }
  }
#line 491
  ret = vmw_user_resource_lookup_handle(dev_priv, tfile, handle, user_surface_converter,
                                        & res);
#line 494
  if (ret == 0) {
#line 495
    *out_surf = vmw_res_to_srf(res);
#line 496
    return (0);
  } else {

  }
#line 499
  *out_surf = 0;
#line 500
  ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf);
#line 501
  return (ret);
}
}
#line 507 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_dmabuf_bo_free(struct ttm_buffer_object *bo ) 
{ struct vmw_dma_buffer *vmw_bo ;
  struct vmw_dma_buffer *tmp ;

  {
#line 509
  tmp = vmw_dma_buffer(bo);
#line 509
  vmw_bo = tmp;
#line 511
  kfree((void const   *)vmw_bo);
#line 512
  return;
}
}
#line 514 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_init(struct vmw_private *dev_priv , struct vmw_dma_buffer *vmw_bo ,
                    size_t size , struct ttm_placement *placement , bool interruptible ,
                    void (*bo_free)(struct ttm_buffer_object * ) ) 
{ struct ttm_bo_device *bdev ;
  size_t acc_size ;
  int ret ;
  long tmp ;

  {
#line 520
  bdev = & dev_priv->bdev;
#line 524
  tmp = ldv__builtin_expect((unsigned long )bo_free == (unsigned long )((void (*)(struct ttm_buffer_object * ))0),
                         0L);
#line 524
  if (tmp != 0L) {
#line 524
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (524), "i" (12UL));
    ldv_40730: ;
#line 524
    goto ldv_40730;
  } else {

  }
#line 526
  acc_size = ttm_bo_acc_size(bdev, size, 440U);
#line 527
  memset((void *)vmw_bo, 0, 440UL);
#line 529
  INIT_LIST_HEAD(& vmw_bo->res_list);
#line 531
  ret = ttm_bo_init(bdev, & vmw_bo->base, size, 0, placement, 0U, (int )interruptible,
                    0, acc_size, 0, bo_free);
#line 535
  return (ret);
}
}
#line 538 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_dmabuf_destroy(struct ttm_buffer_object *bo ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct vmw_user_dma_buffer *tmp ;

  {
#line 540
  tmp = vmw_user_dma_buffer(bo);
#line 540
  vmw_user_bo = tmp;
#line 542
  kfree_call_rcu(& vmw_user_bo->base.rhead, 0);
#line 543
  return;
}
}
#line 545 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_dmabuf_release(struct ttm_base_object **p_base ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  struct ttm_buffer_object *bo ;
  long tmp ;
  struct ttm_base_object  const  *__mptr ;

  {
#line 548
  base = *p_base;
#line 551
  *p_base = 0;
#line 553
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 553
  if (tmp != 0L) {
#line 554
    return;
  } else {

  }
#line 556
  __mptr = (struct ttm_base_object  const  *)base;
#line 556
  vmw_user_bo = (struct vmw_user_dma_buffer *)__mptr;
#line 557
  bo = & vmw_user_bo->dma.base;
#line 558
  ttm_bo_unref(& bo);
#line 559
  return;
}
}
#line 573 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_alloc(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                          uint32_t size , bool shareable , uint32_t *handle , struct vmw_dma_buffer **p_dma_buf ) 
{ struct vmw_user_dma_buffer *user_bo ;
  struct ttm_buffer_object *tmp ;
  int ret ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 584
  tmp___0 = kzalloc(520UL, 208U);
#line 584
  user_bo = (struct vmw_user_dma_buffer *)tmp___0;
#line 585
  tmp___1 = ldv__builtin_expect((unsigned long )user_bo == (unsigned long )((struct vmw_user_dma_buffer *)0),
                             0L);
#line 585
  if (tmp___1 != 0L) {
#line 586
    drm_err("vmw_user_dmabuf_alloc", "Failed to allocate a buffer.\n");
#line 587
    return (-12);
  } else {

  }
#line 590
  ret = vmw_dmabuf_init(dev_priv, & user_bo->dma, (size_t )size, & vmw_vram_sys_placement,
                        1, & vmw_user_dmabuf_destroy);
#line 593
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 593
  if (tmp___2 != 0L) {
#line 594
    return (ret);
  } else {

  }
#line 596
  tmp = ttm_bo_reference(& user_bo->dma.base);
#line 597
  ret = ttm_base_object_init(tfile, & user_bo->base, (int )shareable, 1, & vmw_user_dmabuf_release,
                             0);
#line 602
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 602
  if (tmp___3 != 0L) {
#line 603
    ttm_bo_unref(& tmp);
#line 604
    goto out_no_base_object;
  } else {

  }
#line 607
  *p_dma_buf = & user_bo->dma;
#line 608
  *handle = (uint32_t )user_bo->base.hash.key;
  out_no_base_object: ;
#line 611
  return (ret);
}
}
#line 621 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_verify_access(struct ttm_buffer_object *bo , struct ttm_object_file *tfile ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  long tmp ;
  int tmp___0 ;

  {
#line 626
  tmp = ldv__builtin_expect((unsigned long )bo->destroy != (unsigned long )(& vmw_user_dmabuf_destroy),
                         0L);
#line 626
  if (tmp != 0L) {
#line 627
    return (-1);
  } else {

  }
#line 629
  vmw_user_bo = vmw_user_dma_buffer(bo);
#line 630
  if ((unsigned long )vmw_user_bo->base.tfile == (unsigned long )tfile || (int )vmw_user_bo->base.shareable) {
#line 630
    tmp___0 = 0;
  } else {
#line 630
    tmp___0 = -1;
  }
#line 630
  return (tmp___0);
}
}
#line 634 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_alloc_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  union drm_vmw_alloc_dmabuf_arg *arg ;
  struct drm_vmw_alloc_dmabuf_req *req ;
  struct drm_vmw_dmabuf_rep *rep ;
  struct vmw_dma_buffer *dma_buf ;
  uint32_t handle ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  int ret ;
  long tmp___1 ;
  struct vmw_fpriv *tmp___2 ;
  long tmp___3 ;

  {
#line 637
  tmp = vmw_priv(dev);
#line 637
  dev_priv = tmp;
#line 638
  arg = (union drm_vmw_alloc_dmabuf_arg *)data;
#line 640
  req = & arg->req;
#line 641
  rep = & arg->rep;
#line 644
  tmp___0 = vmw_master(file_priv->master);
#line 644
  vmaster = tmp___0;
#line 647
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 648
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 648
  if (tmp___1 != 0L) {
#line 649
    return (ret);
  } else {

  }
#line 651
  tmp___2 = vmw_fpriv(file_priv);
#line 651
  ret = vmw_user_dmabuf_alloc(dev_priv, tmp___2->tfile, req->size, 0, & handle, & dma_buf);
#line 653
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 653
  if (tmp___3 != 0L) {
#line 654
    goto out_no_dmabuf;
  } else {

  }
#line 656
  rep->handle = handle;
#line 657
  rep->map_handle = dma_buf->base.addr_space_offset;
#line 658
  rep->cur_gmr_id = handle;
#line 659
  rep->cur_gmr_offset = 0U;
#line 661
  vmw_dmabuf_unreference(& dma_buf);
  out_no_dmabuf: 
#line 664
  ttm_read_unlock(& vmaster->lock);
#line 666
  return (ret);
}
}
#line 669 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dmabuf_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_unref_dmabuf_arg *arg ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 672
  arg = (struct drm_vmw_unref_dmabuf_arg *)data;
#line 675
  tmp = vmw_fpriv(file_priv);
#line 675
  tmp___0 = ttm_ref_object_base_unref(tmp->tfile, (unsigned long )arg->handle, 0);
#line 675
  return (tmp___0);
}
}
#line 680 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile , uint32_t handle , struct vmw_dma_buffer **out ) 
{ struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_base_object *base ;
  long tmp ;
  long tmp___0 ;
  struct ttm_base_object  const  *__mptr ;

  {
#line 686
  base = ttm_base_object_lookup(tfile, handle);
#line 687
  tmp = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                         0L);
#line 687
  if (tmp != 0L) {
#line 688
    printk("\vInvalid buffer object handle 0x%08lx.\n", (unsigned long )handle);
#line 690
    return (-3);
  } else {

  }
#line 693
  tmp___0 = ldv__builtin_expect((unsigned int )base->object_type != 1U, 0L);
#line 693
  if (tmp___0 != 0L) {
#line 694
    ttm_base_object_unref(& base);
#line 695
    printk("\vInvalid buffer object handle 0x%08lx.\n", (unsigned long )handle);
#line 697
    return (-22);
  } else {

  }
#line 700
  __mptr = (struct ttm_base_object  const  *)base;
#line 700
  vmw_user_bo = (struct vmw_user_dma_buffer *)__mptr;
#line 701
  ttm_bo_reference(& vmw_user_bo->dma.base);
#line 702
  ttm_base_object_unref(& base);
#line 703
  *out = & vmw_user_bo->dma;
#line 705
  return (0);
}
}
#line 708 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_dmabuf_reference(struct ttm_object_file *tfile , struct vmw_dma_buffer *dma_buf ) 
{ struct vmw_user_dma_buffer *user_bo ;
  struct vmw_dma_buffer  const  *__mptr ;
  int tmp ;

  {
#line 713
  if ((unsigned long )dma_buf->base.destroy != (unsigned long )(& vmw_user_dmabuf_destroy)) {
#line 714
    return (-22);
  } else {

  }
#line 716
  __mptr = (struct vmw_dma_buffer  const  *)dma_buf;
#line 716
  user_bo = (struct vmw_user_dma_buffer *)__mptr + 0xffffffffffffffb0UL;
#line 717
  tmp = ttm_ref_object_add(tfile, & user_bo->base, 0, 0);
#line 717
  return (tmp);
}
}
#line 724 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_stream_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct vmw_stream *stream ;
  int ret ;
  struct vmw_resource  const  *__mptr ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 726
  dev_priv = res->dev_priv;
#line 730
  printk("\016[drm] %s: unref\n", "vmw_stream_destroy");
#line 731
  __mptr = (struct vmw_resource  const  *)res;
#line 731
  stream = (struct vmw_stream *)__mptr;
#line 733
  ret = vmw_overlay_unref(dev_priv, stream->stream_id);
#line 734
  __ret_warn_on = ret != 0;
#line 734
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 734
  if (tmp != 0L) {
#line 734
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared",
                       734);
  } else {

  }
#line 734
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 736
  return;
}
}
#line 737 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_stream_init(struct vmw_private *dev_priv , struct vmw_stream *stream ,
                           void (*res_free)(struct vmw_resource * ) ) 
{ struct vmw_resource *res ;
  int ret ;
  long tmp ;

  {
#line 741
  res = & stream->res;
#line 744
  ret = vmw_resource_init(dev_priv, res, 0, res_free, & vmw_stream_func);
#line 747
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 747
  if (tmp != 0L) {
#line 748
    if ((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 749
      kfree((void const   *)stream);
    } else {
#line 751
      (*res_free)(& stream->res);
    }
#line 752
    return (ret);
  } else {

  }
#line 755
  ret = vmw_overlay_claim(dev_priv, & stream->stream_id);
#line 756
  if (ret != 0) {
#line 757
    vmw_resource_unreference(& res);
#line 758
    return (ret);
  } else {

  }
#line 761
  printk("\016[drm] %s: claimed\n", "vmw_stream_init");
#line 763
  vmw_resource_activate(& stream->res, & vmw_stream_destroy);
#line 764
  return (0);
}
}
#line 767 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_stream_free(struct vmw_resource *res ) 
{ struct vmw_user_stream *stream ;
  struct vmw_resource  const  *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp ;

  {
#line 770
  __mptr = (struct vmw_resource  const  *)res;
#line 770
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffb0UL;
#line 771
  dev_priv = res->dev_priv;
#line 773
  kfree_call_rcu(& stream->base.rhead, 0);
#line 774
  tmp = vmw_mem_glob(dev_priv);
#line 774
  ttm_mem_global_free(tmp, vmw_user_stream_size);
#line 775
  return;
}
}
#line 783 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_user_stream_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_stream *stream ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 785
  base = *p_base;
#line 787
  __mptr = (struct ttm_base_object  const  *)base;
#line 787
  stream = (struct vmw_user_stream *)__mptr;
#line 788
  res = & stream->stream.res;
#line 790
  *p_base = 0;
#line 791
  vmw_resource_unreference(& res);
#line 792
  return;
}
}
#line 794 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_stream_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_resource *res ;
  struct vmw_user_stream *stream ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___0 ;
  struct idr *idr ;
  int ret ;
  long tmp___1 ;
  struct vmw_resource  const  *__mptr ;

  {
#line 797
  tmp = vmw_priv(dev);
#line 797
  dev_priv = tmp;
#line 800
  arg = (struct drm_vmw_stream_arg *)data;
#line 801
  tmp___0 = vmw_fpriv(file_priv);
#line 801
  tfile = tmp___0->tfile;
#line 802
  idr = (struct idr *)(& dev_priv->res_idr) + 2UL;
#line 803
  ret = 0;
#line 806
  res = vmw_resource_lookup(dev_priv, idr, (int )arg->stream_id);
#line 807
  tmp___1 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 807
  if (tmp___1 != 0L) {
#line 808
    return (-22);
  } else {

  }
#line 810
  if ((unsigned long )res->res_free != (unsigned long )(& vmw_user_stream_free)) {
#line 811
    ret = -22;
#line 812
    goto out;
  } else {

  }
#line 815
  __mptr = (struct vmw_resource  const  *)res;
#line 815
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffb0UL;
#line 816
  if ((unsigned long )stream->base.tfile != (unsigned long )tfile) {
#line 817
    ret = -22;
#line 818
    goto out;
  } else {

  }
#line 821
  ttm_ref_object_base_unref(tfile, stream->base.hash.key, 0);
  out: 
#line 823
  vmw_resource_unreference(& res);
#line 824
  return (ret);
}
}
#line 827 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_stream_claim_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  struct drm_vmw_stream_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  int ret ;
  size_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct ttm_mem_global *tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  struct ttm_mem_global *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 830
  tmp = vmw_priv(dev);
#line 830
  dev_priv = tmp;
#line 834
  arg = (struct drm_vmw_stream_arg *)data;
#line 835
  tmp___1 = vmw_fpriv(file_priv);
#line 835
  tfile = tmp___1->tfile;
#line 836
  tmp___2 = vmw_master(file_priv->master);
#line 836
  vmaster = tmp___2;
#line 844
  tmp___4 = ldv__builtin_expect(vmw_user_stream_size == 0ULL, 0L);
#line 844
  if (tmp___4 != 0L) {
#line 845
    tmp___3 = ttm_round_pot(200UL);
#line 845
    vmw_user_stream_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 847
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 848
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 848
  if (tmp___5 != 0L) {
#line 849
    return (ret);
  } else {

  }
#line 851
  tmp___6 = vmw_mem_glob(dev_priv);
#line 851
  ret = ttm_mem_global_alloc(tmp___6, vmw_user_stream_size, 0, 1);
#line 854
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 854
  if (tmp___7 != 0L) {
#line 855
    if (ret != -512) {
#line 856
      drm_err("vmw_stream_claim_ioctl", "Out of graphics memory for stream creation.\n");
    } else {

    }
#line 858
    goto out_unlock;
  } else {

  }
#line 862
  tmp___8 = kmalloc(200UL, 208U);
#line 862
  stream = (struct vmw_user_stream *)tmp___8;
#line 863
  tmp___10 = ldv__builtin_expect((unsigned long )stream == (unsigned long )((struct vmw_user_stream *)0),
                              0L);
#line 863
  if (tmp___10 != 0L) {
#line 864
    tmp___9 = vmw_mem_glob(dev_priv);
#line 864
    ttm_mem_global_free(tmp___9, vmw_user_stream_size);
#line 866
    ret = -12;
#line 867
    goto out_unlock;
  } else {

  }
#line 870
  res = & stream->stream.res;
#line 871
  stream->base.shareable = 0;
#line 872
  stream->base.tfile = 0;
#line 878
  ret = vmw_stream_init(dev_priv, & stream->stream, & vmw_user_stream_free);
#line 879
  tmp___11 = ldv__builtin_expect(ret != 0, 0L);
#line 879
  if (tmp___11 != 0L) {
#line 880
    goto out_unlock;
  } else {

  }
#line 882
  tmp___0 = vmw_resource_reference(res);
#line 883
  ret = ttm_base_object_init(tfile, & stream->base, 0, 258, & vmw_user_stream_base_release,
                             0);
#line 886
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 886
  if (tmp___12 != 0L) {
#line 887
    vmw_resource_unreference(& tmp___0);
#line 888
    goto out_err;
  } else {

  }
#line 891
  arg->stream_id = (uint32_t )res->id;
  out_err: 
#line 893
  vmw_resource_unreference(& res);
  out_unlock: 
#line 895
  ttm_read_unlock(& vmaster->lock);
#line 896
  return (ret);
}
}
#line 899 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_user_stream_lookup(struct vmw_private *dev_priv , struct ttm_object_file *tfile ,
                           uint32_t *inout_id , struct vmw_resource **out ) 
{ struct vmw_user_stream *stream ;
  struct vmw_resource *res ;
  int ret ;
  long tmp ;
  struct vmw_resource  const  *__mptr ;

  {
#line 907
  res = vmw_resource_lookup(dev_priv, (struct idr *)(& dev_priv->res_idr) + 2UL, (int )*inout_id);
#line 909
  tmp = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                         0L);
#line 909
  if (tmp != 0L) {
#line 910
    return (-22);
  } else {

  }
#line 912
  if ((unsigned long )res->res_free != (unsigned long )(& vmw_user_stream_free)) {
#line 913
    ret = -22;
#line 914
    goto err_ref;
  } else {

  }
#line 917
  __mptr = (struct vmw_resource  const  *)res;
#line 917
  stream = (struct vmw_user_stream *)__mptr + 0xffffffffffffffb0UL;
#line 918
  if ((unsigned long )stream->base.tfile != (unsigned long )tfile) {
#line 919
    ret = -1;
#line 920
    goto err_ref;
  } else {

  }
#line 923
  *inout_id = stream->stream.stream_id;
#line 924
  *out = res;
#line 925
  return (0);
  err_ref: 
#line 927
  vmw_resource_unreference(& res);
#line 928
  return (ret);
}
}
#line 932 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dumb_create(struct drm_file *file_priv , struct drm_device *dev , struct drm_mode_create_dumb *args ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___0 ;
  struct vmw_user_dma_buffer *vmw_user_bo ;
  struct ttm_buffer_object *tmp___1 ;
  int ret ;
  void *tmp___2 ;
  struct vmw_fpriv *tmp___3 ;
  long tmp___4 ;

  {
#line 936
  tmp = vmw_priv(dev);
#line 936
  dev_priv = tmp;
#line 937
  tmp___0 = vmw_master(file_priv->master);
#line 937
  vmaster = tmp___0;
#line 942
  args->pitch = args->width * ((args->bpp + 7U) / 8U);
#line 943
  args->size = (uint64_t )(args->pitch * args->height);
#line 945
  tmp___2 = kzalloc(520UL, 208U);
#line 945
  vmw_user_bo = (struct vmw_user_dma_buffer *)tmp___2;
#line 946
  if ((unsigned long )vmw_user_bo == (unsigned long )((struct vmw_user_dma_buffer *)0)) {
#line 947
    return (-12);
  } else {

  }
#line 949
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 950
  if (ret != 0) {
#line 951
    kfree((void const   *)vmw_user_bo);
#line 952
    return (ret);
  } else {

  }
#line 955
  ret = vmw_dmabuf_init(dev_priv, & vmw_user_bo->dma, (size_t )args->size, & vmw_vram_sys_placement,
                        1, & vmw_user_dmabuf_destroy);
#line 958
  if (ret != 0) {
#line 959
    goto out_no_dmabuf;
  } else {

  }
#line 961
  tmp___1 = ttm_bo_reference(& vmw_user_bo->dma.base);
#line 962
  tmp___3 = vmw_fpriv(file_priv);
#line 962
  ret = ttm_base_object_init(tmp___3->tfile, & vmw_user_bo->base, 0, 1, & vmw_user_dmabuf_release,
                             0);
#line 967
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 967
  if (tmp___4 != 0L) {
#line 968
    goto out_no_base_object;
  } else {

  }
#line 970
  args->handle = (uint32_t )vmw_user_bo->base.hash.key;
  out_no_base_object: 
#line 973
  ttm_bo_unref(& tmp___1);
  out_no_dmabuf: 
#line 975
  ttm_read_unlock(& vmaster->lock);
#line 976
  return (ret);
}
}
#line 979 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dumb_map_offset(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ,
                        uint64_t *offset ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_dma_buffer *out_buf ;
  int ret ;

  {
#line 983
  tmp = vmw_fpriv(file_priv);
#line 983
  tfile = tmp->tfile;
#line 987
  ret = vmw_user_dmabuf_lookup(tfile, handle, & out_buf);
#line 988
  if (ret != 0) {
#line 989
    return (-22);
  } else {

  }
#line 991
  *offset = out_buf->base.addr_space_offset;
#line 992
  vmw_dmabuf_unreference(& out_buf);
#line 993
  return (0);
}
}
#line 996 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_dumb_destroy(struct drm_file *file_priv , struct drm_device *dev , uint32_t handle ) 
{ struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 1000
  tmp = vmw_fpriv(file_priv);
#line 1000
  tmp___0 = ttm_ref_object_base_unref(tmp->tfile, (unsigned long )handle, 0);
#line 1000
  return (tmp___0);
}
}
#line 1011 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_resource_buf_alloc(struct vmw_resource *res , bool interruptible ) 
{ unsigned long size ;
  struct vmw_dma_buffer *backup ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1014
  size = (res->backup_size + 4095UL) & 0xfffffffffffff000UL;
#line 1019
  tmp___0 = ldv__builtin_expect((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0),
                             1L);
#line 1019
  if (tmp___0 != 0L) {
#line 1020
    tmp = ldv__builtin_expect((res->backup)->base.num_pages * 4096UL < size, 0L);
#line 1020
    if (tmp != 0L) {
#line 1020
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                           "i" (1020), "i" (12UL));
      ldv_40910: ;
#line 1020
      goto ldv_40910;
    } else {

    }
#line 1021
    return (0);
  } else {

  }
#line 1024
  tmp___1 = kzalloc(440UL, 208U);
#line 1024
  backup = (struct vmw_dma_buffer *)tmp___1;
#line 1025
  tmp___2 = ldv__builtin_expect((unsigned long )backup == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 1025
  if (tmp___2 != 0L) {
#line 1026
    return (-12);
  } else {

  }
#line 1028
  ret = vmw_dmabuf_init(res->dev_priv, backup, res->backup_size, (res->func)->backup_placement,
                        (int )interruptible, & vmw_dmabuf_bo_free);
#line 1032
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1032
  if (tmp___3 != 0L) {
#line 1033
    goto out_no_dmabuf;
  } else {

  }
#line 1035
  res->backup = backup;
  out_no_dmabuf: ;
#line 1038
  return (ret);
}
}
#line 1052 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static int vmw_resource_do_validate(struct vmw_resource *res , struct ttm_validate_buffer *val_buf ) 
{ int ret ;
  struct vmw_res_func  const  *func ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 1055
  ret = 0;
#line 1056
  func = res->func;
#line 1058
  tmp___0 = ldv__builtin_expect(res->id == -1, 0L);
#line 1058
  if (tmp___0 != 0L) {
#line 1059
    ret = (*(func->create))(res);
#line 1060
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1060
    if (tmp != 0L) {
#line 1061
      return (ret);
    } else {

    }
  } else {

  }
#line 1064
  if ((unsigned long )func->bind != (unsigned long )((int (*/* const  */)(struct vmw_resource * ,
                                                                          struct ttm_validate_buffer * ))0)) {
#line 1064
    if ((int )func->needs_backup) {
#line 1064
      tmp___2 = list_empty((struct list_head  const  *)(& res->mob_head));
#line 1064
      if (tmp___2 != 0) {
#line 1064
        if ((unsigned long )val_buf->bo != (unsigned long )((struct ttm_buffer_object *)0)) {
#line 1064
          goto _L;
        } else {
#line 1064
          goto _L___1;
        }
      } else {
#line 1064
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1064
    if (! ((_Bool )func->needs_backup) && (unsigned long )val_buf->bo != (unsigned long )((struct ttm_buffer_object *)0)) {
      _L: /* CIL Label */ 
#line 1068
      ret = (*(func->bind))(res, val_buf);
#line 1069
      tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1069
      if (tmp___1 != 0L) {
#line 1070
        goto out_bind_failed;
      } else {

      }
#line 1071
      if ((int )func->needs_backup) {
#line 1072
        list_add_tail(& res->mob_head, & (res->backup)->res_list);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1081
  res->res_dirty = 1;
#line 1083
  return (0);
  out_bind_failed: 
#line 1086
  (*(func->destroy))(res);
#line 1088
  return (ret);
}
}
#line 1103 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_unreserve(struct vmw_resource *res , struct vmw_dma_buffer *new_backup ,
                            unsigned long new_backup_offset ) 
{ struct vmw_private *dev_priv ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 1107
  dev_priv = res->dev_priv;
#line 1109
  tmp = list_empty((struct list_head  const  *)(& res->lru_head));
#line 1109
  if (tmp == 0) {
#line 1110
    return;
  } else {

  }
#line 1112
  if ((unsigned long )new_backup != (unsigned long )((struct vmw_dma_buffer *)0) && (unsigned long )res->backup != (unsigned long )new_backup) {
#line 1114
    if ((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1115
      tmp___0 = atomic_read((atomic_t const   *)(& (res->backup)->base.reserved));
#line 1115
      tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 1115
      if (tmp___1 != 0L) {
#line 1115
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                             "i" (1115), "i" (12UL));
        ldv_40925: ;
#line 1115
        goto ldv_40925;
      } else {

      }
#line 1116
      list_del_init(& res->mob_head);
#line 1117
      vmw_dmabuf_unreference(& res->backup);
    } else {

    }
#line 1120
    res->backup = vmw_dmabuf_reference(new_backup);
#line 1121
    tmp___2 = atomic_read((atomic_t const   *)(& new_backup->base.reserved));
#line 1121
    tmp___3 = ldv__builtin_expect(tmp___2 == 0, 0L);
#line 1121
    if (tmp___3 != 0L) {
#line 1121
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                           "i" (1121), "i" (12UL));
      ldv_40926: ;
#line 1121
      goto ldv_40926;
    } else {

    }
#line 1122
    list_add_tail(& res->mob_head, & new_backup->res_list);
  } else {

  }
#line 1124
  if ((unsigned long )new_backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1125
    res->backup_offset = new_backup_offset;
  } else {

  }
#line 1127
  if (! ((_Bool )(res->func)->may_evict)) {
#line 1128
    return;
  } else {

  }
#line 1130
  _raw_write_lock(& dev_priv->resource_lock);
#line 1131
  list_add_tail(& res->lru_head, (struct list_head *)(& (res->dev_priv)->res_lru) + (unsigned long )(res->func)->res_type);
#line 1133
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1134
  return;
}
}
#line 1147 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_check_buffer(struct vmw_resource *res , bool interruptible , struct ttm_validate_buffer *val_buf ) 
{ struct list_head val_list ;
  bool backup_dirty ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 1152
  backup_dirty = 0;
#line 1155
  tmp___0 = ldv__builtin_expect((unsigned long )res->backup == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 1155
  if (tmp___0 != 0L) {
#line 1156
    ret = vmw_resource_buf_alloc(res, (int )interruptible);
#line 1157
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1157
    if (tmp != 0L) {
#line 1158
      return (ret);
    } else {

    }
  } else {

  }
#line 1161
  INIT_LIST_HEAD(& val_list);
#line 1162
  val_buf->bo = ttm_bo_reference(& (res->backup)->base);
#line 1163
  list_add_tail(& val_buf->head, & val_list);
#line 1164
  ret = ttm_eu_reserve_buffers(& val_list);
#line 1165
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1165
  if (tmp___1 != 0L) {
#line 1166
    goto out_no_reserve;
  } else {

  }
#line 1168
  if ((int )(res->func)->needs_backup) {
#line 1168
    tmp___2 = list_empty((struct list_head  const  *)(& res->mob_head));
#line 1168
    if (tmp___2 != 0) {
#line 1169
      return (0);
    } else {

    }
  } else {

  }
#line 1171
  backup_dirty = res->backup_dirty;
#line 1172
  ret = ttm_bo_validate(& (res->backup)->base, (res->func)->backup_placement, 1, 0);
#line 1176
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1176
  if (tmp___3 != 0L) {
#line 1177
    goto out_no_validate;
  } else {

  }
#line 1179
  return (0);
  out_no_validate: 
#line 1182
  ttm_eu_backoff_reservation(& val_list);
  out_no_reserve: 
#line 1184
  ttm_bo_unref(& val_buf->bo);
#line 1185
  if ((int )backup_dirty) {
#line 1186
    vmw_dmabuf_unreference(& res->backup);
  } else {

  }
#line 1188
  return (ret);
}
}
#line 1201 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_reserve(struct vmw_resource *res , bool no_backup ) 
{ struct vmw_private *dev_priv ;
  int ret ;
  long tmp ;

  {
#line 1203
  dev_priv = res->dev_priv;
#line 1206
  _raw_write_lock(& dev_priv->resource_lock);
#line 1207
  list_del_init(& res->lru_head);
#line 1208
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1210
  if (((int )(res->func)->needs_backup && (unsigned long )res->backup == (unsigned long )((struct vmw_dma_buffer *)0)) && ! no_backup) {
#line 1212
    ret = vmw_resource_buf_alloc(res, 1);
#line 1213
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 1213
    if (tmp != 0L) {
#line 1214
      return (ret);
    } else {

    }
  } else {

  }
#line 1217
  return (0);
}
}
#line 1226 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_backoff_reservation(struct ttm_validate_buffer *val_buf ) 
{ struct list_head val_list ;
  long tmp ;

  {
#line 1230
  tmp = ldv__builtin_expect((unsigned long )val_buf->bo == (unsigned long )((struct ttm_buffer_object *)0),
                         1L);
#line 1230
  if (tmp != 0L) {
#line 1231
    return;
  } else {

  }
#line 1233
  INIT_LIST_HEAD(& val_list);
#line 1234
  list_add_tail(& val_buf->head, & val_list);
#line 1235
  ttm_eu_backoff_reservation(& val_list);
#line 1236
  ttm_bo_unref(& val_buf->bo);
#line 1237
  return;
}
}
#line 1245 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_do_evict(struct vmw_resource *res ) 
{ struct ttm_validate_buffer val_buf ;
  struct vmw_res_func  const  *func ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
#line 1248
  func = res->func;
#line 1251
  tmp = ldv__builtin_expect((long )(! ((_Bool )func->may_evict)), 0L);
#line 1251
  if (tmp != 0L) {
#line 1251
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"),
                         "i" (1251), "i" (12UL));
    ldv_40953: ;
#line 1251
    goto ldv_40953;
  } else {

  }
#line 1253
  val_buf.bo = 0;
#line 1254
  ret = vmw_resource_check_buffer(res, 1, & val_buf);
#line 1255
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 1255
  if (tmp___0 != 0L) {
#line 1256
    return (ret);
  } else {

  }
#line 1258
  tmp___2 = ldv__builtin_expect((unsigned long )func->unbind != (unsigned long )((int (*/* const  */)(struct vmw_resource * ,
                                                                                                   bool  ,
                                                                                                   struct ttm_validate_buffer * ))0),
                             0L);
#line 1258
  if (tmp___2 != 0L) {
#line 1258
    tmp___3 = ldv__builtin_expect((long )(! ((_Bool )func->needs_backup)), 0L);
#line 1258
    if (tmp___3 != 0L) {
#line 1258
      tmp___6 = 1;
    } else {
#line 1258
      tmp___4 = list_empty((struct list_head  const  *)(& res->mob_head));
#line 1258
      tmp___5 = ldv__builtin_expect(tmp___4 == 0, 0L);
#line 1258
      if (tmp___5 != 0L) {
#line 1258
        tmp___6 = 1;
      } else {
#line 1258
        tmp___6 = 0;
      }
    }
#line 1258
    if (tmp___6 != 0) {
#line 1260
      ret = (*(func->unbind))(res, (int )res->res_dirty, & val_buf);
#line 1261
      tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1261
      if (tmp___1 != 0L) {
#line 1262
        goto out_no_unbind;
      } else {

      }
#line 1263
      list_del_init(& res->mob_head);
    } else {

    }
  } else {

  }
#line 1265
  ret = (*(func->destroy))(res);
#line 1266
  res->backup_dirty = 1;
#line 1267
  res->res_dirty = 0;
  out_no_unbind: 
#line 1269
  vmw_resource_backoff_reservation(& val_buf);
#line 1271
  return (ret);
}
}
#line 1286 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int vmw_resource_validate(struct vmw_resource *res ) 
{ int ret ;
  struct vmw_resource *evict_res ;
  struct vmw_private *dev_priv ;
  struct list_head *lru_list ;
  struct ttm_validate_buffer val_buf ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;
  long tmp___2 ;

  {
#line 1290
  dev_priv = res->dev_priv;
#line 1291
  lru_list = (struct list_head *)(& dev_priv->res_lru) + (unsigned long )(res->func)->res_type;
#line 1294
  tmp = ldv__builtin_expect((long )(! ((_Bool )(res->func)->may_evict)), 1L);
#line 1294
  if (tmp != 0L) {
#line 1295
    return (0);
  } else {

  }
#line 1297
  val_buf.bo = 0;
#line 1298
  if ((unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1299
    val_buf.bo = & (res->backup)->base;
  } else {

  }
  ldv_40967: 
#line 1301
  ret = vmw_resource_do_validate(res, & val_buf);
#line 1302
  tmp___0 = ldv__builtin_expect(ret != -16, 1L);
#line 1302
  if (tmp___0 != 0L) {
#line 1303
    goto ldv_40963;
  } else {

  }
#line 1305
  _raw_write_lock(& dev_priv->resource_lock);
#line 1306
  tmp___1 = list_empty((struct list_head  const  *)lru_list);
#line 1306
  if (tmp___1 != 0 || ! ((_Bool )(res->func)->may_evict)) {
#line 1307
    drm_err("vmw_resource_validate", "Out of device device id entries for %s.\n",
            (res->func)->type_name);
#line 1309
    ret = -16;
#line 1310
    _raw_write_unlock(& dev_priv->resource_lock);
#line 1311
    goto ldv_40963;
  } else {

  }
#line 1315
  __mptr = (struct list_head  const  *)lru_list->next;
#line 1315
  evict_res = vmw_resource_reference((struct vmw_resource *)__mptr + 0xffffffffffffffc0UL);
#line 1317
  list_del_init(& evict_res->lru_head);
#line 1319
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1320
  vmw_resource_do_evict(evict_res);
#line 1321
  vmw_resource_unreference(& evict_res);
#line 1322
  goto ldv_40967;
  ldv_40963: 
#line 1324
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1324
  if (tmp___2 != 0L) {
#line 1325
    goto out_no_validate;
  } else
#line 1326
  if (! ((_Bool )(res->func)->needs_backup) && (unsigned long )res->backup != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 1327
    list_del_init(& res->mob_head);
#line 1328
    vmw_dmabuf_unreference(& res->backup);
  } else {

  }
#line 1331
  return (0);
  out_no_validate: ;
#line 1334
  return (ret);
}
}
#line 1349 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_fence_single_bo(struct ttm_buffer_object *bo , struct vmw_fence_obj *fence ) 
{ struct ttm_bo_device *bdev ;
  struct ttm_bo_driver *driver___0 ;
  struct vmw_fence_obj *old_fence_obj ;
  struct vmw_private *dev_priv ;
  struct ttm_bo_device  const  *__mptr ;

  {
#line 1352
  bdev = bo->bdev;
#line 1353
  driver___0 = bdev->driver;
#line 1356
  __mptr = (struct ttm_bo_device  const  *)bdev;
#line 1356
  dev_priv = (struct vmw_private *)__mptr;
#line 1358
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1359
    vmw_execbuf_fence_commands(0, dev_priv, & fence, 0);
  } else {
#line 1361
    (*(driver___0->sync_obj_ref))((void *)fence);
  }
#line 1363
  spin_lock(& bdev->fence_lock);
#line 1365
  old_fence_obj = (struct vmw_fence_obj *)bo->sync_obj;
#line 1366
  bo->sync_obj = (void *)fence;
#line 1368
  spin_unlock(& bdev->fence_lock);
#line 1370
  if ((unsigned long )old_fence_obj != (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1371
    vmw_fence_obj_unreference(& old_fence_obj);
  } else {

  }
#line 1372
  return;
}
}
#line 1383 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_move_notify(struct ttm_buffer_object *bo , struct ttm_mem_reg *mem ) 
{ 

  {
#line 1385
  return;
}
}
#line 1393 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
bool vmw_resource_needs_backup(struct vmw_resource  const  *res ) 
{ 

  {
#line 1395
  return ((bool )(res->func)->needs_backup);
}
}
#line 1407 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
static void vmw_resource_evict_type(struct vmw_private *dev_priv , enum vmw_res_type type ) 
{ struct list_head *lru_list ;
  struct vmw_resource *evict_res ;
  int tmp ;
  struct list_head  const  *__mptr ;

  {
#line 1410
  lru_list = (struct list_head *)(& dev_priv->res_lru) + (unsigned long )type;
  ldv_40995: 
#line 1414
  _raw_write_lock(& dev_priv->resource_lock);
#line 1416
  tmp = list_empty((struct list_head  const  *)lru_list);
#line 1416
  if (tmp != 0) {
#line 1417
    goto out_unlock;
  } else {

  }
#line 1420
  __mptr = (struct list_head  const  *)lru_list->next;
#line 1420
  evict_res = vmw_resource_reference((struct vmw_resource *)__mptr + 0xffffffffffffffc0UL);
#line 1422
  list_del_init(& evict_res->lru_head);
#line 1423
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1424
  vmw_resource_do_evict(evict_res);
#line 1425
  vmw_resource_unreference(& evict_res);
#line 1426
  goto ldv_40995;
  out_unlock: 
#line 1429
  _raw_write_unlock(& dev_priv->resource_lock);
#line 1430
  return;
}
}
#line 1442 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void vmw_resource_evict_all(struct vmw_private *dev_priv ) 
{ enum vmw_res_type type ;

  {
#line 1446
  ldv_mutex_lock_273(& dev_priv->cmdbuf_mutex);
#line 1448
  type = 0;
#line 1448
  goto ldv_41001;
  ldv_41000: 
#line 1449
  vmw_resource_evict_type(dev_priv, type);
#line 1448
  type = (enum vmw_res_type )((unsigned int )type + 1U);
  ldv_41001: ;
#line 1448
  if ((unsigned int )type <= 2U) {
#line 1449
    goto ldv_41000;
  } else {
#line 1451
    goto ldv_41002;
  }
  ldv_41002: 
#line 1451
  ldv_mutex_unlock_274(& dev_priv->cmdbuf_mutex);
#line 1452
  return;
}
}
#line 1454 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1459
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1461
  mutex_lock(ldv_func_arg1);
#line 1462
  return;
}
}
#line 1464 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_260(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1469
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1471
  mutex_unlock(ldv_func_arg1);
#line 1472
  return;
}
}
#line 1474 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_261(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1479
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1481
  mutex_lock(ldv_func_arg1);
#line 1482
  return;
}
}
#line 1484 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
int ldv_mutex_trylock_262(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1489
  tmp = mutex_trylock(ldv_func_arg1);
#line 1489
  ldv_func_res = tmp;
#line 1491
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1491
  return (tmp___0);
#line 1493
  return (ldv_func_res);
}
}
#line 1496 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1501
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1503
  mutex_unlock(ldv_func_arg1);
#line 1504
  return;
}
}
#line 1506 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1511
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1513
  mutex_lock(ldv_func_arg1);
#line 1514
  return;
}
}
#line 1516 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1521
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1523
  mutex_unlock(ldv_func_arg1);
#line 1524
  return;
}
}
#line 1526 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1531
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1533
  mutex_lock(ldv_func_arg1);
#line 1534
  return;
}
}
#line 1536 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1541
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1543
  mutex_unlock(ldv_func_arg1);
#line 1544
  return;
}
}
#line 1546 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_268(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1551
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 1553
  mutex_unlock(ldv_func_arg1);
#line 1554
  return;
}
}
#line 1556 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_269(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1561
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1563
  mutex_lock(ldv_func_arg1);
#line 1564
  return;
}
}
#line 1566 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_270(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1571
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1573
  mutex_unlock(ldv_func_arg1);
#line 1574
  return;
}
}
#line 1576 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_271(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1581
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1583
  mutex_lock(ldv_func_arg1);
#line 1584
  return;
}
}
#line 1586 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_272(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1591
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1593
  mutex_unlock(ldv_func_arg1);
#line 1594
  return;
}
}
#line 1596 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_lock_273(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1601
  ldv_mutex_lock_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 1603
  mutex_lock(ldv_func_arg1);
#line 1604
  return;
}
}
#line 1606 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c.prepared"
void ldv_mutex_unlock_274(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1611
  ldv_mutex_unlock_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 1613
  mutex_unlock(ldv_func_arg1);
#line 1614
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_294(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_292(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_295(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_297(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_299(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_300(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_302(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_304(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_291(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_293(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_296(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_298(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_301(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) ;
#line 599 "include/drm/ttm/ttm_bo_driver.h"
extern int ttm_tt_init(struct ttm_tt * , struct ttm_bo_device * , unsigned long  ,
                       uint32_t  , struct page * ) ;
#line 613
extern void ttm_tt_fini(struct ttm_tt * ) ;
#line 983
extern struct ttm_mem_type_manager_func  const  ttm_bo_manager_func ;
#line 73 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) ;
#line 77
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) ;
#line 84
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) ;
#line 566 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct ttm_placement vmw_vram_gmr_ne_placement ;
#line 567
struct ttm_placement vmw_sys_placement ;
#line 568
struct ttm_placement vmw_evictable_placement ;
#line 569
struct ttm_placement vmw_srf_placement ;
#line 724
struct ttm_mem_type_manager_func  const  vmw_gmrid_manager_func ;
#line 48 "include/drm/ttm/ttm_page_alloc.h"
extern int ttm_pool_populate(struct ttm_tt * ) ;
#line 57
extern void ttm_pool_unpopulate(struct ttm_tt * ) ;
#line 186 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_placement_flags  =    65540U;
#line 189 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_ne_placement_flags  =    2162692U;
#line 193 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t sys_placement_flags  =    65537U;
#line 196 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_placement_flags  =    65544U;
#line 199 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_ne_placement_flags  =    2162696U;
#line 203 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_placement_flags), 1U, (uint32_t const   *)(& vram_placement_flags)};
#line 212 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_gmr_placement_flags[2U]  = {      65540U,      65544U};
#line 217 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t gmr_vram_placement_flags[2U]  = {      65544U,      65540U};
#line 222 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_gmr_placement  =    {0U, 0U, 2U, (uint32_t const   *)(& vram_gmr_placement_flags), 1U, (uint32_t const   *)(& gmr_placement_flags)};
#line 231 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t vram_gmr_ne_placement_flags[2U]  = {      2162692U,      2162696U};
#line 236 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_gmr_ne_placement  =    {0U, 0U, 2U, (uint32_t const   *)(& vram_gmr_ne_placement_flags), 1U, (uint32_t const   *)(& gmr_ne_placement_flags)};
#line 245 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_sys_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 254 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_vram_ne_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& vram_ne_placement_flags), 1U, (uint32_t const   *)(& vram_ne_placement_flags)};
#line 263 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_sys_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& sys_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 272 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static uint32_t evictable_placement_flags[3U]  = {      65537U,      65540U,      65544U};
#line 278 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_evictable_placement  =    {0U, 0U, 3U, (uint32_t const   *)(& evictable_placement_flags), 1U, (uint32_t const   *)(& sys_placement_flags)};
#line 287 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement vmw_srf_placement  =    {0U, 0U, 1U, (uint32_t const   *)(& gmr_placement_flags), 2U, (uint32_t const   *)(& gmr_vram_placement_flags)};
#line 302 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_bind(struct ttm_tt *ttm , struct ttm_mem_reg *bo_mem ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;
  int tmp ;

  {
#line 304
  __mptr = (struct ttm_tt  const  *)ttm;
#line 304
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 306
  vmw_be->gmr_id = (int )bo_mem->start;
#line 308
  tmp = vmw_gmr_bind(vmw_be->dev_priv, ttm->pages, ttm->num_pages, vmw_be->gmr_id);
#line 308
  return (tmp);
}
}
#line 312 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_unbind(struct ttm_tt *ttm ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;

  {
#line 314
  __mptr = (struct ttm_tt  const  *)ttm;
#line 314
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 316
  vmw_gmr_unbind(vmw_be->dev_priv, vmw_be->gmr_id);
#line 317
  return (0);
}
}
#line 320 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_ttm_destroy(struct ttm_tt *ttm ) 
{ struct vmw_ttm_tt *vmw_be ;
  struct ttm_tt  const  *__mptr ;

  {
#line 322
  __mptr = (struct ttm_tt  const  *)ttm;
#line 322
  vmw_be = (struct vmw_ttm_tt *)__mptr;
#line 324
  ttm_tt_fini(ttm);
#line 325
  kfree((void const   *)vmw_be);
#line 326
  return;
}
}
#line 328 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static struct ttm_backend_func vmw_ttm_func  =    {& vmw_ttm_bind, & vmw_ttm_unbind, & vmw_ttm_destroy};
#line 334 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_tt *vmw_ttm_tt_create(struct ttm_bo_device *bdev , unsigned long size ,
                                 uint32_t page_flags , struct page *dummy_read_page ) 
{ struct vmw_ttm_tt *vmw_be ;
  void *tmp ;
  struct ttm_bo_device  const  *__mptr ;
  int tmp___0 ;

  {
#line 340
  tmp = kmalloc(96UL, 208U);
#line 340
  vmw_be = (struct vmw_ttm_tt *)tmp;
#line 341
  if ((unsigned long )vmw_be == (unsigned long )((struct vmw_ttm_tt *)0)) {
#line 342
    return (0);
  } else {

  }
#line 344
  vmw_be->ttm.func = & vmw_ttm_func;
#line 345
  __mptr = (struct ttm_bo_device  const  *)bdev;
#line 345
  vmw_be->dev_priv = (struct vmw_private *)__mptr;
#line 347
  tmp___0 = ttm_tt_init(& vmw_be->ttm, bdev, size, page_flags, dummy_read_page);
#line 347
  if (tmp___0 != 0) {
#line 348
    kfree((void const   *)vmw_be);
#line 349
    return (0);
  } else {

  }
#line 352
  return (& vmw_be->ttm);
}
}
#line 355 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int vmw_invalidate_caches(struct ttm_bo_device *bdev , uint32_t flags ) 
{ 

  {
#line 357
  return (0);
}
}
#line 360 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int vmw_init_mem_type(struct ttm_bo_device *bdev , uint32_t type , struct ttm_mem_type_manager *man ) 
{ 

  {
#line 363
  switch (type) {
  case 0: 
#line 367
  man->flags = 2U;
#line 368
  man->available_caching = 65536U;
#line 369
  man->default_caching = 65536U;
#line 370
  goto ldv_40657;
  case 2: 
#line 373
  man->func = & ttm_bo_manager_func;
#line 374
  man->gpu_offset = 0UL;
#line 375
  man->flags = 3U;
#line 376
  man->available_caching = 65536U;
#line 377
  man->default_caching = 65536U;
#line 378
  goto ldv_40657;
  case 3: 
#line 385
  man->func = & vmw_gmrid_manager_func;
#line 386
  man->gpu_offset = 0UL;
#line 387
  man->flags = 10U;
#line 388
  man->available_caching = 65536U;
#line 389
  man->default_caching = 65536U;
#line 390
  goto ldv_40657;
  default: 
#line 392
  drm_err("vmw_init_mem_type", "Unsupported memory type %u\n", type);
#line 393
  return (-22);
  }
  ldv_40657: ;
#line 395
  return (0);
}
}
#line 398 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void vmw_evict_flags(struct ttm_buffer_object *bo , struct ttm_placement *placement ) 
{ 

  {
#line 401
  *placement = vmw_sys_placement;
#line 402
  return;
}
}
#line 404 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_verify_access(struct ttm_buffer_object *bo , struct file *filp ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 406
  tmp = vmw_fpriv((struct drm_file *)filp->private_data);
#line 406
  tfile = tmp->tfile;
#line 409
  tmp___0 = vmw_user_dmabuf_verify_access(bo, tfile);
#line 409
  return (tmp___0);
}
}
#line 412 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_io_mem_reserve(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ struct ttm_mem_type_manager *man ;
  struct vmw_private *dev_priv ;
  struct ttm_bo_device  const  *__mptr ;

  {
#line 414
  man = (struct ttm_mem_type_manager *)(& bdev->man) + (unsigned long )mem->mem_type;
#line 415
  __mptr = (struct ttm_bo_device  const  *)bdev;
#line 415
  dev_priv = (struct vmw_private *)__mptr;
#line 417
  mem->bus.addr = 0;
#line 418
  mem->bus.is_iomem = 0;
#line 419
  mem->bus.offset = 0UL;
#line 420
  mem->bus.size = mem->num_pages << 12;
#line 421
  mem->bus.base = 0UL;
#line 422
  if ((man->flags & 2U) == 0U) {
#line 423
    return (-22);
  } else {

  }
#line 424
  switch (mem->mem_type) {
  case 0: ;
  case 3: ;
#line 427
  return (0);
  case 2: 
#line 429
  mem->bus.offset = mem->start << 12;
#line 430
  mem->bus.base = (unsigned long )dev_priv->vram_start;
#line 431
  mem->bus.is_iomem = 1;
#line 432
  goto ldv_40682;
  default: ;
#line 434
  return (-22);
  }
  ldv_40682: ;
#line 436
  return (0);
}
}
#line 439 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_ttm_io_mem_free(struct ttm_bo_device *bdev , struct ttm_mem_reg *mem ) 
{ 

  {
#line 441
  return;
}
}
#line 443 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_ttm_fault_reserve_notify(struct ttm_buffer_object *bo ) 
{ 

  {
#line 445
  return (0);
}
}
#line 453 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void *vmw_sync_obj_ref(void *sync_obj ) 
{ struct vmw_fence_obj *tmp ;

  {
#line 456
  tmp = vmw_fence_obj_reference((struct vmw_fence_obj *)sync_obj);
#line 456
  return ((void *)tmp);
}
}
#line 460 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static void vmw_sync_obj_unref(void **sync_obj ) 
{ 

  {
#line 462
  vmw_fence_obj_unreference((struct vmw_fence_obj **)sync_obj);
#line 463
  return;
}
}
#line 465 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_sync_obj_flush(void *sync_obj ) 
{ 

  {
#line 467
  vmw_fence_obj_flush((struct vmw_fence_obj *)sync_obj);
#line 468
  return (0);
}
}
#line 471 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static bool vmw_sync_obj_signaled(void *sync_obj ) 
{ bool tmp ;

  {
#line 473
  tmp = vmw_fence_obj_signaled((struct vmw_fence_obj *)sync_obj, 1U);
#line 473
  return (tmp);
}
}
#line 478 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
static int vmw_sync_obj_wait(void *sync_obj , bool lazy , bool interruptible ) 
{ int tmp ;

  {
#line 480
  tmp = vmw_fence_obj_wait((struct vmw_fence_obj *)sync_obj, 1U, (int )lazy, (int )interruptible,
                           1250UL);
#line 480
  return (tmp);
}
}
#line 486 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_bo_driver vmw_bo_driver  = 
#line 486
     {& vmw_ttm_tt_create, & ttm_pool_populate, & ttm_pool_unpopulate, & vmw_invalidate_caches,
    & vmw_init_mem_type, & vmw_evict_flags, 0, & vmw_verify_access, & vmw_sync_obj_signaled,
    & vmw_sync_obj_wait, & vmw_sync_obj_flush, & vmw_sync_obj_unref, & vmw_sync_obj_ref,
    0, & vmw_ttm_fault_reserve_notify, 0, & vmw_ttm_io_mem_reserve, & vmw_ttm_io_mem_free};
#line 506 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void **ldvarg11  ;
#line 507 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
uint32_t ldvarg7  ;
#line 508 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
unsigned long ldvarg3  ;
#line 509 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_placement *ldvarg12  ;
#line 510 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void *ldvarg8  ;
#line 511 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct page *ldvarg1  ;
#line 512 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void *ldvarg13  ;
#line 513 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
bool ldvarg10  ;
#line 514 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
bool ldvarg9  ;
#line 515 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_mem_reg *ldvarg81  ;
#line 516 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_buffer_object *vmw_bo_driver_group2  ;
#line 517 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_tt *vmw_ttm_func_group0  ;
#line 518 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void *ldvarg0  ;
#line 519 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_mem_reg *vmw_bo_driver_group1  ;
#line 520 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_tt *vmw_bo_driver_group3  ;
#line 521 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
uint32_t ldvarg5  ;
#line 522 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_mem_type_manager *ldvarg6  ;
#line 523 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void *ldvarg14  ;
#line 524 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct file *ldvarg4  ;
#line 525 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
uint32_t ldvarg2  ;
#line 526 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
struct ttm_bo_device *vmw_bo_driver_group0  ;
#line 528 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_main_exported_11(void) 
{ int tmp ;

  {
#line 530
  tmp = __VERIFIER_nondet_int();
#line 530
  switch (tmp) {
  case 0: ;
#line 533
  if (ldv_state_variable_11 == 1) {
#line 535
    ttm_pool_populate(vmw_bo_driver_group3);
#line 537
    ldv_state_variable_11 = 1;
  } else {

  }
#line 540
  goto ldv_40734;
  case 1: ;
#line 543
  if (ldv_state_variable_11 == 1) {
#line 545
    ttm_pool_unpopulate(vmw_bo_driver_group3);
#line 547
    ldv_state_variable_11 = 1;
  } else {

  }
#line 550
  goto ldv_40734;
  case 2: ;
#line 553
  if (ldv_state_variable_11 == 1) {
#line 555
    vmw_sync_obj_signaled(ldvarg14);
#line 557
    ldv_state_variable_11 = 1;
  } else {

  }
#line 560
  goto ldv_40734;
  case 3: ;
#line 563
  if (ldv_state_variable_11 == 1) {
#line 565
    vmw_sync_obj_ref(ldvarg13);
#line 567
    ldv_state_variable_11 = 1;
  } else {

  }
#line 570
  goto ldv_40734;
  case 4: ;
#line 573
  if (ldv_state_variable_11 == 1) {
#line 575
    vmw_evict_flags(vmw_bo_driver_group2, ldvarg12);
#line 577
    ldv_state_variable_11 = 1;
  } else {

  }
#line 580
  goto ldv_40734;
  case 5: ;
#line 583
  if (ldv_state_variable_11 == 1) {
#line 585
    vmw_ttm_io_mem_reserve(vmw_bo_driver_group0, vmw_bo_driver_group1);
#line 587
    ldv_state_variable_11 = 1;
  } else {

  }
#line 590
  goto ldv_40734;
  case 6: ;
#line 593
  if (ldv_state_variable_11 == 1) {
#line 595
    vmw_sync_obj_unref(ldvarg11);
#line 597
    ldv_state_variable_11 = 1;
  } else {

  }
#line 600
  goto ldv_40734;
  case 7: ;
#line 603
  if (ldv_state_variable_11 == 1) {
#line 605
    vmw_sync_obj_wait(ldvarg8, (int )ldvarg10, (int )ldvarg9);
#line 607
    ldv_state_variable_11 = 1;
  } else {

  }
#line 610
  goto ldv_40734;
  case 8: ;
#line 613
  if (ldv_state_variable_11 == 1) {
#line 615
    vmw_init_mem_type(vmw_bo_driver_group0, ldvarg7, ldvarg6);
#line 617
    ldv_state_variable_11 = 1;
  } else {

  }
#line 620
  goto ldv_40734;
  case 9: ;
#line 623
  if (ldv_state_variable_11 == 1) {
#line 625
    vmw_ttm_fault_reserve_notify(vmw_bo_driver_group2);
#line 627
    ldv_state_variable_11 = 1;
  } else {

  }
#line 630
  goto ldv_40734;
  case 10: ;
#line 633
  if (ldv_state_variable_11 == 1) {
#line 635
    vmw_invalidate_caches(vmw_bo_driver_group0, ldvarg5);
#line 637
    ldv_state_variable_11 = 1;
  } else {

  }
#line 640
  goto ldv_40734;
  case 11: ;
#line 643
  if (ldv_state_variable_11 == 1) {
#line 645
    vmw_verify_access(vmw_bo_driver_group2, ldvarg4);
#line 647
    ldv_state_variable_11 = 1;
  } else {

  }
#line 650
  goto ldv_40734;
  case 12: ;
#line 653
  if (ldv_state_variable_11 == 1) {
#line 655
    vmw_ttm_tt_create(vmw_bo_driver_group0, ldvarg3, ldvarg2, ldvarg1);
#line 657
    ldv_state_variable_11 = 1;
  } else {

  }
#line 660
  goto ldv_40734;
  case 13: ;
#line 663
  if (ldv_state_variable_11 == 1) {
#line 665
    vmw_ttm_io_mem_free(vmw_bo_driver_group0, vmw_bo_driver_group1);
#line 667
    ldv_state_variable_11 = 1;
  } else {

  }
#line 670
  goto ldv_40734;
  case 14: ;
#line 673
  if (ldv_state_variable_11 == 1) {
#line 675
    vmw_sync_obj_flush(ldvarg0);
#line 677
    ldv_state_variable_11 = 1;
  } else {

  }
#line 680
  goto ldv_40734;
  default: ;
#line 681
  goto ldv_40734;
  }
  ldv_40734: ;
#line 685
  return;
}
}
#line 687 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_main_exported_12(void) 
{ int tmp ;

  {
#line 689
  tmp = __VERIFIER_nondet_int();
#line 689
  switch (tmp) {
  case 0: ;
#line 692
  if (ldv_state_variable_12 == 1) {
#line 694
    vmw_ttm_unbind(vmw_ttm_func_group0);
#line 696
    ldv_state_variable_12 = 1;
  } else {

  }
#line 699
  goto ldv_40754;
  case 1: ;
#line 702
  if (ldv_state_variable_12 == 1) {
#line 704
    vmw_ttm_bind(vmw_ttm_func_group0, ldvarg81);
#line 706
    ldv_state_variable_12 = 1;
  } else {

  }
#line 709
  goto ldv_40754;
  case 2: ;
#line 712
  if (ldv_state_variable_12 == 1) {
#line 714
    vmw_ttm_destroy(vmw_ttm_func_group0);
#line 716
    ldv_state_variable_12 = 1;
  } else {

  }
#line 719
  goto ldv_40754;
  default: ;
#line 720
  goto ldv_40754;
  }
  ldv_40754: ;
#line 724
  return;
}
}
#line 725 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_291(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 730
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 732
  mutex_lock(ldv_func_arg1);
#line 733
  return;
}
}
#line 735 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_292(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 740
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 742
  mutex_unlock(ldv_func_arg1);
#line 743
  return;
}
}
#line 745 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_293(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 750
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 752
  mutex_lock(ldv_func_arg1);
#line 753
  return;
}
}
#line 755 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
int ldv_mutex_trylock_294(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 760
  tmp = mutex_trylock(ldv_func_arg1);
#line 760
  ldv_func_res = tmp;
#line 762
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 762
  return (tmp___0);
#line 764
  return (ldv_func_res);
}
}
#line 767 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_295(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 772
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 774
  mutex_unlock(ldv_func_arg1);
#line 775
  return;
}
}
#line 777 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_296(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 782
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 784
  mutex_lock(ldv_func_arg1);
#line 785
  return;
}
}
#line 787 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_297(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 792
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 794
  mutex_unlock(ldv_func_arg1);
#line 795
  return;
}
}
#line 797 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_298(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 802
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 804
  mutex_lock(ldv_func_arg1);
#line 805
  return;
}
}
#line 807 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_299(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 812
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 814
  mutex_unlock(ldv_func_arg1);
#line 815
  return;
}
}
#line 817 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_300(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 822
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 824
  mutex_unlock(ldv_func_arg1);
#line 825
  return;
}
}
#line 827 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_301(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 832
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 834
  mutex_lock(ldv_func_arg1);
#line 835
  return;
}
}
#line 837 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_302(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 842
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 844
  mutex_unlock(ldv_func_arg1);
#line 845
  return;
}
}
#line 847 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 852
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 854
  mutex_lock(ldv_func_arg1);
#line 855
  return;
}
}
#line 857 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_buffer.c.prepared"
void ldv_mutex_unlock_304(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 862
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 864
  mutex_unlock(ldv_func_arg1);
#line 865
  return;
}
}
#line 324 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
#line 328
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 333
  return (oldbit);
}
}
#line 10 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 2: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 4: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 8: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2861: ;
#line 14
  return (pfo_ret__);
}
}
#line 15 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 119 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
#line 123
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0; sete %1": "+m" (v->counter),
                       "=qm" (c): : "memory");
#line 126
  return ((unsigned int )c != 0U);
}
}
#line 173 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ int __ret ;

  {
#line 175
  __ret = i;
#line 175
  switch (4UL) {
  case 1: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 2: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 4: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 8: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  default: 
#line 175
  __xadd_wrong_size();
  }
  ldv_5474: ;
#line 175
  return (__ret + i);
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_322(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_320(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_323(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_325(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_327(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_328(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_330(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_332(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_334(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_336(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_338(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_340(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_342(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_344(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_345(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_319(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_321(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_324(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_326(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_329(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_331(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_333(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_335(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_337(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_339(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_341(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_343(struct mutex *ldv_func_arg1 ) ;
#line 83
void ldv_mutex_lock_fifo_mutex_of_vmw_fifo_state(struct mutex *lock ) ;
#line 87
void ldv_mutex_unlock_fifo_mutex_of_vmw_fifo_state(struct mutex *lock ) ;
#line 91 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
#line 93
  tmp = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
#line 93
  return (tmp);
}
}
#line 139 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 732
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 734
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 737
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 67 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 90
extern void down_write(struct rw_semaphore * ) ;
#line 105
extern void up_write(struct rw_semaphore * ) ;
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 215 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , size_t count ) 
{ size_t __len ;
  void *__ret ;

  {
#line 217
  __len = count;
#line 217
  __ret = __builtin_memcpy((void *)dst, src, __len);
#line 219
  return;
}
}
#line 330 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 2592 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
#line 2594
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2594
  return (tmp);
}
}
#line 2618 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ int tmp ;
  long tmp___0 ;

  {
#line 2620
  tmp = test_tsk_thread_flag(p, 2);
#line 2620
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2620
  return ((int )tmp___0);
}
}
#line 635 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) ;
#line 636
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) ;
#line 637
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) ;
#line 184 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
bool vmw_fifo_have_3d(struct vmw_private *dev_priv ) 
{ __le32 *fifo_mem ;
  uint32_t fifo_min ;
  uint32_t hwversion ;
  struct vmw_fifo_state  const  *fifo ;
  unsigned long tmp ;

  {
#line 186
  fifo_mem = dev_priv->mmio_virt;
#line 188
  fifo = (struct vmw_fifo_state  const  *)(& dev_priv->fifo);
#line 190
  if ((dev_priv->capabilities & 32768U) == 0U) {
#line 191
    return (0);
  } else {

  }
#line 193
  fifo_min = ioread32((void *)fifo_mem);
#line 194
  if (fifo_min <= 28U) {
#line 195
    return (0);
  } else {

  }
#line 197
  if (((unsigned int )fifo->capabilities & 256U) != 0U) {
#line 197
    tmp = 17UL;
  } else {
#line 197
    tmp = 7UL;
  }
#line 197
  hwversion = ioread32((void *)(fifo_mem + tmp));
#line 203
  if (hwversion == 0U) {
#line 204
    return (0);
  } else {

  }
#line 206
  if (hwversion <= 131072U) {
#line 207
    return (0);
  } else {

  }
#line 210
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 211
    return (0);
  } else {

  }
#line 213
  return (1);
}
}
#line 216 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
bool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv ) 
{ __le32 *fifo_mem ;
  uint32_t caps ;

  {
#line 218
  fifo_mem = dev_priv->mmio_virt;
#line 221
  if ((dev_priv->capabilities & 32768U) == 0U) {
#line 222
    return (0);
  } else {

  }
#line 224
  caps = ioread32((void *)fifo_mem + 4U);
#line 225
  if ((caps & 4U) != 0U) {
#line 226
    return (1);
  } else {

  }
#line 228
  return (0);
}
}
#line 231 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_init(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t dummy ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;

  {
#line 233
  fifo_mem = dev_priv->mmio_virt;
#line 238
  fifo->static_buffer_size = 1048576UL;
#line 239
  tmp = vmalloc(fifo->static_buffer_size);
#line 239
  fifo->static_buffer = (__le32 *)tmp;
#line 240
  tmp___0 = ldv__builtin_expect((unsigned long )fifo->static_buffer == (unsigned long )((__le32 *)0),
                             0L);
#line 240
  if (tmp___0 != 0L) {
#line 241
    return (-12);
  } else {

  }
#line 243
  fifo->dynamic_buffer = 0;
#line 244
  fifo->reserved_size = 0UL;
#line 245
  fifo->using_bounce_buffer = 0;
#line 247
  __mutex_init(& fifo->fifo_mutex, "&fifo->fifo_mutex", & __key);
#line 248
  __init_rwsem(& fifo->rwsem, "&fifo->rwsem", & __key___0);
#line 254
  tmp___1 = vmw_read(dev_priv, 2U);
#line 254
  printk("\016[drm] width %d\n", tmp___1);
#line 255
  tmp___2 = vmw_read(dev_priv, 3U);
#line 255
  printk("\016[drm] height %d\n", tmp___2);
#line 256
  tmp___3 = vmw_read(dev_priv, 7U);
#line 256
  printk("\016[drm] bpp %d\n", tmp___3);
#line 258
  ldv_mutex_lock_333(& dev_priv->hw_mutex);
#line 259
  dev_priv->enable_state = vmw_read(dev_priv, 1U);
#line 260
  dev_priv->config_done_state = vmw_read(dev_priv, 20U);
#line 261
  dev_priv->traces_state = vmw_read(dev_priv, 45U);
#line 262
  vmw_write(dev_priv, 1U, 1U);
#line 264
  min = 4U;
#line 265
  if ((dev_priv->capabilities & 32768U) != 0U) {
#line 266
    min = vmw_read(dev_priv, 30U);
  } else {

  }
#line 267
  min = min << 2;
#line 269
  if (min <= 4095U) {
#line 270
    min = 4096U;
  } else {

  }
#line 272
  iowrite32(min, (void *)fifo_mem);
#line 273
  iowrite32(dev_priv->mmio_size, (void *)fifo_mem + 1U);
#line 274
  __asm__  volatile   ("sfence": : : "memory");
#line 275
  iowrite32(min, (void *)fifo_mem + 2U);
#line 276
  iowrite32(min, (void *)fifo_mem + 3U);
#line 277
  iowrite32(0U, (void *)fifo_mem + 290U);
#line 278
  __asm__  volatile   ("mfence": : : "memory");
#line 280
  vmw_write(dev_priv, 20U, 1U);
#line 281
  ldv_mutex_unlock_334(& dev_priv->hw_mutex);
#line 283
  max = ioread32((void *)fifo_mem + 1U);
#line 284
  min = ioread32((void *)fifo_mem);
#line 285
  fifo->capabilities = ioread32((void *)fifo_mem + 4U);
#line 287
  printk("\016[drm] Fifo max 0x%08x min 0x%08x cap 0x%08x\n", max, min, fifo->capabilities);
#line 292
  atomic_set(& dev_priv->marker_seq, (int )dev_priv->last_read_seqno);
#line 293
  iowrite32(dev_priv->last_read_seqno, (void *)fifo_mem + 6U);
#line 294
  vmw_marker_queue_init(& fifo->marker_queue);
#line 295
  tmp___4 = vmw_fifo_send_fence(dev_priv, & dummy);
#line 295
  return (tmp___4);
}
}
#line 298 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_ping_host(struct vmw_private *dev_priv , uint32_t reason ) 
{ __le32 *fifo_mem ;
  unsigned int tmp ;
  long tmp___0 ;

  {
#line 300
  fifo_mem = dev_priv->mmio_virt;
#line 302
  ldv_mutex_lock_335(& dev_priv->hw_mutex);
#line 304
  tmp = ioread32((void *)fifo_mem + 290U);
#line 304
  tmp___0 = ldv__builtin_expect(tmp == 0U, 0L);
#line 304
  if (tmp___0 != 0L) {
#line 305
    iowrite32(1U, (void *)fifo_mem + 290U);
#line 306
    vmw_write(dev_priv, 21U, reason);
  } else {

  }
#line 309
  ldv_mutex_unlock_336(& dev_priv->hw_mutex);
#line 310
  return;
}
}
#line 312 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_release(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo ) 
{ __le32 *fifo_mem ;
  uint32_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 314
  fifo_mem = dev_priv->mmio_virt;
#line 316
  ldv_mutex_lock_337(& dev_priv->hw_mutex);
#line 318
  goto ldv_40656;
  ldv_40655: 
#line 319
  vmw_write(dev_priv, 21U, 1U);
  ldv_40656: 
#line 318
  tmp = vmw_read(dev_priv, 22U);
#line 318
  if (tmp != 0U) {
#line 319
    goto ldv_40655;
  } else {
#line 321
    goto ldv_40657;
  }
  ldv_40657: 
#line 321
  dev_priv->last_read_seqno = ioread32((void *)fifo_mem + 6U);
#line 323
  vmw_write(dev_priv, 20U, dev_priv->config_done_state);
#line 325
  vmw_write(dev_priv, 1U, dev_priv->enable_state);
#line 327
  vmw_write(dev_priv, 45U, dev_priv->traces_state);
#line 330
  ldv_mutex_unlock_338(& dev_priv->hw_mutex);
#line 331
  vmw_marker_queue_takedown(& fifo->marker_queue);
#line 333
  tmp___0 = ldv__builtin_expect((unsigned long )fifo->static_buffer != (unsigned long )((__le32 *)0),
                             1L);
#line 333
  if (tmp___0 != 0L) {
#line 334
    vfree((void const   *)fifo->static_buffer);
#line 335
    fifo->static_buffer = 0;
  } else {

  }
#line 338
  tmp___1 = ldv__builtin_expect((unsigned long )fifo->dynamic_buffer != (unsigned long )((__le32 *)0),
                             1L);
#line 338
  if (tmp___1 != 0L) {
#line 339
    vfree((void const   *)fifo->dynamic_buffer);
#line 340
    fifo->dynamic_buffer = 0;
  } else {

  }
#line 342
  return;
}
}
#line 344 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static bool vmw_fifo_is_full(struct vmw_private *dev_priv , uint32_t bytes ) 
{ __le32 *fifo_mem ;
  uint32_t max ;
  unsigned int tmp ;
  uint32_t next_cmd ;
  unsigned int tmp___0 ;
  uint32_t min ;
  unsigned int tmp___1 ;
  uint32_t stop ;
  unsigned int tmp___2 ;

  {
#line 346
  fifo_mem = dev_priv->mmio_virt;
#line 347
  tmp = ioread32((void *)fifo_mem + 1U);
#line 347
  max = tmp;
#line 348
  tmp___0 = ioread32((void *)fifo_mem + 2U);
#line 348
  next_cmd = tmp___0;
#line 349
  tmp___1 = ioread32((void *)fifo_mem);
#line 349
  min = tmp___1;
#line 350
  tmp___2 = ioread32((void *)fifo_mem + 3U);
#line 350
  stop = tmp___2;
#line 352
  return ((max - next_cmd) + (stop - min) <= bytes);
}
}
#line 355 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static int vmw_fifo_wait_noirq(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                               unsigned long timeout ) 
{ int ret ;
  unsigned long end_jiffies ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;

  {
#line 359
  ret = 0;
#line 360
  end_jiffies = (unsigned long )jiffies + timeout;
#line 361
  tmp = get_current();
#line 361
  __wait.flags = 0U;
#line 361
  __wait.private = (void *)tmp;
#line 361
  __wait.func = & autoremove_wake_function;
#line 361
  __wait.task_list.next = & __wait.task_list;
#line 361
  __wait.task_list.prev = & __wait.task_list;
#line 363
  printk("\016[drm] Fifo wait noirq.\n");
  ldv_40684: ;
#line 366
  if ((int )interruptible) {
#line 366
    tmp___0 = 1;
  } else {
#line 366
    tmp___0 = 2;
  }
#line 366
  prepare_to_wait(& dev_priv->fifo_queue, & __wait, tmp___0);
#line 369
  tmp___1 = vmw_fifo_is_full(dev_priv, bytes);
#line 369
  if (tmp___1) {
#line 369
    tmp___2 = 0;
  } else {
#line 369
    tmp___2 = 1;
  }
#line 369
  if (tmp___2) {
#line 370
    goto ldv_40676;
  } else {

  }
#line 371
  if ((long )jiffies - (long )end_jiffies >= 0L) {
#line 372
    ret = -16;
#line 373
    drm_err("vmw_fifo_wait_noirq", "SVGA device lockup.\n");
#line 374
    goto ldv_40676;
  } else {

  }
#line 376
  schedule_timeout(1L);
#line 377
  if ((int )interruptible) {
#line 377
    tmp___3 = get_current();
#line 377
    tmp___4 = signal_pending(tmp___3);
#line 377
    if (tmp___4 != 0) {
#line 378
      ret = -512;
#line 379
      goto ldv_40676;
    } else {

    }
  } else {

  }
#line 381
  goto ldv_40684;
  ldv_40676: 
#line 382
  finish_wait(& dev_priv->fifo_queue, & __wait);
#line 383
  __wake_up(& dev_priv->fifo_queue, 3U, 0, 0);
#line 384
  printk("\016[drm] Fifo noirq exit.\n");
#line 385
  return (ret);
}
}
#line 388 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static int vmw_fifo_wait(struct vmw_private *dev_priv , uint32_t bytes , bool interruptible ,
                         unsigned long timeout ) 
{ long ret ;
  unsigned long irq_flags ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  raw_spinlock_t *tmp___3 ;
  int tmp___4 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  struct task_struct *tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  raw_spinlock_t *tmp___17 ;
  int tmp___18 ;

  {
#line 392
  ret = 1L;
#line 395
  tmp = vmw_fifo_is_full(dev_priv, bytes);
#line 395
  if (tmp) {
#line 395
    tmp___0 = 0;
  } else {
#line 395
    tmp___0 = 1;
  }
#line 395
  tmp___1 = ldv__builtin_expect((long )tmp___0, 1L);
#line 395
  if (tmp___1 != 0L) {
#line 396
    return (0);
  } else {

  }
#line 398
  vmw_fifo_ping_host(dev_priv, 2U);
#line 399
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 400
    tmp___2 = vmw_fifo_wait_noirq(dev_priv, bytes, (int )interruptible, timeout);
#line 400
    return (tmp___2);
  } else {

  }
#line 403
  ldv_mutex_lock_339(& dev_priv->hw_mutex);
#line 404
  tmp___4 = atomic_add_return(1, & dev_priv->fifo_queue_waiters);
#line 404
  if (tmp___4 > 0) {
#line 405
    tmp___3 = spinlock_check(& dev_priv->irq_lock);
#line 405
    irq_flags = _raw_spin_lock_irqsave(tmp___3);
#line 406
    outl(2U, (int )(dev_priv->io_start + 8U));
#line 408
    dev_priv->irq_mask = dev_priv->irq_mask | 2U;
#line 409
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 410
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 412
  ldv_mutex_unlock_340(& dev_priv->hw_mutex);
#line 414
  if ((int )interruptible) {
#line 415
    __ret = (long )timeout;
#line 415
    tmp___10 = vmw_fifo_is_full(dev_priv, bytes);
#line 415
    if ((int )tmp___10) {
#line 415
      tmp___5 = get_current();
#line 415
      __wait.flags = 0U;
#line 415
      __wait.private = (void *)tmp___5;
#line 415
      __wait.func = & autoremove_wake_function;
#line 415
      __wait.task_list.next = & __wait.task_list;
#line 415
      __wait.task_list.prev = & __wait.task_list;
      ldv_40700: 
#line 415
      prepare_to_wait(& dev_priv->fifo_queue, & __wait, 1);
#line 415
      tmp___6 = vmw_fifo_is_full(dev_priv, bytes);
#line 415
      if (tmp___6) {
#line 415
        tmp___7 = 0;
      } else {
#line 415
        tmp___7 = 1;
      }
#line 415
      if (tmp___7) {
#line 415
        goto ldv_40698;
      } else {

      }
#line 415
      tmp___8 = get_current();
#line 415
      tmp___9 = signal_pending(tmp___8);
#line 415
      if (tmp___9 == 0) {
#line 415
        __ret = schedule_timeout(__ret);
#line 415
        if (__ret == 0L) {
#line 415
          goto ldv_40698;
        } else {

        }
#line 415
        goto ldv_40699;
      } else {

      }
#line 415
      __ret = -512L;
#line 415
      goto ldv_40698;
      ldv_40699: ;
#line 415
      goto ldv_40700;
      ldv_40698: 
#line 415
      finish_wait(& dev_priv->fifo_queue, & __wait);
    } else {

    }
#line 415
    ret = __ret;
  } else {
#line 419
    __ret___0 = (long )timeout;
#line 419
    tmp___14 = vmw_fifo_is_full(dev_priv, bytes);
#line 419
    if ((int )tmp___14) {
#line 419
      tmp___11 = get_current();
#line 419
      __wait___0.flags = 0U;
#line 419
      __wait___0.private = (void *)tmp___11;
#line 419
      __wait___0.func = & autoremove_wake_function;
#line 419
      __wait___0.task_list.next = & __wait___0.task_list;
#line 419
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_40705: 
#line 419
      prepare_to_wait(& dev_priv->fifo_queue, & __wait___0, 2);
#line 419
      tmp___12 = vmw_fifo_is_full(dev_priv, bytes);
#line 419
      if (tmp___12) {
#line 419
        tmp___13 = 0;
      } else {
#line 419
        tmp___13 = 1;
      }
#line 419
      if (tmp___13) {
#line 419
        goto ldv_40704;
      } else {

      }
#line 419
      __ret___0 = schedule_timeout(__ret___0);
#line 419
      if (__ret___0 == 0L) {
#line 419
        goto ldv_40704;
      } else {

      }
#line 419
      goto ldv_40705;
      ldv_40704: 
#line 419
      finish_wait(& dev_priv->fifo_queue, & __wait___0);
    } else {

    }
#line 419
    ret = __ret___0;
  }
#line 423
  tmp___16 = ldv__builtin_expect(ret == 0L, 0L);
#line 423
  if (tmp___16 != 0L) {
#line 424
    ret = -16L;
  } else {
#line 425
    tmp___15 = ldv__builtin_expect(ret > 0L, 1L);
#line 425
    if (tmp___15 != 0L) {
#line 426
      ret = 0L;
    } else {

    }
  }
#line 428
  ldv_mutex_lock_341(& dev_priv->hw_mutex);
#line 429
  tmp___18 = atomic_dec_and_test(& dev_priv->fifo_queue_waiters);
#line 429
  if (tmp___18 != 0) {
#line 430
    tmp___17 = spinlock_check(& dev_priv->irq_lock);
#line 430
    irq_flags = _raw_spin_lock_irqsave(tmp___17);
#line 431
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967293U;
#line 432
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 433
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 435
  ldv_mutex_unlock_342(& dev_priv->hw_mutex);
#line 437
  return ((int )ret);
}
}
#line 450 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void *vmw_fifo_reserve(struct vmw_private *dev_priv , uint32_t bytes ) 
{ struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t max ;
  uint32_t min ;
  uint32_t next_cmd ;
  uint32_t reserveable ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  uint32_t stop ;
  unsigned int tmp___2 ;
  bool need_bounce ;
  bool reserve_in_place ;
  long tmp___3 ;
  bool tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;

  {
#line 452
  fifo_state = & dev_priv->fifo;
#line 453
  fifo_mem = dev_priv->mmio_virt;
#line 457
  reserveable = fifo_state->capabilities & 64U;
#line 460
  ldv_mutex_lock_343(& fifo_state->fifo_mutex);
#line 461
  max = ioread32((void *)fifo_mem + 1U);
#line 462
  min = ioread32((void *)fifo_mem);
#line 463
  next_cmd = ioread32((void *)fifo_mem + 2U);
#line 465
  tmp = ldv__builtin_expect(max - min <= bytes, 0L);
#line 465
  if (tmp != 0L) {
#line 466
    goto out_err;
  } else {

  }
#line 468
  tmp___0 = ldv__builtin_expect(fifo_state->reserved_size != 0UL, 0L);
#line 468
  if (tmp___0 != 0L) {
#line 468
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (468), "i" (12UL));
    ldv_40722: ;
#line 468
    goto ldv_40722;
  } else {

  }
#line 469
  tmp___1 = ldv__builtin_expect((unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0),
                             0L);
#line 469
  if (tmp___1 != 0L) {
#line 469
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (469), "i" (12UL));
    ldv_40723: ;
#line 469
    goto ldv_40723;
  } else {

  }
#line 471
  fifo_state->reserved_size = (unsigned long )bytes;
  ldv_40727: 
#line 474
  tmp___2 = ioread32((void *)fifo_mem + 3U);
#line 474
  stop = tmp___2;
#line 475
  need_bounce = 0;
#line 476
  reserve_in_place = 0;
#line 478
  if (next_cmd >= stop) {
#line 479
    tmp___5 = ldv__builtin_expect(next_cmd + bytes < max, 1L);
#line 479
    if (tmp___5 != 0L) {
#line 481
      reserve_in_place = 1;
    } else {
#line 479
      tmp___6 = ldv__builtin_expect(next_cmd + bytes == max, 1L);
#line 479
      if (tmp___6 != 0L) {
#line 479
        tmp___7 = ldv__builtin_expect(stop > min, 1L);
#line 479
        if (tmp___7 != 0L) {
#line 479
          tmp___8 = 1;
        } else {
#line 479
          tmp___8 = 0;
        }
      } else {
#line 479
        tmp___8 = 0;
      }
#line 479
      if (tmp___8 != 0) {
#line 481
        reserve_in_place = 1;
      } else {
#line 483
        tmp___4 = vmw_fifo_is_full(dev_priv, bytes);
#line 483
        if ((int )tmp___4) {
#line 484
          ret = vmw_fifo_wait(dev_priv, bytes, 0, 750UL);
#line 486
          tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 486
          if (tmp___3 != 0L) {
#line 487
            goto out_err;
          } else {

          }
        } else {
#line 489
          need_bounce = 1;
        }
      }
    }
  } else {
#line 493
    tmp___10 = ldv__builtin_expect(next_cmd + bytes < stop, 1L);
#line 493
    if (tmp___10 != 0L) {
#line 494
      reserve_in_place = 1;
    } else {
#line 496
      ret = vmw_fifo_wait(dev_priv, bytes, 0, 750UL);
#line 498
      tmp___9 = ldv__builtin_expect(ret != 0, 0L);
#line 498
      if (tmp___9 != 0L) {
#line 499
        goto out_err;
      } else {

      }
    }
  }
#line 503
  if ((int )reserve_in_place) {
#line 504
    if (reserveable != 0U || bytes <= 4U) {
#line 505
      fifo_state->using_bounce_buffer = 0;
#line 507
      if (reserveable != 0U) {
#line 508
        iowrite32(bytes, (void *)fifo_mem + 14U);
      } else {

      }
#line 510
      return ((void *)fifo_mem + (unsigned long )(next_cmd >> 2));
    } else {
#line 512
      need_bounce = 1;
    }
  } else {

  }
#line 516
  if ((int )need_bounce) {
#line 517
    fifo_state->using_bounce_buffer = 1;
#line 518
    if ((unsigned long )bytes < fifo_state->static_buffer_size) {
#line 519
      return ((void *)fifo_state->static_buffer);
    } else {
#line 521
      tmp___11 = vmalloc((unsigned long )bytes);
#line 521
      fifo_state->dynamic_buffer = (__le32 *)tmp___11;
#line 522
      return ((void *)fifo_state->dynamic_buffer);
    }
  } else {

  }
#line 525
  goto ldv_40727;
  out_err: 
#line 527
  fifo_state->reserved_size = 0UL;
#line 528
  ldv_mutex_unlock_344(& fifo_state->fifo_mutex);
#line 529
  return (0);
}
}
#line 532 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static void vmw_fifo_res_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                              uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ uint32_t chunk_size ;
  uint32_t rest ;
  uint32_t *buffer ;
  __le32 *tmp ;

  {
#line 537
  chunk_size = max - next_cmd;
#line 539
  if ((unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0)) {
#line 539
    tmp = fifo_state->dynamic_buffer;
  } else {
#line 539
    tmp = fifo_state->static_buffer;
  }
#line 539
  buffer = tmp;
#line 542
  if (bytes < chunk_size) {
#line 543
    chunk_size = bytes;
  } else {

  }
#line 545
  iowrite32(bytes, (void *)fifo_mem + 14U);
#line 546
  __asm__  volatile   ("mfence": : : "memory");
#line 547
  memcpy_toio((void volatile   *)fifo_mem + (unsigned long )(next_cmd >> 2), (void const   *)buffer,
              (size_t )chunk_size);
#line 548
  rest = bytes - chunk_size;
#line 549
  if (rest != 0U) {
#line 550
    memcpy_toio((void volatile   *)fifo_mem + (unsigned long )(min >> 2), (void const   *)buffer + (unsigned long )(chunk_size >> 2),
                (size_t )rest);
  } else {

  }
#line 551
  return;
}
}
#line 554 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
static void vmw_fifo_slow_copy(struct vmw_fifo_state *fifo_state , __le32 *fifo_mem ,
                               uint32_t next_cmd , uint32_t max , uint32_t min , uint32_t bytes ) 
{ uint32_t *buffer ;
  __le32 *tmp ;
  uint32_t *tmp___0 ;
  long tmp___1 ;

  {
#line 559
  if ((unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0)) {
#line 559
    tmp = fifo_state->dynamic_buffer;
  } else {
#line 559
    tmp = fifo_state->static_buffer;
  }
#line 559
  buffer = tmp;
#line 562
  goto ldv_40749;
  ldv_40748: 
#line 563
  tmp___0 = buffer;
#line 563
  buffer = buffer + 1;
#line 563
  iowrite32(*tmp___0, (void *)fifo_mem + (unsigned long )(next_cmd >> 2));
#line 564
  next_cmd = next_cmd + 4U;
#line 565
  tmp___1 = ldv__builtin_expect(next_cmd == max, 0L);
#line 565
  if (tmp___1 != 0L) {
#line 566
    next_cmd = min;
  } else {

  }
#line 567
  __asm__  volatile   ("mfence": : : "memory");
#line 568
  iowrite32(next_cmd, (void *)fifo_mem + 2U);
#line 569
  __asm__  volatile   ("mfence": : : "memory");
#line 570
  bytes = bytes - 4U;
  ldv_40749: ;
#line 562
  if (bytes != 0U) {
#line 563
    goto ldv_40748;
  } else {
#line 565
    goto ldv_40750;
  }
  ldv_40750: ;
#line 567
  return;
}
}
#line 574 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void vmw_fifo_commit(struct vmw_private *dev_priv , uint32_t bytes ) 
{ struct vmw_fifo_state *fifo_state ;
  __le32 *fifo_mem ;
  uint32_t next_cmd ;
  unsigned int tmp ;
  uint32_t max ;
  unsigned int tmp___0 ;
  uint32_t min ;
  unsigned int tmp___1 ;
  bool reserveable ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 576
  fifo_state = & dev_priv->fifo;
#line 577
  fifo_mem = dev_priv->mmio_virt;
#line 578
  tmp = ioread32((void *)fifo_mem + 2U);
#line 578
  next_cmd = tmp;
#line 579
  tmp___0 = ioread32((void *)fifo_mem + 1U);
#line 579
  max = tmp___0;
#line 580
  tmp___1 = ioread32((void *)fifo_mem);
#line 580
  min = tmp___1;
#line 581
  reserveable = (fifo_state->capabilities & 64U) != 0U;
#line 583
  tmp___2 = ldv__builtin_expect((bytes & 3U) != 0U, 0L);
#line 583
  if (tmp___2 != 0L) {
#line 583
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (583), "i" (12UL));
    ldv_40761: ;
#line 583
    goto ldv_40761;
  } else {

  }
#line 584
  tmp___3 = ldv__builtin_expect((unsigned long )bytes > fifo_state->reserved_size, 0L);
#line 584
  if (tmp___3 != 0L) {
#line 584
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"),
                         "i" (584), "i" (12UL));
    ldv_40762: ;
#line 584
    goto ldv_40762;
  } else {

  }
#line 586
  fifo_state->reserved_size = 0UL;
#line 588
  if ((int )fifo_state->using_bounce_buffer) {
#line 589
    if ((int )reserveable) {
#line 590
      vmw_fifo_res_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
    } else {
#line 593
      vmw_fifo_slow_copy(fifo_state, fifo_mem, next_cmd, max, min, bytes);
    }
#line 596
    if ((unsigned long )fifo_state->dynamic_buffer != (unsigned long )((__le32 *)0)) {
#line 597
      vfree((void const   *)fifo_state->dynamic_buffer);
#line 598
      fifo_state->dynamic_buffer = 0;
    } else {

    }
  } else {

  }
#line 603
  down_write(& fifo_state->rwsem);
#line 604
  if ((int )fifo_state->using_bounce_buffer || (int )reserveable) {
#line 605
    next_cmd = next_cmd + bytes;
#line 606
    if (next_cmd >= max) {
#line 607
      next_cmd = (min - max) + next_cmd;
    } else {

    }
#line 608
    __asm__  volatile   ("mfence": : : "memory");
#line 609
    iowrite32(next_cmd, (void *)fifo_mem + 2U);
  } else {

  }
#line 612
  if ((int )reserveable) {
#line 613
    iowrite32(0U, (void *)fifo_mem + 14U);
  } else {

  }
#line 614
  __asm__  volatile   ("mfence": : : "memory");
#line 615
  up_write(& fifo_state->rwsem);
#line 616
  vmw_fifo_ping_host(dev_priv, 1U);
#line 617
  ldv_mutex_unlock_345(& fifo_state->fifo_mutex);
#line 618
  return;
}
}
#line 620 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_send_fence(struct vmw_private *dev_priv , uint32_t *seqno ) 
{ struct vmw_fifo_state *fifo_state ;
  struct svga_fifo_cmd_fence *cmd_fence ;
  void *fm ;
  int ret ;
  uint32_t bytes ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 622
  fifo_state = & dev_priv->fifo;
#line 625
  ret = 0;
#line 626
  bytes = 8U;
#line 628
  fm = vmw_fifo_reserve(dev_priv, bytes);
#line 629
  tmp___0 = ldv__builtin_expect((unsigned long )fm == (unsigned long )((void *)0), 0L);
#line 629
  if (tmp___0 != 0L) {
#line 630
    tmp = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 630
    *seqno = (uint32_t )tmp;
#line 631
    ret = -12;
#line 632
    vmw_fallback_wait(dev_priv, 0, 1, *seqno, 0, 750UL);
#line 634
    goto out_err;
  } else {

  }
  ldv_40773: 
#line 638
  tmp___1 = atomic_add_return(1, & dev_priv->marker_seq);
#line 638
  *seqno = (uint32_t )tmp___1;
#line 639
  if (*seqno == 0U) {
#line 640
    goto ldv_40773;
  } else {
#line 642
    goto ldv_40774;
  }
  ldv_40774: ;
#line 641
  if ((fifo_state->capabilities & 1U) == 0U) {
#line 648
    vmw_fifo_commit(dev_priv, 0U);
#line 649
    return (0);
  } else {

  }
#line 652
  *((__le32 *)fm) = 30U;
#line 653
  cmd_fence = (struct svga_fifo_cmd_fence *)((unsigned long )fm + 4UL);
#line 656
  iowrite32(*seqno, (void *)(& cmd_fence->fence));
#line 657
  vmw_fifo_commit(dev_priv, bytes);
#line 658
  vmw_marker_push(& fifo_state->marker_queue, *seqno);
#line 659
  vmw_update_seqno(dev_priv, fifo_state);
  out_err: ;
#line 662
  return (ret);
}
}
#line 682 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv , uint32_t cid ) 
{ struct ttm_buffer_object *bo ;
  struct __anonstruct_cmd_291___1 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 691
  bo = dev_priv->dummy_query_bo;
#line 697
  tmp = vmw_fifo_reserve(dev_priv, 24U);
#line 697
  cmd = (struct __anonstruct_293___0 *)tmp;
#line 699
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_291___1 *)0),
                             0L);
#line 699
  if (tmp___0 != 0L) {
#line 700
    drm_err("vmw_fifo_emit_dummy_query", "Out of fifo space for dummy query.\n");
#line 701
    return (-12);
  } else {

  }
#line 704
  cmd->header.id = 1067U;
#line 705
  cmd->header.size = 16U;
#line 706
  cmd->body.cid = cid;
#line 707
  cmd->body.type = 0;
#line 709
  if (bo->mem.mem_type == 2U) {
#line 710
    cmd->body.guestResult.gmrId = 4294967294U;
#line 711
    cmd->body.guestResult.offset = (uint32 )bo->offset;
  } else {
#line 713
    cmd->body.guestResult.gmrId = (uint32 )bo->mem.start;
#line 714
    cmd->body.guestResult.offset = 0U;
  }
#line 717
  vmw_fifo_commit(dev_priv, 24U);
#line 719
  return (0);
}
}
#line 722 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_319(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 727
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 729
  mutex_lock(ldv_func_arg1);
#line 730
  return;
}
}
#line 732 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_320(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 737
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 739
  mutex_unlock(ldv_func_arg1);
#line 740
  return;
}
}
#line 742 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_321(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 747
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 749
  mutex_lock(ldv_func_arg1);
#line 750
  return;
}
}
#line 752 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
int ldv_mutex_trylock_322(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 757
  tmp = mutex_trylock(ldv_func_arg1);
#line 757
  ldv_func_res = tmp;
#line 759
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 759
  return (tmp___0);
#line 761
  return (ldv_func_res);
}
}
#line 764 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_323(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 769
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 771
  mutex_unlock(ldv_func_arg1);
#line 772
  return;
}
}
#line 774 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_324(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 779
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 781
  mutex_lock(ldv_func_arg1);
#line 782
  return;
}
}
#line 784 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_325(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 789
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 791
  mutex_unlock(ldv_func_arg1);
#line 792
  return;
}
}
#line 794 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_326(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 799
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 801
  mutex_lock(ldv_func_arg1);
#line 802
  return;
}
}
#line 804 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_327(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 809
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 811
  mutex_unlock(ldv_func_arg1);
#line 812
  return;
}
}
#line 814 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_328(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 819
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 821
  mutex_unlock(ldv_func_arg1);
#line 822
  return;
}
}
#line 824 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_329(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 829
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 831
  mutex_lock(ldv_func_arg1);
#line 832
  return;
}
}
#line 834 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_330(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 839
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 841
  mutex_unlock(ldv_func_arg1);
#line 842
  return;
}
}
#line 844 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_331(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 849
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 851
  mutex_lock(ldv_func_arg1);
#line 852
  return;
}
}
#line 854 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_332(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 859
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 861
  mutex_unlock(ldv_func_arg1);
#line 862
  return;
}
}
#line 864 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_333(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 869
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 871
  mutex_lock(ldv_func_arg1);
#line 872
  return;
}
}
#line 874 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_334(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 879
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 881
  mutex_unlock(ldv_func_arg1);
#line 882
  return;
}
}
#line 884 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_335(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 889
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 891
  mutex_lock(ldv_func_arg1);
#line 892
  return;
}
}
#line 894 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_336(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 899
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 901
  mutex_unlock(ldv_func_arg1);
#line 902
  return;
}
}
#line 904 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_337(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 909
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 911
  mutex_lock(ldv_func_arg1);
#line 912
  return;
}
}
#line 914 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_338(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 919
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 921
  mutex_unlock(ldv_func_arg1);
#line 922
  return;
}
}
#line 924 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_339(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 929
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 931
  mutex_lock(ldv_func_arg1);
#line 932
  return;
}
}
#line 934 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_340(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 939
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 941
  mutex_unlock(ldv_func_arg1);
#line 942
  return;
}
}
#line 944 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_341(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 949
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 951
  mutex_lock(ldv_func_arg1);
#line 952
  return;
}
}
#line 954 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_342(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 959
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 961
  mutex_unlock(ldv_func_arg1);
#line 962
  return;
}
}
#line 964 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_lock_343(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 969
  ldv_mutex_lock_fifo_mutex_of_vmw_fifo_state(ldv_func_arg1);
#line 971
  mutex_lock(ldv_func_arg1);
#line 972
  return;
}
}
#line 974 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_344(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 979
  ldv_mutex_unlock_fifo_mutex_of_vmw_fifo_state(ldv_func_arg1);
#line 981
  mutex_unlock(ldv_func_arg1);
#line 982
  return;
}
}
#line 984 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c.prepared"
void ldv_mutex_unlock_345(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 989
  ldv_mutex_unlock_fifo_mutex_of_vmw_fifo_state(ldv_func_arg1);
#line 991
  mutex_unlock(ldv_func_arg1);
#line 992
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_376(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_374(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_377(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_379(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_381(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_382(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_384(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_386(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_388(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_390(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_392(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_394(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_396(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_398(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_373(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_375(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_378(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_380(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_383(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_385(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_387(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_389(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_391(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_393(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_395(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_397(struct mutex *ldv_func_arg1 ) ;
#line 80 "include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 100
extern void up_read(struct rw_semaphore * ) ;
#line 334 "include/linux/sched.h"
extern void schedule(void) ;
#line 75 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h"
void vmw_fences_update(struct vmw_fence_manager *fman ) ;
#line 609 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) ;
#line 615
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) ;
#line 625
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) ;
#line 626
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) ;
#line 627
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) ;
#line 628
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) ;
#line 639
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) ;
#line 185 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
irqreturn_t vmw_irq_handler(int irq , void *arg ) 
{ struct drm_device *dev ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;
  uint32_t masked_status ;
  long tmp___0 ;

  {
#line 187
  dev = (struct drm_device *)arg;
#line 188
  tmp = vmw_priv(dev);
#line 188
  dev_priv = tmp;
#line 191
  spin_lock(& dev_priv->irq_lock);
#line 192
  status = inl((int )(dev_priv->io_start + 8U));
#line 193
  masked_status = dev_priv->irq_mask & status;
#line 194
  spin_unlock(& dev_priv->irq_lock);
#line 196
  tmp___0 = ldv__builtin_expect(status != 0U, 1L);
#line 196
  if (tmp___0 != 0L) {
#line 197
    outl(status, (int )(dev_priv->io_start + 8U));
  } else {

  }
#line 199
  if (masked_status == 0U) {
#line 200
    return (0);
  } else {

  }
#line 202
  if ((masked_status & 5U) != 0U) {
#line 204
    vmw_fences_update(dev_priv->fman);
#line 205
    __wake_up(& dev_priv->fence_queue, 3U, 0, 0);
  } else {

  }
#line 208
  if ((masked_status & 2U) != 0U) {
#line 209
    __wake_up(& dev_priv->fifo_queue, 3U, 0, 0);
  } else {

  }
#line 212
  return (1);
}
}
#line 215 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
static bool vmw_fifo_idle(struct vmw_private *dev_priv , uint32_t seqno ) 
{ uint32_t busy ;

  {
#line 219
  ldv_mutex_lock_387(& dev_priv->hw_mutex);
#line 220
  busy = vmw_read(dev_priv, 22U);
#line 221
  ldv_mutex_unlock_388(& dev_priv->hw_mutex);
#line 223
  return (busy == 0U);
}
}
#line 226 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_update_seqno(struct vmw_private *dev_priv , struct vmw_fifo_state *fifo_state ) 
{ __le32 *fifo_mem ;
  uint32_t seqno ;
  unsigned int tmp ;

  {
#line 229
  fifo_mem = dev_priv->mmio_virt;
#line 230
  tmp = ioread32((void *)fifo_mem + 6U);
#line 230
  seqno = tmp;
#line 232
  if (dev_priv->last_read_seqno != seqno) {
#line 233
    dev_priv->last_read_seqno = seqno;
#line 234
    vmw_marker_pull(& fifo_state->marker_queue, seqno);
#line 235
    vmw_fences_update(dev_priv->fman);
  } else {

  }
#line 237
  return;
}
}
#line 239 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
bool vmw_seqno_passed(struct vmw_private *dev_priv , uint32_t seqno ) 
{ struct vmw_fifo_state *fifo_state ;
  bool ret ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 245
  tmp = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 245
  if (tmp != 0L) {
#line 246
    return (1);
  } else {

  }
#line 248
  fifo_state = & dev_priv->fifo;
#line 249
  vmw_update_seqno(dev_priv, fifo_state);
#line 250
  tmp___0 = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 250
  if (tmp___0 != 0L) {
#line 251
    return (1);
  } else {

  }
#line 253
  if ((fifo_state->capabilities & 1U) == 0U) {
#line 253
    tmp___1 = vmw_fifo_idle(dev_priv, seqno);
#line 253
    if ((int )tmp___1) {
#line 255
      return (1);
    } else {

    }
  } else {

  }
#line 262
  tmp___2 = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 262
  ret = (uint32_t )tmp___2 - seqno > 16777216U;
#line 265
  return (ret);
}
}
#line 268 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_fallback_wait(struct vmw_private *dev_priv , bool lazy , bool fifo_idle ,
                      uint32_t seqno , bool interruptible , unsigned long timeout ) 
{ struct vmw_fifo_state *fifo_state ;
  uint32_t count ;
  uint32_t signal_seq ;
  int ret ;
  unsigned long end_jiffies ;
  bool (*wait_condition)(struct vmw_private * , uint32_t  ) ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;
  __le32 *fifo_mem ;

  {
#line 275
  fifo_state = & dev_priv->fifo;
#line 277
  count = 0U;
#line 280
  end_jiffies = (unsigned long )jiffies + timeout;
#line 282
  tmp = get_current();
#line 282
  __wait.flags = 0U;
#line 282
  __wait.private = (void *)tmp;
#line 282
  __wait.func = & autoremove_wake_function;
#line 282
  __wait.task_list.next = & __wait.task_list;
#line 282
  __wait.task_list.prev = & __wait.task_list;
#line 284
  if ((int )fifo_idle) {
#line 284
    wait_condition = & vmw_fifo_idle;
  } else {
#line 284
    wait_condition = & vmw_seqno_passed;
  }
#line 291
  if ((int )fifo_idle) {
#line 292
    down_read(& fifo_state->rwsem);
  } else {

  }
#line 293
  tmp___0 = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 293
  signal_seq = (uint32_t )tmp___0;
#line 294
  ret = 0;
  ldv_40669: ;
#line 297
  if ((int )interruptible) {
#line 297
    tmp___1 = 1;
  } else {
#line 297
    tmp___1 = 2;
  }
#line 297
  prepare_to_wait(& dev_priv->fence_queue, & __wait, tmp___1);
#line 300
  tmp___2 = (*wait_condition)(dev_priv, seqno);
#line 300
  if ((int )tmp___2) {
#line 301
    goto ldv_40661;
  } else {

  }
#line 302
  if ((long )jiffies - (long )end_jiffies >= 0L) {
#line 303
    drm_err("vmw_fallback_wait", "SVGA device lockup.\n");
#line 304
    goto ldv_40661;
  } else {

  }
#line 306
  if ((int )lazy) {
#line 307
    schedule_timeout(1L);
  } else {
#line 308
    count = count + 1U;
#line 308
    if ((count & 15U) == 0U) {
#line 314
      tmp___3 = get_current();
#line 314
      tmp___3->state = 0L;
#line 315
      schedule();
#line 316
      tmp___4 = get_current();
#line 316
      if ((int )interruptible) {
#line 316
        tmp___4->state = 1L;
      } else {
#line 316
        tmp___4->state = 2L;
      }
    } else {

    }
  }
#line 320
  if ((int )interruptible) {
#line 320
    tmp___5 = get_current();
#line 320
    tmp___6 = signal_pending(tmp___5);
#line 320
    if (tmp___6 != 0) {
#line 321
      ret = -512;
#line 322
      goto ldv_40661;
    } else {

    }
  } else {

  }
#line 324
  goto ldv_40669;
  ldv_40661: 
#line 325
  finish_wait(& dev_priv->fence_queue, & __wait);
#line 326
  if (ret == 0 && (int )fifo_idle) {
#line 327
    fifo_mem = dev_priv->mmio_virt;
#line 328
    iowrite32(signal_seq, (void *)fifo_mem + 6U);
  } else {

  }
#line 330
  __wake_up(& dev_priv->fence_queue, 3U, 0, 0);
#line 331
  if ((int )fifo_idle) {
#line 332
    up_read(& fifo_state->rwsem);
  } else {

  }
#line 334
  return (ret);
}
}
#line 337 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_seqno_waiter_add(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 339
  ldv_mutex_lock_389(& dev_priv->hw_mutex);
#line 340
  tmp___0 = dev_priv->fence_queue_waiters;
#line 340
  dev_priv->fence_queue_waiters = dev_priv->fence_queue_waiters + 1;
#line 340
  if (tmp___0 == 0) {
#line 343
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 343
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 344
    outl(1U, (int )(dev_priv->io_start + 8U));
#line 346
    dev_priv->irq_mask = dev_priv->irq_mask | 1U;
#line 347
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 348
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 350
  ldv_mutex_unlock_390(& dev_priv->hw_mutex);
#line 351
  return;
}
}
#line 353 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_seqno_waiter_remove(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 355
  ldv_mutex_lock_391(& dev_priv->hw_mutex);
#line 356
  dev_priv->fence_queue_waiters = dev_priv->fence_queue_waiters - 1;
#line 356
  if (dev_priv->fence_queue_waiters == 0) {
#line 359
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 359
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 360
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967294U;
#line 361
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 362
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 364
  ldv_mutex_unlock_392(& dev_priv->hw_mutex);
#line 365
  return;
}
}
#line 368 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_goal_waiter_add(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 370
  ldv_mutex_lock_393(& dev_priv->hw_mutex);
#line 371
  tmp___0 = dev_priv->goal_queue_waiters;
#line 371
  dev_priv->goal_queue_waiters = dev_priv->goal_queue_waiters + 1;
#line 371
  if (tmp___0 == 0) {
#line 374
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 374
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 375
    outl(4U, (int )(dev_priv->io_start + 8U));
#line 377
    dev_priv->irq_mask = dev_priv->irq_mask | 4U;
#line 378
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 379
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 381
  ldv_mutex_unlock_394(& dev_priv->hw_mutex);
#line 382
  return;
}
}
#line 384 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_goal_waiter_remove(struct vmw_private *dev_priv ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 386
  ldv_mutex_lock_395(& dev_priv->hw_mutex);
#line 387
  dev_priv->goal_queue_waiters = dev_priv->goal_queue_waiters - 1;
#line 387
  if (dev_priv->goal_queue_waiters == 0) {
#line 390
    tmp = spinlock_check(& dev_priv->irq_lock);
#line 390
    irq_flags = _raw_spin_lock_irqsave(tmp);
#line 391
    dev_priv->irq_mask = dev_priv->irq_mask & 4294967291U;
#line 392
    vmw_write(dev_priv, 33U, dev_priv->irq_mask);
#line 393
    spin_unlock_irqrestore(& dev_priv->irq_lock, irq_flags);
  } else {

  }
#line 395
  ldv_mutex_unlock_396(& dev_priv->hw_mutex);
#line 396
  return;
}
}
#line 398 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_wait_seqno(struct vmw_private *dev_priv , bool lazy , uint32_t seqno , bool interruptible ,
                   unsigned long timeout ) 
{ long ret ;
  struct vmw_fifo_state *fifo ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___4 ;
  bool tmp___5 ;
  struct task_struct *tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;

  {
#line 403
  fifo = & dev_priv->fifo;
#line 405
  tmp = ldv__builtin_expect(dev_priv->last_read_seqno - seqno <= 16777215U, 1L);
#line 405
  if (tmp != 0L) {
#line 406
    return (0);
  } else {

  }
#line 408
  tmp___0 = vmw_seqno_passed(dev_priv, seqno);
#line 408
  tmp___1 = ldv__builtin_expect((long )tmp___0, 1L);
#line 408
  if (tmp___1 != 0L) {
#line 409
    return (0);
  } else {

  }
#line 411
  vmw_fifo_ping_host(dev_priv, 1U);
#line 413
  if ((fifo->capabilities & 1U) == 0U) {
#line 414
    tmp___2 = vmw_fallback_wait(dev_priv, (int )lazy, 1, seqno, (int )interruptible,
                                timeout);
#line 414
    return (tmp___2);
  } else {

  }
#line 417
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 418
    tmp___3 = vmw_fallback_wait(dev_priv, (int )lazy, 0, seqno, (int )interruptible,
                                timeout);
#line 418
    return (tmp___3);
  } else {

  }
#line 421
  vmw_seqno_waiter_add(dev_priv);
#line 423
  if ((int )interruptible) {
#line 424
    __ret = (long )timeout;
#line 424
    tmp___8 = vmw_seqno_passed(dev_priv, seqno);
#line 424
    if (tmp___8) {
#line 424
      tmp___9 = 0;
    } else {
#line 424
      tmp___9 = 1;
    }
#line 424
    if (tmp___9) {
#line 424
      tmp___4 = get_current();
#line 424
      __wait.flags = 0U;
#line 424
      __wait.private = (void *)tmp___4;
#line 424
      __wait.func = & autoremove_wake_function;
#line 424
      __wait.task_list.next = & __wait.task_list;
#line 424
      __wait.task_list.prev = & __wait.task_list;
      ldv_40712: 
#line 424
      prepare_to_wait(& dev_priv->fence_queue, & __wait, 1);
#line 424
      tmp___5 = vmw_seqno_passed(dev_priv, seqno);
#line 424
      if ((int )tmp___5) {
#line 424
        goto ldv_40710;
      } else {

      }
#line 424
      tmp___6 = get_current();
#line 424
      tmp___7 = signal_pending(tmp___6);
#line 424
      if (tmp___7 == 0) {
#line 424
        __ret = schedule_timeout(__ret);
#line 424
        if (__ret == 0L) {
#line 424
          goto ldv_40710;
        } else {

        }
#line 424
        goto ldv_40711;
      } else {

      }
#line 424
      __ret = -512L;
#line 424
      goto ldv_40710;
      ldv_40711: ;
#line 424
      goto ldv_40712;
      ldv_40710: 
#line 424
      finish_wait(& dev_priv->fence_queue, & __wait);
    } else {

    }
#line 424
    ret = __ret;
  } else {
#line 429
    __ret___0 = (long )timeout;
#line 429
    tmp___12 = vmw_seqno_passed(dev_priv, seqno);
#line 429
    if (tmp___12) {
#line 429
      tmp___13 = 0;
    } else {
#line 429
      tmp___13 = 1;
    }
#line 429
    if (tmp___13) {
#line 429
      tmp___10 = get_current();
#line 429
      __wait___0.flags = 0U;
#line 429
      __wait___0.private = (void *)tmp___10;
#line 429
      __wait___0.func = & autoremove_wake_function;
#line 429
      __wait___0.task_list.next = & __wait___0.task_list;
#line 429
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_40717: 
#line 429
      prepare_to_wait(& dev_priv->fence_queue, & __wait___0, 2);
#line 429
      tmp___11 = vmw_seqno_passed(dev_priv, seqno);
#line 429
      if ((int )tmp___11) {
#line 429
        goto ldv_40716;
      } else {

      }
#line 429
      __ret___0 = schedule_timeout(__ret___0);
#line 429
      if (__ret___0 == 0L) {
#line 429
        goto ldv_40716;
      } else {

      }
#line 429
      goto ldv_40717;
      ldv_40716: 
#line 429
      finish_wait(& dev_priv->fence_queue, & __wait___0);
    } else {

    }
#line 429
    ret = __ret___0;
  }
#line 434
  vmw_seqno_waiter_remove(dev_priv);
#line 436
  tmp___15 = ldv__builtin_expect(ret == 0L, 0L);
#line 436
  if (tmp___15 != 0L) {
#line 437
    ret = -16L;
  } else {
#line 438
    tmp___14 = ldv__builtin_expect(ret > 0L, 1L);
#line 438
    if (tmp___14 != 0L) {
#line 439
      ret = 0L;
    } else {

    }
  }
#line 441
  return ((int )ret);
}
}
#line 444 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_irq_preinstall(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;
  struct lock_class_key __key ;

  {
#line 446
  tmp = vmw_priv(dev);
#line 446
  dev_priv = tmp;
#line 449
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 450
    return;
  } else {

  }
#line 452
  spinlock_check(& dev_priv->irq_lock);
#line 452
  __raw_spin_lock_init(& dev_priv->irq_lock.ldv_5961.rlock, "&(&dev_priv->irq_lock)->rlock",
                       & __key);
#line 453
  status = inl((int )(dev_priv->io_start + 8U));
#line 454
  outl(status, (int )(dev_priv->io_start + 8U));
#line 455
  return;
}
}
#line 457 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int vmw_irq_postinstall(struct drm_device *dev ) 
{ 

  {
#line 459
  return (0);
}
}
#line 462 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void vmw_irq_uninstall(struct drm_device *dev ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  uint32_t status ;

  {
#line 464
  tmp = vmw_priv(dev);
#line 464
  dev_priv = tmp;
#line 467
  if ((dev_priv->capabilities & 262144U) == 0U) {
#line 468
    return;
  } else {

  }
#line 470
  ldv_mutex_lock_397(& dev_priv->hw_mutex);
#line 471
  vmw_write(dev_priv, 33U, 0U);
#line 472
  ldv_mutex_unlock_398(& dev_priv->hw_mutex);
#line 474
  status = inl((int )(dev_priv->io_start + 8U));
#line 475
  outl(status, (int )(dev_priv->io_start + 8U));
#line 476
  return;
}
}
#line 478 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_373(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 483
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 485
  mutex_lock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_374(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 493
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 495
  mutex_unlock(ldv_func_arg1);
#line 496
  return;
}
}
#line 498 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_375(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 503
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 505
  mutex_lock(ldv_func_arg1);
#line 506
  return;
}
}
#line 508 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
int ldv_mutex_trylock_376(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 513
  tmp = mutex_trylock(ldv_func_arg1);
#line 513
  ldv_func_res = tmp;
#line 515
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 515
  return (tmp___0);
#line 517
  return (ldv_func_res);
}
}
#line 520 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_377(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 525
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 527
  mutex_unlock(ldv_func_arg1);
#line 528
  return;
}
}
#line 530 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_378(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 535
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 537
  mutex_lock(ldv_func_arg1);
#line 538
  return;
}
}
#line 540 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_379(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 545
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 547
  mutex_unlock(ldv_func_arg1);
#line 548
  return;
}
}
#line 550 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_380(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 555
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 557
  mutex_lock(ldv_func_arg1);
#line 558
  return;
}
}
#line 560 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_381(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 565
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 567
  mutex_unlock(ldv_func_arg1);
#line 568
  return;
}
}
#line 570 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_382(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 575
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 577
  mutex_unlock(ldv_func_arg1);
#line 578
  return;
}
}
#line 580 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_383(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 585
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 587
  mutex_lock(ldv_func_arg1);
#line 588
  return;
}
}
#line 590 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_384(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 595
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 597
  mutex_unlock(ldv_func_arg1);
#line 598
  return;
}
}
#line 600 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_385(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 605
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 607
  mutex_lock(ldv_func_arg1);
#line 608
  return;
}
}
#line 610 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_386(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 615
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 617
  mutex_unlock(ldv_func_arg1);
#line 618
  return;
}
}
#line 620 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_387(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 625
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 627
  mutex_lock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_388(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 635
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 637
  mutex_unlock(ldv_func_arg1);
#line 638
  return;
}
}
#line 640 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_389(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 645
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 647
  mutex_lock(ldv_func_arg1);
#line 648
  return;
}
}
#line 650 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_390(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 655
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 657
  mutex_unlock(ldv_func_arg1);
#line 658
  return;
}
}
#line 660 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_391(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 665
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 667
  mutex_lock(ldv_func_arg1);
#line 668
  return;
}
}
#line 670 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_392(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 675
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 677
  mutex_unlock(ldv_func_arg1);
#line 678
  return;
}
}
#line 680 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_393(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 685
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 687
  mutex_lock(ldv_func_arg1);
#line 688
  return;
}
}
#line 690 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_394(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 695
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 697
  mutex_unlock(ldv_func_arg1);
#line 698
  return;
}
}
#line 700 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_395(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 705
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 707
  mutex_lock(ldv_func_arg1);
#line 708
  return;
}
}
#line 710 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_396(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 715
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 717
  mutex_unlock(ldv_func_arg1);
#line 718
  return;
}
}
#line 720 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_lock_397(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 725
  ldv_mutex_lock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 727
  mutex_lock(ldv_func_arg1);
#line 728
  return;
}
}
#line 730 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c.prepared"
void ldv_mutex_unlock_398(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 735
  ldv_mutex_unlock_hw_mutex_of_vmw_private(ldv_func_arg1);
#line 737
  mutex_unlock(ldv_func_arg1);
#line 738
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_428(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_429(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_434(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_436(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_438(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_425(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_427(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_430(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_435(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_437(struct mutex *ldv_func_arg1 ) ;
#line 845 "include/drm/drm_crtc.h"
extern int drm_crtc_init(struct drm_device * , struct drm_crtc * , struct drm_crtc_funcs  const  * ) ;
#line 850
extern int drm_connector_init(struct drm_device * , struct drm_connector * , struct drm_connector_funcs  const  * ,
                              int  ) ;
#line 859
extern int drm_encoder_init(struct drm_device * , struct drm_encoder * , struct drm_encoder_funcs  const  * ,
                            int  ) ;
#line 944
extern void drm_object_attach_property(struct drm_mode_object * , struct drm_property * ,
                                       uint64_t  ) ;
#line 968
extern int drm_mode_create_dirty_info_property(struct drm_device * ) ;
#line 971
extern int drm_mode_connector_attach_encoder(struct drm_connector * , struct drm_encoder * ) ;
#line 975
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc * , int  ) ;
#line 1427 "include/drm/drmP.h"
extern int drm_vblank_init(struct drm_device * , int  ) ;
#line 1440
extern void drm_vblank_cleanup(struct drm_device * ) ;
#line 209 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_destroy(struct vmw_legacy_display_unit *ldu ) 
{ 

  {
#line 211
  list_del_init(& ldu->active);
#line 212
  vmw_display_unit_cleanup(& ldu->base);
#line 213
  kfree((void const   *)ldu);
#line 214
  return;
}
}
#line 221 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_crtc_destroy(struct drm_crtc *crtc ) 
{ struct drm_crtc  const  *__mptr ;

  {
#line 223
  __mptr = (struct drm_crtc  const  *)crtc;
#line 223
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr);
#line 225
  return;
}
}
#line 226 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_commit_list(struct vmw_private *dev_priv ) 
{ struct vmw_legacy_display *lds ;
  struct vmw_legacy_display_unit *entry ;
  struct vmw_display_unit *du ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int i ;
  int ret ;
  int w ;
  int h ;
  struct list_head  const  *__mptr ;
  int _max1 ;
  int _max2 ;
  int tmp ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  long tmp___4 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;

  {
#line 228
  lds = dev_priv->ldu_priv;
#line 230
  du = 0;
#line 231
  fb = 0;
#line 232
  crtc = 0;
#line 233
  i = 0;
#line 238
  if ((dev_priv->capabilities & 524288U) == 0U) {
#line 239
    w = 0;
#line 239
    h = 0;
#line 240
    __mptr = (struct list_head  const  *)lds->active.next;
#line 240
    entry = (struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffff4c8UL;
#line 240
    goto ldv_40842;
    ldv_40841: 
#line 241
    crtc = & entry->base.crtc;
#line 242
    _max1 = w;
#line 242
    _max2 = crtc->x + crtc->mode.hdisplay;
#line 242
    if (_max1 > _max2) {
#line 242
      tmp = _max1;
    } else {
#line 242
      tmp = _max2;
    }
#line 242
    w = tmp;
#line 243
    _max1___0 = h;
#line 243
    _max2___0 = crtc->y + crtc->mode.vdisplay;
#line 243
    if (_max1___0 > _max2___0) {
#line 243
      tmp___0 = _max1___0;
    } else {
#line 243
      tmp___0 = _max2___0;
    }
#line 243
    h = tmp___0;
#line 244
    i = i + 1;
#line 240
    __mptr___0 = (struct list_head  const  *)entry->active.next;
#line 240
    entry = (struct vmw_legacy_display_unit *)__mptr___0 + 0xfffffffffffff4c8UL;
    ldv_40842: ;
#line 240
    if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 241
      goto ldv_40841;
    } else {
#line 243
      goto ldv_40843;
    }
    ldv_40843: ;
#line 247
    if ((unsigned long )crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 248
      return (0);
    } else {

    }
#line 249
    fb = entry->base.crtc.fb;
#line 251
    tmp___1 = vmw_kms_write_svga(dev_priv, (unsigned int )w, (unsigned int )h, fb->pitches[0],
                                 (unsigned int )fb->bits_per_pixel, fb->depth);
#line 251
    return (tmp___1);
  } else {

  }
#line 255
  tmp___2 = list_empty((struct list_head  const  *)(& lds->active));
#line 255
  if (tmp___2 == 0) {
#line 256
    __mptr___1 = (struct list_head  const  *)lds->active.next;
#line 256
    entry = (struct vmw_legacy_display_unit *)__mptr___1 + 0xfffffffffffff4c8UL;
#line 257
    fb = entry->base.crtc.fb;
#line 259
    vmw_kms_write_svga(dev_priv, fb->width, fb->height, fb->pitches[0], (unsigned int )fb->bits_per_pixel,
                       fb->depth);
  } else {

  }
#line 264
  if (lds->num_active != 0U) {
#line 264
    tmp___3 = lds->num_active;
  } else {
#line 264
    tmp___3 = 1U;
  }
#line 264
  vmw_write(dev_priv, 34U, tmp___3);
#line 267
  i = 0;
#line 268
  __mptr___2 = (struct list_head  const  *)lds->active.next;
#line 268
  entry = (struct vmw_legacy_display_unit *)__mptr___2 + 0xfffffffffffff4c8UL;
#line 268
  goto ldv_40851;
  ldv_40850: 
#line 269
  crtc = & entry->base.crtc;
#line 271
  vmw_write(dev_priv, 35U, (uint32_t )i);
#line 272
  vmw_write(dev_priv, 36U, i == 0);
#line 273
  vmw_write(dev_priv, 37U, (uint32_t )crtc->x);
#line 274
  vmw_write(dev_priv, 38U, (uint32_t )crtc->y);
#line 275
  vmw_write(dev_priv, 39U, (uint32_t )crtc->mode.hdisplay);
#line 276
  vmw_write(dev_priv, 40U, (uint32_t )crtc->mode.vdisplay);
#line 277
  vmw_write(dev_priv, 35U, 4294967295U);
#line 279
  i = i + 1;
#line 268
  __mptr___3 = (struct list_head  const  *)entry->active.next;
#line 268
  entry = (struct vmw_legacy_display_unit *)__mptr___3 + 0xfffffffffffff4c8UL;
  ldv_40851: ;
#line 268
  if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 269
    goto ldv_40850;
  } else {
#line 271
    goto ldv_40852;
  }
  ldv_40852: 
#line 282
  tmp___4 = ldv__builtin_expect((unsigned int )i != lds->num_active, 0L);
#line 282
  if (tmp___4 != 0L) {
#line 282
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                         "i" (282), "i" (12UL));
    ldv_40853: ;
#line 282
    goto ldv_40853;
  } else {

  }
#line 284
  lds->last_num_active = lds->num_active;
#line 288
  __mptr___4 = (struct list_head  const  *)lds->active.next;
#line 288
  entry = (struct vmw_legacy_display_unit *)__mptr___4 + 0xfffffffffffff4c8UL;
#line 288
  goto ldv_40862;
  ldv_40861: 
#line 289
  du = & entry->base;
#line 291
  if ((unsigned long )du->cursor_dmabuf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 292
    goto ldv_40858;
  } else {

  }
#line 294
  ret = vmw_cursor_update_dmabuf(dev_priv, du->cursor_dmabuf, 64U, 64U, (u32 )du->hotspot_x,
                                 (u32 )du->hotspot_y);
#line 299
  if (ret == 0) {
#line 300
    goto ldv_40859;
  } else {

  }
#line 302
  drm_err("vmw_ldu_commit_list", "Could not update cursor image\n");
  ldv_40858: 
#line 288
  __mptr___5 = (struct list_head  const  *)entry->active.next;
#line 288
  entry = (struct vmw_legacy_display_unit *)__mptr___5 + 0xfffffffffffff4c8UL;
  ldv_40862: ;
#line 288
  if ((unsigned long )(& entry->active) != (unsigned long )(& lds->active)) {
#line 289
    goto ldv_40861;
  } else {
#line 291
    goto ldv_40859;
  }
  ldv_40859: ;
#line 305
  return (0);
}
}
#line 308 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_del_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ) 
{ struct vmw_legacy_display *ld ;
  int tmp ;
  long tmp___0 ;

  {
#line 311
  ld = vmw_priv___0->ldu_priv;
#line 312
  tmp = list_empty((struct list_head  const  *)(& ldu->active));
#line 312
  if (tmp != 0) {
#line 313
    return (0);
  } else {

  }
#line 316
  list_del_init(& ldu->active);
#line 317
  ld->num_active = ld->num_active - 1U;
#line 317
  if (ld->num_active == 0U) {
#line 318
    tmp___0 = ldv__builtin_expect((unsigned long )ld->fb == (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 318
    if (tmp___0 != 0L) {
#line 318
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                           "i" (318), "i" (12UL));
      ldv_40868: ;
#line 318
      goto ldv_40868;
    } else {

    }
#line 319
    if ((unsigned long )(ld->fb)->unpin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 320
      (*((ld->fb)->unpin))(ld->fb);
    } else {

    }
#line 321
    ld->fb = 0;
  } else {

  }
#line 324
  return (0);
}
}
#line 327 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_add_active(struct vmw_private *vmw_priv___0 , struct vmw_legacy_display_unit *ldu ,
                              struct vmw_framebuffer *vfb ) 
{ struct vmw_legacy_display *ld ;
  struct vmw_legacy_display_unit *entry ;
  struct list_head *at ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 331
  ld = vmw_priv___0->ldu_priv;
#line 335
  tmp = ldv__builtin_expect(ld->num_active == 0U, 0L);
#line 335
  if (tmp != 0L) {
#line 335
    tmp___0 = ldv__builtin_expect((unsigned long )ld->fb != (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 335
    if (tmp___0 != 0L) {
#line 335
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                           "i" (335), "i" (12UL));
      ldv_40877: ;
#line 335
      goto ldv_40877;
    } else {

    }
  } else {

  }
#line 336
  if ((unsigned long )ld->fb != (unsigned long )vfb) {
#line 337
    if ((unsigned long )ld->fb != (unsigned long )((struct vmw_framebuffer *)0) && (unsigned long )(ld->fb)->unpin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 338
      (*((ld->fb)->unpin))(ld->fb);
    } else {

    }
#line 339
    if ((unsigned long )vfb->pin != (unsigned long )((int (*)(struct vmw_framebuffer * ))0)) {
#line 340
      (*(vfb->pin))(vfb);
    } else {

    }
#line 341
    ld->fb = vfb;
  } else {

  }
#line 344
  tmp___1 = list_empty((struct list_head  const  *)(& ldu->active));
#line 344
  if (tmp___1 == 0) {
#line 345
    return (0);
  } else {

  }
#line 347
  at = & ld->active;
#line 348
  __mptr = (struct list_head  const  *)ld->active.next;
#line 348
  entry = (struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffff4c8UL;
#line 348
  goto ldv_40884;
  ldv_40883: ;
#line 349
  if (entry->base.unit > ldu->base.unit) {
#line 350
    goto ldv_40882;
  } else {

  }
#line 352
  at = & entry->active;
#line 348
  __mptr___0 = (struct list_head  const  *)entry->active.next;
#line 348
  entry = (struct vmw_legacy_display_unit *)__mptr___0 + 0xfffffffffffff4c8UL;
  ldv_40884: ;
#line 348
  if ((unsigned long )(& entry->active) != (unsigned long )(& ld->active)) {
#line 349
    goto ldv_40883;
  } else {
#line 351
    goto ldv_40882;
  }
  ldv_40882: 
#line 355
  list_add(& ldu->active, at);
#line 357
  ld->num_active = ld->num_active + 1U;
#line 359
  return (0);
}
}
#line 362 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_crtc_set_config(struct drm_mode_set *set ) 
{ struct vmw_private *dev_priv ;
  struct vmw_legacy_display_unit *ldu ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 373
  if ((unsigned long )set == (unsigned long )((struct drm_mode_set *)0)) {
#line 374
    return (-22);
  } else {

  }
#line 376
  if ((unsigned long )set->crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 377
    return (-22);
  } else {

  }
#line 380
  crtc = set->crtc;
#line 381
  __mptr = (struct drm_crtc  const  *)crtc;
#line 381
  ldu = (struct vmw_legacy_display_unit *)__mptr;
#line 382
  if ((unsigned long )set->fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 382
    __mptr___0 = (struct drm_framebuffer  const  *)set->fb;
#line 382
    vfb = (struct vmw_framebuffer *)__mptr___0;
  } else {
#line 382
    vfb = 0;
  }
#line 383
  dev_priv = vmw_priv(crtc->dev);
#line 385
  if (set->num_connectors > 1UL) {
#line 386
    drm_err("vmw_ldu_crtc_set_config", "to many connectors\n");
#line 387
    return (-22);
  } else {

  }
#line 390
  if (set->num_connectors == 1UL && (unsigned long )*(set->connectors) != (unsigned long )(& ldu->base.connector)) {
#line 392
    drm_err("vmw_ldu_crtc_set_config", "connector doesn\'t match %p %p\n", *(set->connectors),
            & ldu->base.connector);
#line 394
    return (-22);
  } else {

  }
#line 398
  if ((unsigned long )(dev_priv->ldu_priv)->fb != (unsigned long )((struct vmw_framebuffer *)0) && (unsigned long )vfb != (unsigned long )((struct vmw_framebuffer *)0)) {
#line 398
    if ((dev_priv->ldu_priv)->num_active != 1U) {
#line 398
      goto _L;
    } else {
#line 398
      tmp = list_empty((struct list_head  const  *)(& ldu->active));
#line 398
      if (tmp != 0) {
        _L: /* CIL Label */ 
#line 398
        if ((unsigned long )(dev_priv->ldu_priv)->fb != (unsigned long )vfb) {
#line 402
          drm_err("vmw_ldu_crtc_set_config", "Multiple framebuffers not supported\n");
#line 403
          return (-22);
        } else {

        }
      } else {

      }
    }
  } else {

  }
#line 407
  connector = & ldu->base.connector;
#line 408
  encoder = & ldu->base.encoder;
#line 411
  if ((set->num_connectors == 0UL || (unsigned long )set->mode == (unsigned long )((struct drm_display_mode *)0)) || (unsigned long )set->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 413
    connector->encoder = 0;
#line 414
    encoder->crtc = 0;
#line 415
    crtc->fb = 0;
#line 417
    vmw_ldu_del_active(dev_priv, ldu);
#line 419
    tmp___0 = vmw_ldu_commit_list(dev_priv);
#line 419
    return (tmp___0);
  } else {

  }
#line 424
  mode = set->mode;
#line 425
  fb = set->fb;
#line 427
  if (set->x + (uint32_t )mode->hdisplay > fb->width || set->y + (uint32_t )mode->vdisplay > fb->height) {
#line 429
    drm_err("vmw_ldu_crtc_set_config", "set outside of framebuffer\n");
#line 430
    return (-22);
  } else {

  }
#line 433
  vmw_fb_off(dev_priv);
#line 435
  crtc->fb = fb;
#line 436
  encoder->crtc = crtc;
#line 437
  connector->encoder = encoder;
#line 438
  crtc->x = (int )set->x;
#line 439
  crtc->y = (int )set->y;
#line 440
  crtc->mode = *mode;
#line 442
  vmw_ldu_add_active(dev_priv, ldu, vfb);
#line 444
  tmp___1 = vmw_ldu_commit_list(dev_priv);
#line 444
  return (tmp___1);
}
}
#line 447 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_crtc_funcs vmw_legacy_crtc_funcs  = 
#line 447
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, 0, & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move,
    & vmw_du_crtc_gamma_set, & vmw_ldu_crtc_destroy, & vmw_ldu_crtc_set_config, 0,
    0};
#line 462 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_encoder_destroy(struct drm_encoder *encoder ) 
{ struct drm_encoder  const  *__mptr ;

  {
#line 464
  __mptr = (struct drm_encoder  const  *)encoder;
#line 464
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffffca8UL);
#line 466
  return;
}
}
#line 467 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_encoder_funcs vmw_legacy_encoder_funcs  =    {0, & vmw_ldu_encoder_destroy};
#line 475 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static void vmw_ldu_connector_destroy(struct drm_connector *connector ) 
{ struct drm_connector  const  *__mptr ;

  {
#line 477
  __mptr = (struct drm_connector  const  *)connector;
#line 477
  vmw_ldu_destroy((struct vmw_legacy_display_unit *)__mptr + 0xfffffffffffffc58UL);
#line 479
  return;
}
}
#line 480 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static struct drm_connector_funcs vmw_legacy_connector_funcs  = 
#line 480
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes, & vmw_du_connector_set_property,
    & vmw_ldu_connector_destroy, 0};
#line 490 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
static int vmw_ldu_init(struct vmw_private *dev_priv , unsigned int unit ) 
{ struct vmw_legacy_display_unit *ldu ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp ;

  {
#line 493
  dev = dev_priv->dev;
#line 498
  tmp = kzalloc(2888UL, 208U);
#line 498
  ldu = (struct vmw_legacy_display_unit *)tmp;
#line 499
  if ((unsigned long )ldu == (unsigned long )((struct vmw_legacy_display_unit *)0)) {
#line 500
    return (-12);
  } else {

  }
#line 502
  ldu->base.unit = unit;
#line 503
  crtc = & ldu->base.crtc;
#line 504
  encoder = & ldu->base.encoder;
#line 505
  connector = & ldu->base.connector;
#line 507
  INIT_LIST_HEAD(& ldu->active);
#line 509
  ldu->base.pref_active = unit == 0U;
#line 510
  ldu->base.pref_width = dev_priv->initial_width;
#line 511
  ldu->base.pref_height = dev_priv->initial_height;
#line 512
  ldu->base.pref_mode = 0;
#line 513
  ldu->base.is_implicit = 1;
#line 515
  drm_connector_init(dev, connector, (struct drm_connector_funcs  const  *)(& vmw_legacy_connector_funcs),
                     15);
#line 517
  connector->status = vmw_du_connector_detect(connector, 1);
#line 519
  drm_encoder_init(dev, encoder, (struct drm_encoder_funcs  const  *)(& vmw_legacy_encoder_funcs),
                   5);
#line 521
  drm_mode_connector_attach_encoder(connector, encoder);
#line 522
  encoder->possible_crtcs = (uint32_t )(1 << (int )unit);
#line 523
  encoder->possible_clones = 0U;
#line 525
  drm_crtc_init(dev, crtc, (struct drm_crtc_funcs  const  *)(& vmw_legacy_crtc_funcs));
#line 527
  drm_mode_crtc_set_gamma_size(crtc, 256);
#line 529
  drm_object_attach_property(& connector->base, dev->mode_config.dirty_info_property,
                             1ULL);
#line 533
  return (0);
}
}
#line 536 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp ;

  {
#line 538
  dev = dev_priv->dev;
#line 541
  if ((unsigned long )dev_priv->ldu_priv != (unsigned long )((struct vmw_legacy_display *)0)) {
#line 542
    printk("\016[drm] ldu system already on\n");
#line 543
    return (-22);
  } else {

  }
#line 546
  tmp = kmalloc(32UL, 208U);
#line 546
  dev_priv->ldu_priv = (struct vmw_legacy_display *)tmp;
#line 547
  if ((unsigned long )dev_priv->ldu_priv == (unsigned long )((struct vmw_legacy_display *)0)) {
#line 548
    return (-12);
  } else {

  }
#line 550
  INIT_LIST_HEAD(& (dev_priv->ldu_priv)->active);
#line 551
  (dev_priv->ldu_priv)->num_active = 0U;
#line 552
  (dev_priv->ldu_priv)->last_num_active = 0U;
#line 553
  (dev_priv->ldu_priv)->fb = 0;
#line 556
  if ((dev_priv->capabilities & 65536U) != 0U) {
#line 557
    ret = drm_vblank_init(dev, 8);
  } else {
#line 559
    ret = drm_vblank_init(dev, 1);
  }
#line 560
  if (ret != 0) {
#line 561
    goto err_free;
  } else {

  }
#line 563
  ret = drm_mode_create_dirty_info_property(dev);
#line 564
  if (ret != 0) {
#line 565
    goto err_vblank_cleanup;
  } else {

  }
#line 567
  if ((dev_priv->capabilities & 65536U) != 0U) {
#line 568
    i = 0;
#line 568
    goto ldv_40932;
    ldv_40931: 
#line 569
    vmw_ldu_init(dev_priv, (unsigned int )i);
#line 568
    i = i + 1;
    ldv_40932: ;
#line 568
    if (i <= 7) {
#line 569
      goto ldv_40931;
    } else {
#line 571
      goto ldv_40933;
    }
    ldv_40933: ;
  } else {
#line 571
    vmw_ldu_init(dev_priv, 0U);
  }
#line 573
  return (0);
  err_vblank_cleanup: 
#line 576
  drm_vblank_cleanup(dev);
  err_free: 
#line 578
  kfree((void const   *)dev_priv->ldu_priv);
#line 579
  dev_priv->ldu_priv = 0;
#line 580
  return (ret);
}
}
#line 583 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int tmp ;
  long tmp___0 ;

  {
#line 585
  dev = dev_priv->dev;
#line 587
  if ((unsigned long )dev_priv->ldu_priv == (unsigned long )((struct vmw_legacy_display *)0)) {
#line 588
    return (-38);
  } else {

  }
#line 590
  drm_vblank_cleanup(dev);
#line 592
  tmp = list_empty((struct list_head  const  *)(& (dev_priv->ldu_priv)->active));
#line 592
  tmp___0 = ldv__builtin_expect(tmp == 0, 0L);
#line 592
  if (tmp___0 != 0L) {
#line 592
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"),
                         "i" (592), "i" (12UL));
    ldv_40938: ;
#line 592
    goto ldv_40938;
  } else {

  }
#line 594
  kfree((void const   *)dev_priv->ldu_priv);
#line 596
  return (0);
}
}
#line 598 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct drm_connector *vmw_legacy_connector_funcs_group0  ;
#line 599 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
uint32_t ldvarg106  ;
#line 600 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
bool ldvarg94  ;
#line 601 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
uint32_t ldvarg91  ;
#line 602 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct drm_encoder *ldvarg80  ;
#line 603 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int ldvarg115  ;
#line 604 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
u16 *ldvarg109  ;
#line 605 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
uint32_t ldvarg111  ;
#line 606 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct drm_crtc *vmw_legacy_crtc_funcs_group0  ;
#line 607 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
uint32_t ldvarg112  ;
#line 608 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct drm_file *ldvarg113  ;
#line 609 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
uint32_t ldvarg114  ;
#line 610 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int ldvarg95  ;
#line 611 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int ldvarg116  ;
#line 612
extern int ldv_vmw_legacy_encoder_funcs_probe_9(void) ;
#line 613 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct drm_mode_set *ldvarg105  ;
#line 614 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
uint32_t ldvarg90  ;
#line 615 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
struct drm_property *ldvarg93  ;
#line 616
extern int ldv_vmw_legacy_crtc_funcs_probe_10(void) ;
#line 617
extern int ldv_vmw_legacy_connector_funcs_probe_8(void) ;
#line 618 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
uint32_t ldvarg110  ;
#line 619 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
u16 *ldvarg108  ;
#line 620 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
uint64_t ldvarg92  ;
#line 621 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
u16 *ldvarg107  ;
#line 623 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_main_exported_8(void) 
{ int tmp ;

  {
#line 625
  tmp = __VERIFIER_nondet_int();
#line 625
  switch (tmp) {
  case 0: ;
#line 628
  if (ldv_state_variable_8 == 1) {
#line 630
    vmw_du_connector_dpms(vmw_legacy_connector_funcs_group0, ldvarg95);
#line 632
    ldv_state_variable_8 = 1;
  } else {

  }
#line 635
  if (ldv_state_variable_8 == 2) {
#line 637
    vmw_du_connector_dpms(vmw_legacy_connector_funcs_group0, ldvarg95);
#line 639
    ldv_state_variable_8 = 2;
  } else {

  }
#line 642
  goto ldv_40970;
  case 1: ;
#line 645
  if (ldv_state_variable_8 == 1) {
#line 647
    vmw_du_connector_detect(vmw_legacy_connector_funcs_group0, (int )ldvarg94);
#line 649
    ldv_state_variable_8 = 1;
  } else {

  }
#line 652
  if (ldv_state_variable_8 == 2) {
#line 654
    vmw_du_connector_detect(vmw_legacy_connector_funcs_group0, (int )ldvarg94);
#line 656
    ldv_state_variable_8 = 2;
  } else {

  }
#line 659
  goto ldv_40970;
  case 2: ;
#line 662
  if (ldv_state_variable_8 == 1) {
#line 664
    vmw_du_connector_set_property(vmw_legacy_connector_funcs_group0, ldvarg93, ldvarg92);
#line 666
    ldv_state_variable_8 = 1;
  } else {

  }
#line 669
  if (ldv_state_variable_8 == 2) {
#line 671
    vmw_du_connector_set_property(vmw_legacy_connector_funcs_group0, ldvarg93, ldvarg92);
#line 673
    ldv_state_variable_8 = 2;
  } else {

  }
#line 676
  goto ldv_40970;
  case 3: ;
#line 679
  if (ldv_state_variable_8 == 2) {
#line 681
    vmw_ldu_connector_destroy(vmw_legacy_connector_funcs_group0);
#line 683
    ldv_state_variable_8 = 1;
#line 684
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 687
  goto ldv_40970;
  case 4: ;
#line 690
  if (ldv_state_variable_8 == 1) {
#line 692
    vmw_du_connector_save(vmw_legacy_connector_funcs_group0);
#line 694
    ldv_state_variable_8 = 1;
  } else {

  }
#line 697
  if (ldv_state_variable_8 == 2) {
#line 699
    vmw_du_connector_save(vmw_legacy_connector_funcs_group0);
#line 701
    ldv_state_variable_8 = 2;
  } else {

  }
#line 704
  goto ldv_40970;
  case 5: ;
#line 707
  if (ldv_state_variable_8 == 1) {
#line 709
    vmw_du_connector_restore(vmw_legacy_connector_funcs_group0);
#line 711
    ldv_state_variable_8 = 1;
  } else {

  }
#line 714
  if (ldv_state_variable_8 == 2) {
#line 716
    vmw_du_connector_restore(vmw_legacy_connector_funcs_group0);
#line 718
    ldv_state_variable_8 = 2;
  } else {

  }
#line 721
  goto ldv_40970;
  case 6: ;
#line 724
  if (ldv_state_variable_8 == 1) {
#line 726
    vmw_du_connector_fill_modes(vmw_legacy_connector_funcs_group0, ldvarg91, ldvarg90);
#line 728
    ldv_state_variable_8 = 1;
  } else {

  }
#line 731
  if (ldv_state_variable_8 == 2) {
#line 733
    vmw_du_connector_fill_modes(vmw_legacy_connector_funcs_group0, ldvarg91, ldvarg90);
#line 735
    ldv_state_variable_8 = 2;
  } else {

  }
#line 738
  goto ldv_40970;
  case 7: ;
#line 741
  if (ldv_state_variable_8 == 1) {
#line 743
    ldv_vmw_legacy_connector_funcs_probe_8();
#line 745
    ldv_state_variable_8 = 2;
#line 746
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 749
  goto ldv_40970;
  default: ;
#line 750
  goto ldv_40970;
  }
  ldv_40970: ;
#line 754
  return;
}
}
#line 756 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_main_exported_10(void) 
{ int tmp ;

  {
#line 758
  tmp = __VERIFIER_nondet_int();
#line 758
  switch (tmp) {
  case 0: ;
#line 761
  if (ldv_state_variable_10 == 1) {
#line 763
    vmw_du_crtc_cursor_move(vmw_legacy_crtc_funcs_group0, ldvarg116, ldvarg115);
#line 765
    ldv_state_variable_10 = 1;
  } else {

  }
#line 768
  if (ldv_state_variable_10 == 2) {
#line 770
    vmw_du_crtc_cursor_move(vmw_legacy_crtc_funcs_group0, ldvarg116, ldvarg115);
#line 772
    ldv_state_variable_10 = 2;
  } else {

  }
#line 775
  goto ldv_40983;
  case 1: ;
#line 778
  if (ldv_state_variable_10 == 1) {
#line 780
    vmw_du_crtc_cursor_set(vmw_legacy_crtc_funcs_group0, ldvarg113, ldvarg112, ldvarg111,
                           ldvarg114);
#line 782
    ldv_state_variable_10 = 1;
  } else {

  }
#line 785
  if (ldv_state_variable_10 == 2) {
#line 787
    vmw_du_crtc_cursor_set(vmw_legacy_crtc_funcs_group0, ldvarg113, ldvarg112, ldvarg111,
                           ldvarg114);
#line 789
    ldv_state_variable_10 = 2;
  } else {

  }
#line 792
  goto ldv_40983;
  case 2: ;
#line 795
  if (ldv_state_variable_10 == 2) {
#line 797
    vmw_ldu_crtc_destroy(vmw_legacy_crtc_funcs_group0);
#line 799
    ldv_state_variable_10 = 1;
#line 800
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 803
  goto ldv_40983;
  case 3: ;
#line 806
  if (ldv_state_variable_10 == 1) {
#line 808
    vmw_du_crtc_save(vmw_legacy_crtc_funcs_group0);
#line 810
    ldv_state_variable_10 = 1;
  } else {

  }
#line 813
  if (ldv_state_variable_10 == 2) {
#line 815
    vmw_du_crtc_save(vmw_legacy_crtc_funcs_group0);
#line 817
    ldv_state_variable_10 = 2;
  } else {

  }
#line 820
  goto ldv_40983;
  case 4: ;
#line 823
  if (ldv_state_variable_10 == 1) {
#line 825
    vmw_du_crtc_gamma_set(vmw_legacy_crtc_funcs_group0, ldvarg109, ldvarg108, ldvarg107,
                          ldvarg110, ldvarg106);
#line 827
    ldv_state_variable_10 = 1;
  } else {

  }
#line 830
  if (ldv_state_variable_10 == 2) {
#line 832
    vmw_du_crtc_gamma_set(vmw_legacy_crtc_funcs_group0, ldvarg109, ldvarg108, ldvarg107,
                          ldvarg110, ldvarg106);
#line 834
    ldv_state_variable_10 = 2;
  } else {

  }
#line 837
  goto ldv_40983;
  case 5: ;
#line 840
  if (ldv_state_variable_10 == 1) {
#line 842
    vmw_du_crtc_restore(vmw_legacy_crtc_funcs_group0);
#line 844
    ldv_state_variable_10 = 1;
  } else {

  }
#line 847
  if (ldv_state_variable_10 == 2) {
#line 849
    vmw_du_crtc_restore(vmw_legacy_crtc_funcs_group0);
#line 851
    ldv_state_variable_10 = 2;
  } else {

  }
#line 854
  goto ldv_40983;
  case 6: ;
#line 857
  if (ldv_state_variable_10 == 1) {
#line 859
    vmw_ldu_crtc_set_config(ldvarg105);
#line 861
    ldv_state_variable_10 = 1;
  } else {

  }
#line 864
  if (ldv_state_variable_10 == 2) {
#line 866
    vmw_ldu_crtc_set_config(ldvarg105);
#line 868
    ldv_state_variable_10 = 2;
  } else {

  }
#line 871
  goto ldv_40983;
  case 7: ;
#line 874
  if (ldv_state_variable_10 == 1) {
#line 876
    ldv_vmw_legacy_crtc_funcs_probe_10();
#line 878
    ldv_state_variable_10 = 2;
#line 879
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 882
  goto ldv_40983;
  default: ;
#line 883
  goto ldv_40983;
  }
  ldv_40983: ;
#line 887
  return;
}
}
#line 889 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_main_exported_9(void) 
{ int tmp ;

  {
#line 891
  tmp = __VERIFIER_nondet_int();
#line 891
  switch (tmp) {
  case 0: ;
#line 894
  if (ldv_state_variable_9 == 2) {
#line 896
    vmw_ldu_encoder_destroy(ldvarg80);
#line 898
    ldv_state_variable_9 = 1;
#line 899
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 902
  goto ldv_40996;
  case 1: ;
#line 905
  if (ldv_state_variable_9 == 1) {
#line 907
    ldv_vmw_legacy_encoder_funcs_probe_9();
#line 909
    ldv_state_variable_9 = 2;
#line 910
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 913
  goto ldv_40996;
  default: ;
#line 914
  goto ldv_40996;
  }
  ldv_40996: ;
#line 918
  return;
}
}
#line 919 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_425(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 924
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 926
  mutex_lock(ldv_func_arg1);
#line 927
  return;
}
}
#line 929 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 934
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 936
  mutex_unlock(ldv_func_arg1);
#line 937
  return;
}
}
#line 939 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_427(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 944
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 946
  mutex_lock(ldv_func_arg1);
#line 947
  return;
}
}
#line 949 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
int ldv_mutex_trylock_428(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 954
  tmp = mutex_trylock(ldv_func_arg1);
#line 954
  ldv_func_res = tmp;
#line 956
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 956
  return (tmp___0);
#line 958
  return (ldv_func_res);
}
}
#line 961 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_429(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 966
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 968
  mutex_unlock(ldv_func_arg1);
#line 969
  return;
}
}
#line 971 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_430(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 976
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 978
  mutex_lock(ldv_func_arg1);
#line 979
  return;
}
}
#line 981 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 986
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 988
  mutex_unlock(ldv_func_arg1);
#line 989
  return;
}
}
#line 991 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 996
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 998
  mutex_lock(ldv_func_arg1);
#line 999
  return;
}
}
#line 1001 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1006
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1008
  mutex_unlock(ldv_func_arg1);
#line 1009
  return;
}
}
#line 1011 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_434(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1016
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 1018
  mutex_unlock(ldv_func_arg1);
#line 1019
  return;
}
}
#line 1021 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_435(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1026
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1028
  mutex_lock(ldv_func_arg1);
#line 1029
  return;
}
}
#line 1031 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_436(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1036
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1038
  mutex_unlock(ldv_func_arg1);
#line 1039
  return;
}
}
#line 1041 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_lock_437(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1046
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1048
  mutex_lock(ldv_func_arg1);
#line 1049
  return;
}
}
#line 1051 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c.prepared"
void ldv_mutex_unlock_438(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1056
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1058
  mutex_unlock(ldv_func_arg1);
#line 1059
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_456(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_459(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_461(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_462(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_464(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_466(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_453(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_455(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_458(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_460(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_463(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_465(struct mutex *ldv_func_arg1 ) ;
#line 50 "include/drm/drm_global.h"
extern int drm_global_item_ref(struct drm_global_reference * ) ;
#line 51
extern void drm_global_item_unref(struct drm_global_reference * ) ;
#line 698 "include/drm/ttm/ttm_bo_api.h"
extern int ttm_bo_mmap(struct file * , struct vm_area_struct * , struct ttm_bo_device * ) ;
#line 146 "include/drm/ttm/ttm_memory.h"
extern int ttm_mem_global_init(struct ttm_mem_global * ) ;
#line 147
extern void ttm_mem_global_release(struct ttm_mem_global * ) ;
#line 728 "include/drm/ttm/ttm_bo_driver.h"
extern void ttm_bo_global_release(struct drm_global_reference * ) ;
#line 729
extern int ttm_bo_global_init(struct drm_global_reference * ) ;
#line 183 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int vmw_mmap(struct file *filp , struct vm_area_struct *vma ) 
{ struct drm_file *file_priv ;
  struct vmw_private *dev_priv ;
  long tmp ;
  int tmp___0 ;

  {
#line 188
  tmp = ldv__builtin_expect(vma->vm_pgoff <= 1048575UL, 0L);
#line 188
  if (tmp != 0L) {
#line 189
    drm_err("vmw_mmap", "Illegal attempt to mmap old fifo space.\n");
#line 190
    return (-22);
  } else {

  }
#line 193
  file_priv = (struct drm_file *)filp->private_data;
#line 194
  dev_priv = vmw_priv((file_priv->minor)->dev);
#line 195
  tmp___0 = ttm_bo_mmap(filp, vma, & dev_priv->bdev);
#line 195
  return (tmp___0);
}
}
#line 198 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
static int vmw_ttm_mem_global_init(struct drm_global_reference *ref ) 
{ int tmp ;

  {
#line 200
  printk("\016[drm] global init.\n");
#line 201
  tmp = ttm_mem_global_init((struct ttm_mem_global *)ref->object);
#line 201
  return (tmp);
}
}
#line 204 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
static void vmw_ttm_mem_global_release(struct drm_global_reference *ref ) 
{ 

  {
#line 206
  ttm_mem_global_release((struct ttm_mem_global *)ref->object);
#line 207
  return;
}
}
#line 209 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int vmw_ttm_global_init(struct vmw_private *dev_priv ) 
{ struct drm_global_reference *global_ref ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 214
  global_ref = & dev_priv->mem_global_ref;
#line 215
  global_ref->global_type = 0;
#line 216
  global_ref->size = 272UL;
#line 217
  global_ref->init = & vmw_ttm_mem_global_init;
#line 218
  global_ref->release = & vmw_ttm_mem_global_release;
#line 220
  ret = drm_global_item_ref(global_ref);
#line 221
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 221
  if (tmp != 0L) {
#line 222
    drm_err("vmw_ttm_global_init", "Failed setting up TTM memory accounting.\n");
#line 223
    return (ret);
  } else {

  }
#line 226
  dev_priv->bo_global_ref.mem_glob = (struct ttm_mem_global *)dev_priv->mem_global_ref.object;
#line 228
  global_ref = & dev_priv->bo_global_ref.ref;
#line 229
  global_ref->global_type = 1;
#line 230
  global_ref->size = 368UL;
#line 231
  global_ref->init = & ttm_bo_global_init;
#line 232
  global_ref->release = & ttm_bo_global_release;
#line 233
  ret = drm_global_item_ref(global_ref);
#line 235
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 235
  if (tmp___0 != 0L) {
#line 236
    drm_err("vmw_ttm_global_init", "Failed setting up TTM buffer objects.\n");
#line 237
    goto out_no_bo;
  } else {

  }
#line 240
  return (0);
  out_no_bo: 
#line 242
  drm_global_item_unref(& dev_priv->mem_global_ref);
#line 243
  return (ret);
}
}
#line 246 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void vmw_ttm_global_release(struct vmw_private *dev_priv ) 
{ 

  {
#line 248
  drm_global_item_unref(& dev_priv->bo_global_ref.ref);
#line 249
  drm_global_item_unref(& dev_priv->mem_global_ref);
#line 250
  return;
}
}
#line 252 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_453(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 257
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 259
  mutex_lock(ldv_func_arg1);
#line 260
  return;
}
}
#line 262 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_454(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 267
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 269
  mutex_unlock(ldv_func_arg1);
#line 270
  return;
}
}
#line 272 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_455(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 277
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 279
  mutex_lock(ldv_func_arg1);
#line 280
  return;
}
}
#line 282 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
int ldv_mutex_trylock_456(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 287
  tmp = mutex_trylock(ldv_func_arg1);
#line 287
  ldv_func_res = tmp;
#line 289
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 289
  return (tmp___0);
#line 291
  return (ldv_func_res);
}
}
#line 294 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 299
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 301
  mutex_unlock(ldv_func_arg1);
#line 302
  return;
}
}
#line 304 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_458(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 309
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 311
  mutex_lock(ldv_func_arg1);
#line 312
  return;
}
}
#line 314 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_459(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 319
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 321
  mutex_unlock(ldv_func_arg1);
#line 322
  return;
}
}
#line 324 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_460(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 329
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 331
  mutex_lock(ldv_func_arg1);
#line 332
  return;
}
}
#line 334 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_461(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 339
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 341
  mutex_unlock(ldv_func_arg1);
#line 342
  return;
}
}
#line 344 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_462(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 349
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 351
  mutex_unlock(ldv_func_arg1);
#line 352
  return;
}
}
#line 354 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_463(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 359
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 361
  mutex_lock(ldv_func_arg1);
#line 362
  return;
}
}
#line 364 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_464(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 369
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 371
  mutex_unlock(ldv_func_arg1);
#line 372
  return;
}
}
#line 374 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_lock_465(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 379
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 381
  mutex_lock(ldv_func_arg1);
#line 382
  return;
}
}
#line 384 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_ttm_glue.c.prepared"
void ldv_mutex_unlock_466(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 389
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 391
  mutex_unlock(ldv_func_arg1);
#line 392
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_484(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_485(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_490(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_492(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_496(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_498(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_500(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_502(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_504(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_507(struct mutex *ldv_func_arg1 ) ;
#line 232
void ldv_mutex_unlock_509(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_481(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_483(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_486(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_491(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_493(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_495(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_497(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_499(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_501(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_503(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) ;
#line 58
void ldv_mutex_lock_508(struct mutex *ldv_func_arg1 ) ;
#line 143
void ldv_mutex_lock_mutex_of_vmw_overlay(struct mutex *lock ) ;
#line 147
void ldv_mutex_unlock_mutex_of_vmw_overlay(struct mutex *lock ) ;
#line 499 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) ;
#line 502
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) ;
#line 511
void vmw_bo_get_guest_ptr(struct ttm_buffer_object  const  *bo , SVGAGuestPtr *ptr ) ;
#line 226 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
__inline static void fill_escape(struct vmw_escape_header *header , uint32_t size ) 
{ 

  {
#line 229
  header->cmd = 33U;
#line 230
  header->body.nsid = 0U;
#line 231
  header->body.size = size;
#line 232
  return;
}
}
#line 234 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
__inline static void fill_flush(struct vmw_escape_video_flush *cmd , uint32_t stream_id ) 
{ 

  {
#line 237
  fill_escape(& cmd->escape, 8U);
#line 238
  cmd->flush.cmdType = 131074U;
#line 239
  cmd->flush.streamId = stream_id;
#line 240
  return;
}
}
#line 248 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_send_put(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ struct vmw_escape_video_flush *flush ;
  size_t fifo_size ;
  bool have_so ;
  int i ;
  int num_items ;
  SVGAGuestPtr ptr ;
  struct __anonstruct_cmds_303 *cmds ;
  struct __anonstruct_items_306 *items ;
  void *tmp ;

  {
#line 255
  have_so = (unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0);
#line 272
  if ((int )have_so) {
#line 273
    num_items = 21;
  } else {
#line 275
    num_items = 19;
  }
#line 277
  fifo_size = ((unsigned long )num_items + 5UL) * 8UL;
#line 279
  tmp = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 279
  cmds = (struct __anonstruct_309___0 *)tmp;
#line 281
  if ((unsigned long )cmds == (unsigned long )((struct __anonstruct_cmds_303 *)0)) {
#line 282
    return (-12);
  } else {

  }
#line 284
  items = (struct __anonstruct_312 *)cmds + 1U;
#line 285
  flush = (struct vmw_escape_video_flush *)items + (unsigned long )num_items;
#line 288
  fill_escape(& cmds->escape, (uint32_t )((unsigned long )(num_items + 1)) * 8U);
#line 290
  cmds->header.cmdType = 131073U;
#line 291
  cmds->header.streamId = arg->stream_id;
#line 294
  i = 0;
#line 294
  goto ldv_40743;
  ldv_40742: 
#line 295
  (items + (unsigned long )i)->registerId = (uint32_t )i;
#line 294
  i = i + 1;
  ldv_40743: ;
#line 294
  if (i < num_items) {
#line 295
    goto ldv_40742;
  } else {
#line 297
    goto ldv_40744;
  }
  ldv_40744: 
#line 297
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)(& buf->base), & ptr);
#line 298
  ptr.offset = ptr.offset + arg->offset;
#line 300
  items->value = 1U;
#line 301
  (items + 1UL)->value = arg->flags;
#line 302
  (items + 2UL)->value = ptr.offset;
#line 303
  (items + 3UL)->value = (uint32_t )arg->format;
#line 304
  (items + 4UL)->value = arg->color_key;
#line 305
  (items + 5UL)->value = arg->size;
#line 306
  (items + 6UL)->value = arg->width;
#line 307
  (items + 7UL)->value = arg->height;
#line 308
  (items + 8UL)->value = (uint32_t )arg->src.x;
#line 309
  (items + 9UL)->value = (uint32_t )arg->src.y;
#line 310
  (items + 10UL)->value = arg->src.w;
#line 311
  (items + 11UL)->value = arg->src.h;
#line 312
  (items + 12UL)->value = (uint32_t )arg->dst.x;
#line 313
  (items + 13UL)->value = (uint32_t )arg->dst.y;
#line 314
  (items + 14UL)->value = arg->dst.w;
#line 315
  (items + 15UL)->value = arg->dst.h;
#line 316
  (items + 16UL)->value = arg->pitch[0];
#line 317
  (items + 17UL)->value = arg->pitch[1];
#line 318
  (items + 18UL)->value = arg->pitch[2];
#line 319
  if ((int )have_so) {
#line 320
    (items + 19UL)->value = ptr.gmrId;
#line 321
    (items + 20UL)->value = 4294967295U;
  } else {

  }
#line 324
  fill_flush(flush, arg->stream_id);
#line 326
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 328
  return (0);
}
}
#line 337 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_send_stop(struct vmw_private *dev_priv , uint32_t stream_id ,
                                 bool interruptible ) 
{ struct __anonstruct_cmds_314 *cmds ;
  int ret ;
  void *tmp ;
  long tmp___0 ;

  {
  ldv_40758: 
#line 349
  tmp = vmw_fifo_reserve(dev_priv, 48U);
#line 349
  cmds = (struct __anonstruct_316 *)tmp;
#line 350
  if ((unsigned long )cmds != (unsigned long )((struct __anonstruct_cmds_314 *)0)) {
#line 351
    goto ldv_40756;
  } else {

  }
#line 353
  ret = vmw_fallback_wait(dev_priv, 0, 1, 0U, (int )interruptible, 750UL);
#line 355
  if ((int )interruptible && ret == -512) {
#line 356
    return (ret);
  } else {
#line 358
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 358
    if (tmp___0 != 0L) {
#line 358
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                           "i" (358), "i" (12UL));
      ldv_40757: ;
#line 358
      goto ldv_40757;
    } else {

    }
  }
#line 359
  goto ldv_40758;
  ldv_40756: 
#line 361
  fill_escape(& cmds->escape, 16U);
#line 362
  cmds->body.header.cmdType = 131073U;
#line 363
  cmds->body.header.streamId = stream_id;
#line 364
  cmds->body.items[0].registerId = 0U;
#line 365
  cmds->body.items[0].value = 0U;
#line 366
  fill_flush(& cmds->flush, stream_id);
#line 368
  vmw_fifo_commit(dev_priv, 48U);
#line 370
  return (0);
}
}
#line 379 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_move_buffer(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                   bool pin , bool inter ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 383
  if (! pin) {
#line 384
    tmp = vmw_dmabuf_unpin(dev_priv, buf, (int )inter);
#line 384
    return (tmp);
  } else {

  }
#line 386
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 387
    tmp___0 = vmw_dmabuf_to_vram(dev_priv, buf, 1, (int )inter);
#line 387
    return (tmp___0);
  } else {

  }
#line 389
  tmp___1 = vmw_dmabuf_to_vram_or_gmr(dev_priv, buf, 1, (int )inter);
#line 389
  return (tmp___1);
}
}
#line 404 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_stop(struct vmw_private *dev_priv , uint32_t stream_id , bool pause ,
                            bool interruptible ) 
{ struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  long tmp ;

  {
#line 408
  overlay = dev_priv->overlay_priv;
#line 409
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )stream_id;
#line 413
  if ((unsigned long )stream->buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 414
    return (0);
  } else {

  }
#line 417
  if (! stream->paused) {
#line 418
    ret = vmw_overlay_send_stop(dev_priv, stream_id, (int )interruptible);
#line 420
    if (ret != 0) {
#line 421
      return (ret);
    } else {

    }
#line 424
    ret = vmw_overlay_move_buffer(dev_priv, stream->buf, 0, (int )interruptible);
#line 426
    if ((int )interruptible && ret == -512) {
#line 427
      return (ret);
    } else {
#line 429
      tmp = ldv__builtin_expect(ret != 0, 0L);
#line 429
      if (tmp != 0L) {
#line 429
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                             "i" (429), "i" (12UL));
        ldv_40774: ;
#line 429
        goto ldv_40774;
      } else {

      }
    }
  } else {

  }
#line 432
  if (! pause) {
#line 433
    vmw_dmabuf_unreference(& stream->buf);
#line 434
    stream->paused = 0;
  } else {
#line 436
    stream->paused = 1;
  }
#line 439
  return (0);
}
}
#line 451 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static int vmw_overlay_update_stream(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                     struct drm_vmw_control_stream_arg *arg , bool interruptible ) 
{ struct vmw_overlay *overlay ;
  struct vmw_stream___0 *stream ;
  int ret ;
  char *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 456
  overlay = dev_priv->overlay_priv;
#line 457
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )arg->stream_id;
#line 458
  ret = 0;
#line 460
  if ((unsigned long )buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 461
    return (-22);
  } else {

  }
#line 463
  if ((int )stream->paused) {
#line 463
    tmp = (char *)"";
  } else {
#line 463
    tmp = (char *)"not ";
  }
#line 463
  drm_ut_debug_printk(1U, "drm", "vmw_overlay_update_stream", "   %s: old %p, new %p, %spaused\n",
                      "vmw_overlay_update_stream", stream->buf, buf, tmp);
#line 466
  if ((unsigned long )stream->buf != (unsigned long )buf) {
#line 467
    ret = vmw_overlay_stop(dev_priv, arg->stream_id, 0, (int )interruptible);
#line 469
    if (ret != 0) {
#line 470
      return (ret);
    } else {

    }
  } else
#line 471
  if (! stream->paused) {
#line 475
    ret = vmw_overlay_send_put(dev_priv, buf, arg, (int )interruptible);
#line 476
    if (ret == 0) {
#line 477
      stream->saved = *arg;
    } else {
#line 479
      tmp___0 = ldv__builtin_expect((long )(! interruptible), 0L);
#line 479
      if (tmp___0 != 0L) {
#line 479
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                             "i" (479), "i" (12UL));
        ldv_40785: ;
#line 479
        goto ldv_40785;
      } else {

      }
    }
#line 481
    return (ret);
  } else {

  }
#line 487
  ret = vmw_overlay_move_buffer(dev_priv, buf, 1, (int )interruptible);
#line 488
  if (ret != 0) {
#line 489
    return (ret);
  } else {

  }
#line 491
  ret = vmw_overlay_send_put(dev_priv, buf, arg, (int )interruptible);
#line 492
  if (ret != 0) {
#line 496
    tmp___1 = vmw_overlay_move_buffer(dev_priv, buf, 0, 0);
#line 496
    tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
#line 496
    if (tmp___2 != 0L) {
#line 496
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                           "i" (497), "i" (12UL));
      ldv_40786: ;
#line 496
      goto ldv_40786;
    } else {

    }
#line 498
    return (ret);
  } else {

  }
#line 501
  if ((unsigned long )stream->buf != (unsigned long )buf) {
#line 502
    stream->buf = vmw_dmabuf_reference(buf);
  } else {

  }
#line 503
  stream->saved = *arg;
#line 505
  stream->paused = 0;
#line 507
  return (0);
}
}
#line 517 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_stop_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 519
  overlay = dev_priv->overlay_priv;
#line 522
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 523
    return (0);
  } else {

  }
#line 525
  ldv_mutex_lock_495(& overlay->mutex);
#line 527
  i = 0;
#line 527
  goto ldv_40798;
  ldv_40797: 
#line 528
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )i;
#line 529
  if ((unsigned long )stream->buf == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 530
    goto ldv_40794;
  } else {

  }
#line 532
  ret = vmw_overlay_stop(dev_priv, (uint32_t )i, 0, 0);
#line 533
  __ret_warn_on = ret != 0;
#line 533
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 533
  if (tmp != 0L) {
#line 533
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       533);
  } else {

  }
#line 533
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  ldv_40794: 
#line 527
  i = i + 1;
  ldv_40798: ;
#line 527
  if (i <= 0) {
#line 528
    goto ldv_40797;
  } else {
#line 530
    goto ldv_40799;
  }
  ldv_40799: 
#line 536
  ldv_mutex_unlock_496(& overlay->mutex);
#line 538
  return (0);
}
}
#line 548 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_resume_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  struct vmw_stream___0 *stream ;

  {
#line 550
  overlay = dev_priv->overlay_priv;
#line 553
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 554
    return (0);
  } else {

  }
#line 556
  ldv_mutex_lock_497(& overlay->mutex);
#line 558
  i = 0;
#line 558
  goto ldv_40810;
  ldv_40809: 
#line 559
  stream = (struct vmw_stream___0 *)(& overlay->stream) + (unsigned long )i;
#line 560
  if (! stream->paused) {
#line 561
    goto ldv_40807;
  } else {

  }
#line 563
  ret = vmw_overlay_update_stream(dev_priv, stream->buf, & stream->saved, 0);
#line 565
  if (ret != 0) {
#line 566
    printk("\016[drm] %s: *warning* failed to resume stream %i\n", "vmw_overlay_resume_all",
           i);
  } else {

  }
  ldv_40807: 
#line 558
  i = i + 1;
  ldv_40810: ;
#line 558
  if (i <= 0) {
#line 559
    goto ldv_40809;
  } else {
#line 561
    goto ldv_40811;
  }
  ldv_40811: 
#line 570
  ldv_mutex_unlock_498(& overlay->mutex);
#line 572
  return (0);
}
}
#line 582 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_pause_all(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 584
  overlay = dev_priv->overlay_priv;
#line 587
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 588
    return (0);
  } else {

  }
#line 590
  ldv_mutex_lock_499(& overlay->mutex);
#line 592
  i = 0;
#line 592
  goto ldv_40822;
  ldv_40821: ;
#line 593
  if ((int )overlay->stream[i].paused) {
#line 594
    printk("\016[drm] %s: *warning* stream %i already paused\n", "vmw_overlay_pause_all",
           i);
  } else {

  }
#line 596
  ret = vmw_overlay_stop(dev_priv, (uint32_t )i, 1, 0);
#line 597
  __ret_warn_on = ret != 0;
#line 597
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 597
  if (tmp != 0L) {
#line 597
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       597);
  } else {

  }
#line 597
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 592
  i = i + 1;
  ldv_40822: ;
#line 592
  if (i <= 0) {
#line 593
    goto ldv_40821;
  } else {
#line 595
    goto ldv_40823;
  }
  ldv_40823: 
#line 600
  ldv_mutex_unlock_500(& overlay->mutex);
#line 602
  return (0);
}
}
#line 606 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
static bool vmw_overlay_available(struct vmw_private  const  *dev_priv ) 
{ 

  {
#line 608
  return ((bool )((unsigned long )dev_priv->overlay_priv != (unsigned long )((struct vmw_overlay */* const  */)0) && ((unsigned int )dev_priv->fifo.capabilities & 40U) == 40U));
}
}
#line 613 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  struct vmw_overlay *overlay ;
  struct drm_vmw_control_stream_arg *arg ;
  struct vmw_dma_buffer *buf ;
  struct vmw_resource *res ;
  int ret ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 616
  tmp = vmw_fpriv(file_priv);
#line 616
  tfile = tmp->tfile;
#line 617
  tmp___0 = vmw_priv(dev);
#line 617
  dev_priv = tmp___0;
#line 618
  overlay = dev_priv->overlay_priv;
#line 619
  arg = (struct drm_vmw_control_stream_arg *)data;
#line 625
  tmp___1 = vmw_overlay_available((struct vmw_private  const  *)dev_priv);
#line 625
  if (tmp___1) {
#line 625
    tmp___2 = 0;
  } else {
#line 625
    tmp___2 = 1;
  }
#line 625
  if (tmp___2) {
#line 626
    return (-38);
  } else {

  }
#line 628
  ret = vmw_user_stream_lookup(dev_priv, tfile, & arg->stream_id, & res);
#line 629
  if (ret != 0) {
#line 630
    return (ret);
  } else {

  }
#line 632
  ldv_mutex_lock_501(& overlay->mutex);
#line 634
  if (arg->enabled == 0U) {
#line 635
    ret = vmw_overlay_stop(dev_priv, arg->stream_id, 0, 1);
#line 636
    goto out_unlock;
  } else {

  }
#line 639
  ret = vmw_user_dmabuf_lookup(tfile, arg->handle, & buf);
#line 640
  if (ret != 0) {
#line 641
    goto out_unlock;
  } else {

  }
#line 643
  ret = vmw_overlay_update_stream(dev_priv, buf, arg, 1);
#line 645
  vmw_dmabuf_unreference(& buf);
  out_unlock: 
#line 648
  ldv_mutex_unlock_502(& overlay->mutex);
#line 649
  vmw_resource_unreference(& res);
#line 651
  return (ret);
}
}
#line 654 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_num_overlays(struct vmw_private *dev_priv ) 
{ bool tmp ;
  int tmp___0 ;

  {
#line 656
  tmp = vmw_overlay_available((struct vmw_private  const  *)dev_priv);
#line 656
  if (tmp) {
#line 656
    tmp___0 = 0;
  } else {
#line 656
    tmp___0 = 1;
  }
#line 656
  if (tmp___0) {
#line 657
    return (0);
  } else {

  }
#line 659
  return (1);
}
}
#line 662 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_num_free_overlays(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  int k ;
  bool tmp ;
  int tmp___0 ;

  {
#line 664
  overlay = dev_priv->overlay_priv;
#line 667
  tmp = vmw_overlay_available((struct vmw_private  const  *)dev_priv);
#line 667
  if (tmp) {
#line 667
    tmp___0 = 0;
  } else {
#line 667
    tmp___0 = 1;
  }
#line 667
  if (tmp___0) {
#line 668
    return (0);
  } else {

  }
#line 670
  ldv_mutex_lock_503(& overlay->mutex);
#line 672
  i = 0;
#line 672
  k = 0;
#line 672
  goto ldv_40850;
  ldv_40849: ;
#line 673
  if (! overlay->stream[i].claimed) {
#line 674
    k = k + 1;
  } else {

  }
#line 672
  i = i + 1;
  ldv_40850: ;
#line 672
  if (i <= 0) {
#line 673
    goto ldv_40849;
  } else {
#line 675
    goto ldv_40851;
  }
  ldv_40851: 
#line 676
  ldv_mutex_unlock_504(& overlay->mutex);
#line 678
  return (k);
}
}
#line 681 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_claim(struct vmw_private *dev_priv , uint32_t *out ) 
{ struct vmw_overlay *overlay ;
  int i ;

  {
#line 683
  overlay = dev_priv->overlay_priv;
#line 686
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 687
    return (-38);
  } else {

  }
#line 689
  ldv_mutex_lock_505(& overlay->mutex);
#line 691
  i = 0;
#line 691
  goto ldv_40860;
  ldv_40859: ;
#line 693
  if ((int )overlay->stream[i].claimed) {
#line 694
    goto ldv_40858;
  } else {

  }
#line 696
  overlay->stream[i].claimed = 1;
#line 697
  *out = (uint32_t )i;
#line 698
  ldv_mutex_unlock_506(& overlay->mutex);
#line 699
  return (0);
  ldv_40858: 
#line 691
  i = i + 1;
  ldv_40860: ;
#line 691
  if (i <= 0) {
#line 692
    goto ldv_40859;
  } else {
#line 694
    goto ldv_40861;
  }
  ldv_40861: 
#line 702
  ldv_mutex_unlock_507(& overlay->mutex);
#line 703
  return (-3);
}
}
#line 706 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_unref(struct vmw_private *dev_priv , uint32_t stream_id ) 
{ struct vmw_overlay *overlay ;
  long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
#line 708
  overlay = dev_priv->overlay_priv;
#line 710
  tmp = ldv__builtin_expect(stream_id != 0U, 0L);
#line 710
  if (tmp != 0L) {
#line 710
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"),
                         "i" (710), "i" (12UL));
    ldv_40867: ;
#line 710
    goto ldv_40867;
  } else {

  }
#line 712
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 713
    return (-38);
  } else {

  }
#line 715
  ldv_mutex_lock_508(& overlay->mutex);
#line 717
  __ret_warn_on = ! overlay->stream[stream_id].claimed;
#line 717
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 717
  if (tmp___0 != 0L) {
#line 717
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       717);
  } else {

  }
#line 717
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 718
  vmw_overlay_stop(dev_priv, stream_id, 0, 0);
#line 719
  overlay->stream[stream_id].claimed = 0;
#line 721
  ldv_mutex_unlock_509(& overlay->mutex);
#line 722
  return (0);
}
}
#line 725 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_init(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  int i ;
  void *tmp ;
  struct lock_class_key __key ;

  {
#line 730
  if ((unsigned long )dev_priv->overlay_priv != (unsigned long )((struct vmw_overlay *)0)) {
#line 731
    return (-22);
  } else {

  }
#line 733
  tmp = kzalloc(272UL, 208U);
#line 733
  overlay = (struct vmw_overlay *)tmp;
#line 734
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 735
    return (-12);
  } else {

  }
#line 737
  __mutex_init(& overlay->mutex, "&overlay->mutex", & __key);
#line 738
  i = 0;
#line 738
  goto ldv_40877;
  ldv_40876: 
#line 739
  overlay->stream[i].buf = 0;
#line 740
  overlay->stream[i].paused = 0;
#line 741
  overlay->stream[i].claimed = 0;
#line 738
  i = i + 1;
  ldv_40877: ;
#line 738
  if (i <= 0) {
#line 739
    goto ldv_40876;
  } else {
#line 741
    goto ldv_40878;
  }
  ldv_40878: 
#line 744
  dev_priv->overlay_priv = overlay;
#line 746
  return (0);
}
}
#line 749 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int vmw_overlay_close(struct vmw_private *dev_priv ) 
{ struct vmw_overlay *overlay ;
  bool forgotten_buffer ;
  int i ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 751
  overlay = dev_priv->overlay_priv;
#line 752
  forgotten_buffer = 0;
#line 755
  if ((unsigned long )overlay == (unsigned long )((struct vmw_overlay *)0)) {
#line 756
    return (-38);
  } else {

  }
#line 758
  i = 0;
#line 758
  goto ldv_40886;
  ldv_40885: ;
#line 759
  if ((unsigned long )overlay->stream[i].buf != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 760
    forgotten_buffer = 1;
#line 761
    vmw_overlay_stop(dev_priv, (uint32_t )i, 0, 0);
  } else {

  }
#line 758
  i = i + 1;
  ldv_40886: ;
#line 758
  if (i <= 0) {
#line 759
    goto ldv_40885;
  } else {
#line 761
    goto ldv_40887;
  }
  ldv_40887: 
#line 765
  __ret_warn_on = (int )forgotten_buffer;
#line 765
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 765
  if (tmp != 0L) {
#line 765
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared",
                       765);
  } else {

  }
#line 765
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 767
  dev_priv->overlay_priv = 0;
#line 768
  kfree((void const   *)overlay);
#line 770
  return (0);
}
}
#line 773 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_481(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 778
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 780
  mutex_lock(ldv_func_arg1);
#line 781
  return;
}
}
#line 783 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 788
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 790
  mutex_unlock(ldv_func_arg1);
#line 791
  return;
}
}
#line 793 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_483(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 798
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 800
  mutex_lock(ldv_func_arg1);
#line 801
  return;
}
}
#line 803 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
int ldv_mutex_trylock_484(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 808
  tmp = mutex_trylock(ldv_func_arg1);
#line 808
  ldv_func_res = tmp;
#line 810
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 810
  return (tmp___0);
#line 812
  return (ldv_func_res);
}
}
#line 815 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_485(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 820
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 822
  mutex_unlock(ldv_func_arg1);
#line 823
  return;
}
}
#line 825 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_486(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 830
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 832
  mutex_lock(ldv_func_arg1);
#line 833
  return;
}
}
#line 835 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 840
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 842
  mutex_unlock(ldv_func_arg1);
#line 843
  return;
}
}
#line 845 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 850
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 852
  mutex_lock(ldv_func_arg1);
#line 853
  return;
}
}
#line 855 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 860
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 862
  mutex_unlock(ldv_func_arg1);
#line 863
  return;
}
}
#line 865 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_490(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 870
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 872
  mutex_unlock(ldv_func_arg1);
#line 873
  return;
}
}
#line 875 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_491(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 880
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 882
  mutex_lock(ldv_func_arg1);
#line 883
  return;
}
}
#line 885 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_492(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 890
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 892
  mutex_unlock(ldv_func_arg1);
#line 893
  return;
}
}
#line 895 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_493(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 900
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 902
  mutex_lock(ldv_func_arg1);
#line 903
  return;
}
}
#line 905 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_494(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 910
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 912
  mutex_unlock(ldv_func_arg1);
#line 913
  return;
}
}
#line 915 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_495(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 920
  ldv_mutex_lock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 922
  mutex_lock(ldv_func_arg1);
#line 923
  return;
}
}
#line 925 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_496(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 930
  ldv_mutex_unlock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 932
  mutex_unlock(ldv_func_arg1);
#line 933
  return;
}
}
#line 935 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_497(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 940
  ldv_mutex_lock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 942
  mutex_lock(ldv_func_arg1);
#line 943
  return;
}
}
#line 945 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_498(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 950
  ldv_mutex_unlock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 952
  mutex_unlock(ldv_func_arg1);
#line 953
  return;
}
}
#line 955 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_499(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 960
  ldv_mutex_lock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 962
  mutex_lock(ldv_func_arg1);
#line 963
  return;
}
}
#line 965 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_500(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 970
  ldv_mutex_unlock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 972
  mutex_unlock(ldv_func_arg1);
#line 973
  return;
}
}
#line 975 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_501(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 980
  ldv_mutex_lock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 982
  mutex_lock(ldv_func_arg1);
#line 983
  return;
}
}
#line 985 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_502(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 990
  ldv_mutex_unlock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 992
  mutex_unlock(ldv_func_arg1);
#line 993
  return;
}
}
#line 995 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_503(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1000
  ldv_mutex_lock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 1002
  mutex_lock(ldv_func_arg1);
#line 1003
  return;
}
}
#line 1005 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_504(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1010
  ldv_mutex_unlock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 1012
  mutex_unlock(ldv_func_arg1);
#line 1013
  return;
}
}
#line 1015 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1020
  ldv_mutex_lock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 1022
  mutex_lock(ldv_func_arg1);
#line 1023
  return;
}
}
#line 1025 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1030
  ldv_mutex_unlock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 1032
  mutex_unlock(ldv_func_arg1);
#line 1033
  return;
}
}
#line 1035 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_507(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1040
  ldv_mutex_unlock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 1042
  mutex_unlock(ldv_func_arg1);
#line 1043
  return;
}
}
#line 1045 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_lock_508(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1050
  ldv_mutex_lock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 1052
  mutex_lock(ldv_func_arg1);
#line 1053
  return;
}
}
#line 1055 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c.prepared"
void ldv_mutex_unlock_509(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1060
  ldv_mutex_unlock_mutex_of_vmw_overlay(ldv_func_arg1);
#line 1062
  mutex_unlock(ldv_func_arg1);
#line 1063
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_542(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_543(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_545(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_547(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_548(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_550(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_552(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_539(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_541(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_546(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_549(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_551(struct mutex *ldv_func_arg1 ) ;
#line 33 "include/linux/time.h"
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs ) 
{ 

  {
#line 35
  if ((long )lhs->tv_sec < (long )rhs->tv_sec) {
#line 36
    return (-1);
  } else {

  }
#line 37
  if ((long )lhs->tv_sec > (long )rhs->tv_sec) {
#line 38
    return (1);
  } else {

  }
#line 39
  return ((int )((unsigned int )lhs->tv_nsec - (unsigned int )rhs->tv_nsec));
}
}
#line 55
extern void set_normalized_timespec(struct timespec * , time_t  , s64  ) ;
#line 78 "include/linux/time.h"
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs ) 
{ struct timespec ts_delta ;

  {
#line 82
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, (s64 )(lhs.tv_nsec - rhs.tv_nsec));
#line 84
  return (ts_delta);
}
}
#line 162
extern void getrawmonotonic(struct timespec * ) ;
#line 236
extern struct timespec ns_to_timespec(s64 const    ) ;
#line 189 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void vmw_marker_queue_init(struct vmw_marker_queue *queue ) 
{ struct lock_class_key __key ;

  {
#line 191
  INIT_LIST_HEAD(& queue->head);
#line 192
  queue->lag = ns_to_timespec(0LL);
#line 193
  getrawmonotonic(& queue->lag_time);
#line 194
  spinlock_check(& queue->lock);
#line 194
  __raw_spin_lock_init(& queue->lock.ldv_5961.rlock, "&(&queue->lock)->rlock", & __key);
#line 196
  return;
}
}
#line 197 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void vmw_marker_queue_takedown(struct vmw_marker_queue *queue ) 
{ struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 201
  spin_lock(& queue->lock);
#line 202
  __mptr = (struct list_head  const  *)queue->head.next;
#line 202
  marker = (struct vmw_marker *)__mptr;
#line 202
  __mptr___0 = (struct list_head  const  *)marker->head.next;
#line 202
  next = (struct vmw_marker *)__mptr___0;
#line 202
  goto ldv_40591;
  ldv_40590: 
#line 203
  kfree((void const   *)marker);
#line 202
  marker = next;
#line 202
  __mptr___1 = (struct list_head  const  *)next->head.next;
#line 202
  next = (struct vmw_marker *)__mptr___1;
  ldv_40591: ;
#line 202
  if ((unsigned long )marker != (unsigned long )queue) {
#line 203
    goto ldv_40590;
  } else {
#line 205
    goto ldv_40592;
  }
  ldv_40592: 
#line 205
  spin_unlock(& queue->lock);
#line 206
  return;
}
}
#line 208 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_marker_push(struct vmw_marker_queue *queue , uint32_t seqno ) 
{ struct vmw_marker *marker ;
  void *tmp ;
  long tmp___0 ;

  {
#line 211
  tmp = kmalloc(40UL, 208U);
#line 211
  marker = (struct vmw_marker *)tmp;
#line 213
  tmp___0 = ldv__builtin_expect((unsigned long )marker == (unsigned long )((struct vmw_marker *)0),
                             0L);
#line 213
  if (tmp___0 != 0L) {
#line 214
    return (-12);
  } else {

  }
#line 216
  marker->seqno = seqno;
#line 217
  getrawmonotonic(& marker->submitted);
#line 218
  spin_lock(& queue->lock);
#line 219
  list_add_tail(& marker->head, & queue->head);
#line 220
  spin_unlock(& queue->lock);
#line 222
  return (0);
}
}
#line 225 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_marker_pull(struct vmw_marker_queue *queue , uint32_t signaled_seqno ) 
{ struct vmw_marker *marker ;
  struct vmw_marker *next ;
  struct timespec now ;
  bool updated ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;

  {
#line 230
  updated = 0;
#line 232
  spin_lock(& queue->lock);
#line 233
  getrawmonotonic(& now);
#line 235
  tmp = list_empty((struct list_head  const  *)(& queue->head));
#line 235
  if (tmp != 0) {
#line 236
    queue->lag = ns_to_timespec(0LL);
#line 237
    queue->lag_time = now;
#line 238
    updated = 1;
#line 239
    goto out_unlock;
  } else {

  }
#line 242
  __mptr = (struct list_head  const  *)queue->head.next;
#line 242
  marker = (struct vmw_marker *)__mptr;
#line 242
  __mptr___0 = (struct list_head  const  *)marker->head.next;
#line 242
  next = (struct vmw_marker *)__mptr___0;
#line 242
  goto ldv_40615;
  ldv_40614: ;
#line 243
  if (signaled_seqno - marker->seqno > 1073741824U) {
#line 244
    goto ldv_40613;
  } else {

  }
#line 246
  queue->lag = timespec_sub(now, marker->submitted);
#line 247
  queue->lag_time = now;
#line 248
  updated = 1;
#line 249
  list_del(& marker->head);
#line 250
  kfree((void const   *)marker);
  ldv_40613: 
#line 242
  marker = next;
#line 242
  __mptr___1 = (struct list_head  const  *)next->head.next;
#line 242
  next = (struct vmw_marker *)__mptr___1;
  ldv_40615: ;
#line 242
  if ((unsigned long )marker != (unsigned long )queue) {
#line 243
    goto ldv_40614;
  } else {
#line 245
    goto ldv_40616;
  }
  ldv_40616: ;
  out_unlock: 
#line 254
  spin_unlock(& queue->lock);
#line 256
  if ((int )updated) {
#line 256
    tmp___0 = 0;
  } else {
#line 256
    tmp___0 = -16;
  }
#line 256
  return (tmp___0);
}
}
#line 259 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static struct timespec vmw_timespec_add(struct timespec t1 , struct timespec t2 ) 
{ 

  {
#line 262
  t1.tv_sec = t1.tv_sec + t2.tv_sec;
#line 263
  t1.tv_nsec = t1.tv_nsec + t2.tv_nsec;
#line 264
  if (t1.tv_nsec > 999999999L) {
#line 265
    t1.tv_sec = t1.tv_sec + 1L;
#line 266
    t1.tv_nsec = t1.tv_nsec + -1000000000L;
  } else {

  }
#line 269
  return (t1);
}
}
#line 272 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static struct timespec vmw_fifo_lag(struct vmw_marker_queue *queue ) 
{ struct timespec now ;
  struct timespec tmp ;

  {
#line 276
  spin_lock(& queue->lock);
#line 277
  getrawmonotonic(& now);
#line 278
  tmp = timespec_sub(now, queue->lag_time);
#line 278
  queue->lag = vmw_timespec_add(queue->lag, tmp);
#line 280
  queue->lag_time = now;
#line 281
  spin_unlock(& queue->lock);
#line 282
  return (queue->lag);
}
}
#line 286 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
static bool vmw_lag_lt(struct vmw_marker_queue *queue , uint32_t us ) 
{ struct timespec lag ;
  struct timespec cond ;
  int tmp ;

  {
#line 291
  cond = ns_to_timespec((long long )us * 1000LL);
#line 292
  lag = vmw_fifo_lag(queue);
#line 293
  tmp = timespec_compare((struct timespec  const  *)(& lag), (struct timespec  const  *)(& cond));
#line 293
  return (tmp <= 0);
}
}
#line 296 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int vmw_wait_lag(struct vmw_private *dev_priv , struct vmw_marker_queue *queue , uint32_t us ) 
{ struct vmw_marker *marker ;
  uint32_t seqno ;
  int ret ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 303
  goto ldv_40642;
  ldv_40641: 
#line 304
  spin_lock(& queue->lock);
#line 305
  tmp___0 = list_empty((struct list_head  const  *)(& queue->head));
#line 305
  if (tmp___0 != 0) {
#line 306
    tmp = atomic_read((atomic_t const   *)(& dev_priv->marker_seq));
#line 306
    seqno = (uint32_t )tmp;
  } else {
#line 308
    __mptr = (struct list_head  const  *)queue->head.next;
#line 308
    marker = (struct vmw_marker *)__mptr;
#line 310
    seqno = marker->seqno;
  }
#line 312
  spin_unlock(& queue->lock);
#line 314
  ret = vmw_wait_seqno(dev_priv, 0, seqno, 1, 750UL);
#line 317
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 317
  if (tmp___1 != 0L) {
#line 318
    return (ret);
  } else {

  }
#line 320
  vmw_marker_pull(queue, seqno);
  ldv_40642: 
#line 303
  tmp___2 = vmw_lag_lt(queue, us);
#line 303
  if (tmp___2) {
#line 303
    tmp___3 = 0;
  } else {
#line 303
    tmp___3 = 1;
  }
#line 303
  if (tmp___3) {
#line 304
    goto ldv_40641;
  } else {
#line 306
    goto ldv_40643;
  }
  ldv_40643: ;
#line 322
  return (0);
}
}
#line 325 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_539(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 330
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 332
  mutex_lock(ldv_func_arg1);
#line 333
  return;
}
}
#line 335 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 340
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 342
  mutex_unlock(ldv_func_arg1);
#line 343
  return;
}
}
#line 345 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_541(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 350
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 352
  mutex_lock(ldv_func_arg1);
#line 353
  return;
}
}
#line 355 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
int ldv_mutex_trylock_542(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 360
  tmp = mutex_trylock(ldv_func_arg1);
#line 360
  ldv_func_res = tmp;
#line 362
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 362
  return (tmp___0);
#line 364
  return (ldv_func_res);
}
}
#line 367 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_543(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 372
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 374
  mutex_unlock(ldv_func_arg1);
#line 375
  return;
}
}
#line 377 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 382
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 384
  mutex_lock(ldv_func_arg1);
#line 385
  return;
}
}
#line 387 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_545(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 392
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 394
  mutex_unlock(ldv_func_arg1);
#line 395
  return;
}
}
#line 397 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_546(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 402
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 404
  mutex_lock(ldv_func_arg1);
#line 405
  return;
}
}
#line 407 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_547(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 412
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 414
  mutex_unlock(ldv_func_arg1);
#line 415
  return;
}
}
#line 417 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_548(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 422
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 424
  mutex_unlock(ldv_func_arg1);
#line 425
  return;
}
}
#line 427 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_549(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 432
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 434
  mutex_lock(ldv_func_arg1);
#line 435
  return;
}
}
#line 437 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_550(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 442
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 444
  mutex_unlock(ldv_func_arg1);
#line 445
  return;
}
}
#line 447 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_lock_551(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 452
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 454
  mutex_lock(ldv_func_arg1);
#line 455
  return;
}
}
#line 457 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_marker.c.prepared"
void ldv_mutex_unlock_552(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 462
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 464
  mutex_unlock(ldv_func_arg1);
#line 465
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_570(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_568(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_571(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_573(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_575(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_576(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_578(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_580(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_567(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_569(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_572(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_574(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_577(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_579(struct mutex *ldv_func_arg1 ) ;
#line 142 "include/linux/idr.h"
extern int ida_pre_get(struct ida * , gfp_t  ) ;
#line 144
extern int ida_get_new(struct ida * , int * ) ;
#line 145
extern void ida_remove(struct ida * , int  ) ;
#line 146
extern void ida_destroy(struct ida * ) ;
#line 147
extern void ida_init(struct ida * ) ;
#line 199 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_get_node(struct ttm_mem_type_manager *man , struct ttm_buffer_object *bo ,
                                  struct ttm_placement *placement , struct ttm_mem_reg *mem ) 
{ struct vmwgfx_gmrid_man *gman ;
  int ret ;
  int id ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 204
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 206
  ret = 0;
#line 209
  mem->mm_node = 0;
#line 211
  spin_lock(& gman->lock);
#line 213
  if (gman->max_gmr_pages != 0U) {
#line 214
    gman->used_gmr_pages = gman->used_gmr_pages + (uint32_t )bo->num_pages;
#line 215
    tmp = ldv__builtin_expect(gman->used_gmr_pages > gman->max_gmr_pages, 0L);
#line 215
    if (tmp != 0L) {
#line 216
      goto out_err_locked;
    } else {

    }
  } else {

  }
  ldv_40588: 
#line 220
  spin_unlock(& gman->lock);
#line 221
  tmp___0 = ida_pre_get(& gman->gmr_ida, 208U);
#line 221
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 221
  if (tmp___1 != 0L) {
#line 222
    ret = -12;
#line 223
    goto out_err;
  } else {

  }
#line 225
  spin_lock(& gman->lock);
#line 227
  ret = ida_get_new(& gman->gmr_ida, & id);
#line 228
  tmp___2 = ldv__builtin_expect(ret == 0, 0L);
#line 228
  if (tmp___2 != 0L) {
#line 228
    tmp___3 = ldv__builtin_expect((uint32_t )id >= gman->max_gmr_ids, 0L);
#line 228
    if (tmp___3 != 0L) {
#line 229
      ida_remove(& gman->gmr_ida, id);
#line 230
      ret = 0;
#line 231
      goto out_err_locked;
    } else {

    }
  } else {

  }
#line 233
  if (ret == -11) {
#line 234
    goto ldv_40588;
  } else {
#line 236
    goto ldv_40589;
  }
  ldv_40589: 
#line 235
  tmp___4 = ldv__builtin_expect(ret == 0, 1L);
#line 235
  if (tmp___4 != 0L) {
#line 236
    mem->mm_node = (void *)gman;
#line 237
    mem->start = (unsigned long )id;
#line 238
    mem->num_pages = bo->num_pages;
  } else {
#line 240
    goto out_err_locked;
  }
#line 242
  spin_unlock(& gman->lock);
#line 243
  return (0);
  out_err: 
#line 246
  spin_lock(& gman->lock);
  out_err_locked: 
#line 248
  gman->used_gmr_pages = gman->used_gmr_pages - (uint32_t )bo->num_pages;
#line 249
  spin_unlock(& gman->lock);
#line 250
  return (ret);
}
}
#line 253 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static void vmw_gmrid_man_put_node(struct ttm_mem_type_manager *man , struct ttm_mem_reg *mem ) 
{ struct vmwgfx_gmrid_man *gman ;

  {
#line 256
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 259
  if ((unsigned long )mem->mm_node != (unsigned long )((void *)0)) {
#line 260
    spin_lock(& gman->lock);
#line 261
    ida_remove(& gman->gmr_ida, (int )mem->start);
#line 262
    gman->used_gmr_pages = gman->used_gmr_pages - (uint32_t )mem->num_pages;
#line 263
    spin_unlock(& gman->lock);
#line 264
    mem->mm_node = 0;
  } else {

  }
#line 266
  return;
}
}
#line 268 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_init(struct ttm_mem_type_manager *man , unsigned long p_size ) 
{ struct vmw_private *dev_priv ;
  struct ttm_bo_device  const  *__mptr ;
  struct vmwgfx_gmrid_man *gman ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;

  {
#line 272
  __mptr = (struct ttm_bo_device  const  *)man->bdev;
#line 272
  dev_priv = (struct vmw_private *)__mptr;
#line 273
  tmp = kzalloc(192UL, 208U);
#line 273
  gman = (struct vmwgfx_gmrid_man *)tmp;
#line 276
  tmp___0 = ldv__builtin_expect((unsigned long )gman == (unsigned long )((struct vmwgfx_gmrid_man *)0),
                             0L);
#line 276
  if (tmp___0 != 0L) {
#line 277
    return (-12);
  } else {

  }
#line 279
  spinlock_check(& gman->lock);
#line 279
  __raw_spin_lock_init(& gman->lock.ldv_5961.rlock, "&(&gman->lock)->rlock", & __key);
#line 280
  gman->max_gmr_pages = dev_priv->max_gmr_pages;
#line 281
  gman->used_gmr_pages = 0U;
#line 282
  ida_init(& gman->gmr_ida);
#line 283
  gman->max_gmr_ids = (uint32_t )p_size;
#line 284
  man->priv = (void *)gman;
#line 285
  return (0);
}
}
#line 288 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static int vmw_gmrid_man_takedown(struct ttm_mem_type_manager *man ) 
{ struct vmwgfx_gmrid_man *gman ;

  {
#line 290
  gman = (struct vmwgfx_gmrid_man *)man->priv;
#line 293
  if ((unsigned long )gman != (unsigned long )((struct vmwgfx_gmrid_man *)0)) {
#line 294
    ida_destroy(& gman->gmr_ida);
#line 295
    kfree((void const   *)gman);
  } else {

  }
#line 297
  return (0);
}
}
#line 300 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
static void vmw_gmrid_man_debug(struct ttm_mem_type_manager *man , char const   *prefix ) 
{ 

  {
#line 303
  printk("\016%s: No debug info available for the GMR id manager.\n", prefix);
#line 304
  return;
}
}
#line 307 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
struct ttm_mem_type_manager_func  const  vmw_gmrid_manager_func  =    {& vmw_gmrid_man_init, & vmw_gmrid_man_takedown, & vmw_gmrid_man_get_node, & vmw_gmrid_man_put_node,
    & vmw_gmrid_man_debug};
#line 315 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
struct ttm_mem_reg *vmw_gmrid_manager_func_group0  ;
#line 316 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
struct ttm_placement *ldvarg20  ;
#line 317 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
char *ldvarg23  ;
#line 318
extern int ldv_vmw_gmrid_manager_func_setup_7(void) ;
#line 319 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
struct ttm_buffer_object *ldvarg21  ;
#line 320 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
int ldv_retval_0  ;
#line 321
extern int ldv_vmw_gmrid_manager_func_release_7(void) ;
#line 322 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
struct ttm_mem_type_manager *vmw_gmrid_manager_func_group1  ;
#line 323 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
unsigned long ldvarg22  ;
#line 325 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_main_exported_7(void) 
{ int tmp ;

  {
#line 327
  tmp = __VERIFIER_nondet_int();
#line 327
  switch (tmp) {
  case 0: ;
#line 330
  if (ldv_state_variable_7 == 1) {
#line 332
    vmw_gmrid_man_takedown(vmw_gmrid_manager_func_group1);
#line 334
    ldv_state_variable_7 = 1;
  } else {

  }
#line 337
  if (ldv_state_variable_7 == 3) {
#line 339
    vmw_gmrid_man_takedown(vmw_gmrid_manager_func_group1);
#line 341
    ldv_state_variable_7 = 3;
  } else {

  }
#line 344
  if (ldv_state_variable_7 == 2) {
#line 346
    vmw_gmrid_man_takedown(vmw_gmrid_manager_func_group1);
#line 348
    ldv_state_variable_7 = 2;
  } else {

  }
#line 351
  goto ldv_40628;
  case 1: ;
#line 354
  if (ldv_state_variable_7 == 1) {
#line 356
    vmw_gmrid_man_put_node(vmw_gmrid_manager_func_group1, vmw_gmrid_manager_func_group0);
#line 358
    ldv_state_variable_7 = 1;
  } else {

  }
#line 361
  if (ldv_state_variable_7 == 3) {
#line 363
    vmw_gmrid_man_put_node(vmw_gmrid_manager_func_group1, vmw_gmrid_manager_func_group0);
#line 365
    ldv_state_variable_7 = 3;
  } else {

  }
#line 368
  if (ldv_state_variable_7 == 2) {
#line 370
    vmw_gmrid_man_put_node(vmw_gmrid_manager_func_group1, vmw_gmrid_manager_func_group0);
#line 372
    ldv_state_variable_7 = 2;
  } else {

  }
#line 375
  goto ldv_40628;
  case 2: ;
#line 378
  if (ldv_state_variable_7 == 1) {
#line 380
    vmw_gmrid_man_debug(vmw_gmrid_manager_func_group1, (char const   *)ldvarg23);
#line 382
    ldv_state_variable_7 = 1;
  } else {

  }
#line 385
  if (ldv_state_variable_7 == 3) {
#line 387
    vmw_gmrid_man_debug(vmw_gmrid_manager_func_group1, (char const   *)ldvarg23);
#line 389
    ldv_state_variable_7 = 3;
  } else {

  }
#line 392
  if (ldv_state_variable_7 == 2) {
#line 394
    vmw_gmrid_man_debug(vmw_gmrid_manager_func_group1, (char const   *)ldvarg23);
#line 396
    ldv_state_variable_7 = 2;
  } else {

  }
#line 399
  goto ldv_40628;
  case 3: ;
#line 402
  if (ldv_state_variable_7 == 2) {
#line 404
    ldv_retval_0 = vmw_gmrid_man_init(vmw_gmrid_manager_func_group1, ldvarg22);
#line 406
    if (ldv_retval_0 == 0) {
#line 407
      ldv_state_variable_7 = 3;
    } else {

    }
  } else {

  }
#line 411
  goto ldv_40628;
  case 4: ;
#line 414
  if (ldv_state_variable_7 == 1) {
#line 416
    vmw_gmrid_man_get_node(vmw_gmrid_manager_func_group1, ldvarg21, ldvarg20, vmw_gmrid_manager_func_group0);
#line 418
    ldv_state_variable_7 = 1;
  } else {

  }
#line 421
  if (ldv_state_variable_7 == 3) {
#line 423
    vmw_gmrid_man_get_node(vmw_gmrid_manager_func_group1, ldvarg21, ldvarg20, vmw_gmrid_manager_func_group0);
#line 425
    ldv_state_variable_7 = 3;
  } else {

  }
#line 428
  if (ldv_state_variable_7 == 2) {
#line 430
    vmw_gmrid_man_get_node(vmw_gmrid_manager_func_group1, ldvarg21, ldvarg20, vmw_gmrid_manager_func_group0);
#line 432
    ldv_state_variable_7 = 2;
  } else {

  }
#line 435
  goto ldv_40628;
  case 5: ;
#line 438
  if (ldv_state_variable_7 == 1) {
#line 440
    ldv_vmw_gmrid_manager_func_setup_7();
#line 442
    ldv_state_variable_7 = 2;
#line 443
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 446
  goto ldv_40628;
  case 6: ;
#line 449
  if (ldv_state_variable_7 == 3) {
#line 451
    ldv_vmw_gmrid_manager_func_release_7();
#line 453
    ldv_state_variable_7 = 1;
#line 454
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 457
  if (ldv_state_variable_7 == 2) {
#line 459
    ldv_vmw_gmrid_manager_func_release_7();
#line 461
    ldv_state_variable_7 = 1;
#line 462
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 465
  goto ldv_40628;
  default: ;
#line 466
  goto ldv_40628;
  }
  ldv_40628: ;
#line 470
  return;
}
}
#line 471 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_567(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 476
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 478
  mutex_lock(ldv_func_arg1);
#line 479
  return;
}
}
#line 481 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_568(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 486
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 488
  mutex_unlock(ldv_func_arg1);
#line 489
  return;
}
}
#line 491 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_569(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 496
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 498
  mutex_lock(ldv_func_arg1);
#line 499
  return;
}
}
#line 501 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
int ldv_mutex_trylock_570(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 506
  tmp = mutex_trylock(ldv_func_arg1);
#line 506
  ldv_func_res = tmp;
#line 508
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 508
  return (tmp___0);
#line 510
  return (ldv_func_res);
}
}
#line 513 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_571(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 518
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 520
  mutex_unlock(ldv_func_arg1);
#line 521
  return;
}
}
#line 523 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_572(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 528
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 530
  mutex_lock(ldv_func_arg1);
#line 531
  return;
}
}
#line 533 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_573(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 538
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 540
  mutex_unlock(ldv_func_arg1);
#line 541
  return;
}
}
#line 543 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_574(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 548
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 550
  mutex_lock(ldv_func_arg1);
#line 551
  return;
}
}
#line 553 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_575(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 558
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 560
  mutex_unlock(ldv_func_arg1);
#line 561
  return;
}
}
#line 563 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_576(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 568
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 570
  mutex_unlock(ldv_func_arg1);
#line 571
  return;
}
}
#line 573 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_577(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 578
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 580
  mutex_lock(ldv_func_arg1);
#line 581
  return;
}
}
#line 583 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_578(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 588
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 590
  mutex_unlock(ldv_func_arg1);
#line 591
  return;
}
}
#line 593 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_lock_579(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 598
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 600
  mutex_lock(ldv_func_arg1);
#line 601
  return;
}
}
#line 603 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c.prepared"
void ldv_mutex_unlock_580(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 608
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 610
  mutex_unlock(ldv_func_arg1);
#line 611
  return;
}
}
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_598(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_596(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_599(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_601(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_603(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_604(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_606(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_608(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_610(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_612(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_595(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_600(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_602(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_605(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_607(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_609(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_611(struct mutex *ldv_func_arg1 ) ;
#line 75
void ldv_mutex_lock_goal_irq_mutex_of_vmw_fence_manager(struct mutex *lock ) ;
#line 79
void ldv_mutex_unlock_goal_irq_mutex_of_vmw_fence_manager(struct mutex *lock ) ;
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 

  {
#line 310
  _raw_spin_lock_irq(& lock->ldv_5961.rlock);
#line 311
  return;
}
}
#line 333 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 

  {
#line 335
  _raw_spin_unlock_irq(& lock->ldv_5961.rlock);
#line 336
  return;
}
}
#line 150 "include/linux/time.h"
extern void do_gettimeofday(struct timeval * ) ;
#line 164 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 409
extern bool schedule_work(struct work_struct * ) ;
#line 420
extern bool cancel_work_sync(struct work_struct * ) ;
#line 257 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_obj_destroy_locked(struct kref *kref ) 
{ struct vmw_fence_obj *fence ;
  struct kref  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned int num_fences ;

  {
#line 260
  __mptr = (struct kref  const  *)kref;
#line 260
  fence = (struct vmw_fence_obj *)__mptr;
#line 262
  fman = fence->fman;
#line 265
  list_del_init(& fence->head);
#line 266
  fman->num_fence_objects = fman->num_fence_objects - 1;
#line 266
  num_fences = (unsigned int )fman->num_fence_objects;
#line 267
  spin_unlock_irq(& fman->lock);
#line 268
  if ((unsigned long )fence->destroy != (unsigned long )((void (*)(struct vmw_fence_obj * ))0)) {
#line 269
    (*(fence->destroy))(fence);
  } else {
#line 271
    kfree((void const   *)fence);
  }
#line 273
  spin_lock_irq(& fman->lock);
#line 274
  return;
}
}
#line 283 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_work_func(struct work_struct *work ) 
{ struct vmw_fence_manager *fman ;
  struct work_struct  const  *__mptr ;
  struct list_head list ;
  struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  bool seqno_valid ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 286
  __mptr = (struct work_struct  const  *)work;
#line 286
  fman = (struct vmw_fence_manager *)__mptr + 0xffffffffffffff98UL;
  ldv_40639: 
#line 292
  INIT_LIST_HEAD(& list);
#line 293
  ldv_mutex_lock_609(& fman->goal_irq_mutex);
#line 295
  spin_lock_irq(& fman->lock);
#line 296
  list_splice_init(& fman->cleanup_list, & list);
#line 297
  seqno_valid = fman->seqno_valid;
#line 298
  spin_unlock_irq(& fman->lock);
#line 300
  if (! seqno_valid && (int )fman->goal_irq_on) {
#line 301
    fman->goal_irq_on = 0;
#line 302
    vmw_goal_waiter_remove(fman->dev_priv);
  } else {

  }
#line 304
  ldv_mutex_unlock_610(& fman->goal_irq_mutex);
#line 306
  tmp = list_empty((struct list_head  const  *)(& list));
#line 306
  if (tmp != 0) {
#line 307
    return;
  } else {

  }
#line 315
  __mptr___0 = (struct list_head  const  *)list.next;
#line 315
  action = (struct vmw_fence_action *)__mptr___0;
#line 315
  __mptr___1 = (struct list_head  const  *)action->head.next;
#line 315
  next_action = (struct vmw_fence_action *)__mptr___1;
#line 315
  goto ldv_40637;
  ldv_40636: 
#line 316
  list_del_init(& action->head);
#line 317
  if ((unsigned long )action->cleanup != (unsigned long )((void (*)(struct vmw_fence_action * ))0)) {
#line 318
    (*(action->cleanup))(action);
  } else {

  }
#line 315
  action = next_action;
#line 315
  __mptr___2 = (struct list_head  const  *)next_action->head.next;
#line 315
  next_action = (struct vmw_fence_action *)__mptr___2;
  ldv_40637: ;
#line 315
  if ((unsigned long )(& action->head) != (unsigned long )(& list)) {
#line 316
    goto ldv_40636;
  } else {
#line 318
    goto ldv_40638;
  }
  ldv_40638: ;
#line 320
  goto ldv_40639;
}
}
#line 323 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_fence_manager *vmw_fence_manager_init(struct vmw_private *dev_priv ) 
{ struct vmw_fence_manager *fman ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  struct lock_class_key __key___1 ;

  {
#line 325
  tmp = kzalloc(400UL, 208U);
#line 325
  fman = (struct vmw_fence_manager *)tmp;
#line 327
  tmp___0 = ldv__builtin_expect((unsigned long )fman == (unsigned long )((struct vmw_fence_manager *)0),
                             0L);
#line 327
  if (tmp___0 != 0L) {
#line 328
    return (0);
  } else {

  }
#line 330
  fman->dev_priv = dev_priv;
#line 331
  spinlock_check(& fman->lock);
#line 331
  __raw_spin_lock_init(& fman->lock.ldv_5961.rlock, "&(&fman->lock)->rlock", & __key);
#line 332
  INIT_LIST_HEAD(& fman->fence_list);
#line 333
  INIT_LIST_HEAD(& fman->cleanup_list);
#line 334
  __init_work(& fman->work, 0);
#line 334
  __constr_expr_0.counter = 4195328L;
#line 334
  fman->work.data = __constr_expr_0;
#line 334
  lockdep_init_map(& fman->work.lockdep_map, "(&fman->work)", & __key___0, 0);
#line 334
  INIT_LIST_HEAD(& fman->work.entry);
#line 334
  fman->work.func = & vmw_fence_work_func;
#line 335
  fman->fifo_down = 1;
#line 336
  tmp___1 = ttm_round_pot(232UL);
#line 336
  fman->user_fence_size = (u32 )tmp___1;
#line 337
  tmp___2 = ttm_round_pot(152UL);
#line 337
  fman->fence_size = (u32 )tmp___2;
#line 338
  tmp___3 = ttm_round_pot(96UL);
#line 338
  fman->event_fence_action_size = (u32 )tmp___3;
#line 340
  __mutex_init(& fman->goal_irq_mutex, "&fman->goal_irq_mutex", & __key___1);
#line 342
  return (fman);
}
}
#line 345 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_manager_takedown(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  bool lists_empty ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 350
  cancel_work_sync(& fman->work);
#line 352
  tmp = spinlock_check(& fman->lock);
#line 352
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 353
  tmp___0 = list_empty((struct list_head  const  *)(& fman->fence_list));
#line 353
  if (tmp___0 != 0) {
#line 353
    tmp___1 = list_empty((struct list_head  const  *)(& fman->cleanup_list));
#line 353
    if (tmp___1 != 0) {
#line 353
      tmp___2 = 1;
    } else {
#line 353
      tmp___2 = 0;
    }
  } else {
#line 353
    tmp___2 = 0;
  }
#line 353
  lists_empty = (bool )tmp___2;
#line 355
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 357
  tmp___3 = ldv__builtin_expect((long )(! lists_empty), 0L);
#line 357
  if (tmp___3 != 0L) {
#line 357
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (357), "i" (12UL));
    ldv_40656: ;
#line 357
    goto ldv_40656;
  } else {

  }
#line 358
  kfree((void const   *)fman);
#line 359
  return;
}
}
#line 361 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static int vmw_fence_obj_init(struct vmw_fence_manager *fman , struct vmw_fence_obj *fence ,
                              u32 seqno , uint32_t mask , void (*destroy)(struct vmw_fence_obj * ) ) 
{ unsigned long irq_flags ;
  unsigned int num_fences ;
  int ret ;
  struct lock_class_key __key ;
  raw_spinlock_t *tmp ;
  long tmp___0 ;

  {
#line 369
  ret = 0;
#line 371
  fence->seqno = seqno;
#line 372
  INIT_LIST_HEAD(& fence->seq_passed_actions);
#line 373
  fence->fman = fman;
#line 374
  fence->signaled = 0U;
#line 375
  fence->signal_mask = mask;
#line 376
  kref_init(& fence->kref);
#line 377
  fence->destroy = destroy;
#line 378
  __init_waitqueue_head(& fence->queue, "&fence->queue", & __key);
#line 380
  tmp = spinlock_check(& fman->lock);
#line 380
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 381
  tmp___0 = ldv__builtin_expect((long )fman->fifo_down, 0L);
#line 381
  if (tmp___0 != 0L) {
#line 382
    ret = -16;
#line 383
    goto out_unlock;
  } else {

  }
#line 385
  list_add_tail(& fence->head, & fman->fence_list);
#line 386
  fman->num_fence_objects = fman->num_fence_objects + 1;
#line 386
  num_fences = (unsigned int )fman->num_fence_objects;
  out_unlock: 
#line 389
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 390
  return (ret);
}
}
#line 394 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
struct vmw_fence_obj *vmw_fence_obj_reference(struct vmw_fence_obj *fence ) 
{ long tmp ;

  {
#line 396
  tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                         0L);
#line 396
  if (tmp != 0L) {
#line 397
    return (0);
  } else {

  }
#line 399
  kref_get(& fence->kref);
#line 400
  return (fence);
}
}
#line 410 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_unreference(struct vmw_fence_obj **fence_p ) 
{ struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 412
  fence = *fence_p;
#line 415
  tmp = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                         0L);
#line 415
  if (tmp != 0L) {
#line 416
    return;
  } else {

  }
#line 418
  fman = fence->fman;
#line 419
  *fence_p = 0;
#line 420
  spin_lock_irq(& fman->lock);
#line 421
  tmp___0 = atomic_read((atomic_t const   *)(& fence->kref.refcount));
#line 421
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 421
  if (tmp___1 != 0L) {
#line 421
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (421), "i" (12UL));
    ldv_40681: ;
#line 421
    goto ldv_40681;
  } else {

  }
#line 422
  kref_put(& fence->kref, & vmw_fence_obj_destroy_locked);
#line 423
  spin_unlock_irq(& fman->lock);
#line 424
  return;
}
}
#line 426 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fences_perform_actions(struct vmw_fence_manager *fman , struct list_head *list ) 
{ struct vmw_fence_action *action ;
  struct vmw_fence_action *next_action ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 431
  __mptr = (struct list_head  const  *)list->next;
#line 431
  action = (struct vmw_fence_action *)__mptr;
#line 431
  __mptr___0 = (struct list_head  const  *)action->head.next;
#line 431
  next_action = (struct vmw_fence_action *)__mptr___0;
#line 431
  goto ldv_40695;
  ldv_40694: 
#line 432
  list_del_init(& action->head);
#line 433
  fman->pending_actions[(unsigned int )action->type] = fman->pending_actions[(unsigned int )action->type] - 1U;
#line 434
  if ((unsigned long )action->seq_passed != (unsigned long )((void (*)(struct vmw_fence_action * ))0)) {
#line 435
    (*(action->seq_passed))(action);
  } else {

  }
#line 442
  list_add_tail(& action->head, & fman->cleanup_list);
#line 431
  action = next_action;
#line 431
  __mptr___1 = (struct list_head  const  *)next_action->head.next;
#line 431
  next_action = (struct vmw_fence_action *)__mptr___1;
  ldv_40695: ;
#line 431
  if ((unsigned long )(& action->head) != (unsigned long )list) {
#line 432
    goto ldv_40694;
  } else {
#line 434
    goto ldv_40696;
  }
  ldv_40696: ;
#line 436
  return;
}
}
#line 462 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static bool vmw_fence_goal_new_locked(struct vmw_fence_manager *fman , u32 passed_seqno ) 
{ u32 goal_seqno ;
  __le32 *fifo_mem ;
  struct vmw_fence_obj *fence ;
  long tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 469
  tmp = ldv__builtin_expect((long )(! fman->seqno_valid), 1L);
#line 469
  if (tmp != 0L) {
#line 470
    return (0);
  } else {

  }
#line 472
  fifo_mem = (fman->dev_priv)->mmio_virt;
#line 473
  goal_seqno = ioread32((void *)fifo_mem + 289U);
#line 474
  tmp___0 = ldv__builtin_expect((int )(passed_seqno - goal_seqno) < 0, 1L);
#line 474
  if (tmp___0 != 0L) {
#line 475
    return (0);
  } else {

  }
#line 477
  fman->seqno_valid = 0;
#line 478
  __mptr = (struct list_head  const  *)fman->fence_list.next;
#line 478
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 478
  goto ldv_40710;
  ldv_40709: 
#line 479
  tmp___1 = list_empty((struct list_head  const  *)(& fence->seq_passed_actions));
#line 479
  if (tmp___1 == 0) {
#line 480
    fman->seqno_valid = 1;
#line 481
    iowrite32(fence->seqno, (void *)fifo_mem + 289U);
#line 483
    goto ldv_40708;
  } else {

  }
#line 478
  __mptr___0 = (struct list_head  const  *)fence->head.next;
#line 478
  fence = (struct vmw_fence_obj *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_40710: ;
#line 478
  if ((unsigned long )(& fence->head) != (unsigned long )(& fman->fence_list)) {
#line 479
    goto ldv_40709;
  } else {
#line 481
    goto ldv_40708;
  }
  ldv_40708: ;
#line 487
  return (1);
}
}
#line 506 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static bool vmw_fence_goal_check_locked(struct vmw_fence_obj *fence ) 
{ u32 goal_seqno ;
  __le32 *fifo_mem ;
  long tmp ;
  long tmp___0 ;

  {
#line 511
  if ((int )fence->signaled & 1) {
#line 512
    return (0);
  } else {

  }
#line 514
  fifo_mem = ((fence->fman)->dev_priv)->mmio_virt;
#line 515
  goal_seqno = ioread32((void *)fifo_mem + 289U);
#line 516
  tmp = ldv__builtin_expect((long )(fence->fman)->seqno_valid, 1L);
#line 516
  if (tmp != 0L) {
#line 516
    tmp___0 = ldv__builtin_expect((int )(goal_seqno - fence->seqno) >= 0, 1L);
#line 516
    if (tmp___0 != 0L) {
#line 518
      return (0);
    } else {

    }
  } else {

  }
#line 520
  iowrite32(fence->seqno, (void *)fifo_mem + 289U);
#line 521
  (fence->fman)->seqno_valid = 1;
#line 523
  return (1);
}
}
#line 526 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fences_update(struct vmw_fence_manager *fman ) 
{ unsigned long flags ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_obj *next_fence ;
  struct list_head action_list ;
  bool needs_rerun ;
  uint32_t seqno ;
  uint32_t new_seqno ;
  __le32 *fifo_mem ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 533
  fifo_mem = (fman->dev_priv)->mmio_virt;
#line 535
  seqno = ioread32((void *)fifo_mem + 6U);
  rerun: 
#line 537
  tmp = spinlock_check(& fman->lock);
#line 537
  flags = _raw_spin_lock_irqsave(tmp);
#line 538
  __mptr = (struct list_head  const  *)fman->fence_list.next;
#line 538
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 538
  __mptr___0 = (struct list_head  const  *)fence->head.next;
#line 538
  next_fence = (struct vmw_fence_obj *)__mptr___0 + 0xfffffffffffffff0UL;
#line 538
  goto ldv_40739;
  ldv_40738: ;
#line 539
  if ((int )(seqno - fence->seqno) >= 0) {
#line 540
    list_del_init(& fence->head);
#line 541
    fence->signaled = fence->signaled | 1U;
#line 542
    INIT_LIST_HEAD(& action_list);
#line 543
    list_splice_init(& fence->seq_passed_actions, & action_list);
#line 545
    vmw_fences_perform_actions(fman, & action_list);
#line 546
    __wake_up(& fence->queue, 3U, 0, 0);
  } else {
#line 548
    goto ldv_40737;
  }
#line 538
  fence = next_fence;
#line 538
  __mptr___1 = (struct list_head  const  *)next_fence->head.next;
#line 538
  next_fence = (struct vmw_fence_obj *)__mptr___1 + 0xfffffffffffffff0UL;
  ldv_40739: ;
#line 538
  if ((unsigned long )(& fence->head) != (unsigned long )(& fman->fence_list)) {
#line 539
    goto ldv_40738;
  } else {
#line 541
    goto ldv_40737;
  }
  ldv_40737: 
#line 551
  needs_rerun = vmw_fence_goal_new_locked(fman, seqno);
#line 553
  tmp___0 = list_empty((struct list_head  const  *)(& fman->cleanup_list));
#line 553
  if (tmp___0 == 0) {
#line 554
    schedule_work(& fman->work);
  } else {

  }
#line 555
  spin_unlock_irqrestore(& fman->lock, flags);
#line 563
  tmp___1 = ldv__builtin_expect((long )needs_rerun, 0L);
#line 563
  if (tmp___1 != 0L) {
#line 564
    new_seqno = ioread32((void *)fifo_mem + 6U);
#line 565
    if (new_seqno != seqno) {
#line 566
      seqno = new_seqno;
#line 567
      goto rerun;
    } else {

    }
  } else {

  }
#line 570
  return;
}
}
#line 572 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
bool vmw_fence_obj_signaled(struct vmw_fence_obj *fence , uint32_t flags ) 
{ struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  uint32_t signaled ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 575
  fman = fence->fman;
#line 579
  tmp = spinlock_check(& fman->lock);
#line 579
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 580
  signaled = fence->signaled;
#line 581
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 583
  flags = fence->signal_mask & flags;
#line 584
  if ((signaled & flags) == flags) {
#line 585
    return (1);
  } else {

  }
#line 587
  if ((signaled & 1U) == 0U) {
#line 588
    vmw_fences_update(fman);
  } else {

  }
#line 590
  tmp___0 = spinlock_check(& fman->lock);
#line 590
  irq_flags = _raw_spin_lock_irqsave(tmp___0);
#line 591
  signaled = fence->signaled;
#line 592
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 594
  return ((signaled & flags) == flags);
}
}
#line 597 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_wait(struct vmw_fence_obj *fence , uint32_t flags , bool lazy ,
                       bool interruptible , unsigned long timeout ) 
{ struct vmw_private *dev_priv ;
  long ret ;
  bool tmp ;
  long tmp___0 ;
  long __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  long __ret___0 ;
  wait_queue_t __wait___0 ;
  struct task_struct *tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 601
  dev_priv = (fence->fman)->dev_priv;
#line 604
  tmp = vmw_fence_obj_signaled(fence, flags);
#line 604
  tmp___0 = ldv__builtin_expect((long )tmp, 1L);
#line 604
  if (tmp___0 != 0L) {
#line 605
    return (0);
  } else {

  }
#line 607
  vmw_fifo_ping_host(dev_priv, 1U);
#line 608
  vmw_seqno_waiter_add(dev_priv);
#line 610
  if ((int )interruptible) {
#line 611
    __ret = (long )timeout;
#line 611
    tmp___5 = vmw_fence_obj_signaled(fence, flags);
#line 611
    if (tmp___5) {
#line 611
      tmp___6 = 0;
    } else {
#line 611
      tmp___6 = 1;
    }
#line 611
    if (tmp___6) {
#line 611
      tmp___1 = get_current();
#line 611
      __wait.flags = 0U;
#line 611
      __wait.private = (void *)tmp___1;
#line 611
      __wait.func = & autoremove_wake_function;
#line 611
      __wait.task_list.next = & __wait.task_list;
#line 611
      __wait.task_list.prev = & __wait.task_list;
      ldv_40766: 
#line 611
      prepare_to_wait(& fence->queue, & __wait, 1);
#line 611
      tmp___2 = vmw_fence_obj_signaled(fence, flags);
#line 611
      if ((int )tmp___2) {
#line 611
        goto ldv_40764;
      } else {

      }
#line 611
      tmp___3 = get_current();
#line 611
      tmp___4 = signal_pending(tmp___3);
#line 611
      if (tmp___4 == 0) {
#line 611
        __ret = schedule_timeout(__ret);
#line 611
        if (__ret == 0L) {
#line 611
          goto ldv_40764;
        } else {

        }
#line 611
        goto ldv_40765;
      } else {

      }
#line 611
      __ret = -512L;
#line 611
      goto ldv_40764;
      ldv_40765: ;
#line 611
      goto ldv_40766;
      ldv_40764: 
#line 611
      finish_wait(& fence->queue, & __wait);
    } else {

    }
#line 611
    ret = __ret;
  } else {
#line 616
    __ret___0 = (long )timeout;
#line 616
    tmp___9 = vmw_fence_obj_signaled(fence, flags);
#line 616
    if (tmp___9) {
#line 616
      tmp___10 = 0;
    } else {
#line 616
      tmp___10 = 1;
    }
#line 616
    if (tmp___10) {
#line 616
      tmp___7 = get_current();
#line 616
      __wait___0.flags = 0U;
#line 616
      __wait___0.private = (void *)tmp___7;
#line 616
      __wait___0.func = & autoremove_wake_function;
#line 616
      __wait___0.task_list.next = & __wait___0.task_list;
#line 616
      __wait___0.task_list.prev = & __wait___0.task_list;
      ldv_40771: 
#line 616
      prepare_to_wait(& fence->queue, & __wait___0, 2);
#line 616
      tmp___8 = vmw_fence_obj_signaled(fence, flags);
#line 616
      if ((int )tmp___8) {
#line 616
        goto ldv_40770;
      } else {

      }
#line 616
      __ret___0 = schedule_timeout(__ret___0);
#line 616
      if (__ret___0 == 0L) {
#line 616
        goto ldv_40770;
      } else {

      }
#line 616
      goto ldv_40771;
      ldv_40770: 
#line 616
      finish_wait(& fence->queue, & __wait___0);
    } else {

    }
#line 616
    ret = __ret___0;
  }
#line 621
  vmw_seqno_waiter_remove(dev_priv);
#line 623
  tmp___12 = ldv__builtin_expect(ret == 0L, 0L);
#line 623
  if (tmp___12 != 0L) {
#line 624
    ret = -16L;
  } else {
#line 625
    tmp___11 = ldv__builtin_expect(ret > 0L, 1L);
#line 625
    if (tmp___11 != 0L) {
#line 626
      ret = 0L;
    } else {

    }
  }
#line 628
  return ((int )ret);
}
}
#line 631 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_flush(struct vmw_fence_obj *fence ) 
{ struct vmw_private *dev_priv ;

  {
#line 633
  dev_priv = (fence->fman)->dev_priv;
#line 635
  vmw_fifo_ping_host(dev_priv, 1U);
#line 636
  return;
}
}
#line 638 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_fence_destroy(struct vmw_fence_obj *fence ) 
{ struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp ;

  {
#line 640
  fman = fence->fman;
#line 642
  kfree((void const   *)fence);
#line 646
  tmp = vmw_mem_glob(fman->dev_priv);
#line 646
  ttm_mem_global_free(tmp, (uint64_t )fman->fence_size);
#line 648
  return;
}
}
#line 650 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_create(struct vmw_fence_manager *fman , uint32_t seqno , uint32_t mask ,
                     struct vmw_fence_obj **p_fence ) 
{ struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp ;
  struct vmw_fence_obj *fence ;
  int ret ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 655
  tmp = vmw_mem_glob(fman->dev_priv);
#line 655
  mem_glob = tmp;
#line 659
  ret = ttm_mem_global_alloc(mem_glob, (uint64_t )fman->fence_size, 0, 0);
#line 661
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 661
  if (tmp___0 != 0L) {
#line 662
    return (ret);
  } else {

  }
#line 664
  tmp___1 = kzalloc(152UL, 208U);
#line 664
  fence = (struct vmw_fence_obj *)tmp___1;
#line 665
  tmp___2 = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                             0L);
#line 665
  if (tmp___2 != 0L) {
#line 666
    ret = -12;
#line 667
    goto out_no_object;
  } else {

  }
#line 670
  ret = vmw_fence_obj_init(fman, fence, seqno, mask, & vmw_fence_destroy);
#line 672
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 672
  if (tmp___3 != 0L) {
#line 673
    goto out_err_init;
  } else {

  }
#line 675
  *p_fence = fence;
#line 676
  return (0);
  out_err_init: 
#line 679
  kfree((void const   *)fence);
  out_no_object: 
#line 681
  ttm_mem_global_free(mem_glob, (uint64_t )fman->fence_size);
#line 682
  return (ret);
}
}
#line 686 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_user_fence_destroy(struct vmw_fence_obj *fence ) 
{ struct vmw_user_fence *ufence ;
  struct vmw_fence_obj  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  struct ttm_mem_global *tmp ;

  {
#line 689
  __mptr = (struct vmw_fence_obj  const  *)fence;
#line 689
  ufence = (struct vmw_user_fence *)__mptr + 0xffffffffffffffb0UL;
#line 690
  fman = fence->fman;
#line 692
  kfree_call_rcu(& ufence->base.rhead, 0);
#line 696
  tmp = vmw_mem_glob(fman->dev_priv);
#line 696
  ttm_mem_global_free(tmp, (uint64_t )fman->user_fence_size);
#line 698
  return;
}
}
#line 700 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_user_fence_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_fence *ufence ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_fence_obj *fence ;

  {
#line 702
  base = *p_base;
#line 704
  __mptr = (struct ttm_base_object  const  *)base;
#line 704
  ufence = (struct vmw_user_fence *)__mptr;
#line 705
  fence = & ufence->fence;
#line 707
  *p_base = 0;
#line 708
  vmw_fence_obj_unreference(& fence);
#line 709
  return;
}
}
#line 711 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_user_fence_create(struct drm_file *file_priv , struct vmw_fence_manager *fman ,
                          uint32_t seqno , uint32_t mask , struct vmw_fence_obj **p_fence ,
                          uint32_t *p_handle ) 
{ struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_user_fence *ufence ;
  struct vmw_fence_obj *tmp___0 ;
  struct ttm_mem_global *mem_glob ;
  struct ttm_mem_global *tmp___1 ;
  int ret ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 718
  tmp = vmw_fpriv(file_priv);
#line 718
  tfile = tmp->tfile;
#line 721
  tmp___1 = vmw_mem_glob(fman->dev_priv);
#line 721
  mem_glob = tmp___1;
#line 729
  ret = ttm_mem_global_alloc(mem_glob, (uint64_t )fman->user_fence_size, 0, 0);
#line 731
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 731
  if (tmp___2 != 0L) {
#line 732
    return (ret);
  } else {

  }
#line 734
  tmp___3 = kzalloc(232UL, 208U);
#line 734
  ufence = (struct vmw_user_fence *)tmp___3;
#line 735
  tmp___4 = ldv__builtin_expect((unsigned long )ufence == (unsigned long )((struct vmw_user_fence *)0),
                             0L);
#line 735
  if (tmp___4 != 0L) {
#line 736
    ret = -12;
#line 737
    goto out_no_object;
  } else {

  }
#line 740
  ret = vmw_fence_obj_init(fman, & ufence->fence, seqno, mask, & vmw_user_fence_destroy);
#line 742
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 742
  if (tmp___5 != 0L) {
#line 743
    kfree((void const   *)ufence);
#line 744
    goto out_no_object;
  } else {

  }
#line 751
  tmp___0 = vmw_fence_obj_reference(& ufence->fence);
#line 752
  ret = ttm_base_object_init(tfile, & ufence->base, 0, 259, & vmw_user_fence_base_release,
                             0);
#line 757
  tmp___6 = ldv__builtin_expect(ret != 0, 0L);
#line 757
  if (tmp___6 != 0L) {
#line 761
    vmw_fence_obj_unreference(& tmp___0);
#line 762
    goto out_err;
  } else {

  }
#line 765
  *p_fence = & ufence->fence;
#line 766
  *p_handle = (uint32_t )ufence->base.hash.key;
#line 768
  return (0);
  out_err: 
#line 770
  tmp___0 = & ufence->fence;
#line 771
  vmw_fence_obj_unreference(& tmp___0);
  out_no_object: 
#line 773
  ttm_mem_global_free(mem_glob, (uint64_t )fman->user_fence_size);
#line 774
  return (ret);
}
}
#line 782 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_fifo_down(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  struct list_head action_list ;
  int ret ;
  raw_spinlock_t *tmp ;
  struct vmw_fence_obj *fence ;
  struct list_head  const  *__mptr ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 793
  tmp = spinlock_check(& fman->lock);
#line 793
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 794
  fman->fifo_down = 1;
#line 795
  goto ldv_40837;
  ldv_40836: 
#line 797
  __mptr = (struct list_head  const  *)fman->fence_list.prev;
#line 797
  fence = (struct vmw_fence_obj *)__mptr + 0xfffffffffffffff0UL;
#line 799
  kref_get(& fence->kref);
#line 800
  spin_unlock_irq(& fman->lock);
#line 802
  ret = vmw_fence_obj_wait(fence, fence->signal_mask, 0, 0, 1250UL);
#line 806
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 806
  if (tmp___0 != 0L) {
#line 807
    list_del_init(& fence->head);
#line 808
    fence->signaled = fence->signaled | 1U;
#line 809
    INIT_LIST_HEAD(& action_list);
#line 810
    list_splice_init(& fence->seq_passed_actions, & action_list);
#line 812
    vmw_fences_perform_actions(fman, & action_list);
#line 813
    __wake_up(& fence->queue, 3U, 0, 0);
  } else {

  }
#line 816
  spin_lock_irq(& fman->lock);
#line 818
  tmp___1 = list_empty((struct list_head  const  *)(& fence->head));
#line 818
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 818
  if (tmp___2 != 0L) {
#line 818
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (818), "i" (12UL));
    ldv_40835: ;
#line 818
    goto ldv_40835;
  } else {

  }
#line 819
  kref_put(& fence->kref, & vmw_fence_obj_destroy_locked);
  ldv_40837: 
#line 795
  tmp___3 = list_empty((struct list_head  const  *)(& fman->fence_list));
#line 795
  if (tmp___3 == 0) {
#line 796
    goto ldv_40836;
  } else {
#line 798
    goto ldv_40838;
  }
  ldv_40838: 
#line 821
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 822
  return;
}
}
#line 824 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_fifo_up(struct vmw_fence_manager *fman ) 
{ unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 828
  tmp = spinlock_check(& fman->lock);
#line 828
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 829
  fman->fifo_down = 0;
#line 830
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 831
  return;
}
}
#line 834 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_wait_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_wait_arg *arg ;
  unsigned long timeout ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int ret ;
  uint64_t wait_timeout ;
  long tmp___0 ;
  struct ttm_base_object  const  *__mptr ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 837
  arg = (struct drm_vmw_fence_wait_arg *)data;
#line 842
  tmp = vmw_fpriv(file_priv);
#line 842
  tfile = tmp->tfile;
#line 844
  wait_timeout = arg->timeout_us * 250ULL;
#line 851
  wait_timeout = ((wait_timeout >> 20) + (wait_timeout >> 24)) - (wait_timeout >> 26);
#line 854
  if (arg->cookie_valid == 0) {
#line 855
    arg->cookie_valid = 1;
#line 856
    arg->kernel_cookie = (unsigned long long )jiffies + wait_timeout;
  } else {

  }
#line 859
  base = ttm_base_object_lookup(tfile, arg->handle);
#line 860
  tmp___0 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 860
  if (tmp___0 != 0L) {
#line 861
    printk("\vWait invalid fence object handle 0x%08lx.\n", (unsigned long )arg->handle);
#line 864
    return (-22);
  } else {

  }
#line 867
  __mptr = (struct ttm_base_object  const  *)base;
#line 867
  fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 869
  timeout = jiffies;
#line 870
  if ((long )timeout - (long )arg->kernel_cookie >= 0L) {
#line 871
    tmp___2 = vmw_fence_obj_signaled(fence, (uint32_t )arg->flags);
#line 871
    if ((int )tmp___2) {
#line 871
      ret = 0;
    } else {
#line 871
      ret = -16;
    }
#line 873
    goto out;
  } else {

  }
#line 876
  timeout = (unsigned long )arg->kernel_cookie - timeout;
#line 878
  ret = vmw_fence_obj_wait(fence, (uint32_t )arg->flags, arg->lazy != 0, 1, timeout);
  out: 
#line 881
  ttm_base_object_unref(& base);
#line 887
  if (ret == 0 && arg->wait_options & 1) {
#line 888
    tmp___3 = ttm_ref_object_base_unref(tfile, (unsigned long )arg->handle, 0);
#line 888
    return (tmp___3);
  } else {

  }
#line 890
  return (ret);
}
}
#line 893 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_signaled_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_signaled_arg *arg ;
  struct ttm_base_object *base ;
  struct vmw_fence_obj *fence ;
  struct vmw_fence_manager *fman ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_private *dev_priv ;
  struct vmw_private *tmp___0 ;
  long tmp___1 ;
  struct ttm_base_object  const  *__mptr ;
  bool tmp___2 ;

  {
#line 896
  arg = (struct drm_vmw_fence_signaled_arg *)data;
#line 901
  tmp = vmw_fpriv(file_priv);
#line 901
  tfile = tmp->tfile;
#line 902
  tmp___0 = vmw_priv(dev);
#line 902
  dev_priv = tmp___0;
#line 904
  base = ttm_base_object_lookup(tfile, arg->handle);
#line 905
  tmp___1 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 905
  if (tmp___1 != 0L) {
#line 906
    printk("\vFence signaled invalid fence object handle 0x%08lx.\n", (unsigned long )arg->handle);
#line 909
    return (-22);
  } else {

  }
#line 912
  __mptr = (struct ttm_base_object  const  *)base;
#line 912
  fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 913
  fman = fence->fman;
#line 915
  tmp___2 = vmw_fence_obj_signaled(fence, arg->flags);
#line 915
  arg->signaled = (int32_t )tmp___2;
#line 916
  spin_lock_irq(& fman->lock);
#line 918
  arg->signaled_flags = fence->signaled;
#line 919
  arg->passed_seqno = dev_priv->last_read_seqno;
#line 920
  spin_unlock_irq(& fman->lock);
#line 922
  ttm_base_object_unref(& base);
#line 924
  return (0);
}
}
#line 928 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_obj_unref_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_fence_arg *arg ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 931
  arg = (struct drm_vmw_fence_arg *)data;
#line 934
  tmp = vmw_fpriv(file_priv);
#line 934
  tmp___0 = ttm_ref_object_base_unref(tmp->tfile, (unsigned long )arg->handle, 0);
#line 934
  return (tmp___0);
}
}
#line 952 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_event_fence_fpriv_gone(struct vmw_fence_manager *fman , struct list_head *event_list ) 
{ struct vmw_event_fence_action *eaction ;
  struct drm_pending_event *event ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;

  {
  ldv_40899: 
#line 960
  tmp = spinlock_check(& fman->lock);
#line 960
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 961
  tmp___0 = list_empty((struct list_head  const  *)event_list);
#line 961
  if (tmp___0 != 0) {
#line 962
    goto out_unlock;
  } else {

  }
#line 963
  __mptr = (struct list_head  const  *)event_list->next;
#line 963
  eaction = (struct vmw_event_fence_action *)__mptr + 0xffffffffffffffd8UL;
#line 966
  list_del_init(& eaction->fpriv_head);
#line 967
  event = eaction->event;
#line 968
  eaction->event = 0;
#line 969
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 970
  (*(event->destroy))(event);
#line 971
  goto ldv_40899;
  out_unlock: 
#line 973
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 974
  return;
}
}
#line 988 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_event_fence_action_seq_passed(struct vmw_fence_action *action ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action  const  *__mptr ;
  struct drm_device *dev ;
  struct drm_pending_event *event ;
  struct drm_file *file_priv ;
  unsigned long irq_flags ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  struct timeval tv ;
  long tmp___1 ;

  {
#line 991
  __mptr = (struct vmw_fence_action  const  *)action;
#line 991
  eaction = (struct vmw_event_fence_action *)__mptr;
#line 992
  dev = eaction->dev;
#line 993
  event = eaction->event;
#line 997
  tmp = ldv__builtin_expect((unsigned long )event == (unsigned long )((struct drm_pending_event *)0),
                         0L);
#line 997
  if (tmp != 0L) {
#line 998
    return;
  } else {

  }
#line 1000
  file_priv = event->file_priv;
#line 1001
  tmp___0 = spinlock_check(& dev->event_lock);
#line 1001
  irq_flags = _raw_spin_lock_irqsave(tmp___0);
#line 1003
  tmp___1 = ldv__builtin_expect((unsigned long )eaction->tv_sec != (unsigned long )((uint32_t *)0),
                             1L);
#line 1003
  if (tmp___1 != 0L) {
#line 1006
    do_gettimeofday(& tv);
#line 1007
    *(eaction->tv_sec) = (uint32_t )tv.tv_sec;
#line 1008
    *(eaction->tv_usec) = (uint32_t )tv.tv_usec;
  } else {

  }
#line 1011
  list_del_init(& eaction->fpriv_head);
#line 1012
  list_add_tail(& (eaction->event)->link, & file_priv->event_list);
#line 1013
  eaction->event = 0;
#line 1014
  __wake_up(& file_priv->event_wait, 3U, 0, 0);
#line 1015
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
#line 1016
  return;
}
}
#line 1027 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
static void vmw_event_fence_action_cleanup(struct vmw_fence_action *action ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_action  const  *__mptr ;
  struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 1030
  __mptr = (struct vmw_fence_action  const  *)action;
#line 1030
  eaction = (struct vmw_event_fence_action *)__mptr;
#line 1031
  fman = (eaction->fence)->fman;
#line 1034
  tmp = spinlock_check(& fman->lock);
#line 1034
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1035
  list_del(& eaction->fpriv_head);
#line 1036
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 1038
  vmw_fence_obj_unreference(& eaction->fence);
#line 1039
  kfree((void const   *)eaction);
#line 1040
  return;
}
}
#line 1052 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void vmw_fence_obj_add_action(struct vmw_fence_obj *fence , struct vmw_fence_action *action ) 
{ struct vmw_fence_manager *fman ;
  unsigned long irq_flags ;
  bool run_update ;
  raw_spinlock_t *tmp ;
  struct list_head action_list ;

  {
#line 1055
  fman = fence->fman;
#line 1057
  run_update = 0;
#line 1059
  ldv_mutex_lock_611(& fman->goal_irq_mutex);
#line 1060
  tmp = spinlock_check(& fman->lock);
#line 1060
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1062
  fman->pending_actions[(unsigned int )action->type] = fman->pending_actions[(unsigned int )action->type] + 1U;
#line 1063
  if ((int )fence->signaled & 1) {
#line 1066
    INIT_LIST_HEAD(& action_list);
#line 1067
    list_add_tail(& action->head, & action_list);
#line 1068
    vmw_fences_perform_actions(fman, & action_list);
  } else {
#line 1070
    list_add_tail(& action->head, & fence->seq_passed_actions);
#line 1076
    run_update = vmw_fence_goal_check_locked(fence);
  }
#line 1079
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 1081
  if ((int )run_update) {
#line 1082
    if (! fman->goal_irq_on) {
#line 1083
      fman->goal_irq_on = 1;
#line 1084
      vmw_goal_waiter_add(fman->dev_priv);
    } else {

    }
#line 1086
    vmw_fences_update(fman);
  } else {

  }
#line 1088
  ldv_mutex_unlock_612(& fman->goal_irq_mutex);
#line 1089
  return;
}
}
#line 1107 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_event_fence_action_queue(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                 struct drm_pending_event *event , uint32_t *tv_sec ,
                                 uint32_t *tv_usec , bool interruptible ) 
{ struct vmw_event_fence_action *eaction ;
  struct vmw_fence_manager *fman ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp ;
  unsigned long irq_flags ;
  void *tmp___0 ;
  long tmp___1 ;
  raw_spinlock_t *tmp___2 ;

  {
#line 1115
  fman = fence->fman;
#line 1116
  tmp = vmw_fpriv(file_priv);
#line 1116
  vmw_fp = tmp;
#line 1119
  tmp___0 = kzalloc(96UL, 208U);
#line 1119
  eaction = (struct vmw_event_fence_action *)tmp___0;
#line 1120
  tmp___1 = ldv__builtin_expect((unsigned long )eaction == (unsigned long )((struct vmw_event_fence_action *)0),
                             0L);
#line 1120
  if (tmp___1 != 0L) {
#line 1121
    return (-12);
  } else {

  }
#line 1123
  eaction->event = event;
#line 1125
  eaction->action.seq_passed = & vmw_event_fence_action_seq_passed;
#line 1126
  eaction->action.cleanup = & vmw_event_fence_action_cleanup;
#line 1127
  eaction->action.type = 0;
#line 1129
  eaction->fence = vmw_fence_obj_reference(fence);
#line 1130
  eaction->dev = (fman->dev_priv)->dev;
#line 1131
  eaction->tv_sec = tv_sec;
#line 1132
  eaction->tv_usec = tv_usec;
#line 1134
  tmp___2 = spinlock_check(& fman->lock);
#line 1134
  irq_flags = _raw_spin_lock_irqsave(tmp___2);
#line 1135
  list_add_tail(& eaction->fpriv_head, & vmw_fp->fence_events);
#line 1136
  spin_unlock_irqrestore(& fman->lock, irq_flags);
#line 1138
  vmw_fence_obj_add_action(fence, & eaction->action);
#line 1140
  return (0);
}
}
#line 1148 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_event_fence_action_create(struct drm_file *file_priv , struct vmw_fence_obj *fence ,
                                  uint32_t flags , uint64_t user_data , bool interruptible ) 
{ struct vmw_event_fence_pending *event ;
  struct drm_device *dev ;
  unsigned long irq_flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  raw_spinlock_t *tmp___4 ;

  {
#line 1155
  dev = ((fence->fman)->dev_priv)->dev;
#line 1159
  tmp = spinlock_check(& dev->event_lock);
#line 1159
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1161
  if ((unsigned int )file_priv->event_space <= 23U) {
#line 1161
    ret = -16;
  } else {
#line 1161
    ret = 0;
  }
#line 1162
  tmp___0 = ldv__builtin_expect(ret == 0, 1L);
#line 1162
  if (tmp___0 != 0L) {
#line 1163
    file_priv->event_space = (int )((unsigned int )file_priv->event_space - 24U);
  } else {

  }
#line 1165
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
#line 1167
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 1167
  if (tmp___1 != 0L) {
#line 1168
    drm_err("vmw_event_fence_action_create", "Failed to allocate event space for this file.\n");
#line 1169
    goto out_no_space;
  } else {

  }
#line 1173
  tmp___2 = kzalloc(72UL, 208U);
#line 1173
  event = (struct vmw_event_fence_pending *)tmp___2;
#line 1174
  tmp___3 = ldv__builtin_expect((unsigned long )event == (unsigned long )((struct vmw_event_fence_pending *)0),
                             0L);
#line 1174
  if (tmp___3 != 0L) {
#line 1175
    drm_err("vmw_event_fence_action_create", "Failed to allocate an event.\n");
#line 1176
    ret = -12;
#line 1177
    goto out_no_event;
  } else {

  }
#line 1180
  event->event.base.type = 2147483648U;
#line 1181
  event->event.base.length = 72U;
#line 1182
  event->event.user_data = user_data;
#line 1184
  event->base.event = & event->event.base;
#line 1185
  event->base.file_priv = file_priv;
#line 1186
  event->base.destroy = (void (*)(struct drm_pending_event * ))(& kfree);
#line 1189
  if ((int )flags & 1) {
#line 1190
    ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, & event->event.tv_sec,
                                       & event->event.tv_usec, (int )interruptible);
  } else {
#line 1196
    ret = vmw_event_fence_action_queue(file_priv, fence, & event->base, 0, 0, (int )interruptible);
  }
#line 1201
  if (ret != 0) {
#line 1202
    goto out_no_queue;
  } else {

  }
  out_no_queue: 
#line 1205
  (*(event->base.destroy))(& event->base);
  out_no_event: 
#line 1207
  tmp___4 = spinlock_check(& dev->event_lock);
#line 1207
  irq_flags = _raw_spin_lock_irqsave(tmp___4);
#line 1208
  file_priv->event_space = (int )((unsigned int )file_priv->event_space + 72U);
#line 1209
  spin_unlock_irqrestore(& dev->event_lock, irq_flags);
  out_no_space: ;
#line 1211
  return (ret);
}
}
#line 1214 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int vmw_fence_event_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct drm_vmw_fence_event_arg *arg ;
  struct vmw_fence_obj *fence ;
  struct vmw_fpriv *vmw_fp ;
  struct vmw_fpriv *tmp___0 ;
  struct drm_vmw_fence_rep *user_fence_rep ;
  uint32_t handle ;
  int ret ;
  struct ttm_base_object *base ;
  struct ttm_base_object *tmp___1 ;
  long tmp___2 ;
  struct ttm_base_object  const  *__mptr ;
  bool existed ;
  long tmp___3 ;
  uint32_t *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  struct vmw_fpriv *tmp___8 ;

  {
#line 1217
  tmp = vmw_priv(dev);
#line 1217
  dev_priv = tmp;
#line 1218
  arg = (struct drm_vmw_fence_event_arg *)data;
#line 1220
  fence = 0;
#line 1221
  tmp___0 = vmw_fpriv(file_priv);
#line 1221
  vmw_fp = tmp___0;
#line 1222
  user_fence_rep = (struct drm_vmw_fence_rep *)arg->fence_rep;
#line 1233
  if (arg->handle != 0U) {
#line 1234
    tmp___1 = ttm_base_object_lookup(vmw_fp->tfile, arg->handle);
#line 1234
    base = tmp___1;
#line 1237
    tmp___2 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                               0L);
#line 1237
    if (tmp___2 != 0L) {
#line 1238
      drm_err("vmw_fence_event_ioctl", "Fence event invalid fence object handle 0x%08lx.\n",
              (unsigned long )arg->handle);
#line 1241
      return (-22);
    } else {

    }
#line 1243
    __mptr = (struct ttm_base_object  const  *)base;
#line 1243
    fence = & ((struct vmw_user_fence *)__mptr)->fence;
#line 1245
    vmw_fence_obj_reference(fence);
#line 1247
    if ((unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1250
      ret = ttm_ref_object_add(vmw_fp->tfile, base, 0, & existed);
#line 1252
      tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1252
      if (tmp___3 != 0L) {
#line 1253
        drm_err("vmw_fence_event_ioctl", "Failed to reference a fence object.\n");
#line 1255
        goto out_no_ref_obj;
      } else {

      }
#line 1257
      handle = (uint32_t )base->hash.key;
    } else {

    }
#line 1259
    ttm_base_object_unref(& base);
  } else {

  }
#line 1265
  if ((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0)) {
#line 1266
    if ((unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1266
      tmp___4 = & handle;
    } else {
#line 1266
      tmp___4 = 0;
    }
#line 1266
    ret = vmw_execbuf_fence_commands(file_priv, dev_priv, & fence, tmp___4);
#line 1270
    tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 1270
    if (tmp___5 != 0L) {
#line 1271
      drm_err("vmw_fence_event_ioctl", "Fence event failed to create fence.\n");
#line 1272
      return (ret);
    } else {

    }
  } else {

  }
#line 1276
  tmp___6 = ldv__builtin_expect((unsigned long )fence == (unsigned long )((struct vmw_fence_obj *)0),
                             0L);
#line 1276
  if (tmp___6 != 0L) {
#line 1276
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"),
                         "i" (1276), "i" (12UL));
    ldv_40994: ;
#line 1276
    goto ldv_40994;
  } else {

  }
#line 1278
  if ((int )arg->flags & 1) {
#line 1279
    ret = vmw_event_fence_action_create(file_priv, fence, arg->flags, arg->user_data,
                                        1);
  } else {
#line 1284
    ret = vmw_event_fence_action_create(file_priv, fence, arg->flags, arg->user_data,
                                        1);
  }
#line 1289
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 1289
  if (tmp___7 != 0L) {
#line 1290
    if (ret != -512) {
#line 1291
      drm_err("vmw_fence_event_ioctl", "Failed to attach event to fence.\n");
    } else {

    }
#line 1292
    goto out_no_create;
  } else {

  }
#line 1295
  vmw_execbuf_copy_fence_user(dev_priv, vmw_fp, 0, user_fence_rep, fence, handle);
#line 1297
  vmw_fence_obj_unreference(& fence);
#line 1298
  return (0);
  out_no_create: ;
#line 1300
  if ((unsigned long )user_fence_rep != (unsigned long )((struct drm_vmw_fence_rep *)0)) {
#line 1301
    tmp___8 = vmw_fpriv(file_priv);
#line 1301
    ttm_ref_object_base_unref(tmp___8->tfile, (unsigned long )handle, 0);
  } else {

  }
  out_no_ref_obj: 
#line 1304
  vmw_fence_obj_unreference(& fence);
#line 1305
  return (ret);
}
}
#line 1308 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_595(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1313
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1315
  mutex_lock(ldv_func_arg1);
#line 1316
  return;
}
}
#line 1318 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_596(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1323
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1325
  mutex_unlock(ldv_func_arg1);
#line 1326
  return;
}
}
#line 1328 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_597(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1333
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1335
  mutex_lock(ldv_func_arg1);
#line 1336
  return;
}
}
#line 1338 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
int ldv_mutex_trylock_598(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1343
  tmp = mutex_trylock(ldv_func_arg1);
#line 1343
  ldv_func_res = tmp;
#line 1345
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1345
  return (tmp___0);
#line 1347
  return (ldv_func_res);
}
}
#line 1350 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_599(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1355
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1357
  mutex_unlock(ldv_func_arg1);
#line 1358
  return;
}
}
#line 1360 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_600(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1365
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1367
  mutex_lock(ldv_func_arg1);
#line 1368
  return;
}
}
#line 1370 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_601(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1375
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1377
  mutex_unlock(ldv_func_arg1);
#line 1378
  return;
}
}
#line 1380 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_602(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1385
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1387
  mutex_lock(ldv_func_arg1);
#line 1388
  return;
}
}
#line 1390 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_603(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1395
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1397
  mutex_unlock(ldv_func_arg1);
#line 1398
  return;
}
}
#line 1400 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_604(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1405
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 1407
  mutex_unlock(ldv_func_arg1);
#line 1408
  return;
}
}
#line 1410 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_605(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1415
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1417
  mutex_lock(ldv_func_arg1);
#line 1418
  return;
}
}
#line 1420 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_606(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1425
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1427
  mutex_unlock(ldv_func_arg1);
#line 1428
  return;
}
}
#line 1430 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_607(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1435
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1437
  mutex_lock(ldv_func_arg1);
#line 1438
  return;
}
}
#line 1440 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_608(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1445
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1447
  mutex_unlock(ldv_func_arg1);
#line 1448
  return;
}
}
#line 1450 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_609(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1455
  ldv_mutex_lock_goal_irq_mutex_of_vmw_fence_manager(ldv_func_arg1);
#line 1457
  mutex_lock(ldv_func_arg1);
#line 1458
  return;
}
}
#line 1460 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_610(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1465
  ldv_mutex_unlock_goal_irq_mutex_of_vmw_fence_manager(ldv_func_arg1);
#line 1467
  mutex_unlock(ldv_func_arg1);
#line 1468
  return;
}
}
#line 1470 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_lock_611(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1475
  ldv_mutex_lock_goal_irq_mutex_of_vmw_fence_manager(ldv_func_arg1);
#line 1477
  mutex_lock(ldv_func_arg1);
#line 1478
  return;
}
}
#line 1480 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c.prepared"
void ldv_mutex_unlock_612(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1485
  ldv_mutex_unlock_goal_irq_mutex_of_vmw_fence_manager(ldv_func_arg1);
#line 1487
  mutex_unlock(ldv_func_arg1);
#line 1488
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_634(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_632(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_635(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_637(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_639(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_640(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_642(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_644(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_631(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_633(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_636(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_638(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_641(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_643(struct mutex *ldv_func_arg1 ) ;
#line 737 "include/drm/ttm/ttm_bo_api.h"
__inline static bool ttm_bo_is_reserved(struct ttm_buffer_object *bo ) 
{ int tmp ;

  {
#line 739
  tmp = atomic_read((atomic_t const   *)(& bo->reserved));
#line 739
  return (tmp != 0);
}
}
#line 495 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) ;
#line 202 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_placement(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                            struct ttm_placement *placement , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
#line 207
  vmaster = dev_priv->active_master;
#line 208
  bo = & buf->base;
#line 211
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 212
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 212
  if (tmp != 0L) {
#line 213
    return (ret);
  } else {

  }
#line 215
  vmw_execbuf_release_pinned_bo(dev_priv);
#line 217
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 218
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 218
  if (tmp___0 != 0L) {
#line 219
    goto err;
  } else {

  }
#line 221
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0);
#line 223
  ttm_bo_unreserve(bo);
  err: 
#line 226
  ttm_write_unlock(& vmaster->lock);
#line 227
  return (ret);
}
}
#line 246 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_vram_or_gmr(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                              bool pin , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement *placement ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 250
  vmaster = dev_priv->active_master;
#line 251
  bo = & buf->base;
#line 255
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 256
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 256
  if (tmp != 0L) {
#line 257
    return (ret);
  } else {

  }
#line 259
  if ((int )pin) {
#line 260
    vmw_execbuf_release_pinned_bo(dev_priv);
  } else {

  }
#line 262
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 263
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 263
  if (tmp___0 != 0L) {
#line 264
    goto err;
  } else {

  }
#line 273
  if ((int )pin) {
#line 274
    placement = & vmw_vram_gmr_ne_placement;
  } else {
#line 276
    placement = & vmw_vram_gmr_placement;
  }
#line 278
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0);
#line 279
  tmp___1 = ldv__builtin_expect(ret == 0, 1L);
#line 279
  if (tmp___1 != 0L || ret == -512) {
#line 280
    goto err_unreserve;
  } else {

  }
#line 288
  if ((int )pin) {
#line 289
    placement = & vmw_vram_ne_placement;
  } else {
#line 291
    placement = & vmw_vram_placement;
  }
#line 293
  ret = ttm_bo_validate(bo, placement, (int )interruptible, 0);
  err_unreserve: 
#line 296
  ttm_bo_unreserve(bo);
  err: 
#line 298
  ttm_write_unlock(& vmaster->lock);
#line 299
  return (ret);
}
}
#line 317 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                       bool pin , bool interruptible ) 
{ struct ttm_placement *placement ;
  int tmp ;

  {
#line 323
  if ((int )pin) {
#line 324
    placement = & vmw_vram_ne_placement;
  } else {
#line 326
    placement = & vmw_vram_placement;
  }
#line 328
  tmp = vmw_dmabuf_to_placement(dev_priv, buf, placement, (int )interruptible);
#line 328
  return (tmp);
}
}
#line 349 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_to_start_of_vram(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf ,
                                bool pin , bool interruptible ) 
{ struct vmw_master *vmaster ;
  struct ttm_buffer_object *bo ;
  struct ttm_placement placement ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
#line 353
  vmaster = dev_priv->active_master;
#line 354
  bo = & buf->base;
#line 356
  ret = 0;
#line 358
  if ((int )pin) {
#line 359
    placement = vmw_vram_ne_placement;
  } else {
#line 361
    placement = vmw_vram_placement;
  }
#line 362
  placement.lpfn = (unsigned int )bo->num_pages;
#line 364
  ret = ttm_write_lock(& vmaster->lock, (int )interruptible);
#line 365
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 365
  if (tmp != 0L) {
#line 366
    return (ret);
  } else {

  }
#line 368
  if ((int )pin) {
#line 369
    vmw_execbuf_release_pinned_bo(dev_priv);
  } else {

  }
#line 370
  ret = ttm_bo_reserve(bo, (int )interruptible, 0, 0, 0U);
#line 371
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 371
  if (tmp___0 != 0L) {
#line 372
    goto err_unlock;
  } else {

  }
#line 375
  if ((bo->mem.mem_type == 2U && bo->mem.start < bo->num_pages) && bo->mem.start != 0UL) {
#line 378
    ttm_bo_validate(bo, & vmw_sys_placement, 0, 0);
  } else {

  }
#line 380
  ret = ttm_bo_validate(bo, & placement, (int )interruptible, 0);
#line 383
  __ret_warn_on = ret == 0 && bo->offset != 0UL;
#line 383
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 383
  if (tmp___1 != 0L) {
#line 383
    warn_slowpath_null("/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared",
                       383);
  } else {

  }
#line 383
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 385
  ttm_bo_unreserve(bo);
  err_unlock: 
#line 387
  ttm_write_unlock(& vmaster->lock);
#line 389
  return (ret);
}
}
#line 407 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int vmw_dmabuf_unpin(struct vmw_private *dev_priv , struct vmw_dma_buffer *buf , bool interruptible ) 
{ int tmp ;

  {
#line 416
  tmp = vmw_dmabuf_to_placement(dev_priv, buf, & vmw_evictable_placement, (int )interruptible);
#line 416
  return (tmp);
}
}
#line 429 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void vmw_bo_get_guest_ptr(struct ttm_buffer_object  const  *bo , SVGAGuestPtr *ptr ) 
{ 

  {
#line 432
  if ((unsigned int )bo->mem.mem_type == 2U) {
#line 433
    ptr->gmrId = 4294967294U;
#line 434
    ptr->offset = (uint32 )bo->offset;
  } else {
#line 436
    ptr->gmrId = (uint32 )bo->mem.start;
#line 437
    ptr->offset = 0U;
  }
#line 439
  return;
}
}
#line 450 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void vmw_bo_pin(struct ttm_buffer_object *bo , bool pin ) 
{ uint32_t pl_flags ;
  struct ttm_placement placement ;
  uint32_t old_mem_type ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
#line 454
  old_mem_type = bo->mem.mem_type;
#line 457
  tmp = ttm_bo_is_reserved(bo);
#line 457
  if (tmp) {
#line 457
    tmp___0 = 0;
  } else {
#line 457
    tmp___0 = 1;
  }
#line 457
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 457
  if (tmp___1 != 0L) {
#line 457
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                         "i" (457), "i" (12UL));
    ldv_40630: ;
#line 457
    goto ldv_40630;
  } else {

  }
#line 458
  tmp___2 = ldv__builtin_expect(old_mem_type != 2U, 0L);
#line 458
  if (tmp___2 != 0L) {
#line 458
    tmp___3 = ldv__builtin_expect(old_mem_type != 3U, 0L);
#line 458
    if (tmp___3 != 0L) {
#line 458
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                           "i" (459), "i" (12UL));
      ldv_40631: ;
#line 458
      goto ldv_40631;
    } else {

    }
  } else {

  }
#line 461
  pl_flags = 65548U;
#line 462
  if ((int )pin) {
#line 463
    pl_flags = pl_flags | 2097152U;
  } else {

  }
#line 465
  memset((void *)(& placement), 0, 40UL);
#line 466
  placement.num_placement = 1U;
#line 467
  placement.placement = (uint32_t const   *)(& pl_flags);
#line 469
  ret = ttm_bo_validate(bo, & placement, 0, 1);
#line 471
  tmp___4 = ldv__builtin_expect(ret != 0, 0L);
#line 471
  if (tmp___4 != 0L) {
#line 471
    goto _L;
  } else {
#line 471
    tmp___5 = ldv__builtin_expect(bo->mem.mem_type != old_mem_type, 0L);
#line 471
    if (tmp___5 != 0L) {
      _L: /* CIL Label */ 
#line 471
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"),
                           "i" (471), "i" (12UL));
      ldv_40632: ;
#line 471
      goto ldv_40632;
    } else {

    }
  }
#line 473
  return;
}
}
#line 474 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_631(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 479
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 481
  mutex_lock(ldv_func_arg1);
#line 482
  return;
}
}
#line 484 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_632(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 489
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 491
  mutex_unlock(ldv_func_arg1);
#line 492
  return;
}
}
#line 494 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_633(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 499
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
int ldv_mutex_trylock_634(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 509
  tmp = mutex_trylock(ldv_func_arg1);
#line 509
  ldv_func_res = tmp;
#line 511
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 511
  return (tmp___0);
#line 513
  return (ldv_func_res);
}
}
#line 516 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_635(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 521
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 523
  mutex_unlock(ldv_func_arg1);
#line 524
  return;
}
}
#line 526 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_636(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 531
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 533
  mutex_lock(ldv_func_arg1);
#line 534
  return;
}
}
#line 536 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_637(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 541
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 543
  mutex_unlock(ldv_func_arg1);
#line 544
  return;
}
}
#line 546 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_638(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 551
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 553
  mutex_lock(ldv_func_arg1);
#line 554
  return;
}
}
#line 556 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_639(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 561
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 563
  mutex_unlock(ldv_func_arg1);
#line 564
  return;
}
}
#line 566 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_640(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 571
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 573
  mutex_unlock(ldv_func_arg1);
#line 574
  return;
}
}
#line 576 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_641(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 581
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 583
  mutex_lock(ldv_func_arg1);
#line 584
  return;
}
}
#line 586 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_642(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 591
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 593
  mutex_unlock(ldv_func_arg1);
#line 594
  return;
}
}
#line 596 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_lock_643(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 601
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 603
  mutex_lock(ldv_func_arg1);
#line 604
  return;
}
}
#line 606 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c.prepared"
void ldv_mutex_unlock_644(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 611
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 613
  mutex_unlock(ldv_func_arg1);
#line 614
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_662(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_660(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_663(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_665(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_667(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_668(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_670(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_672(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_659(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_661(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_664(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_666(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_669(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_671(struct mutex *ldv_func_arg1 ) ;
#line 210 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_destroy(struct vmw_screen_object_unit *sou ) 
{ 

  {
#line 212
  vmw_display_unit_cleanup(& sou->base);
#line 213
  kfree((void const   *)sou);
#line 214
  return;
}
}
#line 221 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_crtc_destroy(struct drm_crtc *crtc ) 
{ struct drm_crtc  const  *__mptr ;

  {
#line 223
  __mptr = (struct drm_crtc  const  *)crtc;
#line 223
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr);
#line 225
  return;
}
}
#line 226 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_del_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ) 
{ struct vmw_screen_object_display *ld ;

  {
#line 229
  ld = vmw_priv___0->sou_priv;
#line 231
  if ((int )sou->active_implicit) {
#line 232
    ld->num_implicit = ld->num_implicit - 1U;
#line 232
    if (ld->num_implicit == 0U) {
#line 233
      ld->implicit_fb = 0;
    } else {

    }
#line 234
    sou->active_implicit = 0;
  } else {

  }
#line 236
  return;
}
}
#line 238 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_add_active(struct vmw_private *vmw_priv___0 , struct vmw_screen_object_unit *sou ,
                               struct vmw_framebuffer *vfb ) 
{ struct vmw_screen_object_display *ld ;
  long tmp ;
  long tmp___0 ;

  {
#line 242
  ld = vmw_priv___0->sou_priv;
#line 244
  tmp = ldv__builtin_expect(ld->num_implicit == 0U, 0L);
#line 244
  if (tmp != 0L) {
#line 244
    tmp___0 = ldv__builtin_expect((unsigned long )ld->implicit_fb != (unsigned long )((struct vmw_framebuffer *)0),
                               0L);
#line 244
    if (tmp___0 != 0L) {
#line 244
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                           "i" (244), "i" (12UL));
      ldv_40831: ;
#line 244
      goto ldv_40831;
    } else {

    }
  } else {

  }
#line 246
  if (! sou->active_implicit && (int )sou->base.is_implicit) {
#line 247
    ld->implicit_fb = vfb;
#line 248
    sou->active_implicit = 1;
#line 249
    ld->num_implicit = ld->num_implicit + 1U;
  } else {

  }
#line 251
  return;
}
}
#line 256 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_fifo_create(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                               uint32_t x , uint32_t y , struct drm_display_mode *mode ) 
{ size_t fifo_size ;
  struct __anonstruct_cmd_293 *cmd ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 270
  tmp = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                         0L);
#line 270
  if (tmp != 0L) {
#line 270
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                         "i" (270), "i" (12UL));
    ldv_40846: ;
#line 270
    goto ldv_40846;
  } else {

  }
#line 272
  fifo_size = 48UL;
#line 273
  tmp___0 = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 273
  cmd = (struct __anonstruct_297___0 *)tmp___0;
#line 275
  tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_293 *)0),
                             0L);
#line 275
  if (tmp___1 != 0L) {
#line 276
    drm_err("vmw_sou_fifo_create", "Fifo reserve failed.\n");
#line 277
    return (-12);
  } else {

  }
#line 280
  memset((void *)cmd, 0, fifo_size);
#line 281
  cmd->header.cmdType = 34U;
#line 282
  cmd->obj.structSize = 44U;
#line 283
  cmd->obj.id = sou->base.unit;
#line 284
  if (sou->base.unit == 0U) {
#line 284
    cmd->obj.flags = 3U;
  } else {
#line 284
    cmd->obj.flags = 1U;
  }
#line 286
  cmd->obj.size.width = (uint32 )mode->hdisplay;
#line 287
  cmd->obj.size.height = (uint32 )mode->vdisplay;
#line 288
  if ((int )sou->base.is_implicit) {
#line 289
    cmd->obj.root.x = (int32 )x;
#line 290
    cmd->obj.root.y = (int32 )y;
  } else {
#line 292
    cmd->obj.root.x = sou->base.gui_x;
#line 293
    cmd->obj.root.y = sou->base.gui_y;
  }
#line 297
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)(& (sou->buffer)->base),
                       & cmd->obj.backingStore.ptr);
#line 298
  cmd->obj.backingStore.pitch = (uint32 )(mode->hdisplay * 4);
#line 300
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 302
  sou->defined = 1;
#line 304
  return (0);
}
}
#line 310 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_fifo_destroy(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ size_t fifo_size ;
  int ret ;
  struct __anonstruct_cmd_302 *cmd ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 324
  tmp = ldv__builtin_expect((long )(! sou->defined), 0L);
#line 324
  if (tmp != 0L) {
#line 325
    return (0);
  } else {

  }
#line 327
  fifo_size = 8UL;
#line 328
  tmp___0 = vmw_fifo_reserve(dev_priv, (uint32_t )fifo_size);
#line 328
  cmd = (struct __anonstruct_306 *)tmp___0;
#line 330
  tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_302 *)0),
                             0L);
#line 330
  if (tmp___1 != 0L) {
#line 331
    drm_err("vmw_sou_fifo_destroy", "Fifo reserve failed.\n");
#line 332
    return (-12);
  } else {

  }
#line 335
  memset((void *)cmd, 0, fifo_size);
#line 336
  cmd->header.cmdType = 35U;
#line 337
  cmd->body.screenId = sou->base.unit;
#line 339
  vmw_fifo_commit(dev_priv, (uint32_t )fifo_size);
#line 342
  ret = vmw_fallback_wait(dev_priv, 0, 1, 0U, 0, 750UL);
#line 343
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 343
  if (tmp___2 != 0L) {
#line 344
    drm_err("vmw_sou_fifo_destroy", "Failed to sync with HW");
  } else {
#line 346
    sou->defined = 0;
  }
#line 348
  return (ret);
}
}
#line 354 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_backing_free(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ) 
{ struct ttm_buffer_object *bo ;
  long tmp ;

  {
#line 359
  tmp = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                         0L);
#line 359
  if (tmp != 0L) {
#line 360
    return;
  } else {

  }
#line 362
  bo = & (sou->buffer)->base;
#line 363
  ttm_bo_unref(& bo);
#line 364
  sou->buffer = 0;
#line 365
  sou->buffer_size = 0UL;
#line 366
  return;
}
}
#line 371 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_backing_alloc(struct vmw_private *dev_priv , struct vmw_screen_object_unit *sou ,
                                 unsigned long size ) 
{ int ret ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 377
  if (sou->buffer_size == size) {
#line 378
    return (0);
  } else {

  }
#line 380
  if ((unsigned long )sou->buffer != (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 381
    vmw_sou_backing_free(dev_priv, sou);
  } else {

  }
#line 383
  tmp = kzalloc(440UL, 208U);
#line 383
  sou->buffer = (struct vmw_dma_buffer *)tmp;
#line 384
  tmp___0 = ldv__builtin_expect((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0),
                             0L);
#line 384
  if (tmp___0 != 0L) {
#line 385
    return (-12);
  } else {

  }
#line 390
  vmw_overlay_pause_all(dev_priv);
#line 391
  ret = vmw_dmabuf_init(dev_priv, sou->buffer, size, & vmw_vram_ne_placement, 0, & vmw_dmabuf_bo_free);
#line 394
  vmw_overlay_resume_all(dev_priv);
#line 396
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 396
  if (tmp___1 != 0L) {
#line 397
    sou->buffer = 0;
  } else {
#line 399
    sou->buffer_size = size;
  }
#line 401
  return (ret);
}
}
#line 404 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_crtc_set_config(struct drm_mode_set *set ) 
{ struct vmw_private *dev_priv ;
  struct vmw_screen_object_unit *sou ;
  struct drm_connector *connector ;
  struct drm_display_mode *mode ;
  struct drm_encoder *encoder ;
  struct vmw_framebuffer *vfb ;
  struct drm_framebuffer *fb ;
  struct drm_crtc *crtc ;
  int ret ;
  struct drm_crtc  const  *__mptr ;
  struct drm_framebuffer  const  *__mptr___0 ;
  long tmp ;
  long tmp___0 ;
  size_t size ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 414
  ret = 0;
#line 416
  if ((unsigned long )set == (unsigned long )((struct drm_mode_set *)0)) {
#line 417
    return (-22);
  } else {

  }
#line 419
  if ((unsigned long )set->crtc == (unsigned long )((struct drm_crtc *)0)) {
#line 420
    return (-22);
  } else {

  }
#line 423
  crtc = set->crtc;
#line 424
  __mptr = (struct drm_crtc  const  *)crtc;
#line 424
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 425
  if ((unsigned long )set->fb != (unsigned long )((struct drm_framebuffer *)0)) {
#line 425
    __mptr___0 = (struct drm_framebuffer  const  *)set->fb;
#line 425
    vfb = (struct vmw_framebuffer *)__mptr___0;
  } else {
#line 425
    vfb = 0;
  }
#line 426
  dev_priv = vmw_priv(crtc->dev);
#line 428
  if (set->num_connectors > 1UL) {
#line 429
    drm_err("vmw_sou_crtc_set_config", "to many connectors\n");
#line 430
    return (-22);
  } else {

  }
#line 433
  if (set->num_connectors == 1UL && (unsigned long )*(set->connectors) != (unsigned long )(& sou->base.connector)) {
#line 435
    drm_err("vmw_sou_crtc_set_config", "connector doesn\'t match %p %p\n", *(set->connectors),
            & sou->base.connector);
#line 437
    return (-22);
  } else {

  }
#line 441
  if (((((int )sou->base.is_implicit && (unsigned long )(dev_priv->sou_priv)->implicit_fb != (unsigned long )((struct vmw_framebuffer *)0)) && (unsigned long )vfb != (unsigned long )((struct vmw_framebuffer *)0)) && ((dev_priv->sou_priv)->num_implicit != 1U || ! sou->active_implicit)) && (unsigned long )(dev_priv->sou_priv)->implicit_fb != (unsigned long )vfb) {
#line 446
    drm_err("vmw_sou_crtc_set_config", "Multiple framebuffers not supported\n");
#line 447
    return (-22);
  } else {

  }
#line 451
  connector = & sou->base.connector;
#line 452
  encoder = & sou->base.encoder;
#line 455
  if ((set->num_connectors == 0UL || (unsigned long )set->mode == (unsigned long )((struct drm_display_mode *)0)) || (unsigned long )set->fb == (unsigned long )((struct drm_framebuffer *)0)) {
#line 456
    ret = vmw_sou_fifo_destroy(dev_priv, sou);
#line 458
    tmp = ldv__builtin_expect(ret != 0, 0L);
#line 458
    if (tmp != 0L) {
#line 459
      return (ret);
    } else {

    }
#line 461
    connector->encoder = 0;
#line 462
    encoder->crtc = 0;
#line 463
    crtc->fb = 0;
#line 464
    crtc->x = 0;
#line 465
    crtc->y = 0;
#line 467
    vmw_sou_del_active(dev_priv, sou);
#line 469
    vmw_sou_backing_free(dev_priv, sou);
#line 471
    return (0);
  } else {

  }
#line 476
  mode = set->mode;
#line 477
  fb = set->fb;
#line 479
  if (set->x + (uint32_t )mode->hdisplay > fb->width || set->y + (uint32_t )mode->vdisplay > fb->height) {
#line 481
    drm_err("vmw_sou_crtc_set_config", "set outside of framebuffer\n");
#line 482
    return (-22);
  } else {

  }
#line 485
  vmw_fb_off(dev_priv);
#line 487
  if (mode->hdisplay != crtc->mode.hdisplay || mode->vdisplay != crtc->mode.vdisplay) {
#line 493
    ret = vmw_sou_fifo_destroy(dev_priv, sou);
#line 495
    tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 495
    if (tmp___0 != 0L) {
#line 496
      return (ret);
    } else {

    }
#line 498
    vmw_sou_backing_free(dev_priv, sou);
  } else {

  }
#line 501
  if ((unsigned long )sou->buffer == (unsigned long )((struct vmw_dma_buffer *)0)) {
#line 503
    size = (size_t )((mode->hdisplay * mode->vdisplay) * 4);
#line 504
    ret = vmw_sou_backing_alloc(dev_priv, sou, size);
#line 505
    tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 505
    if (tmp___1 != 0L) {
#line 506
      return (ret);
    } else {

    }
  } else {

  }
#line 509
  ret = vmw_sou_fifo_create(dev_priv, sou, set->x, set->y, mode);
#line 510
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 510
  if (tmp___2 != 0L) {
#line 518
    if ((int )sou->defined) {
#line 519
      return (ret);
    } else {

    }
#line 521
    connector->encoder = 0;
#line 522
    encoder->crtc = 0;
#line 523
    crtc->fb = 0;
#line 524
    crtc->x = 0;
#line 525
    crtc->y = 0;
#line 527
    return (ret);
  } else {

  }
#line 530
  vmw_sou_add_active(dev_priv, sou, vfb);
#line 532
  connector->encoder = encoder;
#line 533
  encoder->crtc = crtc;
#line 534
  crtc->mode = *mode;
#line 535
  crtc->fb = fb;
#line 536
  crtc->x = (int )set->x;
#line 537
  crtc->y = (int )set->y;
#line 539
  return (0);
}
}
#line 542 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_crtc_funcs vmw_screen_object_crtc_funcs  = 
#line 542
     {& vmw_du_crtc_save, & vmw_du_crtc_restore, 0, & vmw_du_crtc_cursor_set, & vmw_du_crtc_cursor_move,
    & vmw_du_crtc_gamma_set, & vmw_sou_crtc_destroy, & vmw_sou_crtc_set_config, & vmw_du_page_flip,
    0};
#line 557 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_encoder_destroy(struct drm_encoder *encoder ) 
{ struct drm_encoder  const  *__mptr ;

  {
#line 559
  __mptr = (struct drm_encoder  const  *)encoder;
#line 559
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr + 0xfffffffffffffca8UL);
#line 561
  return;
}
}
#line 562 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_encoder_funcs vmw_screen_object_encoder_funcs  =    {0, & vmw_sou_encoder_destroy};
#line 570 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static void vmw_sou_connector_destroy(struct drm_connector *connector ) 
{ struct drm_connector  const  *__mptr ;

  {
#line 572
  __mptr = (struct drm_connector  const  *)connector;
#line 572
  vmw_sou_destroy((struct vmw_screen_object_unit *)__mptr + 0xfffffffffffffc58UL);
#line 574
  return;
}
}
#line 575 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static struct drm_connector_funcs vmw_legacy_connector_funcs___0  = 
#line 575
     {& vmw_du_connector_dpms, & vmw_du_connector_save, & vmw_du_connector_restore,
    0, & vmw_du_connector_detect, & vmw_du_connector_fill_modes, & vmw_du_connector_set_property,
    & vmw_sou_connector_destroy, 0};
#line 585 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
static int vmw_sou_init(struct vmw_private *dev_priv , unsigned int unit ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_device *dev ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_crtc *crtc ;
  void *tmp ;

  {
#line 588
  dev = dev_priv->dev;
#line 593
  tmp = kzalloc(2896UL, 208U);
#line 593
  sou = (struct vmw_screen_object_unit *)tmp;
#line 594
  if ((unsigned long )sou == (unsigned long )((struct vmw_screen_object_unit *)0)) {
#line 595
    return (-12);
  } else {

  }
#line 597
  sou->base.unit = unit;
#line 598
  crtc = & sou->base.crtc;
#line 599
  encoder = & sou->base.encoder;
#line 600
  connector = & sou->base.connector;
#line 602
  sou->active_implicit = 0;
#line 604
  sou->base.pref_active = unit == 0U;
#line 605
  sou->base.pref_width = dev_priv->initial_width;
#line 606
  sou->base.pref_height = dev_priv->initial_height;
#line 607
  sou->base.pref_mode = 0;
#line 608
  sou->base.is_implicit = 1;
#line 610
  drm_connector_init(dev, connector, (struct drm_connector_funcs  const  *)(& vmw_legacy_connector_funcs___0),
                     15);
#line 612
  connector->status = vmw_du_connector_detect(connector, 1);
#line 614
  drm_encoder_init(dev, encoder, (struct drm_encoder_funcs  const  *)(& vmw_screen_object_encoder_funcs),
                   5);
#line 616
  drm_mode_connector_attach_encoder(connector, encoder);
#line 617
  encoder->possible_crtcs = (uint32_t )(1 << (int )unit);
#line 618
  encoder->possible_clones = 0U;
#line 620
  drm_crtc_init(dev, crtc, (struct drm_crtc_funcs  const  *)(& vmw_screen_object_crtc_funcs));
#line 622
  drm_mode_crtc_set_gamma_size(crtc, 256);
#line 624
  drm_object_attach_property(& connector->base, dev->mode_config.dirty_info_property,
                             1ULL);
#line 628
  return (0);
}
}
#line 631 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;
  int i ;
  int ret ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 633
  dev = dev_priv->dev;
#line 636
  if ((unsigned long )dev_priv->sou_priv != (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 637
    printk("\016[drm] sou system already on\n");
#line 638
    return (-22);
  } else {

  }
#line 641
  if ((dev_priv->capabilities & 8388608U) == 0U) {
#line 642
    printk("\016[drm] Not using screen objects, missing cap SCREEN_OBJECT_2\n");
#line 644
    return (-38);
  } else {

  }
#line 647
  ret = -12;
#line 648
  tmp = kmalloc(16UL, 208U);
#line 648
  dev_priv->sou_priv = (struct vmw_screen_object_display *)tmp;
#line 649
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0),
                             0L);
#line 649
  if (tmp___0 != 0L) {
#line 650
    goto err_no_mem;
  } else {

  }
#line 652
  (dev_priv->sou_priv)->num_implicit = 0U;
#line 653
  (dev_priv->sou_priv)->implicit_fb = 0;
#line 655
  ret = drm_vblank_init(dev, 8);
#line 656
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 656
  if (tmp___1 != 0L) {
#line 657
    goto err_free;
  } else {

  }
#line 659
  ret = drm_mode_create_dirty_info_property(dev);
#line 660
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 660
  if (tmp___2 != 0L) {
#line 661
    goto err_vblank_cleanup;
  } else {

  }
#line 663
  i = 0;
#line 663
  goto ldv_40922;
  ldv_40921: 
#line 664
  vmw_sou_init(dev_priv, (unsigned int )i);
#line 663
  i = i + 1;
  ldv_40922: ;
#line 663
  if (i <= 7) {
#line 664
    goto ldv_40921;
  } else {
#line 666
    goto ldv_40923;
  }
  ldv_40923: 
#line 666
  printk("\016[drm] Screen objects system initialized\n");
#line 668
  return (0);
  err_vblank_cleanup: 
#line 671
  drm_vblank_cleanup(dev);
  err_free: 
#line 673
  kfree((void const   *)dev_priv->sou_priv);
#line 674
  dev_priv->sou_priv = 0;
  err_no_mem: ;
#line 676
  return (ret);
}
}
#line 679 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv ) 
{ struct drm_device *dev ;

  {
#line 681
  dev = dev_priv->dev;
#line 683
  if ((unsigned long )dev_priv->sou_priv == (unsigned long )((struct vmw_screen_object_display *)0)) {
#line 684
    return (-38);
  } else {

  }
#line 686
  drm_vblank_cleanup(dev);
#line 688
  kfree((void const   *)dev_priv->sou_priv);
#line 690
  return (0);
}
}
#line 697 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_crtc  const  *__mptr ;

  {
#line 700
  __mptr = (struct drm_crtc  const  *)crtc;
#line 700
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 702
  if (! sou->base.is_implicit) {
#line 703
    return (1);
  } else {

  }
#line 705
  if ((dev_priv->sou_priv)->num_implicit != 1U) {
#line 706
    return (0);
  } else {

  }
#line 708
  return (1);
}
}
#line 715 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv , struct drm_crtc *crtc ) 
{ struct vmw_screen_object_unit *sou ;
  struct drm_crtc  const  *__mptr ;
  long tmp ;
  struct drm_framebuffer  const  *__mptr___0 ;

  {
#line 718
  __mptr = (struct drm_crtc  const  *)crtc;
#line 718
  sou = (struct vmw_screen_object_unit *)__mptr;
#line 720
  tmp = ldv__builtin_expect((long )(! sou->base.is_implicit), 0L);
#line 720
  if (tmp != 0L) {
#line 720
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"),
                         "i" (720), "i" (12UL));
    ldv_40942: ;
#line 720
    goto ldv_40942;
  } else {

  }
#line 723
  __mptr___0 = (struct drm_framebuffer  const  *)sou->base.crtc.fb;
#line 723
  (dev_priv->sou_priv)->implicit_fb = (struct vmw_framebuffer *)__mptr___0;
#line 725
  return;
}
}
#line 726 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int ldvarg77  ;
#line 727
extern int ldv_vmw_screen_object_crtc_funcs_probe_6(void) ;
#line 728 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int ldvarg101  ;
#line 729 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
u16 *ldvarg67  ;
#line 730 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct drm_crtc *vmw_screen_object_crtc_funcs_group0  ;
#line 731 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
uint32_t ldvarg71  ;
#line 732 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
bool ldvarg100  ;
#line 733 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct drm_file *ldvarg72  ;
#line 734 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
uint32_t ldvarg65  ;
#line 735 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
uint64_t ldvarg98  ;
#line 736 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
uint32_t ldvarg97  ;
#line 737 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct drm_mode_set *ldvarg64  ;
#line 738 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
u16 *ldvarg66  ;
#line 739 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
uint32_t ldvarg96  ;
#line 740 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct drm_property *ldvarg99  ;
#line 741 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
uint32_t ldvarg73  ;
#line 742 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
uint32_t ldvarg70  ;
#line 743 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
u16 *ldvarg68  ;
#line 744 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
uint32_t ldvarg69  ;
#line 745
extern int ldv_vmw_legacy_connector_funcs_probe_4(void) ;
#line 746
extern int ldv_vmw_screen_object_encoder_funcs_probe_5(void) ;
#line 747 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct drm_encoder *ldvarg117  ;
#line 748 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int ldvarg76  ;
#line 749 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct drm_pending_vblank_event *ldvarg74  ;
#line 750 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
struct drm_framebuffer *ldvarg75  ;
#line 752 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_main_exported_6(void) 
{ int tmp ;

  {
#line 754
  tmp = __VERIFIER_nondet_int();
#line 754
  switch (tmp) {
  case 0: ;
#line 757
  if (ldv_state_variable_6 == 1) {
#line 759
    vmw_du_crtc_cursor_move(vmw_screen_object_crtc_funcs_group0, ldvarg77, ldvarg76);
#line 761
    ldv_state_variable_6 = 1;
  } else {

  }
#line 764
  if (ldv_state_variable_6 == 2) {
#line 766
    vmw_du_crtc_cursor_move(vmw_screen_object_crtc_funcs_group0, ldvarg77, ldvarg76);
#line 768
    ldv_state_variable_6 = 2;
  } else {

  }
#line 771
  goto ldv_40978;
  case 1: ;
#line 774
  if (ldv_state_variable_6 == 1) {
#line 776
    vmw_du_page_flip(vmw_screen_object_crtc_funcs_group0, ldvarg75, ldvarg74);
#line 778
    ldv_state_variable_6 = 1;
  } else {

  }
#line 781
  if (ldv_state_variable_6 == 2) {
#line 783
    vmw_du_page_flip(vmw_screen_object_crtc_funcs_group0, ldvarg75, ldvarg74);
#line 785
    ldv_state_variable_6 = 2;
  } else {

  }
#line 788
  goto ldv_40978;
  case 2: ;
#line 791
  if (ldv_state_variable_6 == 1) {
#line 793
    vmw_du_crtc_cursor_set(vmw_screen_object_crtc_funcs_group0, ldvarg72, ldvarg71,
                           ldvarg70, ldvarg73);
#line 795
    ldv_state_variable_6 = 1;
  } else {

  }
#line 798
  if (ldv_state_variable_6 == 2) {
#line 800
    vmw_du_crtc_cursor_set(vmw_screen_object_crtc_funcs_group0, ldvarg72, ldvarg71,
                           ldvarg70, ldvarg73);
#line 802
    ldv_state_variable_6 = 2;
  } else {

  }
#line 805
  goto ldv_40978;
  case 3: ;
#line 808
  if (ldv_state_variable_6 == 2) {
#line 810
    vmw_sou_crtc_destroy(vmw_screen_object_crtc_funcs_group0);
#line 812
    ldv_state_variable_6 = 1;
#line 813
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 816
  goto ldv_40978;
  case 4: ;
#line 819
  if (ldv_state_variable_6 == 1) {
#line 821
    vmw_du_crtc_save(vmw_screen_object_crtc_funcs_group0);
#line 823
    ldv_state_variable_6 = 1;
  } else {

  }
#line 826
  if (ldv_state_variable_6 == 2) {
#line 828
    vmw_du_crtc_save(vmw_screen_object_crtc_funcs_group0);
#line 830
    ldv_state_variable_6 = 2;
  } else {

  }
#line 833
  goto ldv_40978;
  case 5: ;
#line 836
  if (ldv_state_variable_6 == 1) {
#line 838
    vmw_du_crtc_gamma_set(vmw_screen_object_crtc_funcs_group0, ldvarg68, ldvarg67,
                          ldvarg66, ldvarg69, ldvarg65);
#line 840
    ldv_state_variable_6 = 1;
  } else {

  }
#line 843
  if (ldv_state_variable_6 == 2) {
#line 845
    vmw_du_crtc_gamma_set(vmw_screen_object_crtc_funcs_group0, ldvarg68, ldvarg67,
                          ldvarg66, ldvarg69, ldvarg65);
#line 847
    ldv_state_variable_6 = 2;
  } else {

  }
#line 850
  goto ldv_40978;
  case 6: ;
#line 853
  if (ldv_state_variable_6 == 1) {
#line 855
    vmw_du_crtc_restore(vmw_screen_object_crtc_funcs_group0);
#line 857
    ldv_state_variable_6 = 1;
  } else {

  }
#line 860
  if (ldv_state_variable_6 == 2) {
#line 862
    vmw_du_crtc_restore(vmw_screen_object_crtc_funcs_group0);
#line 864
    ldv_state_variable_6 = 2;
  } else {

  }
#line 867
  goto ldv_40978;
  case 7: ;
#line 870
  if (ldv_state_variable_6 == 1) {
#line 872
    vmw_sou_crtc_set_config(ldvarg64);
#line 874
    ldv_state_variable_6 = 1;
  } else {

  }
#line 877
  if (ldv_state_variable_6 == 2) {
#line 879
    vmw_sou_crtc_set_config(ldvarg64);
#line 881
    ldv_state_variable_6 = 2;
  } else {

  }
#line 884
  goto ldv_40978;
  case 8: ;
#line 887
  if (ldv_state_variable_6 == 1) {
#line 889
    ldv_vmw_screen_object_crtc_funcs_probe_6();
#line 891
    ldv_state_variable_6 = 2;
#line 892
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 895
  goto ldv_40978;
  default: ;
#line 896
  goto ldv_40978;
  }
  ldv_40978: ;
#line 900
  return;
}
}
#line 902 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_main_exported_4(void) 
{ int tmp ;

  {
#line 904
  tmp = __VERIFIER_nondet_int();
#line 904
  switch (tmp) {
  case 0: ;
#line 907
  if (ldv_state_variable_4 == 1) {
#line 909
    vmw_du_connector_dpms(vmw_legacy_connector_funcs_group0, ldvarg101);
#line 911
    ldv_state_variable_4 = 1;
  } else {

  }
#line 914
  if (ldv_state_variable_4 == 2) {
#line 916
    vmw_du_connector_dpms(vmw_legacy_connector_funcs_group0, ldvarg101);
#line 918
    ldv_state_variable_4 = 2;
  } else {

  }
#line 921
  goto ldv_40992;
  case 1: ;
#line 924
  if (ldv_state_variable_4 == 1) {
#line 926
    vmw_du_connector_detect(vmw_legacy_connector_funcs_group0, (int )ldvarg100);
#line 928
    ldv_state_variable_4 = 1;
  } else {

  }
#line 931
  if (ldv_state_variable_4 == 2) {
#line 933
    vmw_du_connector_detect(vmw_legacy_connector_funcs_group0, (int )ldvarg100);
#line 935
    ldv_state_variable_4 = 2;
  } else {

  }
#line 938
  goto ldv_40992;
  case 2: ;
#line 941
  if (ldv_state_variable_4 == 1) {
#line 943
    vmw_du_connector_set_property(vmw_legacy_connector_funcs_group0, ldvarg99, ldvarg98);
#line 945
    ldv_state_variable_4 = 1;
  } else {

  }
#line 948
  if (ldv_state_variable_4 == 2) {
#line 950
    vmw_du_connector_set_property(vmw_legacy_connector_funcs_group0, ldvarg99, ldvarg98);
#line 952
    ldv_state_variable_4 = 2;
  } else {

  }
#line 955
  goto ldv_40992;
  case 3: ;
#line 958
  if (ldv_state_variable_4 == 2) {
#line 960
    vmw_sou_connector_destroy(vmw_legacy_connector_funcs_group0);
#line 962
    ldv_state_variable_4 = 1;
#line 963
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 966
  goto ldv_40992;
  case 4: ;
#line 969
  if (ldv_state_variable_4 == 1) {
#line 971
    vmw_du_connector_save(vmw_legacy_connector_funcs_group0);
#line 973
    ldv_state_variable_4 = 1;
  } else {

  }
#line 976
  if (ldv_state_variable_4 == 2) {
#line 978
    vmw_du_connector_save(vmw_legacy_connector_funcs_group0);
#line 980
    ldv_state_variable_4 = 2;
  } else {

  }
#line 983
  goto ldv_40992;
  case 5: ;
#line 986
  if (ldv_state_variable_4 == 1) {
#line 988
    vmw_du_connector_restore(vmw_legacy_connector_funcs_group0);
#line 990
    ldv_state_variable_4 = 1;
  } else {

  }
#line 993
  if (ldv_state_variable_4 == 2) {
#line 995
    vmw_du_connector_restore(vmw_legacy_connector_funcs_group0);
#line 997
    ldv_state_variable_4 = 2;
  } else {

  }
#line 1000
  goto ldv_40992;
  case 6: ;
#line 1003
  if (ldv_state_variable_4 == 1) {
#line 1005
    vmw_du_connector_fill_modes(vmw_legacy_connector_funcs_group0, ldvarg97, ldvarg96);
#line 1007
    ldv_state_variable_4 = 1;
  } else {

  }
#line 1010
  if (ldv_state_variable_4 == 2) {
#line 1012
    vmw_du_connector_fill_modes(vmw_legacy_connector_funcs_group0, ldvarg97, ldvarg96);
#line 1014
    ldv_state_variable_4 = 2;
  } else {

  }
#line 1017
  goto ldv_40992;
  case 7: ;
#line 1020
  if (ldv_state_variable_4 == 1) {
#line 1022
    ldv_vmw_legacy_connector_funcs_probe_4();
#line 1024
    ldv_state_variable_4 = 2;
#line 1025
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1028
  goto ldv_40992;
  default: ;
#line 1029
  goto ldv_40992;
  }
  ldv_40992: ;
#line 1033
  return;
}
}
#line 1035 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_main_exported_5(void) 
{ int tmp ;

  {
#line 1037
  tmp = __VERIFIER_nondet_int();
#line 1037
  switch (tmp) {
  case 0: ;
#line 1040
  if (ldv_state_variable_5 == 2) {
#line 1042
    vmw_sou_encoder_destroy(ldvarg117);
#line 1044
    ldv_state_variable_5 = 1;
#line 1045
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1048
  goto ldv_41005;
  case 1: ;
#line 1051
  if (ldv_state_variable_5 == 1) {
#line 1053
    ldv_vmw_screen_object_encoder_funcs_probe_5();
#line 1055
    ldv_state_variable_5 = 2;
#line 1056
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 1059
  goto ldv_41005;
  default: ;
#line 1060
  goto ldv_41005;
  }
  ldv_41005: ;
#line 1064
  return;
}
}
#line 1065 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_659(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1070
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1072
  mutex_lock(ldv_func_arg1);
#line 1073
  return;
}
}
#line 1075 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_660(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1080
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1082
  mutex_unlock(ldv_func_arg1);
#line 1083
  return;
}
}
#line 1085 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_661(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1090
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1092
  mutex_lock(ldv_func_arg1);
#line 1093
  return;
}
}
#line 1095 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
int ldv_mutex_trylock_662(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1100
  tmp = mutex_trylock(ldv_func_arg1);
#line 1100
  ldv_func_res = tmp;
#line 1102
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1102
  return (tmp___0);
#line 1104
  return (ldv_func_res);
}
}
#line 1107 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_663(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1112
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1114
  mutex_unlock(ldv_func_arg1);
#line 1115
  return;
}
}
#line 1117 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_664(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1122
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1124
  mutex_lock(ldv_func_arg1);
#line 1125
  return;
}
}
#line 1127 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_665(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1132
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1134
  mutex_unlock(ldv_func_arg1);
#line 1135
  return;
}
}
#line 1137 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_666(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1142
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1144
  mutex_lock(ldv_func_arg1);
#line 1145
  return;
}
}
#line 1147 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_667(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1152
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1154
  mutex_unlock(ldv_func_arg1);
#line 1155
  return;
}
}
#line 1157 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_668(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1162
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 1164
  mutex_unlock(ldv_func_arg1);
#line 1165
  return;
}
}
#line 1167 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_669(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1172
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1174
  mutex_lock(ldv_func_arg1);
#line 1175
  return;
}
}
#line 1177 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_670(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1182
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1184
  mutex_unlock(ldv_func_arg1);
#line 1185
  return;
}
}
#line 1187 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_lock_671(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1192
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1194
  mutex_lock(ldv_func_arg1);
#line 1195
  return;
}
}
#line 1197 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c.prepared"
void ldv_mutex_unlock_672(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1202
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1204
  mutex_unlock(ldv_func_arg1);
#line 1205
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_690(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_688(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_691(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_693(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_695(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_696(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_700(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_687(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_689(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_692(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_694(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_697(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_699(struct mutex *ldv_func_arg1 ) ;
#line 421 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h"
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) ;
#line 190 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static void vmw_user_context_free(struct vmw_resource *res ) ;
#line 192
static struct vmw_resource *vmw_user_context_base_to_res(struct ttm_base_object *base ) ;
#line 194 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static uint64_t vmw_user_context_size  ;
#line 196 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static struct vmw_user_resource_conv  const  user_context_conv  =    {256, & vmw_user_context_base_to_res, & vmw_user_context_free};
#line 202 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct vmw_user_resource_conv  const  *user_context_converter  =    & user_context_conv;
#line 206 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static struct vmw_res_func  const  vmw_legacy_context_func  = 
#line 206
     {0, 0, "legacy contexts", 0, 0, 0, 0, 0, 0};
#line 222 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static void vmw_hw_context_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct __anonstruct_cmd_291___2 *cmd ;
  void *tmp ;
  long tmp___0 ;

  {
#line 225
  dev_priv = res->dev_priv;
#line 232
  vmw_execbuf_release_pinned_bo(dev_priv);
#line 233
  tmp = vmw_fifo_reserve(dev_priv, 12U);
#line 233
  cmd = (struct __anonstruct_293___1 *)tmp;
#line 234
  tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_291___2 *)0),
                             0L);
#line 234
  if (tmp___0 != 0L) {
#line 235
    drm_err("vmw_hw_context_destroy", "Failed reserving FIFO space for surface destruction.\n");
#line 237
    return;
  } else {

  }
#line 240
  cmd->header.id = 1046U;
#line 241
  cmd->header.size = 4U;
#line 242
  cmd->body.cid = (unsigned int )res->id;
#line 244
  vmw_fifo_commit(dev_priv, 12U);
#line 245
  vmw_3d_resource_dec(dev_priv, 0);
#line 246
  return;
}
}
#line 248 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static int vmw_context_init(struct vmw_private *dev_priv , struct vmw_resource *res ,
                            void (*res_free)(struct vmw_resource * ) ) 
{ int ret ;
  struct __anonstruct_cmd_295___0 *cmd ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 259
  ret = vmw_resource_init(dev_priv, res, 0, res_free, & vmw_legacy_context_func);
#line 262
  tmp = ldv__builtin_expect(ret != 0, 0L);
#line 262
  if (tmp != 0L) {
#line 263
    drm_err("vmw_context_init", "Failed to allocate a resource id.\n");
#line 264
    goto out_early;
  } else {

  }
#line 267
  tmp___0 = ldv__builtin_expect(res->id > 255, 0L);
#line 267
  if (tmp___0 != 0L) {
#line 268
    drm_err("vmw_context_init", "Out of hw context ids.\n");
#line 269
    vmw_resource_unreference(& res);
#line 270
    return (-12);
  } else {

  }
#line 273
  tmp___1 = vmw_fifo_reserve(dev_priv, 12U);
#line 273
  cmd = (struct __anonstruct_297___1 *)tmp___1;
#line 274
  tmp___2 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((struct __anonstruct_cmd_295___0 *)0),
                             0L);
#line 274
  if (tmp___2 != 0L) {
#line 275
    drm_err("vmw_context_init", "Fifo reserve failed.\n");
#line 276
    vmw_resource_unreference(& res);
#line 277
    return (-12);
  } else {

  }
#line 280
  cmd->header.id = 1045U;
#line 281
  cmd->header.size = 4U;
#line 282
  cmd->body.cid = (unsigned int )res->id;
#line 284
  vmw_fifo_commit(dev_priv, 12U);
#line 285
  vmw_3d_resource_inc(dev_priv, 0);
#line 286
  vmw_resource_activate(res, & vmw_hw_context_destroy);
#line 287
  return (0);
  out_early: ;
#line 290
  if ((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0)) {
#line 291
    kfree((void const   *)res);
  } else {
#line 293
    (*res_free)(res);
  }
#line 294
  return (ret);
}
}
#line 297 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv ) 
{ struct vmw_resource *res ;
  void *tmp ;
  int ret ;
  long tmp___0 ;
  struct vmw_resource *tmp___1 ;

  {
#line 299
  tmp = kmalloc(112UL, 208U);
#line 299
  res = (struct vmw_resource *)tmp;
#line 302
  tmp___0 = ldv__builtin_expect((unsigned long )res == (unsigned long )((struct vmw_resource *)0),
                             0L);
#line 302
  if (tmp___0 != 0L) {
#line 303
    return (0);
  } else {

  }
#line 305
  ret = vmw_context_init(dev_priv, res, 0);
#line 307
  if (ret == 0) {
#line 307
    tmp___1 = res;
  } else {
#line 307
    tmp___1 = 0;
  }
#line 307
  return (tmp___1);
}
}
#line 315 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static struct vmw_resource *vmw_user_context_base_to_res(struct ttm_base_object *base ) 
{ struct ttm_base_object  const  *__mptr ;

  {
#line 317
  __mptr = (struct ttm_base_object  const  *)base;
#line 317
  return (& ((struct vmw_user_context *)__mptr)->res);
}
}
#line 320 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static void vmw_user_context_free(struct vmw_resource *res ) 
{ struct vmw_user_context *ctx ;
  struct vmw_resource  const  *__mptr ;
  struct vmw_private *dev_priv ;
  struct ttm_mem_global *tmp ;

  {
#line 323
  __mptr = (struct vmw_resource  const  *)res;
#line 323
  ctx = (struct vmw_user_context *)__mptr + 0xffffffffffffffb0UL;
#line 324
  dev_priv = res->dev_priv;
#line 326
  kfree_call_rcu(& ctx->base.rhead, 0);
#line 327
  tmp = vmw_mem_glob(dev_priv);
#line 327
  ttm_mem_global_free(tmp, vmw_user_context_size);
#line 328
  return;
}
}
#line 336 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
static void vmw_user_context_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_context *ctx ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 338
  base = *p_base;
#line 340
  __mptr = (struct ttm_base_object  const  *)base;
#line 340
  ctx = (struct vmw_user_context *)__mptr;
#line 341
  res = & ctx->res;
#line 343
  *p_base = 0;
#line 344
  vmw_resource_unreference(& res);
#line 345
  return;
}
}
#line 347 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
int vmw_context_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 350
  arg = (struct drm_vmw_context_arg *)data;
#line 351
  tmp = vmw_fpriv(file_priv);
#line 351
  tfile = tmp->tfile;
#line 353
  tmp___0 = ttm_ref_object_base_unref(tfile, (unsigned long )arg->cid, 0);
#line 353
  return (tmp___0);
}
}
#line 356 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
int vmw_context_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_context *ctx ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  struct drm_vmw_context_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  int ret ;
  size_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  struct ttm_mem_global *tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  struct ttm_mem_global *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
#line 359
  tmp = vmw_priv(dev);
#line 359
  dev_priv = tmp;
#line 363
  arg = (struct drm_vmw_context_arg *)data;
#line 364
  tmp___1 = vmw_fpriv(file_priv);
#line 364
  tfile = tmp___1->tfile;
#line 365
  tmp___2 = vmw_master(file_priv->master);
#line 365
  vmaster = tmp___2;
#line 374
  tmp___4 = ldv__builtin_expect(vmw_user_context_size == 0ULL, 0L);
#line 374
  if (tmp___4 != 0L) {
#line 375
    tmp___3 = ttm_round_pot(192UL);
#line 375
    vmw_user_context_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 377
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 378
  tmp___5 = ldv__builtin_expect(ret != 0, 0L);
#line 378
  if (tmp___5 != 0L) {
#line 379
    return (ret);
  } else {

  }
#line 381
  tmp___6 = vmw_mem_glob(dev_priv);
#line 381
  ret = ttm_mem_global_alloc(tmp___6, vmw_user_context_size, 0, 1);
#line 384
  tmp___7 = ldv__builtin_expect(ret != 0, 0L);
#line 384
  if (tmp___7 != 0L) {
#line 385
    if (ret != -512) {
#line 386
      drm_err("vmw_context_define_ioctl", "Out of graphics memory for context creation.\n");
    } else {

    }
#line 388
    goto out_unlock;
  } else {

  }
#line 391
  tmp___8 = kzalloc(192UL, 208U);
#line 391
  ctx = (struct vmw_user_context *)tmp___8;
#line 392
  tmp___10 = ldv__builtin_expect((unsigned long )ctx == (unsigned long )((struct vmw_user_context *)0),
                              0L);
#line 392
  if (tmp___10 != 0L) {
#line 393
    tmp___9 = vmw_mem_glob(dev_priv);
#line 393
    ttm_mem_global_free(tmp___9, vmw_user_context_size);
#line 395
    ret = -12;
#line 396
    goto out_unlock;
  } else {

  }
#line 399
  res = & ctx->res;
#line 400
  ctx->base.shareable = 0;
#line 401
  ctx->base.tfile = 0;
#line 407
  ret = vmw_context_init(dev_priv, res, & vmw_user_context_free);
#line 408
  tmp___11 = ldv__builtin_expect(ret != 0, 0L);
#line 408
  if (tmp___11 != 0L) {
#line 409
    goto out_unlock;
  } else {

  }
#line 411
  tmp___0 = vmw_resource_reference(& ctx->res);
#line 412
  ret = ttm_base_object_init(tfile, & ctx->base, 0, 256, & vmw_user_context_base_release,
                             0);
#line 415
  tmp___12 = ldv__builtin_expect(ret != 0, 0L);
#line 415
  if (tmp___12 != 0L) {
#line 416
    vmw_resource_unreference(& tmp___0);
#line 417
    goto out_err;
  } else {

  }
#line 420
  arg->cid = (int32_t )ctx->base.hash.key;
  out_err: 
#line 422
  vmw_resource_unreference(& res);
  out_unlock: 
#line 424
  ttm_read_unlock(& vmaster->lock);
#line 425
  return (ret);
}
}
#line 428 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct vmw_resource *ldvarg79  ;
#line 429 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
struct ttm_base_object *ldvarg78  ;
#line 431 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_main_exported_3(void) 
{ int tmp ;

  {
#line 433
  tmp = __VERIFIER_nondet_int();
#line 433
  switch (tmp) {
  case 0: ;
#line 436
  if (ldv_state_variable_3 == 1) {
#line 438
    vmw_user_context_free(ldvarg79);
#line 440
    ldv_state_variable_3 = 1;
  } else {

  }
#line 443
  goto ldv_40695;
  case 1: ;
#line 446
  if (ldv_state_variable_3 == 1) {
#line 448
    vmw_user_context_base_to_res(ldvarg78);
#line 450
    ldv_state_variable_3 = 1;
  } else {

  }
#line 453
  goto ldv_40695;
  default: ;
#line 454
  goto ldv_40695;
  }
  ldv_40695: ;
#line 458
  return;
}
}
#line 459 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_687(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 464
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_688(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 474
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 476
  mutex_unlock(ldv_func_arg1);
#line 477
  return;
}
}
#line 479 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_689(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 484
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 486
  mutex_lock(ldv_func_arg1);
#line 487
  return;
}
}
#line 489 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
int ldv_mutex_trylock_690(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 494
  tmp = mutex_trylock(ldv_func_arg1);
#line 494
  ldv_func_res = tmp;
#line 496
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 496
  return (tmp___0);
#line 498
  return (ldv_func_res);
}
}
#line 501 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_691(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 506
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 508
  mutex_unlock(ldv_func_arg1);
#line 509
  return;
}
}
#line 511 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_692(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 516
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 518
  mutex_lock(ldv_func_arg1);
#line 519
  return;
}
}
#line 521 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_693(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 526
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 528
  mutex_unlock(ldv_func_arg1);
#line 529
  return;
}
}
#line 531 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_694(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 536
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 538
  mutex_lock(ldv_func_arg1);
#line 539
  return;
}
}
#line 541 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_695(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 546
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 548
  mutex_unlock(ldv_func_arg1);
#line 549
  return;
}
}
#line 551 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_696(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 556
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 558
  mutex_unlock(ldv_func_arg1);
#line 559
  return;
}
}
#line 561 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_697(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 566
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 568
  mutex_lock(ldv_func_arg1);
#line 569
  return;
}
}
#line 571 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 576
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 578
  mutex_unlock(ldv_func_arg1);
#line 579
  return;
}
}
#line 581 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_lock_699(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 586
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 588
  mutex_lock(ldv_func_arg1);
#line 589
  return;
}
}
#line 591 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_context.c.prepared"
void ldv_mutex_unlock_700(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 596
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 598
  mutex_unlock(ldv_func_arg1);
#line 599
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_718(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_716(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_719(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_721(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_723(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_724(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_726(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_728(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_730(struct mutex *ldv_func_arg1 ) ;
#line 10 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_715(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_717(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_720(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_722(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_725(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_727(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_729(struct mutex *ldv_func_arg1 ) ;
#line 219 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
static struct svga3d_surface_desc  const  svga3d_surface_descs[121U]  = 
#line 219 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
  {      {0, {1U, 1U, 1U, 0U}, 0U, 0U, {0U, {{0U}, {0U}, {0U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 4U, 4U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                      {16U}, {24U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{0U}, {8U}, {16U},
                                                                   {24U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{5U}, {6U}, {5U}, {0U}}}, {{{0U}, {5U},
                                                                      {11U}, {0U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 2U, 2U, {15U, {{5U}, {5U}, {5U}, {0U}}}, {{{0U}, {5U}, {10U},
                                                                   {0U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{5U}, {5U}, {5U}, {1U}}}, {{{0U}, {5U},
                                                                       {10U}, {15U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{4U}, {4U}, {4U}, {4U}}}, {{{0U}, {4U}, {8U},
                                                                   {12U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U},
                                                                       {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {1U}, {15U}, {0U}}}, {{{0U}, {15U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {12, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {4U}, {4U}}}, {{{0U}, {0U},
                                                                      {0U}, {4U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {12, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {8U}, {8U}}}, {{{0U}, {0U},
                                                                       {0U}, {8U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {32, {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U},
                                                                            {0U},
                                                                            {0U},
                                                                            {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {8U}, {8U}}}, {{{0U}, {0U}, {0U},
                                                                   {8U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{5U}, {5U}, {6U}, {0U}}}, {{{11U}, {6U},
                                                                      {0U}, {0U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {0U}}}, {{{16U}, {8U}, {0U},
                                                                   {0U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 3U, 3U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{16U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {79,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {79,
      {1U, 1U, 1U, 0U}, 16U, 16U, {128U, {{32U}, {32U}, {32U}, {32U}}}, {{{64U}, {32U},
                                                                          {0U}, {96U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{8U}, {8U}, {0U}, {0U}}}, {{{8U}, {0U}, {0U},
                                                                   {0U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{24U}, {16U},
                                                                       {8U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{8U}, {8U}, {0U}, {0U}}}, {{{8U}, {0U}, {0U},
                                                                   {0U}}}}, 
        {7, {1U, 1U, 1U, 0U}, 4U, 4U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{16U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {8,
      {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {0U}, {8U}}}, {{{0U}, {0U}, {0U},
                                                                  {0U}}}}, 
        {68, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {68,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {70, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {16U},
                                                                         {0U}, {0U}}}}, 
        {70,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {32U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                     {0U}, {0U}}}}, 
        {16,
      {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                  {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {24U}, {0U}}}, {{{0U}, {24U},
                                                                       {0U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{16U}, {16U}, {0U}, {0U}}}, {{{16U}, {0U},
                                                                     {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {0U}, {16U},
                                                                     {0U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U},
                                                                           {16U},
                                                                           {0U}, {48U}}}}, 
        {132,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{8U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {8U},
                                                                   {0U}}}}, 
        {132, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{8U}, {0U}, {8U}, {0U}}}, {{{8U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {8448,
      {2U, 2U, 1U, 0U}, 6U, 2U, {48U, {{0U}, {0U}, {48U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {1548, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{0U}, {8U},
                                                                         {16U}, {24U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 16U, 16U, {128U, {{32U}, {32U}, {32U}, {32U}}}, {{{64U}, {32U},
                                                                          {0U}, {96U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 16U, 16U, {128U, {{32U}, {32U}, {32U}, {32U}}}, {{{64U}, {32U},
                                                                          {0U}, {96U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 16U, 16U, {128U, {{32U}, {32U}, {32U}, {32U}}}, {{{64U}, {32U},
                                                                          {0U}, {96U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 12U, 12U, {96U, {{32U}, {32U}, {32U}, {0U}}}, {{{64U}, {32U},
                                                                        {0U}, {0U}}}}, 
        {71,
      {1U, 1U, 1U, 0U}, 12U, 12U, {96U, {{32U}, {32U}, {32U}, {0U}}}, {{{64U}, {32U},
                                                                        {0U}, {0U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 12U, 12U, {96U, {{32U}, {32U}, {32U}, {0U}}}, {{{64U}, {32U},
                                                                        {0U}, {0U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 12U, 12U, {96U, {{32U}, {32U}, {32U}, {0U}}}, {{{64U}, {32U},
                                                                        {0U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{16U}, {16U}, {16U}, {16U}}}, {{{32U}, {16U},
                                                                       {0U}, {48U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {32U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                     {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {32U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                     {0U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {32U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                     {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {8U}, {32U}, {0U}}}, {{{0U}, {32U}, {0U},
                                                                    {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {8U}, {32U}, {0U}}}, {{{0U}, {32U},
                                                                       {0U}, {0U}}}}, 
        {68,
      {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {2, {1U, 1U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {8U}, {0U}, {0U}}}, {{{0U}, {32U},
                                                                      {0U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {71,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {11U}, {11U}, {0U}}}, {{{0U}, {10U},
                                                                      {21U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U}, {0U},
                                                                   {24U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U},
                                                                       {0U}, {24U}}}}, 
        {4111,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U}, {0U},
                                                                   {24U}}}}, 
        {15, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U},
                                                                       {0U}, {24U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{16U}, {8U}, {0U},
                                                                   {24U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {16U},
                                                                        {0U}, {0U}}}}, 
        {70,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {16U},
                                                                     {0U}, {0U}}}}, 
        {3,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {16U}, {16U}, {0U}}}, {{{0U}, {16U},
                                                                     {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {32U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U}, {0U},
                                                                    {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U},
                                                                       {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {0U}, {24U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {2, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {0U}, {0U}}}, {{{0U}, {24U},
                                                                      {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U}, {0U},
                                                                   {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U}, {0U},
                                                                   {0U}}}}, 
        {3, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {1, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U},
                                                                       {0U}, {0U}}}}, 
        {1,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {4, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {1, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {1, {1U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {4, {8U, 1U, 1U, 0U}, 1U, 1U, {8U, {{0U}, {0U}, {8U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                     {0U}}}}, 
        {2055, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{9U}, {9U}, {9U}, {5U}}}, {{{18U}, {9U},
                                                                         {0U}, {27U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U}, {0U},
                                                                   {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                      {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {4128, {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U},
                                                                          {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {4128,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {4128,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {32, {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 8U, 8U, {64U, {{0U}, {0U}, {64U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {32, {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U},
                                                                            {0U},
                                                                            {0U},
                                                                            {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {32,
      {4U, 4U, 1U, 0U}, 16U, 16U, {128U, {{0U}, {0U}, {128U}, {0U}}}, {{{0U}, {0U},
                                                                        {0U}, {0U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{10U}, {10U}, {10U}, {2U}}}, {{{0U}, {10U},
                                                                      {20U}, {30U}}}}, 
        {15,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{0U}, {8U}, {16U},
                                                                   {24U}}}}, 
        {4111, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{8U}, {8U}, {8U}, {8U}}}, {{{0U}, {8U},
                                                                         {16U}, {24U}}}}, 
        {7,
      {1U, 1U, 1U, 0U}, 4U, 4U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U}, {16U},
                                                                   {24U}}}}, 
        {4103, {1U, 1U, 1U, 0U}, 4U, 4U, {24U, {{8U}, {8U}, {8U}, {0U}}}, {{{0U}, {8U},
                                                                         {16U}, {24U}}}}, 
        {4,
      {1U, 1U, 1U, 0U}, 2U, 2U, {16U, {{0U}, {0U}, {16U}, {0U}}}, {{{0U}, {0U}, {0U},
                                                                    {0U}}}}, 
        {6, {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U},
                                                                       {0U}, {0U}}}}, 
        {6,
      {1U, 1U, 1U, 0U}, 4U, 4U, {32U, {{0U}, {8U}, {24U}, {0U}}}, {{{0U}, {24U}, {0U},
                                                                    {0U}}}}};
#line 705 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static u32 clamped_umul32(u32 a , u32 b ) 
{ uint64_t tmp ;
  unsigned long long tmp___0 ;

  {
#line 707
  tmp = (unsigned long long )a * (unsigned long long )b;
#line 708
  if (4294967295ULL < tmp) {
#line 708
    tmp___0 = 4294967295ULL;
  } else {
#line 708
    tmp___0 = tmp;
  }
#line 708
  return ((u32 )tmp___0);
}
}
#line 712 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static struct svga3d_surface_desc  const  *svga3dsurface_get_desc(SVGA3dSurfaceFormat format ) 
{ 

  {
#line 714
  if ((unsigned int )format <= 120U) {
#line 715
    return ((struct svga3d_surface_desc  const  *)(& svga3d_surface_descs) + (unsigned long )format);
  } else {

  }
#line 717
  return ((struct svga3d_surface_desc  const  *)(& svga3d_surface_descs));
}
}
#line 749 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static void svga3dsurface_get_size_in_blocks(struct svga3d_surface_desc  const  *desc ,
                                                      struct drm_vmw_size  const  *pixel_size ,
                                                      struct drm_vmw_size *block_size ) 
{ 

  {
#line 753
  block_size->width = (((unsigned int )pixel_size->width + (unsigned int )desc->block_size.width) - 1U) / (unsigned int )desc->block_size.width;
#line 755
  block_size->height = (((unsigned int )pixel_size->height + (unsigned int )desc->block_size.height) - 1U) / (unsigned int )desc->block_size.height;
#line 757
  block_size->depth = (((unsigned int )pixel_size->depth + (unsigned int )desc->block_size.depth) - 1U) / (unsigned int )desc->block_size.depth;
#line 758
  return;
}
}
#line 762 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static bool svga3dsurface_is_planar_surface(struct svga3d_surface_desc  const  *desc ) 
{ 

  {
#line 764
  return (((unsigned int )desc->block_desc & 256U) != 0U);
}
}
#line 768 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static u32 svga3dsurface_calculate_pitch(struct svga3d_surface_desc  const  *desc ,
                                                  struct drm_vmw_size  const  *size ) 
{ u32 pitch ;
  struct drm_vmw_size blocks ;

  {
#line 774
  svga3dsurface_get_size_in_blocks(desc, size, & blocks);
#line 776
  pitch = blocks.width * (uint32_t )desc->pitch_bytes_per_block;
#line 778
  return (pitch);
}
}
#line 804 "/work/zakharov/bench-tests/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/gpu/drm/vmwgfx/svga3d_surfacedefs.h"
__inline static u32 svga3dsurface_get_image_buffer_size(struct svga3d_surface_desc  const  *desc ,
                                                        struct drm_vmw_size  const  *size ,
                                                        u32 pitch ) 
{ struct drm_vmw_size image_blocks ;
  u32 slice_size ;
  u32 total_size ;
  bool tmp ;

  {
#line 811
  svga3dsurface_get_size_in_blocks(desc, size, & image_blocks);
#line 813
  tmp = svga3dsurface_is_planar_surface(desc);
#line 813
  if ((int )tmp) {
#line 814
    total_size = clamped_umul32(image_blocks.width, image_blocks.height);
#line 816
    total_size = clamped_umul32(total_size, image_blocks.depth);
#line 817
    total_size = clamped_umul32(total_size, desc->bytes_per_block);
#line 818
    return (total_size);
  } else {

  }
#line 821
  if (pitch == 0U) {
#line 822
    pitch = svga3dsurface_calculate_pitch(desc, size);
  } else {

  }
#line 824
  slice_size = clamped_umul32(image_blocks.height, pitch);
#line 825
  total_size = clamped_umul32(slice_size, image_blocks.depth);
#line 827
  return (total_size);
}
}
#line 214 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_user_surface_free(struct vmw_resource *res ) ;
#line 216
static struct vmw_resource *vmw_user_surface_base_to_res(struct ttm_base_object *base ) ;
#line 217
static int vmw_legacy_srf_bind(struct vmw_resource *res , struct ttm_validate_buffer *val_buf ) ;
#line 219
static int vmw_legacy_srf_unbind(struct vmw_resource *res , bool readback , struct ttm_validate_buffer *val_buf ) ;
#line 222
static int vmw_legacy_srf_create(struct vmw_resource *res ) ;
#line 223
static int vmw_legacy_srf_destroy(struct vmw_resource *res ) ;
#line 225 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static struct vmw_user_resource_conv  const  user_surface_conv  =    {257, & vmw_user_surface_base_to_res, & vmw_user_surface_free};
#line 231 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_user_resource_conv  const  *user_surface_converter  =    & user_surface_conv;
#line 235 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static uint64_t vmw_user_surface_size  ;
#line 237 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static struct vmw_res_func  const  vmw_legacy_surface_func  = 
#line 237
     {1, 0, "legacy surfaces", & vmw_srf_placement, 1, & vmw_legacy_srf_create, & vmw_legacy_srf_destroy,
    & vmw_legacy_srf_bind, & vmw_legacy_srf_unbind};
#line 284 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
__inline static uint32_t vmw_surface_dma_size(struct vmw_surface  const  *srf ) 
{ 

  {
#line 286
  return ((uint32_t )srf->num_sizes * 84U);
}
}
#line 298 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
__inline static uint32_t vmw_surface_define_size(struct vmw_surface  const  *srf ) 
{ 

  {
#line 300
  return ((uint32_t )srf->num_sizes * 12U + 44U);
}
}
#line 311 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
__inline static uint32_t vmw_surface_destroy_size(void) 
{ 

  {
#line 313
  return (12U);
}
}
#line 322 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_surface_destroy_encode(uint32_t id , void *cmd_space ) 
{ struct vmw_surface_destroy *cmd ;

  {
#line 325
  cmd = (struct vmw_surface_destroy *)cmd_space;
#line 328
  cmd->header.id = 1041U;
#line 329
  cmd->header.size = 4U;
#line 330
  cmd->body.sid = id;
#line 331
  return;
}
}
#line 339 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_surface_define_encode(struct vmw_surface  const  *srf , void *cmd_space ) 
{ struct vmw_surface_define *cmd ;
  struct drm_vmw_size *src_size ;
  SVGA3dSize *cmd_size ;
  uint32_t cmd_len ;
  int i ;

  {
#line 342
  cmd = (struct vmw_surface_define *)cmd_space;
#line 349
  cmd_len = (uint32_t )srf->num_sizes * 12U + 36U;
#line 351
  cmd->header.id = 1040U;
#line 352
  cmd->header.size = cmd_len;
#line 353
  cmd->body.sid = (uint32 )srf->res.id;
#line 354
  cmd->body.surfaceFlags = (SVGA3dSurfaceFlags )srf->flags;
#line 355
  cmd->body.format = (SVGA3dSurfaceFormat )srf->format;
#line 356
  i = 0;
#line 356
  goto ldv_40880;
  ldv_40879: 
#line 357
  cmd->body.face[i].numMipLevels = srf->mip_levels[i];
#line 356
  i = i + 1;
  ldv_40880: ;
#line 356
  if (i <= 5) {
#line 357
    goto ldv_40879;
  } else {
#line 359
    goto ldv_40881;
  }
  ldv_40881: 
#line 359
  cmd = cmd + 1UL;
#line 360
  cmd_size = (SVGA3dSize *)cmd;
#line 361
  src_size = srf->sizes;
#line 363
  i = 0;
#line 363
  goto ldv_40883;
  ldv_40882: 
#line 364
  cmd_size->width = src_size->width;
#line 365
  cmd_size->height = src_size->height;
#line 366
  cmd_size->depth = src_size->depth;
#line 363
  i = i + 1;
#line 363
  cmd_size = cmd_size + 1;
#line 363
  src_size = src_size + 1;
  ldv_40883: ;
#line 363
  if ((unsigned int )i < (unsigned int )srf->num_sizes) {
#line 364
    goto ldv_40882;
  } else {
#line 366
    goto ldv_40884;
  }
  ldv_40884: ;
#line 368
  return;
}
}
#line 379 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_surface_dma_encode(struct vmw_surface *srf , void *cmd_space , SVGAGuestPtr const   *ptr ,
                                   bool to_surface ) 
{ uint32_t i ;
  struct vmw_surface_dma *cmd ;
  struct svga3d_surface_desc  const  *desc ;
  struct svga3d_surface_desc  const  *tmp ;
  SVGA3dCmdHeader *header ;
  SVGA3dCmdSurfaceDMA *body ;
  SVGA3dCopyBox *cb ;
  SVGA3dCmdSurfaceDMASuffix *suffix ;
  struct vmw_surface_offset  const  *cur_offset ;
  struct drm_vmw_size  const  *cur_size ;

  {
#line 385
  cmd = (struct vmw_surface_dma *)cmd_space;
#line 386
  tmp = svga3dsurface_get_desc((SVGA3dSurfaceFormat )srf->format);
#line 386
  desc = tmp;
#line 389
  i = 0U;
#line 389
  goto ldv_40901;
  ldv_40900: 
#line 390
  header = & cmd->header;
#line 391
  body = & cmd->body;
#line 392
  cb = & cmd->cb;
#line 393
  suffix = & cmd->suffix;
#line 394
  cur_offset = (struct vmw_surface_offset  const  *)srf->offsets + (unsigned long )i;
#line 395
  cur_size = (struct drm_vmw_size  const  *)srf->sizes + (unsigned long )i;
#line 397
  header->id = 1044U;
#line 398
  header->size = 76U;
#line 400
  body->guest.ptr = *ptr;
#line 401
  body->guest.ptr.offset = body->guest.ptr.offset + (uint32 )cur_offset->bo_offset;
#line 402
  body->guest.pitch = svga3dsurface_calculate_pitch(desc, cur_size);
#line 404
  body->host.sid = (uint32 )srf->res.id;
#line 405
  body->host.face = cur_offset->face;
#line 406
  body->host.mipmap = cur_offset->mip;
#line 407
  if ((int )to_surface) {
#line 407
    body->transfer = 1;
  } else {
#line 407
    body->transfer = 2;
  }
#line 409
  cb->x = 0U;
#line 410
  cb->y = 0U;
#line 411
  cb->z = 0U;
#line 412
  cb->srcx = 0U;
#line 413
  cb->srcy = 0U;
#line 414
  cb->srcz = 0U;
#line 415
  cb->w = cur_size->width;
#line 416
  cb->h = cur_size->height;
#line 417
  cb->d = cur_size->depth;
#line 419
  suffix->suffixSize = 12U;
#line 420
  suffix->maximumOffset = svga3dsurface_get_image_buffer_size(desc, cur_size, body->guest.pitch);
#line 423
  suffix->flags.discard = 0U;
#line 424
  suffix->flags.unsynchronized = 0U;
#line 425
  suffix->flags.reserved = 0U;
#line 426
  cmd = cmd + 1;
#line 389
  i = i + 1U;
  ldv_40901: ;
#line 389
  if (srf->num_sizes > i) {
#line 390
    goto ldv_40900;
  } else {
#line 392
    goto ldv_40902;
  }
  ldv_40902: ;
#line 394
  return;
}
}
#line 440 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_hw_surface_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct vmw_surface *srf ;
  void *cmd ;
  uint32_t tmp ;
  long tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 443
  dev_priv = res->dev_priv;
#line 447
  if (res->id != -1) {
#line 449
    tmp = vmw_surface_destroy_size();
#line 449
    cmd = vmw_fifo_reserve(dev_priv, tmp);
#line 450
    tmp___0 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((void *)0),
                               0L);
#line 450
    if (tmp___0 != 0L) {
#line 451
      drm_err("vmw_hw_surface_destroy", "Failed reserving FIFO space for surface destruction.\n");
#line 453
      return;
    } else {

    }
#line 456
    vmw_surface_destroy_encode((uint32_t )res->id, cmd);
#line 457
    tmp___1 = vmw_surface_destroy_size();
#line 457
    vmw_fifo_commit(dev_priv, tmp___1);
#line 465
    ldv_mutex_lock_729(& dev_priv->cmdbuf_mutex);
#line 466
    srf = vmw_res_to_srf(res);
#line 467
    dev_priv->used_memory_size = dev_priv->used_memory_size - (uint32_t )res->backup_size;
#line 468
    ldv_mutex_unlock_730(& dev_priv->cmdbuf_mutex);
  } else {

  }
#line 470
  vmw_3d_resource_dec(dev_priv, 0);
#line 471
  return;
}
}
#line 486 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_create(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  struct vmw_surface *srf ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;

  {
#line 488
  dev_priv = res->dev_priv;
#line 494
  tmp = ldv__builtin_expect(res->id != -1, 1L);
#line 494
  if (tmp != 0L) {
#line 495
    return (0);
  } else {

  }
#line 497
  srf = vmw_res_to_srf(res);
#line 498
  tmp___0 = ldv__builtin_expect((unsigned long )dev_priv->used_memory_size + res->backup_size >= (unsigned long )dev_priv->memory_size,
                             0L);
#line 498
  if (tmp___0 != 0L) {
#line 500
    return (-16);
  } else {

  }
#line 506
  ret = vmw_resource_alloc_id(res);
#line 507
  tmp___1 = ldv__builtin_expect(ret != 0, 0L);
#line 507
  if (tmp___1 != 0L) {
#line 508
    drm_err("vmw_legacy_srf_create", "Failed to allocate a surface id.\n");
#line 509
    goto out_no_id;
  } else {

  }
#line 512
  tmp___2 = ldv__builtin_expect(res->id > 32767, 0L);
#line 512
  if (tmp___2 != 0L) {
#line 513
    ret = -16;
#line 514
    goto out_no_fifo;
  } else {

  }
#line 521
  submit_size = vmw_surface_define_size((struct vmw_surface  const  *)srf);
#line 522
  tmp___3 = vmw_fifo_reserve(dev_priv, submit_size);
#line 522
  cmd = (uint8_t *)tmp___3;
#line 523
  tmp___4 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint8_t *)0),
                             0L);
#line 523
  if (tmp___4 != 0L) {
#line 524
    drm_err("vmw_legacy_srf_create", "Failed reserving FIFO space for surface creation.\n");
#line 526
    ret = -12;
#line 527
    goto out_no_fifo;
  } else {

  }
#line 530
  vmw_surface_define_encode((struct vmw_surface  const  *)srf, (void *)cmd);
#line 531
  vmw_fifo_commit(dev_priv, submit_size);
#line 536
  dev_priv->used_memory_size = dev_priv->used_memory_size + (uint32_t )res->backup_size;
#line 537
  return (0);
  out_no_fifo: 
#line 540
  vmw_resource_release_id(res);
  out_no_id: ;
#line 542
  return (ret);
}
}
#line 561 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_dma(struct vmw_resource *res , struct ttm_validate_buffer *val_buf ,
                              bool bind ) 
{ SVGAGuestPtr ptr ;
  struct vmw_fence_obj *fence ;
  uint32_t submit_size ;
  struct vmw_surface *srf ;
  struct vmw_surface *tmp ;
  uint8_t *cmd ;
  struct vmw_private *dev_priv ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 568
  tmp = vmw_res_to_srf(res);
#line 568
  srf = tmp;
#line 570
  dev_priv = res->dev_priv;
#line 572
  tmp___0 = ldv__builtin_expect((unsigned long )val_buf->bo == (unsigned long )((struct ttm_buffer_object *)0),
                             0L);
#line 572
  if (tmp___0 != 0L) {
#line 572
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"),
                         "i" (572), "i" (12UL));
    ldv_40932: ;
#line 572
    goto ldv_40932;
  } else {

  }
#line 574
  submit_size = vmw_surface_dma_size((struct vmw_surface  const  *)srf);
#line 575
  tmp___1 = vmw_fifo_reserve(dev_priv, submit_size);
#line 575
  cmd = (uint8_t *)tmp___1;
#line 576
  tmp___2 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint8_t *)0),
                             0L);
#line 576
  if (tmp___2 != 0L) {
#line 577
    drm_err("vmw_legacy_srf_dma", "Failed reserving FIFO space for surface DMA.\n");
#line 579
    return (-12);
  } else {

  }
#line 581
  vmw_bo_get_guest_ptr((struct ttm_buffer_object  const  *)val_buf->bo, & ptr);
#line 582
  vmw_surface_dma_encode(srf, (void *)cmd, (SVGAGuestPtr const   *)(& ptr), (int )bind);
#line 584
  vmw_fifo_commit(dev_priv, submit_size);
#line 590
  vmw_execbuf_fence_commands(0, dev_priv, & fence, 0);
#line 593
  vmw_fence_single_bo(val_buf->bo, fence);
#line 595
  tmp___3 = ldv__builtin_expect((unsigned long )fence != (unsigned long )((struct vmw_fence_obj *)0),
                             1L);
#line 595
  if (tmp___3 != 0L) {
#line 596
    vmw_fence_obj_unreference(& fence);
  } else {

  }
#line 598
  return (0);
}
}
#line 613 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_bind(struct vmw_resource *res , struct ttm_validate_buffer *val_buf ) 
{ int tmp ;

  {
#line 616
  if (! res->backup_dirty) {
#line 617
    return (0);
  } else {

  }
#line 619
  tmp = vmw_legacy_srf_dma(res, val_buf, 1);
#line 619
  return (tmp);
}
}
#line 634 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_unbind(struct vmw_resource *res , bool readback , struct ttm_validate_buffer *val_buf ) 
{ int tmp ;
  long tmp___0 ;

  {
#line 638
  tmp___0 = ldv__builtin_expect((long )readback, 0L);
#line 638
  if (tmp___0 != 0L) {
#line 639
    tmp = vmw_legacy_srf_dma(res, val_buf, 0);
#line 639
    return (tmp);
  } else {

  }
#line 640
  return (0);
}
}
#line 650 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_legacy_srf_destroy(struct vmw_resource *res ) 
{ struct vmw_private *dev_priv ;
  uint32_t submit_size ;
  uint8_t *cmd ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 652
  dev_priv = res->dev_priv;
#line 656
  tmp = ldv__builtin_expect(res->id == -1, 0L);
#line 656
  if (tmp != 0L) {
#line 656
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"),
                         "i" (656), "i" (12UL));
    ldv_40949: ;
#line 656
    goto ldv_40949;
  } else {

  }
#line 662
  submit_size = vmw_surface_destroy_size();
#line 663
  tmp___0 = vmw_fifo_reserve(dev_priv, submit_size);
#line 663
  cmd = (uint8_t *)tmp___0;
#line 664
  tmp___1 = ldv__builtin_expect((unsigned long )cmd == (unsigned long )((uint8_t *)0),
                             0L);
#line 664
  if (tmp___1 != 0L) {
#line 665
    drm_err("vmw_legacy_srf_destroy", "Failed reserving FIFO space for surface eviction.\n");
#line 667
    return (-12);
  } else {

  }
#line 670
  vmw_surface_destroy_encode((uint32_t )res->id, (void *)cmd);
#line 671
  vmw_fifo_commit(dev_priv, submit_size);
#line 677
  dev_priv->used_memory_size = dev_priv->used_memory_size - (uint32_t )res->backup_size;
#line 683
  vmw_resource_release_id(res);
#line 685
  return (0);
}
}
#line 697 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static int vmw_surface_init(struct vmw_private *dev_priv , struct vmw_surface *srf ,
                            void (*res_free)(struct vmw_resource * ) ) 
{ int ret ;
  struct vmw_resource *res ;
  long tmp ;
  long tmp___0 ;

  {
#line 702
  res = & srf->res;
#line 704
  tmp = ldv__builtin_expect((unsigned long )res_free == (unsigned long )((void (*)(struct vmw_resource * ))0),
                         0L);
#line 704
  if (tmp != 0L) {
#line 704
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"),
                         "i" (704), "i" (12UL));
    ldv_40959: ;
#line 704
    goto ldv_40959;
  } else {

  }
#line 705
  vmw_3d_resource_inc(dev_priv, 0);
#line 706
  ret = vmw_resource_init(dev_priv, res, 1, res_free, & vmw_legacy_surface_func);
#line 709
  tmp___0 = ldv__builtin_expect(ret != 0, 0L);
#line 709
  if (tmp___0 != 0L) {
#line 710
    vmw_3d_resource_dec(dev_priv, 0);
#line 711
    (*res_free)(res);
#line 712
    return (ret);
  } else {

  }
#line 720
  vmw_resource_activate(res, & vmw_hw_surface_destroy);
#line 721
  return (ret);
}
}
#line 734 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static struct vmw_resource *vmw_user_surface_base_to_res(struct ttm_base_object *base ) 
{ struct ttm_base_object  const  *__mptr ;

  {
#line 736
  __mptr = (struct ttm_base_object  const  *)base;
#line 736
  return (& ((struct vmw_user_surface *)__mptr)->srf.res);
}
}
#line 744 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_user_surface_free(struct vmw_resource *res ) 
{ struct vmw_surface *srf ;
  struct vmw_surface *tmp ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface  const  *__mptr ;
  struct vmw_private *dev_priv ;
  uint32_t size ;
  struct ttm_mem_global *tmp___0 ;

  {
#line 746
  tmp = vmw_res_to_srf(res);
#line 746
  srf = tmp;
#line 748
  __mptr = (struct vmw_surface  const  *)srf;
#line 748
  user_srf = (struct vmw_user_surface *)__mptr + 0xffffffffffffffb0UL;
#line 749
  dev_priv = srf->res.dev_priv;
#line 750
  size = user_srf->size;
#line 752
  kfree((void const   *)srf->offsets);
#line 753
  kfree((void const   *)srf->sizes);
#line 754
  kfree((void const   *)srf->snooper.image);
#line 755
  kfree_call_rcu(& user_srf->base.rhead, 0);
#line 756
  tmp___0 = vmw_mem_glob(dev_priv);
#line 756
  ttm_mem_global_free(tmp___0, (uint64_t )size);
#line 757
  return;
}
}
#line 768 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
static void vmw_user_surface_base_release(struct ttm_base_object **p_base ) 
{ struct ttm_base_object *base ;
  struct vmw_user_surface *user_srf ;
  struct ttm_base_object  const  *__mptr ;
  struct vmw_resource *res ;

  {
#line 770
  base = *p_base;
#line 772
  __mptr = (struct ttm_base_object  const  *)base;
#line 772
  user_srf = (struct vmw_user_surface *)__mptr;
#line 773
  res = & user_srf->srf.res;
#line 775
  *p_base = 0;
#line 776
  vmw_resource_unreference(& res);
#line 777
  return;
}
}
#line 787 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
int vmw_surface_destroy_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_vmw_surface_arg *arg ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  int tmp___0 ;

  {
#line 790
  arg = (struct drm_vmw_surface_arg *)data;
#line 791
  tmp = vmw_fpriv(file_priv);
#line 791
  tfile = tmp->tfile;
#line 793
  tmp___0 = ttm_ref_object_base_unref(tfile, (unsigned long )arg->sid, 0);
#line 793
  return (tmp___0);
}
}
#line 804 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
int vmw_surface_define_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct vmw_private *dev_priv ;
  struct vmw_private *tmp ;
  struct vmw_user_surface *user_srf ;
  struct vmw_surface *srf ;
  struct vmw_resource *res ;
  struct vmw_resource *tmp___0 ;
  union drm_vmw_surface_create_arg *arg ;
  struct drm_vmw_surface_create_req *req ;
  struct drm_vmw_surface_arg *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp___1 ;
  struct drm_vmw_size *user_sizes ;
  int ret ;
  int i ;
  int j ;
  uint32_t cur_bo_offset ;
  struct drm_vmw_size *cur_size ;
  struct vmw_surface_offset *cur_offset ;
  uint32_t num_sizes ;
  uint32_t size ;
  struct vmw_master *vmaster ;
  struct vmw_master *tmp___2 ;
  struct svga3d_surface_desc  const  *desc ;
  size_t tmp___3 ;
  long tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  struct ttm_mem_global *tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  size_t __len ;
  void *__ret ;
  void *tmp___13 ;
  long tmp___14 ;
  void *tmp___15 ;
  long tmp___16 ;
  unsigned long tmp___17 ;
  long tmp___18 ;
  uint32_t stride ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  void *tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  struct ttm_mem_global *tmp___24 ;

  {
#line 807
  tmp = vmw_priv(dev);
#line 807
  dev_priv = tmp;
#line 812
  arg = (union drm_vmw_surface_create_arg *)data;
#line 814
  req = & arg->req;
#line 815
  rep = & arg->rep;
#line 816
  tmp___1 = vmw_fpriv(file_priv);
#line 816
  tfile = tmp___1->tfile;
#line 825
  tmp___2 = vmw_master(file_priv->master);
#line 825
  vmaster = tmp___2;
#line 828
  tmp___4 = ldv__builtin_expect(vmw_user_surface_size == 0ULL, 0L);
#line 828
  if (tmp___4 != 0L) {
#line 829
    tmp___3 = ttm_round_pot(304UL);
#line 829
    vmw_user_surface_size = (uint64_t )(tmp___3 + 128UL);
  } else {

  }
#line 832
  num_sizes = 0U;
#line 833
  i = 0;
#line 833
  goto ldv_41016;
  ldv_41015: 
#line 834
  num_sizes = req->mip_levels[i] + num_sizes;
#line 833
  i = i + 1;
  ldv_41016: ;
#line 833
  if (i <= 5) {
#line 834
    goto ldv_41015;
  } else {
#line 836
    goto ldv_41017;
  }
  ldv_41017: ;
#line 836
  if (num_sizes > 144U) {
#line 838
    return (-22);
  } else {

  }
#line 840
  tmp___5 = ttm_round_pot((unsigned long )num_sizes * 16UL);
#line 840
  tmp___6 = ttm_round_pot((unsigned long )num_sizes * 12UL);
#line 840
  size = (((uint32_t )tmp___5 + (uint32_t )vmw_user_surface_size) + (uint32_t )tmp___6) + 128U;
#line 845
  desc = svga3dsurface_get_desc((SVGA3dSurfaceFormat )req->format);
#line 846
  tmp___7 = ldv__builtin_expect((unsigned int )desc->block_desc == 0U, 0L);
#line 846
  if (tmp___7 != 0L) {
#line 847
    drm_err("vmw_surface_define_ioctl", "Invalid surface format for surface creation.\n");
#line 848
    return (-22);
  } else {

  }
#line 851
  ret = ttm_read_lock(& vmaster->lock, 1);
#line 852
  tmp___8 = ldv__builtin_expect(ret != 0, 0L);
#line 852
  if (tmp___8 != 0L) {
#line 853
    return (ret);
  } else {

  }
#line 855
  tmp___9 = vmw_mem_glob(dev_priv);
#line 855
  ret = ttm_mem_global_alloc(tmp___9, (uint64_t )size, 0, 1);
#line 857
  tmp___10 = ldv__builtin_expect(ret != 0, 0L);
#line 857
  if (tmp___10 != 0L) {
#line 858
    if (ret != -512) {
#line 859
      drm_err("vmw_surface_define_ioctl", "Out of graphics memory for surface creation.\n");
    } else {

    }
#line 861
    goto out_unlock;
  } else {

  }
#line 864
  tmp___11 = kzalloc(304UL, 208U);
#line 864
  user_srf = (struct vmw_user_surface *)tmp___11;
#line 865
  tmp___12 = ldv__builtin_expect((unsigned long )user_srf == (unsigned long )((struct vmw_user_surface *)0),
                              0L);
#line 865
  if (tmp___12 != 0L) {
#line 866
    ret = -12;
#line 867
    goto out_no_user_srf;
  } else {

  }
#line 870
  srf = & user_srf->srf;
#line 871
  res = & srf->res;
#line 873
  srf->flags = req->flags;
#line 874
  srf->format = req->format;
#line 875
  srf->scanout = req->scanout != 0;
#line 877
  __len = 24UL;
#line 877
  if (__len > 63UL) {
#line 877
    __ret = __memcpy((void *)(& srf->mip_levels), (void const   *)(& req->mip_levels),
                     __len);
  } else {
#line 877
    __ret = __builtin_memcpy((void *)(& srf->mip_levels), (void const   *)(& req->mip_levels),
                             __len);
  }
#line 878
  srf->num_sizes = num_sizes;
#line 879
  user_srf->size = size;
#line 881
  tmp___13 = kmalloc((unsigned long )srf->num_sizes * 16UL, 208U);
#line 881
  srf->sizes = (struct drm_vmw_size *)tmp___13;
#line 882
  tmp___14 = ldv__builtin_expect((unsigned long )srf->sizes == (unsigned long )((struct drm_vmw_size *)0),
                              0L);
#line 882
  if (tmp___14 != 0L) {
#line 883
    ret = -12;
#line 884
    goto out_no_sizes;
  } else {

  }
#line 886
  tmp___15 = kmalloc((unsigned long )srf->num_sizes * 12UL, 208U);
#line 886
  srf->offsets = (struct vmw_surface_offset *)tmp___15;
#line 888
  tmp___16 = ldv__builtin_expect((unsigned long )srf->sizes == (unsigned long )((struct drm_vmw_size *)0),
                              0L);
#line 888
  if (tmp___16 != 0L) {
#line 889
    ret = -12;
#line 890
    goto out_no_offsets;
  } else {

  }
#line 893
  user_sizes = (struct drm_vmw_size *)req->size_addr;
#line 896
  tmp___17 = copy_from_user((void *)srf->sizes, (void const   *)user_sizes, (unsigned long )srf->num_sizes * 16UL);
#line 896
  ret = (int )tmp___17;
#line 898
  tmp___18 = ldv__builtin_expect(ret != 0, 0L);
#line 898
  if (tmp___18 != 0L) {
#line 899
    ret = -14;
#line 900
    goto out_no_copy;
  } else {

  }
#line 903
  srf->base_size = *(srf->sizes);
#line 904
  srf->autogen_filter = 0;
#line 905
  srf->multisample_count = 1U;
#line 907
  cur_bo_offset = 0U;
#line 908
  cur_offset = srf->offsets;
#line 909
  cur_size = srf->sizes;
#line 911
  i = 0;
#line 911
  goto ldv_41032;
  ldv_41031: 
#line 912
  j = 0;
#line 912
  goto ldv_41029;
  ldv_41028: 
#line 913
  tmp___19 = svga3dsurface_calculate_pitch(desc, (struct drm_vmw_size  const  *)cur_size);
#line 913
  stride = tmp___19;
#line 916
  cur_offset->face = (uint32_t )i;
#line 917
  cur_offset->mip = (uint32_t )j;
#line 918
  cur_offset->bo_offset = cur_bo_offset;
#line 919
  tmp___20 = svga3dsurface_get_image_buffer_size(desc, (struct drm_vmw_size  const  *)cur_size,
                                                 stride);
#line 919
  cur_bo_offset = tmp___20 + cur_bo_offset;
#line 921
  cur_offset = cur_offset + 1;
#line 922
  cur_size = cur_size + 1;
#line 912
  j = j + 1;
  ldv_41029: ;
#line 912
  if ((uint32_t )j < srf->mip_levels[i]) {
#line 913
    goto ldv_41028;
  } else {
#line 915
    goto ldv_41030;
  }
  ldv_41030: 
#line 911
  i = i + 1;
  ldv_41032: ;
#line 911
  if (i <= 5) {
#line 912
    goto ldv_41031;
  } else {
#line 914
    goto ldv_41033;
  }
  ldv_41033: 
#line 925
  res->backup_size = (unsigned long )cur_bo_offset;
#line 926
  if (((((int )srf->scanout && srf->num_sizes == 1U) && (srf->sizes)->width == 64U) && (srf->sizes)->height == 64U) && srf->format == 2U) {
#line 932
    tmp___21 = kmalloc(16384UL, 208U);
#line 932
    srf->snooper.image = (uint32_t *)tmp___21;
#line 934
    if ((unsigned long )srf->snooper.image != (unsigned long )((uint32_t *)0)) {
#line 935
      memset((void *)srf->snooper.image, 0, 16384UL);
    } else {
#line 937
      drm_err("vmw_surface_define_ioctl", "Failed to allocate cursor_image\n");
#line 938
      ret = -12;
#line 939
      goto out_no_copy;
    }
  } else {
#line 942
    srf->snooper.image = 0;
  }
#line 944
  srf->snooper.crtc = 0;
#line 946
  user_srf->base.shareable = 0;
#line 947
  user_srf->base.tfile = 0;
#line 954
  ret = vmw_surface_init(dev_priv, srf, & vmw_user_surface_free);
#line 955
  tmp___22 = ldv__builtin_expect(ret != 0, 0L);
#line 955
  if (tmp___22 != 0L) {
#line 956
    goto out_unlock;
  } else {

  }
#line 958
  tmp___0 = vmw_resource_reference(& srf->res);
#line 959
  ret = ttm_base_object_init(tfile, & user_srf->base, req->shareable != 0, 257, & vmw_user_surface_base_release,
                             0);
#line 963
  tmp___23 = ldv__builtin_expect(ret != 0, 0L);
#line 963
  if (tmp___23 != 0L) {
#line 964
    vmw_resource_unreference(& tmp___0);
#line 965
    vmw_resource_unreference(& res);
#line 966
    goto out_unlock;
  } else {

  }
#line 969
  rep->sid = (int32_t )user_srf->base.hash.key;
#line 970
  vmw_resource_unreference(& res);
#line 972
  ttm_read_unlock(& vmaster->lock);
#line 973
  return (0);
  out_no_copy: 
#line 975
  kfree((void const   *)srf->offsets);
  out_no_offsets: 
#line 977
  kfree((void const   *)srf->sizes);
  out_no_sizes: 
#line 979
  kfree_call_rcu(& user_srf->base.rhead, 0);
  out_no_user_srf: 
#line 981
  tmp___24 = vmw_mem_glob(dev_priv);
#line 981
  ttm_mem_global_free(tmp___24, (uint64_t )size);
  out_unlock: 
#line 983
  ttm_read_unlock(& vmaster->lock);
#line 984
  return (ret);
}
}
#line 995 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
int vmw_surface_reference_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ union drm_vmw_surface_reference_arg *arg ;
  struct drm_vmw_surface_arg *req ;
  struct drm_vmw_surface_create_req *rep ;
  struct ttm_object_file *tfile ;
  struct vmw_fpriv *tmp ;
  struct vmw_surface *srf ;
  struct vmw_user_surface *user_srf ;
  struct drm_vmw_size *user_sizes ;
  struct ttm_base_object *base ;
  int ret ;
  long tmp___0 ;
  long tmp___1 ;
  struct ttm_base_object  const  *__mptr ;
  long tmp___2 ;
  size_t __len ;
  void *__ret ;
  long tmp___3 ;

  {
#line 998
  arg = (union drm_vmw_surface_reference_arg *)data;
#line 1000
  req = & arg->req;
#line 1001
  rep = & arg->rep;
#line 1002
  tmp = vmw_fpriv(file_priv);
#line 1002
  tfile = tmp->tfile;
#line 1007
  ret = -22;
#line 1009
  base = ttm_base_object_lookup(tfile, (uint32_t )req->sid);
#line 1010
  tmp___0 = ldv__builtin_expect((unsigned long )base == (unsigned long )((struct ttm_base_object *)0),
                             0L);
#line 1010
  if (tmp___0 != 0L) {
#line 1011
    drm_err("vmw_surface_reference_ioctl", "Could not find surface to reference.\n");
#line 1012
    return (-22);
  } else {

  }
#line 1015
  tmp___1 = ldv__builtin_expect((unsigned int )base->object_type != 257U, 0L);
#line 1015
  if (tmp___1 != 0L) {
#line 1016
    goto out_bad_resource;
  } else {

  }
#line 1018
  __mptr = (struct ttm_base_object  const  *)base;
#line 1018
  user_srf = (struct vmw_user_surface *)__mptr;
#line 1019
  srf = & user_srf->srf;
#line 1021
  ret = ttm_ref_object_add(tfile, & user_srf->base, 0, 0);
#line 1022
  tmp___2 = ldv__builtin_expect(ret != 0, 0L);
#line 1022
  if (tmp___2 != 0L) {
#line 1023
    drm_err("vmw_surface_reference_ioctl", "Could not add a reference to a surface.\n");
#line 1024
    goto out_no_reference;
  } else {

  }
#line 1027
  rep->flags = srf->flags;
#line 1028
  rep->format = srf->format;
#line 1029
  __len = 24UL;
#line 1029
  if (__len > 63UL) {
#line 1029
    __ret = __memcpy((void *)(& rep->mip_levels), (void const   *)(& srf->mip_levels),
                     __len);
  } else {
#line 1029
    __ret = __builtin_memcpy((void *)(& rep->mip_levels), (void const   *)(& srf->mip_levels),
                             __len);
  }
#line 1030
  user_sizes = (struct drm_vmw_size *)rep->size_addr;
#line 1033
  if ((unsigned long )user_sizes != (unsigned long )((struct drm_vmw_size *)0)) {
#line 1034
    ret = copy_to_user((void *)user_sizes, (void const   *)srf->sizes, srf->num_sizes * 16U);
  } else {

  }
#line 1036
  tmp___3 = ldv__builtin_expect(ret != 0, 0L);
#line 1036
  if (tmp___3 != 0L) {
#line 1037
    drm_err("vmw_surface_reference_ioctl", "copy_to_user failed %p %u\n", user_sizes,
            srf->num_sizes);
#line 1039
    ret = -14;
  } else {

  }
  out_bad_resource: ;
  out_no_reference: 
#line 1043
  ttm_base_object_unref(& base);
#line 1045
  return (ret);
}
}
#line 1047 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_resource *vmw_legacy_surface_func_group1  ;
#line 1048 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct vmw_resource *ldvarg41  ;
#line 1049 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
bool ldvarg42  ;
#line 1050 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct ttm_validate_buffer *vmw_legacy_surface_func_group0  ;
#line 1051 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
struct ttm_base_object *ldvarg40  ;
#line 1053 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_main_exported_1(void) 
{ int tmp ;

  {
#line 1055
  tmp = __VERIFIER_nondet_int();
#line 1055
  switch (tmp) {
  case 0: ;
#line 1058
  if (ldv_state_variable_1 == 1) {
#line 1060
    vmw_legacy_srf_unbind(vmw_legacy_surface_func_group1, (int )ldvarg42, vmw_legacy_surface_func_group0);
#line 1062
    ldv_state_variable_1 = 1;
  } else {

  }
#line 1065
  goto ldv_41066;
  case 1: ;
#line 1068
  if (ldv_state_variable_1 == 1) {
#line 1070
    vmw_legacy_srf_bind(vmw_legacy_surface_func_group1, vmw_legacy_surface_func_group0);
#line 1072
    ldv_state_variable_1 = 1;
  } else {

  }
#line 1075
  goto ldv_41066;
  case 2: ;
#line 1078
  if (ldv_state_variable_1 == 1) {
#line 1080
    vmw_legacy_srf_create(vmw_legacy_surface_func_group1);
#line 1082
    ldv_state_variable_1 = 1;
  } else {

  }
#line 1085
  goto ldv_41066;
  case 3: ;
#line 1088
  if (ldv_state_variable_1 == 1) {
#line 1090
    vmw_legacy_srf_destroy(vmw_legacy_surface_func_group1);
#line 1092
    ldv_state_variable_1 = 1;
  } else {

  }
#line 1095
  goto ldv_41066;
  default: ;
#line 1096
  goto ldv_41066;
  }
  ldv_41066: ;
#line 1100
  return;
}
}
#line 1102 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_main_exported_2(void) 
{ int tmp ;

  {
#line 1104
  tmp = __VERIFIER_nondet_int();
#line 1104
  switch (tmp) {
  case 0: ;
#line 1107
  if (ldv_state_variable_2 == 1) {
#line 1109
    vmw_user_surface_free(ldvarg41);
#line 1111
    ldv_state_variable_2 = 1;
  } else {

  }
#line 1114
  goto ldv_41075;
  case 1: ;
#line 1117
  if (ldv_state_variable_2 == 1) {
#line 1119
    vmw_user_surface_base_to_res(ldvarg40);
#line 1121
    ldv_state_variable_2 = 1;
  } else {

  }
#line 1124
  goto ldv_41075;
  default: ;
#line 1125
  goto ldv_41075;
  }
  ldv_41075: ;
#line 1129
  return;
}
}
#line 1130 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_715(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1135
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1137
  mutex_lock(ldv_func_arg1);
#line 1138
  return;
}
}
#line 1140 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_716(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1145
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1147
  mutex_unlock(ldv_func_arg1);
#line 1148
  return;
}
}
#line 1150 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_717(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1155
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1157
  mutex_lock(ldv_func_arg1);
#line 1158
  return;
}
}
#line 1160 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
int ldv_mutex_trylock_718(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1165
  tmp = mutex_trylock(ldv_func_arg1);
#line 1165
  ldv_func_res = tmp;
#line 1167
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1167
  return (tmp___0);
#line 1169
  return (ldv_func_res);
}
}
#line 1172 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_719(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1177
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1179
  mutex_unlock(ldv_func_arg1);
#line 1180
  return;
}
}
#line 1182 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_720(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1187
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1189
  mutex_lock(ldv_func_arg1);
#line 1190
  return;
}
}
#line 1192 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_721(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1197
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
#line 1199
  mutex_unlock(ldv_func_arg1);
#line 1200
  return;
}
}
#line 1202 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_722(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1207
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1209
  mutex_lock(ldv_func_arg1);
#line 1210
  return;
}
}
#line 1212 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_723(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1217
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
#line 1219
  mutex_unlock(ldv_func_arg1);
#line 1220
  return;
}
}
#line 1222 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_724(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1227
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
#line 1229
  mutex_unlock(ldv_func_arg1);
#line 1230
  return;
}
}
#line 1232 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_725(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1237
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1239
  mutex_lock(ldv_func_arg1);
#line 1240
  return;
}
}
#line 1242 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_726(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1247
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
#line 1249
  mutex_unlock(ldv_func_arg1);
#line 1250
  return;
}
}
#line 1252 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_727(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1257
  ldv_mutex_lock_pm_mutex(ldv_func_arg1);
#line 1259
  mutex_lock(ldv_func_arg1);
#line 1260
  return;
}
}
#line 1262 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_728(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1267
  ldv_mutex_unlock_pm_mutex(ldv_func_arg1);
#line 1269
  mutex_unlock(ldv_func_arg1);
#line 1270
  return;
}
}
#line 1272 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_lock_729(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1277
  ldv_mutex_lock_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 1279
  mutex_lock(ldv_func_arg1);
#line 1280
  return;
}
}
#line 1282 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c.prepared"
void ldv_mutex_unlock_730(struct mutex *ldv_func_arg1 ) 
{ 

  {
#line 1287
  ldv_mutex_unlock_cmdbuf_mutex_of_vmw_private(ldv_func_arg1);
#line 1289
  mutex_unlock(ldv_func_arg1);
#line 1290
  return;
}
}
#line 10 "/home/zakharov/workspace/instruments/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/zakharov/workspace/instruments/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 

  {
  ERROR: __VERIFIER_error();
#line 12
  goto ERROR;
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/zakharov/workspace/instruments/ldv/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 

  {
#line 51
  return (exp);
}
}
#line 59 "/home/zakharov/workspace/instruments/ldv/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 

  {
#line 61
  ldv_error();
#line 62
  return;
}
}
#line 8 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cmdbuf_mutex_of_vmw_private  ;
#line 11 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 16
  if (ldv_mutex_cmdbuf_mutex_of_vmw_private == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_cmdbuf_mutex_of_vmw_private = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 42
  if (ldv_mutex_cmdbuf_mutex_of_vmw_private == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_cmdbuf_mutex_of_vmw_private = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) 
{ 

  {
#line 66
  if (ldv_mutex_cmdbuf_mutex_of_vmw_private == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_cmdbuf_mutex_of_vmw_private = 2;
#line 69
  return;
}
}
#line 72 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_cmdbuf_mutex_of_vmw_private == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_cmdbuf_mutex_of_vmw_private = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cmdbuf_mutex_of_vmw_private(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_cmdbuf_mutex_of_vmw_private == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_cmdbuf_mutex_of_vmw_private = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 127
  if (ldv_mutex_cmdbuf_mutex_of_vmw_private == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cmdbuf_mutex_of_vmw_private(struct mutex *lock ) 
{ 

  {
#line 155
  if (ldv_mutex_cmdbuf_mutex_of_vmw_private == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_cmdbuf_mutex_of_vmw_private = 1;
#line 158
  return;
}
}
#line 160 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cred_guard_mutex_of_signal_struct  ;
#line 163 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 168
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 194
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ 

  {
#line 218
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 221
  return;
}
}
#line 224 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cred_guard_mutex_of_signal_struct(atomic_t *cnt ,
                                                                    struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 279
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ 

  {
#line 307
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_cred_guard_mutex_of_signal_struct = 1;
#line 310
  return;
}
}
#line 312 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_fb_surf_mutex_of_vmw_master  ;
#line 315 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_fb_surf_mutex_of_vmw_master(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 320
  if (ldv_mutex_fb_surf_mutex_of_vmw_master == 1) {

  } else {
#line 320
    ldv_error();
  }
#line 323
  nondetermined = __VERIFIER_nondet_int();
#line 326
  if (nondetermined) {
#line 329
    ldv_mutex_fb_surf_mutex_of_vmw_master = 2;
#line 331
    return (0);
  } else {
#line 336
    return (-4);
  }
}
}
#line 341 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_fb_surf_mutex_of_vmw_master(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 346
  if (ldv_mutex_fb_surf_mutex_of_vmw_master == 1) {

  } else {
#line 346
    ldv_error();
  }
#line 349
  nondetermined = __VERIFIER_nondet_int();
#line 352
  if (nondetermined) {
#line 355
    ldv_mutex_fb_surf_mutex_of_vmw_master = 2;
#line 357
    return (0);
  } else {
#line 362
    return (-4);
  }
}
}
#line 367 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_fb_surf_mutex_of_vmw_master(struct mutex *lock ) 
{ 

  {
#line 370
  if (ldv_mutex_fb_surf_mutex_of_vmw_master == 1) {

  } else {
#line 370
    ldv_error();
  }
#line 372
  ldv_mutex_fb_surf_mutex_of_vmw_master = 2;
#line 373
  return;
}
}
#line 376 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_fb_surf_mutex_of_vmw_master(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 381
  if (ldv_mutex_fb_surf_mutex_of_vmw_master == 1) {

  } else {
#line 381
    ldv_error();
  }
#line 384
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 387
  if (is_mutex_held_by_another_thread) {
#line 390
    return (0);
  } else {
#line 395
    ldv_mutex_fb_surf_mutex_of_vmw_master = 2;
#line 397
    return (1);
  }
}
}
#line 402 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_fb_surf_mutex_of_vmw_master(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 407
  if (ldv_mutex_fb_surf_mutex_of_vmw_master == 1) {

  } else {
#line 407
    ldv_error();
  }
#line 410
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 413
  if (atomic_value_after_dec == 0) {
#line 416
    ldv_mutex_fb_surf_mutex_of_vmw_master = 2;
#line 418
    return (1);
  } else {

  }
#line 422
  return (0);
}
}
#line 427 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_fb_surf_mutex_of_vmw_master(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 431
  if (ldv_mutex_fb_surf_mutex_of_vmw_master == 1) {
#line 434
    nondetermined = __VERIFIER_nondet_int();
#line 437
    if (nondetermined) {
#line 440
      return (0);
    } else {
#line 445
      return (1);
    }
  } else {
#line 451
    return (1);
  }
}
}
#line 456 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_fb_surf_mutex_of_vmw_master(struct mutex *lock ) 
{ 

  {
#line 459
  if (ldv_mutex_fb_surf_mutex_of_vmw_master == 2) {

  } else {
#line 459
    ldv_error();
  }
#line 461
  ldv_mutex_fb_surf_mutex_of_vmw_master = 1;
#line 462
  return;
}
}
#line 464 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_fifo_mutex_of_vmw_fifo_state  ;
#line 467 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_fifo_mutex_of_vmw_fifo_state(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 472
  if (ldv_mutex_fifo_mutex_of_vmw_fifo_state == 1) {

  } else {
#line 472
    ldv_error();
  }
#line 475
  nondetermined = __VERIFIER_nondet_int();
#line 478
  if (nondetermined) {
#line 481
    ldv_mutex_fifo_mutex_of_vmw_fifo_state = 2;
#line 483
    return (0);
  } else {
#line 488
    return (-4);
  }
}
}
#line 493 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_fifo_mutex_of_vmw_fifo_state(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 498
  if (ldv_mutex_fifo_mutex_of_vmw_fifo_state == 1) {

  } else {
#line 498
    ldv_error();
  }
#line 501
  nondetermined = __VERIFIER_nondet_int();
#line 504
  if (nondetermined) {
#line 507
    ldv_mutex_fifo_mutex_of_vmw_fifo_state = 2;
#line 509
    return (0);
  } else {
#line 514
    return (-4);
  }
}
}
#line 519 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_fifo_mutex_of_vmw_fifo_state(struct mutex *lock ) 
{ 

  {
#line 522
  if (ldv_mutex_fifo_mutex_of_vmw_fifo_state == 1) {

  } else {
#line 522
    ldv_error();
  }
#line 524
  ldv_mutex_fifo_mutex_of_vmw_fifo_state = 2;
#line 525
  return;
}
}
#line 528 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_fifo_mutex_of_vmw_fifo_state(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 533
  if (ldv_mutex_fifo_mutex_of_vmw_fifo_state == 1) {

  } else {
#line 533
    ldv_error();
  }
#line 536
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 539
  if (is_mutex_held_by_another_thread) {
#line 542
    return (0);
  } else {
#line 547
    ldv_mutex_fifo_mutex_of_vmw_fifo_state = 2;
#line 549
    return (1);
  }
}
}
#line 554 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_fifo_mutex_of_vmw_fifo_state(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 559
  if (ldv_mutex_fifo_mutex_of_vmw_fifo_state == 1) {

  } else {
#line 559
    ldv_error();
  }
#line 562
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 565
  if (atomic_value_after_dec == 0) {
#line 568
    ldv_mutex_fifo_mutex_of_vmw_fifo_state = 2;
#line 570
    return (1);
  } else {

  }
#line 574
  return (0);
}
}
#line 579 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_fifo_mutex_of_vmw_fifo_state(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 583
  if (ldv_mutex_fifo_mutex_of_vmw_fifo_state == 1) {
#line 586
    nondetermined = __VERIFIER_nondet_int();
#line 589
    if (nondetermined) {
#line 592
      return (0);
    } else {
#line 597
      return (1);
    }
  } else {
#line 603
    return (1);
  }
}
}
#line 608 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_fifo_mutex_of_vmw_fifo_state(struct mutex *lock ) 
{ 

  {
#line 611
  if (ldv_mutex_fifo_mutex_of_vmw_fifo_state == 2) {

  } else {
#line 611
    ldv_error();
  }
#line 613
  ldv_mutex_fifo_mutex_of_vmw_fifo_state = 1;
#line 614
  return;
}
}
#line 616 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_goal_irq_mutex_of_vmw_fence_manager  ;
#line 619 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_goal_irq_mutex_of_vmw_fence_manager(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 624
  if (ldv_mutex_goal_irq_mutex_of_vmw_fence_manager == 1) {

  } else {
#line 624
    ldv_error();
  }
#line 627
  nondetermined = __VERIFIER_nondet_int();
#line 630
  if (nondetermined) {
#line 633
    ldv_mutex_goal_irq_mutex_of_vmw_fence_manager = 2;
#line 635
    return (0);
  } else {
#line 640
    return (-4);
  }
}
}
#line 645 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_goal_irq_mutex_of_vmw_fence_manager(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 650
  if (ldv_mutex_goal_irq_mutex_of_vmw_fence_manager == 1) {

  } else {
#line 650
    ldv_error();
  }
#line 653
  nondetermined = __VERIFIER_nondet_int();
#line 656
  if (nondetermined) {
#line 659
    ldv_mutex_goal_irq_mutex_of_vmw_fence_manager = 2;
#line 661
    return (0);
  } else {
#line 666
    return (-4);
  }
}
}
#line 671 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_goal_irq_mutex_of_vmw_fence_manager(struct mutex *lock ) 
{ 

  {
#line 674
  if (ldv_mutex_goal_irq_mutex_of_vmw_fence_manager == 1) {

  } else {
#line 674
    ldv_error();
  }
#line 676
  ldv_mutex_goal_irq_mutex_of_vmw_fence_manager = 2;
#line 677
  return;
}
}
#line 680 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_goal_irq_mutex_of_vmw_fence_manager(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 685
  if (ldv_mutex_goal_irq_mutex_of_vmw_fence_manager == 1) {

  } else {
#line 685
    ldv_error();
  }
#line 688
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 691
  if (is_mutex_held_by_another_thread) {
#line 694
    return (0);
  } else {
#line 699
    ldv_mutex_goal_irq_mutex_of_vmw_fence_manager = 2;
#line 701
    return (1);
  }
}
}
#line 706 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_goal_irq_mutex_of_vmw_fence_manager(atomic_t *cnt ,
                                                                      struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 711
  if (ldv_mutex_goal_irq_mutex_of_vmw_fence_manager == 1) {

  } else {
#line 711
    ldv_error();
  }
#line 714
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 717
  if (atomic_value_after_dec == 0) {
#line 720
    ldv_mutex_goal_irq_mutex_of_vmw_fence_manager = 2;
#line 722
    return (1);
  } else {

  }
#line 726
  return (0);
}
}
#line 731 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_goal_irq_mutex_of_vmw_fence_manager(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 735
  if (ldv_mutex_goal_irq_mutex_of_vmw_fence_manager == 1) {
#line 738
    nondetermined = __VERIFIER_nondet_int();
#line 741
    if (nondetermined) {
#line 744
      return (0);
    } else {
#line 749
      return (1);
    }
  } else {
#line 755
    return (1);
  }
}
}
#line 760 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_goal_irq_mutex_of_vmw_fence_manager(struct mutex *lock ) 
{ 

  {
#line 763
  if (ldv_mutex_goal_irq_mutex_of_vmw_fence_manager == 2) {

  } else {
#line 763
    ldv_error();
  }
#line 765
  ldv_mutex_goal_irq_mutex_of_vmw_fence_manager = 1;
#line 766
  return;
}
}
#line 768 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_hw_mutex_of_vmw_private  ;
#line 771 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_hw_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 776
  if (ldv_mutex_hw_mutex_of_vmw_private == 1) {

  } else {
#line 776
    ldv_error();
  }
#line 779
  nondetermined = __VERIFIER_nondet_int();
#line 782
  if (nondetermined) {
#line 785
    ldv_mutex_hw_mutex_of_vmw_private = 2;
#line 787
    return (0);
  } else {
#line 792
    return (-4);
  }
}
}
#line 797 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_hw_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 802
  if (ldv_mutex_hw_mutex_of_vmw_private == 1) {

  } else {
#line 802
    ldv_error();
  }
#line 805
  nondetermined = __VERIFIER_nondet_int();
#line 808
  if (nondetermined) {
#line 811
    ldv_mutex_hw_mutex_of_vmw_private = 2;
#line 813
    return (0);
  } else {
#line 818
    return (-4);
  }
}
}
#line 823 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_hw_mutex_of_vmw_private(struct mutex *lock ) 
{ 

  {
#line 826
  if (ldv_mutex_hw_mutex_of_vmw_private == 1) {

  } else {
#line 826
    ldv_error();
  }
#line 828
  ldv_mutex_hw_mutex_of_vmw_private = 2;
#line 829
  return;
}
}
#line 832 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_hw_mutex_of_vmw_private(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 837
  if (ldv_mutex_hw_mutex_of_vmw_private == 1) {

  } else {
#line 837
    ldv_error();
  }
#line 840
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 843
  if (is_mutex_held_by_another_thread) {
#line 846
    return (0);
  } else {
#line 851
    ldv_mutex_hw_mutex_of_vmw_private = 2;
#line 853
    return (1);
  }
}
}
#line 858 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_hw_mutex_of_vmw_private(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 863
  if (ldv_mutex_hw_mutex_of_vmw_private == 1) {

  } else {
#line 863
    ldv_error();
  }
#line 866
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 869
  if (atomic_value_after_dec == 0) {
#line 872
    ldv_mutex_hw_mutex_of_vmw_private = 2;
#line 874
    return (1);
  } else {

  }
#line 878
  return (0);
}
}
#line 883 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_hw_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 887
  if (ldv_mutex_hw_mutex_of_vmw_private == 1) {
#line 890
    nondetermined = __VERIFIER_nondet_int();
#line 893
    if (nondetermined) {
#line 896
      return (0);
    } else {
#line 901
      return (1);
    }
  } else {
#line 907
    return (1);
  }
}
}
#line 912 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_hw_mutex_of_vmw_private(struct mutex *lock ) 
{ 

  {
#line 915
  if (ldv_mutex_hw_mutex_of_vmw_private == 2) {

  } else {
#line 915
    ldv_error();
  }
#line 917
  ldv_mutex_hw_mutex_of_vmw_private = 1;
#line 918
  return;
}
}
#line 920 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 923 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 928
  if (ldv_mutex_lock == 1) {

  } else {
#line 928
    ldv_error();
  }
#line 931
  nondetermined = __VERIFIER_nondet_int();
#line 934
  if (nondetermined) {
#line 937
    ldv_mutex_lock = 2;
#line 939
    return (0);
  } else {
#line 944
    return (-4);
  }
}
}
#line 949 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 954
  if (ldv_mutex_lock == 1) {

  } else {
#line 954
    ldv_error();
  }
#line 957
  nondetermined = __VERIFIER_nondet_int();
#line 960
  if (nondetermined) {
#line 963
    ldv_mutex_lock = 2;
#line 965
    return (0);
  } else {
#line 970
    return (-4);
  }
}
}
#line 975 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 

  {
#line 978
  if (ldv_mutex_lock == 1) {

  } else {
#line 978
    ldv_error();
  }
#line 980
  ldv_mutex_lock = 2;
#line 981
  return;
}
}
#line 984 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 989
  if (ldv_mutex_lock == 1) {

  } else {
#line 989
    ldv_error();
  }
#line 992
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 995
  if (is_mutex_held_by_another_thread) {
#line 998
    return (0);
  } else {
#line 1003
    ldv_mutex_lock = 2;
#line 1005
    return (1);
  }
}
}
#line 1010 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1015
  if (ldv_mutex_lock == 1) {

  } else {
#line 1015
    ldv_error();
  }
#line 1018
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1021
  if (atomic_value_after_dec == 0) {
#line 1024
    ldv_mutex_lock = 2;
#line 1026
    return (1);
  } else {

  }
#line 1030
  return (0);
}
}
#line 1035 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1039
  if (ldv_mutex_lock == 1) {
#line 1042
    nondetermined = __VERIFIER_nondet_int();
#line 1045
    if (nondetermined) {
#line 1048
      return (0);
    } else {
#line 1053
      return (1);
    }
  } else {
#line 1059
    return (1);
  }
}
}
#line 1064 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 

  {
#line 1067
  if (ldv_mutex_lock == 2) {

  } else {
#line 1067
    ldv_error();
  }
#line 1069
  ldv_mutex_lock = 1;
#line 1070
  return;
}
}
#line 1072 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock_of_fb_info  ;
#line 1075 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock_of_fb_info(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1080
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
#line 1080
    ldv_error();
  }
#line 1083
  nondetermined = __VERIFIER_nondet_int();
#line 1086
  if (nondetermined) {
#line 1089
    ldv_mutex_lock_of_fb_info = 2;
#line 1091
    return (0);
  } else {
#line 1096
    return (-4);
  }
}
}
#line 1101 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock_of_fb_info(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1106
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
#line 1106
    ldv_error();
  }
#line 1109
  nondetermined = __VERIFIER_nondet_int();
#line 1112
  if (nondetermined) {
#line 1115
    ldv_mutex_lock_of_fb_info = 2;
#line 1117
    return (0);
  } else {
#line 1122
    return (-4);
  }
}
}
#line 1127 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock_of_fb_info(struct mutex *lock ) 
{ 

  {
#line 1130
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
#line 1130
    ldv_error();
  }
#line 1132
  ldv_mutex_lock_of_fb_info = 2;
#line 1133
  return;
}
}
#line 1136 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock_of_fb_info(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1141
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
#line 1141
    ldv_error();
  }
#line 1144
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1147
  if (is_mutex_held_by_another_thread) {
#line 1150
    return (0);
  } else {
#line 1155
    ldv_mutex_lock_of_fb_info = 2;
#line 1157
    return (1);
  }
}
}
#line 1162 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock_of_fb_info(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1167
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
#line 1167
    ldv_error();
  }
#line 1170
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1173
  if (atomic_value_after_dec == 0) {
#line 1176
    ldv_mutex_lock_of_fb_info = 2;
#line 1178
    return (1);
  } else {

  }
#line 1182
  return (0);
}
}
#line 1187 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock_of_fb_info(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1191
  if (ldv_mutex_lock_of_fb_info == 1) {
#line 1194
    nondetermined = __VERIFIER_nondet_int();
#line 1197
    if (nondetermined) {
#line 1200
      return (0);
    } else {
#line 1205
      return (1);
    }
  } else {
#line 1211
    return (1);
  }
}
}
#line 1216 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock_of_fb_info(struct mutex *lock ) 
{ 

  {
#line 1219
  if (ldv_mutex_lock_of_fb_info == 2) {

  } else {
#line 1219
    ldv_error();
  }
#line 1221
  ldv_mutex_lock_of_fb_info = 1;
#line 1222
  return;
}
}
#line 1224 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  ;
#line 1227 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1232
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 1232
    ldv_error();
  }
#line 1235
  nondetermined = __VERIFIER_nondet_int();
#line 1238
  if (nondetermined) {
#line 1241
    ldv_mutex_mutex_of_device = 2;
#line 1243
    return (0);
  } else {
#line 1248
    return (-4);
  }
}
}
#line 1253 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1258
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 1258
    ldv_error();
  }
#line 1261
  nondetermined = __VERIFIER_nondet_int();
#line 1264
  if (nondetermined) {
#line 1267
    ldv_mutex_mutex_of_device = 2;
#line 1269
    return (0);
  } else {
#line 1274
    return (-4);
  }
}
}
#line 1279 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 

  {
#line 1282
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 1282
    ldv_error();
  }
#line 1284
  ldv_mutex_mutex_of_device = 2;
#line 1285
  return;
}
}
#line 1288 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1293
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 1293
    ldv_error();
  }
#line 1296
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1299
  if (is_mutex_held_by_another_thread) {
#line 1302
    return (0);
  } else {
#line 1307
    ldv_mutex_mutex_of_device = 2;
#line 1309
    return (1);
  }
}
}
#line 1314 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1319
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 1319
    ldv_error();
  }
#line 1322
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1325
  if (atomic_value_after_dec == 0) {
#line 1328
    ldv_mutex_mutex_of_device = 2;
#line 1330
    return (1);
  } else {

  }
#line 1334
  return (0);
}
}
#line 1339 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1343
  if (ldv_mutex_mutex_of_device == 1) {
#line 1346
    nondetermined = __VERIFIER_nondet_int();
#line 1349
    if (nondetermined) {
#line 1352
      return (0);
    } else {
#line 1357
      return (1);
    }
  } else {
#line 1363
    return (1);
  }
}
}
#line 1368 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 

  {
#line 1371
  if (ldv_mutex_mutex_of_device == 2) {

  } else {
#line 1371
    ldv_error();
  }
#line 1373
  ldv_mutex_mutex_of_device = 1;
#line 1374
  return;
}
}
#line 1376 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_drm_mode_config  ;
#line 1379 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_drm_mode_config(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1384
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
#line 1384
    ldv_error();
  }
#line 1387
  nondetermined = __VERIFIER_nondet_int();
#line 1390
  if (nondetermined) {
#line 1393
    ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1395
    return (0);
  } else {
#line 1400
    return (-4);
  }
}
}
#line 1405 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_drm_mode_config(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1410
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
#line 1410
    ldv_error();
  }
#line 1413
  nondetermined = __VERIFIER_nondet_int();
#line 1416
  if (nondetermined) {
#line 1419
    ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1421
    return (0);
  } else {
#line 1426
    return (-4);
  }
}
}
#line 1431 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 

  {
#line 1434
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
#line 1434
    ldv_error();
  }
#line 1436
  ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1437
  return;
}
}
#line 1440 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1445
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
#line 1445
    ldv_error();
  }
#line 1448
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1451
  if (is_mutex_held_by_another_thread) {
#line 1454
    return (0);
  } else {
#line 1459
    ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1461
    return (1);
  }
}
}
#line 1466 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_drm_mode_config(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1471
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
#line 1471
    ldv_error();
  }
#line 1474
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1477
  if (atomic_value_after_dec == 0) {
#line 1480
    ldv_mutex_mutex_of_drm_mode_config = 2;
#line 1482
    return (1);
  } else {

  }
#line 1486
  return (0);
}
}
#line 1491 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_drm_mode_config(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1495
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {
#line 1498
    nondetermined = __VERIFIER_nondet_int();
#line 1501
    if (nondetermined) {
#line 1504
      return (0);
    } else {
#line 1509
      return (1);
    }
  } else {
#line 1515
    return (1);
  }
}
}
#line 1520 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 

  {
#line 1523
  if (ldv_mutex_mutex_of_drm_mode_config == 2) {

  } else {
#line 1523
    ldv_error();
  }
#line 1525
  ldv_mutex_mutex_of_drm_mode_config = 1;
#line 1526
  return;
}
}
#line 1528 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_vmw_overlay  ;
#line 1531 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_vmw_overlay(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1536
  if (ldv_mutex_mutex_of_vmw_overlay == 1) {

  } else {
#line 1536
    ldv_error();
  }
#line 1539
  nondetermined = __VERIFIER_nondet_int();
#line 1542
  if (nondetermined) {
#line 1545
    ldv_mutex_mutex_of_vmw_overlay = 2;
#line 1547
    return (0);
  } else {
#line 1552
    return (-4);
  }
}
}
#line 1557 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_vmw_overlay(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1562
  if (ldv_mutex_mutex_of_vmw_overlay == 1) {

  } else {
#line 1562
    ldv_error();
  }
#line 1565
  nondetermined = __VERIFIER_nondet_int();
#line 1568
  if (nondetermined) {
#line 1571
    ldv_mutex_mutex_of_vmw_overlay = 2;
#line 1573
    return (0);
  } else {
#line 1578
    return (-4);
  }
}
}
#line 1583 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_vmw_overlay(struct mutex *lock ) 
{ 

  {
#line 1586
  if (ldv_mutex_mutex_of_vmw_overlay == 1) {

  } else {
#line 1586
    ldv_error();
  }
#line 1588
  ldv_mutex_mutex_of_vmw_overlay = 2;
#line 1589
  return;
}
}
#line 1592 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_vmw_overlay(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1597
  if (ldv_mutex_mutex_of_vmw_overlay == 1) {

  } else {
#line 1597
    ldv_error();
  }
#line 1600
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1603
  if (is_mutex_held_by_another_thread) {
#line 1606
    return (0);
  } else {
#line 1611
    ldv_mutex_mutex_of_vmw_overlay = 2;
#line 1613
    return (1);
  }
}
}
#line 1618 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_vmw_overlay(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1623
  if (ldv_mutex_mutex_of_vmw_overlay == 1) {

  } else {
#line 1623
    ldv_error();
  }
#line 1626
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1629
  if (atomic_value_after_dec == 0) {
#line 1632
    ldv_mutex_mutex_of_vmw_overlay = 2;
#line 1634
    return (1);
  } else {

  }
#line 1638
  return (0);
}
}
#line 1643 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_vmw_overlay(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1647
  if (ldv_mutex_mutex_of_vmw_overlay == 1) {
#line 1650
    nondetermined = __VERIFIER_nondet_int();
#line 1653
    if (nondetermined) {
#line 1656
      return (0);
    } else {
#line 1661
      return (1);
    }
  } else {
#line 1667
    return (1);
  }
}
}
#line 1672 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_vmw_overlay(struct mutex *lock ) 
{ 

  {
#line 1675
  if (ldv_mutex_mutex_of_vmw_overlay == 2) {

  } else {
#line 1675
    ldv_error();
  }
#line 1677
  ldv_mutex_mutex_of_vmw_overlay = 1;
#line 1678
  return;
}
}
#line 1680 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_pm_mutex  ;
#line 1683 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_pm_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1688
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1688
    ldv_error();
  }
#line 1691
  nondetermined = __VERIFIER_nondet_int();
#line 1694
  if (nondetermined) {
#line 1697
    ldv_mutex_pm_mutex = 2;
#line 1699
    return (0);
  } else {
#line 1704
    return (-4);
  }
}
}
#line 1709 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_pm_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1714
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1714
    ldv_error();
  }
#line 1717
  nondetermined = __VERIFIER_nondet_int();
#line 1720
  if (nondetermined) {
#line 1723
    ldv_mutex_pm_mutex = 2;
#line 1725
    return (0);
  } else {
#line 1730
    return (-4);
  }
}
}
#line 1735 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_pm_mutex(struct mutex *lock ) 
{ 

  {
#line 1738
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1738
    ldv_error();
  }
#line 1740
  ldv_mutex_pm_mutex = 2;
#line 1741
  return;
}
}
#line 1744 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_pm_mutex(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1749
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1749
    ldv_error();
  }
#line 1752
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1755
  if (is_mutex_held_by_another_thread) {
#line 1758
    return (0);
  } else {
#line 1763
    ldv_mutex_pm_mutex = 2;
#line 1765
    return (1);
  }
}
}
#line 1770 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_pm_mutex(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1775
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 1775
    ldv_error();
  }
#line 1778
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1781
  if (atomic_value_after_dec == 0) {
#line 1784
    ldv_mutex_pm_mutex = 2;
#line 1786
    return (1);
  } else {

  }
#line 1790
  return (0);
}
}
#line 1795 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_pm_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1799
  if (ldv_mutex_pm_mutex == 1) {
#line 1802
    nondetermined = __VERIFIER_nondet_int();
#line 1805
    if (nondetermined) {
#line 1808
      return (0);
    } else {
#line 1813
      return (1);
    }
  } else {
#line 1819
    return (1);
  }
}
}
#line 1824 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_pm_mutex(struct mutex *lock ) 
{ 

  {
#line 1827
  if (ldv_mutex_pm_mutex == 2) {

  } else {
#line 1827
    ldv_error();
  }
#line 1829
  ldv_mutex_pm_mutex = 1;
#line 1830
  return;
}
}
#line 1832 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_release_mutex_of_vmw_private  ;
#line 1835 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_release_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1840
  if (ldv_mutex_release_mutex_of_vmw_private == 1) {

  } else {
#line 1840
    ldv_error();
  }
#line 1843
  nondetermined = __VERIFIER_nondet_int();
#line 1846
  if (nondetermined) {
#line 1849
    ldv_mutex_release_mutex_of_vmw_private = 2;
#line 1851
    return (0);
  } else {
#line 1856
    return (-4);
  }
}
}
#line 1861 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_release_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1866
  if (ldv_mutex_release_mutex_of_vmw_private == 1) {

  } else {
#line 1866
    ldv_error();
  }
#line 1869
  nondetermined = __VERIFIER_nondet_int();
#line 1872
  if (nondetermined) {
#line 1875
    ldv_mutex_release_mutex_of_vmw_private = 2;
#line 1877
    return (0);
  } else {
#line 1882
    return (-4);
  }
}
}
#line 1887 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_release_mutex_of_vmw_private(struct mutex *lock ) 
{ 

  {
#line 1890
  if (ldv_mutex_release_mutex_of_vmw_private == 1) {

  } else {
#line 1890
    ldv_error();
  }
#line 1892
  ldv_mutex_release_mutex_of_vmw_private = 2;
#line 1893
  return;
}
}
#line 1896 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_release_mutex_of_vmw_private(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 1901
  if (ldv_mutex_release_mutex_of_vmw_private == 1) {

  } else {
#line 1901
    ldv_error();
  }
#line 1904
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1907
  if (is_mutex_held_by_another_thread) {
#line 1910
    return (0);
  } else {
#line 1915
    ldv_mutex_release_mutex_of_vmw_private = 2;
#line 1917
    return (1);
  }
}
}
#line 1922 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_release_mutex_of_vmw_private(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 1927
  if (ldv_mutex_release_mutex_of_vmw_private == 1) {

  } else {
#line 1927
    ldv_error();
  }
#line 1930
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1933
  if (atomic_value_after_dec == 0) {
#line 1936
    ldv_mutex_release_mutex_of_vmw_private = 2;
#line 1938
    return (1);
  } else {

  }
#line 1942
  return (0);
}
}
#line 1947 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_release_mutex_of_vmw_private(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1951
  if (ldv_mutex_release_mutex_of_vmw_private == 1) {
#line 1954
    nondetermined = __VERIFIER_nondet_int();
#line 1957
    if (nondetermined) {
#line 1960
      return (0);
    } else {
#line 1965
      return (1);
    }
  } else {
#line 1971
    return (1);
  }
}
}
#line 1976 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_release_mutex_of_vmw_private(struct mutex *lock ) 
{ 

  {
#line 1979
  if (ldv_mutex_release_mutex_of_vmw_private == 2) {

  } else {
#line 1979
    ldv_error();
  }
#line 1981
  ldv_mutex_release_mutex_of_vmw_private = 1;
#line 1982
  return;
}
}
#line 1984 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_struct_mutex_of_drm_device  ;
#line 1987 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_struct_mutex_of_drm_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 1992
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
#line 1992
    ldv_error();
  }
#line 1995
  nondetermined = __VERIFIER_nondet_int();
#line 1998
  if (nondetermined) {
#line 2001
    ldv_mutex_struct_mutex_of_drm_device = 2;
#line 2003
    return (0);
  } else {
#line 2008
    return (-4);
  }
}
}
#line 2013 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_struct_mutex_of_drm_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 2018
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
#line 2018
    ldv_error();
  }
#line 2021
  nondetermined = __VERIFIER_nondet_int();
#line 2024
  if (nondetermined) {
#line 2027
    ldv_mutex_struct_mutex_of_drm_device = 2;
#line 2029
    return (0);
  } else {
#line 2034
    return (-4);
  }
}
}
#line 2039 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 

  {
#line 2042
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
#line 2042
    ldv_error();
  }
#line 2044
  ldv_mutex_struct_mutex_of_drm_device = 2;
#line 2045
  return;
}
}
#line 2048 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 2053
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
#line 2053
    ldv_error();
  }
#line 2056
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 2059
  if (is_mutex_held_by_another_thread) {
#line 2062
    return (0);
  } else {
#line 2067
    ldv_mutex_struct_mutex_of_drm_device = 2;
#line 2069
    return (1);
  }
}
}
#line 2074 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_struct_mutex_of_drm_device(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 2079
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
#line 2079
    ldv_error();
  }
#line 2082
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 2085
  if (atomic_value_after_dec == 0) {
#line 2088
    ldv_mutex_struct_mutex_of_drm_device = 2;
#line 2090
    return (1);
  } else {

  }
#line 2094
  return (0);
}
}
#line 2099 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_struct_mutex_of_drm_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 2103
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {
#line 2106
    nondetermined = __VERIFIER_nondet_int();
#line 2109
    if (nondetermined) {
#line 2112
      return (0);
    } else {
#line 2117
      return (1);
    }
  } else {
#line 2123
    return (1);
  }
}
}
#line 2128 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 

  {
#line 2131
  if (ldv_mutex_struct_mutex_of_drm_device == 2) {

  } else {
#line 2131
    ldv_error();
  }
#line 2133
  ldv_mutex_struct_mutex_of_drm_device = 1;
#line 2134
  return;
}
}
#line 2136 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_update_lock_of_backlight_device  ;
#line 2139 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_update_lock_of_backlight_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 2144
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
#line 2144
    ldv_error();
  }
#line 2147
  nondetermined = __VERIFIER_nondet_int();
#line 2150
  if (nondetermined) {
#line 2153
    ldv_mutex_update_lock_of_backlight_device = 2;
#line 2155
    return (0);
  } else {
#line 2160
    return (-4);
  }
}
}
#line 2165 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_update_lock_of_backlight_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 2170
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
#line 2170
    ldv_error();
  }
#line 2173
  nondetermined = __VERIFIER_nondet_int();
#line 2176
  if (nondetermined) {
#line 2179
    ldv_mutex_update_lock_of_backlight_device = 2;
#line 2181
    return (0);
  } else {
#line 2186
    return (-4);
  }
}
}
#line 2191 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_update_lock_of_backlight_device(struct mutex *lock ) 
{ 

  {
#line 2194
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
#line 2194
    ldv_error();
  }
#line 2196
  ldv_mutex_update_lock_of_backlight_device = 2;
#line 2197
  return;
}
}
#line 2200 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_update_lock_of_backlight_device(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
#line 2205
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
#line 2205
    ldv_error();
  }
#line 2208
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 2211
  if (is_mutex_held_by_another_thread) {
#line 2214
    return (0);
  } else {
#line 2219
    ldv_mutex_update_lock_of_backlight_device = 2;
#line 2221
    return (1);
  }
}
}
#line 2226 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_update_lock_of_backlight_device(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
#line 2231
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
#line 2231
    ldv_error();
  }
#line 2234
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 2237
  if (atomic_value_after_dec == 0) {
#line 2240
    ldv_mutex_update_lock_of_backlight_device = 2;
#line 2242
    return (1);
  } else {

  }
#line 2246
  return (0);
}
}
#line 2251 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_update_lock_of_backlight_device(struct mutex *lock ) 
{ int nondetermined ;

  {
#line 2255
  if (ldv_mutex_update_lock_of_backlight_device == 1) {
#line 2258
    nondetermined = __VERIFIER_nondet_int();
#line 2261
    if (nondetermined) {
#line 2264
      return (0);
    } else {
#line 2269
      return (1);
    }
  } else {
#line 2275
    return (1);
  }
}
}
#line 2280 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_update_lock_of_backlight_device(struct mutex *lock ) 
{ 

  {
#line 2283
  if (ldv_mutex_update_lock_of_backlight_device == 2) {

  } else {
#line 2283
    ldv_error();
  }
#line 2285
  ldv_mutex_update_lock_of_backlight_device = 1;
#line 2286
  return;
}
}
#line 2290 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 

  {
#line 2293
  ldv_mutex_cmdbuf_mutex_of_vmw_private = 1;
#line 2295
  ldv_mutex_cred_guard_mutex_of_signal_struct = 1;
#line 2297
  ldv_mutex_fb_surf_mutex_of_vmw_master = 1;
#line 2299
  ldv_mutex_fifo_mutex_of_vmw_fifo_state = 1;
#line 2301
  ldv_mutex_goal_irq_mutex_of_vmw_fence_manager = 1;
#line 2303
  ldv_mutex_hw_mutex_of_vmw_private = 1;
#line 2305
  ldv_mutex_lock = 1;
#line 2307
  ldv_mutex_lock_of_fb_info = 1;
#line 2309
  ldv_mutex_mutex_of_device = 1;
#line 2311
  ldv_mutex_mutex_of_drm_mode_config = 1;
#line 2313
  ldv_mutex_mutex_of_vmw_overlay = 1;
#line 2315
  ldv_mutex_pm_mutex = 1;
#line 2317
  ldv_mutex_release_mutex_of_vmw_private = 1;
#line 2319
  ldv_mutex_struct_mutex_of_drm_device = 1;
#line 2321
  ldv_mutex_update_lock_of_backlight_device = 1;
#line 2322
  return;
}
}
#line 2325 "/work/zakharov/bench-tests/cpa/work/current--X--drivers/gpu/drm/vmwgfx/vmwgfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/31/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 

  {
#line 2328
  if (ldv_mutex_cmdbuf_mutex_of_vmw_private == 1) {

  } else {
#line 2328
    ldv_error();
  }
#line 2330
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
#line 2330
    ldv_error();
  }
#line 2332
  if (ldv_mutex_fb_surf_mutex_of_vmw_master == 1) {

  } else {
#line 2332
    ldv_error();
  }
#line 2334
  if (ldv_mutex_fifo_mutex_of_vmw_fifo_state == 1) {

  } else {
#line 2334
    ldv_error();
  }
#line 2336
  if (ldv_mutex_goal_irq_mutex_of_vmw_fence_manager == 1) {

  } else {
#line 2336
    ldv_error();
  }
#line 2338
  if (ldv_mutex_hw_mutex_of_vmw_private == 1) {

  } else {
#line 2338
    ldv_error();
  }
#line 2340
  if (ldv_mutex_lock == 1) {

  } else {
#line 2340
    ldv_error();
  }
#line 2342
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
#line 2342
    ldv_error();
  }
#line 2344
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
#line 2344
    ldv_error();
  }
#line 2346
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
#line 2346
    ldv_error();
  }
#line 2348
  if (ldv_mutex_mutex_of_vmw_overlay == 1) {

  } else {
#line 2348
    ldv_error();
  }
#line 2350
  if (ldv_mutex_pm_mutex == 1) {

  } else {
#line 2350
    ldv_error();
  }
#line 2352
  if (ldv_mutex_release_mutex_of_vmw_private == 1) {

  } else {
#line 2352
    ldv_error();
  }
#line 2354
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
#line 2354
    ldv_error();
  }
#line 2356
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
#line 2356
    ldv_error();
  }
#line 2357
  return;
}
}
