extern void __VERIFIER_error() __attribute__ ((__noreturn__));

/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is false */

typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef unsigned char u8;
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
typedef int __kernel_pid_t;
typedef __kernel_long_t __kernel_suseconds_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
typedef __u32 nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef unsigned int oom_flags_t;
typedef u64 phys_addr_t;
typedef phys_addr_t resource_size_t;
struct __anonstruct_atomic_t_6 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
struct module;
typedef void (*ctor_fn_t)(void);
struct file_operations;
struct device;
struct completion;
struct pt_regs;
struct pid;
typedef u16 __ticket_t;
typedef u32 __ticketpair_t;
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
union __anonunion_ldv_2024_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
struct arch_spinlock {
   union __anonunion_ldv_2024_8 ldv_2024 ;
};
typedef struct arch_spinlock arch_spinlock_t;
struct __anonstruct_ldv_2031_10 {
   u32 read ;
   s32 write ;
};
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2031_10 ldv_2031 ;
};
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
struct task_struct;
struct lockdep_map;
struct mm_struct;
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
struct __anonstruct_ldv_2096_12 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct_ldv_2111_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
union __anonunion_ldv_2112_11 {
   struct __anonstruct_ldv_2096_12 ldv_2096 ;
   struct __anonstruct_ldv_2111_13 ldv_2111 ;
};
struct desc_struct {
   union __anonunion_ldv_2112_11 ldv_2112 ;
};
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_15 pgd_t;
struct page;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct thread_struct;
struct cpumask;
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
union __anonunion_ldv_2767_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2767_18 ldv_2767 ;
};
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
struct cpumask {
   unsigned long bits[64U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct static_key;
struct seq_operations;
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct_ldv_5125_23 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct_ldv_5131_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion_ldv_5132_22 {
   struct __anonstruct_ldv_5125_23 ldv_5125 ;
   struct __anonstruct_ldv_5131_24 ldv_5131 ;
};
union __anonunion_ldv_5141_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5132_22 ldv_5132 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5141_25 ldv_5141 ;
};
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
struct kmem_cache;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
typedef atomic64_t atomic_long_t;
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct_ldv_5960_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion_ldv_5961_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5960_29 ldv_5960 ;
};
struct spinlock {
   union __anonunion_ldv_5961_28 ldv_5961 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct timespec;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
struct user_namespace;
typedef uid_t kuid_t;
typedef gid_t kgid_t;
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct notifier_block;
typedef unsigned long long cycles_t;
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct tvec_base;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   int cpu ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
struct dev_pm_qos;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
struct pci_bus;
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
struct vm_area_struct;
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct nsproxy;
struct cred;
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
struct sock;
struct kobject;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
struct sysfs_dirent;
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
struct kernel_param;
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion_ldv_14022_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_14022_134 ldv_14022 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
struct static_key {
   atomic_t enabled ;
};
struct tracepoint;
struct tracepoint_func {
   void *func ;
   void *data ;
};
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct mod_arch_specific {

};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct ftrace_event_call;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
struct inode;
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
struct uprobe;
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
struct uprobes_state {
   struct xol_area *xol_area ;
};
struct address_space;
union __anonunion_ldv_14620_136 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
struct __anonstruct_ldv_14630_140 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
union __anonunion_ldv_14632_139 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14630_140 ldv_14630 ;
   int units ;
};
struct __anonstruct_ldv_14634_138 {
   union __anonunion_ldv_14632_139 ldv_14632 ;
   atomic_t _count ;
};
union __anonunion_ldv_14635_137 {
   unsigned long counters ;
   struct __anonstruct_ldv_14634_138 ldv_14634 ;
};
struct __anonstruct_ldv_14636_135 {
   union __anonunion_ldv_14620_136 ldv_14620 ;
   union __anonunion_ldv_14635_137 ldv_14635 ;
};
struct __anonstruct_ldv_14643_142 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
struct slab;
union __anonunion_ldv_14647_141 {
   struct list_head lru ;
   struct __anonstruct_ldv_14643_142 ldv_14643 ;
   struct list_head list ;
   struct slab *slab_page ;
};
union __anonunion_ldv_14652_143 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_14636_135 ldv_14636 ;
   union __anonunion_ldv_14647_141 ldv_14647 ;
   union __anonunion_ldv_14652_143 ldv_14652 ;
   unsigned long debug_flags ;
   int _last_nid ;
};
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
struct __anonstruct_linear_145 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
union __anonunion_shared_144 {
   struct __anonstruct_linear_145 linear ;
   struct list_head nonlinear ;
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_144 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
struct file_ra_state;
struct user_struct;
struct writeback_control;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct nameidata;
struct path;
struct vfsmount;
struct __anonstruct_ldv_17544_147 {
   u32 hash ;
   u32 len ;
};
union __anonunion_ldv_17546_146 {
   struct __anonstruct_ldv_17544_147 ldv_17544 ;
   u64 hash_len ;
};
struct qstr {
   union __anonunion_ldv_17546_146 ldv_17546 ;
   unsigned char const   *name ;
};
struct dentry_operations;
struct super_block;
union __anonunion_d_u_148 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_148 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct block_device;
struct io_context;
struct export_operations;
struct iovec;
struct kiocb;
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct swap_info_struct;
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
struct dquot;
typedef __kernel_uid32_t projid_t;
typedef projid_t kprojid_t;
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
typedef long long qsize_t;
union __anonunion_ldv_18550_150 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
struct kqid {
   union __anonunion_ldv_18550_150 ldv_18550 ;
   enum quota_type type ;
};
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
union __anonunion_arg_152 {
   char *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_151 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_152 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_151 read_descriptor_t;
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
struct backing_dev_info;
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
struct request_queue;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion_ldv_18984_153 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
union __anonunion_ldv_19004_154 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
struct file_lock;
struct cdev;
union __anonunion_ldv_19020_155 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_18984_153 ldv_18984 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_19004_154 ldv_19004 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_19020_155 ldv_19020 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_156 {
   struct list_head fu_list ;
   struct callback_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_156 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
struct files_struct;
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_158 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_157 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_158 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_157 fl_u ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
struct file_system_type;
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
struct exception_table_entry {
   int insn ;
   int fixup ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19U] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct termiox {
   __u16 x_hflag ;
   __u16 x_cflag ;
   __u16 x_rflag[5U] ;
   __u16 x_sflag ;
};
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
struct tty_struct;
struct tty_driver;
struct serial_icounter_struct;
struct tty_operations {
   struct tty_struct *(*lookup)(struct tty_driver * , struct inode * , int  ) ;
   int (*install)(struct tty_driver * , struct tty_struct * ) ;
   void (*remove)(struct tty_driver * , struct tty_struct * ) ;
   int (*open)(struct tty_struct * , struct file * ) ;
   void (*close)(struct tty_struct * , struct file * ) ;
   void (*shutdown)(struct tty_struct * ) ;
   void (*cleanup)(struct tty_struct * ) ;
   int (*write)(struct tty_struct * , unsigned char const   * , int  ) ;
   int (*put_char)(struct tty_struct * , unsigned char  ) ;
   void (*flush_chars)(struct tty_struct * ) ;
   int (*write_room)(struct tty_struct * ) ;
   int (*chars_in_buffer)(struct tty_struct * ) ;
   int (*ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   void (*throttle)(struct tty_struct * ) ;
   void (*unthrottle)(struct tty_struct * ) ;
   void (*stop)(struct tty_struct * ) ;
   void (*start)(struct tty_struct * ) ;
   void (*hangup)(struct tty_struct * ) ;
   int (*break_ctl)(struct tty_struct * , int  ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   void (*set_ldisc)(struct tty_struct * ) ;
   void (*wait_until_sent)(struct tty_struct * , int  ) ;
   void (*send_xchar)(struct tty_struct * , char  ) ;
   int (*tiocmget)(struct tty_struct * ) ;
   int (*tiocmset)(struct tty_struct * , unsigned int  , unsigned int  ) ;
   int (*resize)(struct tty_struct * , struct winsize * ) ;
   int (*set_termiox)(struct tty_struct * , struct termiox * ) ;
   int (*get_icount)(struct tty_struct * , struct serial_icounter_struct * ) ;
   int (*poll_init)(struct tty_driver * , int  , char * ) ;
   int (*poll_get_char)(struct tty_driver * , int  ) ;
   void (*poll_put_char)(struct tty_driver * , int  , char  ) ;
   struct file_operations  const  *proc_fops ;
};
struct proc_dir_entry;
struct tty_port;
struct tty_driver {
   int magic ;
   struct kref kref ;
   struct cdev *cdevs ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   unsigned int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   unsigned long flags ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct tty_port **ports ;
   struct ktermios **termios ;
   void *driver_state ;
   struct tty_operations  const  *ops ;
   struct list_head tty_drivers ;
};
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct dma_map_ops;
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct pdev_archdata {

};
struct device_private;
struct device_driver;
struct driver_private;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct iommu_ops;
struct iommu_group;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
struct device_type;
struct of_device_id;
struct acpi_device_id;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct acpi_dev_node {
   void *handle ;
};
struct dma_coherent_mem;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
};
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
struct pps_event_time {
   struct timespec ts_real ;
};
struct tty_ldisc_ops {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct * ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct * ) ;
   ssize_t (*read)(struct tty_struct * , struct file * , unsigned char * , size_t  ) ;
   ssize_t (*write)(struct tty_struct * , struct file * , unsigned char const   * ,
                    size_t  ) ;
   int (*ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct tty_struct * , struct file * , unsigned int  , unsigned long  ) ;
   void (*set_termios)(struct tty_struct * , struct ktermios * ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct * ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   * , char * , int  ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   void (*dcd_change)(struct tty_struct * , unsigned int  , struct pps_event_time * ) ;
   struct module *owner ;
   int refcount ;
};
struct tty_ldisc {
   struct tty_ldisc_ops *ops ;
   atomic_t users ;
   wait_queue_head_t wq_idle ;
};
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0U] ;
};
struct tty_bufhead {
   struct work_struct work ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
struct signal_struct;
struct tty_port_operations {
   int (*carrier_raised)(struct tty_port * ) ;
   void (*dtr_rts)(struct tty_port * , int  ) ;
   void (*shutdown)(struct tty_port * ) ;
   void (*drop)(struct tty_port * ) ;
   int (*activate)(struct tty_port * , struct tty_struct * ) ;
   void (*destruct)(struct tty_port * ) ;
};
struct tty_port {
   struct tty_bufhead buf ;
   struct tty_struct *tty ;
   struct tty_struct *itty ;
   struct tty_port_operations  const  *ops ;
   spinlock_t lock ;
   int blocked_open ;
   int count ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t delta_msr_wait ;
   unsigned long flags ;
   unsigned long iflags ;
   unsigned char console : 1 ;
   struct mutex mutex ;
   struct mutex buf_mutex ;
   unsigned char *xmit_buf ;
   unsigned int close_delay ;
   unsigned int closing_wait ;
   int drain_delay ;
   struct kref kref ;
};
struct tty_struct {
   int magic ;
   struct kref kref ;
   struct device *dev ;
   struct tty_driver *driver ;
   struct tty_operations  const  *ops ;
   int index ;
   struct mutex ldisc_mutex ;
   struct tty_ldisc *ldisc ;
   struct mutex atomic_write_lock ;
   struct mutex legacy_mutex ;
   struct mutex termios_mutex ;
   spinlock_t ctrl_lock ;
   struct ktermios termios ;
   struct ktermios termios_locked ;
   struct termiox *termiox ;
   char name[64U] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned char closing : 1 ;
   unsigned short minimum_to_wake ;
   unsigned char *write_buf ;
   int write_cnt ;
   struct work_struct SAK_work ;
   struct tty_port *port ;
};
struct mem_cgroup;
struct __anonstruct_ldv_22940_160 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
union __anonunion_ldv_22941_159 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_22940_160 ldv_22940 ;
};
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_22941_159 ldv_22941 ;
};
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
struct kmem_cache_order_objects {
   unsigned long x ;
};
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
typedef unsigned long cputime_t;
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct __anonstruct_sigset_t_162 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_162 sigset_t;
struct siginfo;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_164 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_165 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_166 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__sigfault_168 {
   void *_addr ;
   short _addr_lsb ;
};
struct __anonstruct__sigpoll_169 {
   long _band ;
   int _fd ;
};
struct __anonstruct__sigsys_170 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_163 {
   int _pad[28U] ;
   struct __anonstruct__kill_164 _kill ;
   struct __anonstruct__timer_165 _timer ;
   struct __anonstruct__rt_166 _rt ;
   struct __anonstruct__sigchld_167 _sigchld ;
   struct __anonstruct__sigfault_168 _sigfault ;
   struct __anonstruct__sigpoll_169 _sigpoll ;
   struct __anonstruct__sigsys_170 _sigsys ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_163 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct seccomp_filter;
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
struct plist_head {
   struct list_head node_list ;
};
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct plist_head wait_list ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
struct rt_mutex_waiter;
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct key_type;
struct keyring_list;
union __anonunion_ldv_25436_173 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
struct key_user;
union __anonunion_ldv_25445_174 {
   time_t expiry ;
   time_t revoked_at ;
};
union __anonunion_type_data_175 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
union __anonunion_payload_176 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_25436_173 ldv_25436 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_25445_174 ldv_25445 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_175 type_data ;
   union __anonunion_payload_176 payload ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
struct thread_group_cred;
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct cfs_rq;
struct task_group;
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kioctx;
union __anonunion_ki_obj_177 {
   void *user ;
   struct task_struct *tsk ;
};
struct eventfd_ctx;
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_177 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct callback_head callback_head ;
};
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
struct autogroup;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct rq;
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*migrate_task_rq)(struct task_struct * , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
struct css_set;
struct compat_robust_list_head;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
};
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9U] ;
};
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct acpi_device_id {
   __u8 id[16U] ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
struct mfd_cell;
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
typedef u32 phandle;
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
};
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct device_node *next ;
   struct device_node *allnext ;
   struct proc_dir_entry *pde ;
   struct kref kref ;
   unsigned long _flags ;
   void *data ;
};
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
struct i2c_algorithm;
struct i2c_adapter;
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
};
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
};
struct fb_fix_screeninfo {
   char id[16U] ;
   unsigned long smem_start ;
   __u32 smem_len ;
   __u32 type ;
   __u32 type_aux ;
   __u32 visual ;
   __u16 xpanstep ;
   __u16 ypanstep ;
   __u16 ywrapstep ;
   __u32 line_length ;
   unsigned long mmio_start ;
   __u32 mmio_len ;
   __u32 accel ;
   __u16 capabilities ;
   __u16 reserved[2U] ;
};
struct fb_bitfield {
   __u32 offset ;
   __u32 length ;
   __u32 msb_right ;
};
struct fb_var_screeninfo {
   __u32 xres ;
   __u32 yres ;
   __u32 xres_virtual ;
   __u32 yres_virtual ;
   __u32 xoffset ;
   __u32 yoffset ;
   __u32 bits_per_pixel ;
   __u32 grayscale ;
   struct fb_bitfield red ;
   struct fb_bitfield green ;
   struct fb_bitfield blue ;
   struct fb_bitfield transp ;
   __u32 nonstd ;
   __u32 activate ;
   __u32 height ;
   __u32 width ;
   __u32 accel_flags ;
   __u32 pixclock ;
   __u32 left_margin ;
   __u32 right_margin ;
   __u32 upper_margin ;
   __u32 lower_margin ;
   __u32 hsync_len ;
   __u32 vsync_len ;
   __u32 sync ;
   __u32 vmode ;
   __u32 rotate ;
   __u32 colorspace ;
   __u32 reserved[4U] ;
};
struct fb_cmap {
   __u32 start ;
   __u32 len ;
   __u16 *red ;
   __u16 *green ;
   __u16 *blue ;
   __u16 *transp ;
};
struct fb_copyarea {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 sx ;
   __u32 sy ;
};
struct fb_fillrect {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 color ;
   __u32 rop ;
};
struct fb_image {
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
   __u32 fg_color ;
   __u32 bg_color ;
   __u8 depth ;
   char const   *data ;
   struct fb_cmap cmap ;
};
struct fbcurpos {
   __u16 x ;
   __u16 y ;
};
struct fb_cursor {
   __u16 set ;
   __u16 enable ;
   __u16 rop ;
   char const   *mask ;
   struct fbcurpos hot ;
   struct fb_image image ;
};
enum backlight_type {
    BACKLIGHT_RAW = 1,
    BACKLIGHT_PLATFORM = 2,
    BACKLIGHT_FIRMWARE = 3,
    BACKLIGHT_TYPE_MAX = 4
} ;
struct backlight_device;
struct fb_info;
struct backlight_ops {
   unsigned int options ;
   int (*update_status)(struct backlight_device * ) ;
   int (*get_brightness)(struct backlight_device * ) ;
   int (*check_fb)(struct backlight_device * , struct fb_info * ) ;
};
struct backlight_properties {
   int brightness ;
   int max_brightness ;
   int power ;
   int fb_blank ;
   enum backlight_type type ;
   unsigned int state ;
};
struct backlight_device {
   struct backlight_properties props ;
   struct mutex update_lock ;
   struct mutex ops_lock ;
   struct backlight_ops  const  *ops ;
   struct notifier_block fb_notif ;
   struct device dev ;
};
struct fb_chroma {
   __u32 redx ;
   __u32 greenx ;
   __u32 bluex ;
   __u32 whitex ;
   __u32 redy ;
   __u32 greeny ;
   __u32 bluey ;
   __u32 whitey ;
};
struct fb_videomode;
struct fb_monspecs {
   struct fb_chroma chroma ;
   struct fb_videomode *modedb ;
   __u8 manufacturer[4U] ;
   __u8 monitor[14U] ;
   __u8 serial_no[14U] ;
   __u8 ascii[14U] ;
   __u32 modedb_len ;
   __u32 model ;
   __u32 serial ;
   __u32 year ;
   __u32 week ;
   __u32 hfmin ;
   __u32 hfmax ;
   __u32 dclkmin ;
   __u32 dclkmax ;
   __u16 input ;
   __u16 dpms ;
   __u16 signal ;
   __u16 vfmin ;
   __u16 vfmax ;
   __u16 gamma ;
   unsigned char gtf : 1 ;
   __u16 misc ;
   __u8 version ;
   __u8 revision ;
   __u8 max_x ;
   __u8 max_y ;
};
struct fb_blit_caps {
   u32 x ;
   u32 y ;
   u32 len ;
   u32 flags ;
};
struct fb_pixmap {
   u8 *addr ;
   u32 size ;
   u32 offset ;
   u32 buf_align ;
   u32 scan_align ;
   u32 access_align ;
   u32 flags ;
   u32 blit_x ;
   u32 blit_y ;
   void (*writeio)(struct fb_info * , void * , void * , unsigned int  ) ;
   void (*readio)(struct fb_info * , void * , void * , unsigned int  ) ;
};
struct fb_deferred_io {
   unsigned long delay ;
   struct mutex lock ;
   struct list_head pagelist ;
   void (*first_io)(struct fb_info * ) ;
   void (*deferred_io)(struct fb_info * , struct list_head * ) ;
};
struct fb_ops {
   struct module *owner ;
   int (*fb_open)(struct fb_info * , int  ) ;
   int (*fb_release)(struct fb_info * , int  ) ;
   ssize_t (*fb_read)(struct fb_info * , char * , size_t  , loff_t * ) ;
   ssize_t (*fb_write)(struct fb_info * , char const   * , size_t  , loff_t * ) ;
   int (*fb_check_var)(struct fb_var_screeninfo * , struct fb_info * ) ;
   int (*fb_set_par)(struct fb_info * ) ;
   int (*fb_setcolreg)(unsigned int  , unsigned int  , unsigned int  , unsigned int  ,
                       unsigned int  , struct fb_info * ) ;
   int (*fb_setcmap)(struct fb_cmap * , struct fb_info * ) ;
   int (*fb_blank)(int  , struct fb_info * ) ;
   int (*fb_pan_display)(struct fb_var_screeninfo * , struct fb_info * ) ;
   void (*fb_fillrect)(struct fb_info * , struct fb_fillrect  const  * ) ;
   void (*fb_copyarea)(struct fb_info * , struct fb_copyarea  const  * ) ;
   void (*fb_imageblit)(struct fb_info * , struct fb_image  const  * ) ;
   int (*fb_cursor)(struct fb_info * , struct fb_cursor * ) ;
   void (*fb_rotate)(struct fb_info * , int  ) ;
   int (*fb_sync)(struct fb_info * ) ;
   int (*fb_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_compat_ioctl)(struct fb_info * , unsigned int  , unsigned long  ) ;
   int (*fb_mmap)(struct fb_info * , struct vm_area_struct * ) ;
   void (*fb_get_caps)(struct fb_info * , struct fb_blit_caps * , struct fb_var_screeninfo * ) ;
   void (*fb_destroy)(struct fb_info * ) ;
   int (*fb_debug_enter)(struct fb_info * ) ;
   int (*fb_debug_leave)(struct fb_info * ) ;
};
struct fb_tilemap {
   __u32 width ;
   __u32 height ;
   __u32 depth ;
   __u32 length ;
   __u8 const   *data ;
};
struct fb_tilerect {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 index ;
   __u32 fg ;
   __u32 bg ;
   __u32 rop ;
};
struct fb_tilearea {
   __u32 sx ;
   __u32 sy ;
   __u32 dx ;
   __u32 dy ;
   __u32 width ;
   __u32 height ;
};
struct fb_tileblit {
   __u32 sx ;
   __u32 sy ;
   __u32 width ;
   __u32 height ;
   __u32 fg ;
   __u32 bg ;
   __u32 length ;
   __u32 *indices ;
};
struct fb_tilecursor {
   __u32 sx ;
   __u32 sy ;
   __u32 mode ;
   __u32 shape ;
   __u32 fg ;
   __u32 bg ;
};
struct fb_tile_ops {
   void (*fb_settile)(struct fb_info * , struct fb_tilemap * ) ;
   void (*fb_tilecopy)(struct fb_info * , struct fb_tilearea * ) ;
   void (*fb_tilefill)(struct fb_info * , struct fb_tilerect * ) ;
   void (*fb_tileblit)(struct fb_info * , struct fb_tileblit * ) ;
   void (*fb_tilecursor)(struct fb_info * , struct fb_tilecursor * ) ;
   int (*fb_get_tilemax)(struct fb_info * ) ;
};
struct aperture {
   resource_size_t base ;
   resource_size_t size ;
};
struct apertures_struct {
   unsigned int count ;
   struct aperture ranges[0U] ;
};
struct fb_info {
   atomic_t count ;
   int node ;
   int flags ;
   struct mutex lock ;
   struct mutex mm_lock ;
   struct fb_var_screeninfo var ;
   struct fb_fix_screeninfo fix ;
   struct fb_monspecs monspecs ;
   struct work_struct queue ;
   struct fb_pixmap pixmap ;
   struct fb_pixmap sprite ;
   struct fb_cmap cmap ;
   struct list_head modelist ;
   struct fb_videomode *mode ;
   struct backlight_device *bl_dev ;
   struct mutex bl_curve_mutex ;
   u8 bl_curve[128U] ;
   struct delayed_work deferred_work ;
   struct fb_deferred_io *fbdefio ;
   struct fb_ops *fbops ;
   struct device *device ;
   struct device *dev ;
   int class_flag ;
   struct fb_tile_ops *tileops ;
   char *screen_base ;
   unsigned long screen_size ;
   void *pseudo_palette ;
   u32 state ;
   void *fbcon_par ;
   void *par ;
   struct apertures_struct *apertures ;
};
struct fb_videomode {
   char const   *name ;
   u32 refresh ;
   u32 xres ;
   u32 yres ;
   u32 pixclock ;
   u32 left_margin ;
   u32 right_margin ;
   u32 upper_margin ;
   u32 lower_margin ;
   u32 hsync_len ;
   u32 vsync_len ;
   u32 sync ;
   u32 vmode ;
   u32 flag ;
};
typedef int read_proc_t(char * , char ** , off_t  , int  , int * , void * );
typedef int write_proc_t(struct file * , char const   * , unsigned long  , void * );
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[] ;
};
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
typedef int pci_power_t;
typedef unsigned int pci_channel_state_t;
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned short pci_dev_flags_t;
typedef unsigned short pci_bus_flags_t;
struct pcie_link_state;
struct pci_vpd;
struct pci_sriov;
struct pci_ats;
struct pci_driver;
union __anonunion_ldv_30120_180 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_30120_180 ldv_30120 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
typedef unsigned int pci_ers_result_t;
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
typedef s32 compat_long_t;
typedef u32 compat_uptr_t;
struct compat_robust_list {
   compat_uptr_t next ;
};
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
enum chipset_type {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1
} ;
struct agp_version {
   u16 major ;
   u16 minor ;
};
struct agp_kern_info {
   struct agp_version version ;
   struct pci_dev *device ;
   enum chipset_type chipset ;
   unsigned long mode ;
   unsigned long aper_base ;
   size_t aper_size ;
   int max_memory ;
   int current_memory ;
   bool cant_use_aperture ;
   unsigned long page_mask ;
   struct vm_operations_struct  const  *vm_ops ;
};
struct agp_bridge_data;
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
typedef unsigned int drm_magic_t;
struct drm_clip_rect {
   unsigned short x1 ;
   unsigned short y1 ;
   unsigned short x2 ;
   unsigned short y2 ;
};
struct drm_hw_lock {
   unsigned int volatile   lock ;
   char padding[60U] ;
};
struct drm_unique {
   size_t unique_len ;
   char *unique ;
};
enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5,
    _DRM_GEM = 6
} ;
enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128
} ;
enum drm_stat_type {
    _DRM_STAT_LOCK = 0,
    _DRM_STAT_OPENS = 1,
    _DRM_STAT_CLOSES = 2,
    _DRM_STAT_IOCTLS = 3,
    _DRM_STAT_LOCKS = 4,
    _DRM_STAT_UNLOCKS = 5,
    _DRM_STAT_VALUE = 6,
    _DRM_STAT_BYTE = 7,
    _DRM_STAT_COUNT = 8,
    _DRM_STAT_IRQ = 9,
    _DRM_STAT_PRIMARY = 10,
    _DRM_STAT_SECONDARY = 11,
    _DRM_STAT_DMA = 12,
    _DRM_STAT_SPECIAL = 13,
    _DRM_STAT_MISSED = 14
} ;
struct drm_irq_busid {
   int irq ;
   int busnum ;
   int devnum ;
   int funcnum ;
};
struct drm_set_version {
   int drm_di_major ;
   int drm_di_minor ;
   int drm_dd_major ;
   int drm_dd_minor ;
};
struct drm_mode_fb_cmd2 {
   __u32 fb_id ;
   __u32 width ;
   __u32 height ;
   __u32 pixel_format ;
   __u32 flags ;
   __u32 handles[4U] ;
   __u32 pitches[4U] ;
   __u32 offsets[4U] ;
};
struct drm_mode_create_dumb {
   uint32_t height ;
   uint32_t width ;
   uint32_t bpp ;
   uint32_t flags ;
   uint32_t handle ;
   uint32_t pitch ;
   uint64_t size ;
};
struct drm_event {
   __u32 type ;
   __u32 length ;
};
struct drm_event_vblank {
   struct drm_event base ;
   __u64 user_data ;
   __u32 tv_sec ;
   __u32 tv_usec ;
   __u32 sequence ;
   __u32 reserved ;
};
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[64U] ;
   int count ;
   int layer ;
   struct callback_head callback_head ;
};
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
struct drm_file;
struct drm_device;
struct drm_hash_item {
   struct hlist_node head ;
   unsigned long key ;
};
struct drm_open_hash {
   struct hlist_head *table ;
   u8 order ;
};
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct drm_mm;
struct drm_mm_node {
   struct list_head node_list ;
   struct list_head hole_stack ;
   unsigned char hole_follows : 1 ;
   unsigned char scanned_block : 1 ;
   unsigned char scanned_prev_free : 1 ;
   unsigned char scanned_next_free : 1 ;
   unsigned char scanned_preceeds_hole : 1 ;
   unsigned char allocated : 1 ;
   unsigned long color ;
   unsigned long start ;
   unsigned long size ;
   struct drm_mm *mm ;
};
struct drm_mm {
   struct list_head hole_stack ;
   struct drm_mm_node head_node ;
   struct list_head unused_nodes ;
   int num_unused ;
   spinlock_t unused_lock ;
   unsigned char scan_check_range : 1 ;
   unsigned int scan_alignment ;
   unsigned long scan_color ;
   unsigned long scan_size ;
   unsigned long scan_hit_start ;
   unsigned int scan_hit_size ;
   unsigned int scanned_blocks ;
   unsigned long scan_start ;
   unsigned long scan_end ;
   struct drm_mm_node *prev_scanned_node ;
   void (*color_adjust)(struct drm_mm_node * , unsigned long  , unsigned long * ,
                        unsigned long * ) ;
};
typedef int drm_ioctl_t(struct drm_device * , void * , struct drm_file * );
struct drm_ioctl_desc {
   unsigned int cmd ;
   int flags ;
   drm_ioctl_t *func ;
   unsigned int cmd_drv ;
};
enum ldv_26181 {
    DRM_LIST_NONE = 0,
    DRM_LIST_FREE = 1,
    DRM_LIST_WAIT = 2,
    DRM_LIST_PEND = 3,
    DRM_LIST_PRIO = 4,
    DRM_LIST_RECLAIM = 5
} ;
struct drm_buf {
   int idx ;
   int total ;
   int order ;
   int used ;
   unsigned long offset ;
   void *address ;
   unsigned long bus_address ;
   struct drm_buf *next ;
   int volatile   waiting ;
   int volatile   pending ;
   struct drm_file *file_priv ;
   int context ;
   int while_locked ;
   enum ldv_26181 list ;
   int dev_priv_size ;
   void *dev_private ;
};
struct drm_freelist {
   int initialized ;
   atomic_t count ;
   struct drm_buf *next ;
   wait_queue_head_t waiting ;
   int low_mark ;
   int high_mark ;
   atomic_t wfh ;
   spinlock_t lock ;
};
struct drm_dma_handle {
   dma_addr_t busaddr ;
   void *vaddr ;
   size_t size ;
};
struct drm_buf_entry {
   int buf_size ;
   int buf_count ;
   struct drm_buf *buflist ;
   int seg_count ;
   int page_order ;
   struct drm_dma_handle **seglist ;
   struct drm_freelist freelist ;
};
struct drm_pending_event {
   struct drm_event *event ;
   struct list_head link ;
   struct drm_file *file_priv ;
   pid_t pid ;
   void (*destroy)(struct drm_pending_event * ) ;
};
struct drm_prime_file_private {
   struct list_head head ;
   struct mutex lock ;
};
struct drm_minor;
struct drm_master;
struct drm_file {
   int authenticated ;
   struct pid *pid ;
   kuid_t uid ;
   drm_magic_t magic ;
   unsigned long ioctl_count ;
   struct list_head lhead ;
   struct drm_minor *minor ;
   unsigned long lock_count ;
   struct idr object_idr ;
   spinlock_t table_lock ;
   struct file *filp ;
   void *driver_priv ;
   int is_master ;
   struct drm_master *master ;
   struct list_head fbs ;
   wait_queue_head_t event_wait ;
   struct list_head event_list ;
   int event_space ;
   struct drm_prime_file_private prime ;
};
struct drm_lock_data {
   struct drm_hw_lock *hw_lock ;
   struct drm_file *file_priv ;
   wait_queue_head_t lock_queue ;
   unsigned long lock_time ;
   spinlock_t spinlock ;
   uint32_t kernel_waiters ;
   uint32_t user_waiters ;
   int idle_has_lock ;
};
enum ldv_26207 {
    _DRM_DMA_USE_AGP = 1,
    _DRM_DMA_USE_SG = 2,
    _DRM_DMA_USE_FB = 4,
    _DRM_DMA_USE_PCI_RO = 8
} ;
struct drm_device_dma {
   struct drm_buf_entry bufs[23U] ;
   int buf_count ;
   struct drm_buf **buflist ;
   int seg_count ;
   int page_count ;
   unsigned long *pagelist ;
   unsigned long byte_count ;
   enum ldv_26207 flags ;
};
struct drm_agp_head {
   struct agp_kern_info agp_info ;
   struct list_head memory ;
   unsigned long mode ;
   struct agp_bridge_data *bridge ;
   int enabled ;
   int acquired ;
   unsigned long base ;
   int agp_mtrr ;
   int cant_use_aperture ;
   unsigned long page_mask ;
};
struct drm_sg_mem {
   unsigned long handle ;
   void *virtual ;
   int pages ;
   struct page **pagelist ;
   dma_addr_t *busaddr ;
};
struct drm_sigdata {
   int context ;
   struct drm_hw_lock *lock ;
};
struct drm_local_map {
   resource_size_t offset ;
   unsigned long size ;
   enum drm_map_type type ;
   enum drm_map_flags flags ;
   void *handle ;
   int mtrr ;
};
struct drm_map_list {
   struct list_head head ;
   struct drm_hash_item hash ;
   struct drm_local_map *map ;
   uint64_t user_token ;
   struct drm_master *master ;
   struct drm_mm_node *file_offset_node ;
};
struct dma_buf;
struct dma_buf_attachment;
struct drm_gem_object {
   struct kref refcount ;
   atomic_t handle_count ;
   struct drm_device *dev ;
   struct file *filp ;
   struct drm_map_list map_list ;
   size_t size ;
   int name ;
   uint32_t read_domains ;
   uint32_t write_domain ;
   uint32_t pending_read_domains ;
   uint32_t pending_write_domain ;
   void *driver_private ;
   struct dma_buf *export_dma_buf ;
   struct dma_buf_attachment *import_attach ;
};
struct drm_mode_set;
struct drm_framebuffer;
struct drm_object_properties;
struct drm_mode_object {
   uint32_t id ;
   uint32_t type ;
   struct drm_object_properties *properties ;
};
struct drm_object_properties {
   int count ;
   uint32_t ids[24U] ;
   uint64_t values[24U] ;
};
enum drm_mode_status {
    MODE_OK = 0,
    MODE_HSYNC = 1,
    MODE_VSYNC = 2,
    MODE_H_ILLEGAL = 3,
    MODE_V_ILLEGAL = 4,
    MODE_BAD_WIDTH = 5,
    MODE_NOMODE = 6,
    MODE_NO_INTERLACE = 7,
    MODE_NO_DBLESCAN = 8,
    MODE_NO_VSCAN = 9,
    MODE_MEM = 10,
    MODE_VIRTUAL_X = 11,
    MODE_VIRTUAL_Y = 12,
    MODE_MEM_VIRT = 13,
    MODE_NOCLOCK = 14,
    MODE_CLOCK_HIGH = 15,
    MODE_CLOCK_LOW = 16,
    MODE_CLOCK_RANGE = 17,
    MODE_BAD_HVALUE = 18,
    MODE_BAD_VVALUE = 19,
    MODE_BAD_VSCAN = 20,
    MODE_HSYNC_NARROW = 21,
    MODE_HSYNC_WIDE = 22,
    MODE_HBLANK_NARROW = 23,
    MODE_HBLANK_WIDE = 24,
    MODE_VSYNC_NARROW = 25,
    MODE_VSYNC_WIDE = 26,
    MODE_VBLANK_NARROW = 27,
    MODE_VBLANK_WIDE = 28,
    MODE_PANEL = 29,
    MODE_INTERLACE_WIDTH = 30,
    MODE_ONE_WIDTH = 31,
    MODE_ONE_HEIGHT = 32,
    MODE_ONE_SIZE = 33,
    MODE_NO_REDUCED = 34,
    MODE_UNVERIFIED = -3,
    MODE_BAD = -2,
    MODE_ERROR = -1
} ;
struct drm_display_mode {
   struct list_head head ;
   struct drm_mode_object base ;
   char name[32U] ;
   enum drm_mode_status status ;
   unsigned int type ;
   int clock ;
   int hdisplay ;
   int hsync_start ;
   int hsync_end ;
   int htotal ;
   int hskew ;
   int vdisplay ;
   int vsync_start ;
   int vsync_end ;
   int vtotal ;
   int vscan ;
   unsigned int flags ;
   int width_mm ;
   int height_mm ;
   int clock_index ;
   int synth_clock ;
   int crtc_hdisplay ;
   int crtc_hblank_start ;
   int crtc_hblank_end ;
   int crtc_hsync_start ;
   int crtc_hsync_end ;
   int crtc_htotal ;
   int crtc_hskew ;
   int crtc_vdisplay ;
   int crtc_vblank_start ;
   int crtc_vblank_end ;
   int crtc_vsync_start ;
   int crtc_vsync_end ;
   int crtc_vtotal ;
   int private_size ;
   int *private ;
   int private_flags ;
   int vrefresh ;
   int hsync ;
};
enum drm_connector_status {
    connector_status_connected = 1,
    connector_status_disconnected = 2,
    connector_status_unknown = 3
} ;
enum subpixel_order {
    SubPixelUnknown = 0,
    SubPixelHorizontalRGB = 1,
    SubPixelHorizontalBGR = 2,
    SubPixelVerticalRGB = 3,
    SubPixelVerticalBGR = 4,
    SubPixelNone = 5
} ;
struct drm_display_info {
   char name[32U] ;
   unsigned int width_mm ;
   unsigned int height_mm ;
   unsigned int min_vfreq ;
   unsigned int max_vfreq ;
   unsigned int min_hfreq ;
   unsigned int max_hfreq ;
   unsigned int pixel_clock ;
   unsigned int bpc ;
   enum subpixel_order subpixel_order ;
   u32 color_formats ;
   u8 cea_rev ;
};
struct drm_framebuffer_funcs {
   void (*destroy)(struct drm_framebuffer * ) ;
   int (*create_handle)(struct drm_framebuffer * , struct drm_file * , unsigned int * ) ;
   int (*dirty)(struct drm_framebuffer * , struct drm_file * , unsigned int  , unsigned int  ,
                struct drm_clip_rect * , unsigned int  ) ;
};
struct drm_framebuffer {
   struct drm_device *dev ;
   struct kref refcount ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer_funcs  const  *funcs ;
   unsigned int pitches[4U] ;
   unsigned int offsets[4U] ;
   unsigned int width ;
   unsigned int height ;
   unsigned int depth ;
   int bits_per_pixel ;
   int flags ;
   uint32_t pixel_format ;
   struct list_head filp_head ;
   void *helper_private ;
};
struct drm_property_blob {
   struct drm_mode_object base ;
   struct list_head head ;
   unsigned int length ;
   unsigned char data[] ;
};
struct drm_property {
   struct list_head head ;
   struct drm_mode_object base ;
   uint32_t flags ;
   char name[32U] ;
   uint32_t num_values ;
   uint64_t *values ;
   struct list_head enum_blob_list ;
};
struct drm_crtc;
struct drm_connector;
struct drm_encoder;
struct drm_pending_vblank_event;
struct drm_crtc_funcs {
   void (*save)(struct drm_crtc * ) ;
   void (*restore)(struct drm_crtc * ) ;
   void (*reset)(struct drm_crtc * ) ;
   int (*cursor_set)(struct drm_crtc * , struct drm_file * , uint32_t  , uint32_t  ,
                     uint32_t  ) ;
   int (*cursor_move)(struct drm_crtc * , int  , int  ) ;
   void (*gamma_set)(struct drm_crtc * , u16 * , u16 * , u16 * , uint32_t  , uint32_t  ) ;
   void (*destroy)(struct drm_crtc * ) ;
   int (*set_config)(struct drm_mode_set * ) ;
   int (*page_flip)(struct drm_crtc * , struct drm_framebuffer * , struct drm_pending_vblank_event * ) ;
   int (*set_property)(struct drm_crtc * , struct drm_property * , uint64_t  ) ;
};
struct drm_crtc {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   struct drm_framebuffer *fb ;
   bool enabled ;
   struct drm_display_mode mode ;
   struct drm_display_mode hwmode ;
   bool invert_dimensions ;
   int x ;
   int y ;
   struct drm_crtc_funcs  const  *funcs ;
   uint32_t gamma_size ;
   uint16_t *gamma_store ;
   s64 framedur_ns ;
   s64 linedur_ns ;
   s64 pixeldur_ns ;
   void *helper_private ;
   struct drm_object_properties properties ;
};
struct drm_connector_funcs {
   void (*dpms)(struct drm_connector * , int  ) ;
   void (*save)(struct drm_connector * ) ;
   void (*restore)(struct drm_connector * ) ;
   void (*reset)(struct drm_connector * ) ;
   enum drm_connector_status (*detect)(struct drm_connector * , bool  ) ;
   int (*fill_modes)(struct drm_connector * , uint32_t  , uint32_t  ) ;
   int (*set_property)(struct drm_connector * , struct drm_property * , uint64_t  ) ;
   void (*destroy)(struct drm_connector * ) ;
   void (*force)(struct drm_connector * ) ;
};
struct drm_encoder_funcs {
   void (*reset)(struct drm_encoder * ) ;
   void (*destroy)(struct drm_encoder * ) ;
};
struct drm_encoder {
   struct drm_device *dev ;
   struct list_head head ;
   struct drm_mode_object base ;
   int encoder_type ;
   uint32_t possible_crtcs ;
   uint32_t possible_clones ;
   struct drm_crtc *crtc ;
   struct drm_encoder_funcs  const  *funcs ;
   void *helper_private ;
};
enum drm_connector_force {
    DRM_FORCE_UNSPECIFIED = 0,
    DRM_FORCE_OFF = 1,
    DRM_FORCE_ON = 2,
    DRM_FORCE_ON_DIGITAL = 3
} ;
struct drm_connector {
   struct drm_device *dev ;
   struct device kdev ;
   struct device_attribute *attr ;
   struct list_head head ;
   struct drm_mode_object base ;
   int connector_type ;
   int connector_type_id ;
   bool interlace_allowed ;
   bool doublescan_allowed ;
   struct list_head modes ;
   enum drm_connector_status status ;
   struct list_head probed_modes ;
   struct drm_display_info display_info ;
   struct drm_connector_funcs  const  *funcs ;
   struct list_head user_modes ;
   struct drm_property_blob *edid_blob_ptr ;
   struct drm_object_properties properties ;
   uint8_t polled ;
   int dpms ;
   void *helper_private ;
   enum drm_connector_force force ;
   uint32_t encoder_ids[3U] ;
   struct drm_encoder *encoder ;
   uint8_t eld[128U] ;
   bool dvi_dual ;
   int max_tmds_clock ;
   bool latency_present[2U] ;
   int video_latency[2U] ;
   int audio_latency[2U] ;
   int null_edid_counter ;
   unsigned int bad_edid_counter ;
};
struct drm_mode_set {
   struct drm_framebuffer *fb ;
   struct drm_crtc *crtc ;
   struct drm_display_mode *mode ;
   uint32_t x ;
   uint32_t y ;
   struct drm_connector **connectors ;
   size_t num_connectors ;
};
struct drm_mode_config_funcs {
   struct drm_framebuffer *(*fb_create)(struct drm_device * , struct drm_file * ,
                                        struct drm_mode_fb_cmd2 * ) ;
   void (*output_poll_changed)(struct drm_device * ) ;
};
struct drm_mode_group {
   uint32_t num_crtcs ;
   uint32_t num_encoders ;
   uint32_t num_connectors ;
   uint32_t *id_list ;
};
struct drm_mode_config {
   struct mutex mutex ;
   struct mutex idr_mutex ;
   struct idr crtc_idr ;
   int num_fb ;
   struct list_head fb_list ;
   int num_connector ;
   struct list_head connector_list ;
   int num_encoder ;
   struct list_head encoder_list ;
   int num_plane ;
   struct list_head plane_list ;
   int num_crtc ;
   struct list_head crtc_list ;
   struct list_head property_list ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   struct drm_mode_config_funcs  const  *funcs ;
   resource_size_t fb_base ;
   bool poll_enabled ;
   bool poll_running ;
   struct delayed_work output_poll_work ;
   struct list_head property_blob_list ;
   struct drm_property *edid_property ;
   struct drm_property *dpms_property ;
   struct drm_property *dvi_i_subconnector_property ;
   struct drm_property *dvi_i_select_subconnector_property ;
   struct drm_property *tv_subconnector_property ;
   struct drm_property *tv_select_subconnector_property ;
   struct drm_property *tv_mode_property ;
   struct drm_property *tv_left_margin_property ;
   struct drm_property *tv_right_margin_property ;
   struct drm_property *tv_top_margin_property ;
   struct drm_property *tv_bottom_margin_property ;
   struct drm_property *tv_brightness_property ;
   struct drm_property *tv_contrast_property ;
   struct drm_property *tv_flicker_reduction_property ;
   struct drm_property *tv_overscan_property ;
   struct drm_property *tv_saturation_property ;
   struct drm_property *tv_hue_property ;
   struct drm_property *scaling_mode_property ;
   struct drm_property *dithering_mode_property ;
   struct drm_property *dirty_info_property ;
   uint32_t preferred_depth ;
   uint32_t prefer_shadow ;
};
struct drm_master {
   struct kref refcount ;
   struct list_head head ;
   struct drm_minor *minor ;
   char *unique ;
   int unique_len ;
   int unique_size ;
   int blocked ;
   struct drm_open_hash magiclist ;
   struct list_head magicfree ;
   struct drm_lock_data lock ;
   void *driver_priv ;
};
struct drm_bus {
   int bus_type ;
   int (*get_irq)(struct drm_device * ) ;
   char const   *(*get_name)(struct drm_device * ) ;
   int (*set_busid)(struct drm_device * , struct drm_master * ) ;
   int (*set_unique)(struct drm_device * , struct drm_master * , struct drm_unique * ) ;
   int (*irq_by_busid)(struct drm_device * , struct drm_irq_busid * ) ;
   int (*agp_init)(struct drm_device * ) ;
};
struct usb_driver;
union __anonunion_kdriver_208 {
   struct pci_driver *pci ;
   struct platform_device *platform_device ;
   struct usb_driver *usb ;
};
struct drm_driver {
   int (*load)(struct drm_device * , unsigned long  ) ;
   int (*firstopen)(struct drm_device * ) ;
   int (*open)(struct drm_device * , struct drm_file * ) ;
   void (*preclose)(struct drm_device * , struct drm_file * ) ;
   void (*postclose)(struct drm_device * , struct drm_file * ) ;
   void (*lastclose)(struct drm_device * ) ;
   int (*unload)(struct drm_device * ) ;
   int (*suspend)(struct drm_device * , pm_message_t  ) ;
   int (*resume)(struct drm_device * ) ;
   int (*dma_ioctl)(struct drm_device * , void * , struct drm_file * ) ;
   int (*dma_quiescent)(struct drm_device * ) ;
   int (*context_dtor)(struct drm_device * , int  ) ;
   u32 (*get_vblank_counter)(struct drm_device * , int  ) ;
   int (*enable_vblank)(struct drm_device * , int  ) ;
   void (*disable_vblank)(struct drm_device * , int  ) ;
   int (*device_is_agp)(struct drm_device * ) ;
   int (*get_scanout_position)(struct drm_device * , int  , int * , int * ) ;
   int (*get_vblank_timestamp)(struct drm_device * , int  , int * , struct timeval * ,
                               unsigned int  ) ;
   irqreturn_t (*irq_handler)(int  , void * ) ;
   void (*irq_preinstall)(struct drm_device * ) ;
   int (*irq_postinstall)(struct drm_device * ) ;
   void (*irq_uninstall)(struct drm_device * ) ;
   void (*set_version)(struct drm_device * , struct drm_set_version * ) ;
   int (*master_create)(struct drm_device * , struct drm_master * ) ;
   void (*master_destroy)(struct drm_device * , struct drm_master * ) ;
   int (*master_set)(struct drm_device * , struct drm_file * , bool  ) ;
   void (*master_drop)(struct drm_device * , struct drm_file * , bool  ) ;
   int (*debugfs_init)(struct drm_minor * ) ;
   void (*debugfs_cleanup)(struct drm_minor * ) ;
   int (*gem_init_object)(struct drm_gem_object * ) ;
   void (*gem_free_object)(struct drm_gem_object * ) ;
   int (*gem_open_object)(struct drm_gem_object * , struct drm_file * ) ;
   void (*gem_close_object)(struct drm_gem_object * , struct drm_file * ) ;
   int (*prime_handle_to_fd)(struct drm_device * , struct drm_file * , uint32_t  ,
                             uint32_t  , int * ) ;
   int (*prime_fd_to_handle)(struct drm_device * , struct drm_file * , int  , uint32_t * ) ;
   struct dma_buf *(*gem_prime_export)(struct drm_device * , struct drm_gem_object * ,
                                       int  ) ;
   struct drm_gem_object *(*gem_prime_import)(struct drm_device * , struct dma_buf * ) ;
   void (*vgaarb_irq)(struct drm_device * , bool  ) ;
   int (*dumb_create)(struct drm_file * , struct drm_device * , struct drm_mode_create_dumb * ) ;
   int (*dumb_map_offset)(struct drm_file * , struct drm_device * , uint32_t  , uint64_t * ) ;
   int (*dumb_destroy)(struct drm_file * , struct drm_device * , uint32_t  ) ;
   struct vm_operations_struct  const  *gem_vm_ops ;
   int major ;
   int minor ;
   int patchlevel ;
   char *name ;
   char *desc ;
   char *date ;
   u32 driver_features ;
   int dev_priv_size ;
   struct drm_ioctl_desc *ioctls ;
   int num_ioctls ;
   struct file_operations  const  *fops ;
   union __anonunion_kdriver_208 kdriver ;
   struct drm_bus *bus ;
   struct list_head device_list ;
};
struct drm_info_list {
   char const   *name ;
   int (*show)(struct seq_file * , void * ) ;
   u32 driver_features ;
   void *data ;
};
struct drm_info_node {
   struct list_head list ;
   struct drm_minor *minor ;
   struct drm_info_list *info_ent ;
   struct dentry *dent ;
};
struct drm_minor {
   int index ;
   int type ;
   dev_t device ;
   struct device kdev ;
   struct drm_device *dev ;
   struct proc_dir_entry *proc_root ;
   struct drm_info_node proc_nodes ;
   struct dentry *debugfs_root ;
   struct list_head debugfs_list ;
   struct mutex debugfs_lock ;
   struct drm_master *master ;
   struct list_head master_list ;
   struct drm_mode_group mode_group ;
};
struct drm_cmdline_mode {
   bool specified ;
   bool refresh_specified ;
   bool bpp_specified ;
   int xres ;
   int yres ;
   int bpp ;
   int refresh ;
   bool rb ;
   bool interlace ;
   bool cvt ;
   bool margins ;
   enum drm_connector_force force ;
};
struct drm_pending_vblank_event {
   struct drm_pending_event base ;
   int pipe ;
   struct drm_event_vblank event ;
};
struct usb_device;
struct drm_device {
   struct list_head driver_item ;
   char *devname ;
   int if_version ;
   spinlock_t count_lock ;
   struct mutex struct_mutex ;
   int open_count ;
   atomic_t ioctl_count ;
   atomic_t vma_count ;
   int buf_use ;
   atomic_t buf_alloc ;
   unsigned long counters ;
   enum drm_stat_type types[15U] ;
   atomic_t counts[15U] ;
   struct list_head filelist ;
   struct list_head maplist ;
   int map_count ;
   struct drm_open_hash map_hash ;
   struct list_head ctxlist ;
   int ctx_count ;
   struct mutex ctxlist_mutex ;
   struct idr ctx_idr ;
   struct list_head vmalist ;
   struct drm_device_dma *dma ;
   int irq_enabled ;
   long volatile   context_flag ;
   long volatile   interrupt_flag ;
   long volatile   dma_flag ;
   wait_queue_head_t context_wait ;
   int last_checked ;
   int last_context ;
   unsigned long last_switch ;
   struct work_struct work ;
   int vblank_disable_allowed ;
   wait_queue_head_t *vbl_queue ;
   atomic_t *_vblank_count ;
   struct timeval *_vblank_time ;
   spinlock_t vblank_time_lock ;
   spinlock_t vbl_lock ;
   atomic_t *vblank_refcount ;
   u32 *last_vblank ;
   int *vblank_enabled ;
   int *vblank_inmodeset ;
   u32 *last_vblank_wait ;
   struct timer_list vblank_disable_timer ;
   u32 max_vblank_count ;
   struct list_head vblank_event_list ;
   spinlock_t event_lock ;
   cycles_t ctx_start ;
   cycles_t lck_start ;
   struct fasync_struct *buf_async ;
   wait_queue_head_t buf_readers ;
   wait_queue_head_t buf_writers ;
   struct drm_agp_head *agp ;
   struct device *dev ;
   struct pci_dev *pdev ;
   int pci_vendor ;
   int pci_device ;
   struct platform_device *platformdev ;
   struct usb_device *usbdev ;
   struct drm_sg_mem *sg ;
   unsigned int num_crtcs ;
   void *dev_private ;
   void *mm_private ;
   struct address_space *dev_mapping ;
   struct drm_sigdata sigdata ;
   sigset_t sigmask ;
   struct drm_driver *driver ;
   struct drm_local_map *agp_buffer_map ;
   unsigned int agp_buffer_token ;
   struct drm_minor *control ;
   struct drm_minor *primary ;
   struct drm_mode_config mode_config ;
   spinlock_t object_name_lock ;
   struct idr object_name_idr ;
   int switch_power_state ;
   atomic_t unplugged ;
};
struct i2c_algo_bit_data {
   void *data ;
   void (*setsda)(void * , int  ) ;
   void (*setscl)(void * , int  ) ;
   int (*getsda)(void * ) ;
   int (*getscl)(void * ) ;
   int (*pre_xfer)(struct i2c_adapter * ) ;
   void (*post_xfer)(struct i2c_adapter * ) ;
   int udelay ;
   int timeout ;
};
enum mode_set_atomic {
    LEAVE_ATOMIC_MODE_SET = 0,
    ENTER_ATOMIC_MODE_SET = 1
} ;
struct drm_crtc_helper_funcs {
   void (*dpms)(struct drm_crtc * , int  ) ;
   void (*prepare)(struct drm_crtc * ) ;
   void (*commit)(struct drm_crtc * ) ;
   bool (*mode_fixup)(struct drm_crtc * , struct drm_display_mode  const  * , struct drm_display_mode * ) ;
   int (*mode_set)(struct drm_crtc * , struct drm_display_mode * , struct drm_display_mode * ,
                   int  , int  , struct drm_framebuffer * ) ;
   int (*mode_set_base)(struct drm_crtc * , int  , int  , struct drm_framebuffer * ) ;
   int (*mode_set_base_atomic)(struct drm_crtc * , struct drm_framebuffer * , int  ,
                               int  , enum mode_set_atomic  ) ;
   void (*load_lut)(struct drm_crtc * ) ;
   void (*disable)(struct drm_crtc * ) ;
};
struct psb_intel_mode_device {
   size_t (*bo_offset)(struct drm_device * , void * ) ;
   int backlight_duty_cycle ;
   bool panel_wants_dither ;
   struct drm_display_mode *panel_fixed_mode ;
   struct drm_display_mode *panel_fixed_mode2 ;
   struct drm_display_mode *vbt_mode ;
   uint32_t saveBLC_PWM_CTL ;
};
struct psb_intel_i2c_chan {
   struct drm_device *drm_dev ;
   u32 reg ;
   struct i2c_adapter adapter ;
   struct i2c_algo_bit_data algo ;
   u8 slave_addr ;
};
struct gtt_range;
struct child_device_config {
   u16 handle ;
   u16 device_type ;
   u8 device_id[10U] ;
   u16 addin_offset ;
   u8 dvo_port ;
   u8 i2c_pin ;
   u8 slave_addr ;
   u8 ddc_pin ;
   u16 edid_ptr ;
   u8 dvo_cfg ;
   u8 dvo2_port ;
   u8 i2c2_pin ;
   u8 slave2_addr ;
   u8 ddc2_pin ;
   u8 capabilities ;
   u8 dvo_wiring ;
   u8 dvo2_wiring ;
   u16 extended_type ;
   u8 dvo_function ;
};
struct bdb_lvds_backlight {
   unsigned char type : 2 ;
   unsigned char pol : 1 ;
   unsigned char gpio : 3 ;
   unsigned char gmbus : 2 ;
   u16 freq ;
   u8 minbrightness ;
   u8 i2caddr ;
   u8 brightnesscmd ;
};
struct edp_power_seq {
   u16 t1_t3 ;
   u16 t8 ;
   u16 t9 ;
   u16 t10 ;
   u16 t11_t12 ;
};
struct psb_gtt {
   uint32_t gatt_start ;
   uint32_t mmu_gatt_start ;
   uint32_t gtt_start ;
   uint32_t gtt_phys_start ;
   unsigned int gtt_pages ;
   unsigned int gatt_pages ;
   unsigned long stolen_size ;
   unsigned long vram_stolen_size ;
   struct rw_semaphore sem ;
};
struct gtt_range {
   struct resource resource ;
   u32 offset ;
   struct drm_gem_object gem ;
   int in_gart ;
   bool stolen ;
   bool mmapping ;
   struct page **pages ;
   int npage ;
   int roll ;
};
struct oaktrail_timing_info {
   u16 pixel_clock ;
   u8 hactive_lo ;
   u8 hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hactive_hi : 4 ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vactive_hi : 4 ;
   u8 hsync_offset_lo ;
   u8 hsync_pulse_width_lo ;
   unsigned char vsync_pulse_width_lo : 4 ;
   unsigned char vsync_offset_lo : 4 ;
   unsigned char vsync_pulse_width_hi : 2 ;
   unsigned char vsync_offset_hi : 2 ;
   unsigned char hsync_pulse_width_hi : 2 ;
   unsigned char hsync_offset_hi : 2 ;
   u8 width_mm_lo ;
   u8 height_mm_lo ;
   unsigned char height_mm_hi : 4 ;
   unsigned char width_mm_hi : 4 ;
   u8 hborder ;
   u8 vborder ;
   unsigned char unknown0 : 1 ;
   unsigned char hsync_positive : 1 ;
   unsigned char vsync_positive : 1 ;
   unsigned char separate_sync : 2 ;
   unsigned char stereo : 1 ;
   unsigned char unknown6 : 1 ;
   unsigned char interlaced : 1 ;
};
struct oaktrail_gct_data {
   u8 bpi ;
   u8 pt ;
   struct oaktrail_timing_info DTD ;
   u32 Panel_Port_Control ;
   u32 PP_On_Sequencing ;
   u32 PP_Off_Sequencing ;
   u32 PP_Cycle_Delay ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u16 Panel_MIPI_Display_Descriptor ;
};
struct hdmi_i2c_dev;
struct oaktrail_hdmi_dev {
   struct pci_dev *dev ;
   void *regs ;
   unsigned int mmio ;
   unsigned int mmio_len ;
   int dpms_mode ;
   struct hdmi_i2c_dev *i2c_dev ;
   u32 saveDPLL_CTRL ;
   u32 saveDPLL_DIV_CTRL ;
   u32 saveDPLL_ADJUST ;
   u32 saveDPLL_UPDATE ;
   u32 saveDPLL_CLK_ENABLE ;
   u32 savePCH_HTOTAL_B ;
   u32 savePCH_HBLANK_B ;
   u32 savePCH_HSYNC_B ;
   u32 savePCH_VTOTAL_B ;
   u32 savePCH_VBLANK_B ;
   u32 savePCH_VSYNC_B ;
   u32 savePCH_PIPEBCONF ;
   u32 savePCH_PIPEBSRC ;
};
struct opregion_header;
struct opregion_acpi;
struct opregion_swsci;
struct opregion_asle;
struct psb_intel_opregion {
   struct opregion_header *header ;
   struct opregion_acpi *acpi ;
   struct opregion_swsci *swsci ;
   struct opregion_asle *asle ;
   void *vbt ;
   u32 *lid_state ;
};
struct sdvo_device_mapping {
   u8 initialized ;
   u8 dvo_port ;
   u8 slave_addr ;
   u8 dvo_wiring ;
   u8 i2c_pin ;
   u8 i2c_speed ;
   u8 ddc_pin ;
};
struct intel_gmbus {
   struct i2c_adapter adapter ;
   struct i2c_adapter *force_bit ;
   u32 reg0 ;
};
struct psb_offset {
   u32 fp0 ;
   u32 fp1 ;
   u32 cntr ;
   u32 conf ;
   u32 src ;
   u32 dpll ;
   u32 dpll_md ;
   u32 htotal ;
   u32 hblank ;
   u32 hsync ;
   u32 vtotal ;
   u32 vblank ;
   u32 vsync ;
   u32 stride ;
   u32 size ;
   u32 pos ;
   u32 surf ;
   u32 addr ;
   u32 base ;
   u32 status ;
   u32 linoff ;
   u32 tileoff ;
   u32 palette ;
};
struct psb_pipe {
   u32 fp0 ;
   u32 fp1 ;
   u32 cntr ;
   u32 conf ;
   u32 src ;
   u32 dpll ;
   u32 dpll_md ;
   u32 htotal ;
   u32 hblank ;
   u32 hsync ;
   u32 vtotal ;
   u32 vblank ;
   u32 vsync ;
   u32 stride ;
   u32 size ;
   u32 pos ;
   u32 base ;
   u32 surf ;
   u32 addr ;
   u32 status ;
   u32 linoff ;
   u32 tileoff ;
   u32 palette[256U] ;
};
struct psb_state {
   uint32_t saveVCLK_DIVISOR_VGA0 ;
   uint32_t saveVCLK_DIVISOR_VGA1 ;
   uint32_t saveVCLK_POST_DIV ;
   uint32_t saveVGACNTRL ;
   uint32_t saveADPA ;
   uint32_t saveLVDS ;
   uint32_t saveDVOA ;
   uint32_t saveDVOB ;
   uint32_t saveDVOC ;
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t saveCLOCKGATING ;
   uint32_t saveDSPARB ;
   uint32_t savePFIT_AUTO_RATIOS ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t savePP_ON_DELAYS ;
   uint32_t savePP_OFF_DELAYS ;
   uint32_t savePP_DIVISOR ;
   uint32_t saveBCLRPAT_A ;
   uint32_t saveBCLRPAT_B ;
   uint32_t savePERF_MODE ;
   uint32_t saveDSPFW1 ;
   uint32_t saveDSPFW2 ;
   uint32_t saveDSPFW3 ;
   uint32_t saveDSPFW4 ;
   uint32_t saveDSPFW5 ;
   uint32_t saveDSPFW6 ;
   uint32_t saveCHICKENBIT ;
   uint32_t saveDSPACURSOR_CTRL ;
   uint32_t saveDSPBCURSOR_CTRL ;
   uint32_t saveDSPACURSOR_BASE ;
   uint32_t saveDSPBCURSOR_BASE ;
   uint32_t saveDSPACURSOR_POS ;
   uint32_t saveDSPBCURSOR_POS ;
   uint32_t saveOV_OVADD ;
   uint32_t saveOV_OGAMC0 ;
   uint32_t saveOV_OGAMC1 ;
   uint32_t saveOV_OGAMC2 ;
   uint32_t saveOV_OGAMC3 ;
   uint32_t saveOV_OGAMC4 ;
   uint32_t saveOV_OGAMC5 ;
   uint32_t saveOVC_OVADD ;
   uint32_t saveOVC_OGAMC0 ;
   uint32_t saveOVC_OGAMC1 ;
   uint32_t saveOVC_OGAMC2 ;
   uint32_t saveOVC_OGAMC3 ;
   uint32_t saveOVC_OGAMC4 ;
   uint32_t saveOVC_OGAMC5 ;
   uint32_t saveHISTOGRAM_INT_CONTROL_REG ;
   uint32_t saveHISTOGRAM_LOGIC_CONTROL_REG ;
   uint32_t savePWM_CONTROL_LOGIC ;
};
struct medfield_state {
   uint32_t saveMIPI ;
   uint32_t saveMIPI_C ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveHDMIPHYMISCCTL ;
   uint32_t saveHDMIB_CONTROL ;
};
struct cdv_state {
   uint32_t saveDSPCLK_GATE_D ;
   uint32_t saveRAMCLK_GATE_D ;
   uint32_t saveDSPARB ;
   uint32_t saveDSPFW[6U] ;
   uint32_t saveADPA ;
   uint32_t savePP_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveLVDS ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePP_ON_DELAYS ;
   uint32_t savePP_OFF_DELAYS ;
   uint32_t savePP_CYCLE ;
   uint32_t saveVGACNTRL ;
   uint32_t saveIER ;
   uint32_t saveIMR ;
   u8 saveLBB ;
};
union __anonunion_ldv_38617_214 {
   struct psb_state psb ;
   struct medfield_state mdfld ;
   struct cdv_state cdv ;
};
struct psb_save_area {
   struct psb_pipe pipe[3U] ;
   uint32_t saveBSM ;
   uint32_t saveVBT ;
   union __anonunion_ldv_38617_214 ldv_38617 ;
   uint32_t saveBLC_PWM_CTL2 ;
   uint32_t saveBLC_PWM_CTL ;
};
struct psb_ops;
struct psb_gtt_mm;
struct psb_mmu_driver;
struct psb_mmu_pd;
struct __anonstruct_edp_215 {
   int rate ;
   int lanes ;
   int preemphasis ;
   int vswing ;
   bool initialized ;
   bool support ;
   int bpp ;
   struct edp_power_seq pps ;
};
struct drm_psb_private {
   struct drm_device *dev ;
   struct psb_ops  const  *ops ;
   struct psb_offset  const  *regmap ;
   struct child_device_config *child_dev ;
   int child_dev_num ;
   struct psb_gtt gtt ;
   struct psb_gtt_mm *gtt_mm ;
   struct page *scratch_page ;
   u32 *gtt_map ;
   uint32_t stolen_base ;
   u8 *vram_addr ;
   unsigned long vram_stolen_size ;
   int gtt_initialized ;
   u16 gmch_ctrl ;
   u32 pge_ctl ;
   struct mutex gtt_mutex ;
   struct resource *gtt_mem ;
   struct psb_mmu_driver *mmu ;
   struct psb_mmu_pd *pf_pd ;
   uint8_t *sgx_reg ;
   uint8_t *vdc_reg ;
   uint32_t gatt_free_offset ;
   uint32_t vdc_irq_mask ;
   uint32_t pipestat[3U] ;
   spinlock_t irqmask_lock ;
   bool suspended ;
   bool display_power ;
   int display_count ;
   struct psb_intel_mode_device mode_dev ;
   bool modeset ;
   struct drm_crtc *plane_to_crtc_mapping[3U] ;
   struct drm_crtc *pipe_to_crtc_mapping[3U] ;
   uint32_t num_pipe ;
   uint32_t ospm_base ;
   u32 fuse_reg_value ;
   u32 video_device_fuse ;
   uint8_t platform_rev_id ;
   struct intel_gmbus *gmbus ;
   int crt_ddc_pin ;
   struct sdvo_device_mapping sdvo_mappings[2U] ;
   u32 hotplug_supported_mask ;
   struct drm_property *broadcast_rgb_property ;
   struct drm_property *force_audio_property ;
   int backlight_duty_cycle ;
   bool panel_wants_dither ;
   struct drm_display_mode *panel_fixed_mode ;
   struct drm_display_mode *lfp_lvds_vbt_mode ;
   struct drm_display_mode *sdvo_lvds_vbt_mode ;
   struct bdb_lvds_backlight *lvds_bl ;
   struct psb_intel_i2c_chan *lvds_i2c_bus ;
   unsigned char int_tv_support : 1 ;
   unsigned char lvds_dither : 1 ;
   unsigned char lvds_vbt : 1 ;
   unsigned char int_crt_support : 1 ;
   unsigned char lvds_use_ssc : 1 ;
   int lvds_ssc_freq ;
   bool is_lvds_on ;
   bool is_mipi_on ;
   u32 mipi_ctrl_display ;
   unsigned int core_freq ;
   uint32_t iLVDS_enable ;
   int rpm_enabled ;
   bool has_gct ;
   struct oaktrail_gct_data gct_data ;
   struct oaktrail_hdmi_dev *hdmi_priv ;
   struct psb_save_area regs ;
   uint32_t msi_addr ;
   uint32_t msi_data ;
   struct work_struct hotplug_work ;
   spinlock_t lid_lock ;
   struct timer_list lid_timer ;
   struct psb_intel_opregion opregion ;
   u32 lid_last_state ;
   uint32_t apm_reg ;
   uint16_t apm_base ;
   struct backlight_device *backlight_device ;
   struct drm_property *backlight_property ;
   bool backlight_enabled ;
   int backlight_level ;
   uint32_t blc_adj1 ;
   uint32_t blc_adj2 ;
   void *fbdev ;
   spinlock_t lock_2d ;
   int brightness ;
   int brightness_adjusted ;
   bool dsr_enable ;
   u32 dsr_fb_update ;
   bool dpi_panel_on[3U] ;
   void *dsi_configs[2U] ;
   u32 bpp ;
   u32 bpp2 ;
   u32 pipeconf[3U] ;
   u32 dspcntr[3U] ;
   int mdfld_panel_id ;
   bool dplla_96mhz ;
   struct __anonstruct_edp_215 edp ;
   uint8_t panel_type ;
};
struct psb_ops {
   char const   *name ;
   unsigned char accel_2d : 1 ;
   int pipes ;
   int crtcs ;
   int sgx_offset ;
   int hdmi_mask ;
   int lvds_mask ;
   int cursor_needs_phys ;
   struct drm_crtc_helper_funcs  const  *crtc_helper ;
   struct drm_crtc_funcs  const  *crtc_funcs ;
   int (*chip_setup)(struct drm_device * ) ;
   void (*chip_teardown)(struct drm_device * ) ;
   void (*errata)(struct drm_device * ) ;
   int (*output_init)(struct drm_device * ) ;
   int (*hotplug)(struct drm_device * ) ;
   void (*hotplug_enable)(struct drm_device * , bool  ) ;
   void (*init_pm)(struct drm_device * ) ;
   int (*save_regs)(struct drm_device * ) ;
   int (*restore_regs)(struct drm_device * ) ;
   int (*power_up)(struct drm_device * ) ;
   int (*power_down)(struct drm_device * ) ;
   void (*lvds_bl_power)(struct drm_device * , bool  ) ;
   int i2c_bus ;
};
struct drm_fb_helper;
struct drm_fb_helper_crtc {
   struct drm_mode_set mode_set ;
   struct drm_display_mode *desired_mode ;
};
struct drm_fb_helper_surface_size {
   u32 fb_width ;
   u32 fb_height ;
   u32 surface_width ;
   u32 surface_height ;
   u32 surface_bpp ;
   u32 surface_depth ;
};
struct drm_fb_helper_funcs {
   void (*gamma_set)(struct drm_crtc * , u16  , u16  , u16  , int  ) ;
   void (*gamma_get)(struct drm_crtc * , u16 * , u16 * , u16 * , int  ) ;
   int (*fb_probe)(struct drm_fb_helper * , struct drm_fb_helper_surface_size * ) ;
};
struct drm_fb_helper_connector {
   struct drm_connector *connector ;
   struct drm_cmdline_mode cmdline_mode ;
};
struct drm_fb_helper {
   struct drm_framebuffer *fb ;
   struct drm_framebuffer *saved_fb ;
   struct drm_device *dev ;
   struct drm_display_mode *mode ;
   int crtc_count ;
   struct drm_fb_helper_crtc *crtc_info ;
   int connector_count ;
   struct drm_fb_helper_connector **connector_info ;
   struct drm_fb_helper_funcs *funcs ;
   struct fb_info *fbdev ;
   u32 pseudo_palette[17U] ;
   struct list_head kernel_fb_list ;
   bool delayed_hotplug ;
};
struct psb_framebuffer {
   struct drm_framebuffer base ;
   struct address_space *addr_space ;
   struct fb_info *fbdev ;
   struct gtt_range *gtt ;
};
struct psb_fbdev {
   struct drm_fb_helper psb_fb_helper ;
   struct psb_framebuffer pfb ;
};
typedef int ldv_func_ret_type___2;
enum hrtimer_restart;
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
struct cpuinfo_x86;
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   int x86_tlbsize ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[10U] ;
   char x86_vendor_id[16U] ;
   char x86_model_id[64U] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u8 compute_unit_id ;
   u16 cpu_index ;
   u32 microcode ;
};
enum hrtimer_restart;
struct psb_intel_encoder {
   struct drm_encoder base ;
   int type ;
   bool needs_tv_clock ;
   void (*hot_plug)(struct psb_intel_encoder * ) ;
   int crtc_mask ;
   int clone_mask ;
   u32 ddi_select ;
   void *dev_priv ;
   struct psb_intel_i2c_chan *i2c_bus ;
   struct psb_intel_i2c_chan *ddc_bus ;
};
struct psb_intel_connector {
   struct drm_connector base ;
   struct psb_intel_encoder *encoder ;
};
struct psb_intel_crtc_state {
   uint32_t saveDSPCNTR ;
   uint32_t savePIPECONF ;
   uint32_t savePIPESRC ;
   uint32_t saveDPLL ;
   uint32_t saveFP0 ;
   uint32_t saveFP1 ;
   uint32_t saveHTOTAL ;
   uint32_t saveHBLANK ;
   uint32_t saveHSYNC ;
   uint32_t saveVTOTAL ;
   uint32_t saveVBLANK ;
   uint32_t saveVSYNC ;
   uint32_t saveDSPSTRIDE ;
   uint32_t saveDSPSIZE ;
   uint32_t saveDSPPOS ;
   uint32_t saveDSPBASE ;
   uint32_t savePalette[256U] ;
};
struct psb_intel_framebuffer;
struct psb_intel_crtc {
   struct drm_crtc base ;
   int pipe ;
   int plane ;
   uint32_t cursor_addr ;
   struct gtt_range *cursor_gt ;
   u8 lut_r[256U] ;
   u8 lut_g[256U] ;
   u8 lut_b[256U] ;
   u8 lut_adj[256U] ;
   struct psb_intel_framebuffer *fbdev_fb ;
   struct drm_mode_set mode_set ;
   struct drm_gem_object *cursor_obj ;
   struct drm_display_mode saved_mode ;
   struct drm_display_mode saved_adjusted_mode ;
   struct psb_intel_mode_device *mode_dev ;
   u32 mode_flags ;
   bool active ;
   struct psb_intel_crtc_state *crtc_state ;
};
enum hrtimer_restart;
struct drm_psb_gem_create {
   __u64 size ;
   __u32 handle ;
   __u32 flags ;
};
struct drm_psb_gem_mmap {
   __u32 handle ;
   __u32 pad ;
   __u64 offset ;
};
enum hrtimer_restart;
struct cgroup_subsys_state;
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
struct simple_xattrs {
   struct list_head head ;
   spinlock_t lock ;
};
struct cgroupfs_root;
struct cgroup;
struct css_id;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
   struct work_struct dput_work ;
};
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   int id ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroupfs_root *root ;
   struct cgroup *top_cgroup ;
   struct list_head css_sets ;
   struct list_head allcg_node ;
   struct list_head cft_q_node ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct callback_head callback_head ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
   struct simple_xattrs xattrs ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct callback_head callback_head ;
};
struct reclaim_state {
   unsigned long reclaimed_slab ;
};
struct swap_extent {
   struct list_head list ;
   unsigned long start_page ;
   unsigned long nr_pages ;
   sector_t start_block ;
};
struct swap_info_struct {
   unsigned long flags ;
   short prio ;
   signed char type ;
   signed char next ;
   unsigned int max ;
   unsigned char *swap_map ;
   unsigned int lowest_bit ;
   unsigned int highest_bit ;
   unsigned int pages ;
   unsigned int inuse_pages ;
   unsigned int cluster_next ;
   unsigned int cluster_nr ;
   unsigned int lowest_alloc ;
   unsigned int highest_alloc ;
   struct swap_extent *curr_swap_extent ;
   struct swap_extent first_swap_extent ;
   struct block_device *bdev ;
   struct file *swap_file ;
   unsigned int old_block_size ;
   unsigned long *frontswap_map ;
   atomic_t frontswap_pages ;
};
union __anonunion_v_207 {
   short preferred_node ;
   nodemask_t nodes ;
};
union __anonunion_w_208 {
   nodemask_t cpuset_mems_allowed ;
   nodemask_t user_nodemask ;
};
struct mempolicy {
   atomic_t refcnt ;
   unsigned short mode ;
   unsigned short flags ;
   union __anonunion_v_207 v ;
   union __anonunion_w_208 w ;
};
enum hrtimer_restart;
struct vbt_header {
   u8 signature[20U] ;
   u16 version ;
   u16 header_size ;
   u16 vbt_size ;
   u8 vbt_checksum ;
   u8 reserved0 ;
   u32 bdb_offset ;
   u32 aim_offset[4U] ;
};
struct bdb_header {
   u8 signature[16U] ;
   u16 version ;
   u16 header_size ;
   u16 bdb_size ;
};
struct bdb_general_features {
   unsigned char panel_fitting : 2 ;
   unsigned char flexaim : 1 ;
   unsigned char msg_enable : 1 ;
   unsigned char clear_screen : 3 ;
   unsigned char color_flip : 1 ;
   unsigned char download_ext_vbt : 1 ;
   unsigned char enable_ssc : 1 ;
   unsigned char ssc_freq : 1 ;
   unsigned char enable_lfp_on_override : 1 ;
   unsigned char disable_ssc_ddt : 1 ;
   unsigned char rsvd8 : 3 ;
   unsigned char disable_smooth_vision : 1 ;
   unsigned char single_dvi : 1 ;
   unsigned char rsvd9 : 6 ;
   u8 legacy_monitor_detect ;
   unsigned char int_crt_support : 1 ;
   unsigned char int_tv_support : 1 ;
   unsigned char int_efp_support : 1 ;
   unsigned char dp_ssc_enb : 1 ;
   unsigned char dp_ssc_freq : 1 ;
   unsigned char rsvd11 : 3 ;
};
struct bdb_general_definitions {
   u8 crt_ddc_gmbus_pin ;
   unsigned char dpms_acpi : 1 ;
   unsigned char skip_boot_crt_detect : 1 ;
   unsigned char dpms_aim : 1 ;
   unsigned char rsvd1 : 5 ;
   u8 boot_display[2U] ;
   u8 child_dev_size ;
   struct child_device_config devices[0U] ;
};
struct bdb_lvds_options {
   u8 panel_type ;
   u8 rsvd1 ;
   unsigned char pfit_mode : 2 ;
   unsigned char pfit_text_mode_enhanced : 1 ;
   unsigned char pfit_gfx_mode_enhanced : 1 ;
   unsigned char pfit_ratio_auto : 1 ;
   unsigned char pixel_dither : 1 ;
   unsigned char lvds_edid : 1 ;
   unsigned char rsvd2 : 1 ;
   u8 rsvd4 ;
};
struct lvds_fp_timing {
   u16 x_res ;
   u16 y_res ;
   u32 lvds_reg ;
   u32 lvds_reg_val ;
   u32 pp_on_reg ;
   u32 pp_on_reg_val ;
   u32 pp_off_reg ;
   u32 pp_off_reg_val ;
   u32 pp_cycle_reg ;
   u32 pp_cycle_reg_val ;
   u32 pfit_reg ;
   u32 pfit_reg_val ;
   u16 terminator ;
};
struct lvds_dvo_timing {
   u16 clock ;
   u8 hactive_lo ;
   u8 hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hactive_hi : 4 ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vactive_hi : 4 ;
   u8 hsync_off_lo ;
   u8 hsync_pulse_width ;
   unsigned char vsync_pulse_width : 4 ;
   unsigned char vsync_off : 4 ;
   unsigned char rsvd0 : 6 ;
   unsigned char hsync_off_hi : 2 ;
   u8 h_image ;
   u8 v_image ;
   u8 max_hv ;
   u8 h_border ;
   u8 v_border ;
   unsigned char rsvd1 : 3 ;
   unsigned char digital : 2 ;
   unsigned char vsync_positive : 1 ;
   unsigned char hsync_positive : 1 ;
   unsigned char rsvd2 : 1 ;
};
struct lvds_pnp_id {
   u16 mfg_name ;
   u16 product_code ;
   u32 serial ;
   u8 mfg_week ;
   u8 mfg_year ;
};
struct bdb_lvds_lfp_data_entry {
   struct lvds_fp_timing fp_timing ;
   struct lvds_dvo_timing dvo_timing ;
   struct lvds_pnp_id pnp_id ;
};
struct bdb_lvds_lfp_data {
   struct bdb_lvds_lfp_data_entry data[16U] ;
};
struct bdb_sdvo_lvds_options {
   u8 panel_backlight ;
   u8 h40_set_panel_type ;
   u8 panel_type ;
   u8 ssc_clk_freq ;
   u16 als_low_trip ;
   u16 als_high_trip ;
   u8 sclalarcoeff_tab_row_num ;
   u8 sclalarcoeff_tab_row_size ;
   u8 coefficient[8U] ;
   u8 panel_misc_bits_1 ;
   u8 panel_misc_bits_2 ;
   u8 panel_misc_bits_3 ;
   u8 panel_misc_bits_4 ;
};
struct bdb_driver_features {
   unsigned char boot_dev_algorithm : 1 ;
   unsigned char block_display_switch : 1 ;
   unsigned char allow_display_switch : 1 ;
   unsigned char hotplug_dvo : 1 ;
   unsigned char dual_view_zoom : 1 ;
   unsigned char int15h_hook : 1 ;
   unsigned char sprite_in_clone : 1 ;
   unsigned char primary_lfp_id : 1 ;
   u16 boot_mode_x ;
   u16 boot_mode_y ;
   u8 boot_mode_bpp ;
   u8 boot_mode_refresh ;
   unsigned char enable_lfp_primary : 1 ;
   unsigned char selective_mode_pruning : 1 ;
   unsigned char dual_frequency : 1 ;
   unsigned char render_clock_freq : 1 ;
   unsigned char nt_clone_support : 1 ;
   unsigned char power_scheme_ui : 1 ;
   unsigned char sprite_display_assign : 1 ;
   unsigned char cui_aspect_scaling : 1 ;
   unsigned char preserve_aspect_ratio : 1 ;
   unsigned char sdvo_device_power_down : 1 ;
   unsigned char crt_hotplug : 1 ;
   unsigned char lvds_config : 2 ;
   unsigned char tv_hotplug : 1 ;
   unsigned char hdmi_config : 2 ;
   unsigned char static_display : 1 ;
   unsigned char reserved2 : 7 ;
   u16 legacy_crt_max_x ;
   u16 legacy_crt_max_y ;
   u8 legacy_crt_max_refresh ;
   u8 hdmi_termination ;
   u8 custom_vbt_version ;
};
struct edp_link_params {
   unsigned char rate : 4 ;
   unsigned char lanes : 4 ;
   unsigned char preemphasis : 4 ;
   unsigned char vswing : 4 ;
};
struct bdb_edp {
   struct edp_power_seq power_seqs[16U] ;
   u32 color_depth ;
   u32 sdrrs_msa_timing_delay ;
   struct edp_link_params link_params[16U] ;
};
enum hrtimer_restart;
struct exec_domain;
struct map_segment;
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
struct compat_timespec;
struct __anonstruct_futex_32 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
struct __anonstruct_nanosleep_33 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_34 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
union __anonunion_ldv_6359_31 {
   struct __anonstruct_futex_32 futex ;
   struct __anonstruct_nanosleep_33 nanosleep ;
   struct __anonstruct_poll_34 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion_ldv_6359_31 ldv_6359 ;
};
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
enum hrtimer_restart;
typedef s32 compat_time_t;
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
struct intel_gpio {
   struct i2c_adapter adapter ;
   struct i2c_algo_bit_data algo ;
   struct drm_psb_private *dev_priv ;
   u32 reg ;
};
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned char ist : 3 ;
   unsigned char zero0 : 5 ;
   unsigned char type : 5 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
};
typedef struct gate_struct64 gate_desc;
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
};
struct tss_struct;
struct pv_cpu_ops {
   unsigned long (*get_debugreg)(int  ) ;
   void (*set_debugreg)(int  , unsigned long  ) ;
   void (*clts)(void) ;
   unsigned long (*read_cr0)(void) ;
   void (*write_cr0)(unsigned long  ) ;
   unsigned long (*read_cr4_safe)(void) ;
   unsigned long (*read_cr4)(void) ;
   void (*write_cr4)(unsigned long  ) ;
   unsigned long (*read_cr8)(void) ;
   void (*write_cr8)(unsigned long  ) ;
   void (*load_tr_desc)(void) ;
   void (*load_gdt)(struct desc_ptr  const  * ) ;
   void (*load_idt)(struct desc_ptr  const  * ) ;
   void (*store_gdt)(struct desc_ptr * ) ;
   void (*store_idt)(struct desc_ptr * ) ;
   void (*set_ldt)(void const   * , unsigned int  ) ;
   unsigned long (*store_tr)(void) ;
   void (*load_tls)(struct thread_struct * , unsigned int  ) ;
   void (*load_gs_index)(unsigned int  ) ;
   void (*write_ldt_entry)(struct desc_struct * , int  , void const   * ) ;
   void (*write_gdt_entry)(struct desc_struct * , int  , void const   * , int  ) ;
   void (*write_idt_entry)(gate_desc * , int  , gate_desc const   * ) ;
   void (*alloc_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*free_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*load_sp0)(struct tss_struct * , struct thread_struct * ) ;
   void (*set_iopl_mask)(unsigned int  ) ;
   void (*wbinvd)(void) ;
   void (*io_delay)(void) ;
   void (*cpuid)(unsigned int * , unsigned int * , unsigned int * , unsigned int * ) ;
   u64 (*read_msr)(unsigned int  , int * ) ;
   int (*write_msr)(unsigned int  , unsigned int  , unsigned int  ) ;
   u64 (*read_tsc)(void) ;
   u64 (*read_pmc)(int  ) ;
   unsigned long long (*read_tscp)(unsigned int * ) ;
   void (*irq_enable_sysexit)(void) ;
   void (*usergs_sysret64)(void) ;
   void (*usergs_sysret32)(void) ;
   void (*iret)(void) ;
   void (*swapgs)(void) ;
   void (*start_context_switch)(struct task_struct * ) ;
   void (*end_context_switch)(struct task_struct * ) ;
};
struct x86_hw_tss {
   u32 reserved1 ;
   u64 sp0 ;
   u64 sp1 ;
   u64 sp2 ;
   u64 reserved2 ;
   u64 ist[7U] ;
   u32 reserved3 ;
   u32 reserved4 ;
   u16 reserved5 ;
   u16 io_bitmap_base ;
};
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[1025U] ;
   unsigned long stack[64U] ;
};
enum hrtimer_restart;
struct psb_mmu_driver {
   struct rw_semaphore sem ;
   spinlock_t lock ;
   atomic_t needs_tlbflush ;
   uint8_t *register_map ;
   struct psb_mmu_pd *default_pd ;
   int has_clflush ;
   int clflush_add ;
   unsigned long clflush_mask ;
   struct drm_psb_private *dev_priv ;
};
struct psb_mmu_pt {
   struct psb_mmu_pd *pd ;
   uint32_t index ;
   uint32_t count ;
   struct page *p ;
   uint32_t *v ;
};
struct psb_mmu_pd {
   struct psb_mmu_driver *driver ;
   int hw_context ;
   struct psb_mmu_pt **tables ;
   struct page *p ;
   struct page *dummy_pt ;
   struct page *dummy_page ;
   uint32_t pd_mask ;
   uint32_t invalid_pde ;
   uint32_t invalid_pte ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct drm_mode_modeinfo {
   __u32 clock ;
   __u16 hdisplay ;
   __u16 hsync_start ;
   __u16 hsync_end ;
   __u16 htotal ;
   __u16 hskew ;
   __u16 vdisplay ;
   __u16 vsync_start ;
   __u16 vsync_end ;
   __u16 vtotal ;
   __u16 vscan ;
   __u32 vrefresh ;
   __u32 flags ;
   __u32 type ;
   char name[32U] ;
};
struct drm_psb_dpst_lut_arg {
   uint8_t lut[256U] ;
   int output_id ;
};
struct drm_psb_mode_operation_arg {
   u32 obj_id ;
   u16 operation ;
   struct drm_mode_modeinfo mode ;
   u64 data ;
};
struct drm_psb_stolen_memory_arg {
   u32 base ;
   u32 size ;
};
struct drm_connector_helper_funcs {
   int (*get_modes)(struct drm_connector * ) ;
   int (*mode_valid)(struct drm_connector * , struct drm_display_mode * ) ;
   struct drm_encoder *(*best_encoder)(struct drm_connector * ) ;
};
enum hrtimer_restart;
struct drm_psb_get_pipe_from_crtc_id_arg {
   u32 crtc_id ;
   u32 pipe ;
};
struct drm_encoder_helper_funcs {
   void (*dpms)(struct drm_encoder * , int  ) ;
   void (*save)(struct drm_encoder * ) ;
   void (*restore)(struct drm_encoder * ) ;
   bool (*mode_fixup)(struct drm_encoder * , struct drm_display_mode  const  * , struct drm_display_mode * ) ;
   void (*prepare)(struct drm_encoder * ) ;
   void (*commit)(struct drm_encoder * ) ;
   void (*mode_set)(struct drm_encoder * , struct drm_display_mode * , struct drm_display_mode * ) ;
   struct drm_crtc *(*get_crtc)(struct drm_encoder * ) ;
   enum drm_connector_status (*detect)(struct drm_encoder * , struct drm_connector * ) ;
   void (*disable)(struct drm_encoder * ) ;
};
struct psb_intel_clock_t {
   int n ;
   int m1 ;
   int m2 ;
   int p1 ;
   int p2 ;
   int dot ;
   int vco ;
   int m ;
   int p ;
};
struct psb_intel_range_t {
   int min ;
   int max ;
};
struct psb_intel_p2_t {
   int dot_limit ;
   int p2_slow ;
   int p2_fast ;
};
struct psb_intel_limit_t {
   struct psb_intel_range_t dot ;
   struct psb_intel_range_t vco ;
   struct psb_intel_range_t n ;
   struct psb_intel_range_t m ;
   struct psb_intel_range_t m1 ;
   struct psb_intel_range_t m2 ;
   struct psb_intel_range_t p ;
   struct psb_intel_range_t p1 ;
   struct psb_intel_p2_t p2 ;
};
enum hrtimer_restart;
struct psb_intel_lvds_priv {
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t saveLVDS ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveBLC_PWM_CTL ;
   struct psb_intel_i2c_chan *i2c_bus ;
   struct psb_intel_i2c_chan *ddc_bus ;
};
enum hrtimer_restart;
struct edid;
typedef __u16 __le16;
enum hrtimer_restart;
struct est_timings {
   u8 t1 ;
   u8 t2 ;
   u8 mfg_rsvd ;
};
struct std_timing {
   u8 hsize ;
   u8 vfreq_aspect ;
};
struct detailed_pixel_timing {
   u8 hactive_lo ;
   u8 hblank_lo ;
   u8 hactive_hblank_hi ;
   u8 vactive_lo ;
   u8 vblank_lo ;
   u8 vactive_vblank_hi ;
   u8 hsync_offset_lo ;
   u8 hsync_pulse_width_lo ;
   u8 vsync_offset_pulse_width_lo ;
   u8 hsync_vsync_offset_pulse_width_hi ;
   u8 width_mm_lo ;
   u8 height_mm_lo ;
   u8 width_height_mm_hi ;
   u8 hborder ;
   u8 vborder ;
   u8 misc ;
};
struct detailed_data_string {
   u8 str[13U] ;
};
struct __anonstruct_gtf2_210 {
   u8 reserved ;
   u8 hfreq_start_khz ;
   u8 c ;
   __le16 m ;
   u8 k ;
   u8 j ;
};
struct __anonstruct_cvt_211 {
   u8 version ;
   u8 data1 ;
   u8 data2 ;
   u8 supported_aspects ;
   u8 flags ;
   u8 supported_scalings ;
   u8 preferred_refresh ;
};
union __anonunion_formula_209 {
   struct __anonstruct_gtf2_210 gtf2 ;
   struct __anonstruct_cvt_211 cvt ;
};
struct detailed_data_monitor_range {
   u8 min_vfreq ;
   u8 max_vfreq ;
   u8 min_hfreq_khz ;
   u8 max_hfreq_khz ;
   u8 pixel_clock_mhz ;
   u8 flags ;
   union __anonunion_formula_209 formula ;
};
struct detailed_data_wpindex {
   u8 white_yx_lo ;
   u8 white_x_hi ;
   u8 white_y_hi ;
   u8 gamma ;
};
struct cvt_timing {
   u8 code[3U] ;
};
union __anonunion_data_212 {
   struct detailed_data_string str ;
   struct detailed_data_monitor_range range ;
   struct detailed_data_wpindex color ;
   struct std_timing timings[6U] ;
   struct cvt_timing cvt[4U] ;
};
struct detailed_non_pixel {
   u8 pad1 ;
   u8 type ;
   u8 pad2 ;
   union __anonunion_data_212 data ;
};
union __anonunion_data_213 {
   struct detailed_pixel_timing pixel_data ;
   struct detailed_non_pixel other_data ;
};
struct detailed_timing {
   __le16 pixel_clock ;
   union __anonunion_data_213 data ;
};
struct edid {
   u8 header[8U] ;
   u8 mfg_id[2U] ;
   u8 prod_code[2U] ;
   u32 serial ;
   u8 mfg_week ;
   u8 mfg_year ;
   u8 version ;
   u8 revision ;
   u8 input ;
   u8 width_cm ;
   u8 height_cm ;
   u8 gamma ;
   u8 features ;
   u8 red_green_lo ;
   u8 black_white_lo ;
   u8 red_x ;
   u8 red_y ;
   u8 green_x ;
   u8 green_y ;
   u8 blue_x ;
   u8 blue_y ;
   u8 white_x ;
   u8 white_y ;
   struct est_timings established_timings ;
   struct std_timing standard_timings[8U] ;
   struct detailed_timing detailed_timings[4U] ;
   u8 extensions ;
   u8 checksum ;
};
struct psb_intel_sdvo_caps {
   u8 vendor_id ;
   u8 device_id ;
   u8 device_rev_id ;
   u8 sdvo_version_major ;
   u8 sdvo_version_minor ;
   unsigned char sdvo_inputs_mask : 2 ;
   unsigned char smooth_scaling : 1 ;
   unsigned char sharp_scaling : 1 ;
   unsigned char up_scaling : 1 ;
   unsigned char down_scaling : 1 ;
   unsigned char stall_support : 1 ;
   unsigned char pad : 1 ;
   u16 output_flags ;
};
struct __anonstruct_part1_221 {
   u16 clock ;
   u8 h_active ;
   u8 h_blank ;
   u8 h_high ;
   u8 v_active ;
   u8 v_blank ;
   u8 v_high ;
};
struct __anonstruct_part2_222 {
   u8 h_sync_off ;
   u8 h_sync_width ;
   u8 v_sync_off_width ;
   u8 sync_off_width_high ;
   u8 dtd_flags ;
   u8 sdvo_flags ;
   u8 v_sync_off_high ;
   u8 reserved ;
};
struct psb_intel_sdvo_dtd {
   struct __anonstruct_part1_221 part1 ;
   struct __anonstruct_part2_222 part2 ;
};
struct psb_intel_sdvo_pixel_clock_range {
   u16 min ;
   u16 max ;
};
struct psb_intel_sdvo_preferred_input_timing_args {
   u16 clock ;
   u16 width ;
   u16 height ;
   unsigned char interlace : 1 ;
   unsigned char scaled : 1 ;
   unsigned char pad : 6 ;
};
struct psb_intel_sdvo_get_trained_inputs_response {
   unsigned char input0_trained : 1 ;
   unsigned char input1_trained : 1 ;
   unsigned char pad : 6 ;
};
struct psb_intel_sdvo_in_out_map {
   u16 in0 ;
   u16 in1 ;
};
struct psb_intel_sdvo_set_target_input_args {
   unsigned char target_1 : 1 ;
   unsigned char pad : 7 ;
};
struct psb_intel_sdvo_tv_format {
   unsigned char ntsc_m : 1 ;
   unsigned char ntsc_j : 1 ;
   unsigned char ntsc_443 : 1 ;
   unsigned char pal_b : 1 ;
   unsigned char pal_d : 1 ;
   unsigned char pal_g : 1 ;
   unsigned char pal_h : 1 ;
   unsigned char pal_i : 1 ;
   unsigned char pal_m : 1 ;
   unsigned char pal_n : 1 ;
   unsigned char pal_nc : 1 ;
   unsigned char pal_60 : 1 ;
   unsigned char secam_b : 1 ;
   unsigned char secam_d : 1 ;
   unsigned char secam_g : 1 ;
   unsigned char secam_k : 1 ;
   unsigned char secam_k1 : 1 ;
   unsigned char secam_l : 1 ;
   unsigned char secam_60 : 1 ;
   unsigned char hdtv_std_smpte_240m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_240m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_260m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_260m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_50 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_59 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080i_60 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_23 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_24 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_25 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_29 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_30 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_50 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_59 : 1 ;
   unsigned char hdtv_std_smpte_274m_1080p_60 : 1 ;
   unsigned char hdtv_std_smpte_295m_1080i_50 : 1 ;
   unsigned char hdtv_std_smpte_295m_1080p_50 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_59 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_60 : 1 ;
   unsigned char hdtv_std_smpte_296m_720p_50 : 1 ;
   unsigned char hdtv_std_smpte_293m_480p_59 : 1 ;
   unsigned char hdtv_std_smpte_170m_480i_59 : 1 ;
   unsigned char hdtv_std_iturbt601_576i_50 : 1 ;
   unsigned char hdtv_std_iturbt601_576p_50 : 1 ;
   unsigned char hdtv_std_eia_7702a_480i_60 : 1 ;
   unsigned char hdtv_std_eia_7702a_480p_60 : 1 ;
   unsigned char pad : 3 ;
};
struct psb_intel_sdvo_sdtv_resolution_request {
   unsigned char ntsc_m : 1 ;
   unsigned char ntsc_j : 1 ;
   unsigned char ntsc_443 : 1 ;
   unsigned char pal_b : 1 ;
   unsigned char pal_d : 1 ;
   unsigned char pal_g : 1 ;
   unsigned char pal_h : 1 ;
   unsigned char pal_i : 1 ;
   unsigned char pal_m : 1 ;
   unsigned char pal_n : 1 ;
   unsigned char pal_nc : 1 ;
   unsigned char pal_60 : 1 ;
   unsigned char secam_b : 1 ;
   unsigned char secam_d : 1 ;
   unsigned char secam_g : 1 ;
   unsigned char secam_k : 1 ;
   unsigned char secam_k1 : 1 ;
   unsigned char secam_l : 1 ;
   unsigned char secam_60 : 1 ;
   unsigned char pad : 5 ;
};
struct psb_intel_sdvo_enhancements_reply {
   unsigned char flicker_filter : 1 ;
   unsigned char flicker_filter_adaptive : 1 ;
   unsigned char flicker_filter_2d : 1 ;
   unsigned char saturation : 1 ;
   unsigned char hue : 1 ;
   unsigned char brightness : 1 ;
   unsigned char contrast : 1 ;
   unsigned char overscan_h : 1 ;
   unsigned char overscan_v : 1 ;
   unsigned char hpos : 1 ;
   unsigned char vpos : 1 ;
   unsigned char sharpness : 1 ;
   unsigned char dot_crawl : 1 ;
   unsigned char dither : 1 ;
   unsigned char tv_chroma_filter : 1 ;
   unsigned char tv_luma_filter : 1 ;
};
struct psb_intel_sdvo_encode {
   u8 dvi_rev ;
   u8 hdmi_rev ;
};
struct psb_intel_sdvo {
   struct psb_intel_encoder base ;
   struct i2c_adapter *i2c ;
   u8 slave_addr ;
   struct i2c_adapter ddc ;
   int sdvo_reg ;
   uint16_t controlled_output ;
   struct psb_intel_sdvo_caps caps ;
   int pixel_clock_min ;
   int pixel_clock_max ;
   uint16_t attached_output ;
   uint32_t color_range ;
   bool is_tv ;
   int tv_format_index ;
   bool is_hdmi ;
   bool has_hdmi_monitor ;
   bool has_hdmi_audio ;
   bool is_lvds ;
   struct drm_display_mode *sdvo_lvds_fixed_mode ;
   uint8_t ddc_bus ;
   struct psb_intel_sdvo_dtd input_dtd ;
};
struct psb_intel_sdvo_connector {
   struct psb_intel_connector base ;
   uint16_t output_flag ;
   int force_audio ;
   u8 tv_format_supported[19U] ;
   int format_supported_num ;
   struct drm_property *tv_format ;
   struct drm_property *left ;
   struct drm_property *right ;
   struct drm_property *top ;
   struct drm_property *bottom ;
   struct drm_property *hpos ;
   struct drm_property *vpos ;
   struct drm_property *contrast ;
   struct drm_property *saturation ;
   struct drm_property *hue ;
   struct drm_property *sharpness ;
   struct drm_property *flicker_filter ;
   struct drm_property *flicker_filter_adaptive ;
   struct drm_property *flicker_filter_2d ;
   struct drm_property *tv_chroma_filter ;
   struct drm_property *tv_luma_filter ;
   struct drm_property *dot_crawl ;
   struct drm_property *brightness ;
   u32 left_margin ;
   u32 right_margin ;
   u32 top_margin ;
   u32 bottom_margin ;
   u32 max_hscan ;
   u32 max_vscan ;
   u32 max_hpos ;
   u32 cur_hpos ;
   u32 max_vpos ;
   u32 cur_vpos ;
   u32 cur_brightness ;
   u32 max_brightness ;
   u32 cur_contrast ;
   u32 max_contrast ;
   u32 cur_saturation ;
   u32 max_saturation ;
   u32 cur_hue ;
   u32 max_hue ;
   u32 cur_sharpness ;
   u32 max_sharpness ;
   u32 cur_flicker_filter ;
   u32 max_flicker_filter ;
   u32 cur_flicker_filter_adaptive ;
   u32 max_flicker_filter_adaptive ;
   u32 cur_flicker_filter_2d ;
   u32 max_flicker_filter_2d ;
   u32 cur_tv_chroma_filter ;
   u32 max_tv_chroma_filter ;
   u32 cur_tv_luma_filter ;
   u32 max_tv_luma_filter ;
   u32 cur_dot_crawl ;
   u32 max_dot_crawl ;
};
struct _sdvo_cmd_name {
   u8 cmd ;
   char const   *name ;
};
union __anonunion_enhancements_231 {
   struct psb_intel_sdvo_enhancements_reply reply ;
   uint16_t response ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct gct_r10_timing_info {
   u16 pixel_clock ;
   unsigned char hactive_lo ;
   unsigned char hactive_hi : 4 ;
   unsigned char hblank_lo ;
   unsigned char hblank_hi : 4 ;
   unsigned char hsync_offset_lo ;
   unsigned char hsync_offset_hi : 2 ;
   unsigned char hsync_pulse_width_lo ;
   unsigned char hsync_pulse_width_hi : 2 ;
   unsigned char hsync_positive : 1 ;
   unsigned char rsvd_1 : 3 ;
   u8 vactive_lo ;
   unsigned char vactive_hi : 4 ;
   unsigned char vblank_lo ;
   unsigned char vblank_hi : 4 ;
   unsigned char vsync_offset_lo : 4 ;
   unsigned char vsync_offset_hi : 2 ;
   unsigned char vsync_pulse_width_lo : 4 ;
   unsigned char vsync_pulse_width_hi : 2 ;
   unsigned char vsync_positive : 1 ;
   unsigned char rsvd_2 : 3 ;
};
struct oaktrail_panel_descriptor_v1 {
   u32 Panel_Port_Control ;
   u32 Panel_Power_On_Sequencing ;
   u32 Panel_Power_Off_Sequencing ;
   u32 Panel_Power_Cycle_Delay_and_Reference_Divisor ;
   struct oaktrail_timing_info DTD ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u16 Panel_MIPI_Display_Descriptor ;
};
struct oaktrail_panel_descriptor_v2 {
   u32 Panel_Port_Control ;
   u32 Panel_Power_On_Sequencing ;
   u32 Panel_Power_Off_Sequencing ;
   u8 Panel_Power_Cycle_Delay_and_Reference_Divisor ;
   struct oaktrail_timing_info DTD ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u8 Panel_Initial_Brightness ;
   u16 Panel_MIPI_Display_Descriptor ;
};
struct __anonstruct_panelrx_204 {
   unsigned char NumberOfLanes : 2 ;
   unsigned char MaxLaneFreq : 3 ;
   unsigned char SupportedVideoTransferMode : 2 ;
   unsigned char HSClkBehavior : 1 ;
   unsigned char DuoDisplaySupport : 1 ;
   unsigned char ECC_ChecksumCapabilities : 1 ;
   unsigned char BidirectionalCommunication : 1 ;
   unsigned char Rsvd : 5 ;
};
union oaktrail_panel_rx {
   struct __anonstruct_panelrx_204 panelrx ;
   u16 panel_receiver ;
};
struct __anonstruct_PD_206 {
   unsigned char PanelType : 4 ;
   unsigned char BootPanelIndex : 2 ;
   unsigned char BootMIPI_DSI_RxIndex : 2 ;
};
union __anonunion_ldv_37334_205 {
   struct __anonstruct_PD_206 PD ;
   u8 PanelDescriptor ;
};
struct gct_r0 {
   union __anonunion_ldv_37334_205 ldv_37334 ;
   struct oaktrail_panel_descriptor_v1 panel[4U] ;
   union oaktrail_panel_rx panelrx[4U] ;
};
struct __anonstruct_PD_208 {
   unsigned char PanelType : 4 ;
   unsigned char BootPanelIndex : 2 ;
   unsigned char BootMIPI_DSI_RxIndex : 2 ;
};
union __anonunion_ldv_37345_207 {
   struct __anonstruct_PD_208 PD ;
   u8 PanelDescriptor ;
};
struct gct_r1 {
   union __anonunion_ldv_37345_207 ldv_37345 ;
   struct oaktrail_panel_descriptor_v2 panel[4U] ;
   union oaktrail_panel_rx panelrx[4U] ;
};
struct gct_r10 {
   struct gct_r10_timing_info DTD ;
   u16 Panel_MIPI_Display_Descriptor ;
   u16 Panel_MIPI_Receiver_Descriptor ;
   u16 Panel_Backlight_Inverter_Descriptor ;
   u8 Panel_Initial_Brightness ;
   u32 MIPI_Ctlr_Init_ptr ;
   u32 MIPI_Panel_Init_ptr ;
};
struct mid_vbt_header {
   u32 signature ;
   u8 revision ;
};
struct vbt_r0 {
   struct mid_vbt_header vbt_header ;
   u8 size ;
   u8 checksum ;
};
struct vbt_r10 {
   struct mid_vbt_header vbt_header ;
   u8 checksum ;
   u16 size ;
   u8 panel_count ;
   u8 primary_panel_idx ;
   u8 secondary_panel_idx ;
   u8 __reserved[5U] ;
};
enum hrtimer_restart;
typedef u64 acpi_size;
typedef u64 acpi_physical_address;
struct opregion_header {
   u8 signature[16U] ;
   u32 size ;
   u32 opregion_ver ;
   u8 bios_ver[32U] ;
   u8 vbios_ver[16U] ;
   u8 driver_ver[16U] ;
   u32 mboxes ;
   u8 reserved[164U] ;
};
struct opregion_acpi {
   u32 drdy ;
   u32 csts ;
   u32 cevt ;
   u8 rsvd1[20U] ;
   u32 didl[8U] ;
   u32 cpdl[8U] ;
   u32 cadl[8U] ;
   u32 nadl[8U] ;
   u32 aslp ;
   u32 tidx ;
   u32 chpd ;
   u32 clid ;
   u32 cdck ;
   u32 sxsw ;
   u32 evts ;
   u32 cnot ;
   u32 nrdy ;
   u8 rsvd2[60U] ;
};
struct opregion_swsci {

};
struct opregion_asle {
   u32 ardy ;
   u32 aslc ;
   u32 tche ;
   u32 alsi ;
   u32 bclp ;
   u32 pfit ;
   u32 cblv ;
   u16 bclm[20U] ;
   u32 cpfm ;
   u32 epfm ;
   u8 plut[74U] ;
   u32 pfmb ;
   u8 rsvd[102U] ;
};
typedef unsigned int uint;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct cdv_intel_range_t {
   int min ;
   int max ;
};
struct cdv_intel_p2_t {
   int dot_limit ;
   int p2_slow ;
   int p2_fast ;
};
struct cdv_intel_clock_t {
   int n ;
   int m1 ;
   int m2 ;
   int p1 ;
   int p2 ;
   int dot ;
   int vco ;
   int m ;
   int p ;
};
struct cdv_intel_limit_t {
   struct cdv_intel_range_t dot ;
   struct cdv_intel_range_t vco ;
   struct cdv_intel_range_t n ;
   struct cdv_intel_range_t m ;
   struct cdv_intel_range_t m1 ;
   struct cdv_intel_range_t m2 ;
   struct cdv_intel_range_t p ;
   struct cdv_intel_range_t p1 ;
   struct cdv_intel_p2_t p2 ;
   bool (*find_pll)(struct cdv_intel_limit_t  const  * , struct drm_crtc * , int  ,
                    int  , struct cdv_intel_clock_t * ) ;
};
enum hrtimer_restart;
struct mdfld_hdmi_i2c;
struct mid_intel_hdmi_priv {
   u32 hdmi_reg ;
   u32 save_HDMIB ;
   bool has_hdmi_sink ;
   bool has_hdmi_audio ;
   bool hdmi_device_connected ;
   struct mdfld_hdmi_i2c *i2c_bus ;
   struct i2c_adapter *hdmi_i2c_adapter ;
   struct drm_device *dev ;
};
enum hrtimer_restart;
struct cdv_intel_lvds_priv {
   uint32_t savePP_ON ;
   uint32_t savePP_OFF ;
   uint32_t saveLVDS ;
   uint32_t savePP_CONTROL ;
   uint32_t savePP_CYCLE ;
   uint32_t savePFIT_CONTROL ;
   uint32_t savePFIT_PGM_RATIOS ;
   uint32_t saveBLC_PWM_CTL ;
};
enum hrtimer_restart;
struct i2c_algo_dp_aux_data {
   bool running ;
   u16 address ;
   int (*aux_ch)(struct i2c_adapter * , int  , uint8_t  , uint8_t * ) ;
};
struct cdv_intel_dp {
   uint32_t output_reg ;
   uint32_t DP ;
   uint8_t link_configuration[9U] ;
   bool has_audio ;
   int force_audio ;
   uint32_t color_range ;
   uint8_t link_bw ;
   uint8_t lane_count ;
   uint8_t dpcd[4U] ;
   struct psb_intel_encoder *encoder ;
   struct i2c_adapter adapter ;
   struct i2c_algo_dp_aux_data algo ;
   uint8_t train_set[4U] ;
   uint8_t link_status[6U] ;
   int panel_power_up_delay ;
   int panel_power_down_delay ;
   int panel_power_cycle_delay ;
   int backlight_on_delay ;
   int backlight_off_delay ;
   struct drm_display_mode *panel_fixed_mode ;
   bool panel_on ;
};
struct ddi_regoff {
   uint32_t PreEmph1 ;
   uint32_t PreEmph2 ;
   uint32_t VSwing1 ;
   uint32_t VSwing2 ;
   uint32_t VSwing3 ;
   uint32_t VSwing4 ;
   uint32_t VSwing5 ;
};
struct cdv_intel_dp_m_n {
   uint32_t tu ;
   uint32_t gmch_m ;
   uint32_t gmch_n ;
   uint32_t link_m ;
   uint32_t link_n ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct oaktrail_limit_t {
   struct psb_intel_range_t dot ;
   struct psb_intel_range_t m ;
   struct psb_intel_range_t p1 ;
};
struct oaktrail_clock_t {
   int dot ;
   int m ;
   int p1 ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct intel_range {
   int min ;
   int max ;
};
struct oaktrail_hdmi_limit {
   struct intel_range vco ;
   struct intel_range np ;
   struct intel_range nr ;
   struct intel_range nf ;
};
struct oaktrail_hdmi_clock {
   int np ;
   int nr ;
   int nf ;
   int dot ;
};
enum hrtimer_restart;
struct hdmi_i2c_dev {
   struct i2c_adapter *adap ;
   struct mutex i2c_lock ;
   struct completion complete ;
   int status ;
   struct i2c_msg *msg ;
   int buf_offset ;
};
long ldv__builtin_expect(long exp , long c ) ;
__inline static void rep_nop(void) 
{ 

  {
  __asm__  volatile   ("rep; nop": : : "memory");
  return;
}
}
__inline static void cpu_relax(void) 
{ 

  {
  rep_nop();
  return;
}
}
extern int mutex_trylock(struct mutex * ) ;
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) ;
extern void mutex_unlock(struct mutex * ) ;
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
extern void mutex_lock(struct mutex * ) ;
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) ;
void ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) ;
void ldv_mutex_lock_lock(struct mutex *lock ) ;
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
void ldv_mutex_unlock_lock_of_fb_info(struct mutex *lock ) ;
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
void ldv_mutex_lock_struct_mutex_of_drm_device(struct mutex *lock ) ;
void ldv_mutex_unlock_struct_mutex_of_drm_device(struct mutex *lock ) ;
void ldv_mutex_lock_update_lock_of_backlight_device(struct mutex *lock ) ;
void ldv_mutex_unlock_update_lock_of_backlight_device(struct mutex *lock ) ;
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 

  {
  return (& lock->ldv_5961.rlock);
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 

  {
  _raw_spin_unlock_irqrestore(& lock->ldv_5961.rlock, flags);
  return;
}
}
extern unsigned long volatile   jiffies ;
extern unsigned int ioread32(void * ) ;
extern void iowrite32(u32  , void * ) ;
extern void msleep(unsigned int  ) ;
extern void cfb_copyarea(struct fb_info * , struct fb_copyarea  const  * ) ;
bool gma_power_begin(struct drm_device *dev , bool force_on ) ;
void gma_power_end(struct drm_device *dev ) ;
void psbfb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) ;
int psbfb_sync(struct fb_info *info ) ;
void psb_spank(struct drm_psb_private *dev_priv ) ;
void psb_spank(struct drm_psb_private *dev_priv ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  iowrite32(127U, (void *)dev_priv->sgx_reg + 128U);
  ioread32((void *)dev_priv->sgx_reg + 128U);
  msleep(1U);
  iowrite32(0U, (void *)dev_priv->sgx_reg + 128U);
  __asm__  volatile   ("sfence": : : "memory");
  tmp = ioread32((void *)dev_priv->sgx_reg + 3072U);
  iowrite32(tmp | 16U, (void *)dev_priv->sgx_reg + 3072U);
  __asm__  volatile   ("sfence": : : "memory");
  ioread32((void *)dev_priv->sgx_reg + 3072U);
  msleep(1U);
  tmp___0 = ioread32((void *)dev_priv->sgx_reg + 3072U);
  iowrite32(tmp___0 & 4294967279U, (void *)dev_priv->sgx_reg + 3072U);
  ioread32((void *)dev_priv->sgx_reg + 3072U);
  iowrite32(dev_priv->gtt.gatt_start, (void *)dev_priv->sgx_reg + 3208U);
  return;
}
}
static int psb_2d_wait_available(struct drm_psb_private *dev_priv , unsigned int size ) 
{ uint32_t avail ;
  unsigned int tmp ;
  unsigned long t ;

  {
  tmp = ioread32((void *)dev_priv->sgx_reg + 3608U);
  avail = tmp;
  t = (unsigned long )jiffies + 250UL;
  goto ldv_39131;
  ldv_39130: 
  avail = ioread32((void *)dev_priv->sgx_reg + 3608U);
  if ((long )t - (long )jiffies < 0L) {
    psb_spank(dev_priv);
    return (-5);
  } else {

  }
  ldv_39131: ;
  if (avail < size) {
    goto ldv_39130;
  } else {
    goto ldv_39132;
  }
  ldv_39132: ;
  return (0);
}
}
static int psbfb_2d_submit(struct drm_psb_private *dev_priv , uint32_t *cmdbuf , unsigned int size ) 
{ int ret ;
  int i ;
  unsigned int submit_size ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  uint32_t *tmp___0 ;

  {
  ret = 0;
  tmp = spinlock_check(& dev_priv->lock_2d);
  flags = _raw_spin_lock_irqsave(tmp);
  goto ldv_39150;
  ldv_39149: ;
  if (96U < size) {
    submit_size = 96U;
  } else {
    submit_size = size;
  }
  size = size - submit_size;
  ret = psb_2d_wait_available(dev_priv, submit_size);
  if (ret != 0) {
    goto ldv_39145;
  } else {

  }
  submit_size = submit_size << 2;
  i = 0;
  goto ldv_39147;
  ldv_39146: 
  tmp___0 = cmdbuf;
  cmdbuf = cmdbuf + 1;
  iowrite32(*tmp___0, (void *)dev_priv->sgx_reg + (unsigned long )(i + 16384));
  i = i + 4;
  ldv_39147: ;
  if ((unsigned int )i < submit_size) {
    goto ldv_39146;
  } else {
    goto ldv_39148;
  }
  ldv_39148: 
  ioread32((void *)(dev_priv->sgx_reg + ((unsigned long )(i + 16384) + 0xfffffffffffffffcUL)));
  ldv_39150: ;
  if (size != 0U) {
    goto ldv_39149;
  } else {
    goto ldv_39145;
  }
  ldv_39145: 
  spin_unlock_irqrestore(& dev_priv->lock_2d, flags);
  return (ret);
}
}
static u32 psb_accel_2d_copy_direction(int xdir , int ydir ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  if (xdir < 0) {
    if (ydir < 0) {
      tmp = 8388608U;
    } else {
      tmp = 16777216U;
    }
    return (tmp);
  } else {
    if (ydir < 0) {
      tmp___0 = 25165824U;
    } else {
      tmp___0 = 0U;
    }
    return (tmp___0);
  }
}
}
static int psb_accel_2d_copy(struct drm_psb_private *dev_priv , uint32_t src_offset ,
                             uint32_t src_stride , uint32_t src_format , uint32_t dst_offset ,
                             uint32_t dst_stride , uint32_t dst_format , uint16_t src_x ,
                             uint16_t src_y , uint16_t dst_x , uint16_t dst_y , uint16_t size_x ,
                             uint16_t size_y ) 
{ uint32_t blit_cmd ;
  uint32_t buffer[10U] ;
  uint32_t *buf ;
  uint32_t direction ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  int tmp___9 ;

  {
  buf = (uint32_t *)(& buffer);
  direction = psb_accel_2d_copy_direction((int )src_x - (int )dst_x, (int )src_y - (int )dst_y);
  if (direction == 8388608U || direction == 16777216U) {
    src_x = (unsigned int )((int )size_x + (int )src_x) + 65535U;
    dst_x = (unsigned int )((int )size_x + (int )dst_x) + 65535U;
  } else {

  }
  if (direction == 8388608U || direction == 25165824U) {
    src_y = (unsigned int )((int )size_y + (int )src_y) + 65535U;
    dst_y = (unsigned int )((int )size_y + (int )dst_y) + 65535U;
  } else {

  }
  blit_cmd = direction | 2147601612U;
  tmp = buf;
  buf = buf + 1;
  *tmp = 1879048192U;
  tmp___0 = buf;
  buf = buf + 1;
  *tmp___0 = (dst_format | dst_stride) | 2684354560U;
  tmp___1 = buf;
  buf = buf + 1;
  *tmp___1 = dst_offset;
  tmp___2 = buf;
  buf = buf + 1;
  *tmp___2 = (src_format | src_stride) | 2415919104U;
  tmp___3 = buf;
  buf = buf + 1;
  *tmp___3 = src_offset;
  tmp___4 = buf;
  buf = buf + 1;
  *tmp___4 = (uint32_t )((((int )src_x << 12) | 805306368) | (int )src_y);
  tmp___5 = buf;
  buf = buf + 1;
  *tmp___5 = blit_cmd;
  tmp___6 = buf;
  buf = buf + 1;
  *tmp___6 = (uint32_t )(((int )dst_x << 12) | (int )dst_y);
  tmp___7 = buf;
  buf = buf + 1;
  *tmp___7 = (uint32_t )(((int )size_x << 12) | (int )size_y);
  tmp___8 = buf;
  buf = buf + 1;
  *tmp___8 = 4026531840U;
  tmp___9 = psbfb_2d_submit(dev_priv, (uint32_t *)(& buffer), (unsigned int )(((long )buf - (long )(& buffer)) / 4L));
  return (tmp___9);
}
}
static void psbfb_copyarea_accel(struct fb_info *info , struct fb_copyarea  const  *a ) 
{ struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_framebuffer *fb ;
  struct drm_psb_private *dev_priv ;
  uint32_t offset ;
  uint32_t stride ;
  uint32_t src_format ;
  uint32_t dst_format ;
  bool tmp ;
  int tmp___0 ;

  {
  fbdev = (struct psb_fbdev *)info->par;
  psbfb = & fbdev->pfb;
  dev = psbfb->base.dev;
  fb = fbdev->psb_fb_helper.fb;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((unsigned long )fb == (unsigned long )((struct drm_framebuffer *)0)) {
    return;
  } else {

  }
  offset = (psbfb->gtt)->offset;
  stride = fb->pitches[0];
  switch (fb->depth) {
  case 8: 
  src_format = 196608U;
  dst_format = 196608U;
  goto ldv_39188;
  case 15: 
  src_format = 262144U;
  dst_format = 262144U;
  goto ldv_39188;
  case 16: 
  src_format = 327680U;
  dst_format = 327680U;
  goto ldv_39188;
  case 24: ;
  case 32: 
  src_format = 393216U;
  dst_format = 393216U;
  goto ldv_39188;
  default: 
  cfb_copyarea(info, a);
  return;
  }
  ldv_39188: 
  tmp = gma_power_begin(dev, 0);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    cfb_copyarea(info, a);
    return;
  } else {

  }
  psb_accel_2d_copy(dev_priv, offset, stride, src_format, offset, stride, dst_format,
                    (int )((uint16_t )a->sx), (int )((uint16_t )a->sy), (int )((uint16_t )a->dx),
                    (int )((uint16_t )a->dy), (int )((uint16_t )a->width), (int )((uint16_t )a->height));
  gma_power_end(dev);
  return;
}
}
void psbfb_copyarea(struct fb_info *info , struct fb_copyarea  const  *region ) 
{ long tmp ;

  {
  tmp = ldv__builtin_expect(info->state != 0U, 0L);
  if (tmp != 0L) {
    return;
  } else {

  }
  if (((unsigned int )region->width == 8U || (unsigned int )region->height == 8U) || (info->flags & 2) != 0) {
    return;
  } else {

  }
  psbfb_copyarea_accel(info, region);
  return;
}
}
int psbfb_sync(struct fb_info *info ) 
{ struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  unsigned long _end___0 ;
  int busy ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
  fbdev = (struct psb_fbdev *)info->par;
  psbfb = & fbdev->pfb;
  dev = psbfb->base.dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  _end___0 = (unsigned long )jiffies + 250UL;
  busy = 0;
  tmp = spinlock_check(& dev_priv->lock_2d);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = ioread32((void *)dev_priv->sgx_reg + 3608U);
  if (tmp___0 == 128U) {
    tmp___1 = ioread32((void *)dev_priv->sgx_reg + 3588U);
    if ((tmp___1 & 16777216U) == 0U) {
      goto out;
    } else {

    }
  } else {

  }
  ldv_39218: 
  tmp___2 = ioread32((void *)dev_priv->sgx_reg + 3608U);
  busy = tmp___2 != 128U;
  cpu_relax();
  if (busy != 0 && (long )jiffies - (long )_end___0 < 0L) {
    goto ldv_39218;
  } else {
    goto ldv_39219;
  }
  ldv_39219: ;
  if (busy != 0) {
    tmp___3 = ioread32((void *)dev_priv->sgx_reg + 3608U);
    busy = tmp___3 != 128U;
  } else {

  }
  if (busy != 0) {
    goto out;
  } else {

  }
  ldv_39226: 
  tmp___4 = ioread32((void *)dev_priv->sgx_reg + 3588U);
  busy = (tmp___4 & 16777216U) != 0U;
  cpu_relax();
  if (busy != 0 && (long )jiffies - (long )_end___0 < 0L) {
    goto ldv_39226;
  } else {
    goto ldv_39227;
  }
  ldv_39227: ;
  if (busy != 0) {
    tmp___5 = ioread32((void *)dev_priv->sgx_reg + 3588U);
    busy = (tmp___5 & 16777216U) != 0U;
  } else {

  }
  out: 
  spin_unlock_irqrestore(& dev_priv->lock_2d, flags);
  if (busy != 0) {
    tmp___6 = -16;
  } else {
    tmp___6 = 0;
  }
  return (tmp___6);
}
}
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_28(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_31(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_33(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_36(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_27(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_30(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_32(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_35(struct mutex *ldv_func_arg1 ) ;
int gma_backlight_init(struct drm_device *dev ) ;
void gma_backlight_exit(struct drm_device *dev ) ;
void gma_backlight_disable(struct drm_device *dev ) ;
void gma_backlight_enable(struct drm_device *dev ) ;
void gma_backlight_set(struct drm_device *dev , int v ) ;
void gma_backlight_enable(struct drm_device *dev ) 
{ 

  {
  return;
}
}
void gma_backlight_disable(struct drm_device *dev ) 
{ 

  {
  return;
}
}
void gma_backlight_set(struct drm_device *dev , int v ) 
{ 

  {
  return;
}
}
int gma_backlight_init(struct drm_device *dev ) 
{ 

  {
  return (0);
}
}
void gma_backlight_exit(struct drm_device *dev ) 
{ 

  {
  return;
}
}
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_27(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_28(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_30(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_31(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_32(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_33(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_35(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_36(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
extern int __dynamic_dev_dbg(struct _ddebug * , struct device  const  * , char const   * 
                             , ...) ;
extern void *memset(void * , int  , size_t  ) ;
extern char *strcpy(char * , char const   * ) ;
extern void warn_slowpath_null(char const   * , int const    ) ;
__inline static void *ERR_PTR(long error ) 
{ 

  {
  return ((void *)error);
}
}
extern struct cpuinfo_x86 boot_cpu_data ;
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2,%0; sete %1": "+m" (v->counter),
                       "=qm" (c): "ir" (i): "memory");
  return ((int )c);
}
}
int ldv_mutex_trylock_52(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_53(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_55(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_57(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_58(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_60(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_62(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_63(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_65(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_54(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_56(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_59(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_64(struct mutex *ldv_func_arg1 ) ;
int ldv_state_variable_46 ;
int ldv_state_variable_47 ;
int ldv_state_variable_48 ;
int ldv_state_variable_50 ;
int ldv_state_variable_51 ;
int ldv_state_variable_49 ;
int ref_cnt ;
extern int __VERIFIER_nondet_int(void) ;
int ldv_state_variable_52 ;
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("include/linux/kref.h", 67);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
  if (tmp___0 != 0) {
    (*release)(kref);
    return (1);
  } else {

  }
  return (0);
}
}
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ int tmp ;

  {
  tmp = kref_sub(kref, 1U, release);
  return (tmp);
}
}
extern struct module __this_module ;
extern int vm_insert_mixed(struct vm_area_struct * , unsigned long  , unsigned long  ) ;
extern int dev_err(struct device  const  * , char const   *  , ...) ;
extern void kfree(void const   * ) ;
extern void *__kmalloc(size_t  , gfp_t  ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ void *tmp___2 ;

  {
  tmp___2 = __kmalloc(size, flags);
  return (tmp___2);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  tmp = kmalloc(size, flags | 32768U);
  return (tmp);
}
}
__inline static struct apertures_struct *alloc_apertures(unsigned int max_num ) 
{ struct apertures_struct *a ;
  void *tmp ;

  {
  tmp = kzalloc((unsigned long )max_num * 16UL + 8UL, 208U);
  a = (struct apertures_struct *)tmp;
  if ((unsigned long )a == (unsigned long )((struct apertures_struct *)0)) {
    return (0);
  } else {

  }
  a->count = max_num;
  return (a);
}
}
extern void cfb_fillrect(struct fb_info * , struct fb_fillrect  const  * ) ;
extern void cfb_imageblit(struct fb_info * , struct fb_image  const  * ) ;
extern int unregister_framebuffer(struct fb_info * ) ;
extern struct fb_info *framebuffer_alloc(size_t  , struct device * ) ;
extern void framebuffer_release(struct fb_info * ) ;
extern int fb_alloc_cmap(struct fb_cmap * , int  , int  ) ;
extern void fb_dealloc_cmap(struct fb_cmap * ) ;
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ int tmp ;

  {
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
extern void drm_mode_config_init(struct drm_device * ) ;
extern void drm_mode_config_cleanup(struct drm_device * ) ;
extern int drm_framebuffer_init(struct drm_device * , struct drm_framebuffer * , struct drm_framebuffer_funcs  const  * ) ;
extern void drm_framebuffer_cleanup(struct drm_framebuffer * ) ;
extern struct drm_property *drm_property_create_range(struct drm_device * , int  ,
                                                      char const   * , uint64_t  ,
                                                      uint64_t  ) ;
extern int drm_mode_create_scaling_mode_property(struct drm_device * ) ;
extern uint32_t drm_mode_legacy_fb_format(uint32_t  , uint32_t  ) ;
extern void drm_fb_get_bpp_depth(uint32_t  , unsigned int * , int * ) ;
extern void drm_gem_object_free(struct kref * ) ;
extern int drm_gem_private_object_init(struct drm_device * , struct drm_gem_object * ,
                                       size_t  ) ;
__inline static void drm_gem_object_unreference(struct drm_gem_object *obj ) 
{ 

  {
  if ((unsigned long )obj != (unsigned long )((struct drm_gem_object *)0)) {
    kref_put(& obj->refcount, & drm_gem_object_free);
  } else {

  }
  return;
}
}
__inline static void drm_gem_object_unreference_unlocked(struct drm_gem_object *obj ) 
{ struct drm_device *dev ;

  {
  if ((unsigned long )obj != (unsigned long )((struct drm_gem_object *)0)) {
    dev = obj->dev;
    ldv_mutex_lock_59(& dev->struct_mutex);
    kref_put(& obj->refcount, & drm_gem_object_free);
    ldv_mutex_unlock_60(& dev->struct_mutex);
  } else {

  }
  return;
}
}
extern int drm_gem_handle_create(struct drm_file * , struct drm_gem_object * , u32 * ) ;
extern struct drm_gem_object *drm_gem_object_lookup(struct drm_device * , struct drm_file * ,
                                                    u32  ) ;
extern int drm_fb_helper_init(struct drm_device * , struct drm_fb_helper * , int  ,
                              int  ) ;
extern void drm_fb_helper_fini(struct drm_fb_helper * ) ;
extern int drm_fb_helper_blank(int  , struct fb_info * ) ;
extern int drm_fb_helper_set_par(struct fb_info * ) ;
extern int drm_fb_helper_check_var(struct fb_var_screeninfo * , struct fb_info * ) ;
extern bool drm_fb_helper_restore_fbdev_mode(struct drm_fb_helper * ) ;
extern void drm_fb_helper_fill_var(struct fb_info * , struct drm_fb_helper * , uint32_t  ,
                                   uint32_t  ) ;
extern void drm_fb_helper_fill_fix(struct fb_info * , uint32_t  , uint32_t  ) ;
extern int drm_fb_helper_hotplug_event(struct drm_fb_helper * ) ;
extern bool drm_fb_helper_initial_config(struct drm_fb_helper * , int  ) ;
extern int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper * ) ;
extern int drm_helper_mode_fill_fb_struct(struct drm_framebuffer * , struct drm_mode_fb_cmd2 * ) ;
extern void drm_kms_helper_poll_fini(struct drm_device * ) ;
void psb_intel_crtc_init(struct drm_device *dev , int pipe , struct psb_intel_mode_device *mode_dev ) ;
__inline static struct psb_intel_encoder *psb_intel_attached_encoder(struct drm_connector *connector ) 
{ struct drm_connector  const  *__mptr ;

  {
  __mptr = (struct drm_connector  const  *)connector;
  return (((struct psb_intel_connector *)__mptr)->encoder);
}
}
struct gtt_range *psb_gtt_alloc_range(struct drm_device *dev , int len , char const   *name ,
                                      int backed ) ;
void psb_gtt_free_range(struct drm_device *dev , struct gtt_range *gt ) ;
void psb_gtt_roll(struct drm_device *dev , struct gtt_range *r , int roll ) ;
void psb_modeset_init(struct drm_device *dev ) ;
void psb_modeset_cleanup(struct drm_device *dev ) ;
int psb_fbdev_init(struct drm_device *dev ) ;
int psb_intel_connector_clones(struct drm_device *dev , int type_mask ) ;
static void psb_user_framebuffer_destroy(struct drm_framebuffer *fb ) ;
static int psb_user_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                              unsigned int *handle ) ;
static struct drm_framebuffer_funcs  const  psb_fb_funcs  =    {& psb_user_framebuffer_destroy, & psb_user_framebuffer_create_handle, 0};
static int psbfb_setcolreg(unsigned int regno , unsigned int red , unsigned int green ,
                           unsigned int blue , unsigned int transp , struct fb_info *info ) 
{ struct psb_fbdev *fbdev ;
  struct drm_framebuffer *fb ;
  uint32_t v ;

  {
  fbdev = (struct psb_fbdev *)info->par;
  fb = fbdev->psb_fb_helper.fb;
  if ((unsigned long )fb == (unsigned long )((struct drm_framebuffer *)0)) {
    return (-12);
  } else {

  }
  if (regno > 255U) {
    return (1);
  } else {

  }
  red = (((red << (int )info->var.red.length) - red) + 32767U) >> 16;
  blue = (((blue << (int )info->var.blue.length) - blue) + 32767U) >> 16;
  green = (((green << (int )info->var.green.length) - green) + 32767U) >> 16;
  transp = (((transp << (int )info->var.transp.length) - transp) + 32767U) >> 16;
  v = (((red << (int )info->var.red.offset) | (green << (int )info->var.green.offset)) | (blue << (int )info->var.blue.offset)) | (transp << (int )info->var.transp.offset);
  if (regno <= 15U) {
    switch (fb->bits_per_pixel) {
    case 16: 
    *((uint32_t *)info->pseudo_palette + (unsigned long )regno) = v;
    goto ldv_39182;
    case 24: ;
    case 32: 
    *((uint32_t *)info->pseudo_palette + (unsigned long )regno) = v;
    goto ldv_39182;
    }
    ldv_39182: ;
  } else {

  }
  return (0);
}
}
static int psbfb_pan(struct fb_var_screeninfo *var , struct fb_info *info ) 
{ struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  int pages ;

  {
  fbdev = (struct psb_fbdev *)info->par;
  psbfb = & fbdev->pfb;
  dev = psbfb->base.dev;
  if ((psbfb->gtt)->npage != 0) {
    pages = (int )(info->fix.line_length >> 12);
    psb_gtt_roll(dev, psbfb->gtt, (int )(var->yoffset * (__u32 )pages));
  } else {

  }
  return (0);
}
}
static int psbfb_vm_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) 
{ struct psb_framebuffer *psbfb ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int page_num ;
  int i ;
  unsigned long address ;
  int ret ;
  unsigned long pfn ;
  unsigned long phys_addr ;
  pgprot_t __constr_expr_0 ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  psbfb = (struct psb_framebuffer *)vma->vm_private_data;
  dev = psbfb->base.dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  phys_addr = (unsigned long )dev_priv->stolen_base;
  page_num = (int )((vma->vm_end - vma->vm_start) >> 12);
  address = (unsigned long )vmf->virtual_address - (vmf->pgoff << 12);
  if ((unsigned int )boot_cpu_data.x86 > 3U) {
    __constr_expr_0.pgprot = vma->vm_page_prot.pgprot | 16UL;
    vma->vm_page_prot = __constr_expr_0;
  } else {
    vma->vm_page_prot = vma->vm_page_prot;
  }
  i = 0;
  goto ldv_39209;
  ldv_39208: 
  pfn = phys_addr >> 12;
  ret = vm_insert_mixed(vma, address, pfn);
  tmp___0 = ldv__builtin_expect(ret == -16, 0L);
  if (tmp___0 != 0L) {
    goto ldv_39207;
  } else {
    tmp___1 = ldv__builtin_expect(ret != 0, 0L);
    if (tmp___1 != 0L) {
      tmp___2 = ldv__builtin_expect(i > 0, 0L);
      if (tmp___2 != 0L) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
    if (tmp___3 != 0) {
      goto ldv_39207;
    } else {
      tmp = ldv__builtin_expect(ret != 0, 0L);
      if (tmp != 0L) {
        if (ret == -12) {
          ret = 1;
        } else {
          ret = 2;
        }
        return (ret);
      } else {

      }
    }
  }
  address = address + 4096UL;
  phys_addr = phys_addr + 4096UL;
  i = i + 1;
  ldv_39209: ;
  if (i < page_num) {
    goto ldv_39208;
  } else {
    goto ldv_39207;
  }
  ldv_39207: ;
  return (256);
}
}
static void psbfb_vm_open(struct vm_area_struct *vma ) 
{ 

  {
  return;
}
}
static void psbfb_vm_close(struct vm_area_struct *vma ) 
{ 

  {
  return;
}
}
static struct vm_operations_struct  const  psbfb_vm_ops  = 
     {& psbfb_vm_open, & psbfb_vm_close, & psbfb_vm_fault, 0, 0, 0, 0, 0, 0};
static int psbfb_mmap(struct fb_info *info , struct vm_area_struct *vma ) 
{ struct psb_fbdev *fbdev ;
  struct psb_framebuffer *psbfb ;

  {
  fbdev = (struct psb_fbdev *)info->par;
  psbfb = & fbdev->pfb;
  if (vma->vm_pgoff != 0UL) {
    return (-22);
  } else {

  }
  if (vma->vm_pgoff > 4503599627370495UL) {
    return (-22);
  } else {

  }
  if ((unsigned long )psbfb->addr_space == (unsigned long )((struct address_space *)0)) {
    psbfb->addr_space = (vma->vm_file)->f_mapping;
  } else {

  }
  vma->vm_ops = & psbfb_vm_ops;
  vma->vm_private_data = (void *)psbfb;
  vma->vm_flags = vma->vm_flags | 335822848UL;
  return (0);
}
}
static int psbfb_ioctl(struct fb_info *info , unsigned int cmd , unsigned long arg ) 
{ 

  {
  return (-25);
}
}
static struct fb_ops psbfb_ops  = 
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, 0, & cfb_fillrect, & psbfb_copyarea,
    & cfb_imageblit, 0, 0, & psbfb_sync, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0,
    0};
static struct fb_ops psbfb_roll_ops  = 
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, & psbfb_pan, & cfb_fillrect, & cfb_copyarea,
    & cfb_imageblit, 0, 0, 0, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0, 0};
static struct fb_ops psbfb_unaccel_ops  = 
     {& __this_module, 0, 0, 0, 0, & drm_fb_helper_check_var, & drm_fb_helper_set_par,
    & psbfb_setcolreg, 0, & drm_fb_helper_blank, 0, & cfb_fillrect, & cfb_copyarea,
    & cfb_imageblit, 0, 0, 0, & psbfb_ioctl, 0, & psbfb_mmap, 0, 0, 0, 0};
static int psb_framebuffer_init(struct drm_device *dev , struct psb_framebuffer *fb ,
                                struct drm_mode_fb_cmd2 *mode_cmd , struct gtt_range *gt ) 
{ u32 bpp ;
  u32 depth ;
  int ret ;

  {
  drm_fb_get_bpp_depth(mode_cmd->pixel_format, & depth, (int *)(& bpp));
  if ((mode_cmd->pitches[0] & 63U) != 0U) {
    return (-22);
  } else {

  }
  switch (bpp) {
  case 8: ;
  case 16: ;
  case 24: ;
  case 32: ;
  goto ldv_39244;
  default: ;
  return (-22);
  }
  ldv_39244: 
  ret = drm_framebuffer_init(dev, & fb->base, & psb_fb_funcs);
  if (ret != 0) {
    dev_err((struct device  const  *)dev->dev, "framebuffer init failed: %d\n", ret);
    return (ret);
  } else {

  }
  drm_helper_mode_fill_fb_struct(& fb->base, mode_cmd);
  fb->gtt = gt;
  return (0);
}
}
static struct drm_framebuffer *psb_framebuffer_create(struct drm_device *dev , struct drm_mode_fb_cmd2 *mode_cmd ,
                                                      struct gtt_range *gt ) 
{ struct psb_framebuffer *fb ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = kzalloc(160UL, 208U);
  fb = (struct psb_framebuffer *)tmp;
  if ((unsigned long )fb == (unsigned long )((struct psb_framebuffer *)0)) {
    tmp___0 = ERR_PTR(-12L);
    return ((struct drm_framebuffer *)tmp___0);
  } else {

  }
  ret = psb_framebuffer_init(dev, fb, mode_cmd, gt);
  if (ret != 0) {
    kfree((void const   *)fb);
    tmp___1 = ERR_PTR((long )ret);
    return ((struct drm_framebuffer *)tmp___1);
  } else {

  }
  return (& fb->base);
}
}
static struct gtt_range *psbfb_alloc(struct drm_device *dev , int aligned_size ) 
{ struct gtt_range *backing ;
  int tmp ;

  {
  backing = psb_gtt_alloc_range(dev, aligned_size, "fb", 1);
  if ((unsigned long )backing != (unsigned long )((struct gtt_range *)0)) {
    tmp = drm_gem_private_object_init(dev, & backing->gem, (size_t )aligned_size);
    if (tmp == 0) {
      return (backing);
    } else {

    }
    psb_gtt_free_range(dev, backing);
  } else {

  }
  return (0);
}
}
static int psbfb_create(struct psb_fbdev *fbdev , struct drm_fb_helper_surface_size *sizes ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct fb_info *info ;
  struct drm_framebuffer *fb ;
  struct psb_framebuffer *psbfb ;
  struct drm_mode_fb_cmd2 mode_cmd ;
  struct device *device ;
  int size ;
  int ret ;
  struct gtt_range *backing ;
  u32 bpp ;
  u32 depth ;
  int gtt_roll ;
  int pitch_lines ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  dev = fbdev->psb_fb_helper.dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  psbfb = & fbdev->pfb;
  device = & (dev->pdev)->dev;
  gtt_roll = 0;
  pitch_lines = 0;
  mode_cmd.width = sizes->surface_width;
  mode_cmd.height = sizes->surface_height;
  bpp = sizes->surface_bpp;
  depth = sizes->surface_depth;
  if (bpp == 24U) {
    bpp = 32U;
  } else {

  }
  ldv_39276: 
  mode_cmd.pitches[0] = ((mode_cmd.width * ((bpp + 7U) / 8U) + (__u32 )(4096 >> pitch_lines)) - 1U) & - ((unsigned int )(4096 >> pitch_lines));
  size = (int )(mode_cmd.pitches[0] * mode_cmd.height);
  size = (size + 4095) & -4096;
  backing = psbfb_alloc(dev, size);
  if (pitch_lines != 0) {
    pitch_lines = pitch_lines * 2;
  } else {
    pitch_lines = 1;
  }
  gtt_roll = gtt_roll + 1;
  if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0) && pitch_lines <= 16) {
    goto ldv_39276;
  } else {
    goto ldv_39277;
  }
  ldv_39277: 
  pitch_lines = pitch_lines / 2;
  if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0)) {
    gtt_roll = 0;
    pitch_lines = 64;
    mode_cmd.pitches[0] = (mode_cmd.width * ((bpp + 7U) / 8U) + 63U) & 4294967232U;
    size = (int )(mode_cmd.pitches[0] * mode_cmd.height);
    size = (size + 4095) & -4096;
    backing = psbfb_alloc(dev, size);
    if ((unsigned long )backing == (unsigned long )((struct gtt_range *)0)) {
      return (-12);
    } else {

    }
  } else {

  }
  memset((void *)dev_priv->vram_addr + (unsigned long )backing->offset, 0, (size_t )size);
  ldv_mutex_lock_61(& dev->struct_mutex);
  info = framebuffer_alloc(0UL, device);
  if ((unsigned long )info == (unsigned long )((struct fb_info *)0)) {
    ret = -12;
    goto out_err1;
  } else {

  }
  info->par = (void *)fbdev;
  mode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);
  ret = psb_framebuffer_init(dev, psbfb, & mode_cmd, backing);
  if (ret != 0) {
    goto out_unref;
  } else {

  }
  fb = & psbfb->base;
  psbfb->fbdev = info;
  fbdev->psb_fb_helper.fb = fb;
  fbdev->psb_fb_helper.fbdev = info;
  drm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);
  strcpy((char *)(& info->fix.id), "psbfb");
  info->flags = 1;
  if ((unsigned int )*((unsigned char *)dev_priv->ops + 8UL) != 0U && pitch_lines > 8) {
    info->fbops = & psbfb_ops;
  } else
  if (gtt_roll != 0) {
    info->fbops = & psbfb_roll_ops;
    info->flags = info->flags | 8192;
  } else {
    info->fbops = & psbfb_unaccel_ops;
  }
  ret = fb_alloc_cmap(& info->cmap, 256, 0);
  if (ret != 0) {
    ret = -12;
    goto out_unref;
  } else {

  }
  info->fix.smem_start = (unsigned long )dev->mode_config.fb_base;
  info->fix.smem_len = (__u32 )size;
  info->fix.ywrapstep = (__u16 )gtt_roll;
  info->fix.ypanstep = 0U;
  info->screen_base = (char *)dev_priv->vram_addr + (unsigned long )backing->offset;
  info->screen_size = (unsigned long )size;
  if (dev_priv->gtt.stolen_size != 0UL) {
    info->apertures = alloc_apertures(1U);
    if ((unsigned long )info->apertures == (unsigned long )((struct apertures_struct *)0)) {
      ret = -12;
      goto out_unref;
    } else {

    }
    (info->apertures)->ranges[0].base = dev->mode_config.fb_base;
    (info->apertures)->ranges[0].size = (resource_size_t )dev_priv->gtt.stolen_size;
  } else {

  }
  drm_fb_helper_fill_var(info, & fbdev->psb_fb_helper, sizes->fb_width, sizes->fb_height);
  info->fix.mmio_start = (unsigned long )(dev->pdev)->resource[0].start;
  if ((dev->pdev)->resource[0].start != 0ULL || (dev->pdev)->resource[0].end != (dev->pdev)->resource[0].start) {
    info->fix.mmio_len = ((__u32 )(dev->pdev)->resource[0].end - (__u32 )(dev->pdev)->resource[0].start) + 1U;
  } else {
    info->fix.mmio_len = 0U;
  }
  descriptor.modname = "gma500_gfx";
  descriptor.function = "psbfb_create";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c.prepared";
  descriptor.format = "allocated %dx%d fb\n";
  descriptor.lineno = 623U;
  descriptor.flags = 0U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "allocated %dx%d fb\n",
                      psbfb->base.width, psbfb->base.height);
  } else {

  }
  ldv_mutex_unlock_62(& dev->struct_mutex);
  return (0);
  out_unref: ;
  if ((int )backing->stolen) {
    psb_gtt_free_range(dev, backing);
  } else {
    drm_gem_object_unreference(& backing->gem);
  }
  out_err1: 
  ldv_mutex_unlock_63(& dev->struct_mutex);
  psb_gtt_free_range(dev, backing);
  return (ret);
}
}
static struct drm_framebuffer *psb_user_framebuffer_create(struct drm_device *dev ,
                                                           struct drm_file *filp ,
                                                           struct drm_mode_fb_cmd2 *cmd ) 
{ struct gtt_range *r ;
  struct drm_gem_object *obj ;
  void *tmp ;
  struct drm_gem_object  const  *__mptr ;
  struct drm_framebuffer *tmp___0 ;

  {
  obj = drm_gem_object_lookup(dev, filp, cmd->handles[0]);
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
    tmp = ERR_PTR(-2L);
    return ((struct drm_framebuffer *)tmp);
  } else {

  }
  __mptr = (struct drm_gem_object  const  *)obj;
  r = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
  tmp___0 = psb_framebuffer_create(dev, cmd, r);
  return (tmp___0);
}
}
static void psbfb_gamma_set(struct drm_crtc *crtc , u16 red , u16 green , u16 blue ,
                            int regno ) 
{ struct psb_intel_crtc *intel_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  intel_crtc = (struct psb_intel_crtc *)__mptr;
  intel_crtc->lut_r[regno] = (u8 )((int )red >> 8);
  intel_crtc->lut_g[regno] = (u8 )((int )green >> 8);
  intel_crtc->lut_b[regno] = (u8 )((int )blue >> 8);
  return;
}
}
static void psbfb_gamma_get(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                            int regno ) 
{ struct psb_intel_crtc *intel_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  intel_crtc = (struct psb_intel_crtc *)__mptr;
  *red = (int )((u16 )intel_crtc->lut_r[regno]) << 8U;
  *green = (int )((u16 )intel_crtc->lut_g[regno]) << 8U;
  *blue = (int )((u16 )intel_crtc->lut_b[regno]) << 8U;
  return;
}
}
static int psbfb_probe(struct drm_fb_helper *helper , struct drm_fb_helper_surface_size *sizes ) 
{ struct psb_fbdev *psb_fbdev ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int new_fb ;
  int bytespp ;
  int ret ;

  {
  psb_fbdev = (struct psb_fbdev *)helper;
  dev = psb_fbdev->psb_fb_helper.dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  new_fb = 0;
  bytespp = (int )(sizes->surface_bpp / 8U);
  if (bytespp == 3) {
    bytespp = 4;
  } else {

  }
  if ((unsigned long )(((sizes->fb_width * (u32 )bytespp + 63U) & 4294967232U) * sizes->fb_height) > dev_priv->vram_stolen_size) {
    sizes->surface_bpp = 16U;
    sizes->surface_depth = 16U;
  } else {

  }
  if ((unsigned long )helper->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    ret = psbfb_create(psb_fbdev, sizes);
    if (ret != 0) {
      return (ret);
    } else {

    }
    new_fb = 1;
  } else {

  }
  return (new_fb);
}
}
static struct drm_fb_helper_funcs psb_fb_helper_funcs  =    {& psbfb_gamma_set, & psbfb_gamma_get, & psbfb_probe};
static int psb_fbdev_destroy(struct drm_device *dev , struct psb_fbdev *fbdev ) 
{ struct fb_info *info ;
  struct psb_framebuffer *psbfb ;

  {
  psbfb = & fbdev->pfb;
  if ((unsigned long )fbdev->psb_fb_helper.fbdev != (unsigned long )((struct fb_info *)0)) {
    info = fbdev->psb_fb_helper.fbdev;
    unregister_framebuffer(info);
    if (info->cmap.len != 0U) {
      fb_dealloc_cmap(& info->cmap);
    } else {

    }
    framebuffer_release(info);
  } else {

  }
  drm_fb_helper_fini(& fbdev->psb_fb_helper);
  drm_framebuffer_cleanup(& psbfb->base);
  if ((unsigned long )psbfb->gtt != (unsigned long )((struct gtt_range *)0)) {
    drm_gem_object_unreference(& (psbfb->gtt)->gem);
  } else {

  }
  return (0);
}
}
int psb_fbdev_init(struct drm_device *dev ) 
{ struct psb_fbdev *fbdev ;
  struct drm_psb_private *dev_priv ;
  void *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = kzalloc(336UL, 208U);
  fbdev = (struct psb_fbdev *)tmp;
  if ((unsigned long )fbdev == (unsigned long )((struct psb_fbdev *)0)) {
    dev_err((struct device  const  *)dev->dev, "no memory\n");
    return (-12);
  } else {

  }
  dev_priv->fbdev = (void *)fbdev;
  fbdev->psb_fb_helper.funcs = & psb_fb_helper_funcs;
  drm_fb_helper_init(dev, & fbdev->psb_fb_helper, (dev_priv->ops)->crtcs, 4);
  drm_fb_helper_single_add_all_connectors(& fbdev->psb_fb_helper);
  drm_fb_helper_initial_config(& fbdev->psb_fb_helper, 32);
  return (0);
}
}
static void psb_fbdev_fini(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((unsigned long )dev_priv->fbdev == (unsigned long )((void *)0)) {
    return;
  } else {

  }
  psb_fbdev_destroy(dev, (struct psb_fbdev *)dev_priv->fbdev);
  kfree((void const   *)dev_priv->fbdev);
  dev_priv->fbdev = 0;
  return;
}
}
static void psbfb_output_poll_changed(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_fbdev *fbdev ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  fbdev = (struct psb_fbdev *)dev_priv->fbdev;
  drm_fb_helper_hotplug_event(& fbdev->psb_fb_helper);
  return;
}
}
static int psb_user_framebuffer_create_handle(struct drm_framebuffer *fb , struct drm_file *file_priv ,
                                              unsigned int *handle ) 
{ struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct gtt_range *r ;
  int tmp ;

  {
  __mptr = (struct drm_framebuffer  const  *)fb;
  psbfb = (struct psb_framebuffer *)__mptr;
  r = psbfb->gtt;
  tmp = drm_gem_handle_create(file_priv, & r->gem, handle);
  return (tmp);
}
}
static void psb_user_framebuffer_destroy(struct drm_framebuffer *fb ) 
{ struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr ;
  struct gtt_range *r ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_fbdev *fbdev ;
  struct drm_crtc *crtc ;
  int reset ;
  int __ret_warn_on ;
  long tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  __mptr = (struct drm_framebuffer  const  *)fb;
  psbfb = (struct psb_framebuffer *)__mptr;
  r = psbfb->gtt;
  dev = fb->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  fbdev = (struct psb_fbdev *)dev_priv->fbdev;
  reset = 0;
  __ret_warn_on = (int )r->stolen;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/framebuffer.c.prepared",
                       822);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __mptr___0 = (struct list_head  const  *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
  goto ldv_39370;
  ldv_39369: ;
  if ((unsigned long )crtc->fb == (unsigned long )fb) {
    reset = 1;
  } else {

  }
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_39370: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_39369;
  } else {
    goto ldv_39371;
  }
  ldv_39371: ;
  if (reset != 0) {
    drm_fb_helper_restore_fbdev_mode(& fbdev->psb_fb_helper);
  } else {

  }
  drm_framebuffer_cleanup(fb);
  drm_gem_object_unreference_unlocked(& r->gem);
  kfree((void const   *)fb);
  return;
}
}
static struct drm_mode_config_funcs  const  psb_mode_funcs  =    {& psb_user_framebuffer_create, & psbfb_output_poll_changed};
static int psb_create_backlight_property(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_property *backlight ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((unsigned long )dev_priv->backlight_property != (unsigned long )((struct drm_property *)0)) {
    return (0);
  } else {

  }
  backlight = drm_property_create_range(dev, 0, "backlight", 0ULL, 100ULL);
  dev_priv->backlight_property = backlight;
  return (0);
}
}
static void psb_setup_outputs(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_connector *connector ;
  struct list_head  const  *__mptr ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct drm_encoder *encoder ;
  int crtc_mask ;
  int clone_mask ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  drm_mode_create_scaling_mode_property(dev);
  psb_create_backlight_property(dev);
  (*((dev_priv->ops)->output_init))(dev);
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
  connector = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
  goto ldv_39401;
  ldv_39400: 
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  encoder = & psb_intel_encoder->base;
  crtc_mask = 0;
  clone_mask = 0;
  switch (psb_intel_encoder->type) {
  case 1: 
  crtc_mask = 1;
  clone_mask = 2;
  goto ldv_39392;
  case 3: 
  crtc_mask = 3;
  clone_mask = 8;
  goto ldv_39392;
  case 4: 
  crtc_mask = (dev_priv->ops)->lvds_mask;
  clone_mask = 16;
  goto ldv_39392;
  case 7: 
  crtc_mask = 1;
  clone_mask = 128;
  goto ldv_39392;
  case 8: 
  crtc_mask = 4;
  clone_mask = 256;
  goto ldv_39392;
  case 6: 
  crtc_mask = (dev_priv->ops)->hdmi_mask;
  clone_mask = 64;
  goto ldv_39392;
  case 9: 
  crtc_mask = 3;
  clone_mask = 512;
  goto ldv_39392;
  case 10: 
  crtc_mask = 2;
  clone_mask = 1024;
  }
  ldv_39392: 
  encoder->possible_crtcs = (uint32_t )crtc_mask;
  tmp___0 = psb_intel_connector_clones(dev, clone_mask);
  encoder->possible_clones = (uint32_t )tmp___0;
  __mptr___0 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  ldv_39401: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
    goto ldv_39400;
  } else {
    goto ldv_39402;
  }
  ldv_39402: ;
  return;
}
}
void psb_modeset_init(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  int i ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  drm_mode_config_init(dev);
  dev->mode_config.min_width = 0;
  dev->mode_config.min_height = 0;
  dev->mode_config.funcs = & psb_mode_funcs;
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 92, (u32 *)(& dev->mode_config.fb_base));
  i = 0;
  goto ldv_39410;
  ldv_39409: 
  psb_intel_crtc_init(dev, i, mode_dev);
  i = i + 1;
  ldv_39410: ;
  if ((uint32_t )i < dev_priv->num_pipe) {
    goto ldv_39409;
  } else {
    goto ldv_39411;
  }
  ldv_39411: 
  dev->mode_config.max_width = 2048;
  dev->mode_config.max_height = 2048;
  psb_setup_outputs(dev);
  if ((unsigned long )(dev_priv->ops)->errata != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
    (*((dev_priv->ops)->errata))(dev);
  } else {

  }
  dev_priv->modeset = 1;
  return;
}
}
void psb_modeset_cleanup(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((int )dev_priv->modeset) {
    ldv_mutex_lock_64(& dev->struct_mutex);
    drm_kms_helper_poll_fini(dev);
    psb_fbdev_fini(dev);
    drm_mode_config_cleanup(dev);
    ldv_mutex_unlock_65(& dev->struct_mutex);
  } else {

  }
  return;
}
}
struct fb_var_screeninfo *ldvarg131  ;
unsigned int ldvarg134  ;
struct fb_copyarea *ldvarg106  ;
unsigned int ldvarg101  ;
unsigned int ldvarg67  ;
u16 *ldvarg178  ;
unsigned int ldvarg71  ;
struct fb_var_screeninfo *psbfb_roll_ops_group0  ;
struct fb_copyarea *ldvarg141  ;
unsigned int ldvarg100  ;
struct fb_image *ldvarg72  ;
struct fb_info *psbfb_ops_group0  ;
unsigned int ldvarg136  ;
struct fb_info *psbfb_roll_ops_group1  ;
unsigned int *ldvarg181  ;
unsigned long ldvarg98  ;
int ldvarg97  ;
struct fb_info *psbfb_unaccel_ops_group0  ;
u16 ldvarg174  ;
struct vm_area_struct *psbfb_vm_ops_group0  ;
int ldvarg64  ;
struct vm_fault *ldvarg155  ;
unsigned int ldvarg103  ;
struct fb_fillrect *ldvarg95  ;
struct fb_image *ldvarg140  ;
struct fb_image *ldvarg105  ;
unsigned int ldvarg69  ;
int ldvarg132  ;
struct drm_fb_helper *ldvarg170  ;
struct drm_file *ldvarg182  ;
unsigned int ldvarg138  ;
struct vm_area_struct *ldvarg107  ;
struct drm_crtc *psb_fb_helper_funcs_group0  ;
struct vm_area_struct *ldvarg142  ;
struct drm_mode_fb_cmd2 *ldvarg121  ;
int ldvarg175  ;
unsigned int ldvarg104  ;
unsigned int ldvarg137  ;
struct drm_file *ldvarg122  ;
u16 ldvarg172  ;
struct drm_device *psb_mode_funcs_group0  ;
u16 *ldvarg177  ;
unsigned long ldvarg65  ;
unsigned int ldvarg102  ;
unsigned int ldvarg135  ;
unsigned int ldvarg66  ;
struct fb_var_screeninfo *ldvarg96  ;
unsigned int ldvarg99  ;
struct fb_fillrect *ldvarg63  ;
struct fb_copyarea *ldvarg73  ;
unsigned int ldvarg70  ;
u16 *ldvarg176  ;
unsigned long ldvarg133  ;
unsigned int ldvarg68  ;
u16 ldvarg173  ;
int ldvarg179  ;
struct drm_fb_helper_surface_size *ldvarg171  ;
struct drm_framebuffer *psb_fb_funcs_group0  ;
extern int ldv_psb_fb_funcs_probe_52(void) ;
struct fb_fillrect *ldvarg130  ;
struct vm_area_struct *ldvarg74  ;
unsigned int ldvarg139  ;
void ldv_main_exported_52(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_52 == 2) {
    psb_user_framebuffer_destroy(psb_fb_funcs_group0);
    ldv_state_variable_52 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_39483;
  case 1: ;
  if (ldv_state_variable_52 == 2) {
    psb_user_framebuffer_create_handle(psb_fb_funcs_group0, ldvarg182, ldvarg181);
    ldv_state_variable_52 = 2;
  } else {

  }
  if (ldv_state_variable_52 == 1) {
    psb_user_framebuffer_create_handle(psb_fb_funcs_group0, ldvarg182, ldvarg181);
    ldv_state_variable_52 = 1;
  } else {

  }
  goto ldv_39483;
  case 2: ;
  if (ldv_state_variable_52 == 1) {
    ldv_psb_fb_funcs_probe_52();
    ldv_state_variable_52 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_39483;
  default: ;
  goto ldv_39483;
  }
  ldv_39483: ;
  return;
}
}
void ldv_main_exported_50(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_50 == 1) {
    psbfb_mmap(psbfb_ops_group0, ldvarg142);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 1: ;
  if (ldv_state_variable_50 == 1) {
    psbfb_copyarea(psbfb_ops_group0, (struct fb_copyarea  const  *)ldvarg141);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 2: ;
  if (ldv_state_variable_50 == 1) {
    psbfb_sync(psbfb_ops_group0);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 3: ;
  if (ldv_state_variable_50 == 1) {
    cfb_imageblit(psbfb_ops_group0, (struct fb_image  const  *)ldvarg140);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 4: ;
  if (ldv_state_variable_50 == 1) {
    drm_fb_helper_set_par(psbfb_ops_group0);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 5: ;
  if (ldv_state_variable_50 == 1) {
    psbfb_setcolreg(ldvarg136, ldvarg138, ldvarg137, ldvarg135, ldvarg139, psbfb_ops_group0);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 6: ;
  if (ldv_state_variable_50 == 1) {
    psbfb_ioctl(psbfb_ops_group0, ldvarg134, ldvarg133);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 7: ;
  if (ldv_state_variable_50 == 1) {
    drm_fb_helper_blank(ldvarg132, psbfb_ops_group0);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 8: ;
  if (ldv_state_variable_50 == 1) {
    drm_fb_helper_check_var(ldvarg131, psbfb_ops_group0);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  case 9: ;
  if (ldv_state_variable_50 == 1) {
    cfb_fillrect(psbfb_ops_group0, (struct fb_fillrect  const  *)ldvarg130);
    ldv_state_variable_50 = 1;
  } else {

  }
  goto ldv_39491;
  default: ;
  goto ldv_39491;
  }
  ldv_39491: ;
  return;
}
}
void ldv_main_exported_49(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_49 == 1) {
    psbfb_mmap(psbfb_roll_ops_group1, ldvarg74);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 1: ;
  if (ldv_state_variable_49 == 1) {
    psbfb_pan(psbfb_roll_ops_group0, psbfb_roll_ops_group1);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 2: ;
  if (ldv_state_variable_49 == 1) {
    cfb_copyarea(psbfb_roll_ops_group1, (struct fb_copyarea  const  *)ldvarg73);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 3: ;
  if (ldv_state_variable_49 == 1) {
    cfb_imageblit(psbfb_roll_ops_group1, (struct fb_image  const  *)ldvarg72);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 4: ;
  if (ldv_state_variable_49 == 1) {
    drm_fb_helper_set_par(psbfb_roll_ops_group1);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 5: ;
  if (ldv_state_variable_49 == 1) {
    psbfb_setcolreg(ldvarg68, ldvarg70, ldvarg69, ldvarg67, ldvarg71, psbfb_roll_ops_group1);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 6: ;
  if (ldv_state_variable_49 == 1) {
    psbfb_ioctl(psbfb_roll_ops_group1, ldvarg66, ldvarg65);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 7: ;
  if (ldv_state_variable_49 == 1) {
    drm_fb_helper_blank(ldvarg64, psbfb_roll_ops_group1);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 8: ;
  if (ldv_state_variable_49 == 1) {
    drm_fb_helper_check_var(psbfb_roll_ops_group0, psbfb_roll_ops_group1);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  case 9: ;
  if (ldv_state_variable_49 == 1) {
    cfb_fillrect(psbfb_roll_ops_group1, (struct fb_fillrect  const  *)ldvarg63);
    ldv_state_variable_49 = 1;
  } else {

  }
  goto ldv_39506;
  default: ;
  goto ldv_39506;
  }
  ldv_39506: ;
  return;
}
}
void ldv_main_exported_46(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_46 == 1) {
    psb_user_framebuffer_create(psb_mode_funcs_group0, ldvarg122, ldvarg121);
    ldv_state_variable_46 = 1;
  } else {

  }
  goto ldv_39521;
  case 1: ;
  if (ldv_state_variable_46 == 1) {
    psbfb_output_poll_changed(psb_mode_funcs_group0);
    ldv_state_variable_46 = 1;
  } else {

  }
  goto ldv_39521;
  default: ;
  goto ldv_39521;
  }
  ldv_39521: ;
  return;
}
}
void ldv_main_exported_51(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_51 == 2) {
    psbfb_vm_fault(psbfb_vm_ops_group0, ldvarg155);
    ldv_state_variable_51 = 2;
  } else {

  }
  if (ldv_state_variable_51 == 1) {
    psbfb_vm_fault(psbfb_vm_ops_group0, ldvarg155);
    ldv_state_variable_51 = 1;
  } else {

  }
  goto ldv_39528;
  case 1: ;
  if (ldv_state_variable_51 == 2) {
    psbfb_vm_close(psbfb_vm_ops_group0);
    ldv_state_variable_51 = 1;
  } else {

  }
  goto ldv_39528;
  case 2: ;
  if (ldv_state_variable_51 == 1) {
    psbfb_vm_open(psbfb_vm_ops_group0);
    ldv_state_variable_51 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_39528;
  default: ;
  goto ldv_39528;
  }
  ldv_39528: ;
  return;
}
}
void ldv_main_exported_48(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_48 == 1) {
    psbfb_mmap(psbfb_unaccel_ops_group0, ldvarg107);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  case 1: ;
  if (ldv_state_variable_48 == 1) {
    cfb_copyarea(psbfb_unaccel_ops_group0, (struct fb_copyarea  const  *)ldvarg106);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  case 2: ;
  if (ldv_state_variable_48 == 1) {
    cfb_imageblit(psbfb_unaccel_ops_group0, (struct fb_image  const  *)ldvarg105);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  case 3: ;
  if (ldv_state_variable_48 == 1) {
    drm_fb_helper_set_par(psbfb_unaccel_ops_group0);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  case 4: ;
  if (ldv_state_variable_48 == 1) {
    psbfb_setcolreg(ldvarg101, ldvarg103, ldvarg102, ldvarg100, ldvarg104, psbfb_unaccel_ops_group0);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  case 5: ;
  if (ldv_state_variable_48 == 1) {
    psbfb_ioctl(psbfb_unaccel_ops_group0, ldvarg99, ldvarg98);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  case 6: ;
  if (ldv_state_variable_48 == 1) {
    drm_fb_helper_blank(ldvarg97, psbfb_unaccel_ops_group0);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  case 7: ;
  if (ldv_state_variable_48 == 1) {
    drm_fb_helper_check_var(ldvarg96, psbfb_unaccel_ops_group0);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  case 8: ;
  if (ldv_state_variable_48 == 1) {
    cfb_fillrect(psbfb_unaccel_ops_group0, (struct fb_fillrect  const  *)ldvarg95);
    ldv_state_variable_48 = 1;
  } else {

  }
  goto ldv_39536;
  default: ;
  goto ldv_39536;
  }
  ldv_39536: ;
  return;
}
}
void ldv_main_exported_47(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_47 == 1) {
    psbfb_gamma_get(psb_fb_helper_funcs_group0, ldvarg178, ldvarg177, ldvarg176, ldvarg179);
    ldv_state_variable_47 = 1;
  } else {

  }
  goto ldv_39550;
  case 1: ;
  if (ldv_state_variable_47 == 1) {
    psbfb_gamma_set(psb_fb_helper_funcs_group0, (int )ldvarg174, (int )ldvarg173,
                    (int )ldvarg172, ldvarg175);
    ldv_state_variable_47 = 1;
  } else {

  }
  goto ldv_39550;
  case 2: ;
  if (ldv_state_variable_47 == 1) {
    psbfb_probe(ldvarg170, ldvarg171);
    ldv_state_variable_47 = 1;
  } else {

  }
  goto ldv_39550;
  default: ;
  goto ldv_39550;
  }
  ldv_39550: ;
  return;
}
}
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_52(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_53(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_54(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_55(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_56(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_57(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_58(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_59(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_60(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_62(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_63(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_64(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_65(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_86(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_84(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_87(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_89(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_83(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_85(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_88(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_90(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_97(struct mutex *ldv_func_arg1 ) ;
extern int vm_insert_pfn(struct vm_area_struct * , unsigned long  , unsigned long  ) ;
__inline static void mapping_set_gfp_mask(struct address_space *m , gfp_t mask ) 
{ 

  {
  m->flags = (m->flags & 0xfffffffffe000000UL) | (unsigned long )mask;
  return;
}
}
extern void drm_gem_object_release(struct drm_gem_object * ) ;
extern int drm_gem_object_init(struct drm_device * , struct drm_gem_object * , size_t  ) ;
extern int drm_gem_handle_delete(struct drm_file * , u32  ) ;
extern void drm_gem_free_mmap_offset(struct drm_gem_object * ) ;
extern int drm_gem_create_mmap_offset(struct drm_gem_object * ) ;
int psb_gtt_pin(struct gtt_range *gt ) ;
int psb_gem_init_object(struct drm_gem_object *obj ) ;
void psb_gem_free_object(struct drm_gem_object *obj ) ;
int psb_gem_get_aperture(struct drm_device *dev , void *data , struct drm_file *file ) ;
int psb_gem_dumb_create(struct drm_file *file , struct drm_device *dev , struct drm_mode_create_dumb *args ) ;
int psb_gem_dumb_destroy(struct drm_file *file , struct drm_device *dev , uint32_t handle ) ;
int psb_gem_dumb_map_gtt(struct drm_file *file , struct drm_device *dev , uint32_t handle ,
                         uint64_t *offset ) ;
int psb_gem_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
int psb_gem_create_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int psb_gem_mmap_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) ;
int psb_gem_init_object(struct drm_gem_object *obj ) 
{ 

  {
  return (-22);
}
}
void psb_gem_free_object(struct drm_gem_object *obj ) 
{ struct gtt_range *gtt ;
  struct drm_gem_object  const  *__mptr ;

  {
  __mptr = (struct drm_gem_object  const  *)obj;
  gtt = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
  if ((unsigned long )obj->map_list.map != (unsigned long )((struct drm_local_map *)0)) {
    drm_gem_free_mmap_offset(obj);
  } else {

  }
  drm_gem_object_release(obj);
  psb_gtt_free_range(obj->dev, gtt);
  return;
}
}
int psb_gem_get_aperture(struct drm_device *dev , void *data , struct drm_file *file ) 
{ 

  {
  return (-22);
}
}
int psb_gem_dumb_map_gtt(struct drm_file *file , struct drm_device *dev , uint32_t handle ,
                         uint64_t *offset ) 
{ int ret ;
  struct drm_gem_object *obj ;

  {
  ret = 0;
  if (((dev->driver)->driver_features & 4096U) == 0U) {
    return (-19);
  } else {

  }
  ldv_mutex_lock_95(& dev->struct_mutex);
  obj = drm_gem_object_lookup(dev, file, handle);
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
    ret = -2;
    goto unlock;
  } else {

  }
  if ((unsigned long )obj->map_list.map == (unsigned long )((struct drm_local_map *)0)) {
    ret = drm_gem_create_mmap_offset(obj);
    if (ret != 0) {
      goto out;
    } else {

    }
  } else {

  }
  *offset = (unsigned long long )obj->map_list.hash.key << 12;
  out: 
  drm_gem_object_unreference(obj);
  unlock: 
  ldv_mutex_unlock_96(& dev->struct_mutex);
  return (ret);
}
}
static int psb_gem_create(struct drm_file *file , struct drm_device *dev , uint64_t size ,
                          uint32_t *handlep ) 
{ struct gtt_range *r ;
  int ret ;
  u32 handle ;
  unsigned long __y ;
  int tmp ;

  {
  __y = 4096UL;
  size = ((((unsigned long long )__y + size) - 1ULL) / (unsigned long long )__y) * (unsigned long long )__y;
  r = psb_gtt_alloc_range(dev, (int )size, "gem", 0);
  if ((unsigned long )r == (unsigned long )((struct gtt_range *)0)) {
    dev_err((struct device  const  *)dev->dev, "no memory for %lld byte GEM object\n",
            size);
    return (-28);
  } else {

  }
  tmp = drm_gem_object_init(dev, & r->gem, (size_t )size);
  if (tmp != 0) {
    psb_gtt_free_range(dev, r);
    dev_err((struct device  const  *)dev->dev, "GEM init failed for %lld\n", size);
    return (-12);
  } else {

  }
  mapping_set_gfp_mask((r->gem.filp)->f_mapping, 212U);
  ret = drm_gem_handle_create(file, & r->gem, & handle);
  if (ret != 0) {
    dev_err((struct device  const  *)dev->dev, "GEM handle failed for %p, %lld\n",
            & r->gem, size);
    drm_gem_object_release(& r->gem);
    psb_gtt_free_range(dev, r);
    return (ret);
  } else {

  }
  drm_gem_object_unreference(& r->gem);
  *handlep = handle;
  return (0);
}
}
int psb_gem_dumb_create(struct drm_file *file , struct drm_device *dev , struct drm_mode_create_dumb *args ) 
{ int tmp ;

  {
  args->pitch = (args->width * ((args->bpp + 7U) / 8U) + 63U) & 4294967232U;
  args->size = (uint64_t )(args->pitch * args->height);
  tmp = psb_gem_create(file, dev, args->size, & args->handle);
  return (tmp);
}
}
int psb_gem_dumb_destroy(struct drm_file *file , struct drm_device *dev , uint32_t handle ) 
{ int tmp ;

  {
  tmp = drm_gem_handle_delete(file, handle);
  return (tmp);
}
}
int psb_gem_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) 
{ struct drm_gem_object *obj ;
  struct gtt_range *r ;
  int ret ;
  unsigned long pfn ;
  unsigned long page_offset___0 ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_gem_object  const  *__mptr ;

  {
  obj = (struct drm_gem_object *)vma->vm_private_data;
  dev = obj->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_gem_object  const  *)obj;
  r = (struct gtt_range *)__mptr + 0xffffffffffffffc0UL;
  ldv_mutex_lock_97(& dev->struct_mutex);
  if (! r->mmapping) {
    ret = psb_gtt_pin(r);
    if (ret < 0) {
      dev_err((struct device  const  *)dev->dev, "gma500: pin failed: %d\n", ret);
      goto fail;
    } else {

    }
    r->mmapping = 1;
  } else {

  }
  page_offset___0 = ((unsigned long )vmf->virtual_address - vma->vm_start) >> 12;
  if ((int )r->stolen) {
    pfn = (unsigned long )((dev_priv->stolen_base + r->offset) >> 12);
  } else {
    pfn = (unsigned long )(((long )*(r->pages + page_offset___0) + 24189255811072L) / 80L);
  }
  ret = vm_insert_pfn(vma, (unsigned long )vmf->virtual_address, pfn);
  fail: 
  ldv_mutex_unlock_98(& dev->struct_mutex);
  switch (ret) {
  case 0: ;
  case -512: ;
  case -4: ;
  return (256);
  case -12: ;
  return (1);
  default: ;
  return (2);
  }
}
}
static int psb_gem_create_stolen(struct drm_file *file , struct drm_device *dev ,
                                 int size , u32 *handle ) 
{ struct gtt_range *gtt ;
  struct gtt_range *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = psb_gtt_alloc_range(dev, size, "gem", 1);
  gtt = tmp;
  if ((unsigned long )gtt == (unsigned long )((struct gtt_range *)0)) {
    return (-12);
  } else {

  }
  tmp___0 = drm_gem_private_object_init(dev, & gtt->gem, (size_t )size);
  if (tmp___0 != 0) {
    goto free_gtt;
  } else {

  }
  tmp___1 = drm_gem_handle_create(file, & gtt->gem, handle);
  if (tmp___1 == 0) {
    return (0);
  } else {

  }
  free_gtt: 
  psb_gtt_free_range(dev, gtt);
  return (-12);
}
}
int psb_gem_create_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) 
{ struct drm_psb_gem_create *args ;
  int ret ;
  int tmp ;

  {
  args = (struct drm_psb_gem_create *)data;
  if ((int )args->flags & 1) {
    ret = psb_gem_create_stolen(file, dev, (int )args->size, & args->handle);
    if (ret == 0) {
      return (0);
    } else {

    }
    args->flags = args->flags & 4294967294U;
  } else {

  }
  tmp = psb_gem_create(file, dev, args->size, & args->handle);
  return (tmp);
}
}
int psb_gem_mmap_ioctl(struct drm_device *dev , void *data , struct drm_file *file ) 
{ struct drm_psb_gem_mmap *args ;
  int tmp ;

  {
  args = (struct drm_psb_gem_mmap *)data;
  tmp = (*((dev->driver)->dumb_map_offset))(file, dev, args->handle, & args->offset);
  return (tmp);
}
}
void ldv_mutex_lock_83(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_84(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_85(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_86(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_87(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_88(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_89(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_90(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_92(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_97(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
  return ((long )ptr);
}
}
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
  return (tmp);
}
}
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
int ldv_mutex_trylock_118(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_115(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_117(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_120(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_122(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_125(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_127(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) ;
void ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) ;
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
extern int release_resource(struct resource * ) ;
extern int allocate_resource(struct resource * , struct resource * , resource_size_t  ,
                             resource_size_t  , resource_size_t  , resource_size_t  ,
                             resource_size_t (*)(void * , struct resource  const  * ,
                                                 resource_size_t  , resource_size_t  ) ,
                             void * ) ;
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
extern void iounmap(void volatile   * ) ;
extern void *ioremap_wc(resource_size_t  , unsigned long  ) ;
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ int tmp ;

  {
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ int tmp ;

  {
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
  return (tmp);
}
}
extern void put_page(struct page * ) ;
extern int set_page_dirty(struct page * ) ;
extern int set_pages_array_wc(struct page ** , int  ) ;
extern int set_pages_array_wb(struct page ** , int  ) ;
__inline static gfp_t mapping_gfp_mask(struct address_space *mapping ) 
{ 

  {
  return ((gfp_t )mapping->flags & 33554431U);
}
}
extern struct page *shmem_read_mapping_page_gfp(struct address_space * , unsigned long  ,
                                                gfp_t  ) ;
__inline static struct page *shmem_read_mapping_page(struct address_space *mapping ,
                                                     unsigned long index ) 
{ gfp_t tmp ;
  struct page *tmp___0 ;

  {
  tmp = mapping_gfp_mask(mapping);
  tmp___0 = shmem_read_mapping_page_gfp(mapping, index, tmp);
  return (tmp___0);
}
}
int psb_gtt_init(struct drm_device *dev , int resume ) ;
void psb_gtt_takedown(struct drm_device *dev ) ;
void psb_gtt_unpin(struct gtt_range *gt ) ;
__inline static uint32_t psb_gtt_mask_pte(uint32_t pfn , int type ) 
{ uint32_t mask ;
  long tmp ;

  {
  mask = 1U;
  tmp = ldv__builtin_expect((pfn & 4293918720U) != 0U, 0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared"),
                         "i" (187), "i" (12UL));
    ldv_39275: ;
    goto ldv_39275;
  } else {

  }
  if (type & 1) {
    mask = mask | 8U;
  } else {

  }
  if ((type & 2) != 0) {
    mask = mask | 4U;
  } else {

  }
  if ((type & 4) != 0) {
    mask = mask | 2U;
  } else {

  }
  return ((pfn << 12) | mask);
}
}
static u32 *psb_gtt_entry(struct drm_device *dev , struct gtt_range *r ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long offset ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  offset = (unsigned long )(r->resource.start - (dev_priv->gtt_mem)->start);
  return (dev_priv->gtt_map + (offset >> 12));
}
}
static int psb_gtt_insert(struct drm_device *dev , struct gtt_range *r ) 
{ u32 *gtt_slot ;
  u32 pte ;
  struct page **pages ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;

  {
  if ((unsigned long )r->pages == (unsigned long )((struct page **)0)) {
    __ret_warn_on = 1;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared",
                         234);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    return (-22);
  } else {

  }
  __ret_warn_on___0 = (int )r->stolen;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared",
                       238);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  gtt_slot = psb_gtt_entry(dev, r);
  pages = r->pages;
  set_pages_array_wc(pages, r->npage);
  i = r->roll;
  goto ldv_39295;
  ldv_39294: 
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 80L),
                         0);
  tmp___1 = gtt_slot;
  gtt_slot = gtt_slot + 1;
  iowrite32(pte, (void *)tmp___1);
  i = i + 1;
  ldv_39295: ;
  if (r->npage > i) {
    goto ldv_39294;
  } else {
    goto ldv_39296;
  }
  ldv_39296: 
  i = 0;
  goto ldv_39298;
  ldv_39297: 
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 80L),
                         0);
  tmp___2 = gtt_slot;
  gtt_slot = gtt_slot + 1;
  iowrite32(pte, (void *)tmp___2);
  i = i + 1;
  ldv_39298: ;
  if (r->roll > i) {
    goto ldv_39297;
  } else {
    goto ldv_39299;
  }
  ldv_39299: 
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
  return (0);
}
}
static void psb_gtt_remove(struct drm_device *dev , struct gtt_range *r ) 
{ struct drm_psb_private *dev_priv ;
  u32 *gtt_slot ;
  u32 pte ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u32 *tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __ret_warn_on = (int )r->stolen;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared",
                       277);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  gtt_slot = psb_gtt_entry(dev, r);
  pte = psb_gtt_mask_pte((uint32_t )(((long )dev_priv->scratch_page + 24189255811072L) / 80L),
                         0);
  i = 0;
  goto ldv_39311;
  ldv_39310: 
  tmp___0 = gtt_slot;
  gtt_slot = gtt_slot + 1;
  iowrite32(pte, (void *)tmp___0);
  i = i + 1;
  ldv_39311: ;
  if (r->npage > i) {
    goto ldv_39310;
  } else {
    goto ldv_39312;
  }
  ldv_39312: 
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
  set_pages_array_wb(r->pages, r->npage);
  return;
}
}
void psb_gtt_roll(struct drm_device *dev , struct gtt_range *r , int roll ) 
{ u32 *gtt_slot ;
  u32 pte ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u32 *tmp___0 ;
  u32 *tmp___1 ;

  {
  if (r->npage <= roll) {
    __ret_warn_on = 1;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared",
                         305);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    return;
  } else {

  }
  r->roll = roll;
  if (! r->stolen && r->in_gart == 0) {
    return;
  } else {

  }
  gtt_slot = psb_gtt_entry(dev, r);
  i = r->roll;
  goto ldv_39324;
  ldv_39323: 
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 80L),
                         0);
  tmp___0 = gtt_slot;
  gtt_slot = gtt_slot + 1;
  iowrite32(pte, (void *)tmp___0);
  i = i + 1;
  ldv_39324: ;
  if (r->npage > i) {
    goto ldv_39323;
  } else {
    goto ldv_39325;
  }
  ldv_39325: 
  i = 0;
  goto ldv_39327;
  ldv_39326: 
  pte = psb_gtt_mask_pte((uint32_t )(((long )*(r->pages + (unsigned long )i) + 24189255811072L) / 80L),
                         0);
  tmp___1 = gtt_slot;
  gtt_slot = gtt_slot + 1;
  iowrite32(pte, (void *)tmp___1);
  i = i + 1;
  ldv_39327: ;
  if (r->roll > i) {
    goto ldv_39326;
  } else {
    goto ldv_39328;
  }
  ldv_39328: 
  ioread32((void *)gtt_slot + 0xffffffffffffffffUL);
  return;
}
}
static int psb_gtt_attach_pages(struct gtt_range *gt ) 
{ struct inode *inode ;
  struct address_space *mapping ;
  int i ;
  struct page *p ;
  int pages ;
  int __ret_warn_on ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  pages = (int )(gt->gem.size / 4096UL);
  __ret_warn_on = (unsigned long )gt->pages != (unsigned long )((struct page **)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared",
                       345);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  inode = ((gt->gem.filp)->f_path.dentry)->d_inode;
  mapping = inode->i_mapping;
  tmp___0 = kmalloc((unsigned long )pages * 8UL, 208U);
  gt->pages = (struct page **)tmp___0;
  if ((unsigned long )gt->pages == (unsigned long )((struct page **)0)) {
    return (-12);
  } else {

  }
  gt->npage = pages;
  i = 0;
  goto ldv_39341;
  ldv_39340: 
  p = shmem_read_mapping_page(mapping, (unsigned long )i);
  tmp___1 = IS_ERR((void const   *)p);
  if (tmp___1 != 0L) {
    goto err;
  } else {

  }
  *(gt->pages + (unsigned long )i) = p;
  i = i + 1;
  ldv_39341: ;
  if (i < pages) {
    goto ldv_39340;
  } else {
    goto ldv_39342;
  }
  ldv_39342: ;
  return (0);
  err: ;
  goto ldv_39344;
  ldv_39343: 
  put_page(*(gt->pages + (unsigned long )i));
  ldv_39344: 
  tmp___2 = i;
  i = i - 1;
  if (tmp___2 != 0) {
    goto ldv_39343;
  } else {
    goto ldv_39345;
  }
  ldv_39345: 
  kfree((void const   *)gt->pages);
  gt->pages = 0;
  tmp___3 = PTR_ERR((void const   *)p);
  return ((int )tmp___3);
}
}
static void psb_gtt_detach_pages(struct gtt_range *gt ) 
{ int i ;

  {
  i = 0;
  goto ldv_39351;
  ldv_39350: 
  set_page_dirty(*(gt->pages + (unsigned long )i));
  put_page(*(gt->pages + (unsigned long )i));
  i = i + 1;
  ldv_39351: ;
  if (gt->npage > i) {
    goto ldv_39350;
  } else {
    goto ldv_39352;
  }
  ldv_39352: 
  kfree((void const   *)gt->pages);
  gt->pages = 0;
  return;
}
}
int psb_gtt_pin(struct gtt_range *gt ) 
{ int ret ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;

  {
  ret = 0;
  dev = gt->gem.dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  ldv_mutex_lock_127(& dev_priv->gtt_mutex);
  if (gt->in_gart == 0 && ! gt->stolen) {
    ret = psb_gtt_attach_pages(gt);
    if (ret < 0) {
      goto out;
    } else {

    }
    ret = psb_gtt_insert(dev, gt);
    if (ret < 0) {
      psb_gtt_detach_pages(gt);
      goto out;
    } else {

    }
  } else {

  }
  gt->in_gart = gt->in_gart + 1;
  out: 
  ldv_mutex_unlock_128(& dev_priv->gtt_mutex);
  return (ret);
}
}
void psb_gtt_unpin(struct gtt_range *gt ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int __ret_warn_on ;
  long tmp ;

  {
  dev = gt->gem.dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  ldv_mutex_lock_129(& dev_priv->gtt_mutex);
  __ret_warn_on = gt->in_gart == 0;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared",
                       445);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  gt->in_gart = gt->in_gart - 1;
  if (gt->in_gart == 0 && ! gt->stolen) {
    psb_gtt_remove(dev, gt);
    psb_gtt_detach_pages(gt);
  } else {

  }
  ldv_mutex_unlock_130(& dev_priv->gtt_mutex);
  return;
}
}
struct gtt_range *psb_gtt_alloc_range(struct drm_device *dev , int len , char const   *name ,
                                      int backed ) 
{ struct drm_psb_private *dev_priv ;
  struct gtt_range *gt ;
  struct resource *r ;
  int ret ;
  unsigned long start ;
  unsigned long end ;
  void *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  r = dev_priv->gtt_mem;
  if (backed != 0) {
    start = (unsigned long )r->start;
    end = (unsigned long )((r->start + (unsigned long long )dev_priv->gtt.stolen_size) - 1ULL);
  } else {
    start = (unsigned long )(r->start + (unsigned long long )dev_priv->gtt.stolen_size);
    end = (unsigned long )r->end;
  }
  tmp = kzalloc(240UL, 208U);
  gt = (struct gtt_range *)tmp;
  if ((unsigned long )gt == (unsigned long )((struct gtt_range *)0)) {
    return (0);
  } else {

  }
  gt->resource.name = name;
  gt->stolen = backed != 0;
  gt->in_gart = backed;
  gt->roll = 0;
  gt->gem.dev = dev;
  ret = allocate_resource(dev_priv->gtt_mem, & gt->resource, (resource_size_t )len,
                          (resource_size_t )start, (resource_size_t )end, 4096ULL,
                          0, 0);
  if (ret == 0) {
    gt->offset = (u32 )gt->resource.start - (u32 )r->start;
    return (gt);
  } else {

  }
  kfree((void const   *)gt);
  return (0);
}
}
void psb_gtt_free_range(struct drm_device *dev , struct gtt_range *gt ) 
{ int __ret_warn_on ;
  long tmp ;

  {
  if ((int )gt->mmapping) {
    psb_gtt_unpin(gt);
    gt->mmapping = 0;
  } else {

  }
  __ret_warn_on = gt->in_gart != 0 && ! gt->stolen;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared",
                       526);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  release_resource(& gt->resource);
  kfree((void const   *)gt);
  return;
}
}
static void psb_gtt_alloc(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __init_rwsem(& dev_priv->gtt.sem, "&dev_priv->gtt.sem", & __key);
  return;
}
}
void psb_gtt_takedown(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((unsigned long )dev_priv->gtt_map != (unsigned long )((u32 *)0)) {
    iounmap((void volatile   *)dev_priv->gtt_map);
    dev_priv->gtt_map = 0;
  } else {

  }
  if (dev_priv->gtt_initialized != 0) {
    pci_write_config_word((struct pci_dev  const  *)dev->pdev, 82, (int )dev_priv->gmch_ctrl);
    iowrite32(dev_priv->pge_ctl, (void *)dev_priv->vdc_reg + 8224U);
    ioread32((void *)dev_priv->vdc_reg + 8224U);
  } else {

  }
  if ((unsigned long )dev_priv->vram_addr != (unsigned long )((u8 *)0)) {
    iounmap((void volatile   *)dev_priv->gtt_map);
  } else {

  }
  return;
}
}
int psb_gtt_init(struct drm_device *dev , int resume ) 
{ struct drm_psb_private *dev_priv ;
  unsigned int gtt_pages ;
  unsigned long stolen_size ;
  unsigned long vram_stolen_size ;
  unsigned int i ;
  unsigned int num_pages ;
  unsigned int pfn_base ;
  struct psb_gtt *pg ;
  int ret ;
  uint32_t pte ;
  struct lock_class_key __key ;
  struct _ddebug descriptor ;
  long tmp ;
  struct resource fudge ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  ret = 0;
  __mutex_init(& dev_priv->gtt_mutex, "&dev_priv->gtt_mutex", & __key);
  psb_gtt_alloc(dev);
  pg = & dev_priv->gtt;
  pci_read_config_word((struct pci_dev  const  *)dev->pdev, 82, & dev_priv->gmch_ctrl);
  pci_write_config_word((struct pci_dev  const  *)dev->pdev, 82, (int )((unsigned int )dev_priv->gmch_ctrl | 4U));
  dev_priv->pge_ctl = ioread32((void *)dev_priv->vdc_reg + 8224U);
  iowrite32(dev_priv->pge_ctl | 1U, (void *)dev_priv->vdc_reg + 8224U);
  ioread32((void *)dev_priv->vdc_reg + 8224U);
  dev_priv->gtt_initialized = 1;
  pg->gtt_phys_start = dev_priv->pge_ctl & 4294963200U;
  pg->mmu_gatt_start = 3758096384U;
  pg->gtt_start = (uint32_t )(dev->pdev)->resource[3].start;
  if ((dev->pdev)->resource[3].start != 0ULL || (dev->pdev)->resource[3].end != (dev->pdev)->resource[3].start) {
    gtt_pages = (unsigned int )((((dev->pdev)->resource[3].end - (dev->pdev)->resource[3].start) + 1ULL) >> 12);
  } else {
    gtt_pages = 0U;
  }
  if (pg->gtt_start == 0U || gtt_pages == 0U) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "psb_gtt_init";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared";
    descriptor.format = "GTT PCI BAR not initialized.\n";
    descriptor.lineno = 599U;
    descriptor.flags = 0U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "GTT PCI BAR not initialized.\n");
    } else {

    }
    gtt_pages = 64U;
    pg->gtt_start = dev_priv->pge_ctl;
  } else {

  }
  pg->gatt_start = (uint32_t )(dev->pdev)->resource[2].start;
  if ((dev->pdev)->resource[2].start != 0ULL || (dev->pdev)->resource[2].end != (dev->pdev)->resource[2].start) {
    pg->gatt_pages = (unsigned int )((((dev->pdev)->resource[2].end - (dev->pdev)->resource[2].start) + 1ULL) >> 12);
  } else {
    pg->gatt_pages = 0U;
  }
  dev_priv->gtt_mem = (struct resource *)(& (dev->pdev)->resource) + 2UL;
  if (pg->gatt_pages == 0U || pg->gatt_start == 0U) {
    descriptor___0.modname = "gma500_gfx";
    descriptor___0.function = "psb_gtt_init";
    descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared";
    descriptor___0.format = "GATT PCI BAR not initialized.\n";
    descriptor___0.lineno = 614U;
    descriptor___0.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "GATT PCI BAR not initialized.\n");
    } else {

    }
    pg->gatt_start = 1073741824U;
    pg->gatt_pages = 32768U;
    fudge.start = 1073741824ULL;
    fudge.end = 1207959551ULL;
    fudge.name = "fudge";
    fudge.flags = 512UL;
    dev_priv->gtt_mem = & fudge;
  } else {

  }
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 92, & dev_priv->stolen_base);
  vram_stolen_size = (unsigned long )(pg->gtt_phys_start - dev_priv->stolen_base) - 4096UL;
  stolen_size = vram_stolen_size;
  descriptor___1.modname = "gma500_gfx";
  descriptor___1.function = "psb_gtt_init";
  descriptor___1.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared";
  descriptor___1.format = "Stolen memory base 0x%x, size %luK\n";
  descriptor___1.lineno = 635U;
  descriptor___1.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)dev->dev, "Stolen memory base 0x%x, size %luK\n",
                      dev_priv->stolen_base, vram_stolen_size / 1024UL);
  } else {

  }
  if ((resume != 0 && pg->gtt_pages != gtt_pages) && pg->stolen_size != stolen_size) {
    dev_err((struct device  const  *)dev->dev, "GTT resume error.\n");
    ret = -22;
    goto out_err;
  } else {

  }
  pg->gtt_pages = gtt_pages;
  pg->stolen_size = stolen_size;
  dev_priv->vram_stolen_size = vram_stolen_size;
  tmp___2 = ioremap_nocache((resource_size_t )pg->gtt_phys_start, (unsigned long )(gtt_pages << 12));
  dev_priv->gtt_map = (u32 *)tmp___2;
  if ((unsigned long )dev_priv->gtt_map == (unsigned long )((u32 *)0)) {
    dev_err((struct device  const  *)dev->dev, "Failure to map gtt.\n");
    ret = -12;
    goto out_err;
  } else {

  }
  tmp___3 = ioremap_wc((resource_size_t )dev_priv->stolen_base, stolen_size);
  dev_priv->vram_addr = (u8 *)tmp___3;
  if ((unsigned long )dev_priv->vram_addr == (unsigned long )((u8 *)0)) {
    dev_err((struct device  const  *)dev->dev, "Failure to map stolen base.\n");
    ret = -12;
    goto out_err;
  } else {

  }
  pfn_base = dev_priv->stolen_base >> 12;
  num_pages = (unsigned int )(vram_stolen_size >> 12);
  descriptor___2.modname = "gma500_gfx";
  descriptor___2.function = "psb_gtt_init";
  descriptor___2.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/gtt.c.prepared";
  descriptor___2.format = "Set up %d stolen pages starting at 0x%08x, GTT offset %dK\n";
  descriptor___2.lineno = 673U;
  descriptor___2.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)dev->dev, "Set up %d stolen pages starting at 0x%08x, GTT offset %dK\n",
                      num_pages, pfn_base << 12, 0);
  } else {

  }
  i = 0U;
  goto ldv_39417;
  ldv_39416: 
  pte = psb_gtt_mask_pte(pfn_base + i, 0);
  iowrite32(pte, (void *)dev_priv->gtt_map + (unsigned long )i);
  i = i + 1U;
  ldv_39417: ;
  if (i < num_pages) {
    goto ldv_39416;
  } else {
    goto ldv_39418;
  }
  ldv_39418: 
  pfn_base = (unsigned int )(((long )dev_priv->scratch_page + 24189255811072L) / 80L);
  pte = psb_gtt_mask_pte(pfn_base, 0);
  goto ldv_39420;
  ldv_39419: 
  iowrite32(pte, (void *)dev_priv->gtt_map + (unsigned long )i);
  i = i + 1U;
  ldv_39420: ;
  if (i < gtt_pages) {
    goto ldv_39419;
  } else {
    goto ldv_39421;
  }
  ldv_39421: 
  ioread32((void *)(dev_priv->gtt_map + ((unsigned long )i + 0xffffffffffffffffUL)));
  return (0);
  out_err: 
  psb_gtt_takedown(dev);
  return (ret);
}
}
void ldv_mutex_lock_115(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_116(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_117(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_118(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_120(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_122(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_123(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_125(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_127(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_129(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
extern void *__memcpy(void * , void const   * , size_t  ) ;
extern int memcmp(void const   * , void const   * , size_t  ) ;
int ldv_mutex_trylock_150(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_148(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_156(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_158(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_149(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_157(struct mutex *ldv_func_arg1 ) ;
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
    return (0);
  } else {

  }
  tmp = __kmalloc(n * size, flags);
  return (tmp);
}
}
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  tmp = kmalloc_array(n, size, flags | 32768U);
  return (tmp);
}
}
extern void *pci_map_rom(struct pci_dev * , size_t * ) ;
extern void pci_unmap_rom(struct pci_dev * , void * ) ;
extern void drm_ut_debug_printk(unsigned int  , char const   * , char const   * ,
                                char const   *  , ...) ;
extern void drm_mode_debug_printmodeline(struct drm_display_mode  const  * ) ;
extern void drm_mode_set_name(struct drm_display_mode * ) ;
int psb_intel_init_bios(struct drm_device *dev ) ;
void psb_intel_destroy_bios(struct drm_device *dev ) ;
static void *find_section(struct bdb_header *bdb , int section_id ) 
{ u8 *base ;
  int index ;
  u16 total ;
  u16 current_size ;
  u8 current_id ;

  {
  base = (u8 *)bdb;
  index = 0;
  index = (int )bdb->header_size + index;
  total = bdb->bdb_size;
  goto ldv_38002;
  ldv_38001: 
  current_id = *(base + (unsigned long )index);
  index = index + 1;
  current_size = *((u16 *)base + (unsigned long )index);
  index = index + 2;
  if ((int )current_id == section_id) {
    return ((void *)base + (unsigned long )index);
  } else {

  }
  index = (int )current_size + index;
  ldv_38002: ;
  if ((int )total > index) {
    goto ldv_38001;
  } else {
    goto ldv_38003;
  }
  ldv_38003: ;
  return (0);
}
}
static void parse_edp(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ struct bdb_edp *edp ;
  struct edp_power_seq *edp_pps ;
  struct edp_link_params *edp_link_params ;
  uint8_t panel_type ;
  void *tmp ;

  {
  tmp = find_section(bdb, 27);
  edp = (struct bdb_edp *)tmp;
  dev_priv->edp.bpp = 18;
  if ((unsigned long )edp == (unsigned long )((struct bdb_edp *)0)) {
    if ((int )dev_priv->edp.support) {
      drm_ut_debug_printk(4U, "drm", "parse_edp", "No eDP BDB found but eDP panel supported, assume %dbpp panel color depth.\n",
                          dev_priv->edp.bpp);
    } else {

    }
    return;
  } else {

  }
  panel_type = dev_priv->panel_type;
  switch ((edp->color_depth >> (int )panel_type * 2) & 3U) {
  case 0: 
  dev_priv->edp.bpp = 18;
  goto ldv_38014;
  case 1: 
  dev_priv->edp.bpp = 24;
  goto ldv_38014;
  case 2: 
  dev_priv->edp.bpp = 30;
  goto ldv_38014;
  }
  ldv_38014: 
  edp_pps = (struct edp_power_seq *)(& edp->power_seqs) + (unsigned long )panel_type;
  edp_link_params = (struct edp_link_params *)(& edp->link_params) + (unsigned long )panel_type;
  dev_priv->edp.pps = *edp_pps;
  drm_ut_debug_printk(4U, "drm", "parse_edp", "EDP timing in vbt t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
                      (int )dev_priv->edp.pps.t1_t3, (int )dev_priv->edp.pps.t8, (int )dev_priv->edp.pps.t9,
                      (int )dev_priv->edp.pps.t10, (int )dev_priv->edp.pps.t11_t12);
  if ((unsigned int )*((unsigned char *)edp_link_params + 0UL) != 0U) {
    dev_priv->edp.rate = 10;
  } else {
    dev_priv->edp.rate = 6;
  }
  switch ((int )edp_link_params->lanes) {
  case 0: 
  dev_priv->edp.lanes = 1;
  goto ldv_38018;
  case 1: 
  dev_priv->edp.lanes = 2;
  goto ldv_38018;
  case 3: ;
  default: 
  dev_priv->edp.lanes = 4;
  goto ldv_38018;
  }
  ldv_38018: 
  drm_ut_debug_printk(4U, "drm", "parse_edp", "VBT reports EDP: Lane_count %d, Lane_rate %d, Bpp %d\n",
                      dev_priv->edp.lanes, dev_priv->edp.rate, dev_priv->edp.bpp);
  switch ((int )edp_link_params->preemphasis) {
  case 0: 
  dev_priv->edp.preemphasis = 0;
  goto ldv_38023;
  case 1: 
  dev_priv->edp.preemphasis = 8;
  goto ldv_38023;
  case 2: 
  dev_priv->edp.preemphasis = 16;
  goto ldv_38023;
  case 3: 
  dev_priv->edp.preemphasis = 24;
  goto ldv_38023;
  }
  ldv_38023: ;
  switch ((int )edp_link_params->vswing) {
  case 0: 
  dev_priv->edp.vswing = 0;
  goto ldv_38028;
  case 1: 
  dev_priv->edp.vswing = 1;
  goto ldv_38028;
  case 2: 
  dev_priv->edp.vswing = 2;
  goto ldv_38028;
  case 3: 
  dev_priv->edp.vswing = 3;
  goto ldv_38028;
  }
  ldv_38028: 
  drm_ut_debug_printk(4U, "drm", "parse_edp", "VBT reports EDP: VSwing  %d, Preemph %d\n",
                      dev_priv->edp.vswing, dev_priv->edp.preemphasis);
  return;
}
}
static u16 get_blocksize(void *p ) 
{ u16 *block_ptr ;
  u16 block_size ;

  {
  block_ptr = (u16 *)p + 0xfffffffffffffffeUL;
  block_size = *block_ptr;
  return (block_size);
}
}
static void fill_detail_timing_data(struct drm_display_mode *panel_fixed_mode , struct lvds_dvo_timing *dvo_timing ) 
{ 

  {
  panel_fixed_mode->hdisplay = ((int )dvo_timing->hactive_hi << 8) | (int )dvo_timing->hactive_lo;
  panel_fixed_mode->hsync_start = panel_fixed_mode->hdisplay + (((int )dvo_timing->hsync_off_hi << 8) | (int )dvo_timing->hsync_off_lo);
  panel_fixed_mode->hsync_end = panel_fixed_mode->hsync_start + (int )dvo_timing->hsync_pulse_width;
  panel_fixed_mode->htotal = panel_fixed_mode->hdisplay + (((int )dvo_timing->hblank_hi << 8) | (int )dvo_timing->hblank_lo);
  panel_fixed_mode->vdisplay = ((int )dvo_timing->vactive_hi << 8) | (int )dvo_timing->vactive_lo;
  panel_fixed_mode->vsync_start = panel_fixed_mode->vdisplay + (int )dvo_timing->vsync_off;
  panel_fixed_mode->vsync_end = panel_fixed_mode->vsync_start + (int )dvo_timing->vsync_pulse_width;
  panel_fixed_mode->vtotal = panel_fixed_mode->vdisplay + (((int )dvo_timing->vblank_hi << 8) | (int )dvo_timing->vblank_lo);
  panel_fixed_mode->clock = (int )dvo_timing->clock * 10;
  panel_fixed_mode->type = 8U;
  if ((unsigned int )*((unsigned char *)dvo_timing + 17UL) != 0U) {
    panel_fixed_mode->flags = panel_fixed_mode->flags | 1U;
  } else {
    panel_fixed_mode->flags = panel_fixed_mode->flags | 2U;
  }
  if ((unsigned int )*((unsigned char *)dvo_timing + 17UL) != 0U) {
    panel_fixed_mode->flags = panel_fixed_mode->flags | 4U;
  } else {
    panel_fixed_mode->flags = panel_fixed_mode->flags | 8U;
  }
  if (panel_fixed_mode->hsync_end > panel_fixed_mode->htotal) {
    panel_fixed_mode->htotal = panel_fixed_mode->hsync_end + 1;
  } else {

  }
  if (panel_fixed_mode->vsync_end > panel_fixed_mode->vtotal) {
    panel_fixed_mode->vtotal = panel_fixed_mode->vsync_end + 1;
  } else {

  }
  drm_mode_set_name(panel_fixed_mode);
  return;
}
}
static void parse_backlight_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ struct bdb_lvds_backlight *vbt_lvds_bl ;
  struct bdb_lvds_backlight *lvds_bl ;
  u8 p_type ;
  void *bl_start ;
  struct bdb_lvds_options *lvds_opts ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
  vbt_lvds_bl = 0;
  p_type = 0U;
  bl_start = 0;
  tmp = find_section(bdb, 40);
  lvds_opts = (struct bdb_lvds_options *)tmp;
  dev_priv->lvds_bl = 0;
  if ((unsigned long )lvds_opts != (unsigned long )((struct bdb_lvds_options *)0)) {
    p_type = lvds_opts->panel_type;
  } else {
    return;
  }
  bl_start = find_section(bdb, 43);
  vbt_lvds_bl = (struct bdb_lvds_backlight *)bl_start + ((unsigned long )p_type + 1UL);
  tmp___0 = kzalloc(6UL, 208U);
  lvds_bl = (struct bdb_lvds_backlight *)tmp___0;
  if ((unsigned long )lvds_bl == (unsigned long )((struct bdb_lvds_backlight *)0)) {
    dev_err((struct device  const  *)(dev_priv->dev)->dev, "out of memory for backlight data\n");
    return;
  } else {

  }
  __len = 6UL;
  if (__len > 63UL) {
    __ret = __memcpy((void *)lvds_bl, (void const   *)vbt_lvds_bl, __len);
  } else {
    __ret = __builtin_memcpy((void *)lvds_bl, (void const   *)vbt_lvds_bl, __len);
  }
  dev_priv->lvds_bl = lvds_bl;
  return;
}
}
static void parse_lfp_panel_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ struct bdb_lvds_options *lvds_options ;
  struct bdb_lvds_lfp_data *lvds_lfp_data ;
  struct bdb_lvds_lfp_data_entry *entry ;
  struct lvds_dvo_timing *dvo_timing ;
  struct drm_display_mode *panel_fixed_mode ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;

  {
  dev_priv->lvds_dither = 0U;
  dev_priv->lvds_vbt = 0U;
  tmp = find_section(bdb, 40);
  lvds_options = (struct bdb_lvds_options *)tmp;
  if ((unsigned long )lvds_options == (unsigned long )((struct bdb_lvds_options *)0)) {
    return;
  } else {

  }
  dev_priv->lvds_dither = lvds_options->pixel_dither;
  dev_priv->panel_type = lvds_options->panel_type;
  if ((unsigned int )lvds_options->panel_type == 255U) {
    return;
  } else {

  }
  tmp___0 = find_section(bdb, 42);
  lvds_lfp_data = (struct bdb_lvds_lfp_data *)tmp___0;
  if ((unsigned long )lvds_lfp_data == (unsigned long )((struct bdb_lvds_lfp_data *)0)) {
    return;
  } else {

  }
  entry = (struct bdb_lvds_lfp_data_entry *)(& lvds_lfp_data->data) + (unsigned long )lvds_options->panel_type;
  dvo_timing = & entry->dvo_timing;
  tmp___1 = kzalloc(216UL, 208U);
  panel_fixed_mode = (struct drm_display_mode *)tmp___1;
  if ((unsigned long )panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    dev_err((struct device  const  *)(dev_priv->dev)->dev, "out of memory for fixed panel mode\n");
    return;
  } else {

  }
  dev_priv->lvds_vbt = 1U;
  fill_detail_timing_data(panel_fixed_mode, dvo_timing);
  if (panel_fixed_mode->htotal > 0 && panel_fixed_mode->vtotal > 0) {
    dev_priv->lfp_lvds_vbt_mode = panel_fixed_mode;
    drm_mode_debug_printmodeline((struct drm_display_mode  const  *)panel_fixed_mode);
  } else {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "parse_lfp_panel_data";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/intel_bios.c.prepared";
    descriptor.format = "ignoring invalid LVDS VBT\n";
    descriptor.lineno = 419U;
    descriptor.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)(dev_priv->dev)->dev,
                        "ignoring invalid LVDS VBT\n");
    } else {

    }
    dev_priv->lvds_vbt = 0U;
    kfree((void const   *)panel_fixed_mode);
  }
  return;
}
}
static void parse_sdvo_panel_data(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ struct bdb_sdvo_lvds_options *sdvo_lvds_options ;
  struct lvds_dvo_timing *dvo_timing ;
  struct drm_display_mode *panel_fixed_mode ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  dev_priv->sdvo_lvds_vbt_mode = 0;
  tmp = find_section(bdb, 22);
  sdvo_lvds_options = (struct bdb_sdvo_lvds_options *)tmp;
  if ((unsigned long )sdvo_lvds_options == (unsigned long )((struct bdb_sdvo_lvds_options *)0)) {
    return;
  } else {

  }
  tmp___0 = find_section(bdb, 23);
  dvo_timing = (struct lvds_dvo_timing *)tmp___0;
  if ((unsigned long )dvo_timing == (unsigned long )((struct lvds_dvo_timing *)0)) {
    return;
  } else {

  }
  tmp___1 = kzalloc(216UL, 208U);
  panel_fixed_mode = (struct drm_display_mode *)tmp___1;
  if ((unsigned long )panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    return;
  } else {

  }
  fill_detail_timing_data(panel_fixed_mode, dvo_timing + (unsigned long )sdvo_lvds_options->panel_type);
  dev_priv->sdvo_lvds_vbt_mode = panel_fixed_mode;
  return;
}
}
static void parse_general_features(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ struct bdb_general_features *general ;
  void *tmp ;

  {
  dev_priv->int_tv_support = 1U;
  dev_priv->int_crt_support = 1U;
  tmp = find_section(bdb, 1);
  general = (struct bdb_general_features *)tmp;
  if ((unsigned long )general != (unsigned long )((struct bdb_general_features *)0)) {
    dev_priv->int_tv_support = general->int_tv_support;
    dev_priv->int_crt_support = general->int_crt_support;
    dev_priv->lvds_use_ssc = general->enable_ssc;
    if ((unsigned int )*((unsigned char *)dev_priv + 824UL) != 0U) {
      if ((unsigned int )*((unsigned char *)general + 1UL) != 0U) {
        dev_priv->lvds_ssc_freq = 100;
      } else {
        dev_priv->lvds_ssc_freq = 96;
      }
    } else {

    }
  } else {

  }
  return;
}
}
static void parse_sdvo_device_mapping(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ struct sdvo_device_mapping *p_mapping ;
  struct bdb_general_definitions *p_defs ;
  struct child_device_config *p_child ;
  int i ;
  int child_device_num ;
  int count ;
  u16 block_size ;
  void *tmp ;
  char *tmp___0 ;

  {
  tmp = find_section(bdb, 2);
  p_defs = (struct bdb_general_definitions *)tmp;
  if ((unsigned long )p_defs == (unsigned long )((struct bdb_general_definitions *)0)) {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "No general definition block is found, unable to construct sdvo mapping.\n");
    return;
  } else {

  }
  if ((unsigned int )p_defs->child_dev_size != 33U) {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "different child size is found. Invalid.\n");
    return;
  } else {

  }
  block_size = get_blocksize((void *)p_defs);
  child_device_num = (int )(((unsigned long )block_size - 5UL) / 33UL);
  count = 0;
  i = 0;
  goto ldv_38090;
  ldv_38089: 
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
  if ((unsigned int )p_child->device_type == 0U) {
    goto ldv_38088;
  } else {

  }
  if ((unsigned int )p_child->slave_addr != 112U && (unsigned int )p_child->slave_addr != 114U) {
    goto ldv_38088;
  } else {

  }
  if ((unsigned int )p_child->dvo_port != 1U && (unsigned int )p_child->dvo_port != 2U) {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "Incorrect SDVO port. Skip it\n");
    goto ldv_38088;
  } else {

  }
  if ((unsigned int )p_child->dvo_port == 1U) {
    tmp___0 = (char *)"SDVOB";
  } else {
    tmp___0 = (char *)"SDVOC";
  }
  drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "the SDVO device with slave addr %2x is found on %s port\n",
                      (int )p_child->slave_addr, tmp___0);
  p_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + ((unsigned long )p_child->dvo_port + 0xffffffffffffffffUL);
  if ((unsigned int )p_mapping->initialized == 0U) {
    p_mapping->dvo_port = p_child->dvo_port;
    p_mapping->slave_addr = p_child->slave_addr;
    p_mapping->dvo_wiring = p_child->dvo_wiring;
    p_mapping->ddc_pin = p_child->ddc_pin;
    p_mapping->i2c_pin = p_child->i2c_pin;
    p_mapping->initialized = 1U;
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\n",
                        (int )p_mapping->dvo_port, (int )p_mapping->slave_addr, (int )p_mapping->dvo_wiring,
                        (int )p_mapping->ddc_pin, (int )p_mapping->i2c_pin);
  } else {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "Maybe one SDVO port is shared by two SDVO device.\n");
  }
  if ((unsigned int )p_child->slave2_addr != 0U) {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "there exists the slave2_addr. Maybe this is a SDVO device with multiple inputs.\n");
  } else {

  }
  count = count + 1;
  ldv_38088: 
  i = i + 1;
  ldv_38090: ;
  if (i < child_device_num) {
    goto ldv_38089;
  } else {
    goto ldv_38091;
  }
  ldv_38091: ;
  if (count == 0) {
    drm_ut_debug_printk(4U, "drm", "parse_sdvo_device_mapping", "No SDVO device info is found in VBT\n");
  } else {

  }
  return;
}
}
static void parse_driver_features(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ struct bdb_driver_features *driver___0 ;
  void *tmp ;

  {
  tmp = find_section(bdb, 12);
  driver___0 = (struct bdb_driver_features *)tmp;
  if ((unsigned long )driver___0 == (unsigned long )((struct bdb_driver_features *)0)) {
    return;
  } else {

  }
  if ((unsigned int )*((unsigned char *)driver___0 + 8UL) == 24U) {
    dev_priv->edp.support = 1;
  } else {

  }
  if ((unsigned int )*((unsigned char *)driver___0 + 0UL) != 0U) {
    dev_priv->dplla_96mhz = 1;
  } else {
    dev_priv->dplla_96mhz = 0;
  }
  return;
}
}
static void parse_device_mapping(struct drm_psb_private *dev_priv , struct bdb_header *bdb ) 
{ struct bdb_general_definitions *p_defs ;
  struct child_device_config *p_child ;
  struct child_device_config *child_dev_ptr ;
  int i ;
  int child_device_num ;
  int count ;
  u16 block_size ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
  tmp = find_section(bdb, 2);
  p_defs = (struct bdb_general_definitions *)tmp;
  if ((unsigned long )p_defs == (unsigned long )((struct bdb_general_definitions *)0)) {
    drm_ut_debug_printk(4U, "drm", "parse_device_mapping", "No general definition block is found, no devices defined.\n");
    return;
  } else {

  }
  if ((unsigned int )p_defs->child_dev_size != 33U) {
    drm_ut_debug_printk(4U, "drm", "parse_device_mapping", "different child size is found. Invalid.\n");
    return;
  } else {

  }
  block_size = get_blocksize((void *)p_defs);
  child_device_num = (int )(((unsigned long )block_size - 5UL) / 33UL);
  count = 0;
  i = 0;
  goto ldv_38111;
  ldv_38110: 
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
  if ((unsigned int )p_child->device_type == 0U) {
    goto ldv_38109;
  } else {

  }
  count = count + 1;
  ldv_38109: 
  i = i + 1;
  ldv_38111: ;
  if (i < child_device_num) {
    goto ldv_38110;
  } else {
    goto ldv_38112;
  }
  ldv_38112: ;
  if (count == 0) {
    drm_ut_debug_printk(4U, "drm", "parse_device_mapping", "no child dev is parsed from VBT\n");
    return;
  } else {

  }
  tmp___0 = kcalloc((size_t )count, 33UL, 208U);
  dev_priv->child_dev = (struct child_device_config *)tmp___0;
  if ((unsigned long )dev_priv->child_dev == (unsigned long )((struct child_device_config *)0)) {
    drm_ut_debug_printk(4U, "drm", "parse_device_mapping", "No memory space for child devices\n");
    return;
  } else {

  }
  dev_priv->child_dev_num = count;
  count = 0;
  i = 0;
  goto ldv_38118;
  ldv_38117: 
  p_child = (struct child_device_config *)(& p_defs->devices) + (unsigned long )i;
  if ((unsigned int )p_child->device_type == 0U) {
    goto ldv_38113;
  } else {

  }
  child_dev_ptr = dev_priv->child_dev + (unsigned long )count;
  count = count + 1;
  __len = 33UL;
  if (__len > 63UL) {
    __ret = __memcpy((void *)child_dev_ptr, (void const   *)p_child, __len);
  } else {
    __ret = __builtin_memcpy((void *)child_dev_ptr, (void const   *)p_child, __len);
  }
  ldv_38113: 
  i = i + 1;
  ldv_38118: ;
  if (i < child_device_num) {
    goto ldv_38117;
  } else {
    goto ldv_38119;
  }
  ldv_38119: ;
  return;
}
}
int psb_intel_init_bios(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct pci_dev *pdev ;
  struct vbt_header *vbt ;
  struct bdb_header *bdb ;
  u8 *bios ;
  size_t size ;
  int i ;
  struct vbt_header *vbt___0 ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pdev = dev->pdev;
  vbt = 0;
  bdb = 0;
  bios = 0;
  dev_priv->panel_type = 255U;
  if ((unsigned long )dev_priv->opregion.vbt != (unsigned long )((void *)0)) {
    vbt___0 = (struct vbt_header *)dev_priv->opregion.vbt;
    tmp = memcmp((void const   *)(& vbt___0->signature), (void const   *)"$VBT", 4UL);
    if (tmp == 0) {
      drm_ut_debug_printk(4U, "drm", "psb_intel_init_bios", "Using VBT from OpRegion: %20s\n",
                          (u8 *)(& vbt___0->signature));
      bdb = (struct bdb_header *)vbt___0 + (unsigned long )vbt___0->bdb_offset;
    } else {
      dev_priv->opregion.vbt = 0;
    }
  } else {

  }
  if ((unsigned long )bdb == (unsigned long )((struct bdb_header *)0)) {
    tmp___0 = pci_map_rom(pdev, & size);
    bios = (u8 *)tmp___0;
    if ((unsigned long )bios == (unsigned long )((u8 *)0)) {
      return (-1);
    } else {

    }
    i = 0;
    goto ldv_38134;
    ldv_38133: 
    tmp___1 = memcmp((void const   *)bios + (unsigned long )i, (void const   *)"$VBT",
                     4UL);
    if (tmp___1 == 0) {
      vbt = (struct vbt_header *)bios + (unsigned long )i;
      goto ldv_38132;
    } else {

    }
    i = i + 1;
    ldv_38134: ;
    if ((size_t )(i + 4) < size) {
      goto ldv_38133;
    } else {
      goto ldv_38132;
    }
    ldv_38132: ;
    if ((unsigned long )vbt == (unsigned long )((struct vbt_header *)0)) {
      dev_err((struct device  const  *)dev->dev, "VBT signature missing\n");
      pci_unmap_rom(pdev, (void *)bios);
      return (-1);
    } else {

    }
    bdb = (struct bdb_header *)(bios + ((unsigned long )i + (unsigned long )vbt->bdb_offset));
  } else {

  }
  parse_general_features(dev_priv, bdb);
  parse_driver_features(dev_priv, bdb);
  parse_lfp_panel_data(dev_priv, bdb);
  parse_sdvo_panel_data(dev_priv, bdb);
  parse_sdvo_device_mapping(dev_priv, bdb);
  parse_device_mapping(dev_priv, bdb);
  parse_backlight_data(dev_priv, bdb);
  parse_edp(dev_priv, bdb);
  if ((unsigned long )bios != (unsigned long )((u8 *)0)) {
    pci_unmap_rom(pdev, (void *)bios);
  } else {

  }
  return (0);
}
}
void psb_intel_destroy_bios(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  kfree((void const   *)dev_priv->sdvo_lvds_vbt_mode);
  kfree((void const   *)dev_priv->lfp_lvds_vbt_mode);
  kfree((void const   *)dev_priv->lvds_bl);
  return;
}
}
void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_148(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_149(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_150(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_151(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_154(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_155(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_156(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_157(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_158(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
extern int snprintf(char * , size_t  , char const   *  , ...) ;
int ldv_mutex_trylock_174(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_175(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_177(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_179(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_180(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_182(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_171(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_173(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_176(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_178(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_181(struct mutex *ldv_func_arg1 ) ;
extern unsigned long usecs_to_jiffies(unsigned int const    ) ;
extern int dev_set_drvdata(struct device * , void * ) ;
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 

  {
  dev_set_drvdata(& dev->dev, data);
  return;
}
}
extern int i2c_del_adapter(struct i2c_adapter * ) ;
extern int i2c_bit_add_bus(struct i2c_adapter * ) ;
extern void __const_udelay(unsigned long  ) ;
struct psb_intel_i2c_chan *psb_intel_i2c_create(struct drm_device *dev , u32 const   reg ,
                                                char const   *name ) ;
void psb_intel_i2c_destroy(struct psb_intel_i2c_chan *chan ) ;
__inline static uint32_t REGISTER_READ(struct drm_device *dev , uint32_t reg ) 
{ struct drm_psb_private *dev_priv ;
  unsigned int tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
  return (tmp);
}
}
__inline static void REGISTER_WRITE(struct drm_device *dev , uint32_t reg , uint32_t val ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  iowrite32(val, (void *)dev_priv->vdc_reg + (unsigned long )reg);
  return;
}
}
static int get_clock(void *data ) 
{ struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 val ;

  {
  chan = (struct psb_intel_i2c_chan *)data;
  dev = chan->drm_dev;
  val = REGISTER_READ(dev, chan->reg);
  return ((val & 16U) != 0U);
}
}
static int get_data(void *data ) 
{ struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 val ;

  {
  chan = (struct psb_intel_i2c_chan *)data;
  dev = chan->drm_dev;
  val = REGISTER_READ(dev, chan->reg);
  return ((val & 4096U) != 0U);
}
}
static void set_clock(void *data , int state_high ) 
{ struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 clock_bits ;
  uint32_t tmp ;

  {
  chan = (struct psb_intel_i2c_chan *)data;
  dev = chan->drm_dev;
  reserved = 0U;
  tmp = REGISTER_READ(dev, chan->reg);
  reserved = tmp & 8224U;
  if (state_high != 0) {
    clock_bits = 1U;
  } else {
    clock_bits = 7U;
  }
  REGISTER_WRITE(dev, chan->reg, reserved | clock_bits);
  __const_udelay(85900UL);
  return;
}
}
static void set_data(void *data , int state_high ) 
{ struct psb_intel_i2c_chan *chan ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 data_bits ;
  uint32_t tmp ;

  {
  chan = (struct psb_intel_i2c_chan *)data;
  dev = chan->drm_dev;
  reserved = 0U;
  tmp = REGISTER_READ(dev, chan->reg);
  reserved = tmp & 8224U;
  if (state_high != 0) {
    data_bits = 256U;
  } else {
    data_bits = 1792U;
  }
  REGISTER_WRITE(dev, chan->reg, reserved | data_bits);
  __const_udelay(85900UL);
  return;
}
}
struct psb_intel_i2c_chan *psb_intel_i2c_create(struct drm_device *dev , u32 const   reg ,
                                                char const   *name ) 
{ struct psb_intel_i2c_chan *chan ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  tmp = kzalloc(1736UL, 208U);
  chan = (struct psb_intel_i2c_chan *)tmp;
  if ((unsigned long )chan == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    goto out_free;
  } else {

  }
  chan->drm_dev = dev;
  chan->reg = reg;
  snprintf((char *)(& chan->adapter.name), 20UL, "intel drm %s", name);
  chan->adapter.owner = & __this_module;
  chan->adapter.algo_data = (void *)(& chan->algo);
  chan->adapter.dev.parent = & (dev->pdev)->dev;
  chan->algo.setsda = & set_data;
  chan->algo.setscl = & set_clock;
  chan->algo.getsda = & get_data;
  chan->algo.getscl = & get_clock;
  chan->algo.udelay = 20;
  tmp___0 = usecs_to_jiffies(2200U);
  chan->algo.timeout = (int )tmp___0;
  chan->algo.data = (void *)chan;
  i2c_set_adapdata(& chan->adapter, (void *)chan);
  tmp___1 = i2c_bit_add_bus(& chan->adapter);
  if (tmp___1 != 0) {
    goto out_free;
  } else {

  }
  set_data((void *)chan, 1);
  set_clock((void *)chan, 1);
  __const_udelay(85900UL);
  return (chan);
  out_free: 
  kfree((void const   *)chan);
  return (0);
}
}
void psb_intel_i2c_destroy(struct psb_intel_i2c_chan *chan ) 
{ 

  {
  if ((unsigned long )chan == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    return;
  } else {

  }
  i2c_del_adapter(& chan->adapter);
  kfree((void const   *)chan);
  return;
}
}
void ldv_mutex_lock_171(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_172(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_173(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_174(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_175(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_176(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_177(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_178(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_179(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_180(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_181(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_182(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
extern int printk(char const   *  , ...) ;
extern void __bad_percpu_size(void) ;
__inline static int atomic_read(atomic_t const   *v ) 
{ 

  {
  return ((int )*((int volatile   *)(& v->counter)));
}
}
int ldv_mutex_trylock_198(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_196(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_195(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_197(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_205(struct mutex *ldv_func_arg1 ) ;
int ldv_state_variable_45 ;
extern unsigned long kernel_stack ;
__inline static struct thread_info *current_thread_info(void) 
{ struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
  switch (8UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
  goto ldv_6382;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  goto ldv_6382;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  goto ldv_6382;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  goto ldv_6382;
  default: 
  __bad_percpu_size();
  }
  ldv_6382: 
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
  return (ti);
}
}
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
extern int cpu_number ;
extern void __bad_size_call_parameter(void) ;
extern int i2c_add_adapter(struct i2c_adapter * ) ;
extern atomic_t kgdb_active ;
void gma_intel_i2c_reset(struct drm_device *dev ) ;
int gma_intel_setup_gmbus(struct drm_device *dev ) ;
void gma_intel_gmbus_set_speed(struct i2c_adapter *adapter , int speed ) ;
void gma_intel_gmbus_force_bit(struct i2c_adapter *adapter , bool force_bit ) ;
void gma_intel_teardown_gmbus(struct drm_device *dev ) ;
__inline static struct intel_gmbus *to_intel_gmbus(struct i2c_adapter *i2c ) 
{ struct i2c_adapter  const  *__mptr ;

  {
  __mptr = (struct i2c_adapter  const  *)i2c;
  return ((struct intel_gmbus *)__mptr);
}
}
void gma_intel_i2c_reset(struct drm_device *dev ) 
{ 

  {
  REGISTER_WRITE(dev, 20736U, 0U);
  return;
}
}
static void intel_i2c_quirk_set(struct drm_psb_private *dev_priv , bool enable ) 
{ 

  {
  return;
}
}
static u32 get_reserved(struct intel_gpio *gpio ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  u32 reserved ;
  uint32_t tmp ;

  {
  dev_priv = gpio->dev_priv;
  dev = dev_priv->dev;
  reserved = 0U;
  tmp = REGISTER_READ(dev, gpio->reg);
  reserved = tmp & 8224U;
  return (reserved);
}
}
static int get_clock___0(void *data ) 
{ struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 tmp ;
  uint32_t tmp___0 ;

  {
  gpio = (struct intel_gpio *)data;
  dev_priv = gpio->dev_priv;
  dev = dev_priv->dev;
  tmp = get_reserved(gpio);
  reserved = tmp;
  REGISTER_WRITE(dev, gpio->reg, reserved | 1U);
  REGISTER_WRITE(dev, gpio->reg, reserved);
  tmp___0 = REGISTER_READ(dev, gpio->reg);
  return ((tmp___0 & 16U) != 0U);
}
}
static int get_data___0(void *data ) 
{ struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 tmp ;
  uint32_t tmp___0 ;

  {
  gpio = (struct intel_gpio *)data;
  dev_priv = gpio->dev_priv;
  dev = dev_priv->dev;
  tmp = get_reserved(gpio);
  reserved = tmp;
  REGISTER_WRITE(dev, gpio->reg, reserved | 256U);
  REGISTER_WRITE(dev, gpio->reg, reserved);
  tmp___0 = REGISTER_READ(dev, gpio->reg);
  return ((tmp___0 & 4096U) != 0U);
}
}
static void set_clock___0(void *data , int state_high ) 
{ struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 tmp ;
  u32 clock_bits ;

  {
  gpio = (struct intel_gpio *)data;
  dev_priv = gpio->dev_priv;
  dev = dev_priv->dev;
  tmp = get_reserved(gpio);
  reserved = tmp;
  if (state_high != 0) {
    clock_bits = 1U;
  } else {
    clock_bits = 7U;
  }
  REGISTER_WRITE(dev, gpio->reg, reserved | clock_bits);
  REGISTER_READ(dev, gpio->reg);
  return;
}
}
static void set_data___0(void *data , int state_high ) 
{ struct intel_gpio *gpio ;
  struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  u32 reserved ;
  u32 tmp ;
  u32 data_bits ;

  {
  gpio = (struct intel_gpio *)data;
  dev_priv = gpio->dev_priv;
  dev = dev_priv->dev;
  tmp = get_reserved(gpio);
  reserved = tmp;
  if (state_high != 0) {
    data_bits = 256U;
  } else {
    data_bits = 1792U;
  }
  REGISTER_WRITE(dev, gpio->reg, reserved | data_bits);
  REGISTER_READ(dev, gpio->reg);
  return;
}
}
static struct i2c_adapter *intel_gpio_create(struct drm_psb_private *dev_priv , u32 pin ) 
{ int map_pin_to_reg[8U] ;
  struct intel_gpio *gpio ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  map_pin_to_reg[0] = 0;
  map_pin_to_reg[1] = 20500;
  map_pin_to_reg[2] = 20496;
  map_pin_to_reg[3] = 20504;
  map_pin_to_reg[4] = 20508;
  map_pin_to_reg[5] = 20512;
  map_pin_to_reg[6] = 0;
  map_pin_to_reg[7] = 20516;
  if (pin > 7U || map_pin_to_reg[pin] == 0) {
    return (0);
  } else {

  }
  tmp = kzalloc(1728UL, 208U);
  gpio = (struct intel_gpio *)tmp;
  if ((unsigned long )gpio == (unsigned long )((struct intel_gpio *)0)) {
    return (0);
  } else {

  }
  gpio->reg = (u32 )map_pin_to_reg[pin];
  gpio->dev_priv = dev_priv;
  snprintf((char *)(& gpio->adapter.name), 48UL, "gma500 GPIO%c", (int )*("?BACDE?F" + pin));
  gpio->adapter.owner = & __this_module;
  gpio->adapter.algo_data = (void *)(& gpio->algo);
  gpio->adapter.dev.parent = & ((dev_priv->dev)->pdev)->dev;
  gpio->algo.setsda = & set_data___0;
  gpio->algo.setscl = & set_clock___0;
  gpio->algo.getsda = & get_data___0;
  gpio->algo.getscl = & get_clock___0;
  gpio->algo.udelay = 20;
  tmp___0 = usecs_to_jiffies(2200U);
  gpio->algo.timeout = (int )tmp___0;
  gpio->algo.data = (void *)gpio;
  tmp___1 = i2c_bit_add_bus(& gpio->adapter);
  if (tmp___1 != 0) {
    goto out_free;
  } else {

  }
  return (& gpio->adapter);
  out_free: 
  kfree((void const   *)gpio);
  return (0);
}
}
static int intel_i2c_quirk_xfer(struct drm_psb_private *dev_priv , struct i2c_adapter *adapter ,
                                struct i2c_msg *msgs , int num ) 
{ struct intel_gpio *gpio ;
  struct i2c_adapter  const  *__mptr ;
  int ret ;

  {
  __mptr = (struct i2c_adapter  const  *)adapter;
  gpio = (struct intel_gpio *)__mptr;
  gma_intel_i2c_reset(dev_priv->dev);
  intel_i2c_quirk_set(dev_priv, 1);
  set_data___0((void *)gpio, 1);
  set_clock___0((void *)gpio, 1);
  __const_udelay(85900UL);
  ret = (*((adapter->algo)->master_xfer))(adapter, msgs, num);
  set_data___0((void *)gpio, 1);
  set_clock___0((void *)gpio, 1);
  intel_i2c_quirk_set(dev_priv, 0);
  return (ret);
}
}
static int gmbus_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs , int num ) 
{ struct intel_gmbus *bus ;
  struct i2c_adapter  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  int i ;
  int reg_offset ;
  int tmp ;
  u16 len ;
  u8 *buf ;
  int tmp___0 ;
  u32 val ;
  u32 loop ;
  unsigned long timeout__ ;
  unsigned long tmp___1 ;
  int ret__ ;
  struct thread_info *tmp___2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  u8 *tmp___6 ;
  u32 val___0 ;
  u32 loop___0 ;
  u8 *tmp___7 ;
  int tmp___8 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___9 ;
  int ret_____0 ;
  struct thread_info *tmp___10 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  u8 *tmp___14 ;
  unsigned long timeout_____1 ;
  unsigned long tmp___15 ;
  int ret_____1 ;
  struct thread_info *tmp___16 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  int tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  int tmp___20 ;

  {
  __mptr = (struct i2c_adapter  const  *)adapter;
  bus = (struct intel_gmbus *)__mptr;
  dev_priv = (struct drm_psb_private *)adapter->algo_data;
  dev = dev_priv->dev;
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
    tmp = intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
    return (tmp);
  } else {

  }
  reg_offset = 0;
  REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20736), bus->reg0);
  i = 0;
  goto ldv_39088;
  ldv_39087: 
  len = (msgs + (unsigned long )i)->len;
  buf = (msgs + (unsigned long )i)->buf;
  if ((int )(msgs + (unsigned long )i)->flags & 1) {
    if (i + 1 == num) {
      tmp___0 = 167772160;
    } else {
      tmp___0 = 33554432;
    }
    REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20740), (uint32_t )(((tmp___0 | ((int )len << 16)) | ((int )(msgs + (unsigned long )i)->addr << 1)) | 1073741825));
    REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
    ldv_38970: 
    loop = 0U;
    tmp___1 = msecs_to_jiffies(50U);
    timeout__ = tmp___1 + (unsigned long )jiffies;
    ret__ = 0;
    goto ldv_38964;
    ldv_38963: ;
    if ((long )timeout__ - (long )jiffies < 0L) {
      ret__ = -110;
      goto ldv_38921;
    } else {

    }
    tmp___2 = current_thread_info();
    if ((tmp___2->preempt_count & -268435457) == 0) {
      __vpp_verify = 0;
      switch (4UL) {
      case 1: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
      goto ldv_38927;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
      goto ldv_38927;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
      goto ldv_38927;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
      goto ldv_38927;
      default: 
      __bad_percpu_size();
      }
      ldv_38927: 
      pscr_ret__ = pfo_ret__;
      goto ldv_38933;
      case 2: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
      goto ldv_38937;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
      goto ldv_38937;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
      goto ldv_38937;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
      goto ldv_38937;
      default: 
      __bad_percpu_size();
      }
      ldv_38937: 
      pscr_ret__ = pfo_ret_____0;
      goto ldv_38933;
      case 4: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
      goto ldv_38946;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
      goto ldv_38946;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
      goto ldv_38946;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
      goto ldv_38946;
      default: 
      __bad_percpu_size();
      }
      ldv_38946: 
      pscr_ret__ = pfo_ret_____1;
      goto ldv_38933;
      case 8: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
      goto ldv_38955;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
      goto ldv_38955;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
      goto ldv_38955;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
      goto ldv_38955;
      default: 
      __bad_percpu_size();
      }
      ldv_38955: 
      pscr_ret__ = pfo_ret_____2;
      goto ldv_38933;
      default: 
      __bad_size_call_parameter();
      goto ldv_38933;
      }
      ldv_38933: 
      tmp___3 = atomic_read((atomic_t const   *)(& kgdb_active));
      if (pscr_ret__ != tmp___3) {
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_38964: 
    tmp___4 = REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
    if ((tmp___4 & 3072U) == 0U) {
      goto ldv_38963;
    } else {
      goto ldv_38921;
    }
    ldv_38921: ;
    if (ret__ != 0) {
      goto timeout;
    } else {

    }
    tmp___5 = REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
    if ((tmp___5 & 1024U) != 0U) {
      goto clear_err;
    } else {

    }
    val = REGISTER_READ(dev, (uint32_t )(reg_offset + 20748));
    ldv_38968: 
    tmp___6 = buf;
    buf = buf + 1;
    *tmp___6 = (u8 )val;
    val = val >> 8;
    len = (u16 )((int )len - 1);
    if ((unsigned int )((unsigned short )len) != 0U) {
      loop = loop + 1U;
      if (loop <= 3U) {
        goto ldv_38968;
      } else {
        goto ldv_38969;
      }
    } else {
      goto ldv_38969;
    }
    ldv_38969: ;
    if ((unsigned int )len != 0U) {
      goto ldv_38970;
    } else {
      goto ldv_38971;
    }
    ldv_38971: ;
  } else {
    loop___0 = 0U;
    val___0 = loop___0;
    ldv_38974: 
    tmp___7 = buf;
    buf = buf + 1;
    val___0 = (u32 )((int )*tmp___7 << (int )(loop___0 * 8U)) | val___0;
    len = (u16 )((int )len - 1);
    if ((unsigned int )((unsigned short )len) != 0U) {
      loop___0 = loop___0 + 1U;
      if (loop___0 <= 3U) {
        goto ldv_38974;
      } else {
        goto ldv_38975;
      }
    } else {
      goto ldv_38975;
    }
    ldv_38975: 
    REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20748), val___0);
    if (i + 1 == num) {
      tmp___8 = 134217728;
    } else {
      tmp___8 = 33554432;
    }
    REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20740), (uint32_t )(((tmp___8 | ((int )(msgs + (unsigned long )i)->len << 16)) | ((int )(msgs + (unsigned long )i)->addr << 1)) | 1073741824));
    REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
    goto ldv_39032;
    ldv_39031: 
    tmp___9 = msecs_to_jiffies(50U);
    timeout_____0 = tmp___9 + (unsigned long )jiffies;
    ret_____0 = 0;
    goto ldv_39027;
    ldv_39026: ;
    if ((long )timeout_____0 - (long )jiffies < 0L) {
      ret_____0 = -110;
      goto ldv_38984;
    } else {

    }
    tmp___10 = current_thread_info();
    if ((tmp___10->preempt_count & -268435457) == 0) {
      __vpp_verify___0 = 0;
      switch (4UL) {
      case 1: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
      goto ldv_38990;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
      goto ldv_38990;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
      goto ldv_38990;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
      goto ldv_38990;
      default: 
      __bad_percpu_size();
      }
      ldv_38990: 
      pscr_ret_____0 = pfo_ret_____3;
      goto ldv_38996;
      case 2: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
      goto ldv_39000;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
      goto ldv_39000;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
      goto ldv_39000;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
      goto ldv_39000;
      default: 
      __bad_percpu_size();
      }
      ldv_39000: 
      pscr_ret_____0 = pfo_ret_____4;
      goto ldv_38996;
      case 4: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
      goto ldv_39009;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
      goto ldv_39009;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
      goto ldv_39009;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
      goto ldv_39009;
      default: 
      __bad_percpu_size();
      }
      ldv_39009: 
      pscr_ret_____0 = pfo_ret_____5;
      goto ldv_38996;
      case 8: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
      goto ldv_39018;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
      goto ldv_39018;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
      goto ldv_39018;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
      goto ldv_39018;
      default: 
      __bad_percpu_size();
      }
      ldv_39018: 
      pscr_ret_____0 = pfo_ret_____6;
      goto ldv_38996;
      default: 
      __bad_size_call_parameter();
      goto ldv_38996;
      }
      ldv_38996: 
      tmp___11 = atomic_read((atomic_t const   *)(& kgdb_active));
      if (pscr_ret_____0 != tmp___11) {
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_39027: 
    tmp___12 = REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
    if ((tmp___12 & 3072U) == 0U) {
      goto ldv_39026;
    } else {
      goto ldv_38984;
    }
    ldv_38984: ;
    if (ret_____0 != 0) {
      goto timeout;
    } else {

    }
    tmp___13 = REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
    if ((tmp___13 & 1024U) != 0U) {
      goto clear_err;
    } else {

    }
    loop___0 = 0U;
    val___0 = loop___0;
    ldv_39029: 
    tmp___14 = buf;
    buf = buf + 1;
    val___0 = (u32 )((int )*tmp___14 << (int )(loop___0 * 8U)) | val___0;
    len = (u16 )((int )len - 1);
    if ((unsigned int )((unsigned short )len) != 0U) {
      loop___0 = loop___0 + 1U;
      if (loop___0 <= 3U) {
        goto ldv_39029;
      } else {
        goto ldv_39030;
      }
    } else {
      goto ldv_39030;
    }
    ldv_39030: 
    REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20748), val___0);
    REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
    ldv_39032: ;
    if ((unsigned int )len != 0U) {
      goto ldv_39031;
    } else {
      goto ldv_39033;
    }
    ldv_39033: ;
  }
  if (i + 1 < num) {
    tmp___15 = msecs_to_jiffies(50U);
    timeout_____1 = tmp___15 + (unsigned long )jiffies;
    ret_____1 = 0;
    goto ldv_39085;
    ldv_39084: ;
    if ((long )timeout_____1 - (long )jiffies < 0L) {
      ret_____1 = -110;
      goto ldv_39042;
    } else {

    }
    tmp___16 = current_thread_info();
    if ((tmp___16->preempt_count & -268435457) == 0) {
      __vpp_verify___1 = 0;
      switch (4UL) {
      case 1: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
      goto ldv_39048;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
      goto ldv_39048;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
      goto ldv_39048;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
      goto ldv_39048;
      default: 
      __bad_percpu_size();
      }
      ldv_39048: 
      pscr_ret_____1 = pfo_ret_____7;
      goto ldv_39054;
      case 2: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
      goto ldv_39058;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
      goto ldv_39058;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
      goto ldv_39058;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
      goto ldv_39058;
      default: 
      __bad_percpu_size();
      }
      ldv_39058: 
      pscr_ret_____1 = pfo_ret_____8;
      goto ldv_39054;
      case 4: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
      goto ldv_39067;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
      goto ldv_39067;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
      goto ldv_39067;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
      goto ldv_39067;
      default: 
      __bad_percpu_size();
      }
      ldv_39067: 
      pscr_ret_____1 = pfo_ret_____9;
      goto ldv_39054;
      case 8: ;
      switch (4UL) {
      case 1: 
      __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
      goto ldv_39076;
      case 2: 
      __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
      goto ldv_39076;
      case 4: 
      __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
      goto ldv_39076;
      case 8: 
      __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
      goto ldv_39076;
      default: 
      __bad_percpu_size();
      }
      ldv_39076: 
      pscr_ret_____1 = pfo_ret_____10;
      goto ldv_39054;
      default: 
      __bad_size_call_parameter();
      goto ldv_39054;
      }
      ldv_39054: 
      tmp___17 = atomic_read((atomic_t const   *)(& kgdb_active));
      if (pscr_ret_____1 != tmp___17) {
        msleep(1U);
      } else {

      }
    } else {

    }
    ldv_39085: 
    tmp___18 = REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
    if ((tmp___18 & 17408U) == 0U) {
      goto ldv_39084;
    } else {
      goto ldv_39042;
    }
    ldv_39042: ;
    if (ret_____1 != 0) {
      goto timeout;
    } else {

    }
  } else {

  }
  tmp___19 = REGISTER_READ(dev, (uint32_t )(reg_offset + 20744));
  if ((tmp___19 & 1024U) != 0U) {
    goto clear_err;
  } else {

  }
  i = i + 1;
  ldv_39088: ;
  if (i < num) {
    goto ldv_39087;
  } else {
    goto ldv_39089;
  }
  ldv_39089: ;
  goto done;
  clear_err: 
  REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20740), 2147483648U);
  REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20740), 0U);
  done: 
  REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20736), 0U);
  return (i);
  timeout: 
  printk("\016[drm] GMBUS timed out, falling back to bit banging on pin %d [%s]\n",
         bus->reg0 & 255U, (char *)(& bus->adapter.name));
  REGISTER_WRITE(dev, (uint32_t )(reg_offset + 20736), 0U);
  bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 255U);
  if ((unsigned long )bus->force_bit == (unsigned long )((struct i2c_adapter *)0)) {
    return (-12);
  } else {

  }
  tmp___20 = intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);
  return (tmp___20);
}
}
static u32 gmbus_func(struct i2c_adapter *adapter ) 
{ struct intel_gmbus *bus ;
  struct i2c_adapter  const  *__mptr ;

  {
  __mptr = (struct i2c_adapter  const  *)adapter;
  bus = (struct intel_gmbus *)__mptr;
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
    (*(((bus->force_bit)->algo)->functionality))(bus->force_bit);
  } else {

  }
  return (268402697U);
}
}
static struct i2c_algorithm  const  gmbus_algorithm  =    {& gmbus_xfer, 0, & gmbus_func};
int gma_intel_setup_gmbus(struct drm_device *dev ) 
{ char const   *names[8U] ;
  struct drm_psb_private *dev_priv ;
  int ret ;
  int i ;
  void *tmp ;
  struct intel_gmbus *bus ;
  struct intel_gmbus *bus___0 ;

  {
  names[0] = "disabled";
  names[1] = "ssc";
  names[2] = "vga";
  names[3] = "panel";
  names[4] = "dpc";
  names[5] = "dpb";
  names[6] = "reserved";
  names[7] = "dpd";
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = kcalloc(8UL, 1664UL, 208U);
  dev_priv->gmbus = (struct intel_gmbus *)tmp;
  if ((unsigned long )dev_priv->gmbus == (unsigned long )((struct intel_gmbus *)0)) {
    return (-12);
  } else {

  }
  i = 0;
  goto ldv_39108;
  ldv_39107: 
  bus = dev_priv->gmbus + (unsigned long )i;
  bus->adapter.owner = & __this_module;
  bus->adapter.class = 8U;
  snprintf((char *)(& bus->adapter.name), 48UL, "gma500 gmbus %s", names[i]);
  bus->adapter.dev.parent = & (dev->pdev)->dev;
  bus->adapter.algo_data = (void *)dev_priv;
  bus->adapter.algo = & gmbus_algorithm;
  ret = i2c_add_adapter(& bus->adapter);
  if (ret != 0) {
    goto err;
  } else {

  }
  bus->reg0 = (u32 )i;
  bus->force_bit = intel_gpio_create(dev_priv, (u32 )i);
  i = i + 1;
  ldv_39108: ;
  if (i <= 7) {
    goto ldv_39107;
  } else {
    goto ldv_39109;
  }
  ldv_39109: 
  gma_intel_i2c_reset(dev_priv->dev);
  return (0);
  err: ;
  goto ldv_39112;
  ldv_39111: 
  bus___0 = dev_priv->gmbus + (unsigned long )i;
  i2c_del_adapter(& bus___0->adapter);
  ldv_39112: 
  i = i - 1;
  if (i != 0) {
    goto ldv_39111;
  } else {
    goto ldv_39113;
  }
  ldv_39113: 
  kfree((void const   *)dev_priv->gmbus);
  dev_priv->gmbus = 0;
  return (ret);
}
}
void gma_intel_gmbus_set_speed(struct i2c_adapter *adapter , int speed ) 
{ struct intel_gmbus *bus ;
  struct intel_gmbus *tmp ;

  {
  tmp = to_intel_gmbus(adapter);
  bus = tmp;
  bus->reg0 = (bus->reg0 & 4294966527U) | (u32 )(speed << 8);
  return;
}
}
void gma_intel_gmbus_force_bit(struct i2c_adapter *adapter , bool force_bit ) 
{ struct intel_gmbus *bus ;
  struct intel_gmbus *tmp ;
  struct drm_psb_private *dev_priv ;

  {
  tmp = to_intel_gmbus(adapter);
  bus = tmp;
  if ((int )force_bit) {
    if ((unsigned long )bus->force_bit == (unsigned long )((struct i2c_adapter *)0)) {
      dev_priv = (struct drm_psb_private *)adapter->algo_data;
      bus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 255U);
    } else
    if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
      i2c_del_adapter(bus->force_bit);
      kfree((void const   *)bus->force_bit);
      bus->force_bit = 0;
    } else {

    }
  } else {

  }
  return;
}
}
void gma_intel_teardown_gmbus(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  int i ;
  struct intel_gmbus *bus ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((unsigned long )dev_priv->gmbus == (unsigned long )((struct intel_gmbus *)0)) {
    return;
  } else {

  }
  i = 0;
  goto ldv_39132;
  ldv_39131: 
  bus = dev_priv->gmbus + (unsigned long )i;
  if ((unsigned long )bus->force_bit != (unsigned long )((struct i2c_adapter *)0)) {
    i2c_del_adapter(bus->force_bit);
    kfree((void const   *)bus->force_bit);
  } else {

  }
  i2c_del_adapter(& bus->adapter);
  i = i + 1;
  ldv_39132: ;
  if (i <= 7) {
    goto ldv_39131;
  } else {
    goto ldv_39133;
  }
  ldv_39133: 
  kfree((void const   *)dev_priv->gmbus);
  dev_priv->gmbus = 0;
  return;
}
}
int ldvarg197  ;
struct i2c_adapter *gmbus_algorithm_group0  ;
struct i2c_msg *ldvarg198  ;
void ldv_main_exported_45(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_45 == 1) {
    gmbus_xfer(gmbus_algorithm_group0, ldvarg198, ldvarg197);
    ldv_state_variable_45 = 1;
  } else {

  }
  goto ldv_39141;
  case 1: ;
  if (ldv_state_variable_45 == 1) {
    gmbus_func(gmbus_algorithm_group0);
    ldv_state_variable_45 = 1;
  } else {

  }
  goto ldv_39141;
  default: ;
  goto ldv_39141;
  }
  ldv_39141: ;
  return;
}
}
void ldv_mutex_lock_195(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_196(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_197(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_198(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_203(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_205(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_206(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
__inline static int constant_test_bit(unsigned int nr , unsigned long const volatile   *addr ) 
{ 

  {
  return ((int )((unsigned long )*(addr + (unsigned long )(nr / 64U)) >> ((int )nr & 63)) & 1);
}
}
extern void __might_sleep(char const   * , int  , int  ) ;
extern void clear_page(void * ) ;
extern struct pv_cpu_ops pv_cpu_ops ;
__inline static void __cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                             unsigned int *edx ) 
{ unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_cpu_ops.cpuid == (unsigned long )((void (*)(unsigned int * ,
                                                                                        unsigned int * ,
                                                                                        unsigned int * ,
                                                                                        unsigned int * ))0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (32), "i" (12UL));
    ldv_3703: ;
    goto ldv_3703;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c5;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c4\n  .byte 772b-771b\n  .short %c6\n.popsection\n": "=D" (__edi),
                       "=S" (__esi), "=d" (__edx), "=c" (__ecx): [paravirt_typenum] "i" (32UL),
                       [paravirt_opptr] "i" (& pv_cpu_ops.cpuid), [paravirt_clobber] "i" (511),
                       "D" ((unsigned long )eax), "S" ((unsigned long )ebx), "d" ((unsigned long )ecx),
                       "c" ((unsigned long )edx): "memory", "cc", "rax", "r8", "r9",
                       "r10", "r11");
  return;
}
}
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  *eax = op;
  *ecx = 0U;
  __cpuid(eax, ebx, ecx, edx);
  return;
}
}
__inline static void atomic_set(atomic_t *v , int i ) 
{ 

  {
  v->counter = i;
  return;
}
}
int ldv_mutex_trylock_222(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_220(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_223(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_225(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_227(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_228(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_230(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_219(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_221(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_224(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_226(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_229(struct mutex *ldv_func_arg1 ) ;
__inline static struct thread_info *current_thread_info___0(void) 
{ struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
  switch (8UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
  goto ldv_6364;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  goto ldv_6364;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  goto ldv_6364;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
  goto ldv_6364;
  default: 
  __bad_percpu_size();
  }
  ldv_6364: 
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
  return (ti);
}
}
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
extern void _raw_spin_lock(raw_spinlock_t * ) ;
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
__inline static void spin_lock(spinlock_t *lock ) 
{ 

  {
  _raw_spin_lock(& lock->ldv_5961.rlock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock ) 
{ 

  {
  _raw_spin_unlock(& lock->ldv_5961.rlock);
  return;
}
}
extern void down_read(struct rw_semaphore * ) ;
extern void down_write(struct rw_semaphore * ) ;
extern void up_read(struct rw_semaphore * ) ;
extern void up_write(struct rw_semaphore * ) ;
extern void *vmalloc_user(unsigned long  ) ;
extern void vfree(void const   * ) ;
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ struct page *tmp ;

  {
  tmp = alloc_pages_current(gfp_mask, order);
  return (tmp);
}
}
extern void __free_pages(struct page * , unsigned int  ) ;
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 

  {
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 80L) << 12) + 0xffff880000000000UL));
}
}
__inline static void pagefault_disable(void) 
{ struct thread_info *tmp ;

  {
  tmp = current_thread_info___0();
  tmp->preempt_count = tmp->preempt_count + 1;
  __asm__  volatile   ("": : : "memory");
  return;
}
}
__inline static void pagefault_enable(void) 
{ struct thread_info *tmp ;

  {
  __asm__  volatile   ("": : : "memory");
  tmp = current_thread_info___0();
  tmp->preempt_count = tmp->preempt_count + -1;
  __asm__  volatile   ("": : : "memory");
  return;
}
}
__inline static void *kmap(struct page *page ) 
{ void *tmp ;

  {
  __might_sleep("include/linux/highmem.h", 58, 0);
  tmp = lowmem_page_address((struct page  const  *)page);
  return (tmp);
}
}
__inline static void kunmap(struct page *page ) 
{ 

  {
  return;
}
}
__inline static void *kmap_atomic(struct page *page ) 
{ void *tmp ;

  {
  pagefault_disable();
  tmp = lowmem_page_address((struct page  const  *)page);
  return (tmp);
}
}
__inline static void __kunmap_atomic(void *addr ) 
{ 

  {
  pagefault_enable();
  return;
}
}
struct psb_mmu_driver *psb_mmu_driver_init(uint8_t *registers , int trap_pagefaults ,
                                           int invalid_type , struct drm_psb_private *dev_priv ) ;
void psb_mmu_driver_takedown(struct psb_mmu_driver *driver___0 ) ;
struct psb_mmu_pd *psb_mmu_get_default_pd(struct psb_mmu_driver *driver___0 ) ;
void psb_mmu_mirror_gtt(struct psb_mmu_pd *pd , uint32_t mmu_offset , uint32_t gtt_start ,
                        uint32_t gtt_pages ) ;
struct psb_mmu_pd *psb_mmu_alloc_pd(struct psb_mmu_driver *driver___0 , int trap_pagefaults ,
                                    int invalid_type ) ;
void psb_mmu_free_pagedir(struct psb_mmu_pd *pd ) ;
void psb_mmu_flush(struct psb_mmu_driver *driver___0 , int rc_prot ) ;
void psb_mmu_remove_pfn_sequence(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ) ;
int psb_mmu_insert_pfn_sequence(struct psb_mmu_pd *pd , uint32_t start_pfn , unsigned long address ,
                                uint32_t num_pages , int type ) ;
int psb_mmu_virtual_to_pfn(struct psb_mmu_pd *pd , uint32_t virtual , unsigned long *pfn ) ;
void psb_mmu_set_pd_context(struct psb_mmu_pd *pd , int hw_context ) ;
int psb_mmu_insert_pages(struct psb_mmu_pd *pd , struct page **pages , unsigned long address ,
                         uint32_t num_pages , uint32_t desired_tile_stride , uint32_t hw_tile_stride ,
                         int type ) ;
void psb_mmu_remove_pages(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                          uint32_t desired_tile_stride , uint32_t hw_tile_stride ) ;
__inline static uint32_t psb_mmu_pt_index(uint32_t offset ) 
{ 

  {
  return ((offset >> 12) & 1023U);
}
}
__inline static uint32_t psb_mmu_pd_index(uint32_t offset ) 
{ 

  {
  return (offset >> 22);
}
}
__inline static void psb_clflush(void *addr ) 
{ 

  {
  __asm__  volatile   ("clflush (%0)\n": : "r" (addr): "memory");
  return;
}
}
__inline static void psb_mmu_clflush(struct psb_mmu_driver *driver___0 , void *addr ) 
{ 

  {
  if (driver___0->has_clflush == 0) {
    return;
  } else {

  }
  __asm__  volatile   ("mfence": : : "memory");
  psb_clflush(addr);
  __asm__  volatile   ("mfence": : : "memory");
  return;
}
}
static void psb_page_clflush(struct psb_mmu_driver *driver___0 , struct page *page ) 
{ uint32_t clflush_add ;
  uint32_t clflush_count ;
  int i ;
  uint8_t *clf ;
  void *tmp ;

  {
  clflush_add = (uint32_t )(driver___0->clflush_add >> 12);
  clflush_count = 4096U / clflush_add;
  tmp = kmap_atomic(page);
  clf = (uint8_t *)tmp;
  __asm__  volatile   ("mfence": : : "memory");
  i = 0;
  goto ldv_38010;
  ldv_38009: 
  psb_clflush((void *)clf);
  clf = clf + (unsigned long )clflush_add;
  i = i + 1;
  ldv_38010: ;
  if ((uint32_t )i < clflush_count) {
    goto ldv_38009;
  } else {
    goto ldv_38011;
  }
  ldv_38011: 
  __asm__  volatile   ("mfence": : : "memory");
  __kunmap_atomic((void *)clf);
  return;
}
}
static void psb_pages_clflush(struct psb_mmu_driver *driver___0 , struct page **page ,
                              unsigned long num_pages ) 
{ int i ;
  struct page **tmp ;

  {
  if (driver___0->has_clflush == 0) {
    return;
  } else {

  }
  i = 0;
  goto ldv_38019;
  ldv_38018: 
  tmp = page;
  page = page + 1;
  psb_page_clflush(driver___0, *tmp);
  i = i + 1;
  ldv_38019: ;
  if ((unsigned long )i < num_pages) {
    goto ldv_38018;
  } else {
    goto ldv_38020;
  }
  ldv_38020: ;
  return;
}
}
static void psb_mmu_flush_pd_locked(struct psb_mmu_driver *driver___0 , int force ) 
{ 

  {
  atomic_set(& driver___0->needs_tlbflush, 0);
  return;
}
}
static void psb_mmu_flush_pd(struct psb_mmu_driver *driver___0 , int force ) 
{ 

  {
  down_write(& driver___0->sem);
  psb_mmu_flush_pd_locked(driver___0, force);
  up_write(& driver___0->sem);
  return;
}
}
void psb_mmu_flush(struct psb_mmu_driver *driver___0 , int rc_prot ) 
{ 

  {
  if (rc_prot != 0) {
    down_write(& driver___0->sem);
  } else {

  }
  if (rc_prot != 0) {
    up_write(& driver___0->sem);
  } else {

  }
  return;
}
}
void psb_mmu_set_pd_context(struct psb_mmu_pd *pd , int hw_context ) 
{ 

  {
  psb_pages_clflush(pd->driver, & pd->p, 1UL);
  down_write(& (pd->driver)->sem);
  __asm__  volatile   ("sfence": : : "memory");
  psb_mmu_flush_pd_locked(pd->driver, 1);
  pd->hw_context = hw_context;
  up_write(& (pd->driver)->sem);
  return;
}
}
__inline static unsigned long psb_pd_addr_end(unsigned long addr , unsigned long end ) 
{ unsigned long tmp ;

  {
  addr = (addr + 4194304UL) & 0xffffffffffc00000UL;
  if (addr < end) {
    tmp = addr;
  } else {
    tmp = end;
  }
  return (tmp);
}
}
__inline static uint32_t psb_mmu_mask_pte(uint32_t pfn , int type ) 
{ uint32_t mask ;

  {
  mask = 1U;
  if (type & 1) {
    mask = mask | 8U;
  } else {

  }
  if ((type & 2) != 0) {
    mask = mask | 4U;
  } else {

  }
  if ((type & 4) != 0) {
    mask = mask | 2U;
  } else {

  }
  return ((pfn << 12) | mask);
}
}
struct psb_mmu_pd *psb_mmu_alloc_pd(struct psb_mmu_driver *driver___0 , int trap_pagefaults ,
                                    int invalid_type ) 
{ struct psb_mmu_pd *pd ;
  void *tmp ;
  uint32_t *v ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  tmp = kmalloc(64UL, 208U);
  pd = (struct psb_mmu_pd *)tmp;
  if ((unsigned long )pd == (unsigned long )((struct psb_mmu_pd *)0)) {
    return (0);
  } else {

  }
  pd->p = alloc_pages(4U, 0U);
  if ((unsigned long )pd->p == (unsigned long )((struct page *)0)) {
    goto out_err1;
  } else {

  }
  pd->dummy_pt = alloc_pages(4U, 0U);
  if ((unsigned long )pd->dummy_pt == (unsigned long )((struct page *)0)) {
    goto out_err2;
  } else {

  }
  pd->dummy_page = alloc_pages(4U, 0U);
  if ((unsigned long )pd->dummy_page == (unsigned long )((struct page *)0)) {
    goto out_err3;
  } else {

  }
  if (trap_pagefaults == 0) {
    pd->invalid_pde = psb_mmu_mask_pte((uint32_t )(((long )pd->dummy_pt + 24189255811072L) / 80L),
                                       invalid_type);
    pd->invalid_pte = psb_mmu_mask_pte((uint32_t )(((long )pd->dummy_page + 24189255811072L) / 80L),
                                       invalid_type);
  } else {
    pd->invalid_pde = 0U;
    pd->invalid_pte = 0U;
  }
  tmp___0 = kmap(pd->dummy_pt);
  v = (uint32_t *)tmp___0;
  i = 0;
  goto ldv_38058;
  ldv_38057: 
  *(v + (unsigned long )i) = pd->invalid_pte;
  i = i + 1;
  ldv_38058: ;
  if ((unsigned int )i <= 1023U) {
    goto ldv_38057;
  } else {
    goto ldv_38059;
  }
  ldv_38059: 
  kunmap(pd->dummy_pt);
  tmp___1 = kmap(pd->p);
  v = (uint32_t *)tmp___1;
  i = 0;
  goto ldv_38061;
  ldv_38060: 
  *(v + (unsigned long )i) = pd->invalid_pde;
  i = i + 1;
  ldv_38061: ;
  if ((unsigned int )i <= 1023U) {
    goto ldv_38060;
  } else {
    goto ldv_38062;
  }
  ldv_38062: 
  kunmap(pd->p);
  tmp___2 = kmap(pd->dummy_page);
  clear_page(tmp___2);
  kunmap(pd->dummy_page);
  tmp___3 = vmalloc_user(8192UL);
  pd->tables = (struct psb_mmu_pt **)tmp___3;
  if ((unsigned long )pd->tables == (unsigned long )((struct psb_mmu_pt **)0)) {
    goto out_err4;
  } else {

  }
  pd->hw_context = -1;
  pd->pd_mask = 1U;
  pd->driver = driver___0;
  return (pd);
  out_err4: 
  __free_pages(pd->dummy_page, 0U);
  out_err3: 
  __free_pages(pd->dummy_pt, 0U);
  out_err2: 
  __free_pages(pd->p, 0U);
  out_err1: 
  kfree((void const   *)pd);
  return (0);
}
}
static void psb_mmu_free_pt(struct psb_mmu_pt *pt ) 
{ 

  {
  __free_pages(pt->p, 0U);
  kfree((void const   *)pt);
  return;
}
}
void psb_mmu_free_pagedir(struct psb_mmu_pd *pd ) 
{ struct psb_mmu_driver *driver___0 ;
  struct psb_mmu_pt *pt ;
  int i ;

  {
  driver___0 = pd->driver;
  down_write(& driver___0->sem);
  if (pd->hw_context != -1) {
    psb_mmu_flush_pd_locked(driver___0, 1);
  } else {

  }
  i = 0;
  goto ldv_38074;
  ldv_38073: 
  pt = *(pd->tables + (unsigned long )i);
  if ((unsigned long )pt != (unsigned long )((struct psb_mmu_pt *)0)) {
    psb_mmu_free_pt(pt);
  } else {

  }
  i = i + 1;
  ldv_38074: ;
  if (i <= 1023) {
    goto ldv_38073;
  } else {
    goto ldv_38075;
  }
  ldv_38075: 
  vfree((void const   *)pd->tables);
  __free_pages(pd->dummy_page, 0U);
  __free_pages(pd->dummy_pt, 0U);
  __free_pages(pd->p, 0U);
  kfree((void const   *)pd);
  up_write(& driver___0->sem);
  return;
}
}
static struct psb_mmu_pt *psb_mmu_alloc_pt(struct psb_mmu_pd *pd ) 
{ struct psb_mmu_pt *pt ;
  void *tmp ;
  void *v ;
  uint32_t clflush_add ;
  uint32_t clflush_count ;
  spinlock_t *lock ;
  uint8_t *clf ;
  uint32_t *ptes ;
  int i ;
  uint32_t *tmp___0 ;

  {
  tmp = kmalloc(32UL, 208U);
  pt = (struct psb_mmu_pt *)tmp;
  clflush_add = (uint32_t )((pd->driver)->clflush_add >> 12);
  clflush_count = 4096U / clflush_add;
  lock = & (pd->driver)->lock;
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    return (0);
  } else {

  }
  pt->p = alloc_pages(4U, 0U);
  if ((unsigned long )pt->p == (unsigned long )((struct page *)0)) {
    kfree((void const   *)pt);
    return (0);
  } else {

  }
  spin_lock(lock);
  v = kmap_atomic(pt->p);
  clf = (uint8_t *)v;
  ptes = (uint32_t *)v;
  i = 0;
  goto ldv_38088;
  ldv_38087: 
  tmp___0 = ptes;
  ptes = ptes + 1;
  *tmp___0 = pd->invalid_pte;
  i = i + 1;
  ldv_38088: ;
  if ((unsigned int )i <= 1023U) {
    goto ldv_38087;
  } else {
    goto ldv_38089;
  }
  ldv_38089: ;
  if ((pd->driver)->has_clflush != 0 && pd->hw_context != -1) {
    __asm__  volatile   ("mfence": : : "memory");
    i = 0;
    goto ldv_38091;
    ldv_38090: 
    psb_clflush((void *)clf);
    clf = clf + (unsigned long )clflush_add;
    i = i + 1;
    ldv_38091: ;
    if ((uint32_t )i < clflush_count) {
      goto ldv_38090;
    } else {
      goto ldv_38092;
    }
    ldv_38092: 
    __asm__  volatile   ("mfence": : : "memory");
  } else {

  }
  __kunmap_atomic(v);
  spin_unlock(lock);
  pt->count = 0U;
  pt->pd = pd;
  pt->index = 0U;
  return (pt);
}
}
static struct psb_mmu_pt *psb_mmu_pt_alloc_map_lock(struct psb_mmu_pd *pd , unsigned long addr ) 
{ uint32_t index ;
  uint32_t tmp ;
  struct psb_mmu_pt *pt ;
  uint32_t *v ;
  spinlock_t *lock ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = psb_mmu_pd_index((uint32_t )addr);
  index = tmp;
  lock = & (pd->driver)->lock;
  spin_lock(lock);
  pt = *(pd->tables + (unsigned long )index);
  goto ldv_38101;
  ldv_38102: 
  spin_unlock(lock);
  pt = psb_mmu_alloc_pt(pd);
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    return (0);
  } else {

  }
  spin_lock(lock);
  if ((unsigned long )*(pd->tables + (unsigned long )index) != (unsigned long )((struct psb_mmu_pt *)0)) {
    spin_unlock(lock);
    psb_mmu_free_pt(pt);
    spin_lock(lock);
    pt = *(pd->tables + (unsigned long )index);
    goto ldv_38101;
  } else {

  }
  tmp___0 = kmap_atomic(pd->p);
  v = (uint32_t *)tmp___0;
  *(pd->tables + (unsigned long )index) = pt;
  *(v + (unsigned long )index) = ((uint32_t )(((long )pt->p + 24189255811072L) / 80L) << 12U) | pd->pd_mask;
  pt->index = index;
  __kunmap_atomic((void *)v);
  if (pd->hw_context != -1) {
    psb_mmu_clflush(pd->driver, (void *)v + (unsigned long )index);
    atomic_set(& (pd->driver)->needs_tlbflush, 1);
  } else {

  }
  ldv_38101: ;
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    goto ldv_38102;
  } else {
    goto ldv_38103;
  }
  ldv_38103: 
  tmp___1 = kmap_atomic(pt->p);
  pt->v = (uint32_t *)tmp___1;
  return (pt);
}
}
static struct psb_mmu_pt *psb_mmu_pt_map_lock(struct psb_mmu_pd *pd , unsigned long addr ) 
{ uint32_t index ;
  uint32_t tmp ;
  struct psb_mmu_pt *pt ;
  spinlock_t *lock ;
  void *tmp___0 ;

  {
  tmp = psb_mmu_pd_index((uint32_t )addr);
  index = tmp;
  lock = & (pd->driver)->lock;
  spin_lock(lock);
  pt = *(pd->tables + (unsigned long )index);
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    spin_unlock(lock);
    return (0);
  } else {

  }
  tmp___0 = kmap_atomic(pt->p);
  pt->v = (uint32_t *)tmp___0;
  return (pt);
}
}
static void psb_mmu_pt_unmap_unlock(struct psb_mmu_pt *pt ) 
{ struct psb_mmu_pd *pd ;
  uint32_t *v ;
  void *tmp ;

  {
  pd = pt->pd;
  __kunmap_atomic((void *)pt->v);
  if (pt->count == 0U) {
    tmp = kmap_atomic(pd->p);
    v = (uint32_t *)tmp;
    *(v + (unsigned long )pt->index) = pd->invalid_pde;
    *(pd->tables + (unsigned long )pt->index) = 0;
    if (pd->hw_context != -1) {
      psb_mmu_clflush(pd->driver, (void *)v + (unsigned long )pt->index);
      atomic_set(& (pd->driver)->needs_tlbflush, 1);
    } else {

    }
    __kunmap_atomic((void *)pt->v);
    spin_unlock(& (pd->driver)->lock);
    psb_mmu_free_pt(pt);
    return;
  } else {

  }
  spin_unlock(& (pd->driver)->lock);
  return;
}
}
__inline static void psb_mmu_set_pte(struct psb_mmu_pt *pt , unsigned long addr ,
                                     uint32_t pte ) 
{ uint32_t tmp ;

  {
  tmp = psb_mmu_pt_index((uint32_t )addr);
  *(pt->v + (unsigned long )tmp) = pte;
  return;
}
}
__inline static void psb_mmu_invalidate_pte(struct psb_mmu_pt *pt , unsigned long addr ) 
{ uint32_t tmp ;

  {
  tmp = psb_mmu_pt_index((uint32_t )addr);
  *(pt->v + (unsigned long )tmp) = (pt->pd)->invalid_pte;
  return;
}
}
void psb_mmu_mirror_gtt(struct psb_mmu_pd *pd , uint32_t mmu_offset , uint32_t gtt_start ,
                        uint32_t gtt_pages ) 
{ uint32_t *v ;
  uint32_t start ;
  uint32_t tmp ;
  struct psb_mmu_driver *driver___0 ;
  int num_pages ;
  void *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;

  {
  tmp = psb_mmu_pd_index(mmu_offset);
  start = tmp;
  driver___0 = pd->driver;
  num_pages = (int )gtt_pages;
  down_read(& driver___0->sem);
  spin_lock(& driver___0->lock);
  tmp___0 = kmap_atomic(pd->p);
  v = (uint32_t *)tmp___0;
  v = v + (unsigned long )start;
  goto ldv_38136;
  ldv_38135: 
  tmp___1 = v;
  v = v + 1;
  *tmp___1 = pd->pd_mask | gtt_start;
  gtt_start = gtt_start + 4096U;
  ldv_38136: 
  tmp___2 = gtt_pages;
  gtt_pages = gtt_pages - 1U;
  if (tmp___2 != 0U) {
    goto ldv_38135;
  } else {
    goto ldv_38137;
  }
  ldv_38137: 
  psb_pages_clflush(pd->driver, & pd->p, (unsigned long )num_pages);
  __kunmap_atomic((void *)v);
  spin_unlock(& driver___0->lock);
  if (pd->hw_context != -1) {
    atomic_set(& (pd->driver)->needs_tlbflush, 1);
  } else {

  }
  up_read(& (pd->driver)->sem);
  psb_mmu_flush_pd(pd->driver, 0);
  return;
}
}
struct psb_mmu_pd *psb_mmu_get_default_pd(struct psb_mmu_driver *driver___0 ) 
{ struct psb_mmu_pd *pd ;

  {
  pd = driver___0->default_pd;
  return (pd);
}
}
void psb_mmu_driver_takedown(struct psb_mmu_driver *driver___0 ) 
{ 

  {
  psb_mmu_free_pagedir(driver___0->default_pd);
  kfree((void const   *)driver___0);
  return;
}
}
struct psb_mmu_driver *psb_mmu_driver_init(uint8_t *registers , int trap_pagefaults ,
                                           int invalid_type , struct drm_psb_private *dev_priv ) 
{ struct psb_mmu_driver *driver___0 ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  uint32_t tfms ;
  uint32_t misc ;
  uint32_t cap0 ;
  uint32_t cap4 ;
  uint32_t clflush_size ;
  int tmp___0 ;

  {
  tmp = kmalloc(264UL, 208U);
  driver___0 = (struct psb_mmu_driver *)tmp;
  if ((unsigned long )driver___0 == (unsigned long )((struct psb_mmu_driver *)0)) {
    return (0);
  } else {

  }
  driver___0->dev_priv = dev_priv;
  driver___0->default_pd = psb_mmu_alloc_pd(driver___0, trap_pagefaults, invalid_type);
  if ((unsigned long )driver___0->default_pd == (unsigned long )((struct psb_mmu_pd *)0)) {
    goto out_err1;
  } else {

  }
  spinlock_check(& driver___0->lock);
  __raw_spin_lock_init(& driver___0->lock.ldv_5961.rlock, "&(&driver->lock)->rlock",
                       & __key);
  __init_rwsem(& driver___0->sem, "&driver->sem", & __key___0);
  down_write(& driver___0->sem);
  driver___0->register_map = registers;
  atomic_set(& driver___0->needs_tlbflush, 1);
  driver___0->has_clflush = 0;
  tmp___0 = constant_test_bit(19U, (unsigned long const volatile   *)(& boot_cpu_data.x86_capability));
  if (tmp___0 != 0) {
    cpuid(1U, & tfms, & misc, & cap0, & cap4);
    clflush_size = ((misc >> 8) & 255U) * 8U;
    driver___0->has_clflush = 1;
    driver___0->clflush_add = (int )(((unsigned long )clflush_size * 4096UL) / 4UL);
    driver___0->clflush_mask = (unsigned long )(driver___0->clflush_add + -1);
    driver___0->clflush_mask = ~ driver___0->clflush_mask;
  } else {

  }
  up_write(& driver___0->sem);
  return (driver___0);
  out_err1: 
  kfree((void const   *)driver___0);
  return (0);
}
}
static void psb_mmu_flush_ptes(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                               uint32_t desired_tile_stride , uint32_t hw_tile_stride ) 
{ struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long clflush_add ;
  unsigned long clflush_mask ;
  uint32_t tmp ;

  {
  rows = 1U;
  clflush_add = (unsigned long )(pd->driver)->clflush_add;
  clflush_mask = (pd->driver)->clflush_mask;
  if ((pd->driver)->has_clflush == 0) {
    psb_pages_clflush(pd->driver, & pd->p, (unsigned long )num_pages);
    return;
  } else {

  }
  if (hw_tile_stride != 0U) {
    rows = num_pages / desired_tile_stride;
  } else {
    desired_tile_stride = num_pages;
  }
  add = (unsigned long )(desired_tile_stride << 12);
  row_add = (unsigned long )(hw_tile_stride << 12);
  __asm__  volatile   ("mfence": : : "memory");
  i = 0U;
  goto ldv_38183;
  ldv_38182: 
  addr = address;
  end = addr + add;
  ldv_38180: 
  next = psb_pd_addr_end(addr, end);
  pt = psb_mmu_pt_map_lock(pd, addr);
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    goto ldv_38177;
  } else {

  }
  ldv_38178: 
  tmp = psb_mmu_pt_index((uint32_t )addr);
  psb_clflush((void *)pt->v + (unsigned long )tmp);
  addr = addr + clflush_add;
  if ((addr & clflush_mask) < next) {
    goto ldv_38178;
  } else {
    goto ldv_38179;
  }
  ldv_38179: 
  psb_mmu_pt_unmap_unlock(pt);
  ldv_38177: 
  addr = next;
  if (next != end) {
    goto ldv_38180;
  } else {
    goto ldv_38181;
  }
  ldv_38181: 
  address = address + row_add;
  i = i + 1U;
  ldv_38183: ;
  if (i < rows) {
    goto ldv_38182;
  } else {
    goto ldv_38184;
  }
  ldv_38184: 
  __asm__  volatile   ("mfence": : : "memory");
  return;
}
}
void psb_mmu_remove_pfn_sequence(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ) 
{ struct psb_mmu_pt *pt ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long f_address ;

  {
  f_address = address;
  down_read(& (pd->driver)->sem);
  addr = address;
  end = (unsigned long )(num_pages << 12) + addr;
  ldv_38198: 
  next = psb_pd_addr_end(addr, end);
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    goto out;
  } else {

  }
  ldv_38196: 
  psb_mmu_invalidate_pte(pt, addr);
  pt->count = pt->count - 1U;
  addr = addr + 4096UL;
  if (addr < next) {
    goto ldv_38196;
  } else {
    goto ldv_38197;
  }
  ldv_38197: 
  psb_mmu_pt_unmap_unlock(pt);
  addr = next;
  if (next != end) {
    goto ldv_38198;
  } else {
    goto ldv_38199;
  }
  ldv_38199: ;
  out: ;
  if (pd->hw_context != -1) {
    psb_mmu_flush_ptes(pd, f_address, num_pages, 1U, 1U);
  } else {

  }
  up_read(& (pd->driver)->sem);
  if (pd->hw_context != -1) {
    psb_mmu_flush(pd->driver, 0);
  } else {

  }
  return;
}
}
void psb_mmu_remove_pages(struct psb_mmu_pd *pd , unsigned long address , uint32_t num_pages ,
                          uint32_t desired_tile_stride , uint32_t hw_tile_stride ) 
{ struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long f_address ;

  {
  rows = 1U;
  f_address = address;
  if (hw_tile_stride != 0U) {
    rows = num_pages / desired_tile_stride;
  } else {
    desired_tile_stride = num_pages;
  }
  add = (unsigned long )(desired_tile_stride << 12);
  row_add = (unsigned long )(hw_tile_stride << 12);
  i = 0U;
  goto ldv_38222;
  ldv_38221: 
  addr = address;
  end = addr + add;
  ldv_38219: 
  next = psb_pd_addr_end(addr, end);
  pt = psb_mmu_pt_map_lock(pd, addr);
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    goto ldv_38216;
  } else {

  }
  ldv_38217: 
  psb_mmu_invalidate_pte(pt, addr);
  pt->count = pt->count - 1U;
  addr = addr + 4096UL;
  if (addr < next) {
    goto ldv_38217;
  } else {
    goto ldv_38218;
  }
  ldv_38218: 
  psb_mmu_pt_unmap_unlock(pt);
  ldv_38216: 
  addr = next;
  if (next != end) {
    goto ldv_38219;
  } else {
    goto ldv_38220;
  }
  ldv_38220: 
  address = address + row_add;
  i = i + 1U;
  ldv_38222: ;
  if (i < rows) {
    goto ldv_38221;
  } else {
    goto ldv_38223;
  }
  ldv_38223: ;
  if (pd->hw_context != -1) {
    psb_mmu_flush_ptes(pd, f_address, num_pages, desired_tile_stride, hw_tile_stride);
  } else {

  }
  if (pd->hw_context != -1) {
    psb_mmu_flush(pd->driver, 0);
  } else {

  }
  return;
}
}
int psb_mmu_insert_pfn_sequence(struct psb_mmu_pd *pd , uint32_t start_pfn , unsigned long address ,
                                uint32_t num_pages , int type ) 
{ struct psb_mmu_pt *pt ;
  uint32_t pte ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long f_address ;
  int ret ;
  uint32_t tmp ;

  {
  f_address = address;
  ret = 0;
  down_read(& (pd->driver)->sem);
  addr = address;
  end = (unsigned long )(num_pages << 12) + addr;
  ldv_38241: 
  next = psb_pd_addr_end(addr, end);
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    ret = -12;
    goto out;
  } else {

  }
  ldv_38239: 
  tmp = start_pfn;
  start_pfn = start_pfn + 1U;
  pte = psb_mmu_mask_pte(tmp, type);
  psb_mmu_set_pte(pt, addr, pte);
  pt->count = pt->count + 1U;
  addr = addr + 4096UL;
  if (addr < next) {
    goto ldv_38239;
  } else {
    goto ldv_38240;
  }
  ldv_38240: 
  psb_mmu_pt_unmap_unlock(pt);
  addr = next;
  if (next != end) {
    goto ldv_38241;
  } else {
    goto ldv_38242;
  }
  ldv_38242: ;
  out: ;
  if (pd->hw_context != -1) {
    psb_mmu_flush_ptes(pd, f_address, num_pages, 1U, 1U);
  } else {

  }
  up_read(& (pd->driver)->sem);
  if (pd->hw_context != -1) {
    psb_mmu_flush(pd->driver, 1);
  } else {

  }
  return (ret);
}
}
int psb_mmu_insert_pages(struct psb_mmu_pd *pd , struct page **pages , unsigned long address ,
                         uint32_t num_pages , uint32_t desired_tile_stride , uint32_t hw_tile_stride ,
                         int type ) 
{ struct psb_mmu_pt *pt ;
  uint32_t rows ;
  uint32_t i ;
  uint32_t pte ;
  unsigned long addr ;
  unsigned long end ;
  unsigned long next ;
  unsigned long add ;
  unsigned long row_add ;
  unsigned long f_address ;
  int ret ;
  struct page **tmp ;

  {
  rows = 1U;
  f_address = address;
  ret = 0;
  if (hw_tile_stride != 0U) {
    if (num_pages % desired_tile_stride != 0U) {
      return (-22);
    } else {

    }
    rows = num_pages / desired_tile_stride;
  } else {
    desired_tile_stride = num_pages;
  }
  add = (unsigned long )(desired_tile_stride << 12);
  row_add = (unsigned long )(hw_tile_stride << 12);
  down_read(& (pd->driver)->sem);
  i = 0U;
  goto ldv_38269;
  ldv_38268: 
  addr = address;
  end = addr + add;
  ldv_38266: 
  next = psb_pd_addr_end(addr, end);
  pt = psb_mmu_pt_alloc_map_lock(pd, addr);
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    ret = -12;
    goto out;
  } else {

  }
  ldv_38264: 
  tmp = pages;
  pages = pages + 1;
  pte = psb_mmu_mask_pte((uint32_t )(((long )*tmp + 24189255811072L) / 80L), type);
  psb_mmu_set_pte(pt, addr, pte);
  pt->count = pt->count + 1U;
  addr = addr + 4096UL;
  if (addr < next) {
    goto ldv_38264;
  } else {
    goto ldv_38265;
  }
  ldv_38265: 
  psb_mmu_pt_unmap_unlock(pt);
  addr = next;
  if (next != end) {
    goto ldv_38266;
  } else {
    goto ldv_38267;
  }
  ldv_38267: 
  address = address + row_add;
  i = i + 1U;
  ldv_38269: ;
  if (i < rows) {
    goto ldv_38268;
  } else {
    goto ldv_38270;
  }
  ldv_38270: ;
  out: ;
  if (pd->hw_context != -1) {
    psb_mmu_flush_ptes(pd, f_address, num_pages, desired_tile_stride, hw_tile_stride);
  } else {

  }
  up_read(& (pd->driver)->sem);
  if (pd->hw_context != -1) {
    psb_mmu_flush(pd->driver, 1);
  } else {

  }
  return (ret);
}
}
int psb_mmu_virtual_to_pfn(struct psb_mmu_pd *pd , uint32_t virtual , unsigned long *pfn ) 
{ int ret ;
  struct psb_mmu_pt *pt ;
  uint32_t tmp ;
  spinlock_t *lock ;
  uint32_t *v ;
  void *tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  lock = & (pd->driver)->lock;
  down_read(& (pd->driver)->sem);
  pt = psb_mmu_pt_map_lock(pd, (unsigned long )virtual);
  if ((unsigned long )pt == (unsigned long )((struct psb_mmu_pt *)0)) {
    spin_lock(lock);
    tmp___0 = kmap_atomic(pd->p);
    v = (uint32_t *)tmp___0;
    tmp___1 = psb_mmu_pd_index(virtual);
    tmp = *(v + (unsigned long )tmp___1);
    __kunmap_atomic((void *)v);
    spin_unlock(lock);
    if ((pd->invalid_pde != tmp || (tmp & 1U) == 0U) || (pd->invalid_pte & 1U) == 0U) {
      ret = -22;
      goto out;
    } else {

    }
    ret = 0;
    *pfn = (unsigned long )(pd->invalid_pte >> 12);
    goto out;
  } else {

  }
  tmp___2 = psb_mmu_pt_index(virtual);
  tmp = *(pt->v + (unsigned long )tmp___2);
  if ((tmp & 1U) == 0U) {
    ret = -22;
  } else {
    ret = 0;
    *pfn = (unsigned long )(tmp >> 12);
  }
  psb_mmu_pt_unmap_unlock(pt);
  out: 
  up_read(& (pd->driver)->sem);
  return (ret);
}
}
void ldv_mutex_lock_219(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_220(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_221(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_222(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_223(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_224(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_225(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_226(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_227(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_228(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_229(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_230(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_246(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_244(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_247(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_249(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_251(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_252(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_254(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_256(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_257(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_259(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_243(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_245(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_248(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_250(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_253(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_255(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_258(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_power_mutex(struct mutex *lock ) ;
void ldv_mutex_unlock_power_mutex(struct mutex *lock ) ;
extern void *dev_get_drvdata(struct device  const  * ) ;
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ int tmp ;

  {
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev * ) ;
extern void pci_disable_device(struct pci_dev * ) ;
extern int pci_save_state(struct pci_dev * ) ;
extern void pci_restore_state(struct pci_dev * ) ;
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;

  {
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  return (tmp);
}
}
void gma_power_init(struct drm_device *dev ) ;
void gma_power_uninit(struct drm_device *dev ) ;
int gma_power_suspend(struct device *_dev ) ;
int gma_power_resume(struct device *_dev ) ;
bool gma_power_is_on(struct drm_device *dev ) ;
int psb_runtime_suspend(struct device *dev ) ;
int psb_runtime_resume(struct device *dev ) ;
int psb_runtime_idle(struct device *dev ) ;
void psb_irq_preinstall(struct drm_device *dev ) ;
int psb_irq_postinstall(struct drm_device *dev ) ;
void psb_irq_uninstall(struct drm_device *dev ) ;
extern int __pm_runtime_idle(struct device * , int  ) ;
extern int __pm_runtime_resume(struct device * , int  ) ;
extern int __pm_runtime_set_status(struct device * , unsigned int  ) ;
extern void __pm_runtime_disable(struct device * , bool  ) ;
__inline static int pm_runtime_get(struct device *dev ) 
{ int tmp ;

  {
  tmp = __pm_runtime_resume(dev, 5);
  return (tmp);
}
}
__inline static int pm_runtime_put(struct device *dev ) 
{ int tmp ;

  {
  tmp = __pm_runtime_idle(dev, 5);
  return (tmp);
}
}
__inline static void pm_runtime_set_suspended(struct device *dev ) 
{ 

  {
  __pm_runtime_set_status(dev, 2U);
  return;
}
}
__inline static void pm_runtime_disable(struct device *dev ) 
{ 

  {
  __pm_runtime_disable(dev, 1);
  return;
}
}
static struct mutex power_mutex  ;
static spinlock_t power_ctrl_lock  ;
void gma_power_init(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  dev_priv->apm_base = (uint16_t )dev_priv->apm_reg;
  dev_priv->ospm_base = dev_priv->ospm_base & 65535U;
  dev_priv->display_power = 1;
  dev_priv->display_count = 0;
  dev_priv->suspended = 0;
  spinlock_check(& power_ctrl_lock);
  __raw_spin_lock_init(& power_ctrl_lock.ldv_5961.rlock, "&(&power_ctrl_lock)->rlock",
                       & __key);
  __mutex_init(& power_mutex, "&power_mutex", & __key___0);
  if ((unsigned long )(dev_priv->ops)->init_pm != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
    (*((dev_priv->ops)->init_pm))(dev);
  } else {

  }
  return;
}
}
void gma_power_uninit(struct drm_device *dev ) 
{ 

  {
  pm_runtime_disable(& (dev->pdev)->dev);
  pm_runtime_set_suspended(& (dev->pdev)->dev);
  return;
}
}
static void gma_suspend_display(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((int )dev_priv->suspended) {
    return;
  } else {

  }
  (*((dev_priv->ops)->save_regs))(dev);
  (*((dev_priv->ops)->power_down))(dev);
  dev_priv->display_power = 0;
  return;
}
}
static void gma_resume_display(struct pci_dev *pdev ) 
{ struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  (*((dev_priv->ops)->power_up))(dev);
  dev_priv->suspended = 0;
  dev_priv->display_power = 1;
  iowrite32(dev_priv->pge_ctl | 1U, (void *)dev_priv->vdc_reg + 8224U);
  pci_write_config_word((struct pci_dev  const  *)pdev, 82, (int )((unsigned int )dev_priv->gmch_ctrl | 4U));
  (*((dev_priv->ops)->restore_regs))(dev);
  return;
}
}
static void gma_suspend_pci(struct pci_dev *pdev ) 
{ struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;
  int bsm ;
  int vbt ;

  {
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((int )dev_priv->suspended) {
    return;
  } else {

  }
  pci_save_state(pdev);
  pci_read_config_dword((struct pci_dev  const  *)pdev, 92, (u32 *)(& bsm));
  dev_priv->regs.saveBSM = (uint32_t )bsm;
  pci_read_config_dword((struct pci_dev  const  *)pdev, 252, (u32 *)(& vbt));
  dev_priv->regs.saveVBT = (uint32_t )vbt;
  pci_read_config_dword((struct pci_dev  const  *)pdev, 148, & dev_priv->msi_addr);
  pci_read_config_dword((struct pci_dev  const  *)pdev, 152, & dev_priv->msi_data);
  pci_disable_device(pdev);
  pci_set_power_state(pdev, 3);
  dev_priv->suspended = 1;
  return;
}
}
static bool gma_resume_pci(struct pci_dev *pdev ) 
{ struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;
  int ret ;

  {
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (! dev_priv->suspended) {
    return (1);
  } else {

  }
  pci_set_power_state(pdev, 0);
  pci_restore_state(pdev);
  pci_write_config_dword((struct pci_dev  const  *)pdev, 92, dev_priv->regs.saveBSM);
  pci_write_config_dword((struct pci_dev  const  *)pdev, 252, dev_priv->regs.saveVBT);
  pci_write_config_dword((struct pci_dev  const  *)pdev, 148, dev_priv->msi_addr);
  pci_write_config_dword((struct pci_dev  const  *)pdev, 152, dev_priv->msi_data);
  ret = pci_enable_device(pdev);
  if (ret != 0) {
    dev_err((struct device  const  *)(& pdev->dev), "pci_enable failed: %d\n", ret);
  } else {
    dev_priv->suspended = 0;
  }
  return ((bool )(! ((int )dev_priv->suspended != 0)));
}
}
int gma_power_suspend(struct device *_dev ) 
{ struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
  __mptr = (struct device  const  *)_dev;
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  ldv_mutex_lock_255(& power_mutex);
  if (! dev_priv->suspended) {
    if (dev_priv->display_count != 0) {
      ldv_mutex_unlock_256(& power_mutex);
      dev_err((struct device  const  *)dev->dev, "GPU hardware busy, cannot suspend\n");
      return (-16);
    } else {

    }
    psb_irq_uninstall(dev);
    gma_suspend_display(dev);
    gma_suspend_pci(pdev);
  } else {

  }
  ldv_mutex_unlock_257(& power_mutex);
  return (0);
}
}
int gma_power_resume(struct device *_dev ) 
{ struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  struct drm_device *dev ;
  void *tmp ;

  {
  __mptr = (struct device  const  *)_dev;
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  ldv_mutex_lock_258(& power_mutex);
  gma_resume_pci(pdev);
  gma_resume_display(pdev);
  psb_irq_preinstall(dev);
  psb_irq_postinstall(dev);
  ldv_mutex_unlock_259(& power_mutex);
  return (0);
}
}
bool gma_power_is_on(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  return (dev_priv->display_power);
}
}
bool gma_power_begin(struct drm_device *dev , bool force_on ) 
{ struct drm_psb_private *dev_priv ;
  int ret ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  bool tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = spinlock_check(& power_ctrl_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if ((int )dev_priv->display_power) {
    dev_priv->display_count = dev_priv->display_count + 1;
    pm_runtime_get(& (dev->pdev)->dev);
    spin_unlock_irqrestore(& power_ctrl_lock, flags);
    return (1);
  } else {

  }
  if (! force_on) {
    goto out_false;
  } else {

  }
  tmp___0 = gma_resume_pci(dev->pdev);
  ret = (int )tmp___0;
  if (ret == 0) {
    psb_irq_preinstall(dev);
    psb_irq_postinstall(dev);
    pm_runtime_get(& (dev->pdev)->dev);
    dev_priv->display_count = dev_priv->display_count + 1;
    spin_unlock_irqrestore(& power_ctrl_lock, flags);
    return (1);
  } else {

  }
  out_false: 
  spin_unlock_irqrestore(& power_ctrl_lock, flags);
  return (0);
}
}
void gma_power_end(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = spinlock_check(& power_ctrl_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  dev_priv->display_count = dev_priv->display_count - 1;
  __ret_warn_on = dev_priv->display_count < 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/power.c.prepared",
                       435);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  spin_unlock_irqrestore(& power_ctrl_lock, flags);
  pm_runtime_put(& (dev->pdev)->dev);
  return;
}
}
int psb_runtime_suspend(struct device *dev ) 
{ int tmp ;

  {
  tmp = gma_power_suspend(dev);
  return (tmp);
}
}
int psb_runtime_resume(struct device *dev ) 
{ int tmp ;

  {
  tmp = gma_power_resume(dev);
  return (tmp);
}
}
int psb_runtime_idle(struct device *dev ) 
{ struct drm_device *drmdev ;
  struct device  const  *__mptr ;
  void *tmp ;
  struct drm_psb_private *dev_priv ;

  {
  __mptr = (struct device  const  *)dev;
  tmp = pci_get_drvdata((struct pci_dev *)__mptr + 0xffffffffffffff68UL);
  drmdev = (struct drm_device *)tmp;
  dev_priv = (struct drm_psb_private *)drmdev->dev_private;
  if (dev_priv->display_count != 0) {
    return (0);
  } else {
    return (1);
  }
}
}
void ldv_mutex_lock_243(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_244(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_245(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_246(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_247(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_248(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_249(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_250(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_251(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_252(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_253(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_254(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_255(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_power_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_256(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_power_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_257(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_power_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_258(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_power_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_259(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_power_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
int ldv_mutex_trylock_280(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_278(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_281(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_283(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_285(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_286(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_288(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_290(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_277(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_279(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_282(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_284(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_287(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_289(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_mutex_of_drm_mode_config(struct mutex *lock ) ;
void ldv_mutex_unlock_mutex_of_drm_mode_config(struct mutex *lock ) ;
int ldv_state_variable_36  ;
int ldv_state_variable_8  ;
int ldv_state_variable_46  ;
int ldv_state_variable_47  ;
int ldv_state_variable_15  ;
int ldv_state_variable_20  ;
int ldv_state_variable_10  ;
int ldv_state_variable_48  ;
int ldv_state_variable_30  ;
int ldv_state_variable_6  ;
int ldv_state_variable_0  ;
int ldv_state_variable_21  ;
int ldv_state_variable_5  ;
int ldv_state_variable_45  ;
int ldv_state_variable_33  ;
int ldv_state_variable_16  ;
int ldv_state_variable_13  ;
int ldv_state_variable_43  ;
int ldv_state_variable_2  ;
int ldv_state_variable_25  ;
int ldv_state_variable_50  ;
int ldv_state_variable_12  ;
int ldv_state_variable_26  ;
int ldv_state_variable_28  ;
int ldv_state_variable_22  ;
int ldv_state_variable_14  ;
int ldv_state_variable_11  ;
int ldv_state_variable_44  ;
int ldv_state_variable_38  ;
int ldv_state_variable_37  ;
int ldv_state_variable_29  ;
int ldv_state_variable_17  ;
int ldv_state_variable_51  ;
int ldv_state_variable_18  ;
int ldv_state_variable_39  ;
int ldv_state_variable_19  ;
int ldv_state_variable_49  ;
int ldv_state_variable_9  ;
int ldv_state_variable_27  ;
int ldv_state_variable_24  ;
int ldv_state_variable_3  ;
int ldv_state_variable_32  ;
int ref_cnt  ;
int ldv_state_variable_42  ;
int ldv_state_variable_34  ;
int ldv_state_variable_31  ;
int ldv_state_variable_52  ;
int ldv_state_variable_1  ;
int ldv_state_variable_41  ;
int ldv_state_variable_7  ;
int ldv_state_variable_4  ;
int ldv_state_variable_23  ;
int ldv_state_variable_40  ;
int ldv_state_variable_35  ;
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ void *tmp ;

  {
  tmp = ioremap_nocache(offset, size);
  return (tmp);
}
}
extern void pci_set_master(struct pci_dev * ) ;
extern int set_pages_uc(struct page * , int  ) ;
extern int set_pages_wb(struct page * , int  ) ;
extern struct drm_display_mode *drm_mode_create(struct drm_device * ) ;
extern void drm_mode_destroy(struct drm_device * , struct drm_display_mode * ) ;
extern struct drm_mode_object *drm_mode_object_find(struct drm_device * , uint32_t  ,
                                                    uint32_t  ) ;
extern long drm_ioctl(struct file * , unsigned int  , unsigned long  ) ;
extern int drm_open(struct inode * , struct file * ) ;
extern int drm_fasync(int  , struct file * , int  ) ;
extern ssize_t drm_read(struct file * , char * , size_t  , loff_t * ) ;
extern int drm_release(struct inode * , struct file * ) ;
extern unsigned int drm_poll(struct file * , struct poll_table_struct * ) ;
extern int drm_irq_install(struct drm_device * ) ;
extern int drm_vblank_init(struct drm_device * , int  ) ;
extern void drm_put_dev(struct drm_device * ) ;
extern void drm_gem_vm_open(struct vm_area_struct * ) ;
extern void drm_gem_vm_close(struct vm_area_struct * ) ;
extern int drm_gem_mmap(struct file * , struct vm_area_struct * ) ;
extern int drm_pci_init(struct drm_driver * , struct pci_driver * ) ;
extern void drm_pci_exit(struct drm_driver * , struct pci_driver * ) ;
extern int drm_get_pci_dev(struct pci_dev * , struct pci_device_id  const  * , struct drm_driver * ) ;
extern void drm_kms_helper_poll_init(struct drm_device * ) ;
void psb_intel_crtc_load_lut(struct drm_crtc *crtc ) ;
int psb_intel_get_pipe_from_crtc_id(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
void psb_intel_opregion_fini(struct drm_device *dev ) ;
int psb_intel_opregion_setup(struct drm_device *dev ) ;
void psb_intel_opregion_enable_asle(struct drm_device *dev ) ;
__inline static struct drm_psb_private *psb_priv(struct drm_device *dev ) 
{ 

  {
  return ((struct drm_psb_private *)dev->dev_private);
}
}
irqreturn_t psb_irq_handler(int irq , void *arg ) ;
int psb_enable_vblank(struct drm_device *dev , int pipe ) ;
void psb_disable_vblank(struct drm_device *dev , int pipe ) ;
u32 psb_get_vblank_counter(struct drm_device *dev , int pipe ) ;
struct psb_ops  const  psb_chip_ops ;
struct psb_ops  const  oaktrail_chip_ops ;
struct psb_ops  const  cdv_chip_ops ;
extern void pm_runtime_allow(struct device * ) ;
extern int acpi_video_register(void) ;
static int drm_psb_trap_pagefaults  ;
static int psb_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) ;
static struct pci_device_id  const  pciidlist[28U]  = 
  {      {32902U, 33032U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& psb_chip_ops)}, 
        {32902U,
      33033U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& psb_chip_ops)}, 
        {32902U,
      16640U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16641U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16642U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16643U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16644U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16645U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16646U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16647U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      16648U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& oaktrail_chip_ops)}, 
        {32902U,
      3040U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3041U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3042U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3043U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3044U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3045U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3046U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3047U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3048U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3049U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3050U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3051U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3052U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3053U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U,
      3054U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {32902U, 3055U, 4294967295U, 4294967295U, 0U, 0U, (unsigned long )(& cdv_chip_ops)}, 
        {0U,
      0U, 0U, 0U, 0U, 0U, 0UL}};
struct pci_device_id  const  __mod_pci_device_table  ;
static int psb_adb_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
static int psb_mode_operation_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
static int psb_stolen_memory_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
static int psb_gamma_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
static int psb_dpst_bl_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) ;
static struct drm_ioctl_desc psb_ioctls[9U]  = 
  {      {0U, 17, & psb_gem_create_ioctl, 3222299712U}, 
        {1U, 17, & psb_gem_mmap_ioctl, 3222299713U}, 
        {2U, 1, & psb_stolen_memory_ioctl, 3221775426U}, 
        {0U, 0, 0, 0U}, 
        {4U, 1, & psb_gamma_ioctl, 3238290500U}, 
        {5U, 1, & psb_adb_ioctl, 3221513285U}, 
        {6U, 1, & psb_dpst_bl_ioctl, 3221513286U}, 
        {7U, 1, & psb_mode_operation_ioctl, 3227018311U}, 
        {8U, 0, & psb_intel_get_pipe_from_crtc_id, 3221775432U}};
static void psb_lastclose(struct drm_device *dev ) 
{ 

  {
  return;
}
}
static int psb_do_init(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_gtt *pg ;
  uint32_t stolen_gtt ;
  int ret ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  unsigned int tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pg = & dev_priv->gtt;
  ret = -12;
  if ((pg->mmu_gatt_start & 268435455U) != 0U) {
    dev_err((struct device  const  *)dev->dev, "Gatt must be 256M aligned. This is a bug.\n");
    ret = -22;
    goto out_err;
  } else {

  }
  stolen_gtt = (uint32_t )(pg->stolen_size >> 12) * 4U;
  stolen_gtt = (uint32_t )(((unsigned long )stolen_gtt + 4095UL) >> 12);
  if (stolen_gtt < pg->gtt_pages) {
    stolen_gtt = stolen_gtt;
  } else {
    stolen_gtt = pg->gtt_pages;
  }
  dev_priv->gatt_free_offset = pg->mmu_gatt_start + stolen_gtt * 4194304U;
  spinlock_check(& dev_priv->irqmask_lock);
  __raw_spin_lock_init(& dev_priv->irqmask_lock.ldv_5961.rlock, "&(&dev_priv->irqmask_lock)->rlock",
                       & __key);
  spinlock_check(& dev_priv->lock_2d);
  __raw_spin_lock_init(& dev_priv->lock_2d.ldv_5961.rlock, "&(&dev_priv->lock_2d)->rlock",
                       & __key___0);
  iowrite32(0U, (void *)dev_priv->sgx_reg + 3192U);
  iowrite32(0U, (void *)dev_priv->sgx_reg + 3196U);
  ioread32((void *)dev_priv->sgx_reg + 3196U);
  tmp = ioread32((void *)dev_priv->sgx_reg + 3072U);
  iowrite32(tmp | 130816U, (void *)dev_priv->sgx_reg + 3072U);
  psb_spank(dev_priv);
  iowrite32(pg->gatt_start, (void *)dev_priv->sgx_reg + 3208U);
  return (0);
  out_err: ;
  return (ret);
}
}
static int psb_driver_unload(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_gtt *pg ;
  struct psb_mmu_pd *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((unsigned long )dev_priv != (unsigned long )((struct drm_psb_private *)0)) {
    if ((unsigned long )dev_priv->backlight_device != (unsigned long )((struct backlight_device *)0)) {
      gma_backlight_exit(dev);
    } else {

    }
    psb_modeset_cleanup(dev);
    if ((unsigned long )(dev_priv->ops)->chip_teardown != (unsigned long )((void (*/* const  */)(struct drm_device * ))0)) {
      (*((dev_priv->ops)->chip_teardown))(dev);
    } else {

    }
    psb_intel_opregion_fini(dev);
    if ((unsigned long )dev_priv->pf_pd != (unsigned long )((struct psb_mmu_pd *)0)) {
      psb_mmu_free_pagedir(dev_priv->pf_pd);
      dev_priv->pf_pd = 0;
    } else {

    }
    if ((unsigned long )dev_priv->mmu != (unsigned long )((struct psb_mmu_driver *)0)) {
      pg = & dev_priv->gtt;
      down_read(& pg->sem);
      tmp = psb_mmu_get_default_pd(dev_priv->mmu);
      psb_mmu_remove_pfn_sequence(tmp, (unsigned long )pg->mmu_gatt_start, (uint32_t )(dev_priv->vram_stolen_size >> 12));
      up_read(& pg->sem);
      psb_mmu_driver_takedown(dev_priv->mmu);
      dev_priv->mmu = 0;
    } else {

    }
    psb_gtt_takedown(dev);
    if ((unsigned long )dev_priv->scratch_page != (unsigned long )((struct page *)0)) {
      set_pages_wb(dev_priv->scratch_page, 1);
      __free_pages(dev_priv->scratch_page, 0U);
      dev_priv->scratch_page = 0;
    } else {

    }
    if ((unsigned long )dev_priv->vdc_reg != (unsigned long )((uint8_t *)0)) {
      iounmap((void volatile   *)dev_priv->vdc_reg);
      dev_priv->vdc_reg = 0;
    } else {

    }
    if ((unsigned long )dev_priv->sgx_reg != (unsigned long )((uint8_t *)0)) {
      iounmap((void volatile   *)dev_priv->sgx_reg);
      dev_priv->sgx_reg = 0;
    } else {

    }
    psb_intel_destroy_bios(dev);
    kfree((void const   *)dev_priv);
    dev->dev_private = 0;
  } else {

  }
  gma_power_uninit(dev);
  return (0);
}
}
static int psb_driver_load(struct drm_device *dev , unsigned long chipset ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long resource_start ;
  unsigned long irqflags ;
  int ret ;
  struct drm_connector *connector ;
  struct psb_intel_encoder *psb_intel_encoder ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct psb_mmu_pd *tmp___2 ;
  raw_spinlock_t *tmp___3 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  ret = -12;
  tmp = kzalloc(5056UL, 208U);
  dev_priv = (struct drm_psb_private *)tmp;
  if ((unsigned long )dev_priv == (unsigned long )((struct drm_psb_private *)0)) {
    return (-12);
  } else {

  }
  dev_priv->ops = (struct psb_ops  const  *)chipset;
  dev_priv->dev = dev;
  dev->dev_private = (void *)dev_priv;
  pci_set_master(dev->pdev);
  dev_priv->num_pipe = (uint32_t )(dev_priv->ops)->pipes;
  resource_start = (unsigned long )(dev->pdev)->resource[0].start;
  tmp___0 = ioremap((resource_size_t )resource_start, 524288UL);
  dev_priv->vdc_reg = (uint8_t *)tmp___0;
  if ((unsigned long )dev_priv->vdc_reg == (unsigned long )((uint8_t *)0)) {
    goto out_err;
  } else {

  }
  tmp___1 = ioremap((resource_size_t )((unsigned long )(dev_priv->ops)->sgx_offset + resource_start),
                    32768UL);
  dev_priv->sgx_reg = (uint8_t *)tmp___1;
  if ((unsigned long )dev_priv->sgx_reg == (unsigned long )((uint8_t *)0)) {
    goto out_err;
  } else {

  }
  psb_intel_opregion_setup(dev);
  ret = (*((dev_priv->ops)->chip_setup))(dev);
  if (ret != 0) {
    goto out_err;
  } else {

  }
  gma_power_init(dev);
  ret = -12;
  dev_priv->scratch_page = alloc_pages(32772U, 0U);
  if ((unsigned long )dev_priv->scratch_page == (unsigned long )((struct page *)0)) {
    goto out_err;
  } else {

  }
  set_pages_uc(dev_priv->scratch_page, 1);
  ret = psb_gtt_init(dev, 0);
  if (ret != 0) {
    goto out_err;
  } else {

  }
  dev_priv->mmu = psb_mmu_driver_init(0, drm_psb_trap_pagefaults, 0, dev_priv);
  if ((unsigned long )dev_priv->mmu == (unsigned long )((struct psb_mmu_driver *)0)) {
    goto out_err;
  } else {

  }
  dev_priv->pf_pd = psb_mmu_alloc_pd(dev_priv->mmu, 1, 0);
  if ((unsigned long )dev_priv->pf_pd == (unsigned long )((struct psb_mmu_pd *)0)) {
    goto out_err;
  } else {

  }
  tmp___2 = psb_mmu_get_default_pd(dev_priv->mmu);
  psb_mmu_set_pd_context(tmp___2, 0);
  psb_mmu_set_pd_context(dev_priv->pf_pd, 1);
  ret = psb_do_init(dev);
  if (ret != 0) {
    return (ret);
  } else {

  }
  iowrite32(536870912U, (void *)dev_priv->sgx_reg + 2744U);
  iowrite32(805306368U, (void *)dev_priv->sgx_reg + 3244U);
  acpi_video_register();
  ret = drm_vblank_init(dev, (int )dev_priv->num_pipe);
  if (ret != 0) {
    goto out_err;
  } else {

  }
  dev_priv->vdc_irq_mask = 0U;
  dev_priv->pipestat[0] = 0U;
  dev_priv->pipestat[1] = 0U;
  dev_priv->pipestat[2] = 0U;
  tmp___3 = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp___3);
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
  iowrite32(0U, (void *)dev_priv->vdc_reg + 8352U);
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8360U);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  drm_irq_install(dev);
  dev->vblank_disable_allowed = 1;
  dev->max_vblank_count = 16777215U;
  (dev->driver)->get_vblank_counter = & psb_get_vblank_counter;
  psb_modeset_init(dev);
  psb_fbdev_init(dev);
  drm_kms_helper_poll_init(dev);
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
  connector = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
  goto ldv_39266;
  ldv_39265: 
  psb_intel_encoder = psb_intel_attached_encoder(connector);
  switch (psb_intel_encoder->type) {
  case 4: ;
  case 7: 
  ret = gma_backlight_init(dev);
  goto ldv_39264;
  }
  ldv_39264: 
  __mptr___0 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  ldv_39266: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
    goto ldv_39265;
  } else {
    goto ldv_39267;
  }
  ldv_39267: ;
  if (ret != 0) {
    return (ret);
  } else {

  }
  psb_intel_opregion_enable_asle(dev);
  return (0);
  out_err: 
  psb_driver_unload(dev);
  return (ret);
}
}
static int psb_driver_device_is_agp(struct drm_device *dev ) 
{ 

  {
  return (0);
}
}
__inline static void get_brightness(struct backlight_device *bd ) 
{ 

  {
  return;
}
}
static int psb_dpst_bl_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_psb_private *tmp ;
  uint32_t *arg ;

  {
  tmp = psb_priv(dev);
  dev_priv = tmp;
  arg = (uint32_t *)data;
  dev_priv->blc_adj2 = *arg;
  get_brightness(dev_priv->backlight_device);
  return (0);
}
}
static int psb_adb_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_psb_private *tmp ;
  uint32_t *arg ;

  {
  tmp = psb_priv(dev);
  dev_priv = tmp;
  arg = (uint32_t *)data;
  dev_priv->blc_adj1 = *arg;
  get_brightness(dev_priv->backlight_device);
  return (0);
}
}
static int psb_gamma_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_psb_dpst_lut_arg *lut_arg ;
  struct drm_mode_object *obj ;
  struct drm_crtc *crtc ;
  struct drm_connector *connector ;
  struct psb_intel_crtc *psb_intel_crtc ;
  int i ;
  int32_t obj_id ;
  struct _ddebug descriptor ;
  long tmp ;
  struct drm_mode_object  const  *__mptr ;
  struct drm_crtc  const  *__mptr___0 ;

  {
  lut_arg = (struct drm_psb_dpst_lut_arg *)data;
  i = 0;
  obj_id = lut_arg->output_id;
  obj = drm_mode_object_find(dev, (uint32_t )obj_id, 3233857728U);
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "psb_gamma_ioctl";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c.prepared";
    descriptor.format = "Invalid Connector object.\n";
    descriptor.lineno = 585U;
    descriptor.flags = 0U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "Invalid Connector object.\n");
    } else {

    }
    return (-22);
  } else {

  }
  __mptr = (struct drm_mode_object  const  *)obj;
  connector = (struct drm_connector *)__mptr + 0xfffffffffffffb70UL;
  crtc = (connector->encoder)->crtc;
  __mptr___0 = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr___0;
  i = 0;
  goto ldv_39307;
  ldv_39306: 
  psb_intel_crtc->lut_adj[i] = lut_arg->lut[i];
  i = i + 1;
  ldv_39307: ;
  if (i <= 255) {
    goto ldv_39306;
  } else {
    goto ldv_39308;
  }
  ldv_39308: 
  psb_intel_crtc_load_lut(crtc);
  return (0);
}
}
static int psb_mode_operation_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ uint32_t obj_id ;
  uint16_t op ;
  struct drm_mode_modeinfo *umode ;
  struct drm_display_mode *mode ;
  struct drm_psb_mode_operation_arg *arg ;
  struct drm_mode_object *obj ;
  struct drm_connector *connector ;
  struct drm_connector_helper_funcs *connector_funcs ;
  int ret ;
  int resp ;
  struct drm_mode_object  const  *__mptr ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  mode = 0;
  ret = 0;
  resp = 0;
  arg = (struct drm_psb_mode_operation_arg *)data;
  obj_id = arg->obj_id;
  op = arg->operation;
  switch ((int )op) {
  case 1: 
  umode = & arg->mode;
  ldv_mutex_lock_289(& dev->mode_config.mutex);
  obj = drm_mode_object_find(dev, obj_id, 3233857728U);
  if ((unsigned long )obj == (unsigned long )((struct drm_mode_object *)0)) {
    ret = -22;
    goto mode_op_out;
  } else {

  }
  __mptr = (struct drm_mode_object  const  *)obj;
  connector = (struct drm_connector *)__mptr + 0xfffffffffffffb70UL;
  mode = drm_mode_create(dev);
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
    ret = -12;
    goto mode_op_out;
  } else {

  }
  mode->clock = (int )umode->clock;
  mode->hdisplay = (int )umode->hdisplay;
  mode->hsync_start = (int )umode->hsync_start;
  mode->hsync_end = (int )umode->hsync_end;
  mode->htotal = (int )umode->htotal;
  mode->hskew = (int )umode->hskew;
  mode->vdisplay = (int )umode->vdisplay;
  mode->vsync_start = (int )umode->vsync_start;
  mode->vsync_end = (int )umode->vsync_end;
  mode->vtotal = (int )umode->vtotal;
  mode->vscan = (int )umode->vscan;
  mode->vrefresh = (int )umode->vrefresh;
  mode->flags = umode->flags;
  mode->type = umode->type;
  strncpy((char *)(& mode->name), (char const   *)(& umode->name), 32UL);
  mode->name[31] = 0;
  connector_funcs = (struct drm_connector_helper_funcs *)connector->helper_private;
  if ((unsigned long )connector_funcs->mode_valid != (unsigned long )((int (*)(struct drm_connector * ,
                                                                               struct drm_display_mode * ))0)) {
    resp = (*(connector_funcs->mode_valid))(connector, mode);
    arg->data = (u64 )resp;
  } else {

  }
  if ((unsigned long )mode != (unsigned long )((struct drm_display_mode *)0)) {
    drm_mode_destroy(dev, mode);
  } else {

  }
  mode_op_out: 
  ldv_mutex_unlock_290(& dev->mode_config.mutex);
  return (ret);
  default: 
  descriptor.modname = "gma500_gfx";
  descriptor.function = "psb_mode_operation_ioctl";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_drv.c.prepared";
  descriptor.format = "Unsupported psb mode operation\n";
  descriptor.lineno = 676U;
  descriptor.flags = 0U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "Unsupported psb mode operation\n");
  } else {

  }
  return (-95);
  }
  return (0);
}
}
static int psb_stolen_memory_ioctl(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_psb_private *tmp ;
  struct drm_psb_stolen_memory_arg *arg ;

  {
  tmp = psb_priv(dev);
  dev_priv = tmp;
  arg = (struct drm_psb_stolen_memory_arg *)data;
  arg->base = dev_priv->stolen_base;
  arg->size = (u32 )dev_priv->vram_stolen_size;
  return (0);
}
}
static int psb_driver_open(struct drm_device *dev , struct drm_file *priv ) 
{ 

  {
  return (0);
}
}
static void psb_driver_close(struct drm_device *dev , struct drm_file *priv ) 
{ 

  {
  return;
}
}
static long psb_unlocked_ioctl(struct file *filp , unsigned int cmd , unsigned long arg ) 
{ struct drm_file *file_priv ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  unsigned int runtime_allowed ;
  long tmp ;

  {
  file_priv = (struct drm_file *)filp->private_data;
  dev = (file_priv->minor)->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (runtime_allowed == 1U && (int )dev_priv->is_lvds_on) {
    runtime_allowed = runtime_allowed + 1U;
    pm_runtime_allow(& (dev->pdev)->dev);
    dev_priv->rpm_enabled = 1;
  } else {

  }
  tmp = drm_ioctl(filp, cmd, arg);
  return (tmp);
}
}
static void psb_driver_preclose(struct drm_device *dev , struct drm_file *priv ) 
{ 

  {
  return;
}
}
static void psb_remove(struct pci_dev *pdev ) 
{ struct drm_device *dev ;
  void *tmp ;

  {
  tmp = pci_get_drvdata(pdev);
  dev = (struct drm_device *)tmp;
  drm_put_dev(dev);
  return;
}
}
static struct dev_pm_ops  const  psb_pm_ops  = 
     {0, 0, & gma_power_suspend, & gma_power_resume, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, & psb_runtime_suspend, & psb_runtime_resume, & psb_runtime_idle};
static struct vm_operations_struct  const  psb_gem_vm_ops  = 
     {& drm_gem_vm_open, & drm_gem_vm_close, & psb_gem_fault, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  psb_gem_fops  = 
     {& __this_module, 0, & drm_read, 0, 0, 0, 0, & drm_poll, & psb_unlocked_ioctl,
    0, & drm_gem_mmap, & drm_open, 0, & drm_release, 0, 0, & drm_fasync, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0};
static struct drm_driver driver  = 
     {& psb_driver_load, 0, & psb_driver_open, & psb_driver_preclose, & psb_driver_close,
    & psb_lastclose, & psb_driver_unload, 0, 0, 0, 0, 0, & psb_get_vblank_counter,
    & psb_enable_vblank, & psb_disable_vblank, & psb_driver_device_is_agp, 0, 0, & psb_irq_handler,
    & psb_irq_preinstall, & psb_irq_postinstall, & psb_irq_uninstall, 0, 0, 0, 0,
    0, 0, 0, & psb_gem_init_object, & psb_gem_free_object, 0, 0, 0, 0, 0, 0, 0, & psb_gem_dumb_create,
    & psb_gem_dumb_map_gtt, & psb_gem_dumb_destroy, & psb_gem_vm_ops, 1, 0, 0, (char *)"gma500",
    (char *)"DRM driver for the Intel GMA500", (char *)"2011-06-06", 12736U, 0, (struct drm_ioctl_desc *)(& psb_ioctls),
    9, & psb_gem_fops, {0}, 0, {0, 0}};
static struct pci_driver psb_pci_driver  = 
     {{0, 0}, "gma500", (struct pci_device_id  const  *)(& pciidlist), & psb_probe,
    & psb_remove, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0,
                                        0, & psb_pm_ops, 0}, {{{{{{0U}}, 0U, 0U, 0,
                                                                 {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0}}};
static int psb_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ int tmp ;

  {
  tmp = drm_get_pci_dev(pdev, ent, & driver);
  return (tmp);
}
}
static int psb_init(void) 
{ int tmp ;

  {
  tmp = drm_pci_init(& driver, & psb_pci_driver);
  return (tmp);
}
}
static void psb_exit(void) 
{ 

  {
  drm_pci_exit(& driver, & psb_pci_driver);
  return;
}
}
extern int ldv_psb_pm_ops_complete_44(void) ;
int ldvarg157  ;
struct vm_fault *ldvarg202  ;
int ldv_retval_2  ;
size_t ldvarg118  ;
struct file *ldvarg115  ;
unsigned int ldvarg109  ;
struct drm_device *driver_group2  ;
int ldv_retval_5  ;
int ldv_retval_0  ;
struct vm_area_struct *psb_gem_vm_ops_group0  ;
uint32_t ldvarg165  ;
int ldv_retval_11  ;
int ldv_retval_1  ;
struct file *ldvarg114  ;
struct pci_device_id *ldvarg44  ;
extern int ldv_psb_pm_ops_resume_noirq_44(void) ;
extern int ldv_psb_pm_ops_prepare_44(void) ;
struct file *ldvarg110  ;
unsigned long ldvarg163  ;
void ldv_check_final_state(void) ;
int ldv_retval_8  ;
struct drm_mode_create_dumb *ldvarg161  ;
struct drm_gem_object *driver_group0  ;
void *ldvarg160  ;
int ldvarg158  ;
int ldv_retval_7  ;
struct device *psb_pm_ops_group1  ;
struct inode *psb_gem_fops_group1  ;
extern int ldv_driver_release_41(void) ;
int ldv_retval_12  ;
extern int ldv_psb_pm_ops_suspend_late_44(void) ;
struct vm_area_struct *ldvarg111  ;
void ldv_initialize(void) ;
int ldv_retval_6  ;
int ldvarg112  ;
int ldvarg166  ;
struct pci_dev *psb_pci_driver_group0  ;
int ldvarg113  ;
char *ldvarg119  ;
uint64_t *ldvarg164  ;
struct drm_file *driver_group1  ;
struct poll_table_struct *ldvarg116  ;
extern int ldv_psb_pm_ops_resume_early_44(void) ;
int ldv_retval_9  ;
int ldv_retval_10  ;
int ldv_retval_4  ;
unsigned long ldvarg108  ;
int ldvarg159  ;
extern int ldv_psb_pm_ops_suspend_noirq_44(void) ;
loff_t *ldvarg117  ;
uint32_t ldvarg162  ;
int ldv_retval_3  ;
struct file *psb_gem_fops_group2  ;
void ldv_main_exported_16(void) ;
void ldv_main_exported_13(void) ;
void ldv_main_exported_15(void) ;
void ldv_main_exported_14(void) ;
void ldv_main_exported_25(void) ;
void ldv_main_exported_22(void) ;
void ldv_main_exported_24(void) ;
void ldv_main_exported_23(void) ;
void ldv_main_exported_21(void) ;
void ldv_main_exported_20(void) ;
void ldv_main_exported_38(void) ;
void ldv_main_exported_39(void) ;
void ldv_main_exported_27(void) ;
void ldv_main_exported_35(void) ;
void ldv_main_exported_34(void) ;
void ldv_main_exported_36(void) ;
void ldv_main_exported_37(void) ;
void ldv_main_exported_33(void) ;
void ldv_main_exported_32(void) ;
void ldv_main_exported_30(void) ;
void ldv_main_exported_31(void) ;
void ldv_main_exported_29(void) ;
void ldv_main_exported_6(void) ;
void ldv_main_exported_28(void) ;
void ldv_main_exported_4(void) ;
void ldv_main_exported_3(void) ;
void ldv_main_exported_2(void) ;
void ldv_main_exported_5(void) ;
void ldv_main_exported_11(void) ;
void ldv_main_exported_10(void) ;
void ldv_main_exported_9(void) ;
void ldv_main_exported_12(void) ;
void ldv_main_exported_1(void) ;
void ldv_main_exported_7(void) ;
void ldv_main_exported_18(void) ;
void ldv_main_exported_19(void) ;
void ldv_main_exported_17(void) ;
void ldv_main_exported_8(void) ;
void ldv_main_exported_26(void) ;
int main(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  ldv_initialize();
  ldv_state_variable_33 = 0;
  ldv_state_variable_32 = 0;
  ldv_state_variable_21 = 0;
  ldv_state_variable_7 = 0;
  ldv_state_variable_26 = 0;
  ldv_state_variable_17 = 0;
  ldv_state_variable_2 = 0;
  ldv_state_variable_1 = 0;
  ldv_state_variable_18 = 0;
  ldv_state_variable_30 = 0;
  ldv_state_variable_16 = 0;
  ldv_state_variable_44 = 0;
  ldv_state_variable_27 = 0;
  ldv_state_variable_25 = 0;
  ldv_state_variable_28 = 0;
  ldv_state_variable_40 = 0;
  ldv_state_variable_20 = 0;
  ldv_state_variable_14 = 0;
  ldv_state_variable_49 = 0;
  ldv_state_variable_24 = 0;
  ldv_state_variable_10 = 0;
  ldv_state_variable_31 = 0;
  ldv_state_variable_35 = 0;
  ldv_state_variable_11 = 0;
  ldv_state_variable_48 = 0;
  ldv_state_variable_42 = 0;
  ldv_state_variable_22 = 0;
  ref_cnt = 0;
  ldv_state_variable_0 = 1;
  ldv_state_variable_46 = 0;
  ldv_state_variable_13 = 0;
  ldv_state_variable_23 = 0;
  ldv_state_variable_29 = 0;
  ldv_state_variable_6 = 0;
  ldv_state_variable_50 = 0;
  ldv_state_variable_39 = 0;
  ldv_state_variable_36 = 0;
  ldv_state_variable_3 = 0;
  ldv_state_variable_51 = 0;
  ldv_state_variable_9 = 0;
  ldv_state_variable_41 = 0;
  ldv_state_variable_12 = 0;
  ldv_state_variable_47 = 0;
  ldv_state_variable_15 = 0;
  ldv_state_variable_52 = 0;
  ldv_state_variable_38 = 0;
  ldv_state_variable_8 = 0;
  ldv_state_variable_4 = 0;
  ldv_state_variable_34 = 0;
  ldv_state_variable_45 = 0;
  ldv_state_variable_37 = 0;
  ldv_state_variable_43 = 0;
  ldv_state_variable_19 = 0;
  ldv_state_variable_5 = 0;
  ldv_39678: 
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_33 != 0) {
    ldv_main_exported_33();
  } else {

  }
  goto ldv_39566;
  case 1: ;
  if (ldv_state_variable_32 != 0) {
    ldv_main_exported_32();
  } else {

  }
  goto ldv_39566;
  case 2: ;
  if (ldv_state_variable_21 != 0) {
    ldv_main_exported_21();
  } else {

  }
  goto ldv_39566;
  case 3: ;
  if (ldv_state_variable_7 != 0) {
    ldv_main_exported_7();
  } else {

  }
  goto ldv_39566;
  case 4: ;
  if (ldv_state_variable_26 != 0) {
    ldv_main_exported_26();
  } else {

  }
  goto ldv_39566;
  case 5: ;
  if (ldv_state_variable_17 != 0) {
    ldv_main_exported_17();
  } else {

  }
  goto ldv_39566;
  case 6: ;
  if (ldv_state_variable_2 != 0) {
    ldv_main_exported_2();
  } else {

  }
  goto ldv_39566;
  case 7: ;
  if (ldv_state_variable_1 != 0) {
    ldv_main_exported_1();
  } else {

  }
  goto ldv_39566;
  case 8: ;
  if (ldv_state_variable_18 != 0) {
    ldv_main_exported_18();
  } else {

  }
  goto ldv_39566;
  case 9: ;
  if (ldv_state_variable_30 != 0) {
    ldv_main_exported_30();
  } else {

  }
  goto ldv_39566;
  case 10: ;
  if (ldv_state_variable_16 != 0) {
    ldv_main_exported_16();
  } else {

  }
  goto ldv_39566;
  case 11: ;
  if (ldv_state_variable_44 != 0) {
    tmp___0 = __VERIFIER_nondet_int();
    switch (tmp___0) {
    case 0: ;
    if (ldv_state_variable_44 == 2) {
      psb_runtime_idle(psb_pm_ops_group1);
      ldv_state_variable_44 = 2;
    } else {

    }
    if (ldv_state_variable_44 == 1) {
      psb_runtime_idle(psb_pm_ops_group1);
      ldv_state_variable_44 = 1;
    } else {

    }
    goto ldv_39579;
    case 1: ;
    if (ldv_state_variable_44 == 2) {
      ldv_retval_8 = psb_runtime_resume(psb_pm_ops_group1);
      if (ldv_retval_8 == 0) {
        ldv_state_variable_44 = 1;
        ref_cnt = ref_cnt - 1;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 2: ;
    if (ldv_state_variable_44 == 3) {
      ldv_retval_7 = gma_power_suspend(psb_pm_ops_group1);
      if (ldv_retval_7 == 0) {
        ldv_state_variable_44 = 4;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 3: ;
    if (ldv_state_variable_44 == 1) {
      ldv_retval_6 = psb_runtime_suspend(psb_pm_ops_group1);
      if (ldv_retval_6 == 0) {
        ldv_state_variable_44 = 2;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 4: ;
    if (ldv_state_variable_44 == 7) {
      ldv_retval_5 = gma_power_resume(psb_pm_ops_group1);
      if (ldv_retval_5 == 0) {
        ldv_state_variable_44 = 8;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 5: ;
    if (ldv_state_variable_44 == 4) {
      ldv_retval_4 = ldv_psb_pm_ops_suspend_late_44();
      if (ldv_retval_4 == 0) {
        ldv_state_variable_44 = 5;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 6: ;
    if (ldv_state_variable_44 == 5) {
      ldv_retval_3 = ldv_psb_pm_ops_resume_early_44();
      if (ldv_retval_3 == 0) {
        ldv_state_variable_44 = 7;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 7: ;
    if (ldv_state_variable_44 == 6) {
      ldv_retval_2 = ldv_psb_pm_ops_resume_noirq_44();
      if (ldv_retval_2 == 0) {
        ldv_state_variable_44 = 7;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 8: ;
    if (ldv_state_variable_44 == 1) {
      ldv_retval_1 = ldv_psb_pm_ops_prepare_44();
      if (ldv_retval_1 == 0) {
        ldv_state_variable_44 = 3;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 9: ;
    if (ldv_state_variable_44 == 4) {
      ldv_retval_0 = ldv_psb_pm_ops_suspend_noirq_44();
      if (ldv_retval_0 == 0) {
        ldv_state_variable_44 = 6;
      } else {

      }
    } else {

    }
    goto ldv_39579;
    case 10: ;
    if (ldv_state_variable_44 == 8) {
      ldv_psb_pm_ops_complete_44();
      ldv_state_variable_44 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    goto ldv_39579;
    default: ;
    goto ldv_39579;
    }
    ldv_39579: ;
  } else {

  }
  goto ldv_39566;
  case 12: ;
  if (ldv_state_variable_27 != 0) {
    ldv_main_exported_27();
  } else {

  }
  goto ldv_39566;
  case 13: ;
  if (ldv_state_variable_25 != 0) {
    ldv_main_exported_25();
  } else {

  }
  goto ldv_39566;
  case 14: ;
  if (ldv_state_variable_28 != 0) {
    ldv_main_exported_28();
  } else {

  }
  goto ldv_39566;
  case 15: ;
  if (ldv_state_variable_40 != 0) {
    tmp___1 = __VERIFIER_nondet_int();
    switch (tmp___1) {
    case 0: ;
    if (ldv_state_variable_40 == 1) {
      ldv_retval_9 = psb_probe(psb_pci_driver_group0, (struct pci_device_id  const  *)ldvarg44);
      if (ldv_retval_9 == 0) {
        ldv_state_variable_40 = 2;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_39596;
    case 1: ;
    if (ldv_state_variable_40 == 2) {
      psb_remove(psb_pci_driver_group0);
      ldv_state_variable_40 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    goto ldv_39596;
    default: ;
    goto ldv_39596;
    }
    ldv_39596: ;
  } else {

  }
  goto ldv_39566;
  case 16: ;
  if (ldv_state_variable_20 != 0) {
    ldv_main_exported_20();
  } else {

  }
  goto ldv_39566;
  case 17: ;
  if (ldv_state_variable_14 != 0) {
    ldv_main_exported_14();
  } else {

  }
  goto ldv_39566;
  case 18: ;
  if (ldv_state_variable_49 != 0) {
    ldv_main_exported_49();
  } else {

  }
  goto ldv_39566;
  case 19: ;
  if (ldv_state_variable_24 != 0) {
    ldv_main_exported_24();
  } else {

  }
  goto ldv_39566;
  case 20: ;
  if (ldv_state_variable_10 != 0) {
    ldv_main_exported_10();
  } else {

  }
  goto ldv_39566;
  case 21: ;
  if (ldv_state_variable_31 != 0) {
    ldv_main_exported_31();
  } else {

  }
  goto ldv_39566;
  case 22: ;
  if (ldv_state_variable_35 != 0) {
    ldv_main_exported_35();
  } else {

  }
  goto ldv_39566;
  case 23: ;
  if (ldv_state_variable_11 != 0) {
    ldv_main_exported_11();
  } else {

  }
  goto ldv_39566;
  case 24: ;
  if (ldv_state_variable_48 != 0) {
    ldv_main_exported_48();
  } else {

  }
  goto ldv_39566;
  case 25: ;
  if (ldv_state_variable_42 != 0) {
    tmp___2 = __VERIFIER_nondet_int();
    switch (tmp___2) {
    case 0: ;
    if (ldv_state_variable_42 == 2) {
      drm_read(psb_gem_fops_group2, ldvarg119, ldvarg118, ldvarg117);
      ldv_state_variable_42 = 2;
    } else {

    }
    goto ldv_39610;
    case 1: ;
    if (ldv_state_variable_42 == 2) {
      drm_poll(ldvarg115, ldvarg116);
      ldv_state_variable_42 = 2;
    } else {

    }
    if (ldv_state_variable_42 == 1) {
      drm_poll(ldvarg115, ldvarg116);
      ldv_state_variable_42 = 1;
    } else {

    }
    goto ldv_39610;
    case 2: ;
    if (ldv_state_variable_42 == 2) {
      drm_fasync(ldvarg112, ldvarg114, ldvarg113);
      ldv_state_variable_42 = 2;
    } else {

    }
    if (ldv_state_variable_42 == 1) {
      drm_fasync(ldvarg112, ldvarg114, ldvarg113);
      ldv_state_variable_42 = 1;
    } else {

    }
    goto ldv_39610;
    case 3: ;
    if (ldv_state_variable_42 == 1) {
      ldv_retval_10 = drm_open(psb_gem_fops_group1, psb_gem_fops_group2);
      if (ldv_retval_10 == 0) {
        ldv_state_variable_42 = 2;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_39610;
    case 4: ;
    if (ldv_state_variable_42 == 2) {
      drm_gem_mmap(ldvarg110, ldvarg111);
      ldv_state_variable_42 = 2;
    } else {

    }
    if (ldv_state_variable_42 == 1) {
      drm_gem_mmap(ldvarg110, ldvarg111);
      ldv_state_variable_42 = 1;
    } else {

    }
    goto ldv_39610;
    case 5: ;
    if (ldv_state_variable_42 == 2) {
      drm_release(psb_gem_fops_group1, psb_gem_fops_group2);
      ldv_state_variable_42 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    goto ldv_39610;
    case 6: ;
    if (ldv_state_variable_42 == 2) {
      psb_unlocked_ioctl(psb_gem_fops_group2, ldvarg109, ldvarg108);
      ldv_state_variable_42 = 2;
    } else {

    }
    goto ldv_39610;
    default: ;
    goto ldv_39610;
    }
    ldv_39610: ;
  } else {

  }
  goto ldv_39566;
  case 26: ;
  if (ldv_state_variable_22 != 0) {
    ldv_main_exported_22();
  } else {

  }
  goto ldv_39566;
  case 27: ;
  if (ldv_state_variable_0 != 0) {
    tmp___3 = __VERIFIER_nondet_int();
    switch (tmp___3) {
    case 0: ;
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
      psb_exit();
      ldv_state_variable_0 = 3;
      goto ldv_final;
    } else {

    }
    goto ldv_39622;
    case 1: ;
    if (ldv_state_variable_0 == 1) {
      ldv_retval_11 = psb_init();
      if (ldv_retval_11 != 0) {
        ldv_state_variable_0 = 3;
        goto ldv_final;
      } else {

      }
      if (ldv_retval_11 == 0) {
        ldv_state_variable_0 = 2;
        ldv_state_variable_5 = 1;
        ldv_state_variable_19 = 1;
        ldv_state_variable_43 = 1;
        ldv_state_variable_37 = 1;
        ldv_state_variable_45 = 1;
        ldv_state_variable_34 = 1;
        ldv_state_variable_4 = 1;
        ldv_state_variable_8 = 1;
        ldv_state_variable_38 = 1;
        ldv_state_variable_52 = 1;
        ldv_state_variable_15 = 1;
        ldv_state_variable_47 = 1;
        ldv_state_variable_12 = 1;
        ldv_state_variable_41 = 1;
        ldv_state_variable_9 = 1;
        ldv_state_variable_51 = 1;
        ldv_state_variable_3 = 1;
        ldv_state_variable_36 = 1;
        ldv_state_variable_39 = 1;
        ldv_state_variable_50 = 1;
        ldv_state_variable_6 = 1;
        ldv_state_variable_29 = 1;
        ldv_state_variable_23 = 1;
        ldv_state_variable_13 = 1;
        ldv_state_variable_46 = 1;
        ldv_state_variable_22 = 1;
        ldv_state_variable_42 = 1;
        ldv_state_variable_48 = 1;
        ldv_state_variable_11 = 1;
        ldv_state_variable_35 = 1;
        ldv_state_variable_31 = 1;
        ldv_state_variable_10 = 1;
        ldv_state_variable_24 = 1;
        ldv_state_variable_49 = 1;
        ldv_state_variable_14 = 1;
        ldv_state_variable_20 = 1;
        ldv_state_variable_40 = 1;
        ldv_state_variable_28 = 1;
        ldv_state_variable_25 = 1;
        ldv_state_variable_27 = 1;
        ldv_state_variable_44 = 1;
        ldv_state_variable_16 = 1;
        ldv_state_variable_30 = 1;
        ldv_state_variable_18 = 1;
        ldv_state_variable_1 = 1;
        ldv_state_variable_2 = 1;
        ldv_state_variable_17 = 1;
        ldv_state_variable_26 = 1;
        ldv_state_variable_7 = 1;
        ldv_state_variable_21 = 1;
        ldv_state_variable_32 = 1;
        ldv_state_variable_33 = 1;
      } else {

      }
    } else {

    }
    goto ldv_39622;
    default: ;
    goto ldv_39622;
    }
    ldv_39622: ;
  } else {

  }
  goto ldv_39566;
  case 28: ;
  if (ldv_state_variable_46 != 0) {
    ldv_main_exported_46();
  } else {

  }
  goto ldv_39566;
  case 29: ;
  if (ldv_state_variable_13 != 0) {
    ldv_main_exported_13();
  } else {

  }
  goto ldv_39566;
  case 30: ;
  if (ldv_state_variable_23 != 0) {
    ldv_main_exported_23();
  } else {

  }
  goto ldv_39566;
  case 31: ;
  if (ldv_state_variable_29 != 0) {
    ldv_main_exported_29();
  } else {

  }
  goto ldv_39566;
  case 32: ;
  if (ldv_state_variable_6 != 0) {
    ldv_main_exported_6();
  } else {

  }
  goto ldv_39566;
  case 33: ;
  if (ldv_state_variable_50 != 0) {
    ldv_main_exported_50();
  } else {

  }
  goto ldv_39566;
  case 34: ;
  if (ldv_state_variable_39 != 0) {
    ldv_main_exported_39();
  } else {

  }
  goto ldv_39566;
  case 35: ;
  if (ldv_state_variable_36 != 0) {
    ldv_main_exported_36();
  } else {

  }
  goto ldv_39566;
  case 36: ;
  if (ldv_state_variable_3 != 0) {
    ldv_main_exported_3();
  } else {

  }
  goto ldv_39566;
  case 37: ;
  if (ldv_state_variable_51 != 0) {
    ldv_main_exported_51();
  } else {

  }
  goto ldv_39566;
  case 38: ;
  if (ldv_state_variable_9 != 0) {
    ldv_main_exported_9();
  } else {

  }
  goto ldv_39566;
  case 39: ;
  if (ldv_state_variable_41 != 0) {
    tmp___4 = __VERIFIER_nondet_int();
    switch (tmp___4) {
    case 0: ;
    if (ldv_state_variable_41 == 2) {
      psb_lastclose(driver_group2);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_lastclose(driver_group2);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 1: ;
    if (ldv_state_variable_41 == 2) {
      psb_get_vblank_counter(driver_group2, ldvarg166);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_get_vblank_counter(driver_group2, ldvarg166);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 2: ;
    if (ldv_state_variable_41 == 2) {
      psb_gem_dumb_map_gtt(driver_group1, driver_group2, ldvarg165, ldvarg164);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_gem_dumb_map_gtt(driver_group1, driver_group2, ldvarg165, ldvarg164);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 3: ;
    if (ldv_state_variable_41 == 1) {
      ldv_retval_12 = psb_driver_open(driver_group2, driver_group1);
      if (ldv_retval_12 == 0) {
        ldv_state_variable_41 = 2;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_39638;
    case 4: ;
    if (ldv_state_variable_41 == 2) {
      psb_gem_free_object(driver_group0);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_gem_free_object(driver_group0);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 5: ;
    if (ldv_state_variable_41 == 2) {
      psb_driver_unload(driver_group2);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_driver_unload(driver_group2);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 6: ;
    if (ldv_state_variable_41 == 2) {
      psb_irq_preinstall(driver_group2);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_irq_preinstall(driver_group2);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 7: ;
    if (ldv_state_variable_41 == 2) {
      psb_driver_load(driver_group2, ldvarg163);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_driver_load(driver_group2, ldvarg163);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 8: ;
    if (ldv_state_variable_41 == 2) {
      psb_irq_uninstall(driver_group2);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_irq_uninstall(driver_group2);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 9: ;
    if (ldv_state_variable_41 == 2) {
      psb_gem_dumb_destroy(driver_group1, driver_group2, ldvarg162);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_gem_dumb_destroy(driver_group1, driver_group2, ldvarg162);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 10: ;
    if (ldv_state_variable_41 == 2) {
      psb_driver_close(driver_group2, driver_group1);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_driver_close(driver_group2, driver_group1);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 11: ;
    if (ldv_state_variable_41 == 2) {
      psb_irq_postinstall(driver_group2);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_irq_postinstall(driver_group2);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 12: ;
    if (ldv_state_variable_41 == 2) {
      psb_gem_dumb_create(driver_group1, driver_group2, ldvarg161);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_gem_dumb_create(driver_group1, driver_group2, ldvarg161);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 13: ;
    if (ldv_state_variable_41 == 2) {
      psb_gem_init_object(driver_group0);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_gem_init_object(driver_group0);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 14: ;
    if (ldv_state_variable_41 == 2) {
      psb_irq_handler(ldvarg159, ldvarg160);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_irq_handler(ldvarg159, ldvarg160);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 15: ;
    if (ldv_state_variable_41 == 2) {
      psb_enable_vblank(driver_group2, ldvarg158);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_enable_vblank(driver_group2, ldvarg158);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 16: ;
    if (ldv_state_variable_41 == 2) {
      psb_driver_preclose(driver_group2, driver_group1);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_driver_preclose(driver_group2, driver_group1);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 17: ;
    if (ldv_state_variable_41 == 2) {
      psb_driver_device_is_agp(driver_group2);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_driver_device_is_agp(driver_group2);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 18: ;
    if (ldv_state_variable_41 == 2) {
      psb_disable_vblank(driver_group2, ldvarg157);
      ldv_state_variable_41 = 2;
    } else {

    }
    if (ldv_state_variable_41 == 1) {
      psb_disable_vblank(driver_group2, ldvarg157);
      ldv_state_variable_41 = 1;
    } else {

    }
    goto ldv_39638;
    case 19: ;
    if (ldv_state_variable_41 == 2) {
      ldv_driver_release_41();
      ldv_state_variable_41 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    goto ldv_39638;
    default: ;
    goto ldv_39638;
    }
    ldv_39638: ;
  } else {

  }
  goto ldv_39566;
  case 40: ;
  if (ldv_state_variable_12 != 0) {
    ldv_main_exported_12();
  } else {

  }
  goto ldv_39566;
  case 41: ;
  if (ldv_state_variable_47 != 0) {
    ldv_main_exported_47();
  } else {

  }
  goto ldv_39566;
  case 42: ;
  if (ldv_state_variable_15 != 0) {
    ldv_main_exported_15();
  } else {

  }
  goto ldv_39566;
  case 43: ;
  if (ldv_state_variable_52 != 0) {
    ldv_main_exported_52();
  } else {

  }
  goto ldv_39566;
  case 44: ;
  if (ldv_state_variable_38 != 0) {
    ldv_main_exported_38();
  } else {

  }
  goto ldv_39566;
  case 45: ;
  if (ldv_state_variable_8 != 0) {
    ldv_main_exported_8();
  } else {

  }
  goto ldv_39566;
  case 46: ;
  if (ldv_state_variable_4 != 0) {
    ldv_main_exported_4();
  } else {

  }
  goto ldv_39566;
  case 47: ;
  if (ldv_state_variable_34 != 0) {
    ldv_main_exported_34();
  } else {

  }
  goto ldv_39566;
  case 48: ;
  if (ldv_state_variable_45 != 0) {
    ldv_main_exported_45();
  } else {

  }
  goto ldv_39566;
  case 49: ;
  if (ldv_state_variable_37 != 0) {
    ldv_main_exported_37();
  } else {

  }
  goto ldv_39566;
  case 50: ;
  if (ldv_state_variable_43 != 0) {
    tmp___5 = __VERIFIER_nondet_int();
    switch (tmp___5) {
    case 0: ;
    if (ldv_state_variable_43 == 2) {
      psb_gem_fault(psb_gem_vm_ops_group0, ldvarg202);
      ldv_state_variable_43 = 2;
    } else {

    }
    if (ldv_state_variable_43 == 1) {
      psb_gem_fault(psb_gem_vm_ops_group0, ldvarg202);
      ldv_state_variable_43 = 1;
    } else {

    }
    goto ldv_39671;
    case 1: ;
    if (ldv_state_variable_43 == 2) {
      drm_gem_vm_close(psb_gem_vm_ops_group0);
      ldv_state_variable_43 = 1;
    } else {

    }
    goto ldv_39671;
    case 2: ;
    if (ldv_state_variable_43 == 1) {
      drm_gem_vm_open(psb_gem_vm_ops_group0);
      ldv_state_variable_43 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
    goto ldv_39671;
    default: ;
    goto ldv_39671;
    }
    ldv_39671: ;
  } else {

  }
  goto ldv_39566;
  case 51: ;
  if (ldv_state_variable_19 != 0) {
    ldv_main_exported_19();
  } else {

  }
  goto ldv_39566;
  case 52: ;
  if (ldv_state_variable_5 != 0) {
    ldv_main_exported_5();
  } else {

  }
  goto ldv_39566;
  default: ;
  goto ldv_39566;
  }
  ldv_39566: ;
  goto ldv_39678;
  ldv_final: 
  ldv_check_final_state();
  return 0;
}
}
void ldv_mutex_lock_277(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_278(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_279(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_280(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_281(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_282(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_283(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_284(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_285(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_286(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_287(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_288(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_289(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_290(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
__inline static int ffs(int x ) 
{ int r ;

  {
  __asm__  ("bsfl %1,%0": "=r" (r): "rm" (x), "0" (-1));
  return (r + 1);
}
}
int ldv_mutex_trylock_308(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_309(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_311(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_313(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_316(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_305(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_307(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_310(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_315(struct mutex *ldv_func_arg1 ) ;
extern void pm_runtime_forbid(struct device * ) ;
extern int drm_crtc_init(struct drm_device * , struct drm_crtc * , struct drm_crtc_funcs  const  * ) ;
extern void drm_crtc_cleanup(struct drm_crtc * ) ;
extern void drm_encoder_cleanup(struct drm_encoder * ) ;
extern void drm_mode_set_crtcinfo(struct drm_display_mode * , int  ) ;
extern int drm_mode_connector_attach_encoder(struct drm_connector * , struct drm_encoder * ) ;
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc * , int  ) ;
extern int drm_crtc_helper_set_config(struct drm_mode_set * ) ;
__inline static void drm_crtc_helper_add(struct drm_crtc *crtc , struct drm_crtc_helper_funcs  const  *funcs ) 
{ 

  {
  crtc->helper_private = (void *)funcs;
  return;
}
}
void psb_intel_encoder_prepare(struct drm_encoder *encoder ) ;
void psb_intel_encoder_commit(struct drm_encoder *encoder ) ;
void psb_intel_encoder_destroy(struct drm_encoder *encoder ) ;
void psb_intel_connector_attach_encoder(struct psb_intel_connector *connector , struct psb_intel_encoder *encoder ) ;
struct drm_encoder *psb_intel_best_encoder(struct drm_connector *connector ) ;
struct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) ;
void psb_intel_wait_for_vblank(struct drm_device *dev ) ;
struct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev , int pipe ) ;
struct drm_crtc_helper_funcs  const  psb_intel_helper_funcs ;
struct drm_crtc_funcs  const  psb_intel_crtc_funcs ;
bool psb_intel_pipe_has_type(struct drm_crtc *crtc , int type ) ;
void psb_intel_crtc_gamma_set(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                              uint32_t type , uint32_t size ) ;
void psb_intel_crtc_destroy(struct drm_crtc *crtc ) ;
static struct psb_intel_limit_t  const  psb_intel_limits[4U]  = {      {{25000, 350000}, {930000, 1400000}, {3, 16}, {96, 140}, {18, 26}, {6, 16}, {4,
                                                                                  128},
      {2, 33}, {165000, 4, 2}}, 
        {{25000, 350000}, {930000, 1400000}, {3, 16}, {96, 140}, {18, 26}, {6, 16}, {4,
                                                                                  128},
      {1, 6}, {165000, 14, 14}}, 
        {{20000, 400000}, {1400000, 2800000}, {3, 8}, {70, 120}, {10, 20}, {5, 9}, {5,
                                                                                 80},
      {1, 8}, {200000, 10, 5}}, 
        {{20000, 400000}, {1400000, 2800000}, {3, 8}, {70, 120}, {10, 20}, {5, 9}, {7,
                                                                                 98},
      {1, 8}, {112000, 14, 7}}};
static struct psb_intel_limit_t  const  *psb_intel_limit(struct drm_crtc *crtc ) 
{ struct psb_intel_limit_t  const  *limit ;
  bool tmp ;

  {
  tmp = psb_intel_pipe_has_type(crtc, 4);
  if ((int )tmp) {
    limit = (struct psb_intel_limit_t  const  *)(& psb_intel_limits) + 3UL;
  } else {
    limit = (struct psb_intel_limit_t  const  *)(& psb_intel_limits) + 2UL;
  }
  return (limit);
}
}
static void i8xx_clock(int refclk , struct psb_intel_clock_t *clock ) 
{ 

  {
  clock->m = (clock->m1 * 5 + 10) + (clock->m2 + 2);
  clock->p = clock->p1 * clock->p2;
  clock->vco = (clock->m * refclk) / (clock->n + 2);
  clock->dot = clock->vco / clock->p;
  return;
}
}
static void psb_intel_clock(struct drm_device *dev , int refclk , struct psb_intel_clock_t *clock ) 
{ 

  {
  return;
}
}
bool psb_intel_pipe_has_type(struct drm_crtc *crtc , int type ) 
{ struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *l_entry ;
  struct list_head  const  *__mptr ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
  dev = crtc->dev;
  mode_config = & dev->mode_config;
  __mptr = (struct list_head  const  *)mode_config->connector_list.next;
  l_entry = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
  goto ldv_38307;
  ldv_38306: ;
  if ((unsigned long )l_entry->encoder != (unsigned long )((struct drm_encoder *)0) && (unsigned long )(l_entry->encoder)->crtc == (unsigned long )crtc) {
    tmp = psb_intel_attached_encoder(l_entry);
    psb_intel_encoder = tmp;
    if (psb_intel_encoder->type == type) {
      return (1);
    } else {

    }
  } else {

  }
  __mptr___0 = (struct list_head  const  *)l_entry->head.next;
  l_entry = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  ldv_38307: ;
  if ((unsigned long )(& l_entry->head) != (unsigned long )(& mode_config->connector_list)) {
    goto ldv_38306;
  } else {
    goto ldv_38308;
  }
  ldv_38308: ;
  return (0);
}
}
static bool psb_intel_PLL_is_valid(struct drm_crtc *crtc , struct psb_intel_clock_t *clock ) 
{ struct psb_intel_limit_t  const  *limit ;
  struct psb_intel_limit_t  const  *tmp ;

  {
  tmp = psb_intel_limit(crtc);
  limit = tmp;
  if (clock->p1 < (int )limit->p1.min || (int )limit->p1.max < clock->p1) {
    return (0);
  } else {

  }
  if (clock->p < (int )limit->p.min || (int )limit->p.max < clock->p) {
    return (0);
  } else {

  }
  if (clock->m2 < (int )limit->m2.min || (int )limit->m2.max < clock->m2) {
    return (0);
  } else {

  }
  if (clock->m1 < (int )limit->m1.min || (int )limit->m1.max < clock->m1) {
    return (0);
  } else {

  }
  if (clock->m1 <= clock->m2) {
    return (0);
  } else {

  }
  if (clock->m < (int )limit->m.min || (int )limit->m.max < clock->m) {
    return (0);
  } else {

  }
  if (clock->n < (int )limit->n.min || (int )limit->n.max < clock->n) {
    return (0);
  } else {

  }
  if (clock->vco < (int )limit->vco.min || (int )limit->vco.max < clock->vco) {
    return (0);
  } else {

  }
  if (clock->dot < (int )limit->dot.min || (int )limit->dot.max < clock->dot) {
    return (0);
  } else {

  }
  return (1);
}
}
static bool psb_intel_find_best_PLL(struct drm_crtc *crtc , int target , int refclk ,
                                    struct psb_intel_clock_t *best_clock ) 
{ struct drm_device *dev ;
  struct psb_intel_clock_t clock ;
  struct psb_intel_limit_t  const  *limit ;
  struct psb_intel_limit_t  const  *tmp ;
  int err ;
  uint32_t tmp___0 ;
  bool tmp___1 ;
  uint32_t tmp___2 ;
  int this_err ;
  bool tmp___3 ;
  int tmp___4 ;
  long ret ;
  int __x___0 ;
  int tmp___5 ;

  {
  dev = crtc->dev;
  tmp = psb_intel_limit(crtc);
  limit = tmp;
  err = target;
  tmp___1 = psb_intel_pipe_has_type(crtc, 4);
  if ((int )tmp___1) {
    tmp___2 = REGISTER_READ(dev, 397696U);
    if ((int )tmp___2 < 0) {
      tmp___0 = REGISTER_READ(dev, 397696U);
      if ((tmp___0 & 48U) == 48U) {
        clock.p2 = limit->p2.p2_fast;
      } else {
        clock.p2 = limit->p2.p2_slow;
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int )limit->p2.dot_limit > target) {
    clock.p2 = limit->p2.p2_slow;
  } else {
    clock.p2 = limit->p2.p2_fast;
  }
  memset((void *)best_clock, 0, 36UL);
  clock.m1 = limit->m1.min;
  goto ldv_38340;
  ldv_38339: 
  clock.m2 = limit->m2.min;
  goto ldv_38337;
  ldv_38336: 
  clock.n = limit->n.min;
  goto ldv_38334;
  ldv_38333: 
  clock.p1 = limit->p1.min;
  goto ldv_38331;
  ldv_38330: 
  psb_intel_clock(dev, refclk, & clock);
  tmp___3 = psb_intel_PLL_is_valid(crtc, & clock);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    goto ldv_38325;
  } else {

  }
  __x___0 = clock.dot - target;
  if (__x___0 < 0) {
    tmp___5 = - __x___0;
  } else {
    tmp___5 = __x___0;
  }
  ret = (long )tmp___5;
  this_err = (int )ret;
  if (this_err < err) {
    *best_clock = clock;
    err = this_err;
  } else {

  }
  ldv_38325: 
  clock.p1 = clock.p1 + 1;
  ldv_38331: ;
  if (clock.p1 <= (int )limit->p1.max) {
    goto ldv_38330;
  } else {
    goto ldv_38332;
  }
  ldv_38332: 
  clock.n = clock.n + 1;
  ldv_38334: ;
  if (clock.n <= (int )limit->n.max) {
    goto ldv_38333;
  } else {
    goto ldv_38335;
  }
  ldv_38335: 
  clock.m2 = clock.m2 + 1;
  ldv_38337: ;
  if (clock.m2 < clock.m1 && clock.m2 <= (int )limit->m2.max) {
    goto ldv_38336;
  } else {
    goto ldv_38338;
  }
  ldv_38338: 
  clock.m1 = clock.m1 + 1;
  ldv_38340: ;
  if (clock.m1 <= (int )limit->m1.max) {
    goto ldv_38339;
  } else {
    goto ldv_38341;
  }
  ldv_38341: ;
  return (err != target);
}
}
void psb_intel_wait_for_vblank(struct drm_device *dev ) 
{ unsigned long __ms ;
  unsigned long tmp ;

  {
  __ms = 20UL;
  goto ldv_38347;
  ldv_38346: 
  __const_udelay(4295000UL);
  ldv_38347: 
  tmp = __ms;
  __ms = __ms - 1UL;
  if (tmp != 0UL) {
    goto ldv_38346;
  } else {
    goto ldv_38348;
  }
  ldv_38348: ;
  return;
}
}
static int psb_intel_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int pipe ;
  struct psb_offset  const  *map ;
  unsigned long start ;
  unsigned long offset ;
  u32 dspcntr ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct drm_framebuffer  const  *__mptr___1 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  __mptr___0 = (struct drm_framebuffer  const  *)crtc->fb;
  psbfb = (struct psb_framebuffer *)__mptr___0;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  ret = 0;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "psb_intel_pipe_set_base";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c.prepared";
    descriptor.format = "No FB bound\n";
    descriptor.lineno = 498U;
    descriptor.flags = 0U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No FB bound\n");
    } else {

    }
    goto psb_intel_pipe_cleaner;
  } else {

  }
  ret = psb_gtt_pin(psbfb->gtt);
  if (ret < 0) {
    goto psb_intel_pipe_set_base_exit;
  } else {

  }
  start = (unsigned long )(psbfb->gtt)->offset;
  offset = (unsigned long )((crtc->fb)->pitches[0] * (unsigned int )y + (unsigned int )(((crtc->fb)->bits_per_pixel / 8) * x));
  REGISTER_WRITE(dev, map->stride, (crtc->fb)->pitches[0]);
  dspcntr = REGISTER_READ(dev, map->cntr);
  dspcntr = dspcntr & 3288334335U;
  switch ((crtc->fb)->bits_per_pixel) {
  case 8: 
  dspcntr = dspcntr | 134217728U;
  goto ldv_38374;
  case 16: ;
  if ((crtc->fb)->depth == 15U) {
    dspcntr = dspcntr | 268435456U;
  } else {
    dspcntr = dspcntr | 335544320U;
  }
  goto ldv_38374;
  case 24: ;
  case 32: 
  dspcntr = dspcntr | 402653184U;
  goto ldv_38374;
  default: 
  dev_err((struct device  const  *)dev->dev, "Unknown color depth\n");
  ret = -22;
  psb_gtt_unpin(psbfb->gtt);
  goto psb_intel_pipe_set_base_exit;
  }
  ldv_38374: 
  REGISTER_WRITE(dev, map->cntr, dspcntr);
  REGISTER_WRITE(dev, map->base, (uint32_t )start + (uint32_t )offset);
  REGISTER_READ(dev, map->base);
  psb_intel_pipe_cleaner: ;
  if ((unsigned long )old_fb != (unsigned long )((struct drm_framebuffer *)0)) {
    __mptr___1 = (struct drm_framebuffer  const  *)old_fb;
    psb_gtt_unpin(((struct psb_framebuffer *)__mptr___1)->gtt);
  } else {

  }
  psb_intel_pipe_set_base_exit: 
  gma_power_end(dev);
  return (ret);
}
}
static void psb_intel_crtc_dpms(struct drm_crtc *crtc , int mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 temp ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  switch (mode) {
  case 0: ;
  case 1: ;
  case 2: 
  temp = REGISTER_READ(dev, map->dpll);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->dpll, temp);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
  } else {

  }
  temp = REGISTER_READ(dev, map->conf);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->conf, temp | 2147483648U);
  } else {

  }
  temp = REGISTER_READ(dev, map->cntr);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->cntr, temp | 2147483648U);
    tmp = REGISTER_READ(dev, map->base);
    REGISTER_WRITE(dev, map->base, tmp);
  } else {

  }
  psb_intel_crtc_load_lut(crtc);
  goto ldv_38396;
  case 3: 
  REGISTER_WRITE(dev, 463872U, 2147483648U);
  temp = REGISTER_READ(dev, map->cntr);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->cntr, temp & 2147483647U);
    tmp___0 = REGISTER_READ(dev, map->base);
    REGISTER_WRITE(dev, map->base, tmp___0);
    REGISTER_READ(dev, map->base);
  } else {

  }
  temp = REGISTER_READ(dev, map->conf);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->conf, temp & 2147483647U);
    REGISTER_READ(dev, map->conf);
  } else {

  }
  psb_intel_wait_for_vblank(dev);
  temp = REGISTER_READ(dev, map->dpll);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->dpll, temp & 2147483647U);
    REGISTER_READ(dev, map->dpll);
  } else {

  }
  __const_udelay(644250UL);
  goto ldv_38396;
  }
  ldv_38396: 
  REGISTER_WRITE(dev, 458800U, 16190U);
  return;
}
}
static void psb_intel_crtc_prepare(struct drm_crtc *crtc ) 
{ struct drm_crtc_helper_funcs *crtc_funcs ;

  {
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->dpms))(crtc, 3);
  return;
}
}
static void psb_intel_crtc_commit(struct drm_crtc *crtc ) 
{ struct drm_crtc_helper_funcs *crtc_funcs ;

  {
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->dpms))(crtc, 0);
  return;
}
}
void psb_intel_encoder_prepare(struct drm_encoder *encoder ) 
{ struct drm_encoder_helper_funcs *encoder_funcs ;

  {
  encoder_funcs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
  (*(encoder_funcs->dpms))(encoder, 3);
  return;
}
}
void psb_intel_encoder_commit(struct drm_encoder *encoder ) 
{ struct drm_encoder_helper_funcs *encoder_funcs ;

  {
  encoder_funcs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
  (*(encoder_funcs->dpms))(encoder, 0);
  return;
}
}
void psb_intel_encoder_destroy(struct drm_encoder *encoder ) 
{ struct psb_intel_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;

  {
  __mptr = (struct drm_encoder  const  *)encoder;
  intel_encoder = (struct psb_intel_encoder *)__mptr;
  drm_encoder_cleanup(encoder);
  kfree((void const   *)intel_encoder);
  return;
}
}
static bool psb_intel_crtc_mode_fixup(struct drm_crtc *crtc , struct drm_display_mode  const  *mode ,
                                      struct drm_display_mode *adjusted_mode ) 
{ 

  {
  return (1);
}
}
static int psb_intel_panel_fitter_pipe(struct drm_device *dev ) 
{ u32 pfit_control ;

  {
  pfit_control = REGISTER_READ(dev, 397872U);
  if ((int )pfit_control >= 0) {
    return (-1);
  } else {

  }
  return (1);
}
}
static int psb_intel_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode , int x ,
                                   int y , struct drm_framebuffer *old_fb ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct psb_intel_clock_t clock ;
  u32 dpll ;
  u32 fp ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_sdvo ;
  bool is_lvds ;
  bool is_tv ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct list_head  const  *__mptr___0 ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct list_head  const  *__mptr___1 ;
  int sdvo_pixel_multiply ;
  int tmp___0 ;
  u32 lvds ;
  uint32_t tmp___1 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  dpll = 0U;
  fp = 0U;
  is_sdvo = 0;
  is_lvds = 0;
  is_tv = 0;
  mode_config = & dev->mode_config;
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
    return (0);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  goto ldv_38468;
  ldv_38467: 
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
    goto ldv_38462;
  } else {

  }
  switch (psb_intel_encoder->type) {
  case 4: 
  is_lvds = 1;
  goto ldv_38464;
  case 3: 
  is_sdvo = 1;
  goto ldv_38464;
  case 5: 
  is_tv = 1;
  goto ldv_38464;
  }
  ldv_38464: ;
  ldv_38462: 
  __mptr___1 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  ldv_38468: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
    goto ldv_38467;
  } else {
    goto ldv_38469;
  }
  ldv_38469: 
  refclk = 96000;
  ok = psb_intel_find_best_PLL(crtc, adjusted_mode->clock, refclk, & clock);
  if (! ok) {
    dev_err((struct device  const  *)dev->dev, "Couldn\'t find PLL settings for mode!\n");
    return (0);
  } else {

  }
  fp = (u32 )(((clock.n << 16) | (clock.m1 << 8)) | clock.m2);
  dpll = 268435456U;
  if ((int )is_lvds) {
    dpll = dpll | 134217728U;
    dpll = dpll | 1073741824U;
  } else {
    dpll = dpll | 67108864U;
  }
  if ((int )is_sdvo) {
    sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
    dpll = dpll | 1073741824U;
    dpll = (u32 )((sdvo_pixel_multiply + -1) << 4) | dpll;
  } else {

  }
  dpll = (u32 )((1 << (clock.p1 + -1)) << 16) | dpll;
  switch (clock.p2) {
  case 5: 
  dpll = dpll | 16777216U;
  goto ldv_38472;
  case 7: 
  dpll = dpll | 16777216U;
  goto ldv_38472;
  case 10: 
  dpll = dpll;
  goto ldv_38472;
  case 14: 
  dpll = dpll;
  goto ldv_38472;
  }
  ldv_38472: ;
  if ((int )is_tv) {
    dpll = dpll | 3U;
  } else {

  }
  dpll = dpll;
  pipeconf = REGISTER_READ(dev, map->conf);
  dspcntr = 1073741824U;
  if (pipe == 0) {
    dspcntr = dspcntr;
  } else {
    dspcntr = dspcntr | 16777216U;
  }
  dspcntr = dspcntr | 2147483648U;
  pipeconf = pipeconf | 2147483648U;
  dpll = dpll | 2147483648U;
  tmp___0 = psb_intel_panel_fitter_pipe(dev);
  if (tmp___0 == pipe) {
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)mode);
  if ((int )dpll < 0) {
    REGISTER_WRITE(dev, map->fp0, fp);
    REGISTER_WRITE(dev, map->dpll, dpll & 2147483647U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
  } else {

  }
  if ((int )is_lvds) {
    tmp___1 = REGISTER_READ(dev, 397696U);
    lvds = tmp___1;
    lvds = lvds & 3221225471U;
    if (pipe == 1) {
      lvds = lvds | 1073741824U;
    } else {

    }
    lvds = lvds | 2147484416U;
    lvds = lvds & 4294967235U;
    if (clock.p2 == 7) {
      lvds = lvds | 60U;
    } else {

    }
    REGISTER_WRITE(dev, 397696U, lvds);
    REGISTER_READ(dev, 397696U);
  } else {

  }
  REGISTER_WRITE(dev, map->fp0, fp);
  REGISTER_WRITE(dev, map->dpll, dpll);
  REGISTER_READ(dev, map->dpll);
  __const_udelay(644250UL);
  REGISTER_WRITE(dev, map->dpll, dpll);
  REGISTER_READ(dev, map->dpll);
  __const_udelay(644250UL);
  REGISTER_WRITE(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
  REGISTER_WRITE(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
  REGISTER_WRITE(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
  REGISTER_WRITE(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
  REGISTER_WRITE(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
  REGISTER_WRITE(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
  REGISTER_WRITE(dev, map->size, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
  REGISTER_WRITE(dev, map->pos, 0U);
  REGISTER_WRITE(dev, map->src, (uint32_t )(((mode->hdisplay + -1) << 16) | (mode->vdisplay + -1)));
  REGISTER_WRITE(dev, map->conf, pipeconf);
  REGISTER_READ(dev, map->conf);
  psb_intel_wait_for_vblank(dev);
  REGISTER_WRITE(dev, map->cntr, dspcntr);
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
  psb_intel_wait_for_vblank(dev);
  return (0);
}
}
void psb_intel_crtc_load_lut(struct drm_crtc *crtc ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_offset  const  *map ;
  int palreg ;
  int i ;
  bool tmp ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  map = dev_priv->regmap + (unsigned long )psb_intel_crtc->pipe;
  palreg = (int )map->palette;
  if (! crtc->enabled) {
    return;
  } else {

  }
  switch (psb_intel_crtc->pipe) {
  case 0: ;
  case 1: ;
  goto ldv_38490;
  default: 
  dev_err((struct device  const  *)dev->dev, "Illegal Pipe Number.\n");
  return;
  }
  ldv_38490: 
  tmp = gma_power_begin(dev, 0);
  if ((int )tmp) {
    i = 0;
    goto ldv_38493;
    ldv_38492: 
    REGISTER_WRITE(dev, (uint32_t )(i * 4 + palreg), (uint32_t )(((((int )psb_intel_crtc->lut_r[i] + (int )psb_intel_crtc->lut_adj[i]) << 16) | (((int )psb_intel_crtc->lut_g[i] + (int )psb_intel_crtc->lut_adj[i]) << 8)) | ((int )psb_intel_crtc->lut_b[i] + (int )psb_intel_crtc->lut_adj[i])));
    i = i + 1;
    ldv_38493: ;
    if (i <= 255) {
      goto ldv_38492;
    } else {
      goto ldv_38494;
    }
    ldv_38494: 
    gma_power_end(dev);
  } else {
    i = 0;
    goto ldv_38496;
    ldv_38495: 
    dev_priv->regs.pipe[0].palette[i] = (u32 )(((((int )psb_intel_crtc->lut_r[i] + (int )psb_intel_crtc->lut_adj[i]) << 16) | (((int )psb_intel_crtc->lut_g[i] + (int )psb_intel_crtc->lut_adj[i]) << 8)) | ((int )psb_intel_crtc->lut_b[i] + (int )psb_intel_crtc->lut_adj[i]));
    i = i + 1;
    ldv_38496: ;
    if (i <= 255) {
      goto ldv_38495;
    } else {
      goto ldv_38497;
    }
    ldv_38497: ;
  }
  return;
}
}
static void psb_intel_crtc_save(struct drm_crtc *crtc ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_crtc_state *crtc_state ;
  struct psb_offset  const  *map ;
  uint32_t paletteReg ;
  int i ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  crtc_state = psb_intel_crtc->crtc_state;
  map = dev_priv->regmap + (unsigned long )psb_intel_crtc->pipe;
  if ((unsigned long )crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
    dev_err((struct device  const  *)dev->dev, "No CRTC state found\n");
    return;
  } else {

  }
  crtc_state->saveDSPCNTR = REGISTER_READ(dev, map->cntr);
  crtc_state->savePIPECONF = REGISTER_READ(dev, map->conf);
  crtc_state->savePIPESRC = REGISTER_READ(dev, map->src);
  crtc_state->saveFP0 = REGISTER_READ(dev, map->fp0);
  crtc_state->saveFP1 = REGISTER_READ(dev, map->fp1);
  crtc_state->saveDPLL = REGISTER_READ(dev, map->dpll);
  crtc_state->saveHTOTAL = REGISTER_READ(dev, map->htotal);
  crtc_state->saveHBLANK = REGISTER_READ(dev, map->hblank);
  crtc_state->saveHSYNC = REGISTER_READ(dev, map->hsync);
  crtc_state->saveVTOTAL = REGISTER_READ(dev, map->vtotal);
  crtc_state->saveVBLANK = REGISTER_READ(dev, map->vblank);
  crtc_state->saveVSYNC = REGISTER_READ(dev, map->vsync);
  crtc_state->saveDSPSTRIDE = REGISTER_READ(dev, map->stride);
  crtc_state->saveDSPSIZE = REGISTER_READ(dev, map->size);
  crtc_state->saveDSPPOS = REGISTER_READ(dev, map->pos);
  crtc_state->saveDSPBASE = REGISTER_READ(dev, map->base);
  paletteReg = map->palette;
  i = 0;
  goto ldv_38511;
  ldv_38510: 
  crtc_state->savePalette[i] = REGISTER_READ(dev, (uint32_t )(i << 2) + paletteReg);
  i = i + 1;
  ldv_38511: ;
  if (i <= 255) {
    goto ldv_38510;
  } else {
    goto ldv_38512;
  }
  ldv_38512: ;
  return;
}
}
static void psb_intel_crtc_restore(struct drm_crtc *crtc ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_crtc_state *crtc_state ;
  struct psb_offset  const  *map ;
  uint32_t paletteReg ;
  int i ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  crtc_state = psb_intel_crtc->crtc_state;
  map = dev_priv->regmap + (unsigned long )psb_intel_crtc->pipe;
  if ((unsigned long )crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
    dev_err((struct device  const  *)dev->dev, "No crtc state\n");
    return;
  } else {

  }
  if ((int )crtc_state->saveDPLL < 0) {
    REGISTER_WRITE(dev, map->dpll, crtc_state->saveDPLL & 2147483647U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
  } else {

  }
  REGISTER_WRITE(dev, map->fp0, crtc_state->saveFP0);
  REGISTER_READ(dev, map->fp0);
  REGISTER_WRITE(dev, map->fp1, crtc_state->saveFP1);
  REGISTER_READ(dev, map->fp1);
  REGISTER_WRITE(dev, map->dpll, crtc_state->saveDPLL);
  REGISTER_READ(dev, map->dpll);
  __const_udelay(644250UL);
  REGISTER_WRITE(dev, map->htotal, crtc_state->saveHTOTAL);
  REGISTER_WRITE(dev, map->hblank, crtc_state->saveHBLANK);
  REGISTER_WRITE(dev, map->hsync, crtc_state->saveHSYNC);
  REGISTER_WRITE(dev, map->vtotal, crtc_state->saveVTOTAL);
  REGISTER_WRITE(dev, map->vblank, crtc_state->saveVBLANK);
  REGISTER_WRITE(dev, map->vsync, crtc_state->saveVSYNC);
  REGISTER_WRITE(dev, map->stride, crtc_state->saveDSPSTRIDE);
  REGISTER_WRITE(dev, map->size, crtc_state->saveDSPSIZE);
  REGISTER_WRITE(dev, map->pos, crtc_state->saveDSPPOS);
  REGISTER_WRITE(dev, map->src, crtc_state->savePIPESRC);
  REGISTER_WRITE(dev, map->base, crtc_state->saveDSPBASE);
  REGISTER_WRITE(dev, map->conf, crtc_state->savePIPECONF);
  psb_intel_wait_for_vblank(dev);
  REGISTER_WRITE(dev, map->cntr, crtc_state->saveDSPCNTR);
  REGISTER_WRITE(dev, map->base, crtc_state->saveDSPBASE);
  psb_intel_wait_for_vblank(dev);
  paletteReg = map->palette;
  i = 0;
  goto ldv_38526;
  ldv_38525: 
  REGISTER_WRITE(dev, (uint32_t )(i << 2) + paletteReg, crtc_state->savePalette[i]);
  i = i + 1;
  ldv_38526: ;
  if (i <= 255) {
    goto ldv_38525;
  } else {
    goto ldv_38527;
  }
  ldv_38527: ;
  return;
}
}
static int psb_intel_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv ,
                                     uint32_t handle , uint32_t width , uint32_t height ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  uint32_t control ;
  unsigned int tmp ;
  uint32_t base ;
  unsigned int tmp___0 ;
  uint32_t temp ;
  size_t addr ;
  struct gtt_range *gt ;
  struct gtt_range *cursor_gt ;
  struct drm_gem_object *obj ;
  void *tmp_dst ;
  void *tmp_src ;
  int ret ;
  int i ;
  int cursor_pages ;
  bool tmp___1 ;
  struct drm_gem_object  const  *__mptr___0 ;
  struct _ddebug descriptor ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  struct drm_gem_object  const  *__mptr___1 ;
  size_t __len ;
  void *__ret ;
  bool tmp___4 ;
  struct drm_gem_object  const  *__mptr___2 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  if (pipe == 0) {
    tmp = 458880U;
  } else {
    tmp = 458944U;
  }
  control = tmp;
  if (pipe == 0) {
    tmp___0 = 458884U;
  } else {
    tmp___0 = 458948U;
  }
  base = tmp___0;
  addr = 0UL;
  cursor_gt = psb_intel_crtc->cursor_gt;
  if (handle == 0U) {
    temp = 0U;
    tmp___1 = gma_power_begin(dev, 0);
    if ((int )tmp___1) {
      REGISTER_WRITE(dev, control, temp);
      REGISTER_WRITE(dev, base, 0U);
      gma_power_end(dev);
    } else {

    }
    if ((unsigned long )psb_intel_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
      __mptr___0 = (struct drm_gem_object  const  *)psb_intel_crtc->cursor_obj;
      gt = (struct gtt_range *)__mptr___0 + 0xffffffffffffffc0UL;
      psb_gtt_unpin(gt);
      drm_gem_object_unreference(psb_intel_crtc->cursor_obj);
      psb_intel_crtc->cursor_obj = 0;
    } else {

    }
    return (0);
  } else {

  }
  if (width != 64U || height != 64U) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "psb_intel_crtc_cursor_set";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c.prepared";
    descriptor.format = "we currently only support 64x64 cursors\n";
    descriptor.lineno = 1113U;
    descriptor.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "we currently only support 64x64 cursors\n");
    } else {

    }
    return (-22);
  } else {

  }
  obj = drm_gem_object_lookup(dev, file_priv, handle);
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
    return (-2);
  } else {

  }
  if (obj->size < (size_t )((width * height) * 4U)) {
    descriptor___0.modname = "gma500_gfx";
    descriptor___0.function = "psb_intel_crtc_cursor_set";
    descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c.prepared";
    descriptor___0.format = "buffer is to small\n";
    descriptor___0.lineno = 1122U;
    descriptor___0.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "buffer is to small\n");
    } else {

    }
    return (-12);
  } else {

  }
  __mptr___1 = (struct drm_gem_object  const  *)obj;
  gt = (struct gtt_range *)__mptr___1 + 0xffffffffffffffc0UL;
  ret = psb_gtt_pin(gt);
  if (ret != 0) {
    dev_err((struct device  const  *)dev->dev, "Can not pin down handle 0x%x\n", handle);
    return (ret);
  } else {

  }
  if ((int )(dev_priv->ops)->cursor_needs_phys != 0) {
    if ((unsigned long )cursor_gt == (unsigned long )((struct gtt_range *)0)) {
      dev_err((struct device  const  *)dev->dev, "No hardware cursor mem available");
      return (-12);
    } else {

    }
    if (gt->npage > 4) {
      cursor_pages = 4;
    } else {
      cursor_pages = gt->npage;
    }
    tmp_dst = (void *)dev_priv->vram_addr + (unsigned long )cursor_gt->offset;
    i = 0;
    goto ldv_38564;
    ldv_38563: 
    tmp_src = kmap(*(gt->pages + (unsigned long )i));
    __len = 4096UL;
    if (__len > 63UL) {
      __ret = __memcpy(tmp_dst, (void const   *)tmp_src, __len);
    } else {
      __ret = __builtin_memcpy(tmp_dst, (void const   *)tmp_src, __len);
    }
    kunmap(*(gt->pages + (unsigned long )i));
    tmp_dst = tmp_dst + 4096UL;
    i = i + 1;
    ldv_38564: ;
    if (i < cursor_pages) {
      goto ldv_38563;
    } else {
      goto ldv_38565;
    }
    ldv_38565: 
    addr = (size_t )psb_intel_crtc->cursor_addr;
  } else {
    addr = (size_t )gt->offset;
    psb_intel_crtc->cursor_addr = (uint32_t )addr;
  }
  temp = 0U;
  temp = (uint32_t )(pipe << 28) | temp;
  temp = temp | 67108903U;
  tmp___4 = gma_power_begin(dev, 0);
  if ((int )tmp___4) {
    REGISTER_WRITE(dev, control, temp);
    REGISTER_WRITE(dev, base, (uint32_t )addr);
    gma_power_end(dev);
  } else {

  }
  if ((unsigned long )psb_intel_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
    __mptr___2 = (struct drm_gem_object  const  *)psb_intel_crtc->cursor_obj;
    gt = (struct gtt_range *)__mptr___2 + 0xffffffffffffffc0UL;
    psb_gtt_unpin(gt);
    drm_gem_object_unreference(psb_intel_crtc->cursor_obj);
    psb_intel_crtc->cursor_obj = obj;
  } else {

  }
  return (0);
}
}
static int psb_intel_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ struct drm_device *dev ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  uint32_t temp ;
  uint32_t addr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
  dev = crtc->dev;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  temp = 0U;
  if (x < 0) {
    temp = temp | 32768U;
    x = - x;
  } else {

  }
  if (y < 0) {
    temp = temp | 2147483648U;
    y = - y;
  } else {

  }
  temp = ((uint32_t )x & 2047U) | temp;
  temp = (uint32_t )((y & 2047) << 16) | temp;
  addr = psb_intel_crtc->cursor_addr;
  tmp___1 = gma_power_begin(dev, 0);
  if ((int )tmp___1) {
    if (pipe == 0) {
      tmp = 458888U;
    } else {
      tmp = 458952U;
    }
    REGISTER_WRITE(dev, tmp, temp);
    if (pipe == 0) {
      tmp___0 = 458884U;
    } else {
      tmp___0 = 458948U;
    }
    REGISTER_WRITE(dev, tmp___0, addr);
    gma_power_end(dev);
  } else {

  }
  return (0);
}
}
void psb_intel_crtc_gamma_set(struct drm_crtc *crtc , u16 *red , u16 *green , u16 *blue ,
                              uint32_t type , uint32_t size ) 
{ struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int i ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  if (size != 256U) {
    return;
  } else {

  }
  i = 0;
  goto ldv_38593;
  ldv_38592: 
  psb_intel_crtc->lut_r[i] = (u8 )((int )*(red + (unsigned long )i) >> 8);
  psb_intel_crtc->lut_g[i] = (u8 )((int )*(green + (unsigned long )i) >> 8);
  psb_intel_crtc->lut_b[i] = (u8 )((int )*(blue + (unsigned long )i) >> 8);
  i = i + 1;
  ldv_38593: ;
  if (i <= 255) {
    goto ldv_38592;
  } else {
    goto ldv_38594;
  }
  ldv_38594: 
  psb_intel_crtc_load_lut(crtc);
  return;
}
}
static int psb_crtc_set_config(struct drm_mode_set *set ) 
{ int ret ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int tmp ;

  {
  dev = (set->crtc)->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (dev_priv->rpm_enabled == 0) {
    tmp = drm_crtc_helper_set_config(set);
    return (tmp);
  } else {

  }
  pm_runtime_forbid(& (dev->pdev)->dev);
  ret = drm_crtc_helper_set_config(set);
  pm_runtime_allow(& (dev->pdev)->dev);
  return (ret);
}
}
static int psb_intel_crtc_clock_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 dpll ;
  u32 fp ;
  struct psb_intel_clock_t clock ;
  bool is_lvds ;
  struct psb_pipe *p ;
  uint32_t tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
  tmp___1 = gma_power_begin(dev, 0);
  if ((int )tmp___1) {
    dpll = REGISTER_READ(dev, map->dpll);
    if ((dpll & 256U) == 0U) {
      fp = REGISTER_READ(dev, map->fp0);
    } else {
      fp = REGISTER_READ(dev, map->fp1);
    }
    if (pipe == 1) {
      tmp = REGISTER_READ(dev, 397696U);
      if ((int )tmp < 0) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    is_lvds = (bool )tmp___0;
    gma_power_end(dev);
  } else {
    dpll = p->dpll;
    if ((dpll & 256U) == 0U) {
      fp = p->fp0;
    } else {
      fp = p->fp1;
    }
    is_lvds = (bool )(pipe == 1 && (int )dev_priv->regs.ldv_38617.psb.saveLVDS < 0);
  }
  clock.m1 = (int )((fp & 16128U) >> 8);
  clock.m2 = (int )fp & 63;
  clock.n = (int )((fp & 4128768U) >> 16);
  if ((int )is_lvds) {
    clock.p1 = ffs((int )((dpll & 4128768U) >> 16));
    clock.p2 = 14;
    if ((dpll & 24576U) == 24576U) {
      i8xx_clock(66000, & clock);
    } else {
      i8xx_clock(48000, & clock);
    }
  } else {
    if ((dpll & 2097152U) != 0U) {
      clock.p1 = 2;
    } else {
      clock.p1 = (int )(((dpll & 2031616U) >> 16) + 2U);
    }
    if ((dpll & 8388608U) != 0U) {
      clock.p2 = 4;
    } else {
      clock.p2 = 2;
    }
    i8xx_clock(48000, & clock);
  }
  return (clock.dot);
}
}
struct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct drm_display_mode *mode ;
  int htot ;
  int hsync ;
  int vtot ;
  int vsync ;
  struct drm_psb_private *dev_priv ;
  struct psb_pipe *p ;
  struct psb_offset  const  *map ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  tmp___3 = gma_power_begin(dev, 0);
  if ((int )tmp___3) {
    tmp = REGISTER_READ(dev, map->htotal);
    htot = (int )tmp;
    tmp___0 = REGISTER_READ(dev, map->hsync);
    hsync = (int )tmp___0;
    tmp___1 = REGISTER_READ(dev, map->vtotal);
    vtot = (int )tmp___1;
    tmp___2 = REGISTER_READ(dev, map->vsync);
    vsync = (int )tmp___2;
    gma_power_end(dev);
  } else {
    htot = (int )p->htotal;
    hsync = (int )p->hsync;
    vtot = (int )p->vtotal;
    vsync = (int )p->vsync;
  }
  tmp___4 = kzalloc(216UL, 208U);
  mode = (struct drm_display_mode *)tmp___4;
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
    return (0);
  } else {

  }
  mode->clock = psb_intel_crtc_clock_get(dev, crtc);
  mode->hdisplay = (htot & 65535) + 1;
  mode->htotal = (int )(((unsigned int )htot >> 16) + 1U);
  mode->hsync_start = (hsync & 65535) + 1;
  mode->hsync_end = (int )(((unsigned int )hsync >> 16) + 1U);
  mode->vdisplay = (vtot & 65535) + 1;
  mode->vtotal = (int )(((unsigned int )vtot >> 16) + 1U);
  mode->vsync_start = (vsync & 65535) + 1;
  mode->vsync_end = (int )(((unsigned int )vsync >> 16) + 1U);
  drm_mode_set_name(mode);
  drm_mode_set_crtcinfo(mode, 0);
  return (mode);
}
}
void psb_intel_crtc_destroy(struct drm_crtc *crtc ) 
{ struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct gtt_range *gt ;
  struct drm_gem_object  const  *__mptr___0 ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  if ((unsigned long )psb_intel_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
    __mptr___0 = (struct drm_gem_object  const  *)psb_intel_crtc->cursor_obj;
    gt = (struct gtt_range *)__mptr___0 + 0xffffffffffffffc0UL;
    psb_gtt_unpin(gt);
    drm_gem_object_unreference(psb_intel_crtc->cursor_obj);
    psb_intel_crtc->cursor_obj = 0;
  } else {

  }
  if ((unsigned long )psb_intel_crtc->cursor_gt != (unsigned long )((struct gtt_range *)0)) {
    psb_gtt_free_range(crtc->dev, psb_intel_crtc->cursor_gt);
  } else {

  }
  kfree((void const   *)psb_intel_crtc->crtc_state);
  drm_crtc_cleanup(crtc);
  kfree((void const   *)psb_intel_crtc);
  return;
}
}
struct drm_crtc_helper_funcs  const  psb_intel_helper_funcs  = 
     {& psb_intel_crtc_dpms, & psb_intel_crtc_prepare, & psb_intel_crtc_commit, & psb_intel_crtc_mode_fixup,
    & psb_intel_crtc_mode_set, & psb_intel_pipe_set_base, 0, 0, 0};
struct drm_crtc_funcs  const  psb_intel_crtc_funcs  = 
     {& psb_intel_crtc_save, & psb_intel_crtc_restore, 0, & psb_intel_crtc_cursor_set,
    & psb_intel_crtc_cursor_move, & psb_intel_crtc_gamma_set, & psb_intel_crtc_destroy,
    & psb_crtc_set_config, 0, 0};
static void psb_intel_cursor_init(struct drm_device *dev , struct psb_intel_crtc *psb_intel_crtc ) 
{ struct drm_psb_private *dev_priv ;
  u32 control[3U] ;
  u32 base[3U] ;
  struct gtt_range *cursor_gt ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  control[0] = 458880U;
  control[1] = 458944U;
  control[2] = 458976U;
  base[0] = 458884U;
  base[1] = 458948U;
  base[2] = 458980U;
  if ((int )(dev_priv->ops)->cursor_needs_phys != 0) {
    cursor_gt = psb_gtt_alloc_range(dev, 16384, "cursor", 1);
    if ((unsigned long )cursor_gt == (unsigned long )((struct gtt_range *)0)) {
      psb_intel_crtc->cursor_gt = 0;
      goto out;
    } else {

    }
    psb_intel_crtc->cursor_gt = cursor_gt;
    psb_intel_crtc->cursor_addr = dev_priv->stolen_base + cursor_gt->offset;
  } else {
    psb_intel_crtc->cursor_gt = 0;
  }
  out: 
  REGISTER_WRITE(dev, control[psb_intel_crtc->pipe], 0U);
  REGISTER_WRITE(dev, base[psb_intel_crtc->pipe], 0U);
  return;
}
}
void psb_intel_crtc_init(struct drm_device *dev , int pipe , struct psb_intel_mode_device *mode_dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  int i ;
  uint16_t *r_base ;
  uint16_t *g_base ;
  uint16_t *b_base ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = kzalloc(2456UL, 208U);
  psb_intel_crtc = (struct psb_intel_crtc *)tmp;
  if ((unsigned long )psb_intel_crtc == (unsigned long )((struct psb_intel_crtc *)0)) {
    return;
  } else {

  }
  tmp___0 = kzalloc(1088UL, 208U);
  psb_intel_crtc->crtc_state = (struct psb_intel_crtc_state *)tmp___0;
  if ((unsigned long )psb_intel_crtc->crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
    dev_err((struct device  const  *)dev->dev, "Crtc state error: No memory\n");
    kfree((void const   *)psb_intel_crtc);
    return;
  } else {

  }
  drm_crtc_init(dev, & psb_intel_crtc->base, (dev_priv->ops)->crtc_funcs);
  drm_mode_crtc_set_gamma_size(& psb_intel_crtc->base, 256);
  psb_intel_crtc->pipe = pipe;
  psb_intel_crtc->plane = pipe;
  r_base = psb_intel_crtc->base.gamma_store;
  g_base = r_base + 256UL;
  b_base = g_base + 256UL;
  i = 0;
  goto ldv_38664;
  ldv_38663: 
  psb_intel_crtc->lut_r[i] = (u8 )i;
  psb_intel_crtc->lut_g[i] = (u8 )i;
  psb_intel_crtc->lut_b[i] = (u8 )i;
  *(r_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
  *(g_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
  *(b_base + (unsigned long )i) = (int )((uint16_t )i) << 8U;
  psb_intel_crtc->lut_adj[i] = 0U;
  i = i + 1;
  ldv_38664: ;
  if (i <= 255) {
    goto ldv_38663;
  } else {
    goto ldv_38665;
  }
  ldv_38665: 
  psb_intel_crtc->mode_dev = mode_dev;
  psb_intel_crtc->cursor_addr = 0U;
  drm_crtc_helper_add(& psb_intel_crtc->base, (dev_priv->ops)->crtc_helper);
  psb_intel_crtc->mode_set.crtc = & psb_intel_crtc->base;
  tmp___1 = ldv__builtin_expect((unsigned int )pipe > 2U, 0L);
  if (tmp___1 != 0L) {
    goto _L;
  } else {
    tmp___2 = ldv__builtin_expect((unsigned long )dev_priv->plane_to_crtc_mapping[psb_intel_crtc->plane] != (unsigned long )((struct drm_crtc *)0),
                               0L);
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_display.c.prepared"),
                           "i" (1500), "i" (12UL));
      ldv_38668: ;
      goto ldv_38668;
    } else {

    }
  }
  dev_priv->plane_to_crtc_mapping[psb_intel_crtc->plane] = & psb_intel_crtc->base;
  dev_priv->pipe_to_crtc_mapping[psb_intel_crtc->pipe] = & psb_intel_crtc->base;
  psb_intel_crtc->mode_set.connectors = (struct drm_connector **)psb_intel_crtc + 1U;
  psb_intel_crtc->mode_set.num_connectors = 0UL;
  psb_intel_cursor_init(dev, psb_intel_crtc);
  psb_intel_crtc->active = 1;
  return;
}
}
int psb_intel_get_pipe_from_crtc_id(struct drm_device *dev , void *data , struct drm_file *file_priv ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_psb_get_pipe_from_crtc_id_arg *pipe_from_crtc_id ;
  struct drm_mode_object *drmmode_obj ;
  struct psb_intel_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_mode_object  const  *__mptr___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pipe_from_crtc_id = (struct drm_psb_get_pipe_from_crtc_id_arg *)data;
  if ((unsigned long )dev_priv == (unsigned long )((struct drm_psb_private *)0)) {
    dev_err((struct device  const  *)dev->dev, "called with no initialization\n");
    return (-22);
  } else {

  }
  drmmode_obj = drm_mode_object_find(dev, pipe_from_crtc_id->crtc_id, 3435973836U);
  if ((unsigned long )drmmode_obj == (unsigned long )((struct drm_mode_object *)0)) {
    dev_err((struct device  const  *)dev->dev, "no such CRTC id\n");
    return (-22);
  } else {

  }
  __mptr___0 = (struct drm_mode_object  const  *)drmmode_obj;
  __mptr = (struct drm_crtc  const  *)((struct drm_crtc *)__mptr___0 + 0xffffffffffffffe8UL);
  crtc = (struct psb_intel_crtc *)__mptr;
  pipe_from_crtc_id->pipe = (u32 )crtc->pipe;
  return (0);
}
}
struct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev , int pipe ) 
{ struct drm_crtc *crtc ;
  struct list_head  const  *__mptr ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  crtc = 0;
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
  goto ldv_38696;
  ldv_38695: 
  __mptr___0 = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr___0;
  if (psb_intel_crtc->pipe == pipe) {
    goto ldv_38694;
  } else {

  }
  __mptr___1 = (struct list_head  const  *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_38696: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_38695;
  } else {
    goto ldv_38694;
  }
  ldv_38694: ;
  return (crtc);
}
}
int psb_intel_connector_clones(struct drm_device *dev , int type_mask ) 
{ int index_mask ;
  struct drm_connector *connector ;
  int entry ;
  struct list_head  const  *__mptr ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
  index_mask = 0;
  entry = 0;
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
  connector = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
  goto ldv_38710;
  ldv_38709: 
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  if ((type_mask >> psb_intel_encoder->type) & 1) {
    index_mask = (1 << entry) | index_mask;
  } else {

  }
  entry = entry + 1;
  __mptr___0 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  ldv_38710: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
    goto ldv_38709;
  } else {
    goto ldv_38711;
  }
  ldv_38711: ;
  return (index_mask);
}
}
struct drm_encoder *psb_intel_best_encoder(struct drm_connector *connector ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  return (& psb_intel_encoder->base);
}
}
void psb_intel_connector_attach_encoder(struct psb_intel_connector *connector , struct psb_intel_encoder *encoder ) 
{ 

  {
  connector->encoder = encoder;
  drm_mode_connector_attach_encoder(& connector->base, & encoder->base);
  return;
}
}
u16 *ldvarg187  ;
struct drm_display_mode *ldvarg146  ;
struct drm_display_mode *ldvarg144  ;
u16 *ldvarg186  ;
uint32_t ldvarg184  ;
uint32_t ldvarg190  ;
int ldvarg193  ;
uint32_t ldvarg188  ;
u16 *ldvarg185  ;
uint32_t ldvarg192  ;
struct drm_file *ldvarg191  ;
int ldvarg147  ;
struct drm_mode_set *ldvarg183  ;
int ldvarg145  ;
int ldvarg194  ;
uint32_t ldvarg189  ;
int ldvarg143  ;
struct drm_crtc *psb_intel_crtc_funcs_group0  ;
struct drm_display_mode *psb_intel_helper_funcs_group0  ;
extern int ldv_psb_intel_crtc_funcs_probe_38(void) ;
struct drm_crtc *psb_intel_helper_funcs_group2  ;
int ldvarg149  ;
struct drm_framebuffer *psb_intel_helper_funcs_group1  ;
int ldvarg148  ;
void ldv_main_exported_38(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_38 == 2) {
    psb_intel_crtc_cursor_move(psb_intel_crtc_funcs_group0, ldvarg194, ldvarg193);
    ldv_state_variable_38 = 2;
  } else {

  }
  if (ldv_state_variable_38 == 1) {
    psb_intel_crtc_cursor_move(psb_intel_crtc_funcs_group0, ldvarg194, ldvarg193);
    ldv_state_variable_38 = 1;
  } else {

  }
  goto ldv_38749;
  case 1: ;
  if (ldv_state_variable_38 == 2) {
    psb_intel_crtc_cursor_set(psb_intel_crtc_funcs_group0, ldvarg191, ldvarg190, ldvarg189,
                              ldvarg192);
    ldv_state_variable_38 = 2;
  } else {

  }
  if (ldv_state_variable_38 == 1) {
    psb_intel_crtc_cursor_set(psb_intel_crtc_funcs_group0, ldvarg191, ldvarg190, ldvarg189,
                              ldvarg192);
    ldv_state_variable_38 = 1;
  } else {

  }
  goto ldv_38749;
  case 2: ;
  if (ldv_state_variable_38 == 2) {
    psb_intel_crtc_destroy(psb_intel_crtc_funcs_group0);
    ldv_state_variable_38 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38749;
  case 3: ;
  if (ldv_state_variable_38 == 2) {
    psb_intel_crtc_save(psb_intel_crtc_funcs_group0);
    ldv_state_variable_38 = 2;
  } else {

  }
  if (ldv_state_variable_38 == 1) {
    psb_intel_crtc_save(psb_intel_crtc_funcs_group0);
    ldv_state_variable_38 = 1;
  } else {

  }
  goto ldv_38749;
  case 4: ;
  if (ldv_state_variable_38 == 2) {
    psb_intel_crtc_gamma_set(psb_intel_crtc_funcs_group0, ldvarg187, ldvarg186, ldvarg185,
                             ldvarg188, ldvarg184);
    ldv_state_variable_38 = 2;
  } else {

  }
  if (ldv_state_variable_38 == 1) {
    psb_intel_crtc_gamma_set(psb_intel_crtc_funcs_group0, ldvarg187, ldvarg186, ldvarg185,
                             ldvarg188, ldvarg184);
    ldv_state_variable_38 = 1;
  } else {

  }
  goto ldv_38749;
  case 5: ;
  if (ldv_state_variable_38 == 2) {
    psb_intel_crtc_restore(psb_intel_crtc_funcs_group0);
    ldv_state_variable_38 = 2;
  } else {

  }
  if (ldv_state_variable_38 == 1) {
    psb_intel_crtc_restore(psb_intel_crtc_funcs_group0);
    ldv_state_variable_38 = 1;
  } else {

  }
  goto ldv_38749;
  case 6: ;
  if (ldv_state_variable_38 == 2) {
    psb_crtc_set_config(ldvarg183);
    ldv_state_variable_38 = 2;
  } else {

  }
  if (ldv_state_variable_38 == 1) {
    psb_crtc_set_config(ldvarg183);
    ldv_state_variable_38 = 1;
  } else {

  }
  goto ldv_38749;
  case 7: ;
  if (ldv_state_variable_38 == 1) {
    ldv_psb_intel_crtc_funcs_probe_38();
    ldv_state_variable_38 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38749;
  default: ;
  goto ldv_38749;
  }
  ldv_38749: ;
  return;
}
}
void ldv_main_exported_39(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_39 == 1) {
    psb_intel_pipe_set_base(psb_intel_helper_funcs_group2, ldvarg149, ldvarg148, psb_intel_helper_funcs_group1);
    ldv_state_variable_39 = 1;
  } else {

  }
  goto ldv_38762;
  case 1: ;
  if (ldv_state_variable_39 == 1) {
    psb_intel_crtc_dpms(psb_intel_helper_funcs_group2, ldvarg147);
    ldv_state_variable_39 = 1;
  } else {

  }
  goto ldv_38762;
  case 2: ;
  if (ldv_state_variable_39 == 1) {
    psb_intel_crtc_mode_fixup(psb_intel_helper_funcs_group2, (struct drm_display_mode  const  *)ldvarg146,
                              psb_intel_helper_funcs_group0);
    ldv_state_variable_39 = 1;
  } else {

  }
  goto ldv_38762;
  case 3: ;
  if (ldv_state_variable_39 == 1) {
    psb_intel_crtc_commit(psb_intel_helper_funcs_group2);
    ldv_state_variable_39 = 1;
  } else {

  }
  goto ldv_38762;
  case 4: ;
  if (ldv_state_variable_39 == 1) {
    psb_intel_crtc_mode_set(psb_intel_helper_funcs_group2, psb_intel_helper_funcs_group0,
                            ldvarg144, ldvarg143, ldvarg145, psb_intel_helper_funcs_group1);
    ldv_state_variable_39 = 1;
  } else {

  }
  goto ldv_38762;
  case 5: ;
  if (ldv_state_variable_39 == 1) {
    psb_intel_crtc_prepare(psb_intel_helper_funcs_group2);
    ldv_state_variable_39 = 1;
  } else {

  }
  goto ldv_38762;
  default: ;
  goto ldv_38762;
  }
  ldv_38762: ;
  return;
}
}
void ldv_mutex_lock_305(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_307(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_308(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_309(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_310(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_311(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_313(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_315(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_316(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
extern int strcmp(char const   * , char const   * ) ;
int ldv_mutex_trylock_332(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_330(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_333(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_335(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_337(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_338(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_340(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_329(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_331(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_334(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_336(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_339(struct mutex *ldv_func_arg1 ) ;
extern int dev_printk(char const   * , struct device  const  * , char const   *  , ...) ;
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
extern int i2c_transfer(struct i2c_adapter * , struct i2c_msg * , int  ) ;
extern int drm_connector_init(struct drm_device * , struct drm_connector * , struct drm_connector_funcs  const  * ,
                              int  ) ;
extern void drm_connector_cleanup(struct drm_connector * ) ;
extern int drm_encoder_init(struct drm_device * , struct drm_encoder * , struct drm_encoder_funcs  const  * ,
                            int  ) ;
extern void drm_mode_probed_add(struct drm_connector * , struct drm_display_mode * ) ;
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device * , struct drm_display_mode  const  * ) ;
extern int drm_object_property_set_value(struct drm_mode_object * , struct drm_property * ,
                                         uint64_t  ) ;
extern int drm_object_property_get_value(struct drm_mode_object * , struct drm_property * ,
                                         uint64_t * ) ;
extern void drm_object_attach_property(struct drm_mode_object * , struct drm_property * ,
                                       uint64_t  ) ;
extern int drm_sysfs_connector_add(struct drm_connector * ) ;
extern void drm_sysfs_connector_remove(struct drm_connector * ) ;
extern int drm_helper_probe_single_connector_modes(struct drm_connector * , uint32_t  ,
                                                   uint32_t  ) ;
extern bool drm_crtc_helper_set_mode(struct drm_crtc * , struct drm_display_mode * ,
                                     int  , int  , struct drm_framebuffer * ) ;
extern void drm_helper_connector_dpms(struct drm_connector * , int  ) ;
__inline static void drm_encoder_helper_add(struct drm_encoder *encoder , struct drm_encoder_helper_funcs  const  *funcs ) 
{ 

  {
  encoder->helper_private = (void *)funcs;
  return;
}
}
__inline static void drm_connector_helper_add(struct drm_connector *connector , struct drm_connector_helper_funcs  const  *funcs ) 
{ 

  {
  connector->helper_private = (void *)funcs;
  return;
}
}
int psb_intel_ddc_get_modes(struct drm_connector *connector , struct i2c_adapter *adapter ) ;
void psb_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
void psb_intel_lvds_set_brightness(struct drm_device *dev , int level ) ;
bool psb_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                               struct drm_display_mode *adjusted_mode ) ;
int psb_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) ;
int psb_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                uint64_t value ) ;
void psb_intel_lvds_destroy(struct drm_connector *connector ) ;
struct drm_encoder_funcs  const  psb_intel_lvds_enc_funcs ;
struct drm_connector_helper_funcs  const  psb_intel_lvds_connector_helper_funcs ;
struct drm_connector_funcs  const  psb_intel_lvds_connector_funcs ;
static u32 psb_intel_lvds_get_max_backlight(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 ret ;
  bool tmp ;
  uint32_t tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = gma_power_begin(dev, 0);
  if ((int )tmp) {
    ret = REGISTER_READ(dev, 397908U);
    gma_power_end(dev);
  } else {
    ret = dev_priv->regs.saveBLC_PWM_CTL;
  }
  ret = ret >> 17;
  ret = ret * 2U;
  if (ret == 0U) {
    tmp___0 = REGISTER_READ(dev, 397908U);
    dev_err((struct device  const  *)dev->dev, "BL bug: Reg %08x save %08X\n", tmp___0,
            dev_priv->regs.saveBLC_PWM_CTL);
  } else {

  }
  return (ret);
}
}
static int psb_lvds_i2c_set_brightness(struct drm_device *dev , unsigned int level ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_i2c_chan *lvds_i2c_bus ;
  u8 out_buf[2U] ;
  unsigned int blc_i2c_brightness ;
  struct i2c_msg msgs[1U] ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  lvds_i2c_bus = dev_priv->lvds_i2c_bus;
  msgs[0].addr = (unsigned short )lvds_i2c_bus->slave_addr;
  msgs[0].flags = 0U;
  msgs[0].len = 2U;
  msgs[0].buf = (__u8 *)(& out_buf);
  blc_i2c_brightness = (level * 255U) / 100U & 255U;
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) != 0U) {
    blc_i2c_brightness = 255U - blc_i2c_brightness;
  } else {

  }
  out_buf[0] = (dev_priv->lvds_bl)->brightnesscmd;
  out_buf[1] = (unsigned char )blc_i2c_brightness;
  tmp___0 = i2c_transfer(& lvds_i2c_bus->adapter, (struct i2c_msg *)(& msgs), 1);
  if (tmp___0 == 1) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "psb_lvds_i2c_set_brightness";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c.prepared";
    descriptor.format = "I2C set brightness.(command, value) (%d, %d)\n";
    descriptor.lineno = 275U;
    descriptor.flags = 0U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "I2C set brightness.(command, value) (%d, %d)\n",
                        (int )(dev_priv->lvds_bl)->brightnesscmd, blc_i2c_brightness);
    } else {

    }
    return (0);
  } else {

  }
  dev_err((struct device  const  *)dev->dev, "I2C transfer error\n");
  return (-1);
}
}
static int psb_lvds_pwm_set_brightness(struct drm_device *dev , int level ) 
{ struct drm_psb_private *dev_priv ;
  u32 max_pwm_blc ;
  u32 blc_pwm_duty_cycle ;
  long tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  max_pwm_blc = psb_intel_lvds_get_max_backlight(dev);
  tmp = ldv__builtin_expect(max_pwm_blc == 0U, 0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c.prepared"),
                         "i" (295), "i" (12UL));
    ldv_38162: ;
    goto ldv_38162;
  } else {

  }
  blc_pwm_duty_cycle = ((u32 )level * max_pwm_blc) / 100U;
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) != 0U) {
    blc_pwm_duty_cycle = max_pwm_blc - blc_pwm_duty_cycle;
  } else {

  }
  blc_pwm_duty_cycle = blc_pwm_duty_cycle & 65534U;
  REGISTER_WRITE(dev, 397908U, (max_pwm_blc << 16) | blc_pwm_duty_cycle);
  _dev_info((struct device  const  *)dev->dev, "Backlight lvds set brightness %08x\n",
            (max_pwm_blc << 16) | blc_pwm_duty_cycle);
  return (0);
}
}
void psb_intel_lvds_set_brightness(struct drm_device *dev , int level ) 
{ struct drm_psb_private *dev_priv ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  descriptor.modname = "gma500_gfx";
  descriptor.function = "psb_intel_lvds_set_brightness";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c.prepared";
  descriptor.format = "backlight level is %d\n";
  descriptor.lineno = 321U;
  descriptor.flags = 0U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "backlight level is %d\n",
                      level);
  } else {

  }
  if ((unsigned long )dev_priv->lvds_bl == (unsigned long )((struct bdb_lvds_backlight *)0)) {
    dev_err((struct device  const  *)dev->dev, "NO LVDS backlight info\n");
    return;
  } else {

  }
  if ((unsigned int )*((unsigned char *)dev_priv->lvds_bl + 0UL) == 1U) {
    psb_lvds_i2c_set_brightness(dev, (unsigned int )level);
  } else {
    psb_lvds_pwm_set_brightness(dev, level);
  }
  return;
}
}
static void psb_intel_lvds_set_backlight(struct drm_device *dev , int level ) 
{ struct drm_psb_private *dev_priv ;
  u32 blc_pwm_ctl ;
  bool tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = gma_power_begin(dev, 0);
  if ((int )tmp) {
    blc_pwm_ctl = REGISTER_READ(dev, 397908U);
    blc_pwm_ctl = blc_pwm_ctl & 4294901760U;
    REGISTER_WRITE(dev, 397908U, blc_pwm_ctl | (u32 )level);
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
    gma_power_end(dev);
  } else {
    blc_pwm_ctl = dev_priv->regs.saveBLC_PWM_CTL & 4294901760U;
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
  }
  return;
}
}
static void psb_intel_lvds_set_power(struct drm_device *dev , bool on ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 pp_status ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    dev_err((struct device  const  *)dev->dev, "set power, chip off!\n");
    return;
  } else {

  }
  if ((int )on) {
    tmp___1 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_38183: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status >= 0) {
      goto ldv_38183;
    } else {
      goto ldv_38184;
    }
    ldv_38184: 
    psb_intel_lvds_set_backlight(dev, mode_dev->backlight_duty_cycle);
  } else {
    psb_intel_lvds_set_backlight(dev, 0);
    tmp___2 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_38185: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status < 0) {
      goto ldv_38185;
    } else {
      goto ldv_38186;
    }
    ldv_38186: ;
  }
  gma_power_end(dev);
  return;
}
}
static void psb_intel_lvds_encoder_dpms(struct drm_encoder *encoder , int mode ) 
{ struct drm_device *dev ;

  {
  dev = encoder->dev;
  if (mode == 0) {
    psb_intel_lvds_set_power(dev, 1);
  } else {
    psb_intel_lvds_set_power(dev, 0);
  }
  return;
}
}
static void psb_intel_lvds_save(struct drm_connector *connector ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  dev = connector->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  lvds_priv = (struct psb_intel_lvds_priv *)psb_intel_encoder->dev_priv;
  lvds_priv->savePP_ON = REGISTER_READ(dev, 397832U);
  lvds_priv->savePP_OFF = REGISTER_READ(dev, 397836U);
  lvds_priv->saveLVDS = REGISTER_READ(dev, 397696U);
  lvds_priv->savePP_CONTROL = REGISTER_READ(dev, 397828U);
  lvds_priv->savePP_CYCLE = REGISTER_READ(dev, 397840U);
  lvds_priv->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
  lvds_priv->savePFIT_CONTROL = REGISTER_READ(dev, 397872U);
  lvds_priv->savePFIT_PGM_RATIOS = REGISTER_READ(dev, 397876U);
  dev_priv->backlight_duty_cycle = (int )dev_priv->regs.saveBLC_PWM_CTL & 65535;
  if (dev_priv->backlight_duty_cycle == 0) {
    tmp___0 = psb_intel_lvds_get_max_backlight(dev);
    dev_priv->backlight_duty_cycle = (int )tmp___0;
  } else {

  }
  descriptor.modname = "gma500_gfx";
  descriptor.function = "psb_intel_lvds_save";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c.prepared";
  descriptor.format = "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n";
  descriptor.lineno = 447U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
                      lvds_priv->savePP_ON, lvds_priv->savePP_OFF, lvds_priv->saveLVDS,
                      lvds_priv->savePP_CONTROL, lvds_priv->savePP_CYCLE, lvds_priv->saveBLC_PWM_CTL);
  } else {

  }
  return;
}
}
static void psb_intel_lvds_restore(struct drm_connector *connector ) 
{ struct drm_device *dev ;
  u32 pp_status ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  dev = connector->dev;
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  lvds_priv = (struct psb_intel_lvds_priv *)psb_intel_encoder->dev_priv;
  descriptor.modname = "gma500_gfx";
  descriptor.function = "psb_intel_lvds_restore";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_intel_lvds.c.prepared";
  descriptor.format = "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n";
  descriptor.lineno = 465U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
                      lvds_priv->savePP_ON, lvds_priv->savePP_OFF, lvds_priv->saveLVDS,
                      lvds_priv->savePP_CONTROL, lvds_priv->savePP_CYCLE, lvds_priv->saveBLC_PWM_CTL);
  } else {

  }
  REGISTER_WRITE(dev, 397908U, lvds_priv->saveBLC_PWM_CTL);
  REGISTER_WRITE(dev, 397872U, lvds_priv->savePFIT_CONTROL);
  REGISTER_WRITE(dev, 397876U, lvds_priv->savePFIT_PGM_RATIOS);
  REGISTER_WRITE(dev, 397832U, lvds_priv->savePP_ON);
  REGISTER_WRITE(dev, 397836U, lvds_priv->savePP_OFF);
  REGISTER_WRITE(dev, 397840U, lvds_priv->savePP_CYCLE);
  REGISTER_WRITE(dev, 397828U, lvds_priv->savePP_CONTROL);
  REGISTER_WRITE(dev, 397696U, lvds_priv->saveLVDS);
  if ((int )lvds_priv->savePP_CONTROL & 1) {
    tmp___1 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_38210: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status >= 0) {
      goto ldv_38210;
    } else {
      goto ldv_38211;
    }
    ldv_38211: ;
  } else {
    tmp___2 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_38212: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status < 0) {
      goto ldv_38212;
    } else {
      goto ldv_38213;
    }
    ldv_38213: ;
  }
  return;
}
}
int psb_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct drm_display_mode *fixed_mode ;

  {
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  fixed_mode = dev_priv->mode_dev.panel_fixed_mode;
  if (psb_intel_encoder->type == 8) {
    fixed_mode = dev_priv->mode_dev.panel_fixed_mode2;
  } else {

  }
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {

  }
  if ((mode->flags & 16U) != 0U) {
    return (7);
  } else {

  }
  if ((unsigned long )fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    if (mode->hdisplay > fixed_mode->hdisplay) {
      return (29);
    } else {

    }
    if (mode->vdisplay > fixed_mode->vdisplay) {
      return (29);
    } else {

    }
  } else {

  }
  return (0);
}
}
bool psb_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                               struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_encoder *tmp_encoder ;
  struct drm_display_mode *panel_fixed_mode ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct drm_encoder  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  __mptr = (struct drm_crtc  const  *)encoder->crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  panel_fixed_mode = mode_dev->panel_fixed_mode;
  __mptr___0 = (struct drm_encoder  const  *)encoder;
  psb_intel_encoder = (struct psb_intel_encoder *)__mptr___0;
  if (psb_intel_encoder->type == 8) {
    panel_fixed_mode = mode_dev->panel_fixed_mode2;
  } else {

  }
  if ((dev->pci_device & 65532) != 16640 && psb_intel_crtc->pipe == 0) {
    printk("\vCan\'t support LVDS on pipe A\n");
    return (0);
  } else {

  }
  if ((dev->pci_device & 65532) == 16640 && psb_intel_crtc->pipe != 0) {
    printk("\vMust use PIPE A\n");
    return (0);
  } else {

  }
  __mptr___1 = (struct list_head  const  *)dev->mode_config.encoder_list.next;
  tmp_encoder = (struct drm_encoder *)__mptr___1 + 0xfffffffffffffff8UL;
  goto ldv_38242;
  ldv_38241: ;
  if ((unsigned long )tmp_encoder != (unsigned long )encoder && (unsigned long )tmp_encoder->crtc == (unsigned long )encoder->crtc) {
    printk("\vCan\'t enable LVDS and another encoder on the same pipe\n");
    return (0);
  } else {

  }
  __mptr___2 = (struct list_head  const  *)tmp_encoder->head.next;
  tmp_encoder = (struct drm_encoder *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_38242: ;
  if ((unsigned long )(& tmp_encoder->head) != (unsigned long )(& dev->mode_config.encoder_list)) {
    goto ldv_38241;
  } else {
    goto ldv_38243;
  }
  ldv_38243: ;
  if ((unsigned long )panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    adjusted_mode->hdisplay = panel_fixed_mode->hdisplay;
    adjusted_mode->hsync_start = panel_fixed_mode->hsync_start;
    adjusted_mode->hsync_end = panel_fixed_mode->hsync_end;
    adjusted_mode->htotal = panel_fixed_mode->htotal;
    adjusted_mode->vdisplay = panel_fixed_mode->vdisplay;
    adjusted_mode->vsync_start = panel_fixed_mode->vsync_start;
    adjusted_mode->vsync_end = panel_fixed_mode->vsync_end;
    adjusted_mode->vtotal = panel_fixed_mode->vtotal;
    adjusted_mode->clock = panel_fixed_mode->clock;
    drm_mode_set_crtcinfo(adjusted_mode, 1);
  } else {

  }
  return (1);
}
}
static void psb_intel_lvds_prepare(struct drm_encoder *encoder ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
  psb_intel_lvds_set_power(dev, 0);
  gma_power_end(dev);
  return;
}
}
static void psb_intel_lvds_commit(struct drm_encoder *encoder ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  if (mode_dev->backlight_duty_cycle == 0) {
    tmp = psb_intel_lvds_get_max_backlight(dev);
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
  psb_intel_lvds_set_power(dev, 1);
  return;
}
}
static void psb_intel_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  u32 pfit_control ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
    pfit_control = 2147485280U;
  } else {
    pfit_control = 0U;
  }
  if ((unsigned int )*((unsigned char *)dev_priv + 824UL) != 0U) {
    pfit_control = pfit_control | 8U;
  } else {

  }
  REGISTER_WRITE(dev, 397872U, pfit_control);
  return;
}
}
static enum drm_connector_status psb_intel_lvds_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ 

  {
  return (1);
}
}
static int psb_intel_lvds_get_modes(struct drm_connector *connector ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;
  int ret ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *tmp___0 ;

  {
  dev = connector->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  lvds_priv = (struct psb_intel_lvds_priv *)psb_intel_encoder->dev_priv;
  ret = 0;
  if ((dev->pci_device & 65532) != 16640) {
    ret = psb_intel_ddc_get_modes(connector, & (lvds_priv->i2c_bus)->adapter);
  } else {

  }
  if (ret != 0) {
    return (ret);
  } else {

  }
  connector->display_info.min_vfreq = 0U;
  connector->display_info.max_vfreq = 200U;
  connector->display_info.min_hfreq = 0U;
  connector->display_info.max_hfreq = 200U;
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    tmp___0 = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->panel_fixed_mode);
    mode = tmp___0;
    drm_mode_probed_add(connector, mode);
    return (1);
  } else {

  }
  return (0);
}
}
void psb_intel_lvds_destroy(struct drm_connector *connector ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct psb_intel_lvds_priv *lvds_priv ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  lvds_priv = (struct psb_intel_lvds_priv *)psb_intel_encoder->dev_priv;
  if ((unsigned long )lvds_priv->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    psb_intel_i2c_destroy(lvds_priv->ddc_bus);
  } else {

  }
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const   *)connector);
  return;
}
}
int psb_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                uint64_t value ) 
{ struct drm_encoder *encoder ;
  struct psb_intel_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  uint64_t curval ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct drm_encoder_helper_funcs *hfuncs ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  encoder = connector->encoder;
  if ((unsigned long )encoder == (unsigned long )((struct drm_encoder *)0)) {
    return (-1);
  } else {

  }
  tmp___6 = strcmp((char const   *)(& property->name), "scaling mode");
  if (tmp___6 == 0) {
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
    crtc = (struct psb_intel_crtc *)__mptr;
    if ((unsigned long )crtc == (unsigned long )((struct psb_intel_crtc *)0)) {
      goto set_prop_error;
    } else {

    }
    switch (value) {
    case 1: ;
    goto ldv_38295;
    case 2: ;
    goto ldv_38295;
    case 3: ;
    goto ldv_38295;
    default: ;
    goto set_prop_error;
    }
    ldv_38295: 
    tmp = drm_object_property_get_value(& connector->base, property, & curval);
    if (tmp != 0) {
      goto set_prop_error;
    } else {

    }
    if (curval == value) {
      goto set_prop_done;
    } else {

    }
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
    if (tmp___0 != 0) {
      goto set_prop_error;
    } else {

    }
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
      tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                         (encoder->crtc)->y, (encoder->crtc)->fb);
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      if (tmp___2) {
        goto set_prop_error;
      } else {

      }
    } else {

    }
  } else {
    tmp___5 = strcmp((char const   *)(& property->name), "backlight");
    if (tmp___5 == 0) {
      tmp___3 = drm_object_property_set_value(& connector->base, property, value);
      if (tmp___3 != 0) {
        goto set_prop_error;
      } else {
        gma_backlight_set(encoder->dev, (int )value);
      }
    } else {
      tmp___4 = strcmp((char const   *)(& property->name), "DPMS");
      if (tmp___4 == 0) {
        hfuncs = (struct drm_encoder_helper_funcs *)encoder->helper_private;
        (*(hfuncs->dpms))(encoder, (int )value);
      } else {

      }
    }
  }
  set_prop_done: ;
  return (0);
  set_prop_error: ;
  return (-1);
}
}
static struct drm_encoder_helper_funcs  const  psb_intel_lvds_helper_funcs  = 
     {& psb_intel_lvds_encoder_dpms, 0, 0, & psb_intel_lvds_mode_fixup, & psb_intel_lvds_prepare,
    & psb_intel_lvds_commit, & psb_intel_lvds_mode_set, 0, 0, 0};
struct drm_connector_helper_funcs  const  psb_intel_lvds_connector_helper_funcs  =    {& psb_intel_lvds_get_modes,
    & psb_intel_lvds_mode_valid, & psb_intel_best_encoder};
struct drm_connector_funcs  const  psb_intel_lvds_connector_funcs  = 
     {& drm_helper_connector_dpms, & psb_intel_lvds_save, & psb_intel_lvds_restore,
    0, & psb_intel_lvds_detect, & drm_helper_probe_single_connector_modes, & psb_intel_lvds_set_property,
    & psb_intel_lvds_destroy, 0};
static void psb_intel_lvds_enc_destroy(struct drm_encoder *encoder ) 
{ 

  {
  drm_encoder_cleanup(encoder);
  return;
}
}
struct drm_encoder_funcs  const  psb_intel_lvds_enc_funcs  =    {0, & psb_intel_lvds_enc_destroy};
void psb_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_connector *psb_intel_connector ;
  struct psb_intel_lvds_priv *lvds_priv ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_display_mode *scan ;
  struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  u32 lvds ;
  int pipe ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = kzalloc(136UL, 208U);
  psb_intel_encoder = (struct psb_intel_encoder *)tmp;
  if ((unsigned long )psb_intel_encoder == (unsigned long )((struct psb_intel_encoder *)0)) {
    dev_err((struct device  const  *)dev->dev, "psb_intel_encoder allocation error\n");
    return;
  } else {

  }
  tmp___0 = kzalloc(1864UL, 208U);
  psb_intel_connector = (struct psb_intel_connector *)tmp___0;
  if ((unsigned long )psb_intel_connector == (unsigned long )((struct psb_intel_connector *)0)) {
    dev_err((struct device  const  *)dev->dev, "psb_intel_connector allocation error\n");
    goto failed_encoder;
  } else {

  }
  tmp___1 = kzalloc(48UL, 208U);
  lvds_priv = (struct psb_intel_lvds_priv *)tmp___1;
  if ((unsigned long )lvds_priv == (unsigned long )((struct psb_intel_lvds_priv *)0)) {
    dev_err((struct device  const  *)dev->dev, "LVDS private allocation error\n");
    goto failed_connector;
  } else {

  }
  psb_intel_encoder->dev_priv = (void *)lvds_priv;
  connector = & psb_intel_connector->base;
  encoder = & psb_intel_encoder->base;
  drm_connector_init(dev, connector, & psb_intel_lvds_connector_funcs, 7);
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 3);
  psb_intel_connector_attach_encoder(psb_intel_connector, psb_intel_encoder);
  psb_intel_encoder->type = 4;
  drm_encoder_helper_add(encoder, & psb_intel_lvds_helper_funcs);
  drm_connector_helper_add(connector, & psb_intel_lvds_connector_helper_funcs);
  connector->display_info.subpixel_order = 1;
  connector->interlace_allowed = 0;
  connector->doublescan_allowed = 0;
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
  lvds_priv->i2c_bus = psb_intel_i2c_create(dev, 20500U, "LVDSBLC_B");
  if ((unsigned long )lvds_priv->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "I2C bus registration failed.\n");
    goto failed_blc_i2c;
  } else {

  }
  (lvds_priv->i2c_bus)->slave_addr = 44U;
  dev_priv->lvds_i2c_bus = lvds_priv->i2c_bus;
  lvds_priv->ddc_bus = psb_intel_i2c_create(dev, 20504U, "LVDSDDC_C");
  if ((unsigned long )lvds_priv->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
    goto failed_ddc;
  } else {

  }
  psb_intel_ddc_get_modes(connector, & (lvds_priv->ddc_bus)->adapter);
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
  scan = (struct drm_display_mode *)__mptr;
  goto ldv_38332;
  ldv_38331: ;
  if ((scan->type & 8U) != 0U) {
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
    goto out;
  } else {

  }
  __mptr___0 = (struct list_head  const  *)scan->head.next;
  scan = (struct drm_display_mode *)__mptr___0;
  ldv_38332: ;
  if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
    goto ldv_38331;
  } else {
    goto ldv_38333;
  }
  ldv_38333: ;
  if ((unsigned long )mode_dev->vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->vbt_mode);
  } else {

  }
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
    } else {

    }
  } else {

  }
  lvds = REGISTER_READ(dev, 397696U);
  pipe = (lvds & 1073741824U) != 0U;
  crtc = psb_intel_get_crtc_from_pipe(dev, pipe);
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0) && (int )lvds < 0) {
    mode_dev->panel_fixed_mode = psb_intel_crtc_mode_get(dev, crtc);
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
      goto out;
    } else {

    }
  } else {

  }
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    dev_err((struct device  const  *)dev->dev, "Found no modes on the lvds, ignoring the LVDS\n");
    goto failed_find;
  } else {

  }
  out: 
  drm_sysfs_connector_add(connector);
  return;
  failed_find: ;
  if ((unsigned long )lvds_priv->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    psb_intel_i2c_destroy(lvds_priv->ddc_bus);
  } else {

  }
  failed_ddc: ;
  if ((unsigned long )lvds_priv->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    psb_intel_i2c_destroy(lvds_priv->i2c_bus);
  } else {

  }
  failed_blc_i2c: 
  drm_encoder_cleanup(encoder);
  drm_connector_cleanup(connector);
  failed_connector: 
  kfree((void const   *)psb_intel_connector);
  failed_encoder: 
  kfree((void const   *)psb_intel_encoder);
  return;
}
}
struct drm_encoder *psb_intel_lvds_helper_funcs_group1  ;
struct drm_display_mode *ldvarg200  ;
uint64_t ldvarg85  ;
uint32_t ldvarg84  ;
struct drm_connector *psb_intel_lvds_connector_funcs_group0  ;
int ldvarg88  ;
struct drm_display_mode *psb_intel_lvds_helper_funcs_group0  ;
bool ldvarg87  ;
struct drm_encoder *ldvarg196  ;
struct drm_property *ldvarg86  ;
extern int ldv_psb_intel_lvds_enc_funcs_probe_34(void) ;
struct drm_display_mode *ldvarg150  ;
struct drm_display_mode *ldvarg199  ;
extern int ldv_psb_intel_lvds_connector_funcs_probe_35(void) ;
int ldvarg201  ;
uint32_t ldvarg83  ;
struct drm_connector *psb_intel_lvds_connector_helper_funcs_group0  ;
void ldv_main_exported_35(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_35 == 2) {
    drm_helper_connector_dpms(psb_intel_lvds_connector_funcs_group0, ldvarg88);
    ldv_state_variable_35 = 2;
  } else {

  }
  if (ldv_state_variable_35 == 1) {
    drm_helper_connector_dpms(psb_intel_lvds_connector_funcs_group0, ldvarg88);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_38358;
  case 1: ;
  if (ldv_state_variable_35 == 2) {
    psb_intel_lvds_detect(psb_intel_lvds_connector_funcs_group0, (int )ldvarg87);
    ldv_state_variable_35 = 2;
  } else {

  }
  if (ldv_state_variable_35 == 1) {
    psb_intel_lvds_detect(psb_intel_lvds_connector_funcs_group0, (int )ldvarg87);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_38358;
  case 2: ;
  if (ldv_state_variable_35 == 2) {
    psb_intel_lvds_set_property(psb_intel_lvds_connector_funcs_group0, ldvarg86, ldvarg85);
    ldv_state_variable_35 = 2;
  } else {

  }
  if (ldv_state_variable_35 == 1) {
    psb_intel_lvds_set_property(psb_intel_lvds_connector_funcs_group0, ldvarg86, ldvarg85);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_38358;
  case 3: ;
  if (ldv_state_variable_35 == 2) {
    psb_intel_lvds_destroy(psb_intel_lvds_connector_funcs_group0);
    ldv_state_variable_35 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38358;
  case 4: ;
  if (ldv_state_variable_35 == 2) {
    psb_intel_lvds_save(psb_intel_lvds_connector_funcs_group0);
    ldv_state_variable_35 = 2;
  } else {

  }
  if (ldv_state_variable_35 == 1) {
    psb_intel_lvds_save(psb_intel_lvds_connector_funcs_group0);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_38358;
  case 5: ;
  if (ldv_state_variable_35 == 2) {
    psb_intel_lvds_restore(psb_intel_lvds_connector_funcs_group0);
    ldv_state_variable_35 = 2;
  } else {

  }
  if (ldv_state_variable_35 == 1) {
    psb_intel_lvds_restore(psb_intel_lvds_connector_funcs_group0);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_38358;
  case 6: ;
  if (ldv_state_variable_35 == 2) {
    drm_helper_probe_single_connector_modes(psb_intel_lvds_connector_funcs_group0,
                                            ldvarg84, ldvarg83);
    ldv_state_variable_35 = 2;
  } else {

  }
  if (ldv_state_variable_35 == 1) {
    drm_helper_probe_single_connector_modes(psb_intel_lvds_connector_funcs_group0,
                                            ldvarg84, ldvarg83);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_38358;
  case 7: ;
  if (ldv_state_variable_35 == 1) {
    ldv_psb_intel_lvds_connector_funcs_probe_35();
    ldv_state_variable_35 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38358;
  default: ;
  goto ldv_38358;
  }
  ldv_38358: ;
  return;
}
}
void ldv_main_exported_34(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_34 == 2) {
    psb_intel_lvds_enc_destroy(ldvarg196);
    ldv_state_variable_34 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38371;
  case 1: ;
  if (ldv_state_variable_34 == 1) {
    ldv_psb_intel_lvds_enc_funcs_probe_34();
    ldv_state_variable_34 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38371;
  default: ;
  goto ldv_38371;
  }
  ldv_38371: ;
  return;
}
}
void ldv_main_exported_36(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_36 == 1) {
    psb_intel_lvds_get_modes(psb_intel_lvds_connector_helper_funcs_group0);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_38378;
  case 1: ;
  if (ldv_state_variable_36 == 1) {
    psb_intel_lvds_mode_valid(psb_intel_lvds_connector_helper_funcs_group0, ldvarg150);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_38378;
  case 2: ;
  if (ldv_state_variable_36 == 1) {
    psb_intel_best_encoder(psb_intel_lvds_connector_helper_funcs_group0);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_38378;
  default: ;
  goto ldv_38378;
  }
  ldv_38378: ;
  return;
}
}
void ldv_main_exported_37(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_37 == 1) {
    psb_intel_lvds_encoder_dpms(psb_intel_lvds_helper_funcs_group1, ldvarg201);
    ldv_state_variable_37 = 1;
  } else {

  }
  goto ldv_38386;
  case 1: ;
  if (ldv_state_variable_37 == 1) {
    psb_intel_lvds_mode_fixup(psb_intel_lvds_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg200,
                              psb_intel_lvds_helper_funcs_group0);
    ldv_state_variable_37 = 1;
  } else {

  }
  goto ldv_38386;
  case 2: ;
  if (ldv_state_variable_37 == 1) {
    psb_intel_lvds_commit(psb_intel_lvds_helper_funcs_group1);
    ldv_state_variable_37 = 1;
  } else {

  }
  goto ldv_38386;
  case 3: ;
  if (ldv_state_variable_37 == 1) {
    psb_intel_lvds_mode_set(psb_intel_lvds_helper_funcs_group1, psb_intel_lvds_helper_funcs_group0,
                            ldvarg199);
    ldv_state_variable_37 = 1;
  } else {

  }
  goto ldv_38386;
  case 4: ;
  if (ldv_state_variable_37 == 1) {
    psb_intel_lvds_prepare(psb_intel_lvds_helper_funcs_group1);
    ldv_state_variable_37 = 1;
  } else {

  }
  goto ldv_38386;
  default: ;
  goto ldv_38386;
  }
  ldv_38386: ;
  return;
}
}
void ldv_mutex_lock_329(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_330(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_331(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_332(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_333(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_334(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_335(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_336(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_337(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_338(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_339(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_340(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_356(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_354(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_357(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_359(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_361(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_362(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_364(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_353(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_355(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_358(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_360(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_363(struct mutex *ldv_func_arg1 ) ;
extern struct edid *drm_get_edid(struct drm_connector * , struct i2c_adapter * ) ;
extern int drm_add_edid_modes(struct drm_connector * , struct edid * ) ;
extern int drm_mode_connector_update_edid_property(struct drm_connector * , struct edid * ) ;
bool psb_intel_ddc_probe(struct i2c_adapter *adapter ) ;
bool psb_intel_ddc_probe(struct i2c_adapter *adapter ) 
{ u8 out_buf[2U] ;
  u8 buf[2U] ;
  int ret ;
  struct i2c_msg msgs[2U] ;

  {
  out_buf[0] = 0U;
  out_buf[1] = 0U;
  msgs[0].addr = 80U;
  msgs[0].flags = 0U;
  msgs[0].len = 1U;
  msgs[0].buf = (__u8 *)(& out_buf);
  msgs[1].addr = 80U;
  msgs[1].flags = 1U;
  msgs[1].len = 1U;
  msgs[1].buf = (__u8 *)(& buf);
  ret = i2c_transfer(adapter, (struct i2c_msg *)(& msgs), 2);
  if (ret == 2) {
    return (1);
  } else {

  }
  return (0);
}
}
int psb_intel_ddc_get_modes(struct drm_connector *connector , struct i2c_adapter *adapter ) 
{ struct edid *edid ;
  int ret ;

  {
  ret = 0;
  edid = drm_get_edid(connector, adapter);
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    drm_mode_connector_update_edid_property(connector, edid);
    ret = drm_add_edid_modes(connector, edid);
    kfree((void const   *)edid);
  } else {

  }
  return (ret);
}
}
void ldv_mutex_lock_353(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_354(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_355(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_356(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_357(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_358(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_359(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_360(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_361(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_362(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_363(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_364(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
int ldv_mutex_trylock_380(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_378(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_381(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_383(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_385(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_386(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_388(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_377(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_379(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_382(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_384(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_387(struct mutex *ldv_func_arg1 ) ;
extern struct drm_property *drm_property_create(struct drm_device * , int  , char const   * ,
                                                int  ) ;
extern void drm_property_destroy(struct drm_device * , struct drm_property * ) ;
extern int drm_property_add_enum(struct drm_property * , int  , uint64_t  , char const   * ) ;
extern bool drm_detect_hdmi_monitor(struct edid * ) ;
extern bool drm_detect_monitor_audio(struct edid * ) ;
__inline static void psb_intel_mode_set_pixel_multiplier(struct drm_display_mode *mode ,
                                                         int multiplier ) 
{ 

  {
  mode->clock = mode->clock * multiplier;
  mode->private_flags = mode->private_flags | multiplier;
  return;
}
}
__inline static int psb_intel_mode_get_pixel_multiplier(struct drm_display_mode  const  *mode ) 
{ 

  {
  return ((int )mode->private_flags & 15);
}
}
bool psb_intel_sdvo_init(struct drm_device *dev , int sdvo_reg ) ;
static char const   *tv_format_names[19U]  = 
  {      "NTSC_M",      "NTSC_J",      "NTSC_443",      "PAL_B", 
        "PAL_D",      "PAL_G",      "PAL_H",      "PAL_I", 
        "PAL_M",      "PAL_N",      "PAL_NC",      "PAL_60", 
        "SECAM_B",      "SECAM_D",      "SECAM_G",      "SECAM_K", 
        "SECAM_K1",      "SECAM_L",      "SECAM_60"};
static struct psb_intel_sdvo *to_psb_intel_sdvo(struct drm_encoder *encoder ) 
{ struct drm_encoder  const  *__mptr ;

  {
  __mptr = (struct drm_encoder  const  *)encoder;
  return ((struct psb_intel_sdvo *)__mptr);
}
}
static struct psb_intel_sdvo *intel_attached_sdvo(struct drm_connector *connector ) 
{ struct psb_intel_encoder  const  *__mptr ;
  struct psb_intel_encoder *tmp ;

  {
  tmp = psb_intel_attached_encoder(connector);
  __mptr = (struct psb_intel_encoder  const  *)tmp;
  return ((struct psb_intel_sdvo *)__mptr);
}
}
static struct psb_intel_sdvo_connector *to_psb_intel_sdvo_connector(struct drm_connector *connector ) 
{ struct psb_intel_connector  const  *__mptr ;
  struct drm_connector  const  *__mptr___0 ;

  {
  __mptr___0 = (struct drm_connector  const  *)connector;
  __mptr = (struct psb_intel_connector  const  *)((struct psb_intel_connector *)__mptr___0);
  return ((struct psb_intel_sdvo_connector *)__mptr);
}
}
static bool psb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo , uint16_t flags ) ;
static bool psb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                              int type ) ;
static bool psb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                   struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ) ;
static void psb_intel_sdvo_write_sdvox(struct psb_intel_sdvo *psb_intel_sdvo , u32 val ) 
{ struct drm_device *dev ;
  u32 bval ;
  u32 cval ;
  int i ;

  {
  dev = psb_intel_sdvo->base.base.dev;
  bval = val;
  cval = val;
  if (psb_intel_sdvo->sdvo_reg == 397632) {
    cval = REGISTER_READ(dev, 397664U);
  } else {
    bval = REGISTER_READ(dev, 397632U);
  }
  i = 0;
  goto ldv_39327;
  ldv_39326: 
  REGISTER_WRITE(dev, 397632U, bval);
  REGISTER_READ(dev, 397632U);
  REGISTER_WRITE(dev, 397664U, cval);
  REGISTER_READ(dev, 397664U);
  i = i + 1;
  ldv_39327: ;
  if (i <= 1) {
    goto ldv_39326;
  } else {
    goto ldv_39328;
  }
  ldv_39328: ;
  return;
}
}
static bool psb_intel_sdvo_read_byte(struct psb_intel_sdvo *psb_intel_sdvo , u8 addr ,
                                     u8 *ch ) 
{ struct i2c_msg msgs[2U] ;
  int ret ;

  {
  msgs[0].addr = (unsigned short )psb_intel_sdvo->slave_addr;
  msgs[0].flags = 0U;
  msgs[0].len = 1U;
  msgs[0].buf = & addr;
  msgs[1].addr = (unsigned short )psb_intel_sdvo->slave_addr;
  msgs[1].flags = 1U;
  msgs[1].len = 1U;
  msgs[1].buf = ch;
  ret = i2c_transfer(psb_intel_sdvo->i2c, (struct i2c_msg *)(& msgs), 2);
  if (ret == 2) {
    return (1);
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_read_byte", "i2c transfer returned %d\n",
                      ret);
  return (0);
}
}
static struct _sdvo_cmd_name  const  sdvo_cmd_names[107U]  = 
  {      {1U, "SDVO_CMD_RESET"}, 
        {2U, "SDVO_CMD_GET_DEVICE_CAPS"}, 
        {134U, "SDVO_CMD_GET_FIRMWARE_REV"}, 
        {3U, "SDVO_CMD_GET_TRAINED_INPUTS"}, 
        {4U, "SDVO_CMD_GET_ACTIVE_OUTPUTS"}, 
        {5U, "SDVO_CMD_SET_ACTIVE_OUTPUTS"}, 
        {6U, "SDVO_CMD_GET_IN_OUT_MAP"}, 
        {7U, "SDVO_CMD_SET_IN_OUT_MAP"}, 
        {11U, "SDVO_CMD_GET_ATTACHED_DISPLAYS"}, 
        {12U, "SDVO_CMD_GET_HOT_PLUG_SUPPORT"}, 
        {13U, "SDVO_CMD_SET_ACTIVE_HOT_PLUG"}, 
        {14U, "SDVO_CMD_GET_ACTIVE_HOT_PLUG"}, 
        {15U, "SDVO_CMD_GET_INTERRUPT_EVENT_SOURCE"}, 
        {16U, "SDVO_CMD_SET_TARGET_INPUT"}, 
        {17U, "SDVO_CMD_SET_TARGET_OUTPUT"}, 
        {18U, "SDVO_CMD_GET_INPUT_TIMINGS_PART1"}, 
        {19U, "SDVO_CMD_GET_INPUT_TIMINGS_PART2"}, 
        {20U, "SDVO_CMD_SET_INPUT_TIMINGS_PART1"}, 
        {21U, "SDVO_CMD_SET_INPUT_TIMINGS_PART2"}, 
        {20U, "SDVO_CMD_SET_INPUT_TIMINGS_PART1"}, 
        {22U, "SDVO_CMD_SET_OUTPUT_TIMINGS_PART1"}, 
        {23U, "SDVO_CMD_SET_OUTPUT_TIMINGS_PART2"}, 
        {24U, "SDVO_CMD_GET_OUTPUT_TIMINGS_PART1"}, 
        {25U, "SDVO_CMD_GET_OUTPUT_TIMINGS_PART2"}, 
        {26U, "SDVO_CMD_CREATE_PREFERRED_INPUT_TIMING"}, 
        {27U, "SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1"}, 
        {28U, "SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2"}, 
        {29U, "SDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE"}, 
        {30U, "SDVO_CMD_GET_OUTPUT_PIXEL_CLOCK_RANGE"}, 
        {31U, "SDVO_CMD_GET_SUPPORTED_CLOCK_RATE_MULTS"}, 
        {32U, "SDVO_CMD_GET_CLOCK_RATE_MULT"}, 
        {33U, "SDVO_CMD_SET_CLOCK_RATE_MULT"}, 
        {39U, "SDVO_CMD_GET_SUPPORTED_TV_FORMATS"}, 
        {40U, "SDVO_CMD_GET_TV_FORMAT"}, 
        {41U, "SDVO_CMD_SET_TV_FORMAT"}, 
        {42U, "SDVO_CMD_GET_SUPPORTED_POWER_STATES"}, 
        {43U, "SDVO_CMD_GET_POWER_STATE"}, 
        {44U, "SDVO_CMD_SET_ENCODER_POWER_STATE"}, 
        {125U, "SDVO_CMD_SET_DISPLAY_POWER_STATE"}, 
        {122U, "SDVO_CMD_SET_CONTROL_BUS_SWITCH"}, 
        {131U, "SDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT"}, 
        {133U, "SDVO_CMD_GET_SCALED_HDTV_RESOLUTION_SUPPORT"}, 
        {132U, "SDVO_CMD_GET_SUPPORTED_ENHANCEMENTS"}, 
        {103U, "SDVO_CMD_GET_MAX_HPOS"}, 
        {104U, "SDVO_CMD_GET_HPOS"}, 
        {105U, "SDVO_CMD_SET_HPOS"}, 
        {106U, "SDVO_CMD_GET_MAX_VPOS"}, 
        {107U, "SDVO_CMD_GET_VPOS"}, 
        {108U, "SDVO_CMD_SET_VPOS"}, 
        {85U, "SDVO_CMD_GET_MAX_SATURATION"}, 
        {86U, "SDVO_CMD_GET_SATURATION"}, 
        {87U, "SDVO_CMD_SET_SATURATION"}, 
        {88U, "SDVO_CMD_GET_MAX_HUE"}, 
        {89U, "SDVO_CMD_GET_HUE"}, 
        {90U, "SDVO_CMD_SET_HUE"}, 
        {94U, "SDVO_CMD_GET_MAX_CONTRAST"}, 
        {95U, "SDVO_CMD_GET_CONTRAST"}, 
        {96U, "SDVO_CMD_SET_CONTRAST"}, 
        {91U, "SDVO_CMD_GET_MAX_BRIGHTNESS"}, 
        {92U, "SDVO_CMD_GET_BRIGHTNESS"}, 
        {93U, "SDVO_CMD_SET_BRIGHTNESS"}, 
        {97U, "SDVO_CMD_GET_MAX_OVERSCAN_H"}, 
        {98U, "SDVO_CMD_GET_OVERSCAN_H"}, 
        {99U, "SDVO_CMD_SET_OVERSCAN_H"}, 
        {100U, "SDVO_CMD_GET_MAX_OVERSCAN_V"}, 
        {101U, "SDVO_CMD_GET_OVERSCAN_V"}, 
        {102U, "SDVO_CMD_SET_OVERSCAN_V"}, 
        {77U, "SDVO_CMD_GET_MAX_FLICKER_FILTER"}, 
        {78U, "SDVO_CMD_GET_FLICKER_FILTER"}, 
        {79U, "SDVO_CMD_SET_FLICKER_FILTER"}, 
        {123U, "SDVO_CMD_GET_MAX_FLICKER_FILTER_ADAPTIVE"}, 
        {80U, "SDVO_CMD_GET_FLICKER_FILTER_ADAPTIVE"}, 
        {81U, "SDVO_CMD_SET_FLICKER_FILTER_ADAPTIVE"}, 
        {82U, "SDVO_CMD_GET_MAX_FLICKER_FILTER_2D"}, 
        {83U, "SDVO_CMD_GET_FLICKER_FILTER_2D"}, 
        {84U, "SDVO_CMD_SET_FLICKER_FILTER_2D"}, 
        {109U, "SDVO_CMD_GET_MAX_SHARPNESS"}, 
        {110U, "SDVO_CMD_GET_SHARPNESS"}, 
        {111U, "SDVO_CMD_SET_SHARPNESS"}, 
        {112U, "SDVO_CMD_GET_DOT_CRAWL"}, 
        {113U, "SDVO_CMD_SET_DOT_CRAWL"}, 
        {116U, "SDVO_CMD_GET_MAX_TV_CHROMA_FILTER"}, 
        {117U, "SDVO_CMD_GET_TV_CHROMA_FILTER"}, 
        {118U, "SDVO_CMD_SET_TV_CHROMA_FILTER"}, 
        {119U, "SDVO_CMD_GET_MAX_TV_LUMA_FILTER"}, 
        {120U, "SDVO_CMD_GET_TV_LUMA_FILTER"}, 
        {121U, "SDVO_CMD_SET_TV_LUMA_FILTER"}, 
        {157U, "SDVO_CMD_GET_SUPP_ENCODE"}, 
        {158U, "SDVO_CMD_GET_ENCODE"}, 
        {159U, "SDVO_CMD_SET_ENCODE"}, 
        {139U, "SDVO_CMD_SET_PIXEL_REPLI"}, 
        {140U, "SDVO_CMD_GET_PIXEL_REPLI"}, 
        {141U, "SDVO_CMD_GET_COLORIMETRY_CAP"}, 
        {142U, "SDVO_CMD_SET_COLORIMETRY"}, 
        {143U, "SDVO_CMD_GET_COLORIMETRY"}, 
        {144U, "SDVO_CMD_GET_AUDIO_ENCRYPT_PREFER"}, 
        {145U, "SDVO_CMD_SET_AUDIO_STAT"}, 
        {146U, "SDVO_CMD_GET_AUDIO_STAT"}, 
        {148U, "SDVO_CMD_GET_HBUF_INDEX"}, 
        {147U, "SDVO_CMD_SET_HBUF_INDEX"}, 
        {149U, "SDVO_CMD_GET_HBUF_INFO"}, 
        {151U, "SDVO_CMD_GET_HBUF_AV_SPLIT"}, 
        {150U, "SDVO_CMD_SET_HBUF_AV_SPLIT"}, 
        {155U, "SDVO_CMD_GET_HBUF_TXRATE"}, 
        {154U, "SDVO_CMD_SET_HBUF_TXRATE"}, 
        {152U, "SDVO_CMD_SET_HBUF_DATA"}, 
        {153U, "SDVO_CMD_GET_HBUF_DATA"}};
static void psb_intel_sdvo_debug_write(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                       void const   *args , int args_len ) 
{ int i ;
  char *tmp ;

  {
  if (psb_intel_sdvo->sdvo_reg == 397632) {
    tmp = (char *)"SDVOB";
  } else {
    tmp = (char *)"SDVOC";
  }
  drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_debug_write", "%s: W: %02X ", tmp,
                      (int )cmd);
  i = 0;
  goto ldv_39350;
  ldv_39349: 
  drm_ut_debug_printk(4U, 0, 0, "%02X ", (int )*((u8 *)args + (unsigned long )i));
  i = i + 1;
  ldv_39350: ;
  if (i < args_len) {
    goto ldv_39349;
  } else {
    goto ldv_39351;
  }
  ldv_39351: ;
  goto ldv_39353;
  ldv_39352: 
  drm_ut_debug_printk(4U, 0, 0, "   ");
  i = i + 1;
  ldv_39353: ;
  if (i <= 7) {
    goto ldv_39352;
  } else {
    goto ldv_39354;
  }
  ldv_39354: 
  i = 0;
  goto ldv_39359;
  ldv_39358: ;
  if ((int )((unsigned char )sdvo_cmd_names[i].cmd) == (int )cmd) {
    drm_ut_debug_printk(4U, 0, 0, "(%s)", sdvo_cmd_names[i].name);
    goto ldv_39357;
  } else {

  }
  i = i + 1;
  ldv_39359: ;
  if ((unsigned int )i <= 106U) {
    goto ldv_39358;
  } else {
    goto ldv_39357;
  }
  ldv_39357: ;
  if (i == 107) {
    drm_ut_debug_printk(4U, 0, 0, "(%02X)", (int )cmd);
  } else {

  }
  drm_ut_debug_printk(4U, 0, 0, "\n");
  return;
}
}
static char const   *cmd_status_names[7U]  = {      "Power on",      "Success",      "Not supported",      "Invalid arg", 
        "Pending",      "Target not specified",      "Scaling not supported"};
static bool psb_intel_sdvo_write_cmd(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void const   *args , int args_len ) 
{ u8 *buf ;
  unsigned long __lengthofbuf ;
  void *tmp ;
  u8 status ;
  struct i2c_msg *msgs ;
  unsigned long __lengthofmsgs ;
  void *tmp___0 ;
  int i ;
  int ret ;

  {
  __lengthofbuf = (unsigned long )((long )((args_len + 1) * 2));
  tmp = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
  buf = (u8 *)tmp;
  __lengthofmsgs = (unsigned long )((long )(args_len + 3));
  tmp___0 = __builtin_alloca(sizeof(*msgs) * __lengthofmsgs);
  msgs = (struct i2c_msg *)tmp___0;
  psb_intel_sdvo_debug_write(psb_intel_sdvo, (int )cmd, args, args_len);
  i = 0;
  goto ldv_39375;
  ldv_39374: 
  (msgs + i)->addr = (__u16 )psb_intel_sdvo->slave_addr;
  (msgs + i)->flags = 0U;
  (msgs + i)->len = 2U;
  (msgs + i)->buf = (__u8 *)(& buf) + (unsigned long )(i * 2);
  *(buf + i * 2) = 7U - (unsigned int )((u8 )i);
  *(buf + (i * 2 + 1)) = *((u8 *)args + (unsigned long )i);
  i = i + 1;
  ldv_39375: ;
  if (i < args_len) {
    goto ldv_39374;
  } else {
    goto ldv_39376;
  }
  ldv_39376: 
  (msgs + i)->addr = (__u16 )psb_intel_sdvo->slave_addr;
  (msgs + i)->flags = 0U;
  (msgs + i)->len = 2U;
  (msgs + i)->buf = (__u8 *)(& buf) + (unsigned long )(i * 2);
  *(buf + i * 2) = 8U;
  *(buf + (i * 2 + 1)) = cmd;
  status = 9U;
  (msgs + (i + 1))->addr = (__u16 )psb_intel_sdvo->slave_addr;
  (msgs + (i + 1))->flags = 0U;
  (msgs + (i + 1))->len = 1U;
  (msgs + (i + 1))->buf = & status;
  (msgs + (i + 2))->addr = (__u16 )psb_intel_sdvo->slave_addr;
  (msgs + (i + 2))->flags = 1U;
  (msgs + (i + 2))->len = 1U;
  (msgs + (i + 2))->buf = & status;
  ret = i2c_transfer(psb_intel_sdvo->i2c, (struct i2c_msg *)(& msgs), i + 3);
  if (ret < 0) {
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_write_cmd", "I2c transfer returned %d\n",
                        ret);
    return (0);
  } else {

  }
  if (i + 3 != ret) {
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_write_cmd", "I2c transfer returned %d/%d\n",
                        ret, i + 3);
    return (0);
  } else {

  }
  return (1);
}
}
static bool psb_intel_sdvo_read_response(struct psb_intel_sdvo *psb_intel_sdvo , void *response ,
                                         int response_len ) 
{ u8 retry ;
  u8 status ;
  int i ;
  char *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
  retry = 5U;
  if (psb_intel_sdvo->sdvo_reg == 397632) {
    tmp = (char *)"SDVOB";
  } else {
    tmp = (char *)"SDVOC";
  }
  drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_read_response", "%s: R: ", tmp);
  tmp___0 = psb_intel_sdvo_read_byte(psb_intel_sdvo, 9, & status);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto log_fail;
  } else {

  }
  goto ldv_39389;
  ldv_39388: 
  __const_udelay(64425UL);
  tmp___2 = psb_intel_sdvo_read_byte(psb_intel_sdvo, 9, & status);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto log_fail;
  } else {

  }
  ldv_39389: ;
  if ((unsigned int )status == 4U) {
    tmp___4 = retry;
    retry = (u8 )((int )retry - 1);
    if ((unsigned int )((unsigned char )tmp___4) != 0U) {
      goto ldv_39388;
    } else {
      goto ldv_39390;
    }
  } else {
    goto ldv_39390;
  }
  ldv_39390: ;
  if ((unsigned int )status <= 6U) {
    drm_ut_debug_printk(4U, 0, 0, "(%s)", cmd_status_names[(int )status]);
  } else {
    drm_ut_debug_printk(4U, 0, 0, "(??? %d)", (int )status);
  }
  if ((unsigned int )status != 1U) {
    goto log_fail;
  } else {

  }
  i = 0;
  goto ldv_39392;
  ldv_39391: 
  tmp___5 = psb_intel_sdvo_read_byte(psb_intel_sdvo, (int )((unsigned int )((u8 )i) + 10U),
                                     (u8 *)response + (unsigned long )i);
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    goto log_fail;
  } else {

  }
  drm_ut_debug_printk(4U, 0, 0, " %02X", (int )*((u8 *)response + (unsigned long )i));
  i = i + 1;
  ldv_39392: ;
  if (i < response_len) {
    goto ldv_39391;
  } else {
    goto ldv_39393;
  }
  ldv_39393: 
  drm_ut_debug_printk(4U, 0, 0, "\n");
  return (1);
  log_fail: 
  drm_ut_debug_printk(4U, 0, 0, "... failed\n");
  return (0);
}
}
static int psb_intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode ) 
{ 

  {
  if (mode->clock > 99999) {
    return (1);
  } else
  if (mode->clock > 49999) {
    return (2);
  } else {
    return (4);
  }
}
}
static bool psb_intel_sdvo_set_control_bus_switch(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                  u8 ddc_bus ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 122, (void const   *)(& ddc_bus),
                                 1);
  return (tmp);
}
}
static bool psb_intel_sdvo_set_value(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void const   *data , int len ) 
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, (int )cmd, data, len);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  tmp___1 = psb_intel_sdvo_read_response(psb_intel_sdvo, 0, 0);
  return (tmp___1);
}
}
static bool psb_intel_sdvo_get_value(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                     void *value , int len ) 
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  tmp = psb_intel_sdvo_write_cmd(psb_intel_sdvo, (int )cmd, 0, 0);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  tmp___1 = psb_intel_sdvo_read_response(psb_intel_sdvo, value, len);
  return (tmp___1);
}
}
static bool psb_intel_sdvo_set_target_input(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ struct psb_intel_sdvo_set_target_input_args targets ;
  bool tmp ;

  {
  targets.target_1 = 0U;
  targets.pad = (unsigned char)0;
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 16, (void const   *)(& targets),
                                 1);
  return (tmp);
}
}
static bool psb_intel_sdvo_get_trained_inputs(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              bool *input_1 , bool *input_2 ) 
{ struct psb_intel_sdvo_get_trained_inputs_response response ;
  bool tmp ;
  int tmp___0 ;

  {
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 3, (void *)(& response), 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  *input_1 = (int )response.input0_trained != 0;
  *input_2 = (int )response.input1_trained != 0;
  return (1);
}
}
static bool psb_intel_sdvo_set_active_outputs(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              u16 outputs ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 5, (void const   *)(& outputs), 2);
  return (tmp);
}
}
static bool psb_intel_sdvo_get_input_pixel_clock_range(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                       int *clock_min , int *clock_max ) 
{ struct psb_intel_sdvo_pixel_clock_range clocks ;
  bool tmp ;
  int tmp___0 ;

  {
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 29, (void *)(& clocks), 4);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  *clock_min = (int )clocks.min * 10;
  *clock_max = (int )clocks.max * 10;
  return (1);
}
}
static bool psb_intel_sdvo_set_target_output(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             u16 outputs ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 17, (void const   *)(& outputs),
                                 2);
  return (tmp);
}
}
static bool psb_intel_sdvo_set_timing(struct psb_intel_sdvo *psb_intel_sdvo , u8 cmd ,
                                      struct psb_intel_sdvo_dtd *dtd ) 
{ bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )cmd, (void const   *)(& dtd->part1),
                                 8);
  if ((int )tmp) {
    tmp___0 = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )((unsigned int )cmd + 1U),
                                       (void const   *)(& dtd->part2), 8);
    if ((int )tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((bool )tmp___1);
}
}
static bool psb_intel_sdvo_set_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                            struct psb_intel_sdvo_dtd *dtd ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_set_timing(psb_intel_sdvo, 20, dtd);
  return (tmp);
}
}
static bool psb_intel_sdvo_set_output_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             struct psb_intel_sdvo_dtd *dtd ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_set_timing(psb_intel_sdvo, 22, dtd);
  return (tmp);
}
}
static bool psb_intel_sdvo_create_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                         uint16_t clock , uint16_t width ,
                                                         uint16_t height ) 
{ struct psb_intel_sdvo_preferred_input_timing_args args ;
  bool tmp ;

  {
  memset((void *)(& args), 0, 7UL);
  args.clock = clock;
  args.width = width;
  args.height = height;
  args.interlace = 0U;
  if ((int )psb_intel_sdvo->is_lvds && ((psb_intel_sdvo->sdvo_lvds_fixed_mode)->hdisplay != (int )width || (psb_intel_sdvo->sdvo_lvds_fixed_mode)->vdisplay != (int )height)) {
    args.scaled = 1U;
  } else {

  }
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 26, (void const   *)(& args), 7);
  return (tmp);
}
}
static bool psb_intel_sdvo_get_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct psb_intel_sdvo_dtd *dtd ) 
{ bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 27, (void *)(& dtd->part1), 8);
  if ((int )tmp) {
    tmp___0 = psb_intel_sdvo_get_value(psb_intel_sdvo, 28, (void *)(& dtd->part2),
                                       8);
    if ((int )tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((bool )tmp___1);
}
}
static bool psb_intel_sdvo_set_clock_rate_mult(struct psb_intel_sdvo *psb_intel_sdvo ,
                                               u8 val ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 33, (void const   *)(& val), 1);
  return (tmp);
}
}
static void psb_intel_sdvo_get_dtd_from_mode(struct psb_intel_sdvo_dtd *dtd , struct drm_display_mode  const  *mode ) 
{ uint16_t width ;
  uint16_t height ;
  uint16_t h_blank_len ;
  uint16_t h_sync_len ;
  uint16_t v_blank_len ;
  uint16_t v_sync_len ;
  uint16_t h_sync_offset ;
  uint16_t v_sync_offset ;

  {
  width = (uint16_t )mode->crtc_hdisplay;
  height = (uint16_t )mode->crtc_vdisplay;
  h_blank_len = (int )((uint16_t )mode->crtc_hblank_end) - (int )((uint16_t )mode->crtc_hblank_start);
  h_sync_len = (int )((uint16_t )mode->crtc_hsync_end) - (int )((uint16_t )mode->crtc_hsync_start);
  v_blank_len = (int )((uint16_t )mode->crtc_vblank_end) - (int )((uint16_t )mode->crtc_vblank_start);
  v_sync_len = (int )((uint16_t )mode->crtc_vsync_end) - (int )((uint16_t )mode->crtc_vsync_start);
  h_sync_offset = (int )((uint16_t )mode->crtc_hsync_start) - (int )((uint16_t )mode->crtc_hblank_start);
  v_sync_offset = (int )((uint16_t )mode->crtc_vsync_start) - (int )((uint16_t )mode->crtc_vblank_start);
  dtd->part1.clock = (u16 )((int )mode->clock / 10);
  dtd->part1.h_active = (u8 )width;
  dtd->part1.h_blank = (u8 )h_blank_len;
  dtd->part1.h_high = (u8 )((int )((signed char )(((int )width >> 8) << 4)) | ((int )((signed char )((int )h_blank_len >> 8)) & 15));
  dtd->part1.v_active = (u8 )height;
  dtd->part1.v_blank = (u8 )v_blank_len;
  dtd->part1.v_high = (u8 )((int )((signed char )(((int )height >> 8) << 4)) | ((int )((signed char )((int )v_blank_len >> 8)) & 15));
  dtd->part2.h_sync_off = (u8 )h_sync_offset;
  dtd->part2.h_sync_width = (u8 )h_sync_len;
  dtd->part2.v_sync_off_width = (u8 )((int )((signed char )((int )v_sync_offset << 4)) | ((int )((signed char )v_sync_len) & 15));
  dtd->part2.sync_off_width_high = (u8 )((((int )((signed char )(((int )h_sync_offset & 768) >> 2)) | (int )((signed char )(((int )h_sync_len & 768) >> 4))) | (int )((signed char )(((int )v_sync_offset & 48) >> 2))) | (int )((signed char )(((int )v_sync_len & 48) >> 4)));
  dtd->part2.dtd_flags = 24U;
  if ((int )mode->flags & 1) {
    dtd->part2.dtd_flags = (u8 )((unsigned int )dtd->part2.dtd_flags | 2U);
  } else {

  }
  if (((unsigned int )mode->flags & 4U) != 0U) {
    dtd->part2.dtd_flags = (u8 )((unsigned int )dtd->part2.dtd_flags | 4U);
  } else {

  }
  dtd->part2.sdvo_flags = 0U;
  dtd->part2.v_sync_off_high = (unsigned int )((u8 )v_sync_offset) & 192U;
  dtd->part2.reserved = 0U;
  return;
}
}
static void psb_intel_sdvo_get_mode_from_dtd(struct drm_display_mode *mode , struct psb_intel_sdvo_dtd  const  *dtd ) 
{ 

  {
  mode->hdisplay = (int )dtd->part1.h_active;
  mode->hdisplay = mode->hdisplay + ((((int )((unsigned char )dtd->part1.h_high) >> 4) & 15) << 8);
  mode->hsync_start = mode->hdisplay + (int )dtd->part2.h_sync_off;
  mode->hsync_start = mode->hsync_start + (((int )dtd->part2.sync_off_width_high & 192) << 2);
  mode->hsync_end = mode->hsync_start + (int )dtd->part2.h_sync_width;
  mode->hsync_end = mode->hsync_end + (((int )dtd->part2.sync_off_width_high & 48) << 4);
  mode->htotal = mode->hdisplay + (int )dtd->part1.h_blank;
  mode->htotal = mode->htotal + (((int )dtd->part1.h_high & 15) << 8);
  mode->vdisplay = (int )dtd->part1.v_active;
  mode->vdisplay = mode->vdisplay + ((((int )((unsigned char )dtd->part1.v_high) >> 4) & 15) << 8);
  mode->vsync_start = mode->vdisplay;
  mode->vsync_start = mode->vsync_start + (((int )((unsigned char )dtd->part2.v_sync_off_width) >> 4) & 15);
  mode->vsync_start = mode->vsync_start + (((int )dtd->part2.sync_off_width_high & 12) << 2);
  mode->vsync_start = mode->vsync_start + ((int )dtd->part2.v_sync_off_high & 192);
  mode->vsync_end = mode->vsync_start + ((int )dtd->part2.v_sync_off_width & 15);
  mode->vsync_end = mode->vsync_end + (((int )dtd->part2.sync_off_width_high & 3) << 4);
  mode->vtotal = mode->vdisplay + (int )dtd->part1.v_blank;
  mode->vtotal = mode->vtotal + (((int )dtd->part1.v_high & 15) << 8);
  mode->clock = (int )dtd->part1.clock * 10;
  mode->flags = mode->flags & 4294967290U;
  if (((int )dtd->part2.dtd_flags & 2) != 0) {
    mode->flags = mode->flags | 1U;
  } else {

  }
  if (((int )dtd->part2.dtd_flags & 4) != 0) {
    mode->flags = mode->flags | 4U;
  } else {

  }
  return;
}
}
static bool psb_intel_sdvo_check_supp_encode(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ struct psb_intel_sdvo_encode encode ;
  bool tmp ;

  {
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 157, (void *)(& encode), 2);
  return (tmp);
}
}
static bool psb_intel_sdvo_set_encode(struct psb_intel_sdvo *psb_intel_sdvo , uint8_t mode ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 159, (void const   *)(& mode), 1);
  return (tmp);
}
}
static bool psb_intel_sdvo_set_colorimetry(struct psb_intel_sdvo *psb_intel_sdvo ,
                                           uint8_t mode ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_set_value(psb_intel_sdvo, 142, (void const   *)(& mode), 1);
  return (tmp);
}
}
static bool psb_intel_sdvo_set_avi_infoframe(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ 

  {
  printk("\016[drm] HDMI is not supported yet");
  return (0);
}
}
static bool psb_intel_sdvo_set_tv_format(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ struct psb_intel_sdvo_tv_format format ;
  uint32_t format_map ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  void *__ret ;
  bool tmp___0 ;

  {
  format_map = (uint32_t )(1 << psb_intel_sdvo->tv_format_index);
  memset((void *)(& format), 0, 6UL);
  _min1 = 6UL;
  _min2 = 4UL;
  if (_min1 < _min2) {
    tmp = _min1;
  } else {
    tmp = _min2;
  }
  __len = tmp;
  __ret = __builtin_memcpy((void *)(& format), (void const   *)(& format_map), __len);
  tmp___0 = psb_intel_sdvo_set_value(psb_intel_sdvo, 41, (void const   *)(& format),
                                     6);
  return (tmp___0);
}
}
static bool psb_intel_sdvo_set_output_timings_from_mode(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                        struct drm_display_mode  const  *mode ) 
{ struct psb_intel_sdvo_dtd output_dtd ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  tmp = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  psb_intel_sdvo_get_dtd_from_mode(& output_dtd, mode);
  tmp___1 = psb_intel_sdvo_set_output_timing(psb_intel_sdvo, & output_dtd);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (0);
  } else {

  }
  return (1);
}
}
static bool psb_intel_sdvo_set_input_timings_for_mode(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct drm_display_mode  const  *mode ,
                                                      struct drm_display_mode *adjusted_mode ) 
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
  tmp = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  tmp___1 = psb_intel_sdvo_create_preferred_input_timing(psb_intel_sdvo, (int )((uint16_t )((int )mode->clock / 10)),
                                                         (int )((uint16_t )mode->hdisplay),
                                                         (int )((uint16_t )mode->vdisplay));
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (0);
  } else {

  }
  tmp___3 = psb_intel_sdvo_get_preferred_input_timing(psb_intel_sdvo, & psb_intel_sdvo->input_dtd);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    return (0);
  } else {

  }
  psb_intel_sdvo_get_mode_from_dtd(adjusted_mode, (struct psb_intel_sdvo_dtd  const  *)(& psb_intel_sdvo->input_dtd));
  drm_mode_set_crtcinfo(adjusted_mode, 0);
  return (1);
}
}
static bool psb_intel_sdvo_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                      struct drm_display_mode *adjusted_mode ) 
{ struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  int multiplier ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
  tmp = to_psb_intel_sdvo(encoder);
  psb_intel_sdvo = tmp;
  if ((int )psb_intel_sdvo->is_tv) {
    tmp___0 = psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo, mode);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      return (0);
    } else {

    }
    psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo, mode, adjusted_mode);
  } else
  if ((int )psb_intel_sdvo->is_lvds) {
    tmp___2 = psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo, (struct drm_display_mode  const  *)psb_intel_sdvo->sdvo_lvds_fixed_mode);
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      return (0);
    } else {

    }
    psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo, mode, adjusted_mode);
  } else {

  }
  multiplier = psb_intel_sdvo_get_pixel_multiplier(adjusted_mode);
  psb_intel_mode_set_pixel_multiplier(adjusted_mode, multiplier);
  return (1);
}
}
static void psb_intel_sdvo_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  u32 sdvox ;
  struct psb_intel_sdvo_in_out_map in_out ;
  struct psb_intel_sdvo_dtd input_dtd ;
  int pixel_multiplier ;
  int tmp___0 ;
  int rate ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;

  {
  dev = encoder->dev;
  crtc = encoder->crtc;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  tmp = to_psb_intel_sdvo(encoder);
  psb_intel_sdvo = tmp;
  tmp___0 = psb_intel_mode_get_pixel_multiplier((struct drm_display_mode  const  *)adjusted_mode);
  pixel_multiplier = tmp___0;
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
    return;
  } else {

  }
  in_out.in0 = psb_intel_sdvo->attached_output;
  in_out.in1 = 0U;
  psb_intel_sdvo_set_value(psb_intel_sdvo, 7, (void const   *)(& in_out), 4);
  tmp___1 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return;
  } else {

  }
  if ((int )psb_intel_sdvo->is_tv || (int )psb_intel_sdvo->is_lvds) {
    input_dtd = psb_intel_sdvo->input_dtd;
  } else {
    tmp___3 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      return;
    } else {

    }
    psb_intel_sdvo_get_dtd_from_mode(& input_dtd, (struct drm_display_mode  const  *)adjusted_mode);
    psb_intel_sdvo_set_output_timing(psb_intel_sdvo, & input_dtd);
  }
  tmp___5 = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    return;
  } else {

  }
  if ((int )psb_intel_sdvo->has_hdmi_monitor) {
    psb_intel_sdvo_set_encode(psb_intel_sdvo, 1);
    psb_intel_sdvo_set_colorimetry(psb_intel_sdvo, 0);
    psb_intel_sdvo_set_avi_infoframe(psb_intel_sdvo);
  } else {
    psb_intel_sdvo_set_encode(psb_intel_sdvo, 0);
  }
  if ((int )psb_intel_sdvo->is_tv) {
    tmp___7 = psb_intel_sdvo_set_tv_format(psb_intel_sdvo);
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    if (tmp___8) {
      return;
    } else {

    }
  } else {

  }
  psb_intel_sdvo_set_input_timing(psb_intel_sdvo, & input_dtd);
  switch (pixel_multiplier) {
  default: ;
  case 1: 
  rate = 1;
  goto ldv_39555;
  case 2: 
  rate = 2;
  goto ldv_39555;
  case 4: 
  rate = 8;
  goto ldv_39555;
  }
  ldv_39555: 
  tmp___9 = psb_intel_sdvo_set_clock_rate_mult(psb_intel_sdvo, (int )((u8 )rate));
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10) {
    return;
  } else {

  }
  sdvox = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
  switch (psb_intel_sdvo->sdvo_reg) {
  case 397632: 
  sdvox = sdvox & 212992U;
  goto ldv_39559;
  case 397664: 
  sdvox = sdvox & 131072U;
  goto ldv_39559;
  }
  ldv_39559: 
  sdvox = sdvox | 4718720U;
  if (psb_intel_crtc->pipe == 1) {
    sdvox = sdvox | 1073741824U;
  } else {

  }
  if ((int )psb_intel_sdvo->has_hdmi_audio) {
    sdvox = sdvox | 64U;
  } else {

  }
  if ((int )((signed char )input_dtd.part2.sdvo_flags) < 0) {
    sdvox = sdvox | 536870912U;
  } else {

  }
  psb_intel_sdvo_write_sdvox(psb_intel_sdvo, sdvox);
  return;
}
}
static void psb_intel_sdvo_dpms(struct drm_encoder *encoder , int mode ) 
{ struct drm_device *dev ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  u32 temp ;
  bool input1 ;
  bool input2 ;
  int i ;
  u8 status ;
  bool tmp___0 ;
  char *tmp___1 ;

  {
  dev = encoder->dev;
  tmp = to_psb_intel_sdvo(encoder);
  psb_intel_sdvo = tmp;
  switch (mode) {
  case 0: 
  drm_ut_debug_printk(1U, "drm", "psb_intel_sdvo_dpms", "DPMS_ON");
  goto ldv_39570;
  case 3: 
  drm_ut_debug_printk(1U, "drm", "psb_intel_sdvo_dpms", "DPMS_OFF");
  goto ldv_39570;
  default: 
  drm_ut_debug_printk(1U, "drm", "psb_intel_sdvo_dpms", "DPMS: %d", mode);
  }
  ldv_39570: ;
  if (mode != 0) {
    psb_intel_sdvo_set_active_outputs(psb_intel_sdvo, 0);
    if (mode == 3) {
      temp = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
      if ((int )temp < 0) {
        psb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp & 2147483647U);
      } else {

      }
    } else {

    }
  } else {
    temp = REGISTER_READ(dev, (uint32_t )psb_intel_sdvo->sdvo_reg);
    if ((int )temp >= 0) {
      psb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp | 2147483648U);
    } else {

    }
    i = 0;
    goto ldv_39578;
    ldv_39577: 
    psb_intel_wait_for_vblank(dev);
    i = i + 1;
    ldv_39578: ;
    if (i <= 1) {
      goto ldv_39577;
    } else {
      goto ldv_39579;
    }
    ldv_39579: 
    tmp___0 = psb_intel_sdvo_get_trained_inputs(psb_intel_sdvo, & input1, & input2);
    status = (u8 )tmp___0;
    if ((unsigned int )status == 1U && ! input1) {
      if (psb_intel_sdvo->sdvo_reg == 397632) {
        tmp___1 = (char *)"SDVOB";
      } else {
        tmp___1 = (char *)"SDVOC";
      }
      drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_dpms", "First %s output reported failure to sync\n",
                          tmp___1);
    } else {

    }
    psb_intel_sdvo_set_active_outputs(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
  }
  return;
}
}
static int psb_intel_sdvo_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;

  {
  tmp = intel_attached_sdvo(connector);
  psb_intel_sdvo = tmp;
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {

  }
  if (psb_intel_sdvo->pixel_clock_min > mode->clock) {
    return (16);
  } else {

  }
  if (psb_intel_sdvo->pixel_clock_max < mode->clock) {
    return (15);
  } else {

  }
  if ((int )psb_intel_sdvo->is_lvds) {
    if (mode->hdisplay > (psb_intel_sdvo->sdvo_lvds_fixed_mode)->hdisplay) {
      return (29);
    } else {

    }
    if (mode->vdisplay > (psb_intel_sdvo->sdvo_lvds_fixed_mode)->vdisplay) {
      return (29);
    } else {

    }
  } else {

  }
  return (0);
}
}
static bool psb_intel_sdvo_get_capabilities(struct psb_intel_sdvo *psb_intel_sdvo ,
                                            struct psb_intel_sdvo_caps *caps ) 
{ bool tmp ;
  int tmp___0 ;

  {
  tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 2, (void *)caps, 8);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_get_capabilities", "SDVO capabilities:\n  vendor_id: %d\n  device_id: %d\n  device_rev_id: %d\n  sdvo_version_major: %d\n  sdvo_version_minor: %d\n  sdvo_inputs_mask: %d\n  smooth_scaling: %d\n  sharp_scaling: %d\n  up_scaling: %d\n  down_scaling: %d\n  stall_support: %d\n  output_flags: %d\n",
                      (int )caps->vendor_id, (int )caps->device_id, (int )caps->device_rev_id,
                      (int )caps->sdvo_version_major, (int )caps->sdvo_version_minor,
                      (int )caps->sdvo_inputs_mask, (int )caps->smooth_scaling, (int )caps->sharp_scaling,
                      (int )caps->up_scaling, (int )caps->down_scaling, (int )caps->stall_support,
                      (int )caps->output_flags);
  return (1);
}
}
static bool psb_intel_sdvo_multifunc_encoder(struct psb_intel_sdvo *psb_intel_sdvo ) 
{ int caps ;

  {
  caps = (int )psb_intel_sdvo->caps.output_flags & 15;
  return ((- caps & caps) != 0);
}
}
static struct edid *psb_intel_sdvo_get_edid(struct drm_connector *connector ) 
{ struct psb_intel_sdvo *sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct edid *tmp___0 ;

  {
  tmp = intel_attached_sdvo(connector);
  sdvo = tmp;
  tmp___0 = drm_get_edid(connector, & sdvo->ddc);
  return (tmp___0);
}
}
static struct edid *psb_intel_sdvo_get_analog_edid(struct drm_connector *connector ) 
{ struct drm_psb_private *dev_priv ;
  struct edid *tmp ;

  {
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
  tmp = drm_get_edid(connector, & (dev_priv->gmbus + (unsigned long )dev_priv->crt_ddc_pin)->adapter);
  return (tmp);
}
}
static enum drm_connector_status psb_intel_sdvo_hdmi_sink_detect(struct drm_connector *connector ) 
{ struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  enum drm_connector_status status ;
  struct edid *edid ;
  u8 ddc ;
  u8 saved_ddc ;
  bool tmp___0 ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___1 ;

  {
  tmp = intel_attached_sdvo(connector);
  psb_intel_sdvo = tmp;
  edid = psb_intel_sdvo_get_edid(connector);
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
    tmp___0 = psb_intel_sdvo_multifunc_encoder(psb_intel_sdvo);
    if ((int )tmp___0) {
      saved_ddc = psb_intel_sdvo->ddc_bus;
      ddc = (u8 )((int )psb_intel_sdvo->ddc_bus >> 1);
      goto ldv_39612;
      ldv_39611: 
      psb_intel_sdvo->ddc_bus = ddc;
      edid = psb_intel_sdvo_get_edid(connector);
      if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
        goto ldv_39610;
      } else {

      }
      ddc = (u8 )((int )ddc >> 1);
      ldv_39612: ;
      if ((unsigned int )ddc > 1U) {
        goto ldv_39611;
      } else {
        goto ldv_39610;
      }
      ldv_39610: ;
      if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
        psb_intel_sdvo->ddc_bus = saved_ddc;
      } else {

      }
    } else {

    }
  } else {

  }
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
    edid = psb_intel_sdvo_get_analog_edid(connector);
  } else {

  }
  status = 3;
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    if ((int )((signed char )edid->input) < 0) {
      status = 1;
      if ((int )psb_intel_sdvo->is_hdmi) {
        psb_intel_sdvo->has_hdmi_monitor = drm_detect_hdmi_monitor(edid);
        psb_intel_sdvo->has_hdmi_audio = drm_detect_monitor_audio(edid);
      } else {

      }
    } else {
      status = 2;
    }
    kfree((void const   *)edid);
  } else {

  }
  if ((unsigned int )status == 1U) {
    tmp___1 = to_psb_intel_sdvo_connector(connector);
    psb_intel_sdvo_connector = tmp___1;
    if (psb_intel_sdvo_connector->force_audio != 0) {
      psb_intel_sdvo->has_hdmi_audio = psb_intel_sdvo_connector->force_audio > 0;
    } else {

    }
  } else {

  }
  return (status);
}
}
static enum drm_connector_status psb_intel_sdvo_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ uint16_t response ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___0 ;
  enum drm_connector_status ret ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long __ms ;
  unsigned long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  struct edid *edid ;

  {
  tmp = intel_attached_sdvo(connector);
  psb_intel_sdvo = tmp;
  tmp___0 = to_psb_intel_sdvo_connector(connector);
  psb_intel_sdvo_connector = tmp___0;
  tmp___1 = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 11, 0, 0);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (3);
  } else {

  }
  if (((int )psb_intel_sdvo->caps.output_flags & 12) != 0) {
    __ms = 30UL;
    goto ldv_39624;
    ldv_39623: 
    __const_udelay(4295000UL);
    ldv_39624: 
    tmp___3 = __ms;
    __ms = __ms - 1UL;
    if (tmp___3 != 0UL) {
      goto ldv_39623;
    } else {
      goto ldv_39625;
    }
    ldv_39625: ;
  } else {

  }
  tmp___4 = psb_intel_sdvo_read_response(psb_intel_sdvo, (void *)(& response), 2);
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    return (3);
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_detect", "SDVO response %d %d [%x]\n",
                      (int )response & 255, (int )response >> 8, (int )psb_intel_sdvo_connector->output_flag);
  if ((unsigned int )response == 0U) {
    return (2);
  } else {

  }
  psb_intel_sdvo->attached_output = response;
  psb_intel_sdvo->has_hdmi_monitor = 0;
  psb_intel_sdvo->has_hdmi_audio = 0;
  if ((unsigned int )((int )psb_intel_sdvo_connector->output_flag & (int )response) == 0U) {
    ret = 2;
  } else
  if (((int )psb_intel_sdvo_connector->output_flag & 257) != 0) {
    ret = psb_intel_sdvo_hdmi_sink_detect(connector);
  } else {
    edid = psb_intel_sdvo_get_edid(connector);
    if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
      edid = psb_intel_sdvo_get_analog_edid(connector);
    } else {

    }
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
      if ((int )((signed char )edid->input) < 0) {
        ret = 2;
      } else {
        ret = 1;
      }
      kfree((void const   *)edid);
    } else {
      ret = 1;
    }
  }
  if ((unsigned int )ret == 1U) {
    psb_intel_sdvo->is_tv = 0;
    psb_intel_sdvo->is_lvds = 0;
    psb_intel_sdvo->base.needs_tv_clock = 0;
    if (((int )response & 12) != 0) {
      psb_intel_sdvo->is_tv = 1;
      psb_intel_sdvo->base.needs_tv_clock = 1;
    } else {

    }
    if (((int )response & 16448) != 0) {
      psb_intel_sdvo->is_lvds = (unsigned long )psb_intel_sdvo->sdvo_lvds_fixed_mode != (unsigned long )((struct drm_display_mode *)0);
    } else {

    }
  } else {

  }
  return (ret);
}
}
static void psb_intel_sdvo_get_ddc_modes(struct drm_connector *connector ) 
{ struct edid *edid ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;
  bool monitor_is_digital ;
  bool connector_is_digital ;

  {
  edid = psb_intel_sdvo_get_edid(connector);
  if ((unsigned long )edid == (unsigned long )((struct edid *)0)) {
    edid = psb_intel_sdvo_get_analog_edid(connector);
  } else {

  }
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    tmp = to_psb_intel_sdvo_connector(connector);
    psb_intel_sdvo_connector = tmp;
    monitor_is_digital = (int )((signed char )edid->input) < 0;
    connector_is_digital = ((int )psb_intel_sdvo_connector->output_flag & 257) != 0;
    if ((int )connector_is_digital == (int )monitor_is_digital) {
      drm_mode_connector_update_edid_property(connector, edid);
      drm_add_edid_modes(connector, edid);
    } else {

    }
    kfree((void const   *)edid);
  } else {

  }
  return;
}
}
static struct drm_display_mode  const  sdvo_tv_modes[19U]  = 
  {      {{0, 0}, {0U, 3739147998U, 0}, {'3', '2', '0', 'x', '2', '0', '0', '\000'}, 0,
      64U, 5815, 320, 321, 384, 416, 0, 200, 201, 232, 233, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'3', '2', '0', 'x', '2', '4', '0', '\000'}, 0,
      64U, 6814, 320, 321, 384, 416, 0, 240, 241, 272, 273, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'4', '0', '0', 'x', '3', '0', '0', '\000'}, 0,
      64U, 9910, 400, 401, 464, 496, 0, 300, 301, 332, 333, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '3', '5', '0', '\000'}, 0,
      64U, 16913, 640, 641, 704, 736, 0, 350, 351, 382, 383, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '4', '0', '0', '\000'}, 0,
      64U, 19121, 640, 641, 704, 736, 0, 400, 401, 432, 433, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'6', '4', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 22654, 640, 641, 704, 736, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '0', '4', 'x', '4', '8', '0', '\000'}, 0,
      64U, 24624, 704, 705, 768, 800, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '0', '4', 'x', '5', '7', '6', '\000'}, 0,
      64U, 29232, 704, 705, 768, 800, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '3', '5', '0', '\000'}, 0,
      64U, 18751, 720, 721, 784, 816, 0, 350, 351, 382, 383, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '4', '0', '0', '\000'}, 0,
      64U, 21199, 720, 721, 784, 816, 0, 400, 401, 432, 433, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 25116, 720, 721, 784, 816, 0, 480, 481, 512, 513, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '5', '4', '0', '\000'}, 0,
      64U, 28054, 720, 721, 784, 816, 0, 540, 541, 572, 573, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '2', '0', 'x', '5', '7', '6', '\000'}, 0,
      64U, 29816, 720, 721, 784, 816, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'7', '6', '8', 'x', '5', '7', '6', '\000'}, 0,
      64U, 31570, 768, 769, 832, 864, 0, 576, 577, 608, 609, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '0', '0', 'x', '6', '0', '0', '\000'}, 0,
      64U, 34030, 800, 801, 864, 896, 0, 600, 601, 632, 633, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '3', '2', 'x', '6', '2', '4', '\000'}, 0,
      64U, 36581, 832, 833, 896, 928, 0, 624, 625, 656, 657, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'9', '2', '0', 'x', '7', '6', '6', '\000'}, 0,
      64U, 48707, 920, 921, 984, 1016, 0, 766, 767, 798, 799, 0, 5U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '7', '6', '8', '\000'},
      0, 64U, 53827, 1024, 1025, 1088, 1120, 0, 768, 769, 800, 801, 0, 5U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '2', '8', '0', 'x', '1', '0', '2', '4',
                                     '\000'}, 0, 64U, 87265, 1280, 1281, 1344, 1376,
      0, 1024, 1025, 1056, 1057, 0, 5U, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0}};
static void psb_intel_sdvo_get_tv_modes(struct drm_connector *connector ) 
{ struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_sdtv_resolution_request tv_res ;
  uint32_t reply ;
  uint32_t format_map ;
  int i ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp___0 ;
  void *__ret ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  struct drm_display_mode *nmode ;

  {
  tmp = intel_attached_sdvo(connector);
  psb_intel_sdvo = tmp;
  reply = 0U;
  format_map = 0U;
  format_map = (uint32_t )(1 << psb_intel_sdvo->tv_format_index);
  _min1 = 4UL;
  _min2 = 3UL;
  if (_min1 < _min2) {
    tmp___0 = _min1;
  } else {
    tmp___0 = _min2;
  }
  __len = tmp___0;
  __ret = __builtin_memcpy((void *)(& tv_res), (void const   *)(& format_map), __len);
  tmp___1 = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )psb_intel_sdvo->attached_output);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return;
  } else {

  }
  tmp___3 = psb_intel_sdvo_write_cmd(psb_intel_sdvo, 131, (void const   *)(& tv_res),
                                     3);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    return;
  } else {

  }
  tmp___5 = psb_intel_sdvo_read_response(psb_intel_sdvo, (void *)(& reply), 3);
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    return;
  } else {

  }
  i = 0;
  goto ldv_39657;
  ldv_39656: ;
  if (((uint32_t )(1 << i) & reply) != 0U) {
    nmode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)(& sdvo_tv_modes) + (unsigned long )i);
    if ((unsigned long )nmode != (unsigned long )((struct drm_display_mode *)0)) {
      drm_mode_probed_add(connector, nmode);
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_39657: ;
  if ((unsigned int )i <= 18U) {
    goto ldv_39656;
  } else {
    goto ldv_39658;
  }
  ldv_39658: ;
  return;
}
}
static void psb_intel_sdvo_get_lvds_modes(struct drm_connector *connector ) 
{ struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *newmode ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  tmp = intel_attached_sdvo(connector);
  psb_intel_sdvo = tmp;
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
  psb_intel_ddc_get_modes(connector, psb_intel_sdvo->i2c);
  tmp___0 = list_empty((struct list_head  const  *)(& connector->probed_modes));
  if (tmp___0 == 0) {
    goto end;
  } else {

  }
  if ((unsigned long )dev_priv->sdvo_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
    newmode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)dev_priv->sdvo_lvds_vbt_mode);
    if ((unsigned long )newmode != (unsigned long )((struct drm_display_mode *)0)) {
      newmode->type = 72U;
      drm_mode_probed_add(connector, newmode);
    } else {

    }
  } else {

  }
  end: 
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
  newmode = (struct drm_display_mode *)__mptr;
  goto ldv_39672;
  ldv_39671: ;
  if ((newmode->type & 8U) != 0U) {
    psb_intel_sdvo->sdvo_lvds_fixed_mode = drm_mode_duplicate(connector->dev, (struct drm_display_mode  const  *)newmode);
    drm_mode_set_crtcinfo(psb_intel_sdvo->sdvo_lvds_fixed_mode, 0);
    psb_intel_sdvo->is_lvds = 1;
    goto ldv_39670;
  } else {

  }
  __mptr___0 = (struct list_head  const  *)newmode->head.next;
  newmode = (struct drm_display_mode *)__mptr___0;
  ldv_39672: ;
  if ((unsigned long )(& newmode->head) != (unsigned long )(& connector->probed_modes)) {
    goto ldv_39671;
  } else {
    goto ldv_39670;
  }
  ldv_39670: ;
  return;
}
}
static int psb_intel_sdvo_get_modes(struct drm_connector *connector ) 
{ struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;
  int tmp___0 ;

  {
  tmp = to_psb_intel_sdvo_connector(connector);
  psb_intel_sdvo_connector = tmp;
  if (((int )psb_intel_sdvo_connector->output_flag & 12) != 0) {
    psb_intel_sdvo_get_tv_modes(connector);
  } else
  if (((int )psb_intel_sdvo_connector->output_flag & 16448) != 0) {
    psb_intel_sdvo_get_lvds_modes(connector);
  } else {
    psb_intel_sdvo_get_ddc_modes(connector);
  }
  tmp___0 = list_empty((struct list_head  const  *)(& connector->probed_modes));
  return (tmp___0 == 0);
}
}
static void psb_intel_sdvo_destroy_enhance_property(struct drm_connector *connector ) 
{ struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;
  struct drm_device *dev ;

  {
  tmp = to_psb_intel_sdvo_connector(connector);
  psb_intel_sdvo_connector = tmp;
  dev = connector->dev;
  if ((unsigned long )psb_intel_sdvo_connector->left != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->left);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->right != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->right);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->top != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->top);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->bottom != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->bottom);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->hpos != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->hpos);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->vpos != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->vpos);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->saturation != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->saturation);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->contrast != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->contrast);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->hue != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->hue);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->sharpness != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->sharpness);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->flicker_filter != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_2d != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter_2d);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_adaptive != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter_adaptive);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->tv_luma_filter != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->tv_luma_filter);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->tv_chroma_filter != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->tv_chroma_filter);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->dot_crawl != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->dot_crawl);
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->brightness != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(dev, psb_intel_sdvo_connector->brightness);
  } else {

  }
  return;
}
}
static void psb_intel_sdvo_destroy(struct drm_connector *connector ) 
{ struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp ;

  {
  tmp = to_psb_intel_sdvo_connector(connector);
  psb_intel_sdvo_connector = tmp;
  if ((unsigned long )psb_intel_sdvo_connector->tv_format != (unsigned long )((struct drm_property *)0)) {
    drm_property_destroy(connector->dev, psb_intel_sdvo_connector->tv_format);
  } else {

  }
  psb_intel_sdvo_destroy_enhance_property(connector);
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const   *)connector);
  return;
}
}
static bool psb_intel_sdvo_detect_hdmi_audio(struct drm_connector *connector ) 
{ struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct edid *edid ;
  bool has_audio ;

  {
  tmp = intel_attached_sdvo(connector);
  psb_intel_sdvo = tmp;
  has_audio = 0;
  if (! psb_intel_sdvo->is_hdmi) {
    return (0);
  } else {

  }
  edid = psb_intel_sdvo_get_edid(connector);
  if ((unsigned long )edid != (unsigned long )((struct edid *)0) && (int )((signed char )edid->input) < 0) {
    has_audio = drm_detect_monitor_audio(edid);
  } else {

  }
  return (has_audio);
}
}
static int psb_intel_sdvo_set_property(struct drm_connector *connector , struct drm_property *property ,
                                       uint64_t val ) 
{ struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  struct psb_intel_sdvo_connector *tmp___0 ;
  struct drm_psb_private *dev_priv ;
  uint16_t temp_value ;
  uint8_t cmd ;
  int ret ;
  int i ;
  bool has_audio ;
  bool tmp___1 ;
  int tmp___2 ;
  struct drm_crtc *crtc ;

  {
  tmp = intel_attached_sdvo(connector);
  psb_intel_sdvo = tmp;
  tmp___0 = to_psb_intel_sdvo_connector(connector);
  psb_intel_sdvo_connector = tmp___0;
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
  ret = drm_object_property_set_value(& connector->base, property, val);
  if (ret != 0) {
    return (ret);
  } else {

  }
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
    i = (int )val;
    if (psb_intel_sdvo_connector->force_audio == i) {
      return (0);
    } else {

    }
    psb_intel_sdvo_connector->force_audio = i;
    if (i == 0) {
      has_audio = psb_intel_sdvo_detect_hdmi_audio(connector);
    } else {
      has_audio = i > 0;
    }
    if ((int )psb_intel_sdvo->has_hdmi_audio == (int )has_audio) {
      return (0);
    } else {

    }
    psb_intel_sdvo->has_hdmi_audio = has_audio;
    goto done;
  } else {

  }
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
    if ((uint64_t )(psb_intel_sdvo->color_range != 0U) == val) {
      return (0);
    } else {

    }
    if (val != 0ULL) {
      psb_intel_sdvo->color_range = 256U;
    } else {
      psb_intel_sdvo->color_range = 0U;
    }
    goto done;
  } else {

  }
  if ((unsigned long )psb_intel_sdvo_connector->tv_format == (unsigned long )property) {
    if (val > 18ULL) {
      return (-22);
    } else {

    }
    if (psb_intel_sdvo->tv_format_index == (int )psb_intel_sdvo_connector->tv_format_supported[val]) {
      return (0);
    } else {

    }
    psb_intel_sdvo->tv_format_index = (int )psb_intel_sdvo_connector->tv_format_supported[val];
    goto done;
  } else
  if (((int )psb_intel_sdvo_connector->output_flag & 16460) != 0) {
    temp_value = (uint16_t )val;
    if ((unsigned long )psb_intel_sdvo_connector->left == (unsigned long )property) {
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->right,
                                    val);
      if (psb_intel_sdvo_connector->left_margin == (u32 )temp_value) {
        return (0);
      } else {

      }
      psb_intel_sdvo_connector->left_margin = (u32 )temp_value;
      psb_intel_sdvo_connector->right_margin = (u32 )temp_value;
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_hscan) - (int )((uint16_t )psb_intel_sdvo_connector->left_margin);
      cmd = 99U;
      goto set_value;
    } else
    if ((unsigned long )psb_intel_sdvo_connector->right == (unsigned long )property) {
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->left,
                                    val);
      if (psb_intel_sdvo_connector->right_margin == (u32 )temp_value) {
        return (0);
      } else {

      }
      psb_intel_sdvo_connector->left_margin = (u32 )temp_value;
      psb_intel_sdvo_connector->right_margin = (u32 )temp_value;
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_hscan) - (int )((uint16_t )psb_intel_sdvo_connector->left_margin);
      cmd = 99U;
      goto set_value;
    } else
    if ((unsigned long )psb_intel_sdvo_connector->top == (unsigned long )property) {
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->bottom,
                                    val);
      if (psb_intel_sdvo_connector->top_margin == (u32 )temp_value) {
        return (0);
      } else {

      }
      psb_intel_sdvo_connector->top_margin = (u32 )temp_value;
      psb_intel_sdvo_connector->bottom_margin = (u32 )temp_value;
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_vscan) - (int )((uint16_t )psb_intel_sdvo_connector->top_margin);
      cmd = 102U;
      goto set_value;
    } else
    if ((unsigned long )psb_intel_sdvo_connector->bottom == (unsigned long )property) {
      drm_object_property_set_value(& connector->base, psb_intel_sdvo_connector->top,
                                    val);
      if (psb_intel_sdvo_connector->bottom_margin == (u32 )temp_value) {
        return (0);
      } else {

      }
      psb_intel_sdvo_connector->top_margin = (u32 )temp_value;
      psb_intel_sdvo_connector->bottom_margin = (u32 )temp_value;
      temp_value = (int )((uint16_t )psb_intel_sdvo_connector->max_vscan) - (int )((uint16_t )psb_intel_sdvo_connector->top_margin);
      cmd = 102U;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->hpos == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_hpos == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_hpos < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 105U;
      psb_intel_sdvo_connector->cur_hpos = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->vpos == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_vpos == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_vpos < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 108U;
      psb_intel_sdvo_connector->cur_vpos = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->saturation == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_saturation == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_saturation < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 87U;
      psb_intel_sdvo_connector->cur_saturation = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->contrast == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_contrast == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_contrast < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 96U;
      psb_intel_sdvo_connector->cur_contrast = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->hue == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_hue == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_hue < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 90U;
      psb_intel_sdvo_connector->cur_hue = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_brightness == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_brightness < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 93U;
      psb_intel_sdvo_connector->cur_brightness = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->sharpness == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_sharpness == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_sharpness < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 111U;
      psb_intel_sdvo_connector->cur_sharpness = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_flicker_filter == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_flicker_filter < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 79U;
      psb_intel_sdvo_connector->cur_flicker_filter = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_2d == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_flicker_filter_2d == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_flicker_filter_2d < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 84U;
      psb_intel_sdvo_connector->cur_flicker_filter_2d = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_adaptive == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_flicker_filter_adaptive == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_flicker_filter_adaptive < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 81U;
      psb_intel_sdvo_connector->cur_flicker_filter_adaptive = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->tv_chroma_filter == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_tv_chroma_filter == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_tv_chroma_filter < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 118U;
      psb_intel_sdvo_connector->cur_tv_chroma_filter = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->tv_luma_filter == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_tv_luma_filter == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_tv_luma_filter < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 121U;
      psb_intel_sdvo_connector->cur_tv_luma_filter = (u32 )temp_value;
      goto set_value;
    } else {

    }
    if ((unsigned long )psb_intel_sdvo_connector->dot_crawl == (unsigned long )property) {
      if (psb_intel_sdvo_connector->cur_dot_crawl == (u32 )temp_value) {
        return (0);
      } else {

      }
      if (psb_intel_sdvo_connector->max_dot_crawl < (u32 )temp_value) {
        return (-22);
      } else {

      }
      cmd = 113U;
      psb_intel_sdvo_connector->cur_dot_crawl = (u32 )temp_value;
      goto set_value;
    } else {

    }
  } else {

  }
  return (-22);
  set_value: 
  tmp___1 = psb_intel_sdvo_set_value(psb_intel_sdvo, (int )cmd, (void const   *)(& temp_value),
                                     2);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (-5);
  } else {

  }
  done: ;
  if ((unsigned long )psb_intel_sdvo->base.base.crtc != (unsigned long )((struct drm_crtc *)0)) {
    crtc = psb_intel_sdvo->base.base.crtc;
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, crtc->fb);
  } else {

  }
  return (0);
}
}
static struct drm_encoder_helper_funcs  const  psb_intel_sdvo_helper_funcs  = 
     {& psb_intel_sdvo_dpms, 0, 0, & psb_intel_sdvo_mode_fixup, & psb_intel_encoder_prepare,
    & psb_intel_encoder_commit, & psb_intel_sdvo_mode_set, 0, 0, 0};
static struct drm_connector_funcs  const  psb_intel_sdvo_connector_funcs  = 
     {& drm_helper_connector_dpms, 0, 0, 0, & psb_intel_sdvo_detect, & drm_helper_probe_single_connector_modes,
    & psb_intel_sdvo_set_property, & psb_intel_sdvo_destroy, 0};
static struct drm_connector_helper_funcs  const  psb_intel_sdvo_connector_helper_funcs  =    {& psb_intel_sdvo_get_modes,
    & psb_intel_sdvo_mode_valid, & psb_intel_best_encoder};
static void psb_intel_sdvo_enc_destroy(struct drm_encoder *encoder ) 
{ struct psb_intel_sdvo *psb_intel_sdvo ;
  struct psb_intel_sdvo *tmp ;

  {
  tmp = to_psb_intel_sdvo(encoder);
  psb_intel_sdvo = tmp;
  if ((unsigned long )psb_intel_sdvo->sdvo_lvds_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    drm_mode_destroy(encoder->dev, psb_intel_sdvo->sdvo_lvds_fixed_mode);
  } else {

  }
  i2c_del_adapter(& psb_intel_sdvo->ddc);
  psb_intel_encoder_destroy(encoder);
  return;
}
}
static struct drm_encoder_funcs  const  psb_intel_sdvo_enc_funcs  =    {0, & psb_intel_sdvo_enc_destroy};
static void psb_intel_sdvo_guess_ddc_bus(struct psb_intel_sdvo *sdvo ) 
{ 

  {
  sdvo->ddc_bus = 2U;
  return;
}
}
static void psb_intel_sdvo_select_ddc_bus(struct drm_psb_private *dev_priv , struct psb_intel_sdvo *sdvo ,
                                          u32 reg ) 
{ struct sdvo_device_mapping *mapping ;

  {
  if (reg == 397632U) {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  }
  if ((unsigned int )mapping->initialized != 0U) {
    sdvo->ddc_bus = (uint8_t )(1 << ((int )mapping->ddc_pin >> 4));
  } else {
    psb_intel_sdvo_guess_ddc_bus(sdvo);
  }
  return;
}
}
static void psb_intel_sdvo_select_i2c_bus(struct drm_psb_private *dev_priv , struct psb_intel_sdvo *sdvo ,
                                          u32 reg ) 
{ struct sdvo_device_mapping *mapping ;
  u8 pin ;
  u8 speed ;

  {
  if (reg == 397632U) {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  } else {
    mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  }
  pin = 5U;
  speed = 3U;
  if ((unsigned int )mapping->initialized != 0U) {
    pin = mapping->i2c_pin;
    speed = mapping->i2c_speed;
  } else {

  }
  if ((unsigned int )pin <= 7U) {
    sdvo->i2c = & (dev_priv->gmbus + (unsigned long )pin)->adapter;
    gma_intel_gmbus_set_speed(sdvo->i2c, (int )speed);
    gma_intel_gmbus_force_bit(sdvo->i2c, 1);
  } else {
    sdvo->i2c = & (dev_priv->gmbus + 5UL)->adapter;
  }
  return;
}
}
static bool psb_intel_sdvo_is_hdmi_connector(struct psb_intel_sdvo *psb_intel_sdvo ,
                                             int device ) 
{ bool tmp ;

  {
  tmp = psb_intel_sdvo_check_supp_encode(psb_intel_sdvo);
  return (tmp);
}
}
static u8 psb_intel_sdvo_get_slave_addr(struct drm_device *dev , int sdvo_reg ) 
{ struct drm_psb_private *dev_priv ;
  struct sdvo_device_mapping *my_mapping ;
  struct sdvo_device_mapping *other_mapping ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (sdvo_reg == 397632) {
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
  } else {
    my_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings) + 1UL;
    other_mapping = (struct sdvo_device_mapping *)(& dev_priv->sdvo_mappings);
  }
  if ((unsigned int )my_mapping->slave_addr != 0U) {
    return (my_mapping->slave_addr);
  } else {

  }
  if ((unsigned int )other_mapping->slave_addr != 0U) {
    if ((unsigned int )other_mapping->slave_addr == 112U) {
      return (114U);
    } else {
      return (112U);
    }
  } else {

  }
  if (sdvo_reg == 397632) {
    return (112U);
  } else {
    return (114U);
  }
}
}
static void psb_intel_sdvo_connector_init(struct psb_intel_sdvo_connector *connector ,
                                          struct psb_intel_sdvo *encoder ) 
{ 

  {
  drm_connector_init(encoder->base.base.dev, & connector->base.base, & psb_intel_sdvo_connector_funcs,
                     connector->base.base.connector_type);
  drm_connector_helper_add(& connector->base.base, & psb_intel_sdvo_connector_helper_funcs);
  connector->base.base.interlace_allowed = 0;
  connector->base.base.doublescan_allowed = 0;
  connector->base.base.display_info.subpixel_order = 1;
  psb_intel_connector_attach_encoder(& connector->base, & encoder->base);
  drm_sysfs_connector_add(& connector->base.base);
  return;
}
}
static void psb_intel_sdvo_add_hdmi_properties(struct psb_intel_sdvo_connector *connector ) 
{ 

  {
  return;
}
}
static bool psb_intel_sdvo_dvi_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct psb_intel_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;

  {
  encoder = & psb_intel_sdvo->base.base;
  tmp = kzalloc(2168UL, 208U);
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
    return (0);
  } else {

  }
  if (device == 0) {
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 1U);
    psb_intel_sdvo_connector->output_flag = 1U;
  } else
  if (device == 1) {
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 256U);
    psb_intel_sdvo_connector->output_flag = 256U;
  } else {

  }
  intel_connector = & psb_intel_sdvo_connector->base;
  connector = & intel_connector->base;
  encoder->encoder_type = 2;
  connector->connector_type = 3;
  tmp___0 = psb_intel_sdvo_is_hdmi_connector(psb_intel_sdvo, device);
  if ((int )tmp___0) {
    connector->connector_type = 11;
    psb_intel_sdvo->is_hdmi = 1;
  } else {

  }
  psb_intel_sdvo->base.clone_mask = 576;
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
  if ((int )psb_intel_sdvo->is_hdmi) {
    psb_intel_sdvo_add_hdmi_properties(psb_intel_sdvo_connector);
  } else {

  }
  return (1);
}
}
static bool psb_intel_sdvo_tv_init(struct psb_intel_sdvo *psb_intel_sdvo , int type ) 
{ struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct psb_intel_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
  encoder = & psb_intel_sdvo->base.base;
  tmp = kzalloc(2168UL, 208U);
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
    return (0);
  } else {

  }
  intel_connector = & psb_intel_sdvo_connector->base;
  connector = & intel_connector->base;
  encoder->encoder_type = 4;
  connector->connector_type = 6;
  psb_intel_sdvo->controlled_output = (uint16_t )((int )((short )psb_intel_sdvo->controlled_output) | (int )((short )type));
  psb_intel_sdvo_connector->output_flag = (uint16_t )type;
  psb_intel_sdvo->is_tv = 1;
  psb_intel_sdvo->base.needs_tv_clock = 1;
  psb_intel_sdvo->base.clone_mask = 128;
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
  tmp___0 = psb_intel_sdvo_tv_create_property(psb_intel_sdvo, psb_intel_sdvo_connector,
                                              type);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto err;
  } else {

  }
  tmp___2 = psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto err;
  } else {

  }
  return (1);
  err: 
  psb_intel_sdvo_destroy(connector);
  return (0);
}
}
static bool psb_intel_sdvo_analog_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct psb_intel_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;

  {
  encoder = & psb_intel_sdvo->base.base;
  tmp = kzalloc(2168UL, 208U);
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
    return (0);
  } else {

  }
  intel_connector = & psb_intel_sdvo_connector->base;
  connector = & intel_connector->base;
  connector->polled = 2U;
  encoder->encoder_type = 1;
  connector->connector_type = 1;
  if (device == 0) {
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 2U);
    psb_intel_sdvo_connector->output_flag = 2U;
  } else
  if (device == 1) {
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 512U);
    psb_intel_sdvo_connector->output_flag = 512U;
  } else {

  }
  psb_intel_sdvo->base.clone_mask = 576;
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
  return (1);
}
}
static bool psb_intel_sdvo_lvds_init(struct psb_intel_sdvo *psb_intel_sdvo , int device ) 
{ struct drm_encoder *encoder ;
  struct drm_connector *connector ;
  struct psb_intel_connector *intel_connector ;
  struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  encoder = & psb_intel_sdvo->base.base;
  tmp = kzalloc(2168UL, 208U);
  psb_intel_sdvo_connector = (struct psb_intel_sdvo_connector *)tmp;
  if ((unsigned long )psb_intel_sdvo_connector == (unsigned long )((struct psb_intel_sdvo_connector *)0)) {
    return (0);
  } else {

  }
  intel_connector = & psb_intel_sdvo_connector->base;
  connector = & intel_connector->base;
  encoder->encoder_type = 3;
  connector->connector_type = 7;
  if (device == 0) {
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 64U);
    psb_intel_sdvo_connector->output_flag = 64U;
  } else
  if (device == 1) {
    psb_intel_sdvo->controlled_output = (uint16_t )((unsigned int )psb_intel_sdvo->controlled_output | 16384U);
    psb_intel_sdvo_connector->output_flag = 16384U;
  } else {

  }
  psb_intel_sdvo->base.clone_mask = 768;
  psb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);
  tmp___0 = psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto err;
  } else {

  }
  return (1);
  err: 
  psb_intel_sdvo_destroy(connector);
  return (0);
}
}
static bool psb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo , uint16_t flags ) 
{ bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  unsigned char bytes[2U] ;
  size_t __len ;
  void *__ret ;
  char *tmp___15 ;

  {
  psb_intel_sdvo->is_tv = 0;
  psb_intel_sdvo->base.needs_tv_clock = 0;
  psb_intel_sdvo->is_lvds = 0;
  if ((int )flags & 1) {
    tmp = psb_intel_sdvo_dvi_init(psb_intel_sdvo, 0);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      return (0);
    } else {

    }
  } else {

  }
  if (((int )flags & 257) == 257) {
    tmp___1 = psb_intel_sdvo_dvi_init(psb_intel_sdvo, 1);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      return (0);
    } else {

    }
  } else {

  }
  if (((int )flags & 8) != 0) {
    tmp___3 = psb_intel_sdvo_tv_init(psb_intel_sdvo, 8);
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      return (0);
    } else {

    }
  } else {

  }
  if (((int )flags & 4) != 0) {
    tmp___5 = psb_intel_sdvo_tv_init(psb_intel_sdvo, 4);
    if (tmp___5) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
    if (tmp___6) {
      return (0);
    } else {

    }
  } else {

  }
  if (((int )flags & 2) != 0) {
    tmp___7 = psb_intel_sdvo_analog_init(psb_intel_sdvo, 0);
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    if (tmp___8) {
      return (0);
    } else {

    }
  } else {

  }
  if (((int )flags & 514) == 514) {
    tmp___9 = psb_intel_sdvo_analog_init(psb_intel_sdvo, 1);
    if (tmp___9) {
      tmp___10 = 0;
    } else {
      tmp___10 = 1;
    }
    if (tmp___10) {
      return (0);
    } else {

    }
  } else {

  }
  if (((int )flags & 64) != 0) {
    tmp___11 = psb_intel_sdvo_lvds_init(psb_intel_sdvo, 0);
    if (tmp___11) {
      tmp___12 = 0;
    } else {
      tmp___12 = 1;
    }
    if (tmp___12) {
      return (0);
    } else {

    }
  } else {

  }
  if (((int )flags & 16448) == 16448) {
    tmp___13 = psb_intel_sdvo_lvds_init(psb_intel_sdvo, 1);
    if (tmp___13) {
      tmp___14 = 0;
    } else {
      tmp___14 = 1;
    }
    if (tmp___14) {
      return (0);
    } else {

    }
  } else {

  }
  if (((int )flags & 17231) == 0) {
    psb_intel_sdvo->controlled_output = 0U;
    __len = 2UL;
    if (__len > 63UL) {
      __ret = __memcpy((void *)(& bytes), (void const   *)(& psb_intel_sdvo->caps.output_flags),
                       __len);
    } else {
      __ret = __builtin_memcpy((void *)(& bytes), (void const   *)(& psb_intel_sdvo->caps.output_flags),
                               __len);
    }
    if (psb_intel_sdvo->sdvo_reg == 397632) {
      tmp___15 = (char *)"SDVOB";
    } else {
      tmp___15 = (char *)"SDVOC";
    }
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_output_setup", "%s: Unknown SDVO output type (0x%02x%02x)\n",
                        tmp___15, (int )bytes[0], (int )bytes[1]);
    return (0);
  } else {

  }
  psb_intel_sdvo->base.crtc_mask = 3;
  return (1);
}
}
static bool psb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                              struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                              int type ) 
{ struct drm_device *dev ;
  struct psb_intel_sdvo_tv_format format ;
  uint32_t format_map ;
  uint32_t i ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  unsigned long tmp___3 ;
  void *__ret ;
  int tmp___4 ;

  {
  dev = psb_intel_sdvo->base.base.dev;
  tmp = psb_intel_sdvo_set_target_output(psb_intel_sdvo, (int )((u16 )type));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 39, (void *)(& format), 6);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (0);
  } else {

  }
  _min1 = 4UL;
  _min2 = 6UL;
  if (_min1 < _min2) {
    tmp___3 = _min1;
  } else {
    tmp___3 = _min2;
  }
  __len = tmp___3;
  __ret = __builtin_memcpy((void *)(& format_map), (void const   *)(& format), __len);
  if (format_map == 0U) {
    return (0);
  } else {

  }
  psb_intel_sdvo_connector->format_supported_num = 0;
  i = 0U;
  goto ldv_39813;
  ldv_39812: ;
  if (((uint32_t )(1 << (int )i) & format_map) != 0U) {
    tmp___4 = psb_intel_sdvo_connector->format_supported_num;
    psb_intel_sdvo_connector->format_supported_num = psb_intel_sdvo_connector->format_supported_num + 1;
    psb_intel_sdvo_connector->tv_format_supported[tmp___4] = (u8 )i;
  } else {

  }
  i = i + 1U;
  ldv_39813: ;
  if (i <= 18U) {
    goto ldv_39812;
  } else {
    goto ldv_39814;
  }
  ldv_39814: 
  psb_intel_sdvo_connector->tv_format = drm_property_create(dev, 8, "mode", psb_intel_sdvo_connector->format_supported_num);
  if ((unsigned long )psb_intel_sdvo_connector->tv_format == (unsigned long )((struct drm_property *)0)) {
    return (0);
  } else {

  }
  i = 0U;
  goto ldv_39816;
  ldv_39815: 
  drm_property_add_enum(psb_intel_sdvo_connector->tv_format, (int )i, (uint64_t )i,
                        tv_format_names[(int )psb_intel_sdvo_connector->tv_format_supported[i]]);
  i = i + 1U;
  ldv_39816: ;
  if ((uint32_t )psb_intel_sdvo_connector->format_supported_num > i) {
    goto ldv_39815;
  } else {
    goto ldv_39817;
  }
  ldv_39817: 
  psb_intel_sdvo->tv_format_index = (int )psb_intel_sdvo_connector->tv_format_supported[0];
  drm_object_attach_property(& psb_intel_sdvo_connector->base.base.base, psb_intel_sdvo_connector->tv_format,
                             0ULL);
  return (1);
}
}
static bool psb_intel_sdvo_create_enhance_property_tv(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                      struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                                      struct psb_intel_sdvo_enhancements_reply enhancements ) 
{ struct drm_device *dev ;
  struct drm_connector *connector ;
  uint16_t response ;
  uint16_t data_value[2U] ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;
  int tmp___16 ;
  bool tmp___17 ;
  int tmp___18 ;
  bool tmp___19 ;
  int tmp___20 ;
  bool tmp___21 ;
  int tmp___22 ;
  bool tmp___23 ;
  int tmp___24 ;
  bool tmp___25 ;
  int tmp___26 ;
  bool tmp___27 ;
  int tmp___28 ;
  bool tmp___29 ;
  int tmp___30 ;
  bool tmp___31 ;
  int tmp___32 ;
  bool tmp___33 ;
  int tmp___34 ;
  bool tmp___35 ;
  int tmp___36 ;
  bool tmp___37 ;
  int tmp___38 ;
  bool tmp___39 ;
  int tmp___40 ;
  bool tmp___41 ;
  int tmp___42 ;
  bool tmp___43 ;
  int tmp___44 ;
  bool tmp___45 ;
  int tmp___46 ;
  bool tmp___47 ;
  int tmp___48 ;
  bool tmp___49 ;
  int tmp___50 ;
  bool tmp___51 ;
  int tmp___52 ;
  bool tmp___53 ;
  int tmp___54 ;
  bool tmp___55 ;
  int tmp___56 ;

  {
  dev = psb_intel_sdvo->base.base.dev;
  connector = & psb_intel_sdvo_connector->base.base;
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 97, (void *)(& data_value), 4);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      return (0);
    } else {

    }
    tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 98, (void *)(& response), 2);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      return (0);
    } else {

    }
    psb_intel_sdvo_connector->max_hscan = (u32 )data_value[0];
    psb_intel_sdvo_connector->left_margin = (u32 )((int )data_value[0] - (int )response);
    psb_intel_sdvo_connector->right_margin = psb_intel_sdvo_connector->left_margin;
    psb_intel_sdvo_connector->left = drm_property_create_range(dev, 0, "left_margin",
                                                               0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->left == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->left,
                               (uint64_t )psb_intel_sdvo_connector->left_margin);
    psb_intel_sdvo_connector->right = drm_property_create_range(dev, 0, "right_margin",
                                                                0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->right == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->right,
                               (uint64_t )psb_intel_sdvo_connector->right_margin);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "h_overscan: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    tmp___3 = psb_intel_sdvo_get_value(psb_intel_sdvo, 100, (void *)(& data_value),
                                       4);
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      return (0);
    } else {

    }
    tmp___5 = psb_intel_sdvo_get_value(psb_intel_sdvo, 101, (void *)(& response),
                                       2);
    if (tmp___5) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
    if (tmp___6) {
      return (0);
    } else {

    }
    psb_intel_sdvo_connector->max_vscan = (u32 )data_value[0];
    psb_intel_sdvo_connector->top_margin = (u32 )((int )data_value[0] - (int )response);
    psb_intel_sdvo_connector->bottom_margin = psb_intel_sdvo_connector->top_margin;
    psb_intel_sdvo_connector->top = drm_property_create_range(dev, 0, "top_margin",
                                                              0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->top == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->top, (uint64_t )psb_intel_sdvo_connector->top_margin);
    psb_intel_sdvo_connector->bottom = drm_property_create_range(dev, 0, "bottom_margin",
                                                                 0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->bottom == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->bottom,
                               (uint64_t )psb_intel_sdvo_connector->bottom_margin);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "v_overscan: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    tmp___7 = psb_intel_sdvo_get_value(psb_intel_sdvo, 103, (void *)(& data_value),
                                       4);
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    if (tmp___8) {
      return (0);
    } else {
      tmp___9 = psb_intel_sdvo_get_value(psb_intel_sdvo, 104, (void *)(& response),
                                         2);
      if (tmp___9) {
        tmp___10 = 0;
      } else {
        tmp___10 = 1;
      }
      if (tmp___10) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_hpos = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_hpos = (u32 )response;
    psb_intel_sdvo_connector->hpos = drm_property_create_range(dev, 0, "hpos", 0ULL,
                                                               (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->hpos == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->hpos,
                               (uint64_t )psb_intel_sdvo_connector->cur_hpos);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "hpos: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    tmp___11 = psb_intel_sdvo_get_value(psb_intel_sdvo, 106, (void *)(& data_value),
                                        4);
    if (tmp___11) {
      tmp___12 = 0;
    } else {
      tmp___12 = 1;
    }
    if (tmp___12) {
      return (0);
    } else {
      tmp___13 = psb_intel_sdvo_get_value(psb_intel_sdvo, 107, (void *)(& response),
                                          2);
      if (tmp___13) {
        tmp___14 = 0;
      } else {
        tmp___14 = 1;
      }
      if (tmp___14) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_vpos = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_vpos = (u32 )response;
    psb_intel_sdvo_connector->vpos = drm_property_create_range(dev, 0, "vpos", 0ULL,
                                                               (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->vpos == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->vpos,
                               (uint64_t )psb_intel_sdvo_connector->cur_vpos);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "vpos: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp___15 = psb_intel_sdvo_get_value(psb_intel_sdvo, 85, (void *)(& data_value),
                                        4);
    if (tmp___15) {
      tmp___16 = 0;
    } else {
      tmp___16 = 1;
    }
    if (tmp___16) {
      return (0);
    } else {
      tmp___17 = psb_intel_sdvo_get_value(psb_intel_sdvo, 86, (void *)(& response),
                                          2);
      if (tmp___17) {
        tmp___18 = 0;
      } else {
        tmp___18 = 1;
      }
      if (tmp___18) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_saturation = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_saturation = (u32 )response;
    psb_intel_sdvo_connector->saturation = drm_property_create_range(dev, 0, "saturation",
                                                                     0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->saturation == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->saturation,
                               (uint64_t )psb_intel_sdvo_connector->cur_saturation);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "saturation: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp___19 = psb_intel_sdvo_get_value(psb_intel_sdvo, 94, (void *)(& data_value),
                                        4);
    if (tmp___19) {
      tmp___20 = 0;
    } else {
      tmp___20 = 1;
    }
    if (tmp___20) {
      return (0);
    } else {
      tmp___21 = psb_intel_sdvo_get_value(psb_intel_sdvo, 95, (void *)(& response),
                                          2);
      if (tmp___21) {
        tmp___22 = 0;
      } else {
        tmp___22 = 1;
      }
      if (tmp___22) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_contrast = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_contrast = (u32 )response;
    psb_intel_sdvo_connector->contrast = drm_property_create_range(dev, 0, "contrast",
                                                                   0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->contrast == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->contrast,
                               (uint64_t )psb_intel_sdvo_connector->cur_contrast);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "contrast: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp___23 = psb_intel_sdvo_get_value(psb_intel_sdvo, 88, (void *)(& data_value),
                                        4);
    if (tmp___23) {
      tmp___24 = 0;
    } else {
      tmp___24 = 1;
    }
    if (tmp___24) {
      return (0);
    } else {
      tmp___25 = psb_intel_sdvo_get_value(psb_intel_sdvo, 89, (void *)(& response),
                                          2);
      if (tmp___25) {
        tmp___26 = 0;
      } else {
        tmp___26 = 1;
      }
      if (tmp___26) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_hue = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_hue = (u32 )response;
    psb_intel_sdvo_connector->hue = drm_property_create_range(dev, 0, "hue", 0ULL,
                                                              (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->hue == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->hue, (uint64_t )psb_intel_sdvo_connector->cur_hue);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "hue: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    tmp___27 = psb_intel_sdvo_get_value(psb_intel_sdvo, 109, (void *)(& data_value),
                                        4);
    if (tmp___27) {
      tmp___28 = 0;
    } else {
      tmp___28 = 1;
    }
    if (tmp___28) {
      return (0);
    } else {
      tmp___29 = psb_intel_sdvo_get_value(psb_intel_sdvo, 110, (void *)(& response),
                                          2);
      if (tmp___29) {
        tmp___30 = 0;
      } else {
        tmp___30 = 1;
      }
      if (tmp___30) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_sharpness = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_sharpness = (u32 )response;
    psb_intel_sdvo_connector->sharpness = drm_property_create_range(dev, 0, "sharpness",
                                                                    0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->sharpness == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->sharpness,
                               (uint64_t )psb_intel_sdvo_connector->cur_sharpness);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "sharpness: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp___31 = psb_intel_sdvo_get_value(psb_intel_sdvo, 91, (void *)(& data_value),
                                        4);
    if (tmp___31) {
      tmp___32 = 0;
    } else {
      tmp___32 = 1;
    }
    if (tmp___32) {
      return (0);
    } else {
      tmp___33 = psb_intel_sdvo_get_value(psb_intel_sdvo, 92, (void *)(& response),
                                          2);
      if (tmp___33) {
        tmp___34 = 0;
      } else {
        tmp___34 = 1;
      }
      if (tmp___34) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_brightness = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_brightness = (u32 )response;
    psb_intel_sdvo_connector->brightness = drm_property_create_range(dev, 0, "brightness",
                                                                     0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->brightness,
                               (uint64_t )psb_intel_sdvo_connector->cur_brightness);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "brightness: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp___35 = psb_intel_sdvo_get_value(psb_intel_sdvo, 77, (void *)(& data_value),
                                        4);
    if (tmp___35) {
      tmp___36 = 0;
    } else {
      tmp___36 = 1;
    }
    if (tmp___36) {
      return (0);
    } else {
      tmp___37 = psb_intel_sdvo_get_value(psb_intel_sdvo, 78, (void *)(& response),
                                          2);
      if (tmp___37) {
        tmp___38 = 0;
      } else {
        tmp___38 = 1;
      }
      if (tmp___38) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_flicker_filter = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_flicker_filter = (u32 )response;
    psb_intel_sdvo_connector->flicker_filter = drm_property_create_range(dev, 0, "flicker_filter",
                                                                         0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "flicker_filter: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp___39 = psb_intel_sdvo_get_value(psb_intel_sdvo, 123, (void *)(& data_value),
                                        4);
    if (tmp___39) {
      tmp___40 = 0;
    } else {
      tmp___40 = 1;
    }
    if (tmp___40) {
      return (0);
    } else {
      tmp___41 = psb_intel_sdvo_get_value(psb_intel_sdvo, 80, (void *)(& response),
                                          2);
      if (tmp___41) {
        tmp___42 = 0;
      } else {
        tmp___42 = 1;
      }
      if (tmp___42) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_flicker_filter_adaptive = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_flicker_filter_adaptive = (u32 )response;
    psb_intel_sdvo_connector->flicker_filter_adaptive = drm_property_create_range(dev,
                                                                                  0,
                                                                                  "flicker_filter_adaptive",
                                                                                  0ULL,
                                                                                  (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_adaptive == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter_adaptive,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter_adaptive);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "flicker_filter_adaptive: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp___43 = psb_intel_sdvo_get_value(psb_intel_sdvo, 82, (void *)(& data_value),
                                        4);
    if (tmp___43) {
      tmp___44 = 0;
    } else {
      tmp___44 = 1;
    }
    if (tmp___44) {
      return (0);
    } else {
      tmp___45 = psb_intel_sdvo_get_value(psb_intel_sdvo, 83, (void *)(& response),
                                          2);
      if (tmp___45) {
        tmp___46 = 0;
      } else {
        tmp___46 = 1;
      }
      if (tmp___46) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_flicker_filter_2d = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_flicker_filter_2d = (u32 )response;
    psb_intel_sdvo_connector->flicker_filter_2d = drm_property_create_range(dev, 0,
                                                                            "flicker_filter_2d",
                                                                            0ULL,
                                                                            (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->flicker_filter_2d == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->flicker_filter_2d,
                               (uint64_t )psb_intel_sdvo_connector->cur_flicker_filter_2d);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "flicker_filter_2d: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    tmp___47 = psb_intel_sdvo_get_value(psb_intel_sdvo, 116, (void *)(& data_value),
                                        4);
    if (tmp___47) {
      tmp___48 = 0;
    } else {
      tmp___48 = 1;
    }
    if (tmp___48) {
      return (0);
    } else {
      tmp___49 = psb_intel_sdvo_get_value(psb_intel_sdvo, 117, (void *)(& response),
                                          2);
      if (tmp___49) {
        tmp___50 = 0;
      } else {
        tmp___50 = 1;
      }
      if (tmp___50) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_tv_chroma_filter = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_tv_chroma_filter = (u32 )response;
    psb_intel_sdvo_connector->tv_chroma_filter = drm_property_create_range(dev, 0,
                                                                           "tv_chroma_filter",
                                                                           0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->tv_chroma_filter == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->tv_chroma_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_tv_chroma_filter);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "tv_chroma_filter: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    tmp___51 = psb_intel_sdvo_get_value(psb_intel_sdvo, 119, (void *)(& data_value),
                                        4);
    if (tmp___51) {
      tmp___52 = 0;
    } else {
      tmp___52 = 1;
    }
    if (tmp___52) {
      return (0);
    } else {
      tmp___53 = psb_intel_sdvo_get_value(psb_intel_sdvo, 120, (void *)(& response),
                                          2);
      if (tmp___53) {
        tmp___54 = 0;
      } else {
        tmp___54 = 1;
      }
      if (tmp___54) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_tv_luma_filter = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_tv_luma_filter = (u32 )response;
    psb_intel_sdvo_connector->tv_luma_filter = drm_property_create_range(dev, 0, "tv_luma_filter",
                                                                         0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->tv_luma_filter == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->tv_luma_filter,
                               (uint64_t )psb_intel_sdvo_connector->cur_tv_luma_filter);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "tv_luma_filter: max %d, default %d, current %d\n",
                        (int )data_value[0], (int )data_value[1], (int )response);
  } else {

  }
  if ((unsigned int )*((unsigned char *)(& enhancements) + 1UL) != 0U) {
    tmp___55 = psb_intel_sdvo_get_value(psb_intel_sdvo, 112, (void *)(& response),
                                        2);
    if (tmp___55) {
      tmp___56 = 0;
    } else {
      tmp___56 = 1;
    }
    if (tmp___56) {
      return (0);
    } else {

    }
    psb_intel_sdvo_connector->max_dot_crawl = 1U;
    psb_intel_sdvo_connector->cur_dot_crawl = (u32 )response & 1U;
    psb_intel_sdvo_connector->dot_crawl = drm_property_create_range(dev, 0, "dot_crawl",
                                                                    0ULL, 1ULL);
    if ((unsigned long )psb_intel_sdvo_connector->dot_crawl == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->dot_crawl,
                               (uint64_t )psb_intel_sdvo_connector->cur_dot_crawl);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_tv", "dot crawl: current %d\n",
                        (int )response);
  } else {

  }
  return (1);
}
}
static bool psb_intel_sdvo_create_enhance_property_lvds(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                        struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ,
                                                        struct psb_intel_sdvo_enhancements_reply enhancements ) 
{ struct drm_device *dev ;
  struct drm_connector *connector ;
  uint16_t response ;
  uint16_t data_value[2U] ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  dev = psb_intel_sdvo->base.base.dev;
  connector = & psb_intel_sdvo_connector->base.base;
  if ((unsigned int )*((unsigned char *)(& enhancements) + 0UL) != 0U) {
    tmp = psb_intel_sdvo_get_value(psb_intel_sdvo, 91, (void *)(& data_value), 4);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      return (0);
    } else {
      tmp___1 = psb_intel_sdvo_get_value(psb_intel_sdvo, 92, (void *)(& response),
                                         2);
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      if (tmp___2) {
        return (0);
      } else {

      }
    }
    psb_intel_sdvo_connector->max_brightness = (u32 )data_value[0];
    psb_intel_sdvo_connector->cur_brightness = (u32 )response;
    psb_intel_sdvo_connector->brightness = drm_property_create_range(dev, 0, "brightness",
                                                                     0ULL, (uint64_t )data_value[0]);
    if ((unsigned long )psb_intel_sdvo_connector->brightness == (unsigned long )((struct drm_property *)0)) {
      return (0);
    } else {

    }
    drm_object_attach_property(& connector->base, psb_intel_sdvo_connector->brightness,
                               (uint64_t )psb_intel_sdvo_connector->cur_brightness);
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property_lvds",
                        "brightness: max %d, default %d, current %d\n", (int )data_value[0],
                        (int )data_value[1], (int )response);
  } else {

  }
  return (1);
}
}
static bool psb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo ,
                                                   struct psb_intel_sdvo_connector *psb_intel_sdvo_connector ) 
{ union __anonunion_enhancements_231 enhancements ;
  bool tmp ;
  bool tmp___0 ;

  {
  enhancements.response = 0U;
  psb_intel_sdvo_get_value(psb_intel_sdvo, 132, (void *)(& enhancements), 2);
  if ((unsigned int )enhancements.response == 0U) {
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_create_enhance_property", "No enhancement is supported\n");
    return (1);
  } else {

  }
  if (((int )psb_intel_sdvo_connector->output_flag & 12) != 0) {
    tmp = psb_intel_sdvo_create_enhance_property_tv(psb_intel_sdvo, psb_intel_sdvo_connector,
                                                    enhancements.reply);
    return (tmp);
  } else
  if (((int )psb_intel_sdvo_connector->output_flag & 16448) != 0) {
    tmp___0 = psb_intel_sdvo_create_enhance_property_lvds(psb_intel_sdvo, psb_intel_sdvo_connector,
                                                          enhancements.reply);
    return (tmp___0);
  } else {
    return (1);
  }
}
}
static int psb_intel_sdvo_ddc_proxy_xfer(struct i2c_adapter *adapter , struct i2c_msg *msgs ,
                                         int num ) 
{ struct psb_intel_sdvo *sdvo ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  sdvo = (struct psb_intel_sdvo *)adapter->algo_data;
  tmp = psb_intel_sdvo_set_control_bus_switch(sdvo, (int )sdvo->ddc_bus);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (-5);
  } else {

  }
  tmp___1 = (*(((sdvo->i2c)->algo)->master_xfer))(sdvo->i2c, msgs, num);
  return (tmp___1);
}
}
static u32 psb_intel_sdvo_ddc_proxy_func(struct i2c_adapter *adapter ) 
{ struct psb_intel_sdvo *sdvo ;
  u32 tmp ;

  {
  sdvo = (struct psb_intel_sdvo *)adapter->algo_data;
  tmp = (*(((sdvo->i2c)->algo)->functionality))(sdvo->i2c);
  return (tmp);
}
}
static struct i2c_algorithm  const  psb_intel_sdvo_ddc_proxy  =    {& psb_intel_sdvo_ddc_proxy_xfer, 0, & psb_intel_sdvo_ddc_proxy_func};
static bool psb_intel_sdvo_init_ddc_proxy(struct psb_intel_sdvo *sdvo , struct drm_device *dev ) 
{ int tmp ;

  {
  sdvo->ddc.owner = & __this_module;
  sdvo->ddc.class = 8U;
  snprintf((char *)(& sdvo->ddc.name), 20UL, "SDVO DDC proxy");
  sdvo->ddc.dev.parent = & (dev->pdev)->dev;
  sdvo->ddc.algo_data = (void *)sdvo;
  sdvo->ddc.algo = & psb_intel_sdvo_ddc_proxy;
  tmp = i2c_add_adapter(& sdvo->ddc);
  return (tmp == 0);
}
}
bool psb_intel_sdvo_init(struct drm_device *dev , int sdvo_reg ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_sdvo *psb_intel_sdvo ;
  int i ;
  void *tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  u8 byte ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = kzalloc(1880UL, 208U);
  psb_intel_sdvo = (struct psb_intel_sdvo *)tmp;
  if ((unsigned long )psb_intel_sdvo == (unsigned long )((struct psb_intel_sdvo *)0)) {
    return (0);
  } else {

  }
  psb_intel_sdvo->sdvo_reg = sdvo_reg;
  tmp___0 = psb_intel_sdvo_get_slave_addr(dev, sdvo_reg);
  psb_intel_sdvo->slave_addr = (u8 )((int )tmp___0 >> 1);
  psb_intel_sdvo_select_i2c_bus(dev_priv, psb_intel_sdvo, (u32 )sdvo_reg);
  tmp___1 = psb_intel_sdvo_init_ddc_proxy(psb_intel_sdvo, dev);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    kfree((void const   *)psb_intel_sdvo);
    return (0);
  } else {

  }
  psb_intel_encoder = & psb_intel_sdvo->base;
  psb_intel_encoder->type = 3;
  drm_encoder_init(dev, & psb_intel_encoder->base, & psb_intel_sdvo_enc_funcs, 0);
  i = 0;
  goto ldv_39874;
  ldv_39873: 
  tmp___4 = psb_intel_sdvo_read_byte(psb_intel_sdvo, (int )((u8 )i), & byte);
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    if (sdvo_reg == 397632) {
      tmp___3 = 66;
    } else {
      tmp___3 = 67;
    }
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_init", "No SDVO device found on SDVO%c\n",
                        tmp___3);
    goto err;
  } else {

  }
  i = i + 1;
  ldv_39874: ;
  if (i <= 63) {
    goto ldv_39873;
  } else {
    goto ldv_39875;
  }
  ldv_39875: ;
  if (sdvo_reg == 397632) {
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 64U;
  } else {
    dev_priv->hotplug_supported_mask = dev_priv->hotplug_supported_mask | 128U;
  }
  drm_encoder_helper_add(& psb_intel_encoder->base, & psb_intel_sdvo_helper_funcs);
  tmp___6 = psb_intel_sdvo_get_capabilities(psb_intel_sdvo, & psb_intel_sdvo->caps);
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    goto err;
  } else {

  }
  tmp___9 = psb_intel_sdvo_output_setup(psb_intel_sdvo, (int )psb_intel_sdvo->caps.output_flags);
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10) {
    if (sdvo_reg == 397632) {
      tmp___8 = 66;
    } else {
      tmp___8 = 67;
    }
    drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_init", "SDVO output failed to setup on SDVO%c\n",
                        tmp___8);
    goto err;
  } else {

  }
  psb_intel_sdvo_select_ddc_bus(dev_priv, psb_intel_sdvo, (u32 )sdvo_reg);
  tmp___11 = psb_intel_sdvo_set_target_input(psb_intel_sdvo);
  if (tmp___11) {
    tmp___12 = 0;
  } else {
    tmp___12 = 1;
  }
  if (tmp___12) {
    goto err;
  } else {

  }
  tmp___13 = psb_intel_sdvo_get_input_pixel_clock_range(psb_intel_sdvo, & psb_intel_sdvo->pixel_clock_min,
                                                        & psb_intel_sdvo->pixel_clock_max);
  if (tmp___13) {
    tmp___14 = 0;
  } else {
    tmp___14 = 1;
  }
  if (tmp___14) {
    goto err;
  } else {

  }
  if (((int )psb_intel_sdvo->caps.output_flags & 768) != 0) {
    tmp___15 = 89;
  } else {
    tmp___15 = 78;
  }
  if (((int )psb_intel_sdvo->caps.output_flags & 3) != 0) {
    tmp___16 = 89;
  } else {
    tmp___16 = 78;
  }
  if (((int )psb_intel_sdvo->caps.sdvo_inputs_mask & 2) != 0) {
    tmp___17 = 89;
  } else {
    tmp___17 = 78;
  }
  if ((int )psb_intel_sdvo->caps.sdvo_inputs_mask & 1) {
    tmp___18 = 89;
  } else {
    tmp___18 = 78;
  }
  if (psb_intel_sdvo->sdvo_reg == 397632) {
    tmp___19 = (char *)"SDVOB";
  } else {
    tmp___19 = (char *)"SDVOC";
  }
  drm_ut_debug_printk(4U, "drm", "psb_intel_sdvo_init", "%s device VID/DID: %02X:%02X.%02X, clock range %dMHz - %dMHz, input 1: %c, input 2: %c, output 1: %c, output 2: %c\n",
                      tmp___19, (int )psb_intel_sdvo->caps.vendor_id, (int )psb_intel_sdvo->caps.device_id,
                      (int )psb_intel_sdvo->caps.device_rev_id, psb_intel_sdvo->pixel_clock_min / 1000,
                      psb_intel_sdvo->pixel_clock_max / 1000, tmp___18, tmp___17,
                      tmp___16, tmp___15);
  return (1);
  err: 
  drm_encoder_cleanup(& psb_intel_encoder->base);
  i2c_del_adapter(& psb_intel_sdvo->ddc);
  kfree((void const   *)psb_intel_sdvo);
  return (0);
}
}
bool ldvarg7  ;
uint32_t ldvarg3  ;
struct drm_connector *psb_intel_sdvo_connector_funcs_group0  ;
struct drm_encoder *psb_intel_sdvo_helper_funcs_group1  ;
struct i2c_msg *ldvarg126  ;
extern int ldv_psb_intel_sdvo_enc_funcs_probe_30(void) ;
int ldvarg8  ;
struct drm_display_mode *ldvarg1  ;
struct i2c_adapter *psb_intel_sdvo_ddc_proxy_group0  ;
int ldvarg125  ;
struct drm_display_mode *ldvarg0  ;
uint64_t ldvarg5  ;
struct drm_property *ldvarg6  ;
struct drm_display_mode *psb_intel_sdvo_helper_funcs_group0  ;
uint32_t ldvarg4  ;
extern int ldv_psb_intel_sdvo_connector_funcs_probe_32(void) ;
struct drm_display_mode *ldvarg82  ;
int ldvarg2  ;
struct drm_encoder *ldvarg34  ;
struct drm_connector *psb_intel_sdvo_connector_helper_funcs_group0  ;
void ldv_main_exported_33(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_33 == 1) {
    psb_intel_sdvo_dpms(psb_intel_sdvo_helper_funcs_group1, ldvarg2);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_39902;
  case 1: ;
  if (ldv_state_variable_33 == 1) {
    psb_intel_sdvo_mode_fixup(psb_intel_sdvo_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg1,
                              psb_intel_sdvo_helper_funcs_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_39902;
  case 2: ;
  if (ldv_state_variable_33 == 1) {
    psb_intel_encoder_commit(psb_intel_sdvo_helper_funcs_group1);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_39902;
  case 3: ;
  if (ldv_state_variable_33 == 1) {
    psb_intel_sdvo_mode_set(psb_intel_sdvo_helper_funcs_group1, psb_intel_sdvo_helper_funcs_group0,
                            ldvarg0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_39902;
  case 4: ;
  if (ldv_state_variable_33 == 1) {
    psb_intel_encoder_prepare(psb_intel_sdvo_helper_funcs_group1);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_39902;
  default: ;
  goto ldv_39902;
  }
  ldv_39902: ;
  return;
}
}
void ldv_main_exported_32(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_32 == 1) {
    drm_helper_connector_dpms(psb_intel_sdvo_connector_funcs_group0, ldvarg8);
    ldv_state_variable_32 = 1;
  } else {

  }
  if (ldv_state_variable_32 == 2) {
    drm_helper_connector_dpms(psb_intel_sdvo_connector_funcs_group0, ldvarg8);
    ldv_state_variable_32 = 2;
  } else {

  }
  goto ldv_39912;
  case 1: ;
  if (ldv_state_variable_32 == 1) {
    psb_intel_sdvo_detect(psb_intel_sdvo_connector_funcs_group0, (int )ldvarg7);
    ldv_state_variable_32 = 1;
  } else {

  }
  if (ldv_state_variable_32 == 2) {
    psb_intel_sdvo_detect(psb_intel_sdvo_connector_funcs_group0, (int )ldvarg7);
    ldv_state_variable_32 = 2;
  } else {

  }
  goto ldv_39912;
  case 2: ;
  if (ldv_state_variable_32 == 1) {
    psb_intel_sdvo_set_property(psb_intel_sdvo_connector_funcs_group0, ldvarg6, ldvarg5);
    ldv_state_variable_32 = 1;
  } else {

  }
  if (ldv_state_variable_32 == 2) {
    psb_intel_sdvo_set_property(psb_intel_sdvo_connector_funcs_group0, ldvarg6, ldvarg5);
    ldv_state_variable_32 = 2;
  } else {

  }
  goto ldv_39912;
  case 3: ;
  if (ldv_state_variable_32 == 2) {
    psb_intel_sdvo_destroy(psb_intel_sdvo_connector_funcs_group0);
    ldv_state_variable_32 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_39912;
  case 4: ;
  if (ldv_state_variable_32 == 1) {
    drm_helper_probe_single_connector_modes(psb_intel_sdvo_connector_funcs_group0,
                                            ldvarg4, ldvarg3);
    ldv_state_variable_32 = 1;
  } else {

  }
  if (ldv_state_variable_32 == 2) {
    drm_helper_probe_single_connector_modes(psb_intel_sdvo_connector_funcs_group0,
                                            ldvarg4, ldvarg3);
    ldv_state_variable_32 = 2;
  } else {

  }
  goto ldv_39912;
  case 5: ;
  if (ldv_state_variable_32 == 1) {
    ldv_psb_intel_sdvo_connector_funcs_probe_32();
    ldv_state_variable_32 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_39912;
  default: ;
  goto ldv_39912;
  }
  ldv_39912: ;
  return;
}
}
void ldv_main_exported_30(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_30 == 2) {
    psb_intel_sdvo_enc_destroy(ldvarg34);
    ldv_state_variable_30 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_39923;
  case 1: ;
  if (ldv_state_variable_30 == 1) {
    ldv_psb_intel_sdvo_enc_funcs_probe_30();
    ldv_state_variable_30 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_39923;
  default: ;
  goto ldv_39923;
  }
  ldv_39923: ;
  return;
}
}
void ldv_main_exported_31(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_31 == 1) {
    psb_intel_sdvo_get_modes(psb_intel_sdvo_connector_helper_funcs_group0);
    ldv_state_variable_31 = 1;
  } else {

  }
  goto ldv_39930;
  case 1: ;
  if (ldv_state_variable_31 == 1) {
    psb_intel_sdvo_mode_valid(psb_intel_sdvo_connector_helper_funcs_group0, ldvarg82);
    ldv_state_variable_31 = 1;
  } else {

  }
  goto ldv_39930;
  case 2: ;
  if (ldv_state_variable_31 == 1) {
    psb_intel_best_encoder(psb_intel_sdvo_connector_helper_funcs_group0);
    ldv_state_variable_31 = 1;
  } else {

  }
  goto ldv_39930;
  default: ;
  goto ldv_39930;
  }
  ldv_39930: ;
  return;
}
}
void ldv_main_exported_29(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_29 == 1) {
    psb_intel_sdvo_ddc_proxy_xfer(psb_intel_sdvo_ddc_proxy_group0, ldvarg126, ldvarg125);
    ldv_state_variable_29 = 1;
  } else {

  }
  goto ldv_39938;
  case 1: ;
  if (ldv_state_variable_29 == 1) {
    psb_intel_sdvo_ddc_proxy_func(psb_intel_sdvo_ddc_proxy_group0);
    ldv_state_variable_29 = 1;
  } else {

  }
  goto ldv_39938;
  default: ;
  goto ldv_39938;
  }
  ldv_39938: ;
  return;
}
}
void ldv_mutex_lock_377(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_378(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_379(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_380(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_381(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_382(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_383(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_384(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_385(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_386(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_387(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_388(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_404(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_402(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_405(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_407(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_409(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_410(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_412(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_401(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_403(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_406(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_408(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_411(struct mutex *ldv_func_arg1 ) ;
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 

  {
  return ((unsigned long )timer->entry.next != (unsigned long )((struct list_head */* const  */)0));
}
}
extern void add_timer(struct timer_list * ) ;
extern int del_timer_sync(struct timer_list * ) ;
__inline static unsigned int readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
  return (ret);
}
}
void psb_lid_timer_init(struct drm_psb_private *dev_priv ) ;
void psb_lid_timer_takedown(struct drm_psb_private *dev_priv ) ;
static void psb_lid_timer_func(unsigned long data ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_device *dev ;
  struct timer_list *lid_timer ;
  unsigned long irq_flags ;
  u32 *lid_state ;
  u32 pp_status ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  unsigned int tmp___3 ;
  raw_spinlock_t *tmp___4 ;
  int tmp___5 ;

  {
  dev_priv = (struct drm_psb_private *)data;
  dev = dev_priv->dev;
  lid_timer = & dev_priv->lid_timer;
  lid_state = dev_priv->opregion.lid_state;
  tmp = readl((void const volatile   *)lid_state);
  if (tmp == dev_priv->lid_last_state) {
    goto lid_timer_schedule;
  } else {

  }
  tmp___3 = readl((void const volatile   *)lid_state);
  if ((int )tmp___3 & 1) {
    tmp___0 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___0 | 1U);
    ldv_38002: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status >= 0 && (pp_status & 805306368U) != 0U) {
      goto ldv_38002;
    } else {
      goto ldv_38003;
    }
    ldv_38003: 
    tmp___1 = REGISTER_READ(dev, 397824U);
    if ((int )tmp___1 < 0) {
      psb_intel_lvds_set_brightness(dev, 100);
    } else {
      drm_ut_debug_printk(1U, "drm", "psb_lid_timer_func", "LVDS panel never powered up");
      return;
    }
  } else {
    psb_intel_lvds_set_brightness(dev, 0);
    tmp___2 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_38005: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status >= 0) {
      goto ldv_38005;
    } else {
      goto ldv_38006;
    }
    ldv_38006: ;
  }
  dev_priv->lid_last_state = readl((void const volatile   *)lid_state);
  lid_timer_schedule: 
  tmp___4 = spinlock_check(& dev_priv->lid_lock);
  irq_flags = _raw_spin_lock_irqsave(tmp___4);
  tmp___5 = timer_pending((struct timer_list  const  *)lid_timer);
  if (tmp___5 == 0) {
    lid_timer->expires = (unsigned long )jiffies + 25UL;
    add_timer(lid_timer);
  } else {

  }
  spin_unlock_irqrestore(& dev_priv->lid_lock, irq_flags);
  return;
}
}
void psb_lid_timer_init(struct drm_psb_private *dev_priv ) 
{ struct timer_list *lid_timer ;
  unsigned long irq_flags ;
  struct lock_class_key __key ;
  raw_spinlock_t *tmp ;
  struct lock_class_key __key___0 ;

  {
  lid_timer = & dev_priv->lid_timer;
  spinlock_check(& dev_priv->lid_lock);
  __raw_spin_lock_init(& dev_priv->lid_lock.ldv_5961.rlock, "&(&dev_priv->lid_lock)->rlock",
                       & __key);
  tmp = spinlock_check(& dev_priv->lid_lock);
  irq_flags = _raw_spin_lock_irqsave(tmp);
  init_timer_key(lid_timer, 0U, "(lid_timer)", & __key___0);
  lid_timer->data = (unsigned long )dev_priv;
  lid_timer->function = & psb_lid_timer_func;
  lid_timer->expires = (unsigned long )jiffies + 25UL;
  add_timer(lid_timer);
  spin_unlock_irqrestore(& dev_priv->lid_lock, irq_flags);
  return;
}
}
void psb_lid_timer_takedown(struct drm_psb_private *dev_priv ) 
{ 

  {
  del_timer_sync(& dev_priv->lid_timer);
  return;
}
}
void ldv_mutex_lock_401(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_402(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_403(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_404(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_405(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_406(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_407(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_408(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_409(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_410(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_411(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_412(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_428(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_429(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_434(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_436(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_425(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_427(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_430(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_435(struct mutex *ldv_func_arg1 ) ;
extern bool drm_handle_vblank(struct drm_device * , int  ) ;
void psb_intel_opregion_asle_intr(struct drm_device *dev ) ;
int psb_irq_enable_dpst(struct drm_device *dev ) ;
int psb_irq_disable_dpst(struct drm_device *dev ) ;
void psb_irq_turn_on_dpst(struct drm_device *dev ) ;
void psb_irq_turn_off_dpst(struct drm_device *dev ) ;
void psb_enable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) ;
void psb_disable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) ;
int mdfld_enable_te(struct drm_device *dev , int pipe ) ;
void mdfld_disable_te(struct drm_device *dev , int pipe ) ;
__inline static u32 psb_pipestat(int pipe ) 
{ 

  {
  if (pipe == 0) {
    return (458788U);
  } else {

  }
  if (pipe == 1) {
    return (462884U);
  } else {

  }
  if (pipe == 2) {
    return (466980U);
  } else {

  }
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c.prepared"),
                       "i" (189), "i" (12UL));
  ldv_38075: ;
  goto ldv_38075;
}
}
__inline static u32 mid_pipe_event(int pipe ) 
{ 

  {
  if (pipe == 0) {
    return (64U);
  } else {

  }
  if (pipe == 1) {
    return (16U);
  } else {

  }
  if (pipe == 2) {
    return (4U);
  } else {

  }
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c.prepared"),
                       "i" (201), "i" (12UL));
  ldv_38079: ;
  goto ldv_38079;
}
}
__inline static u32 mid_pipeconf(int pipe ) 
{ 

  {
  if (pipe == 0) {
    return (458760U);
  } else {

  }
  if (pipe == 1) {
    return (462856U);
  } else {

  }
  if (pipe == 2) {
    return (466952U);
  } else {

  }
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/psb_irq.c.prepared"),
                       "i" (225), "i" (12UL));
  ldv_38087: ;
  goto ldv_38087;
}
}
void psb_enable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) 
{ u32 reg ;
  u32 tmp ;
  u32 writeVal ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
  if ((dev_priv->pipestat[pipe] & mask) != mask) {
    tmp = psb_pipestat(pipe);
    reg = tmp;
    dev_priv->pipestat[pipe] = dev_priv->pipestat[pipe] | mask;
    tmp___1 = gma_power_begin(dev_priv->dev, 0);
    if ((int )tmp___1) {
      tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
      writeVal = tmp___0;
      writeVal = ((mask >> 16) | mask) | writeVal;
      iowrite32(writeVal, (void *)dev_priv->vdc_reg + (unsigned long )reg);
      ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
  return;
}
}
void psb_disable_pipestat(struct drm_psb_private *dev_priv , int pipe , u32 mask ) 
{ u32 reg ;
  u32 tmp ;
  u32 writeVal ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
  if ((dev_priv->pipestat[pipe] & mask) != 0U) {
    tmp = psb_pipestat(pipe);
    reg = tmp;
    dev_priv->pipestat[pipe] = dev_priv->pipestat[pipe] & ~ mask;
    tmp___1 = gma_power_begin(dev_priv->dev, 0);
    if ((int )tmp___1) {
      tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
      writeVal = tmp___0;
      writeVal = ~ mask & writeVal;
      iowrite32(writeVal, (void *)dev_priv->vdc_reg + (unsigned long )reg);
      ioread32((void *)dev_priv->vdc_reg + (unsigned long )reg);
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
  return;
}
}
static void mid_enable_pipe_event(struct drm_psb_private *dev_priv , int pipe ) 
{ u32 pipe_event ;
  u32 tmp ;
  bool tmp___0 ;

  {
  tmp___0 = gma_power_begin(dev_priv->dev, 0);
  if ((int )tmp___0) {
    tmp = mid_pipe_event(pipe);
    pipe_event = tmp;
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | pipe_event;
    iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
    iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
    gma_power_end(dev_priv->dev);
  } else {

  }
  return;
}
}
static void mid_disable_pipe_event(struct drm_psb_private *dev_priv , int pipe ) 
{ u32 pipe_event ;
  u32 tmp ;
  bool tmp___0 ;

  {
  if (dev_priv->pipestat[pipe] == 0U) {
    tmp___0 = gma_power_begin(dev_priv->dev, 0);
    if ((int )tmp___0) {
      tmp = mid_pipe_event(pipe);
      pipe_event = tmp;
      dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & ~ pipe_event;
      iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
      iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
      gma_power_end(dev_priv->dev);
    } else {

    }
  } else {

  }
  return;
}
}
static void mid_pipe_event_handler(struct drm_device *dev , int pipe ) 
{ struct drm_psb_private *dev_priv ;
  uint32_t pipe_stat_val ;
  uint32_t pipe_stat_reg ;
  u32 tmp ;
  uint32_t pipe_enable ;
  uint32_t pipe_status ;
  uint32_t pipe_clear ;
  uint32_t i ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pipe_stat_val = 0U;
  tmp = psb_pipestat(pipe);
  pipe_stat_reg = tmp;
  pipe_enable = dev_priv->pipestat[pipe];
  pipe_status = dev_priv->pipestat[pipe] >> 16;
  i = 0U;
  spin_lock(& dev_priv->irqmask_lock);
  pipe_stat_val = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
  pipe_stat_val = (pipe_enable | pipe_status) & pipe_stat_val;
  pipe_stat_val = (pipe_stat_val >> 16) & pipe_stat_val;
  spin_unlock(& dev_priv->irqmask_lock);
  i = 0U;
  goto ldv_38125;
  ldv_38124: 
  tmp___0 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
  iowrite32(tmp___0, (void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
  tmp___1 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
  pipe_clear = tmp___1 & pipe_status;
  if (pipe_clear == 0U) {
    goto ldv_38123;
  } else {

  }
  i = i + 1U;
  ldv_38125: ;
  if (i <= 65534U) {
    goto ldv_38124;
  } else {
    goto ldv_38123;
  }
  ldv_38123: ;
  if (pipe_clear != 0U) {
    tmp___2 = ioread32((void *)dev_priv->vdc_reg + (unsigned long )pipe_stat_reg);
    dev_err((struct device  const  *)dev->dev, "%s, can\'t clear status bits for pipe %d, its value = 0x%x.\n",
            "mid_pipe_event_handler", pipe, tmp___2);
  } else {

  }
  if ((pipe_stat_val & 2U) != 0U) {
    drm_handle_vblank(dev, pipe);
  } else {

  }
  if (((unsigned long )pipe_stat_val & 64UL) != 0UL) {
    drm_handle_vblank(dev, pipe);
  } else {

  }
  return;
}
}
static void psb_vdc_interrupt(struct drm_device *dev , uint32_t vdc_stat ) 
{ 

  {
  if ((int )vdc_stat & 1) {
    psb_intel_opregion_asle_intr(dev);
  } else {

  }
  if ((vdc_stat & 128U) != 0U) {
    mid_pipe_event_handler(dev, 0);
  } else {

  }
  if ((vdc_stat & 32U) != 0U) {
    mid_pipe_event_handler(dev, 1);
  } else {

  }
  return;
}
}
irqreturn_t psb_irq_handler(int irq , void *arg ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  uint32_t vdc_stat ;
  uint32_t dsp_int ;
  uint32_t sgx_int ;
  uint32_t hotplug_int ;
  int handled ;
  bool tmp ;
  u32 s ;
  u32 s2 ;
  uint32_t tmp___0 ;

  {
  dev = (struct drm_device *)arg;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  dsp_int = 0U;
  sgx_int = 0U;
  hotplug_int = 0U;
  handled = 0;
  spin_lock(& dev_priv->irqmask_lock);
  vdc_stat = ioread32((void *)dev_priv->vdc_reg + 8356U);
  if ((vdc_stat & 160U) != 0U) {
    dsp_int = 1U;
  } else {

  }
  if ((vdc_stat & 262144U) != 0U) {
    sgx_int = 1U;
  } else {

  }
  if ((vdc_stat & 131072U) != 0U) {
    hotplug_int = 1U;
  } else {

  }
  vdc_stat = dev_priv->vdc_irq_mask & vdc_stat;
  spin_unlock(& dev_priv->irqmask_lock);
  if (dsp_int != 0U) {
    tmp = gma_power_is_on(dev);
    if ((int )tmp) {
      psb_vdc_interrupt(dev, vdc_stat);
      handled = 1;
    } else {

    }
  } else {

  }
  if (sgx_int != 0U) {
    s = ioread32((void *)dev_priv->sgx_reg + 300U);
    s2 = ioread32((void *)dev_priv->sgx_reg + 280U);
    iowrite32(s, (void *)dev_priv->sgx_reg + 308U);
    iowrite32(s2, (void *)dev_priv->sgx_reg + 276U);
    handled = 1;
  } else {

  }
  if (hotplug_int != 0U && (unsigned long )(dev_priv->ops)->hotplug != (unsigned long )((int (*/* const  */)(struct drm_device * ))0)) {
    handled = (*((dev_priv->ops)->hotplug))(dev);
    tmp___0 = REGISTER_READ(dev, 397588U);
    REGISTER_WRITE(dev, 397588U, tmp___0);
  } else {

  }
  iowrite32(vdc_stat, (void *)dev_priv->vdc_reg + 8356U);
  ioread32((void *)dev_priv->vdc_reg + 8356U);
  __asm__  volatile   ("lfence": : : "memory");
  if (handled == 0) {
    return (0);
  } else {

  }
  return (1);
}
}
void psb_irq_preinstall(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;
  bool tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = gma_power_is_on(dev);
  if ((int )tmp___0) {
    iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
  } else {

  }
  if (*(dev->vblank_enabled) != 0) {
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 128U;
  } else {

  }
  if (*(dev->vblank_enabled + 1UL) != 0) {
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 32U;
  } else {

  }
  if ((unsigned long )(dev_priv->ops)->hotplug != (unsigned long )((int (*/* const  */)(struct drm_device * ))0)) {
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 131072U;
  } else {

  }
  dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 1U;
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return;
}
}
int psb_irq_postinstall(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
  if (*(dev->vblank_enabled) != 0) {
    psb_enable_pipestat(dev_priv, 0, 131072U);
  } else {
    psb_disable_pipestat(dev_priv, 0, 131072U);
  }
  if (*(dev->vblank_enabled + 1UL) != 0) {
    psb_enable_pipestat(dev_priv, 1, 131072U);
  } else {
    psb_disable_pipestat(dev_priv, 1, 131072U);
  }
  if (*(dev->vblank_enabled + 2UL) != 0) {
    psb_enable_pipestat(dev_priv, 2, 131072U);
  } else {
    psb_disable_pipestat(dev_priv, 2, 131072U);
  }
  if ((unsigned long )(dev_priv->ops)->hotplug_enable != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                bool  ))0)) {
    (*((dev_priv->ops)->hotplug_enable))(dev, 1);
  } else {

  }
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return (0);
}
}
void psb_irq_uninstall(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  if ((unsigned long )(dev_priv->ops)->hotplug_enable != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                bool  ))0)) {
    (*((dev_priv->ops)->hotplug_enable))(dev, 0);
  } else {

  }
  iowrite32(4294967295U, (void *)dev_priv->vdc_reg + 8344U);
  if (*(dev->vblank_enabled) != 0) {
    psb_disable_pipestat(dev_priv, 0, 131072U);
  } else {

  }
  if (*(dev->vblank_enabled + 1UL) != 0) {
    psb_disable_pipestat(dev_priv, 1, 131072U);
  } else {

  }
  if (*(dev->vblank_enabled + 2UL) != 0) {
    psb_disable_pipestat(dev_priv, 2, 131072U);
  } else {

  }
  dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 1835008U;
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
  __asm__  volatile   ("sfence": : : "memory");
  tmp___0 = ioread32((void *)dev_priv->vdc_reg + 8356U);
  iowrite32(tmp___0, (void *)dev_priv->vdc_reg + 8356U);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return;
}
}
void psb_irq_turn_on_dpst(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 hist_reg ;
  u32 pwm_reg ;
  bool tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = gma_power_begin(dev, 0);
  if ((int )tmp) {
    iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 397920U);
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397920U);
    iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 397928U);
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
    iowrite32(2147549440U, (void *)dev_priv->vdc_reg + 397904U);
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
    iowrite32(pwm_reg | 50331648U, (void *)dev_priv->vdc_reg + 397904U);
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
    psb_enable_pipestat(dev_priv, 0, 8388608U);
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
    iowrite32(hist_reg | 1073741824U, (void *)dev_priv->vdc_reg + 397928U);
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
    iowrite32(pwm_reg | 2181103872U, (void *)dev_priv->vdc_reg + 397904U);
    gma_power_end(dev);
  } else {

  }
  return;
}
}
int psb_irq_enable_dpst(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  mid_enable_pipe_event(dev_priv, 0);
  psb_irq_turn_on_dpst(dev);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return (0);
}
}
void psb_irq_turn_off_dpst(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 hist_reg ;
  u32 pwm_reg ;
  bool tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = gma_power_begin(dev, 0);
  if ((int )tmp) {
    iowrite32(0U, (void *)dev_priv->vdc_reg + 397928U);
    hist_reg = ioread32((void *)dev_priv->vdc_reg + 397928U);
    psb_disable_pipestat(dev_priv, 0, 8388608U);
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
    iowrite32(pwm_reg & 4278190079U, (void *)dev_priv->vdc_reg + 397904U);
    pwm_reg = ioread32((void *)dev_priv->vdc_reg + 397904U);
    gma_power_end(dev);
  } else {

  }
  return;
}
}
int psb_irq_disable_dpst(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  mid_disable_pipe_event(dev_priv, 0);
  psb_irq_turn_off_dpst(dev);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return (0);
}
}
int psb_enable_vblank(struct drm_device *dev , int pipe ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  uint32_t reg_val ;
  uint32_t pipeconf_reg ;
  u32 tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  raw_spinlock_t *tmp___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  reg_val = 0U;
  tmp = mid_pipeconf(pipe);
  pipeconf_reg = tmp;
  if ((dev->pci_device & 65528) == 304) {
    tmp___0 = mdfld_enable_te(dev, pipe);
    return (tmp___0);
  } else {

  }
  tmp___1 = gma_power_begin(dev, 0);
  if ((int )tmp___1) {
    reg_val = REGISTER_READ(dev, pipeconf_reg);
    gma_power_end(dev);
  } else {

  }
  if ((int )reg_val >= 0) {
    return (-22);
  } else {

  }
  tmp___2 = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp___2);
  if (pipe == 0) {
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 128U;
  } else
  if (pipe == 1) {
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask | 32U;
  } else {

  }
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
  psb_enable_pipestat(dev_priv, pipe, 131072U);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return (0);
}
}
void psb_disable_vblank(struct drm_device *dev , int pipe ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if ((dev->pci_device & 65528) == 304) {
    mdfld_disable_te(dev, pipe);
  } else {

  }
  tmp = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  if (pipe == 0) {
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 4294967167U;
  } else
  if (pipe == 1) {
    dev_priv->vdc_irq_mask = dev_priv->vdc_irq_mask & 4294967263U;
  } else {

  }
  iowrite32(~ dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8360U);
  iowrite32(dev_priv->vdc_irq_mask, (void *)dev_priv->vdc_reg + 8352U);
  psb_disable_pipestat(dev_priv, pipe, 131072U);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return;
}
}
int mdfld_enable_te(struct drm_device *dev , int pipe ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  uint32_t reg_val ;
  uint32_t pipeconf_reg ;
  u32 tmp ;
  bool tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  reg_val = 0U;
  tmp = mid_pipeconf(pipe);
  pipeconf_reg = tmp;
  tmp___0 = gma_power_begin(dev, 0);
  if ((int )tmp___0) {
    reg_val = REGISTER_READ(dev, pipeconf_reg);
    gma_power_end(dev);
  } else {

  }
  if ((int )reg_val >= 0) {
    return (-22);
  } else {

  }
  tmp___1 = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp___1);
  mid_enable_pipe_event(dev_priv, pipe);
  psb_enable_pipestat(dev_priv, pipe, 4194304U);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return (0);
}
}
void mdfld_disable_te(struct drm_device *dev , int pipe ) 
{ struct drm_psb_private *dev_priv ;
  unsigned long irqflags ;
  raw_spinlock_t *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (! dev_priv->dsr_enable) {
    return;
  } else {

  }
  tmp = spinlock_check(& dev_priv->irqmask_lock);
  irqflags = _raw_spin_lock_irqsave(tmp);
  mid_disable_pipe_event(dev_priv, pipe);
  psb_disable_pipestat(dev_priv, pipe, 4194304U);
  spin_unlock_irqrestore(& dev_priv->irqmask_lock, irqflags);
  return;
}
}
u32 psb_get_vblank_counter(struct drm_device *dev , int pipe ) 
{ uint32_t high_frame ;
  uint32_t low_frame ;
  uint32_t pipeconf_reg ;
  uint32_t reg_val ;
  uint32_t high1 ;
  uint32_t high2 ;
  uint32_t low ;
  uint32_t count ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
  high_frame = 458816U;
  low_frame = 458820U;
  pipeconf_reg = 458760U;
  reg_val = 0U;
  high1 = 0U;
  high2 = 0U;
  low = 0U;
  count = 0U;
  switch (pipe) {
  case 0: ;
  goto ldv_38249;
  case 1: 
  high_frame = 462912U;
  low_frame = 462916U;
  pipeconf_reg = 462856U;
  goto ldv_38249;
  case 2: 
  high_frame = 467008U;
  low_frame = 467012U;
  pipeconf_reg = 466952U;
  goto ldv_38249;
  default: 
  dev_err((struct device  const  *)dev->dev, "%s, invalid pipe.\n", "psb_get_vblank_counter");
  return (0U);
  }
  ldv_38249: 
  tmp = gma_power_begin(dev, 0);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0U);
  } else {

  }
  reg_val = REGISTER_READ(dev, pipeconf_reg);
  if ((int )reg_val >= 0) {
    dev_err((struct device  const  *)dev->dev, "trying to get vblank count for disabled pipe %d\n",
            pipe);
    goto psb_get_vblank_counter_exit;
  } else {

  }
  ldv_38255: 
  tmp___1 = REGISTER_READ(dev, high_frame);
  high1 = tmp___1 & 65535U;
  tmp___2 = REGISTER_READ(dev, low_frame);
  low = tmp___2 >> 24;
  tmp___3 = REGISTER_READ(dev, high_frame);
  high2 = tmp___3 & 65535U;
  if (high1 != high2) {
    goto ldv_38255;
  } else {
    goto ldv_38256;
  }
  ldv_38256: 
  count = (high1 << 8) | low;
  psb_get_vblank_counter_exit: 
  gma_power_end(dev);
  return (count);
}
}
void ldv_mutex_lock_425(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_427(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_428(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_429(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_430(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_434(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_435(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_436(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_452(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_450(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_453(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_455(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_458(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_460(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_462(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_464(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_449(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_451(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_454(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_456(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_459(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_461(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_463(struct mutex *ldv_func_arg1 ) ;
extern void pci_dev_put(struct pci_dev * ) ;
extern struct pci_dev *pci_get_domain_bus_and_slot(int  , unsigned int  , unsigned int  ) ;
__inline static struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn ) 
{ struct pci_dev *tmp ;

  {
  tmp = pci_get_domain_bus_and_slot(0, bus, devfn);
  return (tmp);
}
}
extern bool drm_helper_crtc_in_use(struct drm_crtc * ) ;
void psb_intel_opregion_init(struct drm_device *dev ) ;
static int psb_output_init(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  psb_intel_lvds_init(dev, & dev_priv->mode_dev);
  psb_intel_sdvo_init(dev, 397632);
  return (0);
}
}
static void psb_init_pm(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 gating ;
  unsigned int tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = ioread32((void *)dev_priv->sgx_reg);
  gating = tmp;
  gating = gating & 4294967292U;
  gating = gating | 1U;
  iowrite32(gating, (void *)dev_priv->sgx_reg);
  ioread32((void *)dev_priv->sgx_reg);
  return;
}
}
static int psb_save_display_registers(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct drm_connector *connector ;
  struct psb_state *regs ;
  struct list_head  const  *__mptr ;
  bool tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  regs = & dev_priv->regs.ldv_38617.psb;
  regs->saveDSPARB = ioread32((void *)dev_priv->vdc_reg + 458800U);
  regs->saveDSPFW1 = ioread32((void *)dev_priv->vdc_reg + 458804U);
  regs->saveDSPFW2 = ioread32((void *)dev_priv->vdc_reg + 458808U);
  regs->saveDSPFW3 = ioread32((void *)dev_priv->vdc_reg + 458812U);
  regs->saveDSPFW4 = ioread32((void *)dev_priv->vdc_reg + 458832U);
  regs->saveDSPFW5 = ioread32((void *)dev_priv->vdc_reg + 458836U);
  regs->saveDSPFW6 = ioread32((void *)dev_priv->vdc_reg + 458840U);
  regs->saveCHICKENBIT = ioread32((void *)dev_priv->vdc_reg + 459776U);
  ldv_mutex_lock_461(& dev->mode_config.mutex);
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
  goto ldv_38029;
  ldv_38028: 
  tmp = drm_helper_crtc_in_use(crtc);
  if ((int )tmp) {
    (*((crtc->funcs)->save))(crtc);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_38029: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_38028;
  } else {
    goto ldv_38030;
  }
  ldv_38030: 
  __mptr___1 = (struct list_head  const  *)dev->mode_config.connector_list.next;
  connector = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  goto ldv_38036;
  ldv_38035: ;
  if ((unsigned long )(connector->funcs)->save != (unsigned long )((void (*/* const  */)(struct drm_connector * ))0)) {
    (*((connector->funcs)->save))(connector);
  } else {

  }
  __mptr___2 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___2 + 0xfffffffffffffb80UL;
  ldv_38036: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
    goto ldv_38035;
  } else {
    goto ldv_38037;
  }
  ldv_38037: 
  ldv_mutex_unlock_462(& dev->mode_config.mutex);
  return (0);
}
}
static int psb_restore_display_registers(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct drm_crtc *crtc ;
  struct drm_connector *connector ;
  struct psb_state *regs ;
  struct list_head  const  *__mptr ;
  bool tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  regs = & dev_priv->regs.ldv_38617.psb;
  iowrite32(regs->saveDSPARB, (void *)dev_priv->vdc_reg + 458800U);
  iowrite32(regs->saveDSPFW1, (void *)dev_priv->vdc_reg + 458804U);
  iowrite32(regs->saveDSPFW2, (void *)dev_priv->vdc_reg + 458808U);
  iowrite32(regs->saveDSPFW3, (void *)dev_priv->vdc_reg + 458812U);
  iowrite32(regs->saveDSPFW4, (void *)dev_priv->vdc_reg + 458832U);
  iowrite32(regs->saveDSPFW5, (void *)dev_priv->vdc_reg + 458836U);
  iowrite32(regs->saveDSPFW6, (void *)dev_priv->vdc_reg + 458840U);
  iowrite32(regs->saveCHICKENBIT, (void *)dev_priv->vdc_reg + 459776U);
  iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 463872U);
  ldv_mutex_lock_463(& dev->mode_config.mutex);
  __mptr = (struct list_head  const  *)dev->mode_config.crtc_list.next;
  crtc = (struct drm_crtc *)__mptr + 0xfffffffffffffff8UL;
  goto ldv_38050;
  ldv_38049: 
  tmp = drm_helper_crtc_in_use(crtc);
  if ((int )tmp) {
    (*((crtc->funcs)->restore))(crtc);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)crtc->head.next;
  crtc = (struct drm_crtc *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_38050: ;
  if ((unsigned long )(& crtc->head) != (unsigned long )(& dev->mode_config.crtc_list)) {
    goto ldv_38049;
  } else {
    goto ldv_38051;
  }
  ldv_38051: 
  __mptr___1 = (struct list_head  const  *)dev->mode_config.connector_list.next;
  connector = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  goto ldv_38057;
  ldv_38056: ;
  if ((unsigned long )(connector->funcs)->restore != (unsigned long )((void (*/* const  */)(struct drm_connector * ))0)) {
    (*((connector->funcs)->restore))(connector);
  } else {

  }
  __mptr___2 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___2 + 0xfffffffffffffb80UL;
  ldv_38057: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
    goto ldv_38056;
  } else {
    goto ldv_38058;
  }
  ldv_38058: 
  ldv_mutex_unlock_464(& dev->mode_config.mutex);
  return (0);
}
}
static int psb_power_down(struct drm_device *dev ) 
{ 

  {
  return (0);
}
}
static int psb_power_up(struct drm_device *dev ) 
{ 

  {
  return (0);
}
}
static void psb_get_core_freq(struct drm_device *dev ) 
{ uint32_t clock ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;
  struct drm_psb_private *dev_priv ;

  {
  tmp = pci_get_bus_and_slot(0U, 0U);
  pci_root = tmp;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3489989376U);
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & clock);
  pci_dev_put(pci_root);
  switch (clock & 7U) {
  case 0: 
  dev_priv->core_freq = 100U;
  goto ldv_38072;
  case 1: 
  dev_priv->core_freq = 133U;
  goto ldv_38072;
  case 2: 
  dev_priv->core_freq = 150U;
  goto ldv_38072;
  case 3: 
  dev_priv->core_freq = 178U;
  goto ldv_38072;
  case 4: 
  dev_priv->core_freq = 200U;
  goto ldv_38072;
  case 5: ;
  case 6: ;
  case 7: 
  dev_priv->core_freq = 266U;
  goto ldv_38072;
  default: 
  dev_priv->core_freq = 0U;
  }
  ldv_38072: ;
  return;
}
}
static struct psb_offset  const  psb_regmap[2U]  = {      {24640U, 24644U, 459136U, 458760U, 393244U, 24596U, 0U, 393216U, 393220U, 393224U,
      393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459140U, 459140U,
      458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 0U, 397312U, 397316U, 397320U,
      397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U, 463236U,
      462884U, 463236U, 463268U, 43008U}};
static int psb_chip_setup(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  dev_priv->regmap = (struct psb_offset  const  *)(& psb_regmap);
  psb_get_core_freq(dev);
  gma_intel_setup_gmbus(dev);
  psb_intel_opregion_init(dev);
  psb_intel_init_bios(dev);
  return (0);
}
}
static void psb_chip_teardown(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  psb_lid_timer_takedown(dev_priv);
  gma_intel_teardown_gmbus(dev);
  return;
}
}
struct psb_ops  const  psb_chip_ops  = 
     {"Poulsbo", 1U, 2, 2, 262144, 1, 2, 1, & psb_intel_helper_funcs, & psb_intel_crtc_funcs,
    & psb_chip_setup, & psb_chip_teardown, 0, & psb_output_init, 0, 0, & psb_init_pm,
    & psb_save_display_registers, & psb_restore_display_registers, & psb_power_up,
    & psb_power_down, 0, 0};
struct drm_device *psb_chip_ops_group0  ;
void ldv_main_exported_28(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_28 == 1) {
    psb_chip_teardown(psb_chip_ops_group0);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_38096;
  case 1: ;
  if (ldv_state_variable_28 == 1) {
    psb_chip_setup(psb_chip_ops_group0);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_38096;
  case 2: ;
  if (ldv_state_variable_28 == 1) {
    psb_init_pm(psb_chip_ops_group0);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_38096;
  case 3: ;
  if (ldv_state_variable_28 == 1) {
    psb_save_display_registers(psb_chip_ops_group0);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_38096;
  case 4: ;
  if (ldv_state_variable_28 == 1) {
    psb_restore_display_registers(psb_chip_ops_group0);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_38096;
  case 5: ;
  if (ldv_state_variable_28 == 1) {
    psb_power_down(psb_chip_ops_group0);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_38096;
  case 6: ;
  if (ldv_state_variable_28 == 1) {
    psb_output_init(psb_chip_ops_group0);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_38096;
  case 7: ;
  if (ldv_state_variable_28 == 1) {
    psb_power_up(psb_chip_ops_group0);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_38096;
  default: ;
  goto ldv_38096;
  }
  ldv_38096: ;
  return;
}
}
void ldv_mutex_lock_449(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_450(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_451(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_452(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_453(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_454(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_455(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_456(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_458(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_459(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_460(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_461(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_462(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_463(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_drm_mode_config(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_464(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_drm_mode_config(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_484(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_485(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_490(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_492(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_481(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_483(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_486(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_491(struct mutex *ldv_func_arg1 ) ;
__inline static void memcpy_fromio(void *dst , void const volatile   *src , size_t count ) 
{ size_t __len ;
  void *__ret ;

  {
  __len = count;
  __ret = __builtin_memcpy(dst, (void const   *)src, __len);
  return;
}
}
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
int mid_chip_setup(struct drm_device *dev ) ;
static void mid_get_fuse_settings(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;
  uint32_t fuse_value ;
  uint32_t fuse_value_tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  char *tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = pci_get_bus_and_slot(0U, 0U);
  pci_root = tmp;
  fuse_value = 0U;
  fuse_value_tmp = 0U;
  if ((unsigned long )pci_root == (unsigned long )((struct pci_dev *)0)) {
    __ret_warn_on = 1;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c.prepared",
                         192);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    return;
  } else {

  }
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3498116608U);
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & fuse_value);
  if ((dev->pci_device & 65532) == 16640) {
    dev_priv->iLVDS_enable = fuse_value & 2048U;
  } else {

  }
  if (dev_priv->iLVDS_enable != 0U) {
    tmp___1 = (char *)"LVDS display";
  } else {
    tmp___1 = (char *)"MIPI display";
  }
  printk("\016[drm] internal display is %s\n", tmp___1);
  if (dev_priv->iLVDS_enable != 0U) {
    dev_priv->is_lvds_on = 1;
    dev_priv->is_mipi_on = 0;
  } else {
    dev_priv->is_mipi_on = 1;
    dev_priv->is_lvds_on = 0;
  }
  dev_priv->video_device_fuse = fuse_value;
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3498117376U);
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & fuse_value);
  descriptor.modname = "gma500_gfx";
  descriptor.function = "mid_get_fuse_settings";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c.prepared";
  descriptor.format = "SKU values is 0x%x.\n";
  descriptor.lineno = 221U;
  descriptor.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "SKU values is 0x%x.\n",
                      fuse_value);
  } else {

  }
  fuse_value_tmp = (fuse_value & 28672U) >> 12;
  dev_priv->fuse_reg_value = fuse_value;
  switch (fuse_value_tmp) {
  case 0: 
  dev_priv->core_freq = 200U;
  goto ldv_37978;
  case 1: 
  dev_priv->core_freq = 100U;
  goto ldv_37978;
  case 2: 
  dev_priv->core_freq = 166U;
  goto ldv_37978;
  default: 
  dev_warn((struct device  const  *)dev->dev, "Invalid SKU values, SKU value = 0x%08x\n",
           fuse_value_tmp);
  dev_priv->core_freq = 0U;
  }
  ldv_37978: 
  descriptor___0.modname = "gma500_gfx";
  descriptor___0.function = "mid_get_fuse_settings";
  descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c.prepared";
  descriptor___0.format = "LNC core clk is %dMHz.\n";
  descriptor___0.lineno = 241U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "LNC core clk is %dMHz.\n",
                      dev_priv->core_freq);
  } else {

  }
  pci_dev_put(pci_root);
  return;
}
}
static void mid_get_pci_revID(struct drm_psb_private *dev_priv ) 
{ uint32_t platform_rev_id ;
  struct pci_dev *pci_gfx_root ;
  struct pci_dev *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  platform_rev_id = 0U;
  tmp = pci_get_bus_and_slot(0U, 16U);
  pci_gfx_root = tmp;
  if ((unsigned long )pci_gfx_root == (unsigned long )((struct pci_dev *)0)) {
    __ret_warn_on = 1;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c.prepared",
                         254);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    return;
  } else {

  }
  pci_read_config_dword((struct pci_dev  const  *)pci_gfx_root, 8, & platform_rev_id);
  dev_priv->platform_rev_id = (unsigned char )platform_rev_id;
  pci_dev_put(pci_gfx_root);
  descriptor.modname = "gma500_gfx";
  descriptor.function = "mid_get_pci_revID";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c.prepared";
  descriptor.format = "platform_rev_id is %x\n";
  descriptor.lineno = 261U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(dev_priv->dev)->dev,
                      "platform_rev_id is %x\n", (int )dev_priv->platform_rev_id);
  } else {

  }
  return;
}
}
static int read_vbt_r0(u32 addr , struct vbt_r0 *vbt ) 
{ void *vbt_virtual ;

  {
  vbt_virtual = ioremap((resource_size_t )addr, 7UL);
  if ((unsigned long )vbt_virtual == (unsigned long )((void *)0)) {
    return (-1);
  } else {

  }
  memcpy_fromio((void *)vbt, (void const volatile   *)vbt_virtual, 7UL);
  iounmap((void volatile   *)vbt_virtual);
  return (0);
}
}
static int read_vbt_r10(u32 addr , struct vbt_r10 *vbt ) 
{ void *vbt_virtual ;

  {
  vbt_virtual = ioremap((resource_size_t )addr, 16UL);
  if ((unsigned long )vbt_virtual == (unsigned long )((void *)0)) {
    return (-1);
  } else {

  }
  memcpy_fromio((void *)vbt, (void const volatile   *)vbt_virtual, 16UL);
  iounmap((void volatile   *)vbt_virtual);
  return (0);
}
}
static int mid_get_vbt_data_r0(struct drm_psb_private *dev_priv , u32 addr ) 
{ struct vbt_r0 vbt ;
  void *gct_virtual ;
  struct gct_r0 gct ;
  u8 bpi ;
  int tmp ;

  {
  tmp = read_vbt_r0(addr, & vbt);
  if (tmp != 0) {
    return (-1);
  } else {

  }
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 7UL), (unsigned long )vbt.size - 7UL);
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
    return (-1);
  } else {

  }
  memcpy_fromio((void *)(& gct), (void const volatile   *)gct_virtual, 161UL);
  iounmap((void volatile   *)gct_virtual);
  bpi = gct.ldv_37334.PD.BootPanelIndex;
  dev_priv->gct_data.bpi = bpi;
  dev_priv->gct_data.pt = gct.ldv_37334.PD.PanelType;
  dev_priv->gct_data.DTD = gct.panel[(int )bpi].DTD;
  dev_priv->gct_data.Panel_Port_Control = gct.panel[(int )bpi].Panel_Port_Control;
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = gct.panel[(int )bpi].Panel_MIPI_Display_Descriptor;
  return (0);
}
}
static int mid_get_vbt_data_r1(struct drm_psb_private *dev_priv , u32 addr ) 
{ struct vbt_r0 vbt ;
  void *gct_virtual ;
  struct gct_r1 gct ;
  u8 bpi ;
  int tmp ;

  {
  tmp = read_vbt_r0(addr, & vbt);
  if (tmp != 0) {
    return (-1);
  } else {

  }
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 7UL), (unsigned long )vbt.size - 7UL);
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
    return (-1);
  } else {

  }
  memcpy_fromio((void *)(& gct), (void const volatile   *)gct_virtual, 153UL);
  iounmap((void volatile   *)gct_virtual);
  bpi = gct.ldv_37345.PD.BootPanelIndex;
  dev_priv->gct_data.bpi = bpi;
  dev_priv->gct_data.pt = gct.ldv_37345.PD.PanelType;
  dev_priv->gct_data.DTD = gct.panel[(int )bpi].DTD;
  dev_priv->gct_data.Panel_Port_Control = gct.panel[(int )bpi].Panel_Port_Control;
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = gct.panel[(int )bpi].Panel_MIPI_Display_Descriptor;
  return (0);
}
}
static int mid_get_vbt_data_r10(struct drm_psb_private *dev_priv , u32 addr ) 
{ struct vbt_r10 vbt ;
  void *gct_virtual ;
  struct gct_r10 *gct ;
  struct oaktrail_timing_info *dp_ti ;
  struct gct_r10_timing_info *ti ;
  int ret ;
  int tmp ;
  void *tmp___0 ;

  {
  dp_ti = & dev_priv->gct_data.DTD;
  ret = -1;
  tmp = read_vbt_r10(addr, & vbt);
  if (tmp != 0) {
    return (-1);
  } else {

  }
  tmp___0 = kmalloc((unsigned long )vbt.panel_count * 28UL, 208U);
  gct = (struct gct_r10 *)tmp___0;
  if ((unsigned long )gct == (unsigned long )((struct gct_r10 *)0)) {
    return (-1);
  } else {

  }
  gct_virtual = ioremap((resource_size_t )((unsigned long )addr + 16UL), (unsigned long )vbt.panel_count * 28UL);
  if ((unsigned long )gct_virtual == (unsigned long )((void *)0)) {
    goto out;
  } else {

  }
  memcpy_fromio((void *)gct, (void const volatile   *)gct_virtual, 28UL);
  iounmap((void volatile   *)gct_virtual);
  dev_priv->gct_data.bpi = vbt.primary_panel_idx;
  dev_priv->gct_data.Panel_MIPI_Display_Descriptor = (gct + (unsigned long )vbt.primary_panel_idx)->Panel_MIPI_Display_Descriptor;
  ti = & (gct + (unsigned long )vbt.primary_panel_idx)->DTD;
  dp_ti->pixel_clock = ti->pixel_clock;
  dp_ti->hactive_hi = ti->hactive_hi;
  dp_ti->hactive_lo = ti->hactive_lo;
  dp_ti->hblank_hi = ti->hblank_hi;
  dp_ti->hblank_lo = ti->hblank_lo;
  dp_ti->hsync_offset_hi = ti->hsync_offset_hi;
  dp_ti->hsync_offset_lo = ti->hsync_offset_lo;
  dp_ti->hsync_pulse_width_hi = ti->hsync_pulse_width_hi;
  dp_ti->hsync_pulse_width_lo = ti->hsync_pulse_width_lo;
  dp_ti->vactive_hi = ti->vactive_hi;
  dp_ti->vactive_lo = ti->vactive_lo;
  dp_ti->vblank_hi = ti->vblank_hi;
  dp_ti->vblank_lo = ti->vblank_lo;
  dp_ti->vsync_offset_hi = ti->vsync_offset_hi;
  dp_ti->vsync_offset_lo = ti->vsync_offset_lo;
  dp_ti->vsync_pulse_width_hi = ti->vsync_pulse_width_hi;
  dp_ti->vsync_pulse_width_lo = ti->vsync_pulse_width_lo;
  ret = 0;
  out: 
  kfree((void const   *)gct);
  return (ret);
}
}
static void mid_get_vbt_data(struct drm_psb_private *dev_priv ) 
{ struct drm_device *dev ;
  u32 addr ;
  u8 *vbt_virtual ;
  struct mid_vbt_header vbt_header ;
  struct pci_dev *pci_gfx_root ;
  struct pci_dev *tmp ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;

  {
  dev = dev_priv->dev;
  tmp = pci_get_bus_and_slot(0U, 16U);
  pci_gfx_root = tmp;
  ret = -1;
  pci_read_config_dword((struct pci_dev  const  *)pci_gfx_root, 252, & addr);
  pci_dev_put(pci_gfx_root);
  descriptor.modname = "gma500_gfx";
  descriptor.function = "mid_get_vbt_data";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c.prepared";
  descriptor.format = "drm platform config address is %x\n";
  descriptor.lineno = 435U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "drm platform config address is %x\n",
                      addr);
  } else {

  }
  if (addr == 0U) {
    goto out;
  } else {

  }
  tmp___1 = ioremap((resource_size_t )addr, 5UL);
  vbt_virtual = (u8 *)tmp___1;
  if ((unsigned long )vbt_virtual == (unsigned long )((u8 *)0)) {
    goto out;
  } else {

  }
  memcpy_fromio((void *)(& vbt_header), (void const volatile   *)vbt_virtual, 5UL);
  iounmap((void volatile   *)vbt_virtual);
  tmp___2 = memcmp((void const   *)(& vbt_header.signature), (void const   *)"$GCT",
                   4UL);
  if (tmp___2 != 0) {
    goto out;
  } else {

  }
  descriptor___0.modname = "gma500_gfx";
  descriptor___0.function = "mid_get_vbt_data";
  descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/mid_bios.c.prepared";
  descriptor___0.format = "GCT revision is %02x\n";
  descriptor___0.lineno = 451U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "GCT revision is %02x\n",
                      (int )vbt_header.revision);
  } else {

  }
  switch ((int )vbt_header.revision) {
  case 0: 
  ret = mid_get_vbt_data_r0(dev_priv, addr);
  goto ldv_38058;
  case 1: 
  ret = mid_get_vbt_data_r1(dev_priv, addr);
  goto ldv_38058;
  case 16: 
  ret = mid_get_vbt_data_r10(dev_priv, addr);
  goto ldv_38058;
  default: 
  dev_err((struct device  const  *)dev->dev, "Unknown revision of GCT!\n");
  }
  ldv_38058: ;
  out: ;
  if (ret != 0) {
    dev_err((struct device  const  *)dev->dev, "Unable to read GCT!");
  } else {
    dev_priv->has_gct = 1;
  }
  return;
}
}
int mid_chip_setup(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mid_get_fuse_settings(dev);
  mid_get_vbt_data(dev_priv);
  mid_get_pci_revID(dev_priv);
  return (0);
}
}
void ldv_mutex_lock_481(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_482(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_483(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_484(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_485(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_486(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_489(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_490(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_491(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_492(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_508(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_509(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_511(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_513(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_514(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_516(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_507(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_510(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_515(struct mutex *ldv_func_arg1 ) ;
extern void *ioremap_cache(resource_size_t  , unsigned long  ) ;
extern int register_acpi_notifier(struct notifier_block * ) ;
extern int unregister_acpi_notifier(struct notifier_block * ) ;
__inline static void *acpi_os_ioremap(acpi_physical_address phys , acpi_size size ) 
{ void *tmp ;

  {
  tmp = ioremap_cache(phys, (unsigned long )size);
  return (tmp);
}
}
static struct psb_intel_opregion *system_opregion  ;
static u32 asle_set_backlight(struct drm_device *dev , u32 bclp ) 
{ struct drm_psb_private *dev_priv ;
  struct opregion_asle *asle ;
  struct backlight_device *bd ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  asle = dev_priv->opregion.asle;
  bd = dev_priv->backlight_device;
  drm_ut_debug_printk(2U, "drm", "asle_set_backlight", "asle set backlight %x\n",
                      bclp);
  if ((int )bclp >= 0) {
    return (4096U);
  } else {

  }
  if ((unsigned long )bd == (unsigned long )((struct backlight_device *)0)) {
    return (4096U);
  } else {

  }
  bclp = bclp & 2147483647U;
  if (bclp > 255U) {
    return (4096U);
  } else {

  }
  asle->cblv = (bclp * 100U) / 255U | 2147483648U;
  return (0U);
}
}
void psb_intel_opregion_asle_intr(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct opregion_asle *asle ;
  u32 asle_stat ;
  u32 asle_req ;
  u32 tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  asle = dev_priv->opregion.asle;
  asle_stat = 0U;
  if ((unsigned long )asle == (unsigned long )((struct opregion_asle *)0)) {
    return;
  } else {

  }
  asle_req = asle->aslc & 15U;
  if (asle_req == 0U) {
    drm_ut_debug_printk(2U, "drm", "psb_intel_opregion_asle_intr", "non asle set request??\n");
    return;
  } else {

  }
  if ((asle_req & 2U) != 0U) {
    tmp = asle_set_backlight(dev, asle->bclp);
    asle_stat = tmp | asle_stat;
  } else {

  }
  asle->aslc = asle_stat;
  return;
}
}
void psb_intel_opregion_enable_asle(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct opregion_asle *asle ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  asle = dev_priv->opregion.asle;
  if ((unsigned long )asle != (unsigned long )((struct opregion_asle *)0) && (unsigned long )system_opregion != (unsigned long )((struct psb_intel_opregion *)0)) {
    psb_enable_pipestat(dev_priv, 0, 4194304U);
    psb_enable_pipestat(dev_priv, 1, 4194304U);
    asle->tche = 15U;
    asle->ardy = 1U;
  } else {

  }
  return;
}
}
static int psb_intel_opregion_video_event(struct notifier_block *nb , unsigned long val ,
                                          void *data ) 
{ struct opregion_acpi *acpi ;

  {
  if ((unsigned long )system_opregion == (unsigned long )((struct psb_intel_opregion *)0)) {
    return (0);
  } else {

  }
  acpi = system_opregion->acpi;
  acpi->csts = 0U;
  return (1);
}
}
static struct notifier_block psb_intel_opregion_notifier  =    {& psb_intel_opregion_video_event, 0, 0};
void psb_intel_opregion_init(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  opregion = & dev_priv->opregion;
  if ((unsigned long )opregion->header == (unsigned long )((struct opregion_header *)0)) {
    return;
  } else {

  }
  if ((unsigned long )opregion->acpi != (unsigned long )((struct opregion_acpi *)0)) {
    (opregion->acpi)->csts = 0U;
    (opregion->acpi)->drdy = 1U;
    system_opregion = opregion;
    register_acpi_notifier(& psb_intel_opregion_notifier);
  } else {

  }
  return;
}
}
void psb_intel_opregion_fini(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  opregion = & dev_priv->opregion;
  if ((unsigned long )opregion->header == (unsigned long )((struct opregion_header *)0)) {
    return;
  } else {

  }
  if ((unsigned long )opregion->acpi != (unsigned long )((struct opregion_acpi *)0)) {
    (opregion->acpi)->drdy = 0U;
    system_opregion = 0;
    unregister_acpi_notifier(& psb_intel_opregion_notifier);
  } else {

  }
  iounmap((void volatile   *)opregion->header);
  opregion->header = 0;
  opregion->acpi = 0;
  opregion->swsci = 0;
  opregion->asle = 0;
  opregion->vbt = 0;
  return;
}
}
int psb_intel_opregion_setup(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_opregion *opregion ;
  u32 opregion_phy ;
  u32 mboxes ;
  void *base ;
  int err ;
  int tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  opregion = & dev_priv->opregion;
  err = 0;
  pci_read_config_dword((struct pci_dev  const  *)dev->pdev, 252, & opregion_phy);
  if (opregion_phy == 0U) {
    drm_ut_debug_printk(2U, "drm", "psb_intel_opregion_setup", "ACPI Opregion not supported\n");
    return (-524);
  } else {

  }
  drm_ut_debug_printk(1U, "drm", "psb_intel_opregion_setup", "OpRegion detected at 0x%8x\n",
                      opregion_phy);
  base = acpi_os_ioremap((acpi_physical_address )opregion_phy, 8192ULL);
  if ((unsigned long )base == (unsigned long )((void *)0)) {
    return (-12);
  } else {

  }
  tmp = memcmp((void const   *)base, (void const   *)"IntelGraphicsMem", 16UL);
  if (tmp != 0) {
    drm_ut_debug_printk(2U, "drm", "psb_intel_opregion_setup", "opregion signature mismatch\n");
    err = -22;
    goto err_out;
  } else {

  }
  opregion->header = (struct opregion_header *)base;
  opregion->vbt = base + 1024UL;
  opregion->lid_state = (u32 *)base + 428U;
  mboxes = (opregion->header)->mboxes;
  if ((int )mboxes & 1) {
    drm_ut_debug_printk(2U, "drm", "psb_intel_opregion_setup", "Public ACPI methods supported\n");
    opregion->acpi = (struct opregion_acpi *)base + 256U;
  } else {

  }
  if ((mboxes & 4U) != 0U) {
    drm_ut_debug_printk(2U, "drm", "psb_intel_opregion_setup", "ASLE supported\n");
    opregion->asle = (struct opregion_asle *)base + 768U;
  } else {

  }
  return (0);
  err_out: 
  iounmap((void volatile   *)base);
  return (err);
}
}
void *ldvarg39  ;
unsigned long ldvarg40  ;
struct notifier_block *ldvarg38  ;
void ldv_main_exported_27(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_27 == 1) {
    psb_intel_opregion_video_event(ldvarg38, ldvarg40, ldvarg39);
    ldv_state_variable_27 = 1;
  } else {

  }
  goto ldv_41096;
  default: ;
  goto ldv_41096;
  }
  ldv_41096: ;
  return;
}
}
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_507(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_508(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_509(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_510(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_511(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_513(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_514(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_515(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_516(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
int ldv_mutex_trylock_532(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_530(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_533(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_535(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_537(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_538(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_529(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_531(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_534(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_536(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_539(struct mutex *ldv_func_arg1 ) ;
extern void __init_work(struct work_struct * , int  ) ;
extern bool schedule_work(struct work_struct * ) ;
__inline static void outb(unsigned char value , int port ) 
{ 

  {
  __asm__  volatile   ("outb %b0, %w1": : "a" (value), "Nd" (port));
  return;
}
}
__inline static unsigned char inb(int port ) 
{ unsigned char value ;

  {
  __asm__  volatile   ("inb %w1, %b0": "=a" (value): "Nd" (port));
  return (value);
}
}
__inline static void outl(unsigned int value , int port ) 
{ 

  {
  __asm__  volatile   ("outl %0, %w1": : "a" (value), "Nd" (port));
  return;
}
}
__inline static unsigned int inl(int port ) 
{ unsigned int value ;

  {
  __asm__  volatile   ("inl %w1, %0": "=a" (value): "Nd" (port));
  return (value);
}
}
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ int tmp ;

  {
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ int tmp ;

  {
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
  return (tmp);
}
}
extern int pci_enable_msi_block(struct pci_dev * , unsigned int  ) ;
extern void drm_mode_config_reset(struct drm_device * ) ;
extern int drm_helper_resume_force_mode(struct drm_device * ) ;
extern void drm_helper_hpd_irq_event(struct drm_device * ) ;
void cdv_intel_dp_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                       int output_reg ) ;
void cdv_intel_attach_force_audio_property(struct drm_connector *connector ) ;
void cdv_intel_attach_broadcast_rgb_property(struct drm_connector *connector ) ;
struct drm_crtc_helper_funcs  const  cdv_intel_helper_funcs ;
struct drm_crtc_funcs  const  cdv_intel_crtc_funcs ;
void cdv_intel_crt_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
void cdv_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
void cdv_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                   int reg ) ;
static void cdv_disable_vga(struct drm_device *dev ) 
{ u8 sr1 ;
  u32 vga_reg ;

  {
  vga_reg = 463872U;
  outb(1, 964);
  sr1 = inb(965);
  outb((int )((unsigned int )sr1 | 32U), 965);
  __const_udelay(1288500UL);
  REGISTER_WRITE(dev, vga_reg, 2147483648U);
  REGISTER_READ(dev, vga_reg);
  return;
}
}
static int cdv_output_init(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  drm_mode_create_scaling_mode_property(dev);
  cdv_disable_vga(dev);
  cdv_intel_crt_init(dev, & dev_priv->mode_dev);
  cdv_intel_lvds_init(dev, & dev_priv->mode_dev);
  tmp___0 = REGISTER_READ(dev, 397632U);
  if ((tmp___0 & 4U) != 0U) {
    cdv_hdmi_init(dev, & dev_priv->mode_dev, 397632);
    tmp = REGISTER_READ(dev, 409856U);
    if ((tmp & 4U) != 0U) {
      cdv_intel_dp_init(dev, & dev_priv->mode_dev, 409856);
    } else {

    }
  } else {

  }
  tmp___2 = REGISTER_READ(dev, 397664U);
  if ((tmp___2 & 4U) != 0U) {
    cdv_hdmi_init(dev, & dev_priv->mode_dev, 397664);
    tmp___1 = REGISTER_READ(dev, 410112U);
    if ((tmp___1 & 4U) != 0U) {
      cdv_intel_dp_init(dev, & dev_priv->mode_dev, 410112);
    } else {

    }
  } else {

  }
  return (0);
}
}
__inline static u32 CDV_MSG_READ32(uint port , uint offset ) 
{ int mcr ;
  uint32_t ret_val ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;

  {
  mcr = (int )(((port << 16) | (offset << 8)) | 268435456U);
  ret_val = 0U;
  tmp = pci_get_bus_and_slot(0U, 0U);
  pci_root = tmp;
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, (u32 )mcr);
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & ret_val);
  pci_dev_put(pci_root);
  return (ret_val);
}
}
__inline static void CDV_MSG_WRITE32(uint port , uint offset , u32 value ) 
{ int mcr ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;

  {
  mcr = (int )(((port << 16) | (offset << 8)) | 285212912U);
  tmp = pci_get_bus_and_slot(0U, 0U);
  pci_root = tmp;
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 212, value);
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, (u32 )mcr);
  pci_dev_put(pci_root);
  return;
}
}
static void cdv_init_pm(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  int i ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 pwr_sts ;
  unsigned int tmp___1 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = CDV_MSG_READ32(4U, 122U);
  dev_priv->apm_base = (uint16_t )tmp;
  tmp___0 = CDV_MSG_READ32(4U, 120U);
  dev_priv->ospm_base = tmp___0 & 65535U;
  pwr_cnt = inl((int )dev_priv->apm_base);
  pwr_cnt = pwr_cnt & 4294967292U;
  pwr_cnt = pwr_cnt | 2U;
  outl(pwr_cnt, (int )dev_priv->apm_base);
  i = 0;
  goto ldv_38045;
  ldv_38044: 
  tmp___1 = inl((int )dev_priv->apm_base + 4);
  pwr_sts = tmp___1;
  if ((pwr_sts & 3U) == 0U) {
    return;
  } else {

  }
  __const_udelay(42950UL);
  i = i + 1;
  ldv_38045: ;
  if (i <= 4) {
    goto ldv_38044;
  } else {
    goto ldv_38046;
  }
  ldv_38046: 
  dev_err((struct device  const  *)dev->dev, "GPU: power management timed out.\n");
  return;
}
}
static void cdv_errata(struct drm_device *dev ) 
{ 

  {
  CDV_MSG_WRITE32(3U, 48U, 134377736U);
  return;
}
}
static int cdv_save_display_registers(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct drm_connector *connector ;
  struct _ddebug descriptor ;
  long tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  regs = & dev_priv->regs;
  descriptor.modname = "gma500_gfx";
  descriptor.function = "cdv_save_display_registers";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_device.c.prepared";
  descriptor.format = "Saving GPU registers.\n";
  descriptor.lineno = 413U;
  descriptor.flags = 0U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "Saving GPU registers.\n");
  } else {

  }
  pci_read_config_byte((struct pci_dev  const  *)dev->pdev, 244, & regs->ldv_38617.cdv.saveLBB);
  regs->ldv_38617.cdv.saveDSPCLK_GATE_D = REGISTER_READ(dev, 25088U);
  regs->ldv_38617.cdv.saveRAMCLK_GATE_D = REGISTER_READ(dev, 25104U);
  regs->ldv_38617.cdv.saveDSPARB = REGISTER_READ(dev, 458800U);
  regs->ldv_38617.cdv.saveDSPFW[0] = REGISTER_READ(dev, 458804U);
  regs->ldv_38617.cdv.saveDSPFW[1] = REGISTER_READ(dev, 458808U);
  regs->ldv_38617.cdv.saveDSPFW[2] = REGISTER_READ(dev, 458812U);
  regs->ldv_38617.cdv.saveDSPFW[3] = REGISTER_READ(dev, 458832U);
  regs->ldv_38617.cdv.saveDSPFW[4] = REGISTER_READ(dev, 458836U);
  regs->ldv_38617.cdv.saveDSPFW[5] = REGISTER_READ(dev, 458840U);
  regs->ldv_38617.cdv.saveADPA = REGISTER_READ(dev, 397568U);
  regs->ldv_38617.cdv.savePP_CONTROL = REGISTER_READ(dev, 397828U);
  regs->ldv_38617.cdv.savePFIT_PGM_RATIOS = REGISTER_READ(dev, 397876U);
  regs->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
  regs->saveBLC_PWM_CTL2 = REGISTER_READ(dev, 397904U);
  regs->ldv_38617.cdv.saveLVDS = REGISTER_READ(dev, 397696U);
  regs->ldv_38617.cdv.savePFIT_CONTROL = REGISTER_READ(dev, 397872U);
  regs->ldv_38617.cdv.savePP_ON_DELAYS = REGISTER_READ(dev, 397832U);
  regs->ldv_38617.cdv.savePP_OFF_DELAYS = REGISTER_READ(dev, 397836U);
  regs->ldv_38617.cdv.savePP_CYCLE = REGISTER_READ(dev, 397840U);
  regs->ldv_38617.cdv.saveVGACNTRL = REGISTER_READ(dev, 463872U);
  regs->ldv_38617.cdv.saveIER = REGISTER_READ(dev, 8352U);
  regs->ldv_38617.cdv.saveIMR = REGISTER_READ(dev, 8360U);
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
  connector = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
  goto ldv_38063;
  ldv_38062: 
  (*((connector->funcs)->dpms))(connector, 3);
  __mptr___0 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  ldv_38063: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
    goto ldv_38062;
  } else {
    goto ldv_38064;
  }
  ldv_38064: ;
  return (0);
}
}
static int cdv_restore_display_registers(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct drm_connector *connector ;
  u32 temp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  regs = & dev_priv->regs;
  pci_write_config_byte((struct pci_dev  const  *)dev->pdev, 244, (int )regs->ldv_38617.cdv.saveLBB);
  REGISTER_WRITE(dev, 25088U, regs->ldv_38617.cdv.saveDSPCLK_GATE_D);
  REGISTER_WRITE(dev, 25104U, regs->ldv_38617.cdv.saveRAMCLK_GATE_D);
  REGISTER_WRITE(dev, 8464U, 0U);
  REGISTER_WRITE(dev, 8464U, 5U);
  temp = REGISTER_READ(dev, 24596U);
  if ((temp & 536870912U) == 0U) {
    REGISTER_WRITE(dev, 24596U, temp | 536870912U);
    REGISTER_READ(dev, 24596U);
  } else {

  }
  temp = REGISTER_READ(dev, 24600U);
  if ((temp & 536870912U) == 0U) {
    REGISTER_WRITE(dev, 24600U, temp | 536870912U);
    REGISTER_READ(dev, 24600U);
  } else {

  }
  __const_udelay(2147500UL);
  REGISTER_WRITE(dev, 458804U, regs->ldv_38617.cdv.saveDSPFW[0]);
  REGISTER_WRITE(dev, 458808U, regs->ldv_38617.cdv.saveDSPFW[1]);
  REGISTER_WRITE(dev, 458812U, regs->ldv_38617.cdv.saveDSPFW[2]);
  REGISTER_WRITE(dev, 458832U, regs->ldv_38617.cdv.saveDSPFW[3]);
  REGISTER_WRITE(dev, 458836U, regs->ldv_38617.cdv.saveDSPFW[4]);
  REGISTER_WRITE(dev, 458840U, regs->ldv_38617.cdv.saveDSPFW[5]);
  REGISTER_WRITE(dev, 458800U, regs->ldv_38617.cdv.saveDSPARB);
  REGISTER_WRITE(dev, 397568U, regs->ldv_38617.cdv.saveADPA);
  REGISTER_WRITE(dev, 397904U, regs->saveBLC_PWM_CTL2);
  REGISTER_WRITE(dev, 397696U, regs->ldv_38617.cdv.saveLVDS);
  REGISTER_WRITE(dev, 397872U, regs->ldv_38617.cdv.savePFIT_CONTROL);
  REGISTER_WRITE(dev, 397876U, regs->ldv_38617.cdv.savePFIT_PGM_RATIOS);
  REGISTER_WRITE(dev, 397908U, regs->saveBLC_PWM_CTL);
  REGISTER_WRITE(dev, 397832U, regs->ldv_38617.cdv.savePP_ON_DELAYS);
  REGISTER_WRITE(dev, 397836U, regs->ldv_38617.cdv.savePP_OFF_DELAYS);
  REGISTER_WRITE(dev, 397840U, regs->ldv_38617.cdv.savePP_CYCLE);
  REGISTER_WRITE(dev, 397828U, regs->ldv_38617.cdv.savePP_CONTROL);
  REGISTER_WRITE(dev, 463872U, regs->ldv_38617.cdv.saveVGACNTRL);
  REGISTER_WRITE(dev, 8352U, regs->ldv_38617.cdv.saveIER);
  REGISTER_WRITE(dev, 8360U, regs->ldv_38617.cdv.saveIMR);
  cdv_errata(dev);
  drm_mode_config_reset(dev);
  __mptr = (struct list_head  const  *)dev->mode_config.connector_list.next;
  connector = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
  goto ldv_38077;
  ldv_38076: 
  (*((connector->funcs)->dpms))(connector, 0);
  __mptr___0 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  ldv_38077: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& dev->mode_config.connector_list)) {
    goto ldv_38076;
  } else {
    goto ldv_38078;
  }
  ldv_38078: 
  drm_helper_resume_force_mode(dev);
  return (0);
}
}
static int cdv_power_down(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  int tries ;
  int tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tries = 5;
  pwr_cnt = inl((int )dev_priv->apm_base);
  pwr_cnt = pwr_cnt & 4294967292U;
  pwr_cnt = pwr_cnt | 1U;
  pwr_mask = 3U;
  outl(pwr_cnt, (int )dev_priv->apm_base);
  goto ldv_38088;
  ldv_38087: 
  pwr_sts = inl((int )dev_priv->apm_base + 4);
  if ((pwr_sts & pwr_mask) == 3U) {
    return (0);
  } else {

  }
  __const_udelay(42950UL);
  ldv_38088: 
  tmp = tries;
  tries = tries - 1;
  if (tmp != 0) {
    goto ldv_38087;
  } else {
    goto ldv_38089;
  }
  ldv_38089: ;
  return (0);
}
}
static int cdv_power_up(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 pwr_cnt ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  int tries ;
  int tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tries = 5;
  pwr_cnt = inl((int )dev_priv->apm_base);
  pwr_cnt = pwr_cnt & 4294967292U;
  pwr_cnt = pwr_cnt | 2U;
  pwr_mask = 3U;
  outl(pwr_cnt, (int )dev_priv->apm_base);
  goto ldv_38099;
  ldv_38098: 
  pwr_sts = inl((int )dev_priv->apm_base + 4);
  if ((pwr_sts & pwr_mask) == 0U) {
    return (0);
  } else {

  }
  __const_udelay(42950UL);
  ldv_38099: 
  tmp = tries;
  tries = tries - 1;
  if (tmp != 0) {
    goto ldv_38098;
  } else {
    goto ldv_38100;
  }
  ldv_38100: ;
  return (0);
}
}
static void cdv_get_core_freq(struct drm_device *dev ) 
{ uint32_t clock ;
  struct pci_dev *pci_root ;
  struct pci_dev *tmp ;
  struct drm_psb_private *dev_priv ;

  {
  tmp = pci_get_bus_and_slot(0U, 0U);
  pci_root = tmp;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pci_write_config_dword((struct pci_dev  const  *)pci_root, 208, 3489989376U);
  pci_read_config_dword((struct pci_dev  const  *)pci_root, 212, & clock);
  pci_dev_put(pci_root);
  switch (clock & 7U) {
  case 0: 
  dev_priv->core_freq = 100U;
  goto ldv_38108;
  case 1: 
  dev_priv->core_freq = 133U;
  goto ldv_38108;
  case 2: 
  dev_priv->core_freq = 150U;
  goto ldv_38108;
  case 3: 
  dev_priv->core_freq = 178U;
  goto ldv_38108;
  case 4: 
  dev_priv->core_freq = 200U;
  goto ldv_38108;
  case 5: ;
  case 6: ;
  case 7: 
  dev_priv->core_freq = 266U;
  goto ldv_38108;
  default: 
  dev_priv->core_freq = 0U;
  }
  ldv_38108: ;
  return;
}
}
static void cdv_hotplug_work_func(struct work_struct *work ) 
{ struct drm_psb_private *dev_priv ;
  struct work_struct  const  *__mptr ;
  struct drm_device *dev ;

  {
  __mptr = (struct work_struct  const  *)work;
  dev_priv = (struct drm_psb_private *)__mptr + 0xffffffffffffee80UL;
  dev = dev_priv->dev;
  drm_helper_hpd_irq_event(dev);
  return;
}
}
static int cdv_hotplug_event(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  uint32_t tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  schedule_work(& dev_priv->hotplug_work);
  tmp = REGISTER_READ(dev, 397588U);
  REGISTER_WRITE(dev, 397588U, tmp);
  return (1);
}
}
static void cdv_hotplug_enable(struct drm_device *dev , bool on ) 
{ u32 hotplug ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  if ((int )on) {
    tmp = REGISTER_READ(dev, 397584U);
    hotplug = tmp;
    hotplug = hotplug | 939524608U;
    REGISTER_WRITE(dev, 397584U, hotplug);
  } else {
    REGISTER_WRITE(dev, 397584U, 0U);
    tmp___0 = REGISTER_READ(dev, 397588U);
    REGISTER_WRITE(dev, 397588U, tmp___0);
  }
  return;
}
}
static char const   *force_audio_names[3U]  = {      "off",      "auto",      "on"};
void cdv_intel_attach_force_audio_property(struct drm_connector *connector ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_property *prop ;
  int i ;

  {
  dev = connector->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  prop = dev_priv->force_audio_property;
  if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
    prop = drm_property_create(dev, 8, "audio", 3);
    if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
      return;
    } else {

    }
    i = 0;
    goto ldv_38146;
    ldv_38145: 
    drm_property_add_enum(prop, i, (uint64_t )(i + -1), force_audio_names[i]);
    i = i + 1;
    ldv_38146: ;
    if ((unsigned int )i <= 2U) {
      goto ldv_38145;
    } else {
      goto ldv_38147;
    }
    ldv_38147: 
    dev_priv->force_audio_property = prop;
  } else {

  }
  drm_object_attach_property(& connector->base, prop, 0ULL);
  return;
}
}
static char const   *broadcast_rgb_names[2U]  = {      "Full",      "Limited 16:235"};
void cdv_intel_attach_broadcast_rgb_property(struct drm_connector *connector ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_property *prop ;
  int i ;

  {
  dev = connector->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  prop = dev_priv->broadcast_rgb_property;
  if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
    prop = drm_property_create(dev, 8, "Broadcast RGB", 2);
    if ((unsigned long )prop == (unsigned long )((struct drm_property *)0)) {
      return;
    } else {

    }
    i = 0;
    goto ldv_38161;
    ldv_38160: 
    drm_property_add_enum(prop, i, (uint64_t )i, broadcast_rgb_names[i]);
    i = i + 1;
    ldv_38161: ;
    if ((unsigned int )i <= 1U) {
      goto ldv_38160;
    } else {
      goto ldv_38162;
    }
    ldv_38162: 
    dev_priv->broadcast_rgb_property = prop;
  } else {

  }
  drm_object_attach_property(& connector->base, prop, 0ULL);
  return;
}
}
static struct psb_offset  const  cdv_regmap[2U]  = {      {24640U, 24644U, 459136U, 458760U, 393244U, 24596U, 24604U, 393216U, 393220U,
      393224U, 393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459140U,
      459140U, 458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 24608U, 397312U, 397316U,
      397320U, 397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U,
      463236U, 462884U, 463236U, 463268U, 43008U}};
static int cdv_chip_setup(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  int tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __init_work(& dev_priv->hotplug_work, 0);
  __constr_expr_0.counter = 4195328L;
  dev_priv->hotplug_work.data = __constr_expr_0;
  lockdep_init_map(& dev_priv->hotplug_work.lockdep_map, "(&dev_priv->hotplug_work)",
                   & __key, 0);
  INIT_LIST_HEAD(& dev_priv->hotplug_work.entry);
  dev_priv->hotplug_work.func = & cdv_hotplug_work_func;
  tmp = pci_enable_msi_block(dev->pdev, 1U);
  if (tmp != 0) {
    dev_warn((struct device  const  *)dev->dev, "Enabling MSI failed!\n");
  } else {

  }
  dev_priv->regmap = (struct psb_offset  const  *)(& cdv_regmap);
  cdv_get_core_freq(dev);
  psb_intel_opregion_init(dev);
  psb_intel_init_bios(dev);
  cdv_hotplug_enable(dev, 0);
  return (0);
}
}
struct psb_ops  const  cdv_chip_ops  = 
     {"GMA3600/3650", 0U, 2, 2, 524288, 3, 2, 0, & cdv_intel_helper_funcs, & cdv_intel_crtc_funcs,
    & cdv_chip_setup, 0, & cdv_errata, & cdv_output_init, & cdv_hotplug_event, & cdv_hotplug_enable,
    & cdv_init_pm, & cdv_save_display_registers, & cdv_restore_display_registers,
    & cdv_power_up, & cdv_power_down, 0, 0};
struct drm_device *cdv_chip_ops_group0  ;
bool ldvarg23  ;
void ldv_main_exported_26(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_26 == 1) {
    cdv_chip_setup(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 1: ;
  if (ldv_state_variable_26 == 1) {
    cdv_errata(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 2: ;
  if (ldv_state_variable_26 == 1) {
    cdv_init_pm(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 3: ;
  if (ldv_state_variable_26 == 1) {
    cdv_hotplug_enable(cdv_chip_ops_group0, (int )ldvarg23);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 4: ;
  if (ldv_state_variable_26 == 1) {
    cdv_hotplug_event(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 5: ;
  if (ldv_state_variable_26 == 1) {
    cdv_save_display_registers(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 6: ;
  if (ldv_state_variable_26 == 1) {
    cdv_restore_display_registers(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 7: ;
  if (ldv_state_variable_26 == 1) {
    cdv_power_down(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 8: ;
  if (ldv_state_variable_26 == 1) {
    cdv_output_init(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  case 9: ;
  if (ldv_state_variable_26 == 1) {
    cdv_power_up(cdv_chip_ops_group0);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_38177;
  default: ;
  goto ldv_38177;
  }
  ldv_38177: ;
  return;
}
}
void ldv_mutex_lock_529(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_530(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_531(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_532(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_533(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_534(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_535(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_536(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_537(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_538(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_539(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_540(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_556(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_554(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_557(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_559(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_561(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_562(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_564(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_553(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_555(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_558(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_560(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_563(struct mutex *ldv_func_arg1 ) ;
static void cdv_intel_crt_dpms(struct drm_encoder *encoder , int mode ) 
{ struct drm_device *dev ;
  u32 temp ;
  u32 reg ;

  {
  dev = encoder->dev;
  reg = 397568U;
  temp = REGISTER_READ(dev, reg);
  temp = temp & 4294964223U;
  temp = temp & 2147483647U;
  switch (mode) {
  case 0: 
  temp = temp | 2147483648U;
  goto ldv_38158;
  case 1: 
  temp = temp | 2147484672U;
  goto ldv_38158;
  case 2: 
  temp = temp | 2147485696U;
  goto ldv_38158;
  case 3: 
  temp = temp | 3072U;
  goto ldv_38158;
  }
  ldv_38158: 
  REGISTER_WRITE(dev, reg, temp);
  return;
}
}
static int cdv_intel_crt_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 

  {
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {

  }
  if (mode->clock <= 19999) {
    return (16);
  } else {

  }
  if (mode->clock > 355000) {
    return (15);
  } else {

  }
  return (0);
}
}
static bool cdv_intel_crt_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                     struct drm_display_mode *adjusted_mode ) 
{ 

  {
  return (1);
}
}
static void cdv_intel_crt_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct drm_crtc *crtc ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int dpll_md_reg ;
  u32 adpa ;
  u32 dpll_md ;
  u32 adpa_reg ;

  {
  dev = encoder->dev;
  crtc = encoder->crtc;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  if (psb_intel_crtc->pipe == 0) {
    dpll_md_reg = 24604;
  } else {
    dpll_md_reg = 24608;
  }
  adpa_reg = 397568U;
  dpll_md = REGISTER_READ(dev, (uint32_t )dpll_md_reg);
  REGISTER_WRITE(dev, (uint32_t )dpll_md_reg, dpll_md & 4294951167U);
  adpa = 0U;
  if ((int )adjusted_mode->flags & 1) {
    adpa = adpa | 8U;
  } else {

  }
  if ((adjusted_mode->flags & 4U) != 0U) {
    adpa = adpa | 16U;
  } else {

  }
  if (psb_intel_crtc->pipe == 0) {
    adpa = adpa;
  } else {
    adpa = adpa | 1073741824U;
  }
  REGISTER_WRITE(dev, adpa_reg, adpa);
  return;
}
}
static bool cdv_intel_crt_detect_hotplug(struct drm_connector *connector , bool force ) 
{ struct drm_device *dev ;
  u32 hotplug_en ;
  int i ;
  int tries ;
  int ret ;
  u32 orig ;
  unsigned long timeout ;
  unsigned long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
  dev = connector->dev;
  tries = 0;
  ret = 0;
  tries = 2;
  hotplug_en = REGISTER_READ(dev, 397584U);
  orig = hotplug_en;
  hotplug_en = hotplug_en & 4294967047U;
  hotplug_en = hotplug_en | 8U;
  hotplug_en = hotplug_en | 256U;
  hotplug_en = hotplug_en | 32U;
  i = 0;
  goto ldv_38205;
  ldv_38204: 
  REGISTER_WRITE(dev, 397584U, hotplug_en);
  tmp = msecs_to_jiffies(1000U);
  timeout = tmp + (unsigned long )jiffies;
  ldv_38203: 
  tmp___0 = REGISTER_READ(dev, 397584U);
  if ((tmp___0 & 8U) == 0U) {
    goto ldv_38196;
  } else {

  }
  msleep(1U);
  if ((long )jiffies - (long )timeout < 0L) {
    goto ldv_38203;
  } else {
    goto ldv_38196;
  }
  ldv_38196: 
  i = i + 1;
  ldv_38205: ;
  if (i < tries) {
    goto ldv_38204;
  } else {
    goto ldv_38206;
  }
  ldv_38206: 
  tmp___1 = REGISTER_READ(dev, 397588U);
  if ((tmp___1 & 768U) != 0U) {
    ret = 1;
  } else {

  }
  REGISTER_WRITE(dev, 397588U, 2048U);
  REGISTER_WRITE(dev, 397584U, orig);
  return (ret != 0);
}
}
static enum drm_connector_status cdv_intel_crt_detect(struct drm_connector *connector ,
                                                      bool force ) 
{ bool tmp ;

  {
  tmp = cdv_intel_crt_detect_hotplug(connector, (int )force);
  if ((int )tmp) {
    return (1);
  } else {
    return (2);
  }
}
}
static void cdv_intel_crt_destroy(struct drm_connector *connector ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  psb_intel_i2c_destroy(psb_intel_encoder->ddc_bus);
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const   *)connector);
  return;
}
}
static int cdv_intel_crt_get_modes(struct drm_connector *connector ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  int tmp___0 ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  tmp___0 = psb_intel_ddc_get_modes(connector, & (psb_intel_encoder->ddc_bus)->adapter);
  return (tmp___0);
}
}
static int cdv_intel_crt_set_property(struct drm_connector *connector , struct drm_property *property ,
                                      uint64_t value ) 
{ 

  {
  return (0);
}
}
static struct drm_encoder_helper_funcs  const  cdv_intel_crt_helper_funcs  = 
     {& cdv_intel_crt_dpms, 0, 0, & cdv_intel_crt_mode_fixup, & psb_intel_encoder_prepare,
    & psb_intel_encoder_commit, & cdv_intel_crt_mode_set, 0, 0, 0};
static struct drm_connector_funcs  const  cdv_intel_crt_connector_funcs  = 
     {& drm_helper_connector_dpms, 0, 0, 0, & cdv_intel_crt_detect, & drm_helper_probe_single_connector_modes,
    & cdv_intel_crt_set_property, & cdv_intel_crt_destroy, 0};
static struct drm_connector_helper_funcs  const  cdv_intel_crt_connector_helper_funcs  =    {& cdv_intel_crt_get_modes,
    & cdv_intel_crt_mode_valid, & psb_intel_best_encoder};
static void cdv_intel_crt_enc_destroy(struct drm_encoder *encoder ) 
{ 

  {
  drm_encoder_cleanup(encoder);
  return;
}
}
static struct drm_encoder_funcs  const  cdv_intel_crt_enc_funcs  =    {0, & cdv_intel_crt_enc_destroy};
void cdv_intel_crt_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ struct psb_intel_connector *psb_intel_connector ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  u32 i2c_reg ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = kzalloc(136UL, 208U);
  psb_intel_encoder = (struct psb_intel_encoder *)tmp;
  if ((unsigned long )psb_intel_encoder == (unsigned long )((struct psb_intel_encoder *)0)) {
    return;
  } else {

  }
  tmp___0 = kzalloc(1864UL, 208U);
  psb_intel_connector = (struct psb_intel_connector *)tmp___0;
  if ((unsigned long )psb_intel_connector == (unsigned long )((struct psb_intel_connector *)0)) {
    goto failed_connector;
  } else {

  }
  connector = & psb_intel_connector->base;
  drm_connector_init(dev, connector, & cdv_intel_crt_connector_funcs, 1);
  encoder = & psb_intel_encoder->base;
  drm_encoder_init(dev, encoder, & cdv_intel_crt_enc_funcs, 1);
  psb_intel_connector_attach_encoder(psb_intel_connector, psb_intel_encoder);
  i2c_reg = 20496U;
  psb_intel_encoder->ddc_bus = psb_intel_i2c_create(dev, i2c_reg, "CRTDDC_A");
  if ((unsigned long )psb_intel_encoder->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
    goto failed_ddc;
  } else {

  }
  psb_intel_encoder->type = 1;
  connector->interlace_allowed = 0;
  connector->doublescan_allowed = 0;
  drm_encoder_helper_add(encoder, & cdv_intel_crt_helper_funcs);
  drm_connector_helper_add(connector, & cdv_intel_crt_connector_helper_funcs);
  drm_sysfs_connector_add(connector);
  return;
  failed_ddc: 
  drm_encoder_cleanup(& psb_intel_encoder->base);
  drm_connector_cleanup(& psb_intel_connector->base);
  kfree((void const   *)psb_intel_connector);
  failed_connector: 
  kfree((void const   *)psb_intel_encoder);
  return;
}
}
uint64_t ldvarg77  ;
struct drm_display_mode *ldvarg41  ;
int ldvarg80  ;
int ldvarg43  ;
struct drm_display_mode *ldvarg42  ;
bool ldvarg79  ;
extern int ldv_cdv_intel_crt_enc_funcs_probe_22(void) ;
struct drm_encoder *ldvarg120  ;
struct drm_display_mode *ldvarg124  ;
extern int ldv_cdv_intel_crt_connector_funcs_probe_24(void) ;
struct drm_property *ldvarg78  ;
struct drm_encoder *cdv_intel_crt_helper_funcs_group1  ;
struct drm_display_mode *cdv_intel_crt_helper_funcs_group0  ;
struct drm_connector *cdv_intel_crt_connector_helper_funcs_group0  ;
uint32_t ldvarg76  ;
struct drm_connector *cdv_intel_crt_connector_funcs_group0  ;
uint32_t ldvarg75  ;
void ldv_main_exported_25(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_25 == 1) {
    cdv_intel_crt_dpms(cdv_intel_crt_helper_funcs_group1, ldvarg43);
    ldv_state_variable_25 = 1;
  } else {

  }
  goto ldv_38265;
  case 1: ;
  if (ldv_state_variable_25 == 1) {
    cdv_intel_crt_mode_fixup(cdv_intel_crt_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg42,
                             cdv_intel_crt_helper_funcs_group0);
    ldv_state_variable_25 = 1;
  } else {

  }
  goto ldv_38265;
  case 2: ;
  if (ldv_state_variable_25 == 1) {
    psb_intel_encoder_commit(cdv_intel_crt_helper_funcs_group1);
    ldv_state_variable_25 = 1;
  } else {

  }
  goto ldv_38265;
  case 3: ;
  if (ldv_state_variable_25 == 1) {
    cdv_intel_crt_mode_set(cdv_intel_crt_helper_funcs_group1, cdv_intel_crt_helper_funcs_group0,
                           ldvarg41);
    ldv_state_variable_25 = 1;
  } else {

  }
  goto ldv_38265;
  case 4: ;
  if (ldv_state_variable_25 == 1) {
    psb_intel_encoder_prepare(cdv_intel_crt_helper_funcs_group1);
    ldv_state_variable_25 = 1;
  } else {

  }
  goto ldv_38265;
  default: ;
  goto ldv_38265;
  }
  ldv_38265: ;
  return;
}
}
void ldv_main_exported_22(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_22 == 2) {
    cdv_intel_crt_enc_destroy(ldvarg120);
    ldv_state_variable_22 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38275;
  case 1: ;
  if (ldv_state_variable_22 == 1) {
    ldv_cdv_intel_crt_enc_funcs_probe_22();
    ldv_state_variable_22 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38275;
  default: ;
  goto ldv_38275;
  }
  ldv_38275: ;
  return;
}
}
void ldv_main_exported_24(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_24 == 2) {
    drm_helper_connector_dpms(cdv_intel_crt_connector_funcs_group0, ldvarg80);
    ldv_state_variable_24 = 2;
  } else {

  }
  if (ldv_state_variable_24 == 1) {
    drm_helper_connector_dpms(cdv_intel_crt_connector_funcs_group0, ldvarg80);
    ldv_state_variable_24 = 1;
  } else {

  }
  goto ldv_38282;
  case 1: ;
  if (ldv_state_variable_24 == 2) {
    cdv_intel_crt_detect(cdv_intel_crt_connector_funcs_group0, (int )ldvarg79);
    ldv_state_variable_24 = 2;
  } else {

  }
  if (ldv_state_variable_24 == 1) {
    cdv_intel_crt_detect(cdv_intel_crt_connector_funcs_group0, (int )ldvarg79);
    ldv_state_variable_24 = 1;
  } else {

  }
  goto ldv_38282;
  case 2: ;
  if (ldv_state_variable_24 == 2) {
    cdv_intel_crt_set_property(cdv_intel_crt_connector_funcs_group0, ldvarg78, ldvarg77);
    ldv_state_variable_24 = 2;
  } else {

  }
  if (ldv_state_variable_24 == 1) {
    cdv_intel_crt_set_property(cdv_intel_crt_connector_funcs_group0, ldvarg78, ldvarg77);
    ldv_state_variable_24 = 1;
  } else {

  }
  goto ldv_38282;
  case 3: ;
  if (ldv_state_variable_24 == 2) {
    cdv_intel_crt_destroy(cdv_intel_crt_connector_funcs_group0);
    ldv_state_variable_24 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38282;
  case 4: ;
  if (ldv_state_variable_24 == 2) {
    drm_helper_probe_single_connector_modes(cdv_intel_crt_connector_funcs_group0,
                                            ldvarg76, ldvarg75);
    ldv_state_variable_24 = 2;
  } else {

  }
  if (ldv_state_variable_24 == 1) {
    drm_helper_probe_single_connector_modes(cdv_intel_crt_connector_funcs_group0,
                                            ldvarg76, ldvarg75);
    ldv_state_variable_24 = 1;
  } else {

  }
  goto ldv_38282;
  case 5: ;
  if (ldv_state_variable_24 == 1) {
    ldv_cdv_intel_crt_connector_funcs_probe_24();
    ldv_state_variable_24 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38282;
  default: ;
  goto ldv_38282;
  }
  ldv_38282: ;
  return;
}
}
void ldv_main_exported_23(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_23 == 1) {
    cdv_intel_crt_get_modes(cdv_intel_crt_connector_helper_funcs_group0);
    ldv_state_variable_23 = 1;
  } else {

  }
  goto ldv_38293;
  case 1: ;
  if (ldv_state_variable_23 == 1) {
    cdv_intel_crt_mode_valid(cdv_intel_crt_connector_helper_funcs_group0, ldvarg124);
    ldv_state_variable_23 = 1;
  } else {

  }
  goto ldv_38293;
  case 2: ;
  if (ldv_state_variable_23 == 1) {
    psb_intel_best_encoder(cdv_intel_crt_connector_helper_funcs_group0);
    ldv_state_variable_23 = 1;
  } else {

  }
  goto ldv_38293;
  default: ;
  goto ldv_38293;
  }
  ldv_38293: ;
  return;
}
}
void ldv_mutex_lock_553(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_554(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_555(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_556(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_557(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_558(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_559(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_560(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_561(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_562(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_563(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_564(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_580(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_578(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_581(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_583(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_585(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_586(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_588(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_577(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_579(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_582(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_584(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_587(struct mutex *ldv_func_arg1 ) ;
extern int drm_err(char const   * , char const   *  , ...) ;
extern void drm_vblank_off(struct drm_device * , int  ) ;
void cdv_intel_dp_set_m_n(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                          struct drm_display_mode *adjusted_mode ) ;
int cdv_sb_read(struct drm_device *dev , u32 reg , u32 *val ) ;
int cdv_sb_write(struct drm_device *dev , u32 reg , u32 val ) ;
void cdv_sb_reset(struct drm_device *dev ) ;
struct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) ;
__inline static void cdv_intel_wait_for_vblank(struct drm_device *dev ) 
{ unsigned long __ms ;
  unsigned long tmp ;

  {
  __ms = 20UL;
  goto ldv_38269;
  ldv_38268: 
  __const_udelay(4295000UL);
  ldv_38269: 
  tmp = __ms;
  __ms = __ms - 1UL;
  if (tmp != 0UL) {
    goto ldv_38268;
  } else {
    goto ldv_38270;
  }
  ldv_38270: ;
  return;
}
}
static bool cdv_intel_find_best_PLL(struct cdv_intel_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct cdv_intel_clock_t *best_clock ) ;
static bool cdv_intel_find_dp_pll(struct cdv_intel_limit_t  const  *limit , struct drm_crtc *crtc ,
                                  int target , int refclk , struct cdv_intel_clock_t *best_clock ) ;
static struct cdv_intel_limit_t  const  cdv_intel_limits[6U]  = {      {{20000, 115500}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {28,
                                                                                  140},
      {2, 10}, {200000, 14, 14}, & cdv_intel_find_best_PLL}, 
        {{20000, 115500}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {28,
                                                                                  140},
      {2, 10}, {200000, 14, 14}, & cdv_intel_find_best_PLL}, 
        {{20000, 400000}, {1809000, 3564000}, {1, 1}, {67, 132}, {0, 0}, {65, 130}, {5,
                                                                                  90},
      {1, 9}, {225000, 10, 5}, & cdv_intel_find_best_PLL}, 
        {{20000, 400000}, {1800000, 3600000}, {2, 6}, {60, 160}, {0, 0}, {58, 158}, {5,
                                                                                  100},
      {1, 10}, {225000, 10, 5}, & cdv_intel_find_best_PLL}, 
        {{160000, 272000}, {1809000, 3564000}, {1, 1}, {67, 132}, {0, 0}, {65, 130},
      {5, 90}, {1, 9}, {225000, 10, 10}, & cdv_intel_find_dp_pll}, 
        {{160000, 272000}, {1800000, 3600000}, {2, 6}, {60, 164}, {0, 0}, {58, 162},
      {5, 100}, {1, 10}, {225000, 10, 10}, & cdv_intel_find_dp_pll}};
int cdv_sb_read(struct drm_device *dev , u32 reg , u32 *val ) 
{ int ret ;
  unsigned long timeout__ ;
  unsigned long tmp ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___2 ;
  int ret_____0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___3 ;
  uint32_t tmp___4 ;

  {
  tmp = msecs_to_jiffies(1000U);
  timeout__ = tmp + (unsigned long )jiffies;
  ret__ = 0;
  goto ldv_38374;
  ldv_38373: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38331;
  } else {

  }
  __vpp_verify = 0;
  switch (4UL) {
  case 1: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
  goto ldv_38337;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38337;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38337;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38337;
  default: 
  __bad_percpu_size();
  }
  ldv_38337: 
  pscr_ret__ = pfo_ret__;
  goto ldv_38343;
  case 2: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38347;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38347;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38347;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38347;
  default: 
  __bad_percpu_size();
  }
  ldv_38347: 
  pscr_ret__ = pfo_ret_____0;
  goto ldv_38343;
  case 4: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38356;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38356;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38356;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38356;
  default: 
  __bad_percpu_size();
  }
  ldv_38356: 
  pscr_ret__ = pfo_ret_____1;
  goto ldv_38343;
  case 8: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38365;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38365;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38365;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38365;
  default: 
  __bad_percpu_size();
  }
  ldv_38365: 
  pscr_ret__ = pfo_ret_____2;
  goto ldv_38343;
  default: 
  __bad_size_call_parameter();
  goto ldv_38343;
  }
  ldv_38343: 
  tmp___0 = atomic_read((atomic_t const   *)(& kgdb_active));
  if (pscr_ret__ != tmp___0) {
    msleep(1U);
  } else {

  }
  ldv_38374: 
  tmp___1 = REGISTER_READ(dev, 8448U);
  if ((int )tmp___1 & 1) {
    goto ldv_38373;
  } else {
    goto ldv_38331;
  }
  ldv_38331: 
  ret = ret__;
  if (ret != 0) {
    drm_err("cdv_sb_read", "timeout waiting for SB to idle before read\n");
    return (ret);
  } else {

  }
  REGISTER_WRITE(dev, 8456U, reg);
  REGISTER_WRITE(dev, 8448U, 35056U);
  tmp___2 = msecs_to_jiffies(1000U);
  timeout_____0 = tmp___2 + (unsigned long )jiffies;
  ret_____0 = 0;
  goto ldv_38428;
  ldv_38427: ;
  if ((long )timeout_____0 - (long )jiffies < 0L) {
    ret_____0 = -110;
    goto ldv_38385;
  } else {

  }
  __vpp_verify___0 = 0;
  switch (4UL) {
  case 1: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
  goto ldv_38391;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
  goto ldv_38391;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
  goto ldv_38391;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
  goto ldv_38391;
  default: 
  __bad_percpu_size();
  }
  ldv_38391: 
  pscr_ret_____0 = pfo_ret_____3;
  goto ldv_38397;
  case 2: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
  goto ldv_38401;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
  goto ldv_38401;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
  goto ldv_38401;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
  goto ldv_38401;
  default: 
  __bad_percpu_size();
  }
  ldv_38401: 
  pscr_ret_____0 = pfo_ret_____4;
  goto ldv_38397;
  case 4: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
  goto ldv_38410;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
  goto ldv_38410;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
  goto ldv_38410;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
  goto ldv_38410;
  default: 
  __bad_percpu_size();
  }
  ldv_38410: 
  pscr_ret_____0 = pfo_ret_____5;
  goto ldv_38397;
  case 8: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
  goto ldv_38419;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
  goto ldv_38419;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
  goto ldv_38419;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
  goto ldv_38419;
  default: 
  __bad_percpu_size();
  }
  ldv_38419: 
  pscr_ret_____0 = pfo_ret_____6;
  goto ldv_38397;
  default: 
  __bad_size_call_parameter();
  goto ldv_38397;
  }
  ldv_38397: 
  tmp___3 = atomic_read((atomic_t const   *)(& kgdb_active));
  if (pscr_ret_____0 != tmp___3) {
    msleep(1U);
  } else {

  }
  ldv_38428: 
  tmp___4 = REGISTER_READ(dev, 8448U);
  if ((int )tmp___4 & 1) {
    goto ldv_38427;
  } else {
    goto ldv_38385;
  }
  ldv_38385: 
  ret = ret_____0;
  if (ret != 0) {
    drm_err("cdv_sb_read", "timeout waiting for SB to idle after read\n");
    return (ret);
  } else {

  }
  *val = REGISTER_READ(dev, 8452U);
  return (0);
}
}
int cdv_sb_write(struct drm_device *dev , u32 reg , u32 val ) 
{ int ret ;
  bool dpio_debug ;
  u32 temp ;
  int tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  unsigned long timeout_____0 ;
  unsigned long tmp___3 ;
  int ret_____0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  int tmp___6 ;

  {
  dpio_debug = 1;
  if ((int )dpio_debug) {
    tmp = cdv_sb_read(dev, reg, & temp);
    if (tmp == 0) {
      drm_ut_debug_printk(4U, "drm", "cdv_sb_write", "0x%08x: 0x%08x (before)\n",
                          reg, temp);
    } else {

    }
    drm_ut_debug_printk(4U, "drm", "cdv_sb_write", "0x%08x: 0x%08x\n", reg, val);
  } else {

  }
  tmp___0 = msecs_to_jiffies(1000U);
  timeout__ = tmp___0 + (unsigned long )jiffies;
  ret__ = 0;
  goto ldv_38490;
  ldv_38489: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38447;
  } else {

  }
  __vpp_verify = 0;
  switch (4UL) {
  case 1: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
  goto ldv_38453;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38453;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38453;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38453;
  default: 
  __bad_percpu_size();
  }
  ldv_38453: 
  pscr_ret__ = pfo_ret__;
  goto ldv_38459;
  case 2: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38463;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38463;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38463;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38463;
  default: 
  __bad_percpu_size();
  }
  ldv_38463: 
  pscr_ret__ = pfo_ret_____0;
  goto ldv_38459;
  case 4: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38472;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38472;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38472;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38472;
  default: 
  __bad_percpu_size();
  }
  ldv_38472: 
  pscr_ret__ = pfo_ret_____1;
  goto ldv_38459;
  case 8: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38481;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38481;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38481;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38481;
  default: 
  __bad_percpu_size();
  }
  ldv_38481: 
  pscr_ret__ = pfo_ret_____2;
  goto ldv_38459;
  default: 
  __bad_size_call_parameter();
  goto ldv_38459;
  }
  ldv_38459: 
  tmp___1 = atomic_read((atomic_t const   *)(& kgdb_active));
  if (pscr_ret__ != tmp___1) {
    msleep(1U);
  } else {

  }
  ldv_38490: 
  tmp___2 = REGISTER_READ(dev, 8448U);
  if ((int )tmp___2 & 1) {
    goto ldv_38489;
  } else {
    goto ldv_38447;
  }
  ldv_38447: 
  ret = ret__;
  if (ret != 0) {
    drm_err("cdv_sb_write", "timeout waiting for SB to idle before write\n");
    return (ret);
  } else {

  }
  REGISTER_WRITE(dev, 8456U, reg);
  REGISTER_WRITE(dev, 8452U, val);
  REGISTER_WRITE(dev, 8448U, 100592U);
  tmp___3 = msecs_to_jiffies(1000U);
  timeout_____0 = tmp___3 + (unsigned long )jiffies;
  ret_____0 = 0;
  goto ldv_38543;
  ldv_38542: ;
  if ((long )timeout_____0 - (long )jiffies < 0L) {
    ret_____0 = -110;
    goto ldv_38500;
  } else {

  }
  __vpp_verify___0 = 0;
  switch (4UL) {
  case 1: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
  goto ldv_38506;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
  goto ldv_38506;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
  goto ldv_38506;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
  goto ldv_38506;
  default: 
  __bad_percpu_size();
  }
  ldv_38506: 
  pscr_ret_____0 = pfo_ret_____3;
  goto ldv_38512;
  case 2: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
  goto ldv_38516;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
  goto ldv_38516;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
  goto ldv_38516;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
  goto ldv_38516;
  default: 
  __bad_percpu_size();
  }
  ldv_38516: 
  pscr_ret_____0 = pfo_ret_____4;
  goto ldv_38512;
  case 4: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
  goto ldv_38525;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
  goto ldv_38525;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
  goto ldv_38525;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
  goto ldv_38525;
  default: 
  __bad_percpu_size();
  }
  ldv_38525: 
  pscr_ret_____0 = pfo_ret_____5;
  goto ldv_38512;
  case 8: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
  goto ldv_38534;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
  goto ldv_38534;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
  goto ldv_38534;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
  goto ldv_38534;
  default: 
  __bad_percpu_size();
  }
  ldv_38534: 
  pscr_ret_____0 = pfo_ret_____6;
  goto ldv_38512;
  default: 
  __bad_size_call_parameter();
  goto ldv_38512;
  }
  ldv_38512: 
  tmp___4 = atomic_read((atomic_t const   *)(& kgdb_active));
  if (pscr_ret_____0 != tmp___4) {
    msleep(1U);
  } else {

  }
  ldv_38543: 
  tmp___5 = REGISTER_READ(dev, 8448U);
  if ((int )tmp___5 & 1) {
    goto ldv_38542;
  } else {
    goto ldv_38500;
  }
  ldv_38500: 
  ret = ret_____0;
  if (ret != 0) {
    drm_err("cdv_sb_write", "timeout waiting for SB to idle after write\n");
    return (ret);
  } else {

  }
  if ((int )dpio_debug) {
    tmp___6 = cdv_sb_read(dev, reg, & temp);
    if (tmp___6 == 0) {
      drm_ut_debug_printk(4U, "drm", "cdv_sb_write", "0x%08x: 0x%08x (after)\n", reg,
                          temp);
    } else {

    }
  } else {

  }
  return (0);
}
}
void cdv_sb_reset(struct drm_device *dev ) 
{ 

  {
  REGISTER_WRITE(dev, 8464U, 0U);
  REGISTER_READ(dev, 8464U);
  REGISTER_WRITE(dev, 8464U, 5U);
  return;
}
}
static int cdv_dpll_set_clock_cdv(struct drm_device *dev , struct drm_crtc *crtc ,
                                  struct cdv_intel_clock_t *clock , bool is_lvds ,
                                  u32 ddi_select ) 
{ struct psb_intel_crtc *psb_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  u32 m ;
  u32 n_vco ;
  u32 p ;
  int ret ;
  int dpll_reg ;
  int tmp ;
  int ref_sfr ;
  int tmp___0 ;
  u32 ref_value ;
  u32 lane_reg ;
  u32 lane_value ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_crtc->pipe;
  ret = 0;
  if (pipe == 0) {
    tmp = 24596;
  } else {
    tmp = 24600;
  }
  dpll_reg = tmp;
  if (pipe == 0) {
    tmp___0 = 32784;
  } else {
    tmp___0 = 32816;
  }
  ref_sfr = tmp___0;
  cdv_sb_reset(dev);
  REGISTER_WRITE(dev, (uint32_t )dpll_reg, 805306368U);
  __const_udelay(429500UL);
  ref_value = 6858497U;
  cdv_sb_write(dev, (u32 )(pipe * 32 + 32792), ref_value);
  ret = cdv_sb_read(dev, (u32 )ref_sfr, & ref_value);
  if (ret != 0) {
    return (ret);
  } else {

  }
  ref_value = ref_value & 4294942719U;
  if ((pipe == 1 && ! is_lvds) && (ddi_select & 32768U) == 0U) {
    drm_ut_debug_printk(4U, "drm", "cdv_dpll_set_clock_cdv", "use DPLLA for pipe B\n");
    ref_value = ref_value | 16384U;
  } else {
    drm_ut_debug_printk(4U, "drm", "cdv_dpll_set_clock_cdv", "use their DPLL for pipe A/B\n");
    ref_value = ref_value | 8192U;
  }
  ret = cdv_sb_write(dev, (u32 )ref_sfr, ref_value);
  if (ret != 0) {
    return (ret);
  } else {

  }
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32776), & m);
  if (ret != 0) {
    return (ret);
  } else {

  }
  m = m & 16777215U;
  m = (u32 )(clock->m2 << 24) | m;
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32776), m);
  if (ret != 0) {
    return (ret);
  } else {

  }
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32788), & n_vco);
  if (ret != 0) {
    return (ret);
  } else {

  }
  n_vco = n_vco & 65535U;
  n_vco = n_vco | 263U;
  n_vco = n_vco & 16777215U;
  n_vco = (u32 )(clock->n << 26) | n_vco;
  if (clock->vco <= 2249999) {
    n_vco = n_vco | 33554432U;
    n_vco = n_vco;
  } else
  if (clock->vco <= 2749999) {
    n_vco = n_vco | 16777216U;
    n_vco = n_vco | 1073741824U;
  } else
  if (clock->vco <= 3299999) {
    n_vco = n_vco;
    n_vco = n_vco | 2147483648U;
  } else {
    n_vco = n_vco;
    n_vco = n_vco | 3221225472U;
  }
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32788), n_vco);
  if (ret != 0) {
    return (ret);
  } else {

  }
  ret = cdv_sb_read(dev, (u32 )(pipe * 32 + 32796), & p);
  if (ret != 0) {
    return (ret);
  } else {

  }
  p = p & 1073680383U;
  p = ((u32 )(clock->p1 << 12) & 65535U) | p;
  switch (clock->p2) {
  case 5: 
  p = p | 1073741824U;
  goto ldv_38570;
  case 10: 
  p = p;
  goto ldv_38570;
  case 14: 
  p = p | 2147483648U;
  goto ldv_38570;
  case 7: 
  p = p | 3221225472U;
  goto ldv_38570;
  default: 
  drm_err("cdv_dpll_set_clock_cdv", "Bad P2 clock: %d\n", clock->p2);
  return (-22);
  }
  ldv_38570: 
  ret = cdv_sb_write(dev, (u32 )(pipe * 32 + 32796), p);
  if (ret != 0) {
    return (ret);
  } else {

  }
  if (ddi_select != 0U) {
    if ((ddi_select & 3U) == 1U) {
      lane_reg = 288U;
      cdv_sb_read(dev, lane_reg, & lane_value);
      lane_value = lane_value & 4287627263U;
      lane_value = lane_value | 3145728U;
      cdv_sb_write(dev, lane_reg, lane_value);
      lane_reg = 544U;
      cdv_sb_read(dev, lane_reg, & lane_value);
      lane_value = lane_value & 4287627263U;
      lane_value = lane_value | 3145728U;
      cdv_sb_write(dev, lane_reg, lane_value);
    } else {
      lane_reg = 8992U;
      cdv_sb_read(dev, lane_reg, & lane_value);
      lane_value = lane_value & 4287627263U;
      lane_value = lane_value | 3145728U;
      cdv_sb_write(dev, lane_reg, lane_value);
      lane_reg = 9248U;
      cdv_sb_read(dev, lane_reg, & lane_value);
      lane_value = lane_value & 4287627263U;
      lane_value = lane_value | 3145728U;
      cdv_sb_write(dev, lane_reg, lane_value);
    }
  } else {

  }
  return (0);
}
}
static bool cdv_intel_pipe_has_type(struct drm_crtc *crtc , int type ) 
{ struct drm_device *dev ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *l_entry ;
  struct list_head  const  *__mptr ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
  dev = crtc->dev;
  mode_config = & dev->mode_config;
  __mptr = (struct list_head  const  *)mode_config->connector_list.next;
  l_entry = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
  goto ldv_38588;
  ldv_38587: ;
  if ((unsigned long )l_entry->encoder != (unsigned long )((struct drm_encoder *)0) && (unsigned long )(l_entry->encoder)->crtc == (unsigned long )crtc) {
    tmp = psb_intel_attached_encoder(l_entry);
    psb_intel_encoder = tmp;
    if (psb_intel_encoder->type == type) {
      return (1);
    } else {

    }
  } else {

  }
  __mptr___0 = (struct list_head  const  *)l_entry->head.next;
  l_entry = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  ldv_38588: ;
  if ((unsigned long )(& l_entry->head) != (unsigned long )(& mode_config->connector_list)) {
    goto ldv_38587;
  } else {
    goto ldv_38589;
  }
  ldv_38589: ;
  return (0);
}
}
static struct cdv_intel_limit_t  const  *cdv_intel_limit(struct drm_crtc *crtc , int refclk ) 
{ struct cdv_intel_limit_t  const  *limit ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  tmp___1 = cdv_intel_pipe_has_type(crtc, 4);
  if ((int )tmp___1) {
    if (refclk == 96000) {
      limit = (struct cdv_intel_limit_t  const  *)(& cdv_intel_limits);
    } else {
      limit = (struct cdv_intel_limit_t  const  *)(& cdv_intel_limits) + 1UL;
    }
  } else {
    tmp = psb_intel_pipe_has_type(crtc, 9);
    if ((int )tmp) {
      goto _L;
    } else {
      tmp___0 = psb_intel_pipe_has_type(crtc, 10);
      if ((int )tmp___0) {
        _L: /* CIL Label */ 
        if (refclk == 27000) {
          limit = (struct cdv_intel_limit_t  const  *)(& cdv_intel_limits) + 4UL;
        } else {
          limit = (struct cdv_intel_limit_t  const  *)(& cdv_intel_limits) + 5UL;
        }
      } else
      if (refclk == 27000) {
        limit = (struct cdv_intel_limit_t  const  *)(& cdv_intel_limits) + 2UL;
      } else {
        limit = (struct cdv_intel_limit_t  const  *)(& cdv_intel_limits) + 3UL;
      }
    }
  }
  return (limit);
}
}
static void cdv_intel_clock(struct drm_device *dev , int refclk , struct cdv_intel_clock_t *clock ) 
{ 

  {
  clock->m = clock->m2 + 2;
  clock->p = clock->p1 * clock->p2;
  clock->vco = (clock->m * refclk) / clock->n;
  clock->dot = clock->vco / clock->p;
  return;
}
}
static bool cdv_intel_PLL_is_valid(struct drm_crtc *crtc , struct cdv_intel_limit_t  const  *limit ,
                                   struct cdv_intel_clock_t *clock ) 
{ 

  {
  if (clock->p1 < (int )limit->p1.min || (int )limit->p1.max < clock->p1) {
    return (0);
  } else {

  }
  if (clock->p < (int )limit->p.min || (int )limit->p.max < clock->p) {
    return (0);
  } else {

  }
  if (clock->vco < (int )limit->vco.min || (int )limit->vco.max < clock->vco) {
    return (0);
  } else {

  }
  if (clock->dot < (int )limit->dot.min || (int )limit->dot.max < clock->dot) {
    return (0);
  } else {

  }
  return (1);
}
}
static bool cdv_intel_find_best_PLL(struct cdv_intel_limit_t  const  *limit , struct drm_crtc *crtc ,
                                    int target , int refclk , struct cdv_intel_clock_t *best_clock ) 
{ struct drm_device *dev ;
  struct cdv_intel_clock_t clock ;
  int err ;
  uint32_t tmp ;
  bool tmp___0 ;
  uint32_t tmp___1 ;
  int this_err ;
  bool tmp___2 ;
  int tmp___3 ;
  long ret ;
  int __x___0 ;
  int tmp___4 ;

  {
  dev = crtc->dev;
  err = target;
  tmp___0 = cdv_intel_pipe_has_type(crtc, 4);
  if ((int )tmp___0) {
    tmp___1 = REGISTER_READ(dev, 397696U);
    if ((int )tmp___1 < 0) {
      tmp = REGISTER_READ(dev, 397696U);
      if ((tmp & 48U) == 48U) {
        clock.p2 = limit->p2.p2_fast;
      } else {
        clock.p2 = limit->p2.p2_slow;
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int )limit->p2.dot_limit > target) {
    clock.p2 = limit->p2.p2_slow;
  } else {
    clock.p2 = limit->p2.p2_fast;
  }
  memset((void *)best_clock, 0, 36UL);
  clock.m1 = 0;
  clock.n = limit->n.min;
  goto ldv_38628;
  ldv_38627: 
  clock.m2 = limit->m2.min;
  goto ldv_38625;
  ldv_38624: 
  clock.p1 = limit->p1.min;
  goto ldv_38622;
  ldv_38621: 
  cdv_intel_clock(dev, refclk, & clock);
  tmp___2 = cdv_intel_PLL_is_valid(crtc, limit, & clock);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    goto ldv_38616;
  } else {

  }
  __x___0 = clock.dot - target;
  if (__x___0 < 0) {
    tmp___4 = - __x___0;
  } else {
    tmp___4 = __x___0;
  }
  ret = (long )tmp___4;
  this_err = (int )ret;
  if (this_err < err) {
    *best_clock = clock;
    err = this_err;
  } else {

  }
  ldv_38616: 
  clock.p1 = clock.p1 + 1;
  ldv_38622: ;
  if (clock.p1 <= (int )limit->p1.max) {
    goto ldv_38621;
  } else {
    goto ldv_38623;
  }
  ldv_38623: 
  clock.m2 = clock.m2 + 1;
  ldv_38625: ;
  if (clock.m2 <= (int )limit->m2.max) {
    goto ldv_38624;
  } else {
    goto ldv_38626;
  }
  ldv_38626: 
  clock.n = clock.n + 1;
  ldv_38628: ;
  if (clock.n <= (int )limit->n.max) {
    goto ldv_38627;
  } else {
    goto ldv_38629;
  }
  ldv_38629: ;
  return (err != target);
}
}
static bool cdv_intel_find_dp_pll(struct cdv_intel_limit_t  const  *limit , struct drm_crtc *crtc ,
                                  int target , int refclk , struct cdv_intel_clock_t *best_clock ) 
{ struct cdv_intel_clock_t clock ;
  size_t __len ;
  void *__ret ;

  {
  if (refclk == 27000) {
    if (target <= 199999) {
      clock.p1 = 2;
      clock.p2 = 10;
      clock.n = 1;
      clock.m1 = 0;
      clock.m2 = 118;
    } else {
      clock.p1 = 1;
      clock.p2 = 10;
      clock.n = 1;
      clock.m1 = 0;
      clock.m2 = 98;
    }
  } else
  if (refclk == 100000) {
    if (target <= 199999) {
      clock.p1 = 2;
      clock.p2 = 10;
      clock.n = 5;
      clock.m1 = 0;
      clock.m2 = 160;
    } else {
      clock.p1 = 1;
      clock.p2 = 10;
      clock.n = 5;
      clock.m1 = 0;
      clock.m2 = 133;
    }
  } else {
    return (0);
  }
  clock.m = clock.m2 + 2;
  clock.p = clock.p1 * clock.p2;
  clock.vco = (clock.m * refclk) / clock.n;
  clock.dot = clock.vco / clock.p;
  __len = 36UL;
  if (__len > 63UL) {
    __ret = __memcpy((void *)best_clock, (void const   *)(& clock), __len);
  } else {
    __ret = __builtin_memcpy((void *)best_clock, (void const   *)(& clock), __len);
  }
  return (1);
}
}
static int cdv_intel_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int pipe ;
  struct psb_offset  const  *map ;
  unsigned long start ;
  unsigned long offset ;
  u32 dspcntr ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct drm_framebuffer  const  *__mptr___1 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  __mptr___0 = (struct drm_framebuffer  const  *)crtc->fb;
  psbfb = (struct psb_framebuffer *)__mptr___0;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  ret = 0;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {

  }
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    dev_err((struct device  const  *)dev->dev, "No FB bound\n");
    goto psb_intel_pipe_cleaner;
  } else {

  }
  ret = psb_gtt_pin(psbfb->gtt);
  if (ret < 0) {
    goto psb_intel_pipe_set_base_exit;
  } else {

  }
  start = (unsigned long )(psbfb->gtt)->offset;
  offset = (unsigned long )((crtc->fb)->pitches[0] * (unsigned int )y + (unsigned int )(((crtc->fb)->bits_per_pixel / 8) * x));
  REGISTER_WRITE(dev, map->stride, (crtc->fb)->pitches[0]);
  dspcntr = REGISTER_READ(dev, map->cntr);
  dspcntr = dspcntr & 3288334335U;
  switch ((crtc->fb)->bits_per_pixel) {
  case 8: 
  dspcntr = dspcntr | 134217728U;
  goto ldv_38664;
  case 16: ;
  if ((crtc->fb)->depth == 15U) {
    dspcntr = dspcntr | 268435456U;
  } else {
    dspcntr = dspcntr | 335544320U;
  }
  goto ldv_38664;
  case 24: ;
  case 32: 
  dspcntr = dspcntr | 402653184U;
  goto ldv_38664;
  default: 
  dev_err((struct device  const  *)dev->dev, "Unknown color depth\n");
  ret = -22;
  goto psb_intel_pipe_set_base_exit;
  }
  ldv_38664: 
  REGISTER_WRITE(dev, map->cntr, dspcntr);
  descriptor.modname = "gma500_gfx";
  descriptor.function = "cdv_intel_pipe_set_base";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c.prepared";
  descriptor.format = "Writing base %08lX %08lX %d %d\n";
  descriptor.lineno = 793U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "Writing base %08lX %08lX %d %d\n",
                      start, offset, x, y);
  } else {

  }
  REGISTER_WRITE(dev, map->base, (uint32_t )offset);
  REGISTER_READ(dev, map->base);
  REGISTER_WRITE(dev, map->surf, (uint32_t )start);
  REGISTER_READ(dev, map->surf);
  psb_intel_pipe_cleaner: ;
  if ((unsigned long )old_fb != (unsigned long )((struct drm_framebuffer *)0)) {
    __mptr___1 = (struct drm_framebuffer  const  *)old_fb;
    psb_gtt_unpin(((struct psb_framebuffer *)__mptr___1)->gtt);
  } else {

  }
  psb_intel_pipe_set_base_exit: 
  gma_power_end(dev);
  return (ret);
}
}
static bool cdv_intel_pipe_enabled(struct drm_device *dev , int pipe ) 
{ struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  psb_intel_crtc = 0;
  crtc = dev_priv->pipe_to_crtc_mapping[pipe];
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0) || ! psb_intel_crtc->active) {
    return (0);
  } else {

  }
  return (1);
}
}
static bool cdv_intel_single_pipe_active(struct drm_device *dev ) 
{ uint32_t pipe_enabled ;
  bool tmp ;
  bool tmp___0 ;

  {
  pipe_enabled = 0U;
  tmp = cdv_intel_pipe_enabled(dev, 0);
  if ((int )tmp) {
    pipe_enabled = pipe_enabled | 1U;
  } else {

  }
  tmp___0 = cdv_intel_pipe_enabled(dev, 1);
  if ((int )tmp___0) {
    pipe_enabled = pipe_enabled | 2U;
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "cdv_intel_single_pipe_active", "pipe enabled %x\n",
                      pipe_enabled);
  if (pipe_enabled == 1U || pipe_enabled == 2U) {
    return (1);
  } else {
    return (0);
  }
}
}
static bool is_pipeb_lvds(struct drm_device *dev , struct drm_crtc *crtc ) 
{ struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct list_head  const  *__mptr___0 ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct list_head  const  *__mptr___1 ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  mode_config = & dev->mode_config;
  if (psb_intel_crtc->pipe != 1) {
    return (0);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  goto ldv_38703;
  ldv_38702: 
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
    goto ldv_38701;
  } else {

  }
  if (psb_intel_encoder->type == 4) {
    return (1);
  } else {

  }
  ldv_38701: 
  __mptr___1 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  ldv_38703: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
    goto ldv_38702;
  } else {
    goto ldv_38704;
  }
  ldv_38704: ;
  return (0);
}
}
static void cdv_intel_disable_self_refresh(struct drm_device *dev ) 
{ uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  tmp___0 = REGISTER_READ(dev, 8416U);
  if ((tmp___0 & 32768U) != 0U) {
    tmp = REGISTER_READ(dev, 8416U);
    REGISTER_WRITE(dev, 8416U, tmp & 4294934527U);
    REGISTER_READ(dev, 8416U);
    cdv_intel_wait_for_vblank(dev);
    REGISTER_WRITE(dev, 196608U, 0U);
    REGISTER_READ(dev, 196608U);
    cdv_intel_wait_for_vblank(dev);
  } else {

  }
  return;
}
}
static void cdv_intel_update_watermark(struct drm_device *dev , struct drm_crtc *crtc ) 
{ u32 fw ;
  bool tmp ;
  bool tmp___0 ;

  {
  tmp___0 = cdv_intel_single_pipe_active(dev);
  if ((int )tmp___0) {
    fw = REGISTER_READ(dev, 458804U);
    fw = fw & 8388607U;
    fw = fw | 1056964608U;
    fw = fw & 4290838527U;
    fw = fw | 262144U;
    REGISTER_WRITE(dev, 458804U, fw);
    fw = REGISTER_READ(dev, 458808U);
    fw = fw & 4294951167U;
    fw = fw | 1536U;
    fw = fw & 4294967168U;
    fw = fw | 8U;
    REGISTER_WRITE(dev, 458808U, fw);
    REGISTER_WRITE(dev, 458812U, 905969664U);
    tmp = is_pipeb_lvds(dev, crtc);
    if ((int )tmp) {
      REGISTER_WRITE(dev, 458836U, 262960U);
    } else {
      fw = 50594564U;
      REGISTER_WRITE(dev, 458836U, fw);
    }
    REGISTER_WRITE(dev, 458840U, 16U);
    cdv_intel_wait_for_vblank(dev);
    REGISTER_WRITE(dev, 8416U, 32768U);
    REGISTER_READ(dev, 8416U);
    cdv_intel_wait_for_vblank(dev);
  } else {
    REGISTER_WRITE(dev, 458804U, 1065879560U);
    REGISTER_WRITE(dev, 458808U, 184680962U);
    REGISTER_WRITE(dev, 458812U, 603979776U);
    REGISTER_WRITE(dev, 458832U, 134414850U);
    REGISTER_WRITE(dev, 458836U, 16843009U);
    REGISTER_WRITE(dev, 458840U, 464U);
    cdv_intel_wait_for_vblank(dev);
    cdv_intel_disable_self_refresh(dev);
  }
  return;
}
}
static void cdv_intel_crtc_load_lut(struct drm_crtc *crtc ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int palreg ;
  int i ;
  bool tmp ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  palreg = 40960;
  if (! crtc->enabled) {
    return;
  } else {

  }
  switch (psb_intel_crtc->pipe) {
  case 0: ;
  goto ldv_38724;
  case 1: 
  palreg = 43008;
  goto ldv_38724;
  case 2: 
  palreg = 44032;
  goto ldv_38724;
  default: 
  dev_err((struct device  const  *)dev->dev, "Illegal Pipe Number.\n");
  return;
  }
  ldv_38724: 
  tmp = gma_power_begin(dev, 0);
  if ((int )tmp) {
    i = 0;
    goto ldv_38729;
    ldv_38728: 
    REGISTER_WRITE(dev, (uint32_t )(i * 4 + palreg), (uint32_t )(((((int )psb_intel_crtc->lut_r[i] + (int )psb_intel_crtc->lut_adj[i]) << 16) | (((int )psb_intel_crtc->lut_g[i] + (int )psb_intel_crtc->lut_adj[i]) << 8)) | ((int )psb_intel_crtc->lut_b[i] + (int )psb_intel_crtc->lut_adj[i])));
    i = i + 1;
    ldv_38729: ;
    if (i <= 255) {
      goto ldv_38728;
    } else {
      goto ldv_38730;
    }
    ldv_38730: 
    gma_power_end(dev);
  } else {
    i = 0;
    goto ldv_38732;
    ldv_38731: 
    dev_priv->regs.pipe[0].palette[i] = (u32 )(((((int )psb_intel_crtc->lut_r[i] + (int )psb_intel_crtc->lut_adj[i]) << 16) | (((int )psb_intel_crtc->lut_g[i] + (int )psb_intel_crtc->lut_adj[i]) << 8)) | ((int )psb_intel_crtc->lut_b[i] + (int )psb_intel_crtc->lut_adj[i]));
    i = i + 1;
    ldv_38732: ;
    if (i <= 255) {
      goto ldv_38731;
    } else {
      goto ldv_38733;
    }
    ldv_38733: ;
  }
  return;
}
}
static void cdv_intel_crtc_dpms(struct drm_crtc *crtc , int mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 temp ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  cdv_intel_disable_self_refresh(dev);
  switch (mode) {
  case 0: ;
  case 1: ;
  case 2: ;
  if ((int )psb_intel_crtc->active) {
    goto ldv_38749;
  } else {

  }
  psb_intel_crtc->active = 1;
  temp = REGISTER_READ(dev, map->dpll);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->dpll, temp);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
  } else {

  }
  temp = REGISTER_READ(dev, map->cntr);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->cntr, temp | 2147483648U);
    tmp = REGISTER_READ(dev, map->base);
    REGISTER_WRITE(dev, map->base, tmp);
  } else {

  }
  __const_udelay(644250UL);
  temp = REGISTER_READ(dev, map->conf);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->conf, temp | 2147483648U);
  } else {

  }
  temp = REGISTER_READ(dev, map->status);
  temp = temp & 4294901760U;
  temp = temp | 2147483648U;
  REGISTER_WRITE(dev, map->status, temp);
  REGISTER_READ(dev, map->status);
  cdv_intel_crtc_load_lut(crtc);
  goto ldv_38749;
  case 3: ;
  if (! psb_intel_crtc->active) {
    goto ldv_38749;
  } else {

  }
  psb_intel_crtc->active = 0;
  REGISTER_WRITE(dev, 463872U, 2147483648U);
  drm_vblank_off(dev, pipe);
  cdv_intel_wait_for_vblank(dev);
  temp = REGISTER_READ(dev, map->conf);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->conf, temp & 2147483647U);
    REGISTER_READ(dev, map->conf);
  } else {

  }
  cdv_intel_wait_for_vblank(dev);
  __const_udelay(644250UL);
  temp = REGISTER_READ(dev, map->cntr);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->cntr, temp & 2147483647U);
    tmp___0 = REGISTER_READ(dev, map->base);
    REGISTER_WRITE(dev, map->base, tmp___0);
    REGISTER_READ(dev, map->base);
  } else {

  }
  temp = REGISTER_READ(dev, map->dpll);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->dpll, temp & 2147483647U);
    REGISTER_READ(dev, map->dpll);
  } else {

  }
  __const_udelay(644250UL);
  goto ldv_38749;
  }
  ldv_38749: 
  cdv_intel_update_watermark(dev, crtc);
  REGISTER_WRITE(dev, 458800U, 16190U);
  return;
}
}
static void cdv_intel_crtc_prepare(struct drm_crtc *crtc ) 
{ struct drm_crtc_helper_funcs *crtc_funcs ;

  {
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->dpms))(crtc, 3);
  return;
}
}
static void cdv_intel_crtc_commit(struct drm_crtc *crtc ) 
{ struct drm_crtc_helper_funcs *crtc_funcs ;

  {
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->dpms))(crtc, 0);
  return;
}
}
static bool cdv_intel_crtc_mode_fixup(struct drm_crtc *crtc , struct drm_display_mode  const  *mode ,
                                      struct drm_display_mode *adjusted_mode ) 
{ 

  {
  return (1);
}
}
static int cdv_intel_panel_fitter_pipe(struct drm_device *dev ) 
{ u32 pfit_control ;

  {
  pfit_control = REGISTER_READ(dev, 397872U);
  if ((int )pfit_control >= 0) {
    return (-1);
  } else {

  }
  return ((int )(pfit_control >> 29) & 3);
}
}
static int cdv_intel_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode , int x ,
                                   int y , struct drm_framebuffer *old_fb ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct cdv_intel_clock_t clock ;
  u32 dpll ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_crt ;
  bool is_lvds ;
  bool is_tv ;
  bool is_hdmi ;
  bool is_dp ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct cdv_intel_limit_t  const  *limit ;
  u32 ddi_select ;
  bool is_edp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct list_head  const  *__mptr___1 ;
  uint32_t tmp___0 ;
  u32 lvds ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  int sdvo_pixel_multiply ;
  struct drm_crtc_helper_funcs *crtc_funcs ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  dpll = 0U;
  is_crt = 0;
  is_lvds = 0;
  is_tv = 0;
  is_hdmi = 0;
  is_dp = 0;
  mode_config = & dev->mode_config;
  ddi_select = 0U;
  is_edp___0 = 0;
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  goto ldv_38815;
  ldv_38814: 
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
    goto ldv_38804;
  } else {

  }
  ddi_select = psb_intel_encoder->ddi_select;
  switch (psb_intel_encoder->type) {
  case 4: 
  is_lvds = 1;
  goto ldv_38806;
  case 5: 
  is_tv = 1;
  goto ldv_38806;
  case 1: 
  is_crt = 1;
  goto ldv_38806;
  case 6: 
  is_hdmi = 1;
  goto ldv_38806;
  case 9: 
  is_dp = 1;
  goto ldv_38806;
  case 10: 
  is_edp___0 = 1;
  goto ldv_38806;
  default: 
  drm_err("cdv_intel_crtc_mode_set", "invalid output type.\n");
  return (0);
  }
  ldv_38806: ;
  ldv_38804: 
  __mptr___1 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  ldv_38815: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
    goto ldv_38814;
  } else {
    goto ldv_38816;
  }
  ldv_38816: ;
  if ((int )dev_priv->dplla_96mhz) {
    refclk = 96000;
  } else {
    refclk = 27000;
  }
  if ((int )is_dp || (int )is_edp___0) {
    if (pipe == 0) {
      refclk = 27000;
    } else {
      refclk = 100000;
    }
  } else {

  }
  if ((int )is_lvds && (unsigned int )*((unsigned char *)dev_priv + 824UL) != 0U) {
    refclk = dev_priv->lvds_ssc_freq * 1000;
    drm_ut_debug_printk(4U, "drm", "cdv_intel_crtc_mode_set", "Use SSC reference clock %d Mhz\n",
                        dev_priv->lvds_ssc_freq);
  } else {

  }
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)adjusted_mode);
  limit = cdv_intel_limit(crtc, refclk);
  ok = (*(limit->find_pll))(limit, crtc, adjusted_mode->clock, refclk, & clock);
  if (! ok) {
    dev_err((struct device  const  *)dev->dev, "Couldn\'t find PLL settings for mode!\n");
    return (0);
  } else {

  }
  dpll = 268435456U;
  if ((int )is_tv) {
    dpll = dpll | 3U;
  } else {

  }
  if ((int )is_dp || (int )is_edp___0) {
    cdv_intel_dp_set_m_n(crtc, mode, adjusted_mode);
  } else {
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458832), 0U);
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458836), 0U);
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458848), 0U);
    REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458852), 0U);
  }
  dpll = dpll | 536870912U;
  pipeconf = REGISTER_READ(dev, map->conf);
  pipeconf = pipeconf & 4294967071U;
  if ((int )is_edp___0) {
    switch (dev_priv->edp.bpp) {
    case 24: 
    pipeconf = pipeconf;
    goto ldv_38818;
    case 18: 
    pipeconf = pipeconf | 64U;
    goto ldv_38818;
    case 30: 
    pipeconf = pipeconf | 32U;
    goto ldv_38818;
    default: 
    pipeconf = pipeconf;
    goto ldv_38818;
    }
    ldv_38818: ;
  } else
  if ((int )is_lvds) {
    tmp___0 = REGISTER_READ(dev, 397696U);
    if ((tmp___0 & 192U) == 192U) {
      pipeconf = pipeconf;
    } else {
      pipeconf = pipeconf | 64U;
    }
  } else {
    pipeconf = pipeconf;
  }
  dspcntr = 1073741824U;
  if (pipe == 0) {
    dspcntr = dspcntr;
  } else {
    dspcntr = dspcntr | 16777216U;
  }
  dspcntr = dspcntr | 2147483648U;
  pipeconf = pipeconf | 2147483648U;
  REGISTER_WRITE(dev, map->dpll, dpll | 805306368U);
  REGISTER_READ(dev, map->dpll);
  cdv_dpll_set_clock_cdv(dev, crtc, & clock, (int )is_lvds, ddi_select);
  __const_udelay(644250UL);
  if ((int )is_lvds) {
    tmp___1 = REGISTER_READ(dev, 397696U);
    lvds = tmp___1;
    lvds = lvds | 3221226240U;
    if (clock.p2 == 7) {
      lvds = lvds | 60U;
    } else {
      lvds = lvds & 4294967235U;
    }
    REGISTER_WRITE(dev, 397696U, lvds);
    REGISTER_READ(dev, 397696U);
  } else {

  }
  dpll = dpll | 2147483648U;
  tmp___2 = cdv_intel_panel_fitter_pipe(dev);
  if (tmp___2 == pipe) {
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
  if (pipe == 0) {
    tmp___3 = 65;
  } else {
    tmp___3 = 66;
  }
  drm_ut_debug_printk(4U, "drm", "cdv_intel_crtc_mode_set", "Mode for pipe %c:\n",
                      tmp___3);
  drm_mode_debug_printmodeline((struct drm_display_mode  const  *)mode);
  tmp___4 = REGISTER_READ(dev, map->dpll);
  REGISTER_WRITE(dev, map->dpll, (tmp___4 & 2147450879U) | 2147483648U);
  REGISTER_READ(dev, map->dpll);
  __const_udelay(644250UL);
  tmp___5 = REGISTER_READ(dev, map->dpll);
  if ((tmp___5 & 32768U) == 0U) {
    dev_err((struct device  const  *)dev->dev, "Failed to get DPLL lock\n");
    return (-16);
  } else {

  }
  sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
  REGISTER_WRITE(dev, map->dpll_md, (uint32_t )((sdvo_pixel_multiply + -1) << 8));
  REGISTER_WRITE(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
  REGISTER_WRITE(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
  REGISTER_WRITE(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
  REGISTER_WRITE(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
  REGISTER_WRITE(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
  REGISTER_WRITE(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
  REGISTER_WRITE(dev, map->size, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
  REGISTER_WRITE(dev, map->pos, 0U);
  REGISTER_WRITE(dev, map->src, (uint32_t )(((mode->hdisplay + -1) << 16) | (mode->vdisplay + -1)));
  REGISTER_WRITE(dev, map->conf, pipeconf);
  REGISTER_READ(dev, map->conf);
  cdv_intel_wait_for_vblank(dev);
  REGISTER_WRITE(dev, map->cntr, dspcntr);
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
  cdv_intel_wait_for_vblank(dev);
  return (0);
}
}
static void cdv_intel_crtc_save(struct drm_crtc *crtc ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_crtc_state *crtc_state ;
  struct psb_offset  const  *map ;
  uint32_t paletteReg ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  crtc_state = psb_intel_crtc->crtc_state;
  map = dev_priv->regmap + (unsigned long )psb_intel_crtc->pipe;
  if ((unsigned long )crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "cdv_intel_crtc_save";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c.prepared";
    descriptor.format = "No CRTC state found\n";
    descriptor.lineno = 1442U;
    descriptor.flags = 0U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No CRTC state found\n");
    } else {

    }
    return;
  } else {

  }
  crtc_state->saveDSPCNTR = REGISTER_READ(dev, map->cntr);
  crtc_state->savePIPECONF = REGISTER_READ(dev, map->conf);
  crtc_state->savePIPESRC = REGISTER_READ(dev, map->src);
  crtc_state->saveFP0 = REGISTER_READ(dev, map->fp0);
  crtc_state->saveFP1 = REGISTER_READ(dev, map->fp1);
  crtc_state->saveDPLL = REGISTER_READ(dev, map->dpll);
  crtc_state->saveHTOTAL = REGISTER_READ(dev, map->htotal);
  crtc_state->saveHBLANK = REGISTER_READ(dev, map->hblank);
  crtc_state->saveHSYNC = REGISTER_READ(dev, map->hsync);
  crtc_state->saveVTOTAL = REGISTER_READ(dev, map->vtotal);
  crtc_state->saveVBLANK = REGISTER_READ(dev, map->vblank);
  crtc_state->saveVSYNC = REGISTER_READ(dev, map->vsync);
  crtc_state->saveDSPSTRIDE = REGISTER_READ(dev, map->stride);
  crtc_state->saveDSPSIZE = REGISTER_READ(dev, map->size);
  crtc_state->saveDSPPOS = REGISTER_READ(dev, map->pos);
  crtc_state->saveDSPBASE = REGISTER_READ(dev, map->base);
  drm_ut_debug_printk(1U, "drm", "cdv_intel_crtc_save", "(%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x)\n",
                      crtc_state->saveDSPCNTR, crtc_state->savePIPECONF, crtc_state->savePIPESRC,
                      crtc_state->saveFP0, crtc_state->saveFP1, crtc_state->saveDPLL,
                      crtc_state->saveHTOTAL, crtc_state->saveHBLANK, crtc_state->saveHSYNC,
                      crtc_state->saveVTOTAL, crtc_state->saveVBLANK, crtc_state->saveVSYNC,
                      crtc_state->saveDSPSTRIDE, crtc_state->saveDSPSIZE, crtc_state->saveDSPPOS,
                      crtc_state->saveDSPBASE);
  paletteReg = map->palette;
  i = 0;
  goto ldv_38840;
  ldv_38839: 
  crtc_state->savePalette[i] = REGISTER_READ(dev, (uint32_t )(i << 2) + paletteReg);
  i = i + 1;
  ldv_38840: ;
  if (i <= 255) {
    goto ldv_38839;
  } else {
    goto ldv_38841;
  }
  ldv_38841: ;
  return;
}
}
static void cdv_intel_crtc_restore(struct drm_crtc *crtc ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_intel_crtc_state *crtc_state ;
  struct psb_offset  const  *map ;
  uint32_t paletteReg ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  crtc_state = psb_intel_crtc->crtc_state;
  map = dev_priv->regmap + (unsigned long )psb_intel_crtc->pipe;
  if ((unsigned long )crtc_state == (unsigned long )((struct psb_intel_crtc_state *)0)) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "cdv_intel_crtc_restore";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c.prepared";
    descriptor.format = "No crtc state\n";
    descriptor.lineno = 1504U;
    descriptor.flags = 0U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No crtc state\n");
    } else {

    }
    return;
  } else {

  }
  tmp___0 = REGISTER_READ(dev, map->base);
  tmp___1 = REGISTER_READ(dev, map->pos);
  tmp___2 = REGISTER_READ(dev, map->size);
  tmp___3 = REGISTER_READ(dev, map->stride);
  tmp___4 = REGISTER_READ(dev, map->vsync);
  tmp___5 = REGISTER_READ(dev, map->vblank);
  tmp___6 = REGISTER_READ(dev, map->vtotal);
  tmp___7 = REGISTER_READ(dev, map->hsync);
  tmp___8 = REGISTER_READ(dev, map->hblank);
  tmp___9 = REGISTER_READ(dev, map->htotal);
  tmp___10 = REGISTER_READ(dev, map->dpll);
  tmp___11 = REGISTER_READ(dev, map->fp1);
  tmp___12 = REGISTER_READ(dev, map->fp0);
  tmp___13 = REGISTER_READ(dev, map->src);
  tmp___14 = REGISTER_READ(dev, map->conf);
  tmp___15 = REGISTER_READ(dev, map->cntr);
  drm_ut_debug_printk(1U, "drm", "cdv_intel_crtc_restore", "current:(%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x)\n",
                      tmp___15, tmp___14, tmp___13, tmp___12, tmp___11, tmp___10,
                      tmp___9, tmp___8, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3,
                      tmp___2, tmp___1, tmp___0);
  drm_ut_debug_printk(1U, "drm", "cdv_intel_crtc_restore", "saved: (%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x)\n",
                      crtc_state->saveDSPCNTR, crtc_state->savePIPECONF, crtc_state->savePIPESRC,
                      crtc_state->saveFP0, crtc_state->saveFP1, crtc_state->saveDPLL,
                      crtc_state->saveHTOTAL, crtc_state->saveHBLANK, crtc_state->saveHSYNC,
                      crtc_state->saveVTOTAL, crtc_state->saveVBLANK, crtc_state->saveVSYNC,
                      crtc_state->saveDSPSTRIDE, crtc_state->saveDSPSIZE, crtc_state->saveDSPPOS,
                      crtc_state->saveDSPBASE);
  if ((int )crtc_state->saveDPLL < 0) {
    REGISTER_WRITE(dev, map->dpll, crtc_state->saveDPLL & 2147483647U);
    REGISTER_READ(dev, map->dpll);
    tmp___16 = REGISTER_READ(dev, map->dpll);
    drm_ut_debug_printk(1U, "drm", "cdv_intel_crtc_restore", "write dpll: %x\n", tmp___16);
    __const_udelay(644250UL);
  } else {

  }
  REGISTER_WRITE(dev, map->fp0, crtc_state->saveFP0);
  REGISTER_READ(dev, map->fp0);
  REGISTER_WRITE(dev, map->fp1, crtc_state->saveFP1);
  REGISTER_READ(dev, map->fp1);
  REGISTER_WRITE(dev, map->dpll, crtc_state->saveDPLL);
  REGISTER_READ(dev, map->dpll);
  __const_udelay(644250UL);
  REGISTER_WRITE(dev, map->htotal, crtc_state->saveHTOTAL);
  REGISTER_WRITE(dev, map->hblank, crtc_state->saveHBLANK);
  REGISTER_WRITE(dev, map->hsync, crtc_state->saveHSYNC);
  REGISTER_WRITE(dev, map->vtotal, crtc_state->saveVTOTAL);
  REGISTER_WRITE(dev, map->vblank, crtc_state->saveVBLANK);
  REGISTER_WRITE(dev, map->vsync, crtc_state->saveVSYNC);
  REGISTER_WRITE(dev, map->stride, crtc_state->saveDSPSTRIDE);
  REGISTER_WRITE(dev, map->size, crtc_state->saveDSPSIZE);
  REGISTER_WRITE(dev, map->pos, crtc_state->saveDSPPOS);
  REGISTER_WRITE(dev, map->src, crtc_state->savePIPESRC);
  REGISTER_WRITE(dev, map->base, crtc_state->saveDSPBASE);
  REGISTER_WRITE(dev, map->conf, crtc_state->savePIPECONF);
  cdv_intel_wait_for_vblank(dev);
  REGISTER_WRITE(dev, map->cntr, crtc_state->saveDSPCNTR);
  REGISTER_WRITE(dev, map->base, crtc_state->saveDSPBASE);
  cdv_intel_wait_for_vblank(dev);
  paletteReg = map->palette;
  i = 0;
  goto ldv_38857;
  ldv_38856: 
  REGISTER_WRITE(dev, (uint32_t )(i << 2) + paletteReg, crtc_state->savePalette[i]);
  i = i + 1;
  ldv_38857: ;
  if (i <= 255) {
    goto ldv_38856;
  } else {
    goto ldv_38858;
  }
  ldv_38858: ;
  return;
}
}
static int cdv_intel_crtc_cursor_set(struct drm_crtc *crtc , struct drm_file *file_priv ,
                                     uint32_t handle , uint32_t width , uint32_t height ) 
{ struct drm_device *dev ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  uint32_t control ;
  unsigned int tmp ;
  uint32_t base ;
  unsigned int tmp___0 ;
  uint32_t temp ;
  size_t addr ;
  struct gtt_range *gt ;
  struct drm_gem_object *obj ;
  int ret ;
  bool tmp___1 ;
  struct drm_gem_object  const  *__mptr___0 ;
  struct _ddebug descriptor ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  struct drm_gem_object  const  *__mptr___1 ;
  bool tmp___4 ;
  struct drm_gem_object  const  *__mptr___2 ;

  {
  dev = crtc->dev;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  if (pipe == 0) {
    tmp = 458880U;
  } else {
    tmp = 458944U;
  }
  control = tmp;
  if (pipe == 0) {
    tmp___0 = 458884U;
  } else {
    tmp___0 = 458948U;
  }
  base = tmp___0;
  addr = 0UL;
  if (handle == 0U) {
    temp = 0U;
    tmp___1 = gma_power_begin(dev, 0);
    if ((int )tmp___1) {
      REGISTER_WRITE(dev, control, temp);
      REGISTER_WRITE(dev, base, 0U);
      gma_power_end(dev);
    } else {

    }
    if ((unsigned long )psb_intel_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
      __mptr___0 = (struct drm_gem_object  const  *)psb_intel_crtc->cursor_obj;
      gt = (struct gtt_range *)__mptr___0 + 0xffffffffffffffc0UL;
      psb_gtt_unpin(gt);
      drm_gem_object_unreference(psb_intel_crtc->cursor_obj);
      psb_intel_crtc->cursor_obj = 0;
    } else {

    }
    return (0);
  } else {

  }
  if (width != 64U || height != 64U) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "cdv_intel_crtc_cursor_set";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c.prepared";
    descriptor.format = "we currently only support 64x64 cursors\n";
    descriptor.lineno = 1636U;
    descriptor.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "we currently only support 64x64 cursors\n");
    } else {

    }
    return (-22);
  } else {

  }
  obj = drm_gem_object_lookup(dev, file_priv, handle);
  if ((unsigned long )obj == (unsigned long )((struct drm_gem_object *)0)) {
    return (-2);
  } else {

  }
  if (obj->size < (size_t )((width * height) * 4U)) {
    descriptor___0.modname = "gma500_gfx";
    descriptor___0.function = "cdv_intel_crtc_cursor_set";
    descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/cdv_intel_display.c.prepared";
    descriptor___0.format = "buffer is to small\n";
    descriptor___0.lineno = 1645U;
    descriptor___0.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "buffer is to small\n");
    } else {

    }
    return (-12);
  } else {

  }
  __mptr___1 = (struct drm_gem_object  const  *)obj;
  gt = (struct gtt_range *)__mptr___1 + 0xffffffffffffffc0UL;
  ret = psb_gtt_pin(gt);
  if (ret != 0) {
    dev_err((struct device  const  *)dev->dev, "Can not pin down handle 0x%x\n", handle);
    return (ret);
  } else {

  }
  addr = (size_t )gt->offset;
  psb_intel_crtc->cursor_addr = (uint32_t )addr;
  temp = 0U;
  temp = (uint32_t )(pipe << 28) | temp;
  temp = temp | 67108903U;
  tmp___4 = gma_power_begin(dev, 0);
  if ((int )tmp___4) {
    REGISTER_WRITE(dev, control, temp);
    REGISTER_WRITE(dev, base, (uint32_t )addr);
    gma_power_end(dev);
  } else {

  }
  if ((unsigned long )psb_intel_crtc->cursor_obj != (unsigned long )((struct drm_gem_object *)0)) {
    __mptr___2 = (struct drm_gem_object  const  *)psb_intel_crtc->cursor_obj;
    gt = (struct gtt_range *)__mptr___2 + 0xffffffffffffffc0UL;
    psb_gtt_unpin(gt);
    drm_gem_object_unreference(psb_intel_crtc->cursor_obj);
    psb_intel_crtc->cursor_obj = obj;
  } else {

  }
  return (0);
}
}
static int cdv_intel_crtc_cursor_move(struct drm_crtc *crtc , int x , int y ) 
{ struct drm_device *dev ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  uint32_t temp ;
  uint32_t adder ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
  dev = crtc->dev;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  temp = 0U;
  if (x < 0) {
    temp = temp | 32768U;
    x = - x;
  } else {

  }
  if (y < 0) {
    temp = temp | 2147483648U;
    y = - y;
  } else {

  }
  temp = ((uint32_t )x & 2047U) | temp;
  temp = (uint32_t )((y & 2047) << 16) | temp;
  adder = psb_intel_crtc->cursor_addr;
  tmp___1 = gma_power_begin(dev, 0);
  if ((int )tmp___1) {
    if (pipe == 0) {
      tmp = 458888U;
    } else {
      tmp = 458952U;
    }
    REGISTER_WRITE(dev, tmp, temp);
    if (pipe == 0) {
      tmp___0 = 458884U;
    } else {
      tmp___0 = 458948U;
    }
    REGISTER_WRITE(dev, tmp___0, adder);
    gma_power_end(dev);
  } else {

  }
  return (0);
}
}
static void cdv_intel_crtc_gamma_set(struct drm_crtc *crtc , u16 *red , u16 *green ,
                                     u16 *blue , uint32_t start , uint32_t size ) 
{ struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int i ;
  int end ;
  unsigned int tmp ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  if (256U < start + size) {
    tmp = 256U;
  } else {
    tmp = start + size;
  }
  end = (int )tmp;
  i = (int )start;
  goto ldv_38913;
  ldv_38912: 
  psb_intel_crtc->lut_r[i] = (u8 )((int )*(red + (unsigned long )i) >> 8);
  psb_intel_crtc->lut_g[i] = (u8 )((int )*(green + (unsigned long )i) >> 8);
  psb_intel_crtc->lut_b[i] = (u8 )((int )*(blue + (unsigned long )i) >> 8);
  i = i + 1;
  ldv_38913: ;
  if (i < end) {
    goto ldv_38912;
  } else {
    goto ldv_38914;
  }
  ldv_38914: 
  cdv_intel_crtc_load_lut(crtc);
  return;
}
}
static int cdv_crtc_set_config(struct drm_mode_set *set ) 
{ int ret ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  int tmp ;

  {
  ret = 0;
  dev = (set->crtc)->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (dev_priv->rpm_enabled == 0) {
    tmp = drm_crtc_helper_set_config(set);
    return (tmp);
  } else {

  }
  pm_runtime_forbid(& (dev->pdev)->dev);
  ret = drm_crtc_helper_set_config(set);
  pm_runtime_allow(& (dev->pdev)->dev);
  return (ret);
}
}
static void i8xx_clock___0(int refclk , struct cdv_intel_clock_t *clock ) 
{ 

  {
  clock->m = (clock->m1 * 5 + 10) + (clock->m2 + 2);
  clock->p = clock->p1 * clock->p2;
  clock->vco = (clock->m * refclk) / (clock->n + 2);
  clock->dot = clock->vco / clock->p;
  return;
}
}
static int cdv_intel_crtc_clock_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 dpll ;
  u32 fp ;
  struct cdv_intel_clock_t clock ;
  bool is_lvds ;
  struct psb_pipe *p ;
  uint32_t tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
  tmp___1 = gma_power_begin(dev, 0);
  if ((int )tmp___1) {
    dpll = REGISTER_READ(dev, map->dpll);
    if ((dpll & 256U) == 0U) {
      fp = REGISTER_READ(dev, map->fp0);
    } else {
      fp = REGISTER_READ(dev, map->fp1);
    }
    if (pipe == 1) {
      tmp = REGISTER_READ(dev, 397696U);
      if ((int )tmp < 0) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    is_lvds = (bool )tmp___0;
    gma_power_end(dev);
  } else {
    dpll = p->dpll;
    if ((dpll & 256U) == 0U) {
      fp = p->fp0;
    } else {
      fp = p->fp1;
    }
    is_lvds = (bool )(pipe == 1 && (int )dev_priv->regs.ldv_38617.psb.saveLVDS < 0);
  }
  clock.m1 = (int )((fp & 16128U) >> 8);
  clock.m2 = (int )fp & 63;
  clock.n = (int )((fp & 4128768U) >> 16);
  if ((int )is_lvds) {
    clock.p1 = ffs((int )((dpll & 4128768U) >> 16));
    if (clock.p1 == 0) {
      clock.p1 = 4;
      dev_err((struct device  const  *)dev->dev, "PLL %d\n", dpll);
    } else {

    }
    clock.p2 = 14;
    if ((dpll & 24576U) == 24576U) {
      i8xx_clock___0(66000, & clock);
    } else {
      i8xx_clock___0(48000, & clock);
    }
  } else {
    if ((dpll & 2097152U) != 0U) {
      clock.p1 = 2;
    } else {
      clock.p1 = (int )(((dpll & 2031616U) >> 16) + 2U);
    }
    if ((dpll & 8388608U) != 0U) {
      clock.p2 = 4;
    } else {
      clock.p2 = 2;
    }
    i8xx_clock___0(48000, & clock);
  }
  return (clock.dot);
}
}
struct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev , struct drm_crtc *crtc ) 
{ struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct drm_psb_private *dev_priv ;
  struct psb_pipe *p ;
  struct psb_offset  const  *map ;
  struct drm_display_mode *mode ;
  int htot ;
  int hsync ;
  int vtot ;
  int vsync ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  p = (struct psb_pipe *)(& dev_priv->regs.pipe) + (unsigned long )pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  tmp___3 = gma_power_begin(dev, 0);
  if ((int )tmp___3) {
    tmp = REGISTER_READ(dev, map->htotal);
    htot = (int )tmp;
    tmp___0 = REGISTER_READ(dev, map->hsync);
    hsync = (int )tmp___0;
    tmp___1 = REGISTER_READ(dev, map->vtotal);
    vtot = (int )tmp___1;
    tmp___2 = REGISTER_READ(dev, map->vsync);
    vsync = (int )tmp___2;
    gma_power_end(dev);
  } else {
    htot = (int )p->htotal;
    hsync = (int )p->hsync;
    vtot = (int )p->vtotal;
    vsync = (int )p->vsync;
  }
  tmp___4 = kzalloc(216UL, 208U);
  mode = (struct drm_display_mode *)tmp___4;
  if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
    return (0);
  } else {

  }
  mode->clock = cdv_intel_crtc_clock_get(dev, crtc);
  mode->hdisplay = (htot & 65535) + 1;
  mode->htotal = (int )(((unsigned int )htot >> 16) + 1U);
  mode->hsync_start = (hsync & 65535) + 1;
  mode->hsync_end = (int )(((unsigned int )hsync >> 16) + 1U);
  mode->vdisplay = (vtot & 65535) + 1;
  mode->vtotal = (int )(((unsigned int )vtot >> 16) + 1U);
  mode->vsync_start = (vsync & 65535) + 1;
  mode->vsync_end = (int )(((unsigned int )vsync >> 16) + 1U);
  drm_mode_set_name(mode);
  drm_mode_set_crtcinfo(mode, 0);
  return (mode);
}
}
static void cdv_intel_crtc_destroy(struct drm_crtc *crtc ) 
{ struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;

  {
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  kfree((void const   *)psb_intel_crtc->crtc_state);
  drm_crtc_cleanup(crtc);
  kfree((void const   *)psb_intel_crtc);
  return;
}
}
struct drm_crtc_helper_funcs  const  cdv_intel_helper_funcs  = 
     {& cdv_intel_crtc_dpms, & cdv_intel_crtc_prepare, & cdv_intel_crtc_commit, & cdv_intel_crtc_mode_fixup,
    & cdv_intel_crtc_mode_set, & cdv_intel_pipe_set_base, 0, 0, 0};
struct drm_crtc_funcs  const  cdv_intel_crtc_funcs  = 
     {& cdv_intel_crtc_save, & cdv_intel_crtc_restore, 0, & cdv_intel_crtc_cursor_set,
    & cdv_intel_crtc_cursor_move, & cdv_intel_crtc_gamma_set, & cdv_intel_crtc_destroy,
    & cdv_crtc_set_config, 0, 0};
int ldvarg11  ;
struct drm_display_mode *cdv_intel_helper_funcs_group0  ;
uint32_t ldvarg51  ;
struct drm_display_mode *ldvarg12  ;
struct drm_framebuffer *cdv_intel_helper_funcs_group1  ;
int ldvarg56  ;
u16 *ldvarg49  ;
uint32_t ldvarg50  ;
uint32_t ldvarg46  ;
struct drm_file *ldvarg53  ;
int ldvarg13  ;
int ldvarg55  ;
struct drm_display_mode *ldvarg10  ;
int ldvarg9  ;
struct drm_mode_set *ldvarg45  ;
int ldvarg15  ;
u16 *ldvarg48  ;
uint32_t ldvarg54  ;
struct drm_crtc *cdv_intel_helper_funcs_group2  ;
int ldvarg14  ;
struct drm_crtc *cdv_intel_crtc_funcs_group0  ;
uint32_t ldvarg52  ;
extern int ldv_cdv_intel_crtc_funcs_probe_20(void) ;
u16 *ldvarg47  ;
void ldv_main_exported_21(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_21 == 1) {
    cdv_intel_pipe_set_base(cdv_intel_helper_funcs_group2, ldvarg15, ldvarg14, cdv_intel_helper_funcs_group1);
    ldv_state_variable_21 = 1;
  } else {

  }
  goto ldv_38993;
  case 1: ;
  if (ldv_state_variable_21 == 1) {
    cdv_intel_crtc_dpms(cdv_intel_helper_funcs_group2, ldvarg13);
    ldv_state_variable_21 = 1;
  } else {

  }
  goto ldv_38993;
  case 2: ;
  if (ldv_state_variable_21 == 1) {
    cdv_intel_crtc_mode_fixup(cdv_intel_helper_funcs_group2, (struct drm_display_mode  const  *)ldvarg12,
                              cdv_intel_helper_funcs_group0);
    ldv_state_variable_21 = 1;
  } else {

  }
  goto ldv_38993;
  case 3: ;
  if (ldv_state_variable_21 == 1) {
    cdv_intel_crtc_commit(cdv_intel_helper_funcs_group2);
    ldv_state_variable_21 = 1;
  } else {

  }
  goto ldv_38993;
  case 4: ;
  if (ldv_state_variable_21 == 1) {
    cdv_intel_crtc_mode_set(cdv_intel_helper_funcs_group2, cdv_intel_helper_funcs_group0,
                            ldvarg10, ldvarg9, ldvarg11, cdv_intel_helper_funcs_group1);
    ldv_state_variable_21 = 1;
  } else {

  }
  goto ldv_38993;
  case 5: ;
  if (ldv_state_variable_21 == 1) {
    cdv_intel_crtc_prepare(cdv_intel_helper_funcs_group2);
    ldv_state_variable_21 = 1;
  } else {

  }
  goto ldv_38993;
  default: ;
  goto ldv_38993;
  }
  ldv_38993: ;
  return;
}
}
void ldv_main_exported_20(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_20 == 2) {
    cdv_intel_crtc_cursor_move(cdv_intel_crtc_funcs_group0, ldvarg56, ldvarg55);
    ldv_state_variable_20 = 2;
  } else {

  }
  if (ldv_state_variable_20 == 1) {
    cdv_intel_crtc_cursor_move(cdv_intel_crtc_funcs_group0, ldvarg56, ldvarg55);
    ldv_state_variable_20 = 1;
  } else {

  }
  goto ldv_39004;
  case 1: ;
  if (ldv_state_variable_20 == 2) {
    cdv_intel_crtc_cursor_set(cdv_intel_crtc_funcs_group0, ldvarg53, ldvarg52, ldvarg51,
                              ldvarg54);
    ldv_state_variable_20 = 2;
  } else {

  }
  if (ldv_state_variable_20 == 1) {
    cdv_intel_crtc_cursor_set(cdv_intel_crtc_funcs_group0, ldvarg53, ldvarg52, ldvarg51,
                              ldvarg54);
    ldv_state_variable_20 = 1;
  } else {

  }
  goto ldv_39004;
  case 2: ;
  if (ldv_state_variable_20 == 2) {
    cdv_intel_crtc_destroy(cdv_intel_crtc_funcs_group0);
    ldv_state_variable_20 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_39004;
  case 3: ;
  if (ldv_state_variable_20 == 2) {
    cdv_intel_crtc_save(cdv_intel_crtc_funcs_group0);
    ldv_state_variable_20 = 2;
  } else {

  }
  if (ldv_state_variable_20 == 1) {
    cdv_intel_crtc_save(cdv_intel_crtc_funcs_group0);
    ldv_state_variable_20 = 1;
  } else {

  }
  goto ldv_39004;
  case 4: ;
  if (ldv_state_variable_20 == 2) {
    cdv_intel_crtc_gamma_set(cdv_intel_crtc_funcs_group0, ldvarg49, ldvarg48, ldvarg47,
                             ldvarg50, ldvarg46);
    ldv_state_variable_20 = 2;
  } else {

  }
  if (ldv_state_variable_20 == 1) {
    cdv_intel_crtc_gamma_set(cdv_intel_crtc_funcs_group0, ldvarg49, ldvarg48, ldvarg47,
                             ldvarg50, ldvarg46);
    ldv_state_variable_20 = 1;
  } else {

  }
  goto ldv_39004;
  case 5: ;
  if (ldv_state_variable_20 == 2) {
    cdv_intel_crtc_restore(cdv_intel_crtc_funcs_group0);
    ldv_state_variable_20 = 2;
  } else {

  }
  if (ldv_state_variable_20 == 1) {
    cdv_intel_crtc_restore(cdv_intel_crtc_funcs_group0);
    ldv_state_variable_20 = 1;
  } else {

  }
  goto ldv_39004;
  case 6: ;
  if (ldv_state_variable_20 == 2) {
    cdv_crtc_set_config(ldvarg45);
    ldv_state_variable_20 = 2;
  } else {

  }
  if (ldv_state_variable_20 == 1) {
    cdv_crtc_set_config(ldvarg45);
    ldv_state_variable_20 = 1;
  } else {

  }
  goto ldv_39004;
  case 7: ;
  if (ldv_state_variable_20 == 1) {
    ldv_cdv_intel_crtc_funcs_probe_20();
    ldv_state_variable_20 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_39004;
  default: ;
  goto ldv_39004;
  }
  ldv_39004: ;
  return;
}
}
void ldv_mutex_lock_577(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_578(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_579(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_580(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_581(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_582(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_583(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_584(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_585(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_586(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_587(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_588(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_604(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_602(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_605(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_607(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_609(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_610(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_612(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_601(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_603(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_606(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_608(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_611(struct mutex *ldv_func_arg1 ) ;
static void cdv_hdmi_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                              struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  u32 hdmib ;
  struct drm_crtc *crtc ;
  struct psb_intel_crtc *intel_crtc ;
  struct drm_crtc  const  *__mptr___0 ;

  {
  dev = encoder->dev;
  __mptr = (struct drm_encoder  const  *)encoder;
  psb_intel_encoder = (struct psb_intel_encoder *)__mptr;
  hdmi_priv = (struct mid_intel_hdmi_priv *)psb_intel_encoder->dev_priv;
  crtc = encoder->crtc;
  __mptr___0 = (struct drm_crtc  const  *)crtc;
  intel_crtc = (struct psb_intel_crtc *)__mptr___0;
  hdmib = 2048U;
  if ((adjusted_mode->flags & 4U) != 0U) {
    hdmib = hdmib | 16U;
  } else {

  }
  if ((int )adjusted_mode->flags & 1) {
    hdmib = hdmib | 8U;
  } else {

  }
  if (intel_crtc->pipe == 1) {
    hdmib = hdmib | 1073741824U;
  } else {

  }
  if ((int )hdmi_priv->has_hdmi_audio) {
    hdmib = hdmib | 64U;
    hdmib = hdmib | 512U;
  } else {

  }
  REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib);
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
  return;
}
}
static bool cdv_hdmi_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                struct drm_display_mode *adjusted_mode ) 
{ 

  {
  return (1);
}
}
static void cdv_hdmi_dpms(struct drm_encoder *encoder , int mode ) 
{ struct drm_device *dev ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  u32 hdmib ;

  {
  dev = encoder->dev;
  __mptr = (struct drm_encoder  const  *)encoder;
  psb_intel_encoder = (struct psb_intel_encoder *)__mptr;
  hdmi_priv = (struct mid_intel_hdmi_priv *)psb_intel_encoder->dev_priv;
  hdmib = REGISTER_READ(dev, hdmi_priv->hdmi_reg);
  if (mode != 0) {
    REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib & 2147483647U);
  } else {
    REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmib | 2147483648U);
  }
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
  return;
}
}
static void cdv_hdmi_save(struct drm_connector *connector ) 
{ struct drm_device *dev ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;

  {
  dev = connector->dev;
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  hdmi_priv = (struct mid_intel_hdmi_priv *)psb_intel_encoder->dev_priv;
  hdmi_priv->save_HDMIB = REGISTER_READ(dev, hdmi_priv->hdmi_reg);
  return;
}
}
static void cdv_hdmi_restore(struct drm_connector *connector ) 
{ struct drm_device *dev ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;

  {
  dev = connector->dev;
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  hdmi_priv = (struct mid_intel_hdmi_priv *)psb_intel_encoder->dev_priv;
  REGISTER_WRITE(dev, hdmi_priv->hdmi_reg, hdmi_priv->save_HDMIB);
  REGISTER_READ(dev, hdmi_priv->hdmi_reg);
  return;
}
}
static enum drm_connector_status cdv_hdmi_detect(struct drm_connector *connector ,
                                                 bool force ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  struct edid *edid ;
  enum drm_connector_status status ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  hdmi_priv = (struct mid_intel_hdmi_priv *)psb_intel_encoder->dev_priv;
  edid = 0;
  status = 2;
  edid = drm_get_edid(connector, & (psb_intel_encoder->i2c_bus)->adapter);
  hdmi_priv->has_hdmi_sink = 0;
  hdmi_priv->has_hdmi_audio = 0;
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    if ((int )((signed char )edid->input) < 0) {
      status = 1;
      hdmi_priv->has_hdmi_sink = drm_detect_hdmi_monitor(edid);
      hdmi_priv->has_hdmi_audio = drm_detect_monitor_audio(edid);
    } else {

    }
    kfree((void const   *)edid);
  } else {

  }
  return (status);
}
}
static int cdv_hdmi_set_property(struct drm_connector *connector , struct drm_property *property ,
                                 uint64_t value ) 
{ struct drm_encoder *encoder ;
  struct psb_intel_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  bool centre ;
  uint64_t curValue ;
  int tmp ;
  int tmp___0 ;
  struct drm_encoder_helper_funcs *helpers ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  encoder = connector->encoder;
  tmp___3 = strcmp((char const   *)(& property->name), "scaling mode");
  if (tmp___3 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
    crtc = (struct psb_intel_crtc *)__mptr;
    if ((unsigned long )crtc == (unsigned long )((struct psb_intel_crtc *)0)) {
      return (-1);
    } else {

    }
    switch (value) {
    case 1: ;
    goto ldv_38342;
    case 2: ;
    goto ldv_38342;
    case 3: ;
    goto ldv_38342;
    default: ;
    return (-1);
    }
    ldv_38342: 
    tmp = drm_object_property_get_value(& connector->base, property, & curValue);
    if (tmp != 0) {
      return (-1);
    } else {

    }
    if (curValue == value) {
      return (0);
    } else {

    }
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
    if (tmp___0 != 0) {
      return (-1);
    } else {

    }
    centre = (bool )(curValue == 2ULL || value == 2ULL);
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
      if ((int )centre) {
        tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                           (encoder->crtc)->y, (encoder->crtc)->fb);
        if (tmp___1) {
          tmp___2 = 0;
        } else {
          tmp___2 = 1;
        }
        if (tmp___2) {
          return (-1);
        } else {
          helpers = (struct drm_encoder_helper_funcs *)encoder->helper_private;
          (*(helpers->mode_set))(encoder, & crtc->saved_mode, & crtc->saved_adjusted_mode);
        }
      } else {

      }
    } else {

    }
  } else {

  }
  return (0);
}
}
static int cdv_hdmi_get_modes(struct drm_connector *connector ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct edid *edid ;
  int ret ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  edid = 0;
  ret = 0;
  edid = drm_get_edid(connector, & (psb_intel_encoder->i2c_bus)->adapter);
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    drm_mode_connector_update_edid_property(connector, edid);
    ret = drm_add_edid_modes(connector, edid);
    kfree((void const   *)edid);
  } else {

  }
  return (ret);
}
}
static int cdv_hdmi_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 

  {
  if (mode->clock > 165000) {
    return (15);
  } else {

  }
  if (mode->clock <= 19999) {
    return (15);
  } else {

  }
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {

  }
  if ((mode->flags & 16U) != 0U) {
    return (7);
  } else {

  }
  return (0);
}
}
static void cdv_hdmi_destroy(struct drm_connector *connector ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  if ((unsigned long )psb_intel_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    psb_intel_i2c_destroy(psb_intel_encoder->i2c_bus);
  } else {

  }
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const   *)connector);
  return;
}
}
static struct drm_encoder_helper_funcs  const  cdv_hdmi_helper_funcs  = 
     {& cdv_hdmi_dpms, 0, 0, & cdv_hdmi_mode_fixup, & psb_intel_encoder_prepare, & psb_intel_encoder_commit,
    & cdv_hdmi_mode_set, 0, 0, 0};
static struct drm_connector_helper_funcs  const  cdv_hdmi_connector_helper_funcs  =    {& cdv_hdmi_get_modes,
    & cdv_hdmi_mode_valid, & psb_intel_best_encoder};
static struct drm_connector_funcs  const  cdv_hdmi_connector_funcs  = 
     {& drm_helper_connector_dpms, & cdv_hdmi_save, & cdv_hdmi_restore, 0, & cdv_hdmi_detect,
    & drm_helper_probe_single_connector_modes, & cdv_hdmi_set_property, & cdv_hdmi_destroy,
    0};
void cdv_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                   int reg ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_connector *psb_intel_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct mid_intel_hdmi_priv *hdmi_priv ;
  int ddc_bus ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  tmp = kzalloc(136UL, 208U);
  psb_intel_encoder = (struct psb_intel_encoder *)tmp;
  if ((unsigned long )psb_intel_encoder == (unsigned long )((struct psb_intel_encoder *)0)) {
    return;
  } else {

  }
  tmp___0 = kzalloc(1864UL, 208U);
  psb_intel_connector = (struct psb_intel_connector *)tmp___0;
  if ((unsigned long )psb_intel_connector == (unsigned long )((struct psb_intel_connector *)0)) {
    goto err_connector;
  } else {

  }
  tmp___1 = kzalloc(40UL, 208U);
  hdmi_priv = (struct mid_intel_hdmi_priv *)tmp___1;
  if ((unsigned long )hdmi_priv == (unsigned long )((struct mid_intel_hdmi_priv *)0)) {
    goto err_priv;
  } else {

  }
  connector = & psb_intel_connector->base;
  encoder = & psb_intel_encoder->base;
  drm_connector_init(dev, connector, & cdv_hdmi_connector_funcs, 3);
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 2);
  psb_intel_connector_attach_encoder(psb_intel_connector, psb_intel_encoder);
  psb_intel_encoder->type = 6;
  hdmi_priv->hdmi_reg = (u32 )reg;
  hdmi_priv->has_hdmi_sink = 0;
  psb_intel_encoder->dev_priv = (void *)hdmi_priv;
  drm_encoder_helper_add(encoder, & cdv_hdmi_helper_funcs);
  drm_connector_helper_add(connector, & cdv_hdmi_connector_helper_funcs);
  connector->display_info.subpixel_order = 1;
  connector->interlace_allowed = 0;
  connector->doublescan_allowed = 0;
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
  switch (reg) {
  case 397632: 
  ddc_bus = 20512;
  psb_intel_encoder->ddi_select = 1U;
  goto ldv_38378;
  case 397664: 
  ddc_bus = 20508;
  psb_intel_encoder->ddi_select = 2U;
  goto ldv_38378;
  default: 
  drm_err("cdv_hdmi_init", "unknown reg 0x%x for HDMI\n", reg);
  goto failed_ddc;
  }
  ldv_38378: ;
  if (reg == 397632) {
    tmp___2 = "HDMIB";
  } else {
    tmp___2 = "HDMIC";
  }
  psb_intel_encoder->i2c_bus = psb_intel_i2c_create(dev, (u32 const   )ddc_bus, tmp___2);
  if ((unsigned long )psb_intel_encoder->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    dev_err((struct device  const  *)dev->dev, "No ddc adapter available!\n");
    goto failed_ddc;
  } else {

  }
  hdmi_priv->hdmi_i2c_adapter = & (psb_intel_encoder->i2c_bus)->adapter;
  hdmi_priv->dev = dev;
  drm_sysfs_connector_add(connector);
  return;
  failed_ddc: 
  drm_encoder_cleanup(encoder);
  drm_connector_cleanup(connector);
  err_priv: 
  kfree((void const   *)psb_intel_connector);
  err_connector: 
  kfree((void const   *)psb_intel_encoder);
  return;
}
}
struct drm_display_mode *ldvarg204  ;
struct drm_display_mode *ldvarg203  ;
uint32_t ldvarg24  ;
struct drm_property *ldvarg27  ;
uint64_t ldvarg26  ;
struct drm_connector *cdv_hdmi_connector_helper_funcs_group0  ;
struct drm_connector *cdv_hdmi_connector_funcs_group0  ;
struct drm_display_mode *ldvarg33  ;
struct drm_display_mode *cdv_hdmi_helper_funcs_group0  ;
struct drm_encoder *cdv_hdmi_helper_funcs_group1  ;
extern int ldv_cdv_hdmi_connector_funcs_probe_17(void) ;
int ldvarg205  ;
uint32_t ldvarg25  ;
int ldvarg29  ;
bool ldvarg28  ;
void ldv_main_exported_18(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_18 == 1) {
    cdv_hdmi_get_modes(cdv_hdmi_connector_helper_funcs_group0);
    ldv_state_variable_18 = 1;
  } else {

  }
  goto ldv_38403;
  case 1: ;
  if (ldv_state_variable_18 == 1) {
    cdv_hdmi_mode_valid(cdv_hdmi_connector_helper_funcs_group0, ldvarg33);
    ldv_state_variable_18 = 1;
  } else {

  }
  goto ldv_38403;
  case 2: ;
  if (ldv_state_variable_18 == 1) {
    psb_intel_best_encoder(cdv_hdmi_connector_helper_funcs_group0);
    ldv_state_variable_18 = 1;
  } else {

  }
  goto ldv_38403;
  default: ;
  goto ldv_38403;
  }
  ldv_38403: ;
  return;
}
}
void ldv_main_exported_19(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_19 == 1) {
    cdv_hdmi_dpms(cdv_hdmi_helper_funcs_group1, ldvarg205);
    ldv_state_variable_19 = 1;
  } else {

  }
  goto ldv_38411;
  case 1: ;
  if (ldv_state_variable_19 == 1) {
    cdv_hdmi_mode_fixup(cdv_hdmi_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg204,
                        cdv_hdmi_helper_funcs_group0);
    ldv_state_variable_19 = 1;
  } else {

  }
  goto ldv_38411;
  case 2: ;
  if (ldv_state_variable_19 == 1) {
    psb_intel_encoder_commit(cdv_hdmi_helper_funcs_group1);
    ldv_state_variable_19 = 1;
  } else {

  }
  goto ldv_38411;
  case 3: ;
  if (ldv_state_variable_19 == 1) {
    cdv_hdmi_mode_set(cdv_hdmi_helper_funcs_group1, cdv_hdmi_helper_funcs_group0,
                      ldvarg203);
    ldv_state_variable_19 = 1;
  } else {

  }
  goto ldv_38411;
  case 4: ;
  if (ldv_state_variable_19 == 1) {
    psb_intel_encoder_prepare(cdv_hdmi_helper_funcs_group1);
    ldv_state_variable_19 = 1;
  } else {

  }
  goto ldv_38411;
  default: ;
  goto ldv_38411;
  }
  ldv_38411: ;
  return;
}
}
void ldv_main_exported_17(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_17 == 1) {
    drm_helper_connector_dpms(cdv_hdmi_connector_funcs_group0, ldvarg29);
    ldv_state_variable_17 = 1;
  } else {

  }
  if (ldv_state_variable_17 == 2) {
    drm_helper_connector_dpms(cdv_hdmi_connector_funcs_group0, ldvarg29);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_38421;
  case 1: ;
  if (ldv_state_variable_17 == 1) {
    cdv_hdmi_detect(cdv_hdmi_connector_funcs_group0, (int )ldvarg28);
    ldv_state_variable_17 = 1;
  } else {

  }
  if (ldv_state_variable_17 == 2) {
    cdv_hdmi_detect(cdv_hdmi_connector_funcs_group0, (int )ldvarg28);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_38421;
  case 2: ;
  if (ldv_state_variable_17 == 1) {
    cdv_hdmi_set_property(cdv_hdmi_connector_funcs_group0, ldvarg27, ldvarg26);
    ldv_state_variable_17 = 1;
  } else {

  }
  if (ldv_state_variable_17 == 2) {
    cdv_hdmi_set_property(cdv_hdmi_connector_funcs_group0, ldvarg27, ldvarg26);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_38421;
  case 3: ;
  if (ldv_state_variable_17 == 2) {
    cdv_hdmi_destroy(cdv_hdmi_connector_funcs_group0);
    ldv_state_variable_17 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38421;
  case 4: ;
  if (ldv_state_variable_17 == 1) {
    cdv_hdmi_save(cdv_hdmi_connector_funcs_group0);
    ldv_state_variable_17 = 1;
  } else {

  }
  if (ldv_state_variable_17 == 2) {
    cdv_hdmi_save(cdv_hdmi_connector_funcs_group0);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_38421;
  case 5: ;
  if (ldv_state_variable_17 == 1) {
    cdv_hdmi_restore(cdv_hdmi_connector_funcs_group0);
    ldv_state_variable_17 = 1;
  } else {

  }
  if (ldv_state_variable_17 == 2) {
    cdv_hdmi_restore(cdv_hdmi_connector_funcs_group0);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_38421;
  case 6: ;
  if (ldv_state_variable_17 == 1) {
    drm_helper_probe_single_connector_modes(cdv_hdmi_connector_funcs_group0, ldvarg25,
                                            ldvarg24);
    ldv_state_variable_17 = 1;
  } else {

  }
  if (ldv_state_variable_17 == 2) {
    drm_helper_probe_single_connector_modes(cdv_hdmi_connector_funcs_group0, ldvarg25,
                                            ldvarg24);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_38421;
  case 7: ;
  if (ldv_state_variable_17 == 1) {
    ldv_cdv_hdmi_connector_funcs_probe_17();
    ldv_state_variable_17 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38421;
  default: ;
  goto ldv_38421;
  }
  ldv_38421: ;
  return;
}
}
void ldv_mutex_lock_601(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_602(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_603(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_604(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_605(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_606(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_607(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_608(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_609(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_610(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_611(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_612(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_628(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_626(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_629(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_631(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_633(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_634(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_636(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_625(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_627(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_630(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_632(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_635(struct mutex *ldv_func_arg1 ) ;
static u32 cdv_intel_lvds_get_max_backlight(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 retval ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp___0 = gma_power_begin(dev, 0);
  if ((int )tmp___0) {
    tmp = REGISTER_READ(dev, 397908U);
    retval = (tmp >> 17) * 2U;
    gma_power_end(dev);
  } else {
    retval = (dev_priv->regs.saveBLC_PWM_CTL >> 17) * 2U;
  }
  return (retval);
}
}
static void cdv_intel_lvds_set_backlight(struct drm_device *dev , int level ) 
{ struct drm_psb_private *dev_priv ;
  u32 blc_pwm_ctl ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp___0 = gma_power_begin(dev, 0);
  if ((int )tmp___0) {
    tmp = REGISTER_READ(dev, 397908U);
    blc_pwm_ctl = tmp & 4294901760U;
    REGISTER_WRITE(dev, 397908U, blc_pwm_ctl | (u32 )level);
    gma_power_end(dev);
  } else {
    blc_pwm_ctl = dev_priv->regs.saveBLC_PWM_CTL & 4294901760U;
    dev_priv->regs.saveBLC_PWM_CTL = blc_pwm_ctl | (u32 )level;
  }
  return;
}
}
static void cdv_intel_lvds_set_power(struct drm_device *dev , struct drm_encoder *encoder ,
                                     bool on ) 
{ struct drm_psb_private *dev_priv ;
  u32 pp_status ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  if ((int )on) {
    tmp___1 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_38282: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status >= 0) {
      goto ldv_38282;
    } else {
      goto ldv_38283;
    }
    ldv_38283: 
    cdv_intel_lvds_set_backlight(dev, dev_priv->mode_dev.backlight_duty_cycle);
  } else {
    cdv_intel_lvds_set_backlight(dev, 0);
    tmp___2 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_38284: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status < 0) {
      goto ldv_38284;
    } else {
      goto ldv_38285;
    }
    ldv_38285: ;
  }
  gma_power_end(dev);
  return;
}
}
static void cdv_intel_lvds_encoder_dpms(struct drm_encoder *encoder , int mode ) 
{ struct drm_device *dev ;

  {
  dev = encoder->dev;
  if (mode == 0) {
    cdv_intel_lvds_set_power(dev, encoder, 1);
  } else {
    cdv_intel_lvds_set_power(dev, encoder, 0);
  }
  return;
}
}
static void cdv_intel_lvds_save(struct drm_connector *connector ) 
{ 

  {
  return;
}
}
static void cdv_intel_lvds_restore(struct drm_connector *connector ) 
{ 

  {
  return;
}
}
static int cdv_intel_lvds_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *fixed_mode ;

  {
  dev = connector->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  fixed_mode = dev_priv->mode_dev.panel_fixed_mode;
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {

  }
  if ((mode->flags & 16U) != 0U) {
    return (7);
  } else {

  }
  if ((unsigned long )fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    if (mode->hdisplay > fixed_mode->hdisplay) {
      return (29);
    } else {

    }
    if (mode->vdisplay > fixed_mode->vdisplay) {
      return (29);
    } else {

    }
  } else {

  }
  return (0);
}
}
static bool cdv_intel_lvds_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                      struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct drm_encoder *tmp_encoder ;
  struct drm_display_mode *panel_fixed_mode ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  panel_fixed_mode = mode_dev->panel_fixed_mode;
  __mptr = (struct list_head  const  *)dev->mode_config.encoder_list.next;
  tmp_encoder = (struct drm_encoder *)__mptr + 0xfffffffffffffff8UL;
  goto ldv_38319;
  ldv_38318: ;
  if ((unsigned long )tmp_encoder != (unsigned long )encoder && (unsigned long )tmp_encoder->crtc == (unsigned long )encoder->crtc) {
    printk("\vCan\'t enable LVDS and another encoder on the same pipe\n");
    return (0);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)tmp_encoder->head.next;
  tmp_encoder = (struct drm_encoder *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_38319: ;
  if ((unsigned long )(& tmp_encoder->head) != (unsigned long )(& dev->mode_config.encoder_list)) {
    goto ldv_38318;
  } else {
    goto ldv_38320;
  }
  ldv_38320: ;
  if ((unsigned long )panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    adjusted_mode->hdisplay = panel_fixed_mode->hdisplay;
    adjusted_mode->hsync_start = panel_fixed_mode->hsync_start;
    adjusted_mode->hsync_end = panel_fixed_mode->hsync_end;
    adjusted_mode->htotal = panel_fixed_mode->htotal;
    adjusted_mode->vdisplay = panel_fixed_mode->vdisplay;
    adjusted_mode->vsync_start = panel_fixed_mode->vsync_start;
    adjusted_mode->vsync_end = panel_fixed_mode->vsync_end;
    adjusted_mode->vtotal = panel_fixed_mode->vtotal;
    adjusted_mode->clock = panel_fixed_mode->clock;
    drm_mode_set_crtcinfo(adjusted_mode, 1);
  } else {

  }
  return (1);
}
}
static void cdv_intel_lvds_prepare(struct drm_encoder *encoder ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
  cdv_intel_lvds_set_power(dev, encoder, 0);
  gma_power_end(dev);
  return;
}
}
static void cdv_intel_lvds_commit(struct drm_encoder *encoder ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  if (mode_dev->backlight_duty_cycle == 0) {
    tmp = cdv_intel_lvds_get_max_backlight(dev);
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
  cdv_intel_lvds_set_power(dev, encoder, 1);
  return;
}
}
static void cdv_intel_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  u32 pfit_control ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)encoder->crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
    pfit_control = 2147485280U;
  } else {
    pfit_control = 0U;
  }
  pfit_control = (u32 )(psb_intel_crtc->pipe << 29) | pfit_control;
  if ((unsigned int )*((unsigned char *)dev_priv + 824UL) != 0U) {
    pfit_control = pfit_control | 8U;
  } else {

  }
  REGISTER_WRITE(dev, 397872U, pfit_control);
  return;
}
}
static enum drm_connector_status cdv_intel_lvds_detect(struct drm_connector *connector ,
                                                       bool force ) 
{ 

  {
  return (1);
}
}
static int cdv_intel_lvds_get_modes(struct drm_connector *connector ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct psb_intel_mode_device *mode_dev ;
  int ret ;
  struct drm_display_mode *mode ;
  struct drm_display_mode *tmp___0 ;

  {
  dev = connector->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  mode_dev = & dev_priv->mode_dev;
  ret = psb_intel_ddc_get_modes(connector, & (psb_intel_encoder->i2c_bus)->adapter);
  if (ret != 0) {
    return (ret);
  } else {

  }
  connector->display_info.min_vfreq = 0U;
  connector->display_info.max_vfreq = 200U;
  connector->display_info.min_hfreq = 0U;
  connector->display_info.max_hfreq = 200U;
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    tmp___0 = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->panel_fixed_mode);
    mode = tmp___0;
    drm_mode_probed_add(connector, mode);
    return (1);
  } else {

  }
  return (0);
}
}
static void cdv_intel_lvds_destroy(struct drm_connector *connector ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  if ((unsigned long )psb_intel_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    psb_intel_i2c_destroy(psb_intel_encoder->i2c_bus);
  } else {

  }
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const   *)connector);
  return;
}
}
static int cdv_intel_lvds_set_property(struct drm_connector *connector , struct drm_property *property ,
                                       uint64_t value ) 
{ struct drm_encoder *encoder ;
  struct psb_intel_crtc *crtc ;
  struct drm_crtc  const  *__mptr ;
  uint64_t curValue ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct drm_encoder_helper_funcs *helpers ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  encoder = connector->encoder;
  tmp___6 = strcmp((char const   *)(& property->name), "scaling mode");
  if (tmp___6 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
    __mptr = (struct drm_crtc  const  *)encoder->crtc;
    crtc = (struct psb_intel_crtc *)__mptr;
    if ((unsigned long )crtc == (unsigned long )((struct psb_intel_crtc *)0)) {
      return (-1);
    } else {

    }
    switch (value) {
    case 1: ;
    goto ldv_38372;
    case 2: ;
    goto ldv_38372;
    case 3: ;
    goto ldv_38372;
    default: ;
    return (-1);
    }
    ldv_38372: 
    tmp = drm_object_property_get_value(& connector->base, property, & curValue);
    if (tmp != 0) {
      return (-1);
    } else {

    }
    if (curValue == value) {
      return (0);
    } else {

    }
    tmp___0 = drm_object_property_set_value(& connector->base, property, value);
    if (tmp___0 != 0) {
      return (-1);
    } else {

    }
    if (crtc->saved_mode.hdisplay != 0 && crtc->saved_mode.vdisplay != 0) {
      tmp___1 = drm_crtc_helper_set_mode(encoder->crtc, & crtc->saved_mode, (encoder->crtc)->x,
                                         (encoder->crtc)->y, (encoder->crtc)->fb);
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      if (tmp___2) {
        return (-1);
      } else {

      }
    } else {

    }
  } else {
    tmp___5 = strcmp((char const   *)(& property->name), "backlight");
    if (tmp___5 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
      tmp___3 = drm_object_property_set_value(& connector->base, property, value);
      if (tmp___3 != 0) {
        return (-1);
      } else {
        gma_backlight_set(encoder->dev, (int )value);
      }
    } else {
      tmp___4 = strcmp((char const   *)(& property->name), "DPMS");
      if (tmp___4 == 0 && (unsigned long )encoder != (unsigned long )((struct drm_encoder *)0)) {
        helpers = (struct drm_encoder_helper_funcs *)encoder->helper_private;
        (*(helpers->dpms))(encoder, (int )value);
      } else {

      }
    }
  }
  return (0);
}
}
static struct drm_encoder_helper_funcs  const  cdv_intel_lvds_helper_funcs  = 
     {& cdv_intel_lvds_encoder_dpms, 0, 0, & cdv_intel_lvds_mode_fixup, & cdv_intel_lvds_prepare,
    & cdv_intel_lvds_commit, & cdv_intel_lvds_mode_set, 0, 0, 0};
static struct drm_connector_helper_funcs  const  cdv_intel_lvds_connector_helper_funcs  =    {& cdv_intel_lvds_get_modes,
    & cdv_intel_lvds_mode_valid, & psb_intel_best_encoder};
static struct drm_connector_funcs  const  cdv_intel_lvds_connector_funcs  = 
     {& drm_helper_connector_dpms, & cdv_intel_lvds_save, & cdv_intel_lvds_restore,
    0, & cdv_intel_lvds_detect, & drm_helper_probe_single_connector_modes, & cdv_intel_lvds_set_property,
    & cdv_intel_lvds_destroy, 0};
static void cdv_intel_lvds_enc_destroy(struct drm_encoder *encoder ) 
{ 

  {
  drm_encoder_cleanup(encoder);
  return;
}
}
static struct drm_encoder_funcs  const  cdv_intel_lvds_enc_funcs  =    {0, & cdv_intel_lvds_enc_destroy};
static bool lvds_is_present_in_vbt(struct drm_device *dev , u8 *i2c_pin ) 
{ struct drm_psb_private *dev_priv ;
  int i ;
  struct child_device_config *child ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (dev_priv->child_dev_num == 0) {
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38393;
  ldv_38392: 
  child = dev_priv->child_dev + (unsigned long )i;
  if ((unsigned int )child->device_type != 4130U && (unsigned int )child->device_type != 34U) {
    goto ldv_38391;
  } else {

  }
  if ((unsigned int )child->i2c_pin != 0U) {
    *i2c_pin = child->i2c_pin;
  } else {

  }
  if ((unsigned int )child->addin_offset != 0U) {
    return (1);
  } else {

  }
  if ((unsigned long )dev_priv->opregion.vbt != (unsigned long )((void *)0)) {
    return (1);
  } else {

  }
  ldv_38391: 
  i = i + 1;
  ldv_38393: ;
  if (dev_priv->child_dev_num > i) {
    goto ldv_38392;
  } else {
    goto ldv_38394;
  }
  ldv_38394: ;
  return (0);
}
}
void cdv_intel_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_connector *psb_intel_connector ;
  struct cdv_intel_lvds_priv *lvds_priv ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_display_mode *scan ;
  struct drm_crtc *crtc ;
  struct drm_psb_private *dev_priv ;
  u32 lvds ;
  int pipe ;
  u8 pin ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u32 pwm ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pin = 3U;
  tmp = lvds_is_present_in_vbt(dev, & pin);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_lvds_init", "LVDS is not present in VBT\n");
    return;
  } else {

  }
  tmp___1 = kzalloc(136UL, 208U);
  psb_intel_encoder = (struct psb_intel_encoder *)tmp___1;
  if ((unsigned long )psb_intel_encoder == (unsigned long )((struct psb_intel_encoder *)0)) {
    return;
  } else {

  }
  tmp___2 = kzalloc(1864UL, 208U);
  psb_intel_connector = (struct psb_intel_connector *)tmp___2;
  if ((unsigned long )psb_intel_connector == (unsigned long )((struct psb_intel_connector *)0)) {
    goto failed_connector;
  } else {

  }
  tmp___3 = kzalloc(32UL, 208U);
  lvds_priv = (struct cdv_intel_lvds_priv *)tmp___3;
  if ((unsigned long )lvds_priv == (unsigned long )((struct cdv_intel_lvds_priv *)0)) {
    goto failed_lvds_priv;
  } else {

  }
  psb_intel_encoder->dev_priv = (void *)lvds_priv;
  connector = & psb_intel_connector->base;
  encoder = & psb_intel_encoder->base;
  drm_connector_init(dev, connector, & cdv_intel_lvds_connector_funcs, 7);
  drm_encoder_init(dev, encoder, & cdv_intel_lvds_enc_funcs, 3);
  psb_intel_connector_attach_encoder(psb_intel_connector, psb_intel_encoder);
  psb_intel_encoder->type = 4;
  drm_encoder_helper_add(encoder, & cdv_intel_lvds_helper_funcs);
  drm_connector_helper_add(connector, & cdv_intel_lvds_connector_helper_funcs);
  connector->display_info.subpixel_order = 1;
  connector->interlace_allowed = 0;
  connector->doublescan_allowed = 0;
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
  psb_intel_encoder->i2c_bus = psb_intel_i2c_create(dev, 20500U, "LVDSBLC_B");
  if ((unsigned long )psb_intel_encoder->i2c_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "I2C bus registration failed.\n");
    goto failed_blc_i2c;
  } else {

  }
  (psb_intel_encoder->i2c_bus)->slave_addr = 44U;
  dev_priv->lvds_i2c_bus = psb_intel_encoder->i2c_bus;
  psb_intel_encoder->ddc_bus = psb_intel_i2c_create(dev, 20504U, "LVDSDDC_C");
  if ((unsigned long )psb_intel_encoder->ddc_bus == (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    dev_printk("\v", (struct device  const  *)(& (dev->pdev)->dev), "DDC bus registration failed.\n");
    goto failed_ddc;
  } else {

  }
  psb_intel_ddc_get_modes(connector, & (psb_intel_encoder->ddc_bus)->adapter);
  __mptr = (struct list_head  const  *)connector->probed_modes.next;
  scan = (struct drm_display_mode *)__mptr;
  goto ldv_38421;
  ldv_38420: ;
  if ((scan->type & 8U) != 0U) {
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
    goto out;
  } else {

  }
  __mptr___0 = (struct list_head  const  *)scan->head.next;
  scan = (struct drm_display_mode *)__mptr___0;
  ldv_38421: ;
  if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
    goto ldv_38420;
  } else {
    goto ldv_38422;
  }
  ldv_38422: ;
  if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
      goto out;
    } else {

    }
  } else {

  }
  lvds = REGISTER_READ(dev, 397696U);
  pipe = (lvds & 1073741824U) != 0U;
  crtc = psb_intel_get_crtc_from_pipe(dev, pipe);
  if ((unsigned long )crtc != (unsigned long )((struct drm_crtc *)0) && (int )lvds < 0) {
    mode_dev->panel_fixed_mode = cdv_intel_crtc_mode_get(dev, crtc);
    if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
      goto out;
    } else {

    }
  } else {

  }
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    drm_ut_debug_printk(1U, "drm", "cdv_intel_lvds_init", "Found no modes on the lvds, ignoring the LVDS\n");
    goto failed_find;
  } else {

  }
  pwm = REGISTER_READ(dev, 397904U);
  if (pipe == 1) {
    pwm = pwm | 536870912U;
  } else {
    pwm = pwm & 3758096383U;
  }
  pwm = pwm | 2147483648U;
  REGISTER_WRITE(dev, 397904U, pwm);
  out: 
  drm_sysfs_connector_add(connector);
  return;
  failed_find: 
  printk("\vFailed find\n");
  if ((unsigned long )psb_intel_encoder->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    psb_intel_i2c_destroy(psb_intel_encoder->ddc_bus);
  } else {

  }
  failed_ddc: 
  printk("\vFailed DDC\n");
  if ((unsigned long )psb_intel_encoder->i2c_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    psb_intel_i2c_destroy(psb_intel_encoder->i2c_bus);
  } else {

  }
  failed_blc_i2c: 
  printk("\vFailed BLC\n");
  drm_encoder_cleanup(encoder);
  drm_connector_cleanup(connector);
  kfree((void const   *)lvds_priv);
  failed_lvds_priv: 
  kfree((void const   *)psb_intel_connector);
  failed_connector: 
  kfree((void const   *)psb_intel_encoder);
  return;
}
}
struct drm_property *ldvarg60  ;
uint64_t ldvarg59  ;
int ldvarg62  ;
struct drm_encoder *ldvarg123  ;
uint32_t ldvarg57  ;
extern int ldv_cdv_intel_lvds_connector_funcs_probe_14(void) ;
uint32_t ldvarg58  ;
int ldvarg37  ;
struct drm_display_mode *ldvarg36  ;
struct drm_connector *cdv_intel_lvds_connector_funcs_group0  ;
struct drm_display_mode *cdv_intel_lvds_helper_funcs_group0  ;
extern int ldv_cdv_intel_lvds_enc_funcs_probe_13(void) ;
struct drm_display_mode *ldvarg35  ;
struct drm_encoder *cdv_intel_lvds_helper_funcs_group1  ;
struct drm_connector *cdv_intel_lvds_connector_helper_funcs_group0  ;
struct drm_display_mode *ldvarg180  ;
bool ldvarg61  ;
void ldv_main_exported_16(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_16 == 1) {
    cdv_intel_lvds_encoder_dpms(cdv_intel_lvds_helper_funcs_group1, ldvarg37);
    ldv_state_variable_16 = 1;
  } else {

  }
  goto ldv_38448;
  case 1: ;
  if (ldv_state_variable_16 == 1) {
    cdv_intel_lvds_mode_fixup(cdv_intel_lvds_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg36,
                              cdv_intel_lvds_helper_funcs_group0);
    ldv_state_variable_16 = 1;
  } else {

  }
  goto ldv_38448;
  case 2: ;
  if (ldv_state_variable_16 == 1) {
    cdv_intel_lvds_commit(cdv_intel_lvds_helper_funcs_group1);
    ldv_state_variable_16 = 1;
  } else {

  }
  goto ldv_38448;
  case 3: ;
  if (ldv_state_variable_16 == 1) {
    cdv_intel_lvds_mode_set(cdv_intel_lvds_helper_funcs_group1, cdv_intel_lvds_helper_funcs_group0,
                            ldvarg35);
    ldv_state_variable_16 = 1;
  } else {

  }
  goto ldv_38448;
  case 4: ;
  if (ldv_state_variable_16 == 1) {
    cdv_intel_lvds_prepare(cdv_intel_lvds_helper_funcs_group1);
    ldv_state_variable_16 = 1;
  } else {

  }
  goto ldv_38448;
  default: ;
  goto ldv_38448;
  }
  ldv_38448: ;
  return;
}
}
void ldv_main_exported_13(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_13 == 2) {
    cdv_intel_lvds_enc_destroy(ldvarg123);
    ldv_state_variable_13 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38458;
  case 1: ;
  if (ldv_state_variable_13 == 1) {
    ldv_cdv_intel_lvds_enc_funcs_probe_13();
    ldv_state_variable_13 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38458;
  default: ;
  goto ldv_38458;
  }
  ldv_38458: ;
  return;
}
}
void ldv_main_exported_15(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_15 == 1) {
    cdv_intel_lvds_get_modes(cdv_intel_lvds_connector_helper_funcs_group0);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_38465;
  case 1: ;
  if (ldv_state_variable_15 == 1) {
    cdv_intel_lvds_mode_valid(cdv_intel_lvds_connector_helper_funcs_group0, ldvarg180);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_38465;
  case 2: ;
  if (ldv_state_variable_15 == 1) {
    psb_intel_best_encoder(cdv_intel_lvds_connector_helper_funcs_group0);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_38465;
  default: ;
  goto ldv_38465;
  }
  ldv_38465: ;
  return;
}
}
void ldv_main_exported_14(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_14 == 2) {
    drm_helper_connector_dpms(cdv_intel_lvds_connector_funcs_group0, ldvarg62);
    ldv_state_variable_14 = 2;
  } else {

  }
  if (ldv_state_variable_14 == 1) {
    drm_helper_connector_dpms(cdv_intel_lvds_connector_funcs_group0, ldvarg62);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_38473;
  case 1: ;
  if (ldv_state_variable_14 == 2) {
    cdv_intel_lvds_detect(cdv_intel_lvds_connector_funcs_group0, (int )ldvarg61);
    ldv_state_variable_14 = 2;
  } else {

  }
  if (ldv_state_variable_14 == 1) {
    cdv_intel_lvds_detect(cdv_intel_lvds_connector_funcs_group0, (int )ldvarg61);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_38473;
  case 2: ;
  if (ldv_state_variable_14 == 2) {
    cdv_intel_lvds_set_property(cdv_intel_lvds_connector_funcs_group0, ldvarg60, ldvarg59);
    ldv_state_variable_14 = 2;
  } else {

  }
  if (ldv_state_variable_14 == 1) {
    cdv_intel_lvds_set_property(cdv_intel_lvds_connector_funcs_group0, ldvarg60, ldvarg59);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_38473;
  case 3: ;
  if (ldv_state_variable_14 == 2) {
    cdv_intel_lvds_destroy(cdv_intel_lvds_connector_funcs_group0);
    ldv_state_variable_14 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38473;
  case 4: ;
  if (ldv_state_variable_14 == 2) {
    cdv_intel_lvds_save(cdv_intel_lvds_connector_funcs_group0);
    ldv_state_variable_14 = 2;
  } else {

  }
  if (ldv_state_variable_14 == 1) {
    cdv_intel_lvds_save(cdv_intel_lvds_connector_funcs_group0);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_38473;
  case 5: ;
  if (ldv_state_variable_14 == 2) {
    cdv_intel_lvds_restore(cdv_intel_lvds_connector_funcs_group0);
    ldv_state_variable_14 = 2;
  } else {

  }
  if (ldv_state_variable_14 == 1) {
    cdv_intel_lvds_restore(cdv_intel_lvds_connector_funcs_group0);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_38473;
  case 6: ;
  if (ldv_state_variable_14 == 2) {
    drm_helper_probe_single_connector_modes(cdv_intel_lvds_connector_funcs_group0,
                                            ldvarg58, ldvarg57);
    ldv_state_variable_14 = 2;
  } else {

  }
  if (ldv_state_variable_14 == 1) {
    drm_helper_probe_single_connector_modes(cdv_intel_lvds_connector_funcs_group0,
                                            ldvarg58, ldvarg57);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_38473;
  case 7: ;
  if (ldv_state_variable_14 == 1) {
    ldv_cdv_intel_lvds_connector_funcs_probe_14();
    ldv_state_variable_14 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38473;
  default: ;
  goto ldv_38473;
  }
  ldv_38473: ;
  return;
}
}
void ldv_mutex_lock_625(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_626(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_627(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_628(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_629(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_630(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_631(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_632(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_633(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_634(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_635(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_636(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_652(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_650(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_653(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_655(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_657(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_658(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_660(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_649(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_651(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_654(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_656(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_659(struct mutex *ldv_func_arg1 ) ;
extern int i2c_dp_aux_add_bus(struct i2c_adapter * ) ;
static struct ddi_regoff ddi_DP_train_table[2U]  = {      {33068U, 33060U, 33108U, 33096U, 33100U, 33104U, 33112U}, 
        {33324U, 33316U, 33364U, 33352U, 33356U, 33360U, 33368U}};
static uint32_t dp_vswing_premph_table[8U]  = 
  {      1429440852U,      16384U,      1431144788U,      8192U, 
        1432783188U,      0U,      1436205268U,      24576U};
static bool is_edp(struct psb_intel_encoder *encoder ) 
{ 

  {
  return (encoder->type == 10);
}
}
static void cdv_intel_dp_start_link_train(struct psb_intel_encoder *encoder ) ;
static void cdv_intel_dp_complete_link_train(struct psb_intel_encoder *encoder ) ;
static void cdv_intel_dp_link_down(struct psb_intel_encoder *encoder ) ;
static int cdv_intel_dp_max_lane_count(struct psb_intel_encoder *encoder ) 
{ struct cdv_intel_dp *intel_dp ;
  int max_lane_count ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  max_lane_count = 4;
  if ((unsigned int )intel_dp->dpcd[0] > 16U) {
    max_lane_count = (int )intel_dp->dpcd[2] & 31;
    switch (max_lane_count) {
    case 1: ;
    case 2: ;
    case 4: ;
    goto ldv_38041;
    default: 
    max_lane_count = 4;
    }
    ldv_38041: ;
  } else {

  }
  return (max_lane_count);
}
}
static int cdv_intel_dp_max_link_bw(struct psb_intel_encoder *encoder ) 
{ struct cdv_intel_dp *intel_dp ;
  int max_link_bw ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  max_link_bw = (int )intel_dp->dpcd[1];
  switch (max_link_bw) {
  case 6: ;
  case 10: ;
  goto ldv_38050;
  default: 
  max_link_bw = 6;
  goto ldv_38050;
  }
  ldv_38050: ;
  return (max_link_bw);
}
}
static int cdv_intel_dp_link_clock(uint8_t link_bw ) 
{ 

  {
  if ((unsigned int )link_bw == 10U) {
    return (270000);
  } else {
    return (162000);
  }
}
}
static int cdv_intel_dp_link_required(int pixel_clock , int bpp ) 
{ 

  {
  return ((pixel_clock * bpp + 7) / 8);
}
}
static int cdv_intel_dp_max_data_rate(int max_link_clock , int max_lanes ) 
{ 

  {
  return (((max_link_clock * max_lanes) * 19) / 20);
}
}
static void cdv_intel_edp_panel_vdd_on(struct psb_intel_encoder *intel_encoder ) 
{ struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;

  {
  dev = intel_encoder->base.dev;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  if ((int )intel_dp->panel_on) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_vdd_on", "Skip VDD on because of panel on\n");
    return;
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_vdd_on", "\n");
  pp = REGISTER_READ(dev, 397828U);
  pp = pp | 8U;
  REGISTER_WRITE(dev, 397828U, pp);
  REGISTER_READ(dev, 397828U);
  msleep((unsigned int )intel_dp->panel_power_up_delay);
  return;
}
}
static void cdv_intel_edp_panel_vdd_off(struct psb_intel_encoder *intel_encoder ) 
{ struct drm_device *dev ;
  u32 pp ;

  {
  dev = intel_encoder->base.dev;
  drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_vdd_off", "\n");
  pp = REGISTER_READ(dev, 397828U);
  pp = pp & 4294967287U;
  REGISTER_WRITE(dev, 397828U, pp);
  REGISTER_READ(dev, 397828U);
  return;
}
}
static bool cdv_intel_edp_panel_on(struct psb_intel_encoder *intel_encoder ) 
{ struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;
  u32 idle_on_mask ;
  uint32_t tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___1 ;
  uint32_t tmp___2 ;

  {
  dev = intel_encoder->base.dev;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  idle_on_mask = 2147483648U;
  if ((int )intel_dp->panel_on) {
    return (1);
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_on", "\n");
  pp = REGISTER_READ(dev, 397828U);
  pp = pp & 65535U;
  pp = pp | 2882338817U;
  REGISTER_WRITE(dev, 397828U, pp);
  REGISTER_READ(dev, 397828U);
  tmp___0 = msecs_to_jiffies(1000U);
  timeout__ = tmp___0 + (unsigned long )jiffies;
  ret__ = 0;
  goto ldv_38135;
  ldv_38134: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38092;
  } else {

  }
  __vpp_verify = 0;
  switch (4UL) {
  case 1: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
  goto ldv_38098;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38098;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38098;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38098;
  default: 
  __bad_percpu_size();
  }
  ldv_38098: 
  pscr_ret__ = pfo_ret__;
  goto ldv_38104;
  case 2: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38108;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38108;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38108;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38108;
  default: 
  __bad_percpu_size();
  }
  ldv_38108: 
  pscr_ret__ = pfo_ret_____0;
  goto ldv_38104;
  case 4: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38117;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38117;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38117;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38117;
  default: 
  __bad_percpu_size();
  }
  ldv_38117: 
  pscr_ret__ = pfo_ret_____1;
  goto ldv_38104;
  case 8: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38126;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38126;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38126;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38126;
  default: 
  __bad_percpu_size();
  }
  ldv_38126: 
  pscr_ret__ = pfo_ret_____2;
  goto ldv_38104;
  default: 
  __bad_size_call_parameter();
  goto ldv_38104;
  }
  ldv_38104: 
  tmp___1 = atomic_read((atomic_t const   *)(& kgdb_active));
  if (pscr_ret__ != tmp___1) {
    msleep(1U);
  } else {

  }
  ldv_38135: 
  tmp___2 = REGISTER_READ(dev, 397824U);
  if ((tmp___2 & idle_on_mask) != idle_on_mask) {
    goto ldv_38134;
  } else {
    goto ldv_38092;
  }
  ldv_38092: ;
  if (ret__ != 0) {
    tmp = REGISTER_READ(dev, 397824U);
    drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_on", "Error in Powering up eDP panel, status %x\n",
                        tmp);
    intel_dp->panel_on = 0;
  } else {
    intel_dp->panel_on = 1;
  }
  msleep((unsigned int )intel_dp->panel_power_up_delay);
  return (0);
}
}
static void cdv_intel_edp_panel_off(struct psb_intel_encoder *intel_encoder ) 
{ struct drm_device *dev ;
  u32 pp ;
  u32 idle_off_mask ;
  struct cdv_intel_dp *intel_dp ;
  uint32_t tmp ;
  unsigned long timeout__ ;
  unsigned long tmp___0 ;
  int ret__ ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___1 ;
  uint32_t tmp___2 ;

  {
  dev = intel_encoder->base.dev;
  idle_off_mask = 2147483648U;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_off", "\n");
  pp = REGISTER_READ(dev, 397828U);
  if ((pp & 1U) == 0U) {
    return;
  } else {

  }
  intel_dp->panel_on = 0;
  pp = pp & 65535U;
  pp = pp & 4294967294U;
  pp = pp & 4294967287U;
  pp = pp & 4294967291U;
  REGISTER_WRITE(dev, 397828U, pp);
  REGISTER_READ(dev, 397828U);
  tmp = REGISTER_READ(dev, 397824U);
  drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_off", "PP_STATUS %x\n", tmp);
  tmp___0 = msecs_to_jiffies(1000U);
  timeout__ = tmp___0 + (unsigned long )jiffies;
  ret__ = 0;
  goto ldv_38196;
  ldv_38195: ;
  if ((long )timeout__ - (long )jiffies < 0L) {
    ret__ = -110;
    goto ldv_38153;
  } else {

  }
  __vpp_verify = 0;
  switch (4UL) {
  case 1: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
  goto ldv_38159;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38159;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38159;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
  goto ldv_38159;
  default: 
  __bad_percpu_size();
  }
  ldv_38159: 
  pscr_ret__ = pfo_ret__;
  goto ldv_38165;
  case 2: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38169;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38169;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38169;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
  goto ldv_38169;
  default: 
  __bad_percpu_size();
  }
  ldv_38169: 
  pscr_ret__ = pfo_ret_____0;
  goto ldv_38165;
  case 4: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38178;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38178;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38178;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
  goto ldv_38178;
  default: 
  __bad_percpu_size();
  }
  ldv_38178: 
  pscr_ret__ = pfo_ret_____1;
  goto ldv_38165;
  case 8: ;
  switch (4UL) {
  case 1: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38187;
  case 2: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38187;
  case 4: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38187;
  case 8: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
  goto ldv_38187;
  default: 
  __bad_percpu_size();
  }
  ldv_38187: 
  pscr_ret__ = pfo_ret_____2;
  goto ldv_38165;
  default: 
  __bad_size_call_parameter();
  goto ldv_38165;
  }
  ldv_38165: 
  tmp___1 = atomic_read((atomic_t const   *)(& kgdb_active));
  if (pscr_ret__ != tmp___1) {
    msleep(1U);
  } else {

  }
  ldv_38196: 
  tmp___2 = REGISTER_READ(dev, 397824U);
  if ((tmp___2 & idle_off_mask) != 0U) {
    goto ldv_38195;
  } else {
    goto ldv_38153;
  }
  ldv_38153: ;
  if (ret__ != 0) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_off", "Error in turning off Panel\n");
  } else {

  }
  msleep((unsigned int )intel_dp->panel_power_cycle_delay);
  drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_panel_off", "Over\n");
  return;
}
}
static void cdv_intel_edp_backlight_on(struct psb_intel_encoder *intel_encoder ) 
{ struct drm_device *dev ;
  u32 pp ;

  {
  dev = intel_encoder->base.dev;
  drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_backlight_on", "\n");
  msleep(300U);
  pp = REGISTER_READ(dev, 397828U);
  pp = pp | 4U;
  REGISTER_WRITE(dev, 397828U, pp);
  gma_backlight_enable(dev);
  return;
}
}
static void cdv_intel_edp_backlight_off(struct psb_intel_encoder *intel_encoder ) 
{ struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  u32 pp ;

  {
  dev = intel_encoder->base.dev;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  drm_ut_debug_printk(4U, "drm", "cdv_intel_edp_backlight_off", "\n");
  gma_backlight_disable(dev);
  msleep(10U);
  pp = REGISTER_READ(dev, 397828U);
  pp = pp & 4294967291U;
  REGISTER_WRITE(dev, 397828U, pp);
  msleep((unsigned int )intel_dp->backlight_off_delay);
  return;
}
}
static int cdv_intel_dp_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ struct psb_intel_encoder *encoder ;
  struct psb_intel_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  int max_link_clock ;
  int tmp___0 ;
  int tmp___1 ;
  int max_lanes ;
  int tmp___2 ;
  struct drm_psb_private *dev_priv ;
  bool tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;

  {
  tmp = psb_intel_attached_encoder(connector);
  encoder = tmp;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  tmp___0 = cdv_intel_dp_max_link_bw(encoder);
  tmp___1 = cdv_intel_dp_link_clock((int )((uint8_t )tmp___0));
  max_link_clock = tmp___1;
  tmp___2 = cdv_intel_dp_max_lane_count(encoder);
  max_lanes = tmp___2;
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
  tmp___3 = is_edp(encoder);
  if ((int )tmp___3 && (unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    if (mode->hdisplay > (intel_dp->panel_fixed_mode)->hdisplay) {
      return (29);
    } else {

    }
    if (mode->vdisplay > (intel_dp->panel_fixed_mode)->vdisplay) {
      return (29);
    } else {

    }
  } else {

  }
  tmp___4 = is_edp(encoder);
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    tmp___6 = cdv_intel_dp_link_required(mode->clock, dev_priv->edp.bpp);
    tmp___7 = cdv_intel_dp_max_data_rate(max_link_clock, max_lanes);
    if (tmp___6 > tmp___7) {
      return (15);
    } else {

    }
  } else {

  }
  tmp___10 = is_edp(encoder);
  if ((int )tmp___10) {
    tmp___8 = cdv_intel_dp_link_required(mode->clock, 24);
    tmp___9 = cdv_intel_dp_max_data_rate(max_link_clock, max_lanes);
    if (tmp___8 > tmp___9) {
      return (15);
    } else {

    }
  } else {

  }
  if (mode->clock <= 9999) {
    return (16);
  } else {

  }
  return (0);
}
}
static uint32_t pack_aux(uint8_t *src , int src_bytes ) 
{ int i ;
  uint32_t v ;

  {
  v = 0U;
  if (src_bytes > 4) {
    src_bytes = 4;
  } else {

  }
  i = 0;
  goto ldv_38227;
  ldv_38226: 
  v = ((unsigned int )*(src + (unsigned long )i) << (3 - i) * 8) | v;
  i = i + 1;
  ldv_38227: ;
  if (i < src_bytes) {
    goto ldv_38226;
  } else {
    goto ldv_38228;
  }
  ldv_38228: ;
  return (v);
}
}
static void unpack_aux(uint32_t src , uint8_t *dst , int dst_bytes ) 
{ int i ;

  {
  if (dst_bytes > 4) {
    dst_bytes = 4;
  } else {

  }
  i = 0;
  goto ldv_38236;
  ldv_38235: 
  *(dst + (unsigned long )i) = (uint8_t )(src >> (3 - i) * 8);
  i = i + 1;
  ldv_38236: ;
  if (i < dst_bytes) {
    goto ldv_38235;
  } else {
    goto ldv_38237;
  }
  ldv_38237: ;
  return;
}
}
static int cdv_intel_dp_aux_ch(struct psb_intel_encoder *encoder , uint8_t *send ,
                               int send_bytes , uint8_t *recv , int recv_size ) 
{ struct cdv_intel_dp *intel_dp ;
  uint32_t output_reg ;
  struct drm_device *dev ;
  uint32_t ch_ctl ;
  uint32_t ch_data ;
  int i ;
  int recv_bytes ;
  uint32_t status ;
  uint32_t aux_clock_divider ;
  int try ;
  int precharge ;
  bool tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  output_reg = intel_dp->output_reg;
  dev = encoder->base.dev;
  ch_ctl = output_reg + 16U;
  ch_data = ch_ctl + 4U;
  aux_clock_divider = 100U;
  precharge = 4;
  tmp = is_edp(encoder);
  if ((int )tmp) {
    precharge = 10;
  } else {

  }
  tmp___1 = REGISTER_READ(dev, ch_ctl);
  if ((int )tmp___1 < 0) {
    tmp___0 = REGISTER_READ(dev, ch_ctl);
    drm_err("cdv_intel_dp_aux_ch", "dp_aux_ch not started status 0x%08x\n", tmp___0);
    return (-16);
  } else {

  }
  try = 0;
  goto ldv_38264;
  ldv_38263: 
  i = 0;
  goto ldv_38258;
  ldv_38257: 
  tmp___2 = pack_aux(send + (unsigned long )i, send_bytes - i);
  REGISTER_WRITE(dev, ch_data + (uint32_t )i, tmp___2);
  i = i + 4;
  ldv_38258: ;
  if (i < send_bytes) {
    goto ldv_38257;
  } else {
    goto ldv_38259;
  }
  ldv_38259: 
  REGISTER_WRITE(dev, ch_ctl, ((uint32_t )(((send_bytes << 20) | (-0x7FFFFFFF-1)) | (precharge << 16)) | aux_clock_divider) | 1375731712U);
  ldv_38261: 
  status = REGISTER_READ(dev, ch_ctl);
  if ((int )status >= 0) {
    goto ldv_38260;
  } else {

  }
  __const_udelay(429500UL);
  goto ldv_38261;
  ldv_38260: 
  REGISTER_WRITE(dev, ch_ctl, status | 1375731712U);
  if ((status & 1073741824U) != 0U) {
    goto ldv_38262;
  } else {

  }
  try = try + 1;
  ldv_38264: ;
  if (try <= 4) {
    goto ldv_38263;
  } else {
    goto ldv_38262;
  }
  ldv_38262: ;
  if ((status & 1073741824U) == 0U) {
    drm_err("cdv_intel_dp_aux_ch", "dp_aux_ch not done status 0x%08x\n", status);
    return (-16);
  } else {

  }
  if ((status & 33554432U) != 0U) {
    drm_err("cdv_intel_dp_aux_ch", "dp_aux_ch receive error status 0x%08x\n", status);
    return (-5);
  } else {

  }
  if ((status & 268435456U) != 0U) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_aux_ch", "dp_aux_ch timeout status 0x%08x\n",
                        status);
    return (-110);
  } else {

  }
  recv_bytes = (int )((status & 32505856U) >> 20);
  if (recv_bytes > recv_size) {
    recv_bytes = recv_size;
  } else {

  }
  i = 0;
  goto ldv_38266;
  ldv_38265: 
  tmp___3 = REGISTER_READ(dev, ch_data + (uint32_t )i);
  unpack_aux(tmp___3, recv + (unsigned long )i, recv_bytes - i);
  i = i + 4;
  ldv_38266: ;
  if (i < recv_bytes) {
    goto ldv_38265;
  } else {
    goto ldv_38267;
  }
  ldv_38267: ;
  return (recv_bytes);
}
}
static int cdv_intel_dp_aux_native_write(struct psb_intel_encoder *encoder , uint16_t address ,
                                         uint8_t *send , int send_bytes ) 
{ int ret ;
  uint8_t msg[20U] ;
  int msg_bytes ;
  uint8_t ack ;
  size_t __len ;
  void *__ret ;

  {
  if (send_bytes > 16) {
    return (-1);
  } else {

  }
  msg[0] = 128U;
  msg[1] = (uint8_t )((int )address >> 8);
  msg[2] = (uint8_t )address;
  msg[3] = (unsigned int )((uint8_t )send_bytes) + 255U;
  __len = (size_t )send_bytes;
  __ret = __builtin_memcpy((void *)(& msg) + 4U, (void const   *)send, __len);
  msg_bytes = send_bytes + 4;
  ldv_38282: 
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, & ack, 1);
  if (ret < 0) {
    return (ret);
  } else {

  }
  if (((int )ack & 48) == 0) {
    goto ldv_38281;
  } else
  if (((int )ack & 48) == 32) {
    __const_udelay(429500UL);
  } else {
    return (-5);
  }
  goto ldv_38282;
  ldv_38281: ;
  return (send_bytes);
}
}
static int cdv_intel_dp_aux_native_write_1(struct psb_intel_encoder *encoder , uint16_t address ,
                                           uint8_t byte ) 
{ int tmp ;

  {
  tmp = cdv_intel_dp_aux_native_write(encoder, (int )address, & byte, 1);
  return (tmp);
}
}
static int cdv_intel_dp_aux_native_read(struct psb_intel_encoder *encoder , uint16_t address ,
                                        uint8_t *recv , int recv_bytes ) 
{ uint8_t msg[4U] ;
  int msg_bytes ;
  uint8_t reply[20U] ;
  int reply_bytes ;
  uint8_t ack ;
  int ret ;
  size_t __len ;
  void *__ret ;

  {
  msg[0] = 144U;
  msg[1] = (uint8_t )((int )address >> 8);
  msg[2] = (uint8_t )address;
  msg[3] = (unsigned int )((uint8_t )recv_bytes) + 255U;
  msg_bytes = 4;
  reply_bytes = recv_bytes + 1;
  ldv_38303: 
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, (uint8_t *)(& reply),
                            reply_bytes);
  if (ret == 0) {
    return (-71);
  } else {

  }
  if (ret < 0) {
    return (ret);
  } else {

  }
  ack = reply[0];
  if (((int )ack & 48) == 0) {
    __len = (size_t )(ret + -1);
    __ret = __builtin_memcpy((void *)recv, (void const   *)(& reply) + 1U, __len);
    return (ret + -1);
  } else
  if (((int )ack & 48) == 32) {
    __const_udelay(429500UL);
  } else {
    return (-5);
  }
  goto ldv_38303;
}
}
static int cdv_intel_dp_i2c_aux_ch(struct i2c_adapter *adapter , int mode , uint8_t write_byte ,
                                   uint8_t *read_byte ) 
{ struct i2c_algo_dp_aux_data *algo_data ;
  struct cdv_intel_dp *intel_dp ;
  struct i2c_adapter  const  *__mptr ;
  struct psb_intel_encoder *encoder ;
  uint16_t address ;
  uint8_t msg[5U] ;
  uint8_t reply[2U] ;
  unsigned int retry ;
  int msg_bytes ;
  int reply_bytes ;
  int ret ;

  {
  algo_data = (struct i2c_algo_dp_aux_data *)adapter->algo_data;
  __mptr = (struct i2c_adapter  const  *)adapter;
  intel_dp = (struct cdv_intel_dp *)__mptr + 0xffffffffffffffd0UL;
  encoder = intel_dp->encoder;
  address = algo_data->address;
  if ((mode & 4) != 0) {
    msg[0] = 16U;
  } else {
    msg[0] = 0U;
  }
  if ((mode & 8) == 0) {
    msg[0] = (uint8_t )((unsigned int )msg[0] | 64U);
  } else {

  }
  msg[1] = (uint8_t )((int )address >> 8);
  msg[2] = (uint8_t )address;
  switch (mode) {
  case 2: 
  msg[3] = 0U;
  msg[4] = write_byte;
  msg_bytes = 5;
  reply_bytes = 1;
  goto ldv_38323;
  case 4: 
  msg[3] = 0U;
  msg_bytes = 4;
  reply_bytes = 2;
  goto ldv_38323;
  default: 
  msg_bytes = 3;
  reply_bytes = 1;
  goto ldv_38323;
  }
  ldv_38323: 
  retry = 0U;
  goto ldv_38339;
  ldv_38338: 
  ret = cdv_intel_dp_aux_ch(encoder, (uint8_t *)(& msg), msg_bytes, (uint8_t *)(& reply),
                            reply_bytes);
  if (ret < 0) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_i2c_aux_ch", "aux_ch failed %d\n",
                        ret);
    return (ret);
  } else {

  }
  switch ((int )reply[0] & 48) {
  case 0: ;
  goto ldv_38328;
  case 16: 
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_i2c_aux_ch", "aux_ch native nack\n");
  return (-121);
  case 32: 
  __const_udelay(429500UL);
  goto ldv_38331;
  default: 
  drm_err("cdv_intel_dp_i2c_aux_ch", "aux_ch invalid native reply 0x%02x\n", (int )reply[0]);
  return (-121);
  }
  ldv_38328: ;
  switch ((int )reply[0] & 192) {
  case 0: ;
  if (mode == 4) {
    *read_byte = reply[1];
  } else {

  }
  return (reply_bytes + -1);
  case 64: 
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_i2c_aux_ch", "aux_i2c nack\n");
  return (-121);
  case 128: 
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_i2c_aux_ch", "aux_i2c defer\n");
  __const_udelay(429500UL);
  goto ldv_38336;
  default: 
  drm_err("cdv_intel_dp_i2c_aux_ch", "aux_i2c invalid reply 0x%02x\n", (int )reply[0]);
  return (-121);
  }
  ldv_38336: ;
  ldv_38331: 
  retry = retry + 1U;
  ldv_38339: ;
  if (retry <= 4U) {
    goto ldv_38338;
  } else {
    goto ldv_38340;
  }
  ldv_38340: 
  drm_err("cdv_intel_dp_i2c_aux_ch", "too many retries, giving up\n");
  return (-121);
}
}
static int cdv_intel_dp_i2c_init(struct psb_intel_connector *connector , struct psb_intel_encoder *encoder ,
                                 char const   *name ) 
{ struct cdv_intel_dp *intel_dp ;
  int ret ;
  bool tmp ;
  bool tmp___0 ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_i2c_init", "i2c_init %s\n", name);
  intel_dp->algo.running = 0;
  intel_dp->algo.address = 0U;
  intel_dp->algo.aux_ch = & cdv_intel_dp_i2c_aux_ch;
  memset((void *)(& intel_dp->adapter), 0, 1648UL);
  intel_dp->adapter.owner = & __this_module;
  intel_dp->adapter.class = 8U;
  strncpy((char *)(& intel_dp->adapter.name), name, 47UL);
  intel_dp->adapter.name[47UL] = 0;
  intel_dp->adapter.algo_data = (void *)(& intel_dp->algo);
  intel_dp->adapter.dev.parent = & connector->base.kdev;
  tmp = is_edp(encoder);
  if ((int )tmp) {
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
  ret = i2c_dp_aux_add_bus(& intel_dp->adapter);
  tmp___0 = is_edp(encoder);
  if ((int )tmp___0) {
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
  return (ret);
}
}
void cdv_intel_fixed_panel_mode(struct drm_display_mode *fixed_mode , struct drm_display_mode *adjusted_mode ) 
{ 

  {
  adjusted_mode->hdisplay = fixed_mode->hdisplay;
  adjusted_mode->hsync_start = fixed_mode->hsync_start;
  adjusted_mode->hsync_end = fixed_mode->hsync_end;
  adjusted_mode->htotal = fixed_mode->htotal;
  adjusted_mode->vdisplay = fixed_mode->vdisplay;
  adjusted_mode->vsync_start = fixed_mode->vsync_start;
  adjusted_mode->vsync_end = fixed_mode->vsync_end;
  adjusted_mode->vtotal = fixed_mode->vtotal;
  adjusted_mode->clock = fixed_mode->clock;
  drm_mode_set_crtcinfo(adjusted_mode, 1);
  return;
}
}
static bool cdv_intel_dp_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                    struct drm_display_mode *adjusted_mode ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct cdv_intel_dp *intel_dp ;
  int lane_count ;
  int clock ;
  int max_lane_count ;
  int tmp ;
  int max_clock ;
  int tmp___0 ;
  int bws[2U] ;
  int refclock ;
  int bpp ;
  bool tmp___1 ;
  int link_avail ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;

  {
  dev_priv = (struct drm_psb_private *)(encoder->dev)->dev_private;
  __mptr = (struct drm_encoder  const  *)encoder;
  intel_encoder = (struct psb_intel_encoder *)__mptr;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  tmp = cdv_intel_dp_max_lane_count(intel_encoder);
  max_lane_count = tmp;
  tmp___0 = cdv_intel_dp_max_link_bw(intel_encoder);
  max_clock = tmp___0 == 10;
  bws[0] = 6;
  bws[1] = 10;
  refclock = mode->clock;
  bpp = 24;
  tmp___1 = is_edp(intel_encoder);
  if ((int )tmp___1 && (unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    cdv_intel_fixed_panel_mode(intel_dp->panel_fixed_mode, adjusted_mode);
    refclock = (intel_dp->panel_fixed_mode)->clock;
    bpp = dev_priv->edp.bpp;
  } else {

  }
  lane_count = 1;
  goto ldv_38376;
  ldv_38375: 
  clock = max_clock;
  goto ldv_38373;
  ldv_38372: 
  tmp___2 = cdv_intel_dp_link_clock((int )((uint8_t )bws[clock]));
  tmp___3 = cdv_intel_dp_max_data_rate(tmp___2, lane_count);
  link_avail = tmp___3;
  tmp___4 = cdv_intel_dp_link_required(refclock, bpp);
  if (tmp___4 <= link_avail) {
    intel_dp->link_bw = (uint8_t )bws[clock];
    intel_dp->lane_count = (uint8_t )lane_count;
    adjusted_mode->clock = cdv_intel_dp_link_clock((int )intel_dp->link_bw);
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_mode_fixup", "Display port link bw %02x lane count %d clock %d\n",
                        (int )intel_dp->link_bw, (int )intel_dp->lane_count, adjusted_mode->clock);
    return (1);
  } else {

  }
  clock = clock - 1;
  ldv_38373: ;
  if (clock >= 0) {
    goto ldv_38372;
  } else {
    goto ldv_38374;
  }
  ldv_38374: 
  lane_count = lane_count << 1;
  ldv_38376: ;
  if (lane_count <= max_lane_count) {
    goto ldv_38375;
  } else {
    goto ldv_38377;
  }
  ldv_38377: 
  tmp___5 = is_edp(intel_encoder);
  if ((int )tmp___5) {
    intel_dp->lane_count = (uint8_t )max_lane_count;
    intel_dp->link_bw = (uint8_t )bws[max_clock];
    adjusted_mode->clock = cdv_intel_dp_link_clock((int )intel_dp->link_bw);
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_mode_fixup", "Force picking display port link bw %02x lane count %d clock %d\n",
                        (int )intel_dp->link_bw, (int )intel_dp->lane_count, adjusted_mode->clock);
    return (1);
  } else {

  }
  return (0);
}
}
static void cdv_intel_reduce_ratio(uint32_t *num , uint32_t *den ) 
{ uint64_t value ;
  uint64_t m ;
  uint32_t __base ;
  uint32_t __rem ;

  {
  m = (uint64_t )*num;
  value = m * 8388608ULL;
  __base = *den;
  __rem = (uint32_t )(value % (uint64_t )__base);
  value = value / (uint64_t )__base;
  m = (uint64_t )__rem;
  *num = (uint32_t )value;
  *den = 8388608U;
  return;
}
}
static void cdv_intel_dp_compute_m_n(int bpp , int nlanes , int pixel_clock , int link_clock ,
                                     struct cdv_intel_dp_m_n *m_n ) 
{ 

  {
  m_n->tu = 64U;
  m_n->gmch_m = (uint32_t )((pixel_clock * bpp + 7) >> 3);
  m_n->gmch_n = (uint32_t )(link_clock * nlanes);
  cdv_intel_reduce_ratio(& m_n->gmch_m, & m_n->gmch_n);
  m_n->link_m = (uint32_t )pixel_clock;
  m_n->link_n = (uint32_t )link_clock;
  cdv_intel_reduce_ratio(& m_n->link_m, & m_n->link_n);
  return;
}
}
void cdv_intel_dp_set_m_n(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                          struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_mode_config *mode_config ;
  struct drm_encoder *encoder ;
  struct psb_intel_crtc *intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int lane_count ;
  int bpp ;
  struct cdv_intel_dp_m_n m_n ;
  int pipe ;
  struct list_head  const  *__mptr___0 ;
  struct psb_intel_encoder *intel_encoder ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_encoder  const  *__mptr___1 ;
  bool tmp ;
  struct list_head  const  *__mptr___2 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_config = & dev->mode_config;
  __mptr = (struct drm_crtc  const  *)crtc;
  intel_crtc = (struct psb_intel_crtc *)__mptr;
  lane_count = 4;
  bpp = 24;
  pipe = intel_crtc->pipe;
  __mptr___0 = (struct list_head  const  *)mode_config->encoder_list.next;
  encoder = (struct drm_encoder *)__mptr___0 + 0xfffffffffffffff8UL;
  goto ldv_38427;
  ldv_38426: ;
  if ((unsigned long )encoder->crtc != (unsigned long )crtc) {
    goto ldv_38422;
  } else {

  }
  __mptr___1 = (struct drm_encoder  const  *)encoder;
  intel_encoder = (struct psb_intel_encoder *)__mptr___1;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  if (intel_encoder->type == 9) {
    lane_count = (int )intel_dp->lane_count;
    goto ldv_38425;
  } else {
    tmp = is_edp(intel_encoder);
    if ((int )tmp) {
      lane_count = (int )intel_dp->lane_count;
      bpp = dev_priv->edp.bpp;
      goto ldv_38425;
    } else {

    }
  }
  ldv_38422: 
  __mptr___2 = (struct list_head  const  *)encoder->head.next;
  encoder = (struct drm_encoder *)__mptr___2 + 0xfffffffffffffff8UL;
  ldv_38427: ;
  if ((unsigned long )(& encoder->head) != (unsigned long )(& mode_config->encoder_list)) {
    goto ldv_38426;
  } else {
    goto ldv_38425;
  }
  ldv_38425: 
  cdv_intel_dp_compute_m_n(bpp, lane_count, mode->clock, adjusted_mode->clock, & m_n);
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458832), ((m_n.tu - 1U) << 25) | m_n.gmch_m);
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458836), m_n.gmch_n);
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458848), m_n.link_m);
  REGISTER_WRITE(dev, (uint32_t )(pipe * 4096 + 458852), m_n.link_n);
  return;
}
}
static void cdv_intel_dp_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode ) 
{ struct psb_intel_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct drm_crtc *crtc ;
  struct psb_intel_crtc *intel_crtc ;
  struct drm_crtc  const  *__mptr___0 ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_device *dev ;
  uint32_t pfit_control ;
  bool tmp ;

  {
  __mptr = (struct drm_encoder  const  *)encoder;
  intel_encoder = (struct psb_intel_encoder *)__mptr;
  crtc = encoder->crtc;
  __mptr___0 = (struct drm_crtc  const  *)crtc;
  intel_crtc = (struct psb_intel_crtc *)__mptr___0;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  dev = encoder->dev;
  intel_dp->DP = 0U;
  intel_dp->DP = intel_dp->DP | intel_dp->color_range;
  if ((int )adjusted_mode->flags & 1) {
    intel_dp->DP = intel_dp->DP | 8U;
  } else {

  }
  if ((adjusted_mode->flags & 4U) != 0U) {
    intel_dp->DP = intel_dp->DP | 16U;
  } else {

  }
  intel_dp->DP = intel_dp->DP | 805306368U;
  switch ((int )intel_dp->lane_count) {
  case 1: 
  intel_dp->DP = intel_dp->DP;
  goto ldv_38443;
  case 2: 
  intel_dp->DP = intel_dp->DP | 524288U;
  goto ldv_38443;
  case 4: 
  intel_dp->DP = intel_dp->DP | 1572864U;
  goto ldv_38443;
  }
  ldv_38443: ;
  if ((int )intel_dp->has_audio) {
    intel_dp->DP = intel_dp->DP | 64U;
  } else {

  }
  memset((void *)(& intel_dp->link_configuration), 0, 9UL);
  intel_dp->link_configuration[0] = intel_dp->link_bw;
  intel_dp->link_configuration[1] = intel_dp->lane_count;
  if ((unsigned int )intel_dp->dpcd[0] > 16U && (int )((signed char )intel_dp->dpcd[2]) < 0) {
    intel_dp->link_configuration[1] = (uint8_t )((unsigned int )intel_dp->link_configuration[1] | 128U);
    intel_dp->DP = intel_dp->DP | 262144U;
  } else {

  }
  if (intel_crtc->pipe == 1) {
    intel_dp->DP = intel_dp->DP | 1073741824U;
  } else {

  }
  REGISTER_WRITE(dev, intel_dp->output_reg, intel_dp->DP | 2147483648U);
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_mode_set", "DP expected reg is %x\n",
                      intel_dp->DP);
  tmp = is_edp(intel_encoder);
  if ((int )tmp) {
    cdv_intel_edp_panel_on(intel_encoder);
    if (mode->hdisplay != adjusted_mode->hdisplay || mode->vdisplay != adjusted_mode->vdisplay) {
      pfit_control = 2147483648U;
    } else {
      pfit_control = 0U;
    }
    pfit_control = (uint32_t )(intel_crtc->pipe << 29) | pfit_control;
    REGISTER_WRITE(dev, 397872U, pfit_control);
  } else {

  }
  return;
}
}
static void cdv_intel_dp_sink_dpms(struct psb_intel_encoder *encoder , int mode ) 
{ struct cdv_intel_dp *intel_dp ;
  int ret ;
  int i ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  if ((unsigned int )intel_dp->dpcd[0] <= 16U) {
    return;
  } else {

  }
  if (mode != 0) {
    ret = cdv_intel_dp_aux_native_write_1(encoder, 1536, 2);
    if (ret != 1) {
      drm_ut_debug_printk(2U, "drm", "cdv_intel_dp_sink_dpms", "failed to write sink power state\n");
    } else {

    }
  } else {
    i = 0;
    goto ldv_38458;
    ldv_38457: 
    ret = cdv_intel_dp_aux_native_write_1(encoder, 1536, 1);
    if (ret == 1) {
      goto ldv_38456;
    } else {

    }
    __const_udelay(4295000UL);
    i = i + 1;
    ldv_38458: ;
    if (i <= 2) {
      goto ldv_38457;
    } else {
      goto ldv_38456;
    }
    ldv_38456: ;
  }
  return;
}
}
static void cdv_intel_dp_prepare(struct drm_encoder *encoder ) 
{ struct psb_intel_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  int edp ;
  bool tmp ;

  {
  __mptr = (struct drm_encoder  const  *)encoder;
  intel_encoder = (struct psb_intel_encoder *)__mptr;
  tmp = is_edp(intel_encoder);
  edp = (int )tmp;
  if (edp != 0) {
    cdv_intel_edp_backlight_off(intel_encoder);
    cdv_intel_edp_panel_off(intel_encoder);
    cdv_intel_edp_panel_vdd_on(intel_encoder);
  } else {

  }
  cdv_intel_dp_sink_dpms(intel_encoder, 0);
  cdv_intel_dp_link_down(intel_encoder);
  if (edp != 0) {
    cdv_intel_edp_panel_vdd_off(intel_encoder);
  } else {

  }
  return;
}
}
static void cdv_intel_dp_commit(struct drm_encoder *encoder ) 
{ struct psb_intel_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  int edp ;
  bool tmp ;

  {
  __mptr = (struct drm_encoder  const  *)encoder;
  intel_encoder = (struct psb_intel_encoder *)__mptr;
  tmp = is_edp(intel_encoder);
  edp = (int )tmp;
  if (edp != 0) {
    cdv_intel_edp_panel_on(intel_encoder);
  } else {

  }
  cdv_intel_dp_start_link_train(intel_encoder);
  cdv_intel_dp_complete_link_train(intel_encoder);
  if (edp != 0) {
    cdv_intel_edp_backlight_on(intel_encoder);
  } else {

  }
  return;
}
}
static void cdv_intel_dp_dpms(struct drm_encoder *encoder , int mode ) 
{ struct psb_intel_encoder *intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct cdv_intel_dp *intel_dp ;
  struct drm_device *dev ;
  uint32_t dp_reg ;
  uint32_t tmp ;
  int edp ;
  bool tmp___0 ;

  {
  __mptr = (struct drm_encoder  const  *)encoder;
  intel_encoder = (struct psb_intel_encoder *)__mptr;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  dev = encoder->dev;
  tmp = REGISTER_READ(dev, intel_dp->output_reg);
  dp_reg = tmp;
  tmp___0 = is_edp(intel_encoder);
  edp = (int )tmp___0;
  if (mode != 0) {
    if (edp != 0) {
      cdv_intel_edp_backlight_off(intel_encoder);
      cdv_intel_edp_panel_vdd_on(intel_encoder);
    } else {

    }
    cdv_intel_dp_sink_dpms(intel_encoder, mode);
    cdv_intel_dp_link_down(intel_encoder);
    if (edp != 0) {
      cdv_intel_edp_panel_vdd_off(intel_encoder);
      cdv_intel_edp_panel_off(intel_encoder);
    } else {

    }
  } else {
    if (edp != 0) {
      cdv_intel_edp_panel_on(intel_encoder);
    } else {

    }
    cdv_intel_dp_sink_dpms(intel_encoder, mode);
    if ((int )dp_reg >= 0) {
      cdv_intel_dp_start_link_train(intel_encoder);
      cdv_intel_dp_complete_link_train(intel_encoder);
    } else {

    }
    if (edp != 0) {
      cdv_intel_edp_backlight_on(intel_encoder);
    } else {

    }
  }
  return;
}
}
static bool cdv_intel_dp_aux_native_read_retry(struct psb_intel_encoder *encoder ,
                                               uint16_t address , uint8_t *recv ,
                                               int recv_bytes ) 
{ int ret ;
  int i ;

  {
  i = 0;
  goto ldv_38493;
  ldv_38492: 
  ret = cdv_intel_dp_aux_native_read(encoder, (int )address, recv, recv_bytes);
  if (ret == recv_bytes) {
    return (1);
  } else {

  }
  __const_udelay(4295000UL);
  i = i + 1;
  ldv_38493: ;
  if (i <= 2) {
    goto ldv_38492;
  } else {
    goto ldv_38494;
  }
  ldv_38494: ;
  return (0);
}
}
static bool cdv_intel_dp_get_link_status(struct psb_intel_encoder *encoder ) 
{ struct cdv_intel_dp *intel_dp ;
  bool tmp ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  tmp = cdv_intel_dp_aux_native_read_retry(encoder, 514, (uint8_t *)(& intel_dp->link_status),
                                           6);
  return (tmp);
}
}
static uint8_t cdv_intel_dp_link_status(uint8_t *link_status , int r ) 
{ 

  {
  return (*(link_status + ((unsigned long )r + 0xfffffffffffffdfeUL)));
}
}
static uint8_t cdv_intel_get_adjust_request_voltage(uint8_t *link_status , int lane ) 
{ int i ;
  int s ;
  int tmp ;
  uint8_t l ;
  uint8_t tmp___0 ;

  {
  i = (lane >> 1) + 518;
  if (lane & 1) {
    tmp = 4;
  } else {
    tmp = 0;
  }
  s = tmp;
  tmp___0 = cdv_intel_dp_link_status(link_status, i);
  l = tmp___0;
  return ((unsigned int )((uint8_t )((int )l >> s)) & 3U);
}
}
static uint8_t cdv_intel_get_adjust_request_pre_emphasis(uint8_t *link_status , int lane ) 
{ int i ;
  int s ;
  int tmp ;
  uint8_t l ;
  uint8_t tmp___0 ;

  {
  i = (lane >> 1) + 518;
  if (lane & 1) {
    tmp = 6;
  } else {
    tmp = 2;
  }
  s = tmp;
  tmp___0 = cdv_intel_dp_link_status(link_status, i);
  l = tmp___0;
  return (((unsigned int )((uint8_t )((int )l >> s)) & 3U) << 3U);
}
}
static void cdv_intel_get_adjust_train(struct psb_intel_encoder *encoder ) 
{ struct cdv_intel_dp *intel_dp ;
  uint8_t v ;
  uint8_t p ;
  int lane ;
  uint8_t this_v ;
  uint8_t tmp ;
  uint8_t this_p ;
  uint8_t tmp___0 ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  v = 0U;
  p = 0U;
  lane = 0;
  goto ldv_38527;
  ldv_38526: 
  tmp = cdv_intel_get_adjust_request_voltage((uint8_t *)(& intel_dp->link_status),
                                             lane);
  this_v = tmp;
  tmp___0 = cdv_intel_get_adjust_request_pre_emphasis((uint8_t *)(& intel_dp->link_status),
                                                      lane);
  this_p = tmp___0;
  if ((int )this_v > (int )v) {
    v = this_v;
  } else {

  }
  if ((int )this_p > (int )p) {
    p = this_p;
  } else {

  }
  lane = lane + 1;
  ldv_38527: ;
  if ((int )intel_dp->lane_count > lane) {
    goto ldv_38526;
  } else {
    goto ldv_38528;
  }
  ldv_38528: ;
  if ((unsigned int )v > 2U) {
    v = 7U;
  } else {

  }
  if ((unsigned int )p == 24U) {
    p = (uint8_t )((unsigned int )p | 32U);
  } else {

  }
  lane = 0;
  goto ldv_38530;
  ldv_38529: 
  intel_dp->train_set[lane] = (uint8_t )((int )v | (int )p);
  lane = lane + 1;
  ldv_38530: ;
  if (lane <= 3) {
    goto ldv_38529;
  } else {
    goto ldv_38531;
  }
  ldv_38531: ;
  return;
}
}
static uint8_t cdv_intel_get_lane_status(uint8_t *link_status , int lane ) 
{ int i ;
  int s ;
  uint8_t l ;
  uint8_t tmp ;

  {
  i = (lane >> 1) + 514;
  s = (lane & 1) * 4;
  tmp = cdv_intel_dp_link_status(link_status, i);
  l = tmp;
  return ((unsigned int )((uint8_t )((int )l >> s)) & 15U);
}
}
static bool cdv_intel_clock_recovery_ok(uint8_t *link_status , int lane_count ) 
{ int lane ;
  uint8_t lane_status ;

  {
  lane = 0;
  goto ldv_38546;
  ldv_38545: 
  lane_status = cdv_intel_get_lane_status(link_status, lane);
  if (((int )lane_status & 1) == 0) {
    return (0);
  } else {

  }
  lane = lane + 1;
  ldv_38546: ;
  if (lane < lane_count) {
    goto ldv_38545;
  } else {
    goto ldv_38547;
  }
  ldv_38547: ;
  return (1);
}
}
static bool cdv_intel_channel_eq_ok(struct psb_intel_encoder *encoder ) 
{ struct cdv_intel_dp *intel_dp ;
  uint8_t lane_align ;
  uint8_t lane_status ;
  int lane ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  lane_align = cdv_intel_dp_link_status((uint8_t *)(& intel_dp->link_status), 516);
  if (((int )lane_align & 1) == 0) {
    return (0);
  } else {

  }
  lane = 0;
  goto ldv_38556;
  ldv_38555: 
  lane_status = cdv_intel_get_lane_status((uint8_t *)(& intel_dp->link_status), lane);
  if (((int )lane_status & 7) != 7) {
    return (0);
  } else {

  }
  lane = lane + 1;
  ldv_38556: ;
  if ((int )intel_dp->lane_count > lane) {
    goto ldv_38555;
  } else {
    goto ldv_38557;
  }
  ldv_38557: ;
  return (1);
}
}
static bool cdv_intel_dp_set_link_train(struct psb_intel_encoder *encoder , uint32_t dp_reg_value ,
                                        uint8_t dp_train_pat ) 
{ struct drm_device *dev ;
  int ret ;
  struct cdv_intel_dp *intel_dp ;

  {
  dev = encoder->base.dev;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  REGISTER_WRITE(dev, intel_dp->output_reg, dp_reg_value);
  REGISTER_READ(dev, intel_dp->output_reg);
  ret = cdv_intel_dp_aux_native_write_1(encoder, 258, (int )dp_train_pat);
  if (ret != 1) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_set_link_train", "Failure in setting link pattern %x\n",
                        (int )dp_train_pat);
    return (0);
  } else {

  }
  return (1);
}
}
static bool cdv_intel_dplink_set_level(struct psb_intel_encoder *encoder , uint8_t dp_train_pat ) 
{ int ret ;
  struct cdv_intel_dp *intel_dp ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  ret = cdv_intel_dp_aux_native_write(encoder, 259, (uint8_t *)(& intel_dp->train_set),
                                      (int )intel_dp->lane_count);
  if ((int )intel_dp->lane_count != ret) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dplink_set_level", "Failure in setting level %d, lane_cnt= %d\n",
                        (int )intel_dp->train_set[0], (int )intel_dp->lane_count);
    return (0);
  } else {

  }
  return (1);
}
}
static void cdv_intel_dp_set_vswing_premph(struct psb_intel_encoder *encoder , uint8_t signal_level ) 
{ struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  struct ddi_regoff *ddi_reg ;
  int vswing ;
  int premph ;
  int index ;

  {
  dev = encoder->base.dev;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  if (intel_dp->output_reg == 409856U) {
    ddi_reg = (struct ddi_regoff *)(& ddi_DP_train_table);
  } else {
    ddi_reg = (struct ddi_regoff *)(& ddi_DP_train_table) + 1UL;
  }
  vswing = (int )signal_level & 3;
  premph = ((int )signal_level & 24) >> 3;
  if (vswing + premph > 3) {
    return;
  } else {

  }
  return;
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_set_vswing_premph", "Test2\n");
  cdv_sb_reset(dev);
  cdv_sb_write(dev, ddi_reg->VSwing5, 84226362U);
  cdv_sb_write(dev, ddi_reg->VSwing1, 1128292437U);
  index = (vswing + premph) * 2;
  if (premph == 1 && vswing == 1) {
    cdv_sb_write(dev, ddi_reg->VSwing2, 1433635156U);
  } else {
    cdv_sb_write(dev, ddi_reg->VSwing2, dp_vswing_premph_table[index]);
  }
  if (vswing + premph == 3) {
    cdv_sb_write(dev, ddi_reg->VSwing3, 1887445056U);
  } else {
    cdv_sb_write(dev, ddi_reg->VSwing3, 1082138688U);
  }
  cdv_sb_write(dev, ddi_reg->VSwing1, 3275776085U);
  cdv_sb_write(dev, ddi_reg->PreEmph1, 520290368U);
  index = premph * 2 + 1;
  cdv_sb_write(dev, ddi_reg->PreEmph2, dp_vswing_premph_table[index]);
  return;
}
}
static void cdv_intel_dp_start_link_train(struct psb_intel_encoder *encoder ) 
{ struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  int i ;
  uint8_t voltage ;
  bool clock_recovery ;
  int tries ;
  u32 reg ;
  uint32_t DP ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
  dev = encoder->base.dev;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  clock_recovery = 0;
  DP = intel_dp->DP;
  DP = DP | 2147483648U;
  DP = DP & 3489660927U;
  reg = DP;
  reg = reg;
  REGISTER_WRITE(dev, intel_dp->output_reg, reg);
  REGISTER_READ(dev, intel_dp->output_reg);
  psb_intel_wait_for_vblank(dev);
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_start_link_train", "Link config\n");
  cdv_intel_dp_aux_native_write(encoder, 256, (uint8_t *)(& intel_dp->link_configuration),
                                2);
  memset((void *)(& intel_dp->train_set), 0, 4UL);
  voltage = 0U;
  tries = 0;
  clock_recovery = 0;
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_start_link_train", "Start train\n");
  reg = DP;
  ldv_38601: 
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_start_link_train", "DP Link Train Set %x, Link_config %x, %x\n",
                      (int )intel_dp->train_set[0], (int )intel_dp->link_configuration[0],
                      (int )intel_dp->link_configuration[1]);
  tmp = cdv_intel_dp_set_link_train(encoder, reg, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_start_link_train", "Failure in aux-transfer setting pattern 1\n");
  } else {

  }
  cdv_intel_dp_set_vswing_premph(encoder, (int )intel_dp->train_set[0]);
  cdv_intel_dplink_set_level(encoder, 1);
  __const_udelay(859000UL);
  tmp___1 = cdv_intel_dp_get_link_status(encoder);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    goto ldv_38597;
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_start_link_train", "DP Link status %x, %x, %x, %x, %x, %x\n",
                      (int )intel_dp->link_status[0], (int )intel_dp->link_status[1],
                      (int )intel_dp->link_status[2], (int )intel_dp->link_status[3],
                      (int )intel_dp->link_status[4], (int )intel_dp->link_status[5]);
  tmp___3 = cdv_intel_clock_recovery_ok((uint8_t *)(& intel_dp->link_status), (int )intel_dp->lane_count);
  if ((int )tmp___3) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_start_link_train", "PT1 train is done\n");
    clock_recovery = 1;
    goto ldv_38597;
  } else {

  }
  i = 0;
  goto ldv_38600;
  ldv_38599: ;
  if (((int )intel_dp->train_set[i] & 4) == 0) {
    goto ldv_38598;
  } else {

  }
  i = i + 1;
  ldv_38600: ;
  if ((int )intel_dp->lane_count > i) {
    goto ldv_38599;
  } else {
    goto ldv_38598;
  }
  ldv_38598: ;
  if ((int )intel_dp->lane_count == i) {
    goto ldv_38597;
  } else {

  }
  if (((int )intel_dp->train_set[0] & 3) == (int )voltage) {
    tries = tries + 1;
    if (tries == 5) {
      goto ldv_38597;
    } else {

    }
  } else {
    tries = 0;
  }
  voltage = (unsigned int )intel_dp->train_set[0] & 3U;
  cdv_intel_get_adjust_train(encoder);
  goto ldv_38601;
  ldv_38597: ;
  if (! clock_recovery) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_start_link_train", "failure in DP patter 1 training, train set %x\n",
                        (int )intel_dp->train_set[0]);
  } else {

  }
  intel_dp->DP = DP;
  return;
}
}
static void cdv_intel_dp_complete_link_train(struct psb_intel_encoder *encoder ) 
{ struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  bool channel_eq ;
  int tries ;
  int cr_tries ;
  u32 reg ;
  uint32_t DP ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;

  {
  dev = encoder->base.dev;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  channel_eq = 0;
  DP = intel_dp->DP;
  tries = 0;
  cr_tries = 0;
  channel_eq = 0;
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_complete_link_train", "\n");
  reg = DP | 268435456U;
  ldv_38615: 
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_complete_link_train", "DP Link Train Set %x, Link_config %x, %x\n",
                      (int )intel_dp->train_set[0], (int )intel_dp->link_configuration[0],
                      (int )intel_dp->link_configuration[1]);
  tmp = cdv_intel_dp_set_link_train(encoder, reg, 2);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_complete_link_train", "Failure in aux-transfer setting pattern 2\n");
  } else {

  }
  if (cr_tries > 5) {
    drm_err("cdv_intel_dp_complete_link_train", "failed to train DP, aborting\n");
    cdv_intel_dp_link_down(encoder);
    goto ldv_38613;
  } else {

  }
  cdv_intel_dp_set_vswing_premph(encoder, (int )intel_dp->train_set[0]);
  cdv_intel_dplink_set_level(encoder, 2);
  __const_udelay(4295000UL);
  tmp___1 = cdv_intel_dp_get_link_status(encoder);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    goto ldv_38613;
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_complete_link_train", "DP Link status %x, %x, %x, %x, %x, %x\n",
                      (int )intel_dp->link_status[0], (int )intel_dp->link_status[1],
                      (int )intel_dp->link_status[2], (int )intel_dp->link_status[3],
                      (int )intel_dp->link_status[4], (int )intel_dp->link_status[5]);
  tmp___3 = cdv_intel_clock_recovery_ok((uint8_t *)(& intel_dp->link_status), (int )intel_dp->lane_count);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    cdv_intel_dp_start_link_train(encoder);
    cr_tries = cr_tries + 1;
    goto ldv_38614;
  } else {

  }
  tmp___5 = cdv_intel_channel_eq_ok(encoder);
  if ((int )tmp___5) {
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_complete_link_train", "PT2 train is done\n");
    channel_eq = 1;
    goto ldv_38613;
  } else {

  }
  if (tries > 5) {
    cdv_intel_dp_link_down(encoder);
    cdv_intel_dp_start_link_train(encoder);
    tries = 0;
    cr_tries = cr_tries + 1;
    goto ldv_38614;
  } else {

  }
  cdv_intel_get_adjust_train(encoder);
  tries = tries + 1;
  ldv_38614: ;
  goto ldv_38615;
  ldv_38613: 
  reg = DP | 805306368U;
  REGISTER_WRITE(dev, intel_dp->output_reg, reg);
  REGISTER_READ(dev, intel_dp->output_reg);
  cdv_intel_dp_aux_native_write_1(encoder, 258, 0);
  return;
}
}
static void cdv_intel_dp_link_down(struct psb_intel_encoder *encoder ) 
{ struct drm_device *dev ;
  struct cdv_intel_dp *intel_dp ;
  uint32_t DP ;
  uint32_t tmp ;

  {
  dev = encoder->base.dev;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  DP = intel_dp->DP;
  tmp = REGISTER_READ(dev, intel_dp->output_reg);
  if ((int )tmp >= 0) {
    return;
  } else {

  }
  drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_link_down", "\n");
  DP = DP & 3489660927U;
  REGISTER_WRITE(dev, intel_dp->output_reg, DP | 536870912U);
  REGISTER_READ(dev, intel_dp->output_reg);
  msleep(17U);
  REGISTER_WRITE(dev, intel_dp->output_reg, DP & 2147483647U);
  REGISTER_READ(dev, intel_dp->output_reg);
  return;
}
}
static enum drm_connector_status cdv_dp_detect(struct psb_intel_encoder *encoder ) 
{ struct cdv_intel_dp *intel_dp ;
  enum drm_connector_status status ;
  int tmp ;

  {
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  status = 2;
  tmp = cdv_intel_dp_aux_native_read(encoder, 0, (uint8_t *)(& intel_dp->dpcd), 4);
  if (tmp == 4) {
    if ((unsigned int )intel_dp->dpcd[0] != 0U) {
      status = 1;
    } else {

    }
  } else {

  }
  if ((unsigned int )status == 1U) {
    drm_ut_debug_printk(4U, "drm", "cdv_dp_detect", "DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\n",
                        (int )intel_dp->dpcd[0], (int )intel_dp->dpcd[1], (int )intel_dp->dpcd[2],
                        (int )intel_dp->dpcd[3]);
  } else {

  }
  return (status);
}
}
static enum drm_connector_status cdv_intel_dp_detect(struct drm_connector *connector ,
                                                     bool force ) 
{ struct psb_intel_encoder *encoder ;
  struct psb_intel_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  enum drm_connector_status status ;
  struct edid *edid ;
  int edp ;
  bool tmp___0 ;

  {
  tmp = psb_intel_attached_encoder(connector);
  encoder = tmp;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  edid = 0;
  tmp___0 = is_edp(encoder);
  edp = (int )tmp___0;
  intel_dp->has_audio = 0;
  if (edp != 0) {
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
  status = cdv_dp_detect(encoder);
  if ((unsigned int )status != 1U) {
    if (edp != 0) {
      cdv_intel_edp_panel_vdd_off(encoder);
    } else {

    }
    return (status);
  } else {

  }
  if (intel_dp->force_audio != 0) {
    intel_dp->has_audio = intel_dp->force_audio > 0;
  } else {
    edid = drm_get_edid(connector, & intel_dp->adapter);
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
      intel_dp->has_audio = drm_detect_monitor_audio(edid);
      kfree((void const   *)edid);
    } else {

    }
  }
  if (edp != 0) {
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
  return (1);
}
}
static int cdv_intel_dp_get_modes(struct drm_connector *connector ) 
{ struct psb_intel_encoder *intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  struct edid *edid ;
  int ret ;
  int edp ;
  bool tmp___0 ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct drm_display_mode *newmode ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct drm_display_mode *mode ;
  bool tmp___1 ;

  {
  tmp = psb_intel_attached_encoder(connector);
  intel_encoder = tmp;
  intel_dp = (struct cdv_intel_dp *)intel_encoder->dev_priv;
  edid = 0;
  ret = 0;
  tmp___0 = is_edp(intel_encoder);
  edp = (int )tmp___0;
  edid = drm_get_edid(connector, & intel_dp->adapter);
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    drm_mode_connector_update_edid_property(connector, edid);
    ret = drm_add_edid_modes(connector, edid);
    kfree((void const   *)edid);
  } else {

  }
  tmp___1 = is_edp(intel_encoder);
  if ((int )tmp___1) {
    dev = connector->dev;
    dev_priv = (struct drm_psb_private *)dev->dev_private;
    cdv_intel_edp_panel_vdd_off(intel_encoder);
    if (ret != 0) {
      if (edp != 0 && (unsigned long )intel_dp->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
        __mptr = (struct list_head  const  *)connector->probed_modes.next;
        newmode = (struct drm_display_mode *)__mptr;
        goto ldv_38655;
        ldv_38654: ;
        if ((newmode->type & 8U) != 0U) {
          intel_dp->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)newmode);
          goto ldv_38653;
        } else {

        }
        __mptr___0 = (struct list_head  const  *)newmode->head.next;
        newmode = (struct drm_display_mode *)__mptr___0;
        ldv_38655: ;
        if ((unsigned long )(& newmode->head) != (unsigned long )(& connector->probed_modes)) {
          goto ldv_38654;
        } else {
          goto ldv_38653;
        }
        ldv_38653: ;
      } else {

      }
      return (ret);
    } else {

    }
    if ((unsigned long )intel_dp->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0) && (unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
      intel_dp->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
      if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
        (intel_dp->panel_fixed_mode)->type = (intel_dp->panel_fixed_mode)->type | 8U;
      } else {

      }
    } else {

    }
    if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)intel_dp->panel_fixed_mode);
      drm_mode_probed_add(connector, mode);
      return (1);
    } else {

    }
  } else {

  }
  return (ret);
}
}
static bool cdv_intel_dp_detect_audio(struct drm_connector *connector ) 
{ struct psb_intel_encoder *encoder ;
  struct psb_intel_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  struct edid *edid ;
  bool has_audio ;
  int edp ;
  bool tmp___0 ;

  {
  tmp = psb_intel_attached_encoder(connector);
  encoder = tmp;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  has_audio = 0;
  tmp___0 = is_edp(encoder);
  edp = (int )tmp___0;
  if (edp != 0) {
    cdv_intel_edp_panel_vdd_on(encoder);
  } else {

  }
  edid = drm_get_edid(connector, & intel_dp->adapter);
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    has_audio = drm_detect_monitor_audio(edid);
    kfree((void const   *)edid);
  } else {

  }
  if (edp != 0) {
    cdv_intel_edp_panel_vdd_off(encoder);
  } else {

  }
  return (has_audio);
}
}
static int cdv_intel_dp_set_property(struct drm_connector *connector , struct drm_property *property ,
                                     uint64_t val ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_intel_encoder *encoder ;
  struct psb_intel_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  int ret ;
  int i ;
  bool has_audio ;
  struct drm_crtc *crtc ;

  {
  dev_priv = (struct drm_psb_private *)(connector->dev)->dev_private;
  tmp = psb_intel_attached_encoder(connector);
  encoder = tmp;
  intel_dp = (struct cdv_intel_dp *)encoder->dev_priv;
  ret = drm_object_property_set_value(& connector->base, property, val);
  if (ret != 0) {
    return (ret);
  } else {

  }
  if ((unsigned long )dev_priv->force_audio_property == (unsigned long )property) {
    i = (int )val;
    if (intel_dp->force_audio == i) {
      return (0);
    } else {

    }
    intel_dp->force_audio = i;
    if (i == 0) {
      has_audio = cdv_intel_dp_detect_audio(connector);
    } else {
      has_audio = i > 0;
    }
    if ((int )intel_dp->has_audio == (int )has_audio) {
      return (0);
    } else {

    }
    intel_dp->has_audio = has_audio;
    goto done;
  } else {

  }
  if ((unsigned long )dev_priv->broadcast_rgb_property == (unsigned long )property) {
    if ((uint64_t )(intel_dp->color_range != 0U) == val) {
      return (0);
    } else {

    }
    if (val != 0ULL) {
      intel_dp->color_range = 256U;
    } else {
      intel_dp->color_range = 0U;
    }
    goto done;
  } else {

  }
  return (-22);
  done: ;
  if ((unsigned long )encoder->base.crtc != (unsigned long )((struct drm_crtc *)0)) {
    crtc = encoder->base.crtc;
    drm_crtc_helper_set_mode(crtc, & crtc->mode, crtc->x, crtc->y, crtc->fb);
  } else {

  }
  return (0);
}
}
static void cdv_intel_dp_destroy(struct drm_connector *connector ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_encoder *tmp ;
  struct cdv_intel_dp *intel_dp ;
  bool tmp___0 ;

  {
  tmp = psb_intel_attached_encoder(connector);
  psb_intel_encoder = tmp;
  intel_dp = (struct cdv_intel_dp *)psb_intel_encoder->dev_priv;
  tmp___0 = is_edp(psb_intel_encoder);
  if ((int )tmp___0) {
    if ((unsigned long )intel_dp->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
      kfree((void const   *)intel_dp->panel_fixed_mode);
      intel_dp->panel_fixed_mode = 0;
    } else {

    }
  } else {

  }
  i2c_del_adapter(& intel_dp->adapter);
  drm_sysfs_connector_remove(connector);
  drm_connector_cleanup(connector);
  kfree((void const   *)connector);
  return;
}
}
static void cdv_intel_dp_encoder_destroy(struct drm_encoder *encoder ) 
{ 

  {
  drm_encoder_cleanup(encoder);
  return;
}
}
static struct drm_encoder_helper_funcs  const  cdv_intel_dp_helper_funcs  = 
     {& cdv_intel_dp_dpms, 0, 0, & cdv_intel_dp_mode_fixup, & cdv_intel_dp_prepare,
    & cdv_intel_dp_commit, & cdv_intel_dp_mode_set, 0, 0, 0};
static struct drm_connector_funcs  const  cdv_intel_dp_connector_funcs  = 
     {& drm_helper_connector_dpms, 0, 0, 0, & cdv_intel_dp_detect, & drm_helper_probe_single_connector_modes,
    & cdv_intel_dp_set_property, & cdv_intel_dp_destroy, 0};
static struct drm_connector_helper_funcs  const  cdv_intel_dp_connector_helper_funcs  =    {& cdv_intel_dp_get_modes,
    & cdv_intel_dp_mode_valid, & psb_intel_best_encoder};
static struct drm_encoder_funcs  const  cdv_intel_dp_enc_funcs  =    {0, & cdv_intel_dp_encoder_destroy};
static void cdv_intel_dp_add_properties(struct drm_connector *connector ) 
{ 

  {
  cdv_intel_attach_force_audio_property(connector);
  cdv_intel_attach_broadcast_rgb_property(connector);
  return;
}
}
static bool cdv_intel_dpc_is_edp(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct child_device_config *p_child ;
  int i ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (dev_priv->child_dev_num == 0) {
    return (0);
  } else {

  }
  i = 0;
  goto ldv_38700;
  ldv_38699: 
  p_child = dev_priv->child_dev + (unsigned long )i;
  if ((unsigned int )p_child->dvo_port == 8U && (unsigned int )p_child->device_type == 30918U) {
    return (1);
  } else {

  }
  i = i + 1;
  ldv_38700: ;
  if (dev_priv->child_dev_num > i) {
    goto ldv_38699;
  } else {
    goto ldv_38701;
  }
  ldv_38701: ;
  return (0);
}
}
static void cdv_disable_intel_clock_gating(struct drm_device *dev ) 
{ u32 reg_value ;

  {
  reg_value = REGISTER_READ(dev, 25088U);
  reg_value = reg_value | 1124083776U;
  REGISTER_WRITE(dev, 25088U, reg_value);
  __const_udelay(2147500UL);
  return;
}
}
void cdv_intel_dp_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ,
                       int output_reg ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_connector *psb_intel_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct cdv_intel_dp *intel_dp ;
  char const   *name ;
  int type ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  int ret ;
  struct edp_power_seq cur ;
  u32 pp_on ;
  u32 pp_off ;
  u32 pp_div ;
  u32 pwm_ctrl ;
  bool tmp___3 ;

  {
  name = 0;
  type = 10;
  tmp = kzalloc(136UL, 208U);
  psb_intel_encoder = (struct psb_intel_encoder *)tmp;
  if ((unsigned long )psb_intel_encoder == (unsigned long )((struct psb_intel_encoder *)0)) {
    return;
  } else {

  }
  tmp___0 = kzalloc(1864UL, 208U);
  psb_intel_connector = (struct psb_intel_connector *)tmp___0;
  if ((unsigned long )psb_intel_connector == (unsigned long )((struct psb_intel_connector *)0)) {
    goto err_connector;
  } else {

  }
  tmp___1 = kzalloc(1760UL, 208U);
  intel_dp = (struct cdv_intel_dp *)tmp___1;
  if ((unsigned long )intel_dp == (unsigned long )((struct cdv_intel_dp *)0)) {
    goto err_priv;
  } else {

  }
  if (output_reg == 410112) {
    tmp___2 = cdv_intel_dpc_is_edp(dev);
    if ((int )tmp___2) {
      type = 14;
    } else {

    }
  } else {

  }
  connector = & psb_intel_connector->base;
  encoder = & psb_intel_encoder->base;
  drm_connector_init(dev, connector, & cdv_intel_dp_connector_funcs, type);
  drm_encoder_init(dev, encoder, & cdv_intel_dp_enc_funcs, 2);
  psb_intel_connector_attach_encoder(psb_intel_connector, psb_intel_encoder);
  if (type == 10) {
    psb_intel_encoder->type = 9;
  } else {
    psb_intel_encoder->type = 10;
  }
  psb_intel_encoder->dev_priv = (void *)intel_dp;
  intel_dp->encoder = psb_intel_encoder;
  intel_dp->output_reg = (uint32_t )output_reg;
  drm_encoder_helper_add(encoder, & cdv_intel_dp_helper_funcs);
  drm_connector_helper_add(connector, & cdv_intel_dp_connector_helper_funcs);
  connector->polled = 1U;
  connector->interlace_allowed = 0;
  connector->doublescan_allowed = 0;
  drm_sysfs_connector_add(connector);
  switch (output_reg) {
  case 409856: 
  name = "DPDDC-B";
  psb_intel_encoder->ddi_select = 32769U;
  goto ldv_38721;
  case 410112: 
  name = "DPDDC-C";
  psb_intel_encoder->ddi_select = 32770U;
  goto ldv_38721;
  }
  ldv_38721: 
  cdv_disable_intel_clock_gating(dev);
  cdv_intel_dp_i2c_init(psb_intel_connector, psb_intel_encoder, name);
  cdv_intel_dp_add_properties(connector);
  tmp___3 = is_edp(psb_intel_encoder);
  if ((int )tmp___3) {
    pp_on = REGISTER_READ(dev, 397828U);
    pp_on = pp_on & 65535U;
    pp_on = pp_on | 2882338816U;
    REGISTER_WRITE(dev, 397828U, pp_on);
    pwm_ctrl = REGISTER_READ(dev, 397904U);
    pwm_ctrl = pwm_ctrl | 536870912U;
    REGISTER_WRITE(dev, 397904U, pwm_ctrl);
    pp_on = REGISTER_READ(dev, 397832U);
    pp_off = REGISTER_READ(dev, 397836U);
    pp_div = REGISTER_READ(dev, 397840U);
    cur.t1_t3 = (u16 )((pp_on & 536805376U) >> 16);
    cur.t8 = (unsigned int )((u16 )pp_on) & 8191U;
    cur.t9 = (unsigned int )((u16 )pp_off) & 8191U;
    cur.t10 = (u16 )((pp_off & 536805376U) >> 16);
    cur.t11_t12 = (unsigned int )((u16 )pp_div) & 31U;
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_init", "cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
                        (int )cur.t1_t3, (int )cur.t8, (int )cur.t9, (int )cur.t10,
                        (int )cur.t11_t12);
    intel_dp->panel_power_up_delay = (int )((unsigned int )cur.t1_t3 / 10U);
    intel_dp->backlight_on_delay = (int )((unsigned int )cur.t8 / 10U);
    intel_dp->backlight_off_delay = (int )((unsigned int )cur.t9 / 10U);
    intel_dp->panel_power_down_delay = (int )((unsigned int )cur.t10 / 10U);
    intel_dp->panel_power_cycle_delay = ((int )cur.t11_t12 + -1) * 100;
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_init", "panel power up delay %d, power down delay %d, power cycle delay %d\n",
                        intel_dp->panel_power_up_delay, intel_dp->panel_power_down_delay,
                        intel_dp->panel_power_cycle_delay);
    drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_init", "backlight on delay %d, off delay %d\n",
                        intel_dp->backlight_on_delay, intel_dp->backlight_off_delay);
    cdv_intel_edp_panel_vdd_on(psb_intel_encoder);
    ret = cdv_intel_dp_aux_native_read(psb_intel_encoder, 0, (uint8_t *)(& intel_dp->dpcd),
                                       4);
    cdv_intel_edp_panel_vdd_off(psb_intel_encoder);
    if (ret == 0) {
      printk("\016[drm] failed to retrieve link info, disabling eDP\n");
      cdv_intel_dp_encoder_destroy(encoder);
      cdv_intel_dp_destroy(connector);
      goto err_priv;
    } else {
      drm_ut_debug_printk(4U, "drm", "cdv_intel_dp_init", "DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\n",
                          (int )intel_dp->dpcd[0], (int )intel_dp->dpcd[1], (int )intel_dp->dpcd[2],
                          (int )intel_dp->dpcd[3]);
    }
  } else {

  }
  return;
  err_priv: 
  kfree((void const   *)psb_intel_connector);
  err_connector: 
  kfree((void const   *)psb_intel_encoder);
  return;
}
}
int ldvarg94  ;
uint64_t ldvarg91  ;
struct drm_display_mode *cdv_intel_dp_helper_funcs_group0  ;
extern int ldv_cdv_intel_dp_enc_funcs_probe_9(void) ;
struct drm_display_mode *ldvarg168  ;
struct drm_encoder *ldvarg156  ;
struct drm_display_mode *ldvarg81  ;
struct drm_connector *cdv_intel_dp_connector_funcs_group0  ;
struct drm_display_mode *ldvarg167  ;
struct drm_encoder *cdv_intel_dp_helper_funcs_group1  ;
uint32_t ldvarg90  ;
struct drm_connector *cdv_intel_dp_connector_helper_funcs_group0  ;
bool ldvarg93  ;
extern int ldv_cdv_intel_dp_connector_funcs_probe_11(void) ;
struct drm_property *ldvarg92  ;
uint32_t ldvarg89  ;
int ldvarg169  ;
void ldv_main_exported_11(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_11 == 2) {
    drm_helper_connector_dpms(cdv_intel_dp_connector_funcs_group0, ldvarg94);
    ldv_state_variable_11 = 2;
  } else {

  }
  if (ldv_state_variable_11 == 1) {
    drm_helper_connector_dpms(cdv_intel_dp_connector_funcs_group0, ldvarg94);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_38753;
  case 1: ;
  if (ldv_state_variable_11 == 2) {
    cdv_intel_dp_detect(cdv_intel_dp_connector_funcs_group0, (int )ldvarg93);
    ldv_state_variable_11 = 2;
  } else {

  }
  if (ldv_state_variable_11 == 1) {
    cdv_intel_dp_detect(cdv_intel_dp_connector_funcs_group0, (int )ldvarg93);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_38753;
  case 2: ;
  if (ldv_state_variable_11 == 2) {
    cdv_intel_dp_set_property(cdv_intel_dp_connector_funcs_group0, ldvarg92, ldvarg91);
    ldv_state_variable_11 = 2;
  } else {

  }
  if (ldv_state_variable_11 == 1) {
    cdv_intel_dp_set_property(cdv_intel_dp_connector_funcs_group0, ldvarg92, ldvarg91);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_38753;
  case 3: ;
  if (ldv_state_variable_11 == 2) {
    cdv_intel_dp_destroy(cdv_intel_dp_connector_funcs_group0);
    ldv_state_variable_11 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38753;
  case 4: ;
  if (ldv_state_variable_11 == 2) {
    drm_helper_probe_single_connector_modes(cdv_intel_dp_connector_funcs_group0, ldvarg90,
                                            ldvarg89);
    ldv_state_variable_11 = 2;
  } else {

  }
  if (ldv_state_variable_11 == 1) {
    drm_helper_probe_single_connector_modes(cdv_intel_dp_connector_funcs_group0, ldvarg90,
                                            ldvarg89);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_38753;
  case 5: ;
  if (ldv_state_variable_11 == 1) {
    ldv_cdv_intel_dp_connector_funcs_probe_11();
    ldv_state_variable_11 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38753;
  default: ;
  goto ldv_38753;
  }
  ldv_38753: ;
  return;
}
}
void ldv_main_exported_10(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_10 == 1) {
    cdv_intel_dp_get_modes(cdv_intel_dp_connector_helper_funcs_group0);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_38764;
  case 1: ;
  if (ldv_state_variable_10 == 1) {
    cdv_intel_dp_mode_valid(cdv_intel_dp_connector_helper_funcs_group0, ldvarg81);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_38764;
  case 2: ;
  if (ldv_state_variable_10 == 1) {
    psb_intel_best_encoder(cdv_intel_dp_connector_helper_funcs_group0);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_38764;
  default: ;
  goto ldv_38764;
  }
  ldv_38764: ;
  return;
}
}
void ldv_main_exported_9(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_9 == 2) {
    cdv_intel_dp_encoder_destroy(ldvarg156);
    ldv_state_variable_9 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38772;
  case 1: ;
  if (ldv_state_variable_9 == 1) {
    ldv_cdv_intel_dp_enc_funcs_probe_9();
    ldv_state_variable_9 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38772;
  default: ;
  goto ldv_38772;
  }
  ldv_38772: ;
  return;
}
}
void ldv_main_exported_12(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_12 == 1) {
    cdv_intel_dp_dpms(cdv_intel_dp_helper_funcs_group1, ldvarg169);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_38779;
  case 1: ;
  if (ldv_state_variable_12 == 1) {
    cdv_intel_dp_mode_fixup(cdv_intel_dp_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg168,
                            cdv_intel_dp_helper_funcs_group0);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_38779;
  case 2: ;
  if (ldv_state_variable_12 == 1) {
    cdv_intel_dp_commit(cdv_intel_dp_helper_funcs_group1);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_38779;
  case 3: ;
  if (ldv_state_variable_12 == 1) {
    cdv_intel_dp_mode_set(cdv_intel_dp_helper_funcs_group1, cdv_intel_dp_helper_funcs_group0,
                          ldvarg167);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_38779;
  case 4: ;
  if (ldv_state_variable_12 == 1) {
    cdv_intel_dp_prepare(cdv_intel_dp_helper_funcs_group1);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_38779;
  default: ;
  goto ldv_38779;
  }
  ldv_38779: ;
  return;
}
}
void ldv_mutex_lock_649(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_650(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_651(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_652(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_653(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_654(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_655(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_656(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_657(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_658(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_659(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_660(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_676(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_674(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_677(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_679(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_681(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_682(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_684(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_673(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_675(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_678(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_680(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_683(struct mutex *ldv_func_arg1 ) ;
void oaktrail_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
void oaktrail_hdmi_setup(struct drm_device *dev ) ;
void oaktrail_hdmi_teardown(struct drm_device *dev ) ;
void oaktrail_hdmi_save(struct drm_device *dev ) ;
void oaktrail_hdmi_restore(struct drm_device *dev ) ;
void oaktrail_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) ;
struct drm_crtc_helper_funcs  const  oaktrail_helper_funcs ;
static int oaktrail_output_init(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  if (dev_priv->iLVDS_enable != 0U) {
    oaktrail_lvds_init(dev, & dev_priv->mode_dev);
  } else {
    dev_err((struct device  const  *)dev->dev, "DSI is not supported\n");
  }
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
    oaktrail_hdmi_init(dev, & dev_priv->mode_dev);
  } else {

  }
  return (0);
}
}
static int oaktrail_save_display_registers(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct psb_pipe *p ;
  int i ;
  u32 pp_stat ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  regs = & dev_priv->regs;
  p = (struct psb_pipe *)(& regs->pipe);
  regs->ldv_38617.psb.saveDSPARB = ioread32((void *)dev_priv->vdc_reg + 458800U);
  regs->ldv_38617.psb.saveDSPFW1 = ioread32((void *)dev_priv->vdc_reg + 458804U);
  regs->ldv_38617.psb.saveDSPFW2 = ioread32((void *)dev_priv->vdc_reg + 458808U);
  regs->ldv_38617.psb.saveDSPFW3 = ioread32((void *)dev_priv->vdc_reg + 458812U);
  regs->ldv_38617.psb.saveDSPFW4 = ioread32((void *)dev_priv->vdc_reg + 458832U);
  regs->ldv_38617.psb.saveDSPFW5 = ioread32((void *)dev_priv->vdc_reg + 458836U);
  regs->ldv_38617.psb.saveDSPFW6 = ioread32((void *)dev_priv->vdc_reg + 458840U);
  regs->ldv_38617.psb.saveCHICKENBIT = ioread32((void *)dev_priv->vdc_reg + 459776U);
  p->conf = ioread32((void *)dev_priv->vdc_reg + 458760U);
  p->src = ioread32((void *)dev_priv->vdc_reg + 393244U);
  p->fp0 = ioread32((void *)dev_priv->vdc_reg + 61504U);
  p->fp1 = ioread32((void *)dev_priv->vdc_reg + 61508U);
  p->dpll = ioread32((void *)dev_priv->vdc_reg + 61460U);
  p->htotal = ioread32((void *)dev_priv->vdc_reg + 393216U);
  p->hblank = ioread32((void *)dev_priv->vdc_reg + 393220U);
  p->hsync = ioread32((void *)dev_priv->vdc_reg + 393224U);
  p->vtotal = ioread32((void *)dev_priv->vdc_reg + 393228U);
  p->vblank = ioread32((void *)dev_priv->vdc_reg + 393232U);
  p->vsync = ioread32((void *)dev_priv->vdc_reg + 393236U);
  regs->ldv_38617.psb.saveBCLRPAT_A = ioread32((void *)dev_priv->vdc_reg + 393248U);
  p->cntr = ioread32((void *)dev_priv->vdc_reg + 459136U);
  p->stride = ioread32((void *)dev_priv->vdc_reg + 459144U);
  p->addr = ioread32((void *)dev_priv->vdc_reg + 459140U);
  p->surf = ioread32((void *)dev_priv->vdc_reg + 459164U);
  p->linoff = ioread32((void *)dev_priv->vdc_reg + 459140U);
  p->tileoff = ioread32((void *)dev_priv->vdc_reg + 459172U);
  regs->ldv_38617.psb.saveDSPACURSOR_CTRL = ioread32((void *)dev_priv->vdc_reg + 458880U);
  regs->ldv_38617.psb.saveDSPACURSOR_BASE = ioread32((void *)dev_priv->vdc_reg + 458884U);
  regs->ldv_38617.psb.saveDSPACURSOR_POS = ioread32((void *)dev_priv->vdc_reg + 458888U);
  i = 0;
  goto ldv_39090;
  ldv_39089: 
  p->palette[i] = ioread32((void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 40960));
  i = i + 1;
  ldv_39090: ;
  if (i <= 255) {
    goto ldv_39089;
  } else {
    goto ldv_39091;
  }
  ldv_39091: ;
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
    oaktrail_hdmi_save(dev);
  } else {

  }
  regs->ldv_38617.psb.savePERF_MODE = ioread32((void *)dev_priv->vdc_reg + 8436U);
  regs->ldv_38617.psb.savePP_CONTROL = ioread32((void *)dev_priv->vdc_reg + 397828U);
  regs->ldv_38617.psb.savePFIT_PGM_RATIOS = ioread32((void *)dev_priv->vdc_reg + 397876U);
  regs->ldv_38617.psb.savePFIT_AUTO_RATIOS = ioread32((void *)dev_priv->vdc_reg + 397880U);
  regs->saveBLC_PWM_CTL = ioread32((void *)dev_priv->vdc_reg + 397908U);
  regs->saveBLC_PWM_CTL2 = ioread32((void *)dev_priv->vdc_reg + 397904U);
  regs->ldv_38617.psb.saveLVDS = ioread32((void *)dev_priv->vdc_reg + 397696U);
  regs->ldv_38617.psb.savePFIT_CONTROL = ioread32((void *)dev_priv->vdc_reg + 397872U);
  regs->ldv_38617.psb.savePP_ON_DELAYS = ioread32((void *)dev_priv->vdc_reg + 397832U);
  regs->ldv_38617.psb.savePP_OFF_DELAYS = ioread32((void *)dev_priv->vdc_reg + 397836U);
  regs->ldv_38617.psb.savePP_DIVISOR = ioread32((void *)dev_priv->vdc_reg + 397840U);
  regs->ldv_38617.psb.saveOV_OVADD = ioread32((void *)dev_priv->vdc_reg + 196608U);
  regs->ldv_38617.psb.saveOV_OGAMC0 = ioread32((void *)dev_priv->vdc_reg + 196644U);
  regs->ldv_38617.psb.saveOV_OGAMC1 = ioread32((void *)dev_priv->vdc_reg + 196640U);
  regs->ldv_38617.psb.saveOV_OGAMC2 = ioread32((void *)dev_priv->vdc_reg + 196636U);
  regs->ldv_38617.psb.saveOV_OGAMC3 = ioread32((void *)dev_priv->vdc_reg + 196632U);
  regs->ldv_38617.psb.saveOV_OGAMC4 = ioread32((void *)dev_priv->vdc_reg + 196628U);
  regs->ldv_38617.psb.saveOV_OGAMC5 = ioread32((void *)dev_priv->vdc_reg + 196624U);
  regs->ldv_38617.psb.saveHISTOGRAM_INT_CONTROL_REG = ioread32((void *)dev_priv->vdc_reg + 397928U);
  regs->ldv_38617.psb.saveHISTOGRAM_LOGIC_CONTROL_REG = ioread32((void *)dev_priv->vdc_reg + 397920U);
  regs->ldv_38617.psb.savePWM_CONTROL_LOGIC = ioread32((void *)dev_priv->vdc_reg + 397904U);
  if (dev_priv->iLVDS_enable != 0U) {
    iowrite32(0U, (void *)dev_priv->vdc_reg + 397828U);
    ldv_39092: 
    pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
    if ((int )pp_stat < 0) {
      goto ldv_39092;
    } else {
      goto ldv_39093;
    }
    ldv_39093: 
    iowrite32(1476395008U, (void *)dev_priv->vdc_reg + 459136U);
    iowrite32(0U, (void *)dev_priv->vdc_reg + 459164U);
    msleep(4U);
    iowrite32(0U, (void *)dev_priv->vdc_reg + 458760U);
    msleep(8U);
    iowrite32(0U, (void *)dev_priv->vdc_reg + 61460U);
  } else {

  }
  return (0);
}
}
static int oaktrail_restore_display_registers(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct psb_save_area *regs ;
  struct psb_pipe *p ;
  u32 pp_stat ;
  int i ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  regs = & dev_priv->regs;
  p = (struct psb_pipe *)(& regs->pipe);
  iowrite32(regs->ldv_38617.psb.saveDSPARB, (void *)dev_priv->vdc_reg + 458800U);
  iowrite32(regs->ldv_38617.psb.saveDSPFW1, (void *)dev_priv->vdc_reg + 458804U);
  iowrite32(regs->ldv_38617.psb.saveDSPFW2, (void *)dev_priv->vdc_reg + 458808U);
  iowrite32(regs->ldv_38617.psb.saveDSPFW3, (void *)dev_priv->vdc_reg + 458812U);
  iowrite32(regs->ldv_38617.psb.saveDSPFW4, (void *)dev_priv->vdc_reg + 458832U);
  iowrite32(regs->ldv_38617.psb.saveDSPFW5, (void *)dev_priv->vdc_reg + 458836U);
  iowrite32(regs->ldv_38617.psb.saveDSPFW6, (void *)dev_priv->vdc_reg + 458840U);
  iowrite32(regs->ldv_38617.psb.saveCHICKENBIT, (void *)dev_priv->vdc_reg + 459776U);
  iowrite32(2147483648U, (void *)dev_priv->vdc_reg + 463872U);
  iowrite32(p->fp0, (void *)dev_priv->vdc_reg + 61504U);
  iowrite32(p->fp1, (void *)dev_priv->vdc_reg + 61508U);
  iowrite32(p->dpll, (void *)dev_priv->vdc_reg + 61460U);
  __const_udelay(644250UL);
  iowrite32(p->htotal, (void *)dev_priv->vdc_reg + 393216U);
  iowrite32(p->hblank, (void *)dev_priv->vdc_reg + 393220U);
  iowrite32(p->hsync, (void *)dev_priv->vdc_reg + 393224U);
  iowrite32(p->vtotal, (void *)dev_priv->vdc_reg + 393228U);
  iowrite32(p->vblank, (void *)dev_priv->vdc_reg + 393232U);
  iowrite32(p->vsync, (void *)dev_priv->vdc_reg + 393236U);
  iowrite32(p->src, (void *)dev_priv->vdc_reg + 393244U);
  iowrite32(regs->ldv_38617.psb.saveBCLRPAT_A, (void *)dev_priv->vdc_reg + 393248U);
  iowrite32(regs->ldv_38617.psb.savePERF_MODE, (void *)dev_priv->vdc_reg + 8436U);
  if (dev_priv->iLVDS_enable != 0U) {
    iowrite32(p->conf, (void *)dev_priv->vdc_reg + 458760U);
  } else {

  }
  iowrite32(p->linoff, (void *)dev_priv->vdc_reg + 459140U);
  iowrite32(p->stride, (void *)dev_priv->vdc_reg + 459144U);
  iowrite32(p->tileoff, (void *)dev_priv->vdc_reg + 459172U);
  iowrite32(p->cntr, (void *)dev_priv->vdc_reg + 459136U);
  iowrite32(p->surf, (void *)dev_priv->vdc_reg + 459164U);
  iowrite32(regs->ldv_38617.psb.saveDSPACURSOR_CTRL, (void *)dev_priv->vdc_reg + 458880U);
  iowrite32(regs->ldv_38617.psb.saveDSPACURSOR_POS, (void *)dev_priv->vdc_reg + 458888U);
  iowrite32(regs->ldv_38617.psb.saveDSPACURSOR_BASE, (void *)dev_priv->vdc_reg + 458884U);
  i = 0;
  goto ldv_39103;
  ldv_39102: 
  iowrite32(p->palette[i], (void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 40960));
  i = i + 1;
  ldv_39103: ;
  if (i <= 255) {
    goto ldv_39102;
  } else {
    goto ldv_39104;
  }
  ldv_39104: ;
  if ((unsigned long )dev_priv->hdmi_priv != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
    oaktrail_hdmi_restore(dev);
  } else {

  }
  if (dev_priv->iLVDS_enable != 0U) {
    iowrite32(regs->saveBLC_PWM_CTL2, (void *)dev_priv->vdc_reg + 397904U);
    iowrite32(regs->ldv_38617.psb.saveLVDS, (void *)dev_priv->vdc_reg + 397696U);
    iowrite32(regs->ldv_38617.psb.savePFIT_CONTROL, (void *)dev_priv->vdc_reg + 397872U);
    iowrite32(regs->ldv_38617.psb.savePFIT_PGM_RATIOS, (void *)dev_priv->vdc_reg + 397876U);
    iowrite32(regs->ldv_38617.psb.savePFIT_AUTO_RATIOS, (void *)dev_priv->vdc_reg + 397880U);
    iowrite32(regs->saveBLC_PWM_CTL, (void *)dev_priv->vdc_reg + 397908U);
    iowrite32(regs->ldv_38617.psb.savePP_ON_DELAYS, (void *)dev_priv->vdc_reg + 397832U);
    iowrite32(regs->ldv_38617.psb.savePP_OFF_DELAYS, (void *)dev_priv->vdc_reg + 397836U);
    iowrite32(regs->ldv_38617.psb.savePP_DIVISOR, (void *)dev_priv->vdc_reg + 397840U);
    iowrite32(regs->ldv_38617.psb.savePP_CONTROL, (void *)dev_priv->vdc_reg + 397828U);
  } else {

  }
  ldv_39105: 
  pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
  if ((pp_stat & 134217728U) != 0U) {
    goto ldv_39105;
  } else {
    goto ldv_39106;
  }
  ldv_39106: ;
  ldv_39107: 
  pp_stat = ioread32((void *)dev_priv->vdc_reg + 397824U);
  if ((pp_stat & 268435456U) != 0U) {
    goto ldv_39107;
  } else {
    goto ldv_39108;
  }
  ldv_39108: 
  iowrite32(regs->ldv_38617.psb.saveOV_OVADD, (void *)dev_priv->vdc_reg + 196608U);
  iowrite32(regs->ldv_38617.psb.saveOV_OGAMC0, (void *)dev_priv->vdc_reg + 196644U);
  iowrite32(regs->ldv_38617.psb.saveOV_OGAMC1, (void *)dev_priv->vdc_reg + 196640U);
  iowrite32(regs->ldv_38617.psb.saveOV_OGAMC2, (void *)dev_priv->vdc_reg + 196636U);
  iowrite32(regs->ldv_38617.psb.saveOV_OGAMC3, (void *)dev_priv->vdc_reg + 196632U);
  iowrite32(regs->ldv_38617.psb.saveOV_OGAMC4, (void *)dev_priv->vdc_reg + 196628U);
  iowrite32(regs->ldv_38617.psb.saveOV_OGAMC5, (void *)dev_priv->vdc_reg + 196624U);
  iowrite32(regs->ldv_38617.psb.saveHISTOGRAM_INT_CONTROL_REG, (void *)dev_priv->vdc_reg + 397928U);
  iowrite32(regs->ldv_38617.psb.saveHISTOGRAM_LOGIC_CONTROL_REG, (void *)dev_priv->vdc_reg + 397920U);
  iowrite32(regs->ldv_38617.psb.savePWM_CONTROL_LOGIC, (void *)dev_priv->vdc_reg + 397904U);
  return (0);
}
}
static int oaktrail_power_down(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 pwr_mask ;
  u32 pwr_sts ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pwr_mask = 12U;
  outl(pwr_mask, (int )(dev_priv->ospm_base + 32U));
  ldv_39116: 
  pwr_sts = inl((int )(dev_priv->ospm_base + 48U));
  if ((pwr_sts & pwr_mask) == pwr_mask) {
    goto ldv_39115;
  } else {
    __const_udelay(42950UL);
  }
  goto ldv_39116;
  ldv_39115: ;
  return (0);
}
}
static int oaktrail_power_up(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 pwr_mask ;
  u32 pwr_sts ;
  u32 pwr_cnt ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pwr_mask = 12U;
  pwr_cnt = inl((int )(dev_priv->ospm_base + 32U));
  pwr_cnt = ~ pwr_mask & pwr_cnt;
  outl(pwr_cnt, (int )(dev_priv->ospm_base + 32U));
  ldv_39125: 
  pwr_sts = inl((int )(dev_priv->ospm_base + 48U));
  if ((pwr_sts & pwr_mask) == 0U) {
    goto ldv_39124;
  } else {
    __const_udelay(42950UL);
  }
  goto ldv_39125;
  ldv_39124: ;
  return (0);
}
}
static struct psb_offset  const  oaktrail_regmap[2U]  = {      {61504U, 61508U, 459136U, 458760U, 393244U, 61460U, 0U, 393216U, 393220U, 393224U,
      393228U, 393232U, 393236U, 459144U, 459152U, 459148U, 459164U, 459164U, 459164U,
      458788U, 459140U, 459172U, 40960U}, 
        {24648U, 24652U, 463232U, 462856U, 397340U, 24600U, 0U, 397312U, 397316U, 397320U,
      397324U, 397328U, 397332U, 463240U, 463248U, 463244U, 463260U, 463236U, 463236U,
      462884U, 463236U, 463268U, 43008U}};
static int oaktrail_chip_setup(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  int ret ;
  int tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = pci_enable_msi_block(dev->pdev, 1U);
  if (tmp != 0) {
    dev_warn((struct device  const  *)dev->dev, "Enabling MSI failed!\n");
  } else {

  }
  dev_priv->regmap = (struct psb_offset  const  *)(& oaktrail_regmap);
  ret = mid_chip_setup(dev);
  if (ret < 0) {
    return (ret);
  } else {

  }
  if (! dev_priv->has_gct) {
    psb_intel_opregion_init(dev);
    psb_intel_init_bios(dev);
  } else {

  }
  oaktrail_hdmi_setup(dev);
  return (0);
}
}
static void oaktrail_teardown(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  oaktrail_hdmi_teardown(dev);
  if (! dev_priv->has_gct) {
    psb_intel_destroy_bios(dev);
  } else {

  }
  return;
}
}
struct psb_ops  const  oaktrail_chip_ops  = 
     {"Oaktrail", 1U, 2, 2, 524288, 2, 1, 0, & oaktrail_helper_funcs, & psb_intel_crtc_funcs,
    & oaktrail_chip_setup, & oaktrail_teardown, 0, & oaktrail_output_init, 0, 0, 0,
    & oaktrail_save_display_registers, & oaktrail_restore_display_registers, & oaktrail_power_up,
    & oaktrail_power_down, 0, 1};
struct drm_device *oaktrail_chip_ops_group0  ;
void ldv_main_exported_8(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_8 == 1) {
    oaktrail_teardown(oaktrail_chip_ops_group0);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_39142;
  case 1: ;
  if (ldv_state_variable_8 == 1) {
    oaktrail_chip_setup(oaktrail_chip_ops_group0);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_39142;
  case 2: ;
  if (ldv_state_variable_8 == 1) {
    oaktrail_save_display_registers(oaktrail_chip_ops_group0);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_39142;
  case 3: ;
  if (ldv_state_variable_8 == 1) {
    oaktrail_restore_display_registers(oaktrail_chip_ops_group0);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_39142;
  case 4: ;
  if (ldv_state_variable_8 == 1) {
    oaktrail_power_down(oaktrail_chip_ops_group0);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_39142;
  case 5: ;
  if (ldv_state_variable_8 == 1) {
    oaktrail_output_init(oaktrail_chip_ops_group0);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_39142;
  case 6: ;
  if (ldv_state_variable_8 == 1) {
    oaktrail_power_up(oaktrail_chip_ops_group0);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_39142;
  default: ;
  goto ldv_39142;
  }
  ldv_39142: ;
  return;
}
}
void ldv_mutex_lock_673(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_674(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_675(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_676(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_677(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_678(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_679(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_680(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_681(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_682(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_683(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_684(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
extern int __dynamic_pr_debug(struct _ddebug * , char const   *  , ...) ;
int ldv_mutex_trylock_700(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_701(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_703(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_705(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_706(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_708(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_697(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_699(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_702(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_704(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_707(struct mutex *ldv_func_arg1 ) ;
int oaktrail_crtc_hdmi_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode , int x , int y ,
                                struct drm_framebuffer *old_fb ) ;
void oaktrail_crtc_hdmi_dpms(struct drm_crtc *crtc , int mode ) ;
static struct oaktrail_limit_t  const  oaktrail_limits[3U]  = {      {{19750, 120000}, {20, 34}, {2, 8}}, 
        {{19750, 120000}, {12, 20}, {2, 7}}, 
        {{19750, 120000}, {10, 17}, {2, 8}}};
static u32 const   oaktrail_m_converts[26U]  = 
  {      43U,      21U,      42U,      53U, 
        26U,      13U,      38U,      51U, 
        25U,      44U,      54U,      59U, 
        29U,      46U,      55U,      27U, 
        45U,      22U,      11U,      37U, 
        18U,      9U,      36U,      50U, 
        57U,      28U};
static struct oaktrail_limit_t  const  *oaktrail_limit(struct drm_crtc *crtc ) 
{ struct oaktrail_limit_t  const  *limit ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  bool tmp ;
  bool tmp___0 ;

  {
  limit = 0;
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = psb_intel_pipe_has_type(crtc, 4);
  if ((int )tmp) {
    goto _L;
  } else {
    tmp___0 = psb_intel_pipe_has_type(crtc, 7);
    if ((int )tmp___0) {
      _L: /* CIL Label */ 
      switch (dev_priv->core_freq) {
      case 100: 
      limit = (struct oaktrail_limit_t  const  *)(& oaktrail_limits);
      goto ldv_38269;
      case 166: 
      limit = (struct oaktrail_limit_t  const  *)(& oaktrail_limits) + 1UL;
      goto ldv_38269;
      case 200: 
      limit = (struct oaktrail_limit_t  const  *)(& oaktrail_limits) + 2UL;
      goto ldv_38269;
      }
      ldv_38269: ;
    } else {
      limit = 0;
      dev_err((struct device  const  *)dev->dev, "oaktrail_limit Wrong display type.\n");
    }
  }
  return (limit);
}
}
static void oaktrail_clock(int refclk , struct oaktrail_clock_t *clock ) 
{ 

  {
  clock->dot = (clock->m * refclk) / (clock->p1 * 14);
  return;
}
}
static void mrstPrintPll(char *prefix , struct oaktrail_clock_t *clock ) 
{ struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "gma500_gfx";
  descriptor.function = "mrstPrintPll";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c.prepared";
  descriptor.format = "%s: dotclock = %d,  m = %d, p1 = %d.\n";
  descriptor.lineno = 265U;
  descriptor.flags = 0U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_pr_debug(& descriptor, "%s: dotclock = %d,  m = %d, p1 = %d.\n", prefix,
                       clock->dot, clock->m, clock->p1);
  } else {

  }
  return;
}
}
static bool mrstFindBestPLL(struct drm_crtc *crtc , int target , int refclk , struct oaktrail_clock_t *best_clock ) 
{ struct oaktrail_clock_t clock ;
  struct oaktrail_limit_t  const  *limit ;
  struct oaktrail_limit_t  const  *tmp ;
  int err ;
  int this_err ;
  long ret ;
  int __x___0 ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  tmp = oaktrail_limit(crtc);
  limit = tmp;
  err = target;
  memset((void *)best_clock, 0, 12UL);
  clock.m = limit->m.min;
  goto ldv_38300;
  ldv_38299: 
  clock.p1 = limit->p1.min;
  goto ldv_38297;
  ldv_38296: 
  oaktrail_clock(refclk, & clock);
  __x___0 = clock.dot - target;
  if (__x___0 < 0) {
    tmp___0 = - __x___0;
  } else {
    tmp___0 = __x___0;
  }
  ret = (long )tmp___0;
  this_err = (int )ret;
  if (this_err < err) {
    *best_clock = clock;
    err = this_err;
  } else {

  }
  clock.p1 = clock.p1 + 1;
  ldv_38297: ;
  if (clock.p1 <= (int )limit->p1.max) {
    goto ldv_38296;
  } else {
    goto ldv_38298;
  }
  ldv_38298: 
  clock.m = clock.m + 1;
  ldv_38300: ;
  if (clock.m <= (int )limit->m.max) {
    goto ldv_38299;
  } else {
    goto ldv_38301;
  }
  ldv_38301: 
  descriptor.modname = "gma500_gfx";
  descriptor.function = "mrstFindBestPLL";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c.prepared";
  descriptor.format = "mrstFindBestPLL err = %d.\n";
  descriptor.lineno = 296U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(crtc->dev)->dev, "mrstFindBestPLL err = %d.\n",
                      err);
  } else {

  }
  return (err != target);
}
}
static void oaktrail_crtc_dpms(struct drm_crtc *crtc , int mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  int pipe ;
  struct psb_offset  const  *map ;
  u32 temp ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  if (pipe == 1) {
    oaktrail_crtc_hdmi_dpms(crtc, mode);
    return;
  } else {

  }
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  switch (mode) {
  case 0: ;
  case 1: ;
  case 2: 
  temp = REGISTER_READ(dev, map->dpll);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->dpll, temp);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
    REGISTER_WRITE(dev, map->dpll, temp | 2147483648U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
  } else {

  }
  temp = REGISTER_READ(dev, map->conf);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->conf, temp | 2147483648U);
  } else {

  }
  temp = REGISTER_READ(dev, map->cntr);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, map->cntr, temp | 2147483648U);
    tmp___1 = REGISTER_READ(dev, map->base);
    REGISTER_WRITE(dev, map->base, tmp___1);
  } else {

  }
  psb_intel_crtc_load_lut(crtc);
  goto ldv_38319;
  case 3: 
  REGISTER_WRITE(dev, 463872U, 2147483648U);
  temp = REGISTER_READ(dev, map->cntr);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->cntr, temp & 2147483647U);
    tmp___2 = REGISTER_READ(dev, map->base);
    REGISTER_WRITE(dev, map->base, tmp___2);
    REGISTER_READ(dev, map->base);
  } else {

  }
  temp = REGISTER_READ(dev, map->conf);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->conf, temp & 2147483647U);
    REGISTER_READ(dev, map->conf);
  } else {

  }
  psb_intel_wait_for_vblank(dev);
  temp = REGISTER_READ(dev, map->dpll);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, map->dpll, temp & 2147483647U);
    REGISTER_READ(dev, map->dpll);
  } else {

  }
  __const_udelay(644250UL);
  goto ldv_38319;
  }
  ldv_38319: 
  REGISTER_WRITE(dev, 458800U, 16383U);
  REGISTER_WRITE(dev, 458804U, 1065879562U);
  REGISTER_WRITE(dev, 458808U, 184944648U);
  REGISTER_WRITE(dev, 458812U, 0U);
  REGISTER_WRITE(dev, 458832U, 134415364U);
  REGISTER_WRITE(dev, 458836U, 67372036U);
  REGISTER_WRITE(dev, 458840U, 120U);
  tmp___3 = REGISTER_READ(dev, 459776U);
  REGISTER_WRITE(dev, 459776U, tmp___3 | 16384U);
  gma_power_end(dev);
  return;
}
}
static int oaktrail_panel_fitter_pipe(struct drm_device *dev ) 
{ u32 pfit_control ;

  {
  pfit_control = REGISTER_READ(dev, 397872U);
  if ((int )pfit_control >= 0) {
    return (-1);
  } else {

  }
  return ((int )(pfit_control >> 29) & 3);
}
}
static int oaktrail_crtc_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                  struct drm_display_mode *adjusted_mode , int x ,
                                  int y , struct drm_framebuffer *old_fb ) 
{ struct drm_device *dev ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct drm_psb_private *dev_priv ;
  int pipe ;
  struct psb_offset  const  *map ;
  int refclk ;
  struct oaktrail_clock_t clock ;
  u32 dpll ;
  u32 fp ;
  u32 dspcntr ;
  u32 pipeconf ;
  bool ok ;
  bool is_sdvo ;
  bool is_lvds ;
  bool is_mipi ;
  struct drm_mode_config *mode_config ;
  struct psb_intel_encoder *psb_intel_encoder ;
  uint64_t scalingType ;
  struct drm_connector *connector ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___2 ;
  int offsetX ;
  int offsetY ;
  struct drm_crtc_helper_funcs *crtc_funcs ;
  struct _ddebug descriptor ;
  long tmp___3 ;
  struct _ddebug descriptor___0 ;
  long tmp___4 ;
  int sdvo_pixel_multiply ;

  {
  dev = crtc->dev;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  refclk = 0;
  dpll = 0U;
  fp = 0U;
  is_sdvo = 0;
  is_lvds = 0;
  is_mipi = 0;
  mode_config = & dev->mode_config;
  psb_intel_encoder = 0;
  scalingType = 1ULL;
  if (pipe == 1) {
    tmp = oaktrail_crtc_hdmi_mode_set(crtc, mode, adjusted_mode, x, y, old_fb);
    return (tmp);
  } else {

  }
  tmp___0 = gma_power_begin(dev, 1);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  __len = 216UL;
  if (__len > 63UL) {
    __ret = __memcpy((void *)(& psb_intel_crtc->saved_mode), (void const   *)mode,
                     __len);
  } else {
    __ret = __builtin_memcpy((void *)(& psb_intel_crtc->saved_mode), (void const   *)mode,
                             __len);
  }
  __len___0 = 216UL;
  if (__len___0 > 63UL) {
    __ret___0 = __memcpy((void *)(& psb_intel_crtc->saved_adjusted_mode), (void const   *)adjusted_mode,
                         __len___0);
  } else {
    __ret___0 = __builtin_memcpy((void *)(& psb_intel_crtc->saved_adjusted_mode),
                                 (void const   *)adjusted_mode, __len___0);
  }
  __mptr___0 = (struct list_head  const  *)mode_config->connector_list.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  goto ldv_38370;
  ldv_38369: ;
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
    goto ldv_38364;
  } else {

  }
  psb_intel_encoder = psb_intel_attached_encoder(connector);
  switch (psb_intel_encoder->type) {
  case 4: 
  is_lvds = 1;
  goto ldv_38366;
  case 3: 
  is_sdvo = 1;
  goto ldv_38366;
  case 7: 
  is_mipi = 1;
  goto ldv_38366;
  }
  ldv_38366: ;
  ldv_38364: 
  __mptr___1 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___1 + 0xfffffffffffffb80UL;
  ldv_38370: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
    goto ldv_38369;
  } else {
    goto ldv_38371;
  }
  ldv_38371: 
  REGISTER_WRITE(dev, 463872U, 2147483648U);
  tmp___2 = oaktrail_panel_fitter_pipe(dev);
  if (tmp___2 == pipe) {
    REGISTER_WRITE(dev, 397872U, 0U);
  } else {

  }
  REGISTER_WRITE(dev, map->src, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)));
  if ((unsigned long )psb_intel_encoder != (unsigned long )((struct psb_intel_encoder *)0)) {
    drm_object_property_get_value(& connector->base, dev->mode_config.scaling_mode_property,
                                  & scalingType);
  } else {

  }
  if (scalingType == 2ULL) {
    offsetX = 0;
    offsetY = 0;
    offsetX = (adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2;
    offsetY = (adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2;
    REGISTER_WRITE(dev, map->htotal, (uint32_t )((mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
    REGISTER_WRITE(dev, map->vtotal, (uint32_t )((mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
    REGISTER_WRITE(dev, map->hblank, (uint32_t )(((adjusted_mode->crtc_hblank_start - offsetX) + -1) | (((adjusted_mode->crtc_hblank_end - offsetX) + -1) << 16)));
    REGISTER_WRITE(dev, map->hsync, (uint32_t )(((adjusted_mode->crtc_hsync_start - offsetX) + -1) | (((adjusted_mode->crtc_hsync_end - offsetX) + -1) << 16)));
    REGISTER_WRITE(dev, map->vblank, (uint32_t )(((adjusted_mode->crtc_vblank_start - offsetY) + -1) | (((adjusted_mode->crtc_vblank_end - offsetY) + -1) << 16)));
    REGISTER_WRITE(dev, map->vsync, (uint32_t )(((adjusted_mode->crtc_vsync_start - offsetY) + -1) | (((adjusted_mode->crtc_vsync_end - offsetY) + -1) << 16)));
  } else {
    REGISTER_WRITE(dev, map->htotal, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
    REGISTER_WRITE(dev, map->vtotal, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
    REGISTER_WRITE(dev, map->hblank, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
    REGISTER_WRITE(dev, map->hsync, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
    REGISTER_WRITE(dev, map->vblank, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
    REGISTER_WRITE(dev, map->vsync, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
  }
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
  pipeconf = REGISTER_READ(dev, map->conf);
  dspcntr = REGISTER_READ(dev, map->cntr);
  dspcntr = dspcntr | 1073741824U;
  if (pipe == 0) {
    dspcntr = dspcntr;
  } else {
    dspcntr = dspcntr | 16777216U;
  }
  if ((int )is_mipi) {
    goto oaktrail_crtc_mode_set_exit;
  } else {

  }
  refclk = (int )(dev_priv->core_freq * 1000U);
  dpll = 0U;
  ok = mrstFindBestPLL(crtc, adjusted_mode->clock, refclk, & clock);
  if (! ok) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "oaktrail_crtc_mode_set";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c.prepared";
    descriptor.format = "mrstFindBestPLL fail in oaktrail_crtc_mode_set.\n";
    descriptor.lineno = 572U;
    descriptor.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "mrstFindBestPLL fail in oaktrail_crtc_mode_set.\n");
    } else {

    }
  } else {
    descriptor___0.modname = "gma500_gfx";
    descriptor___0.function = "oaktrail_crtc_mode_set";
    descriptor___0.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c.prepared";
    descriptor___0.format = "oaktrail_crtc_mode_set pixel clock = %d,m = %x, p1 = %x.\n";
    descriptor___0.lineno = 576U;
    descriptor___0.flags = 0U;
    tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev->dev, "oaktrail_crtc_mode_set pixel clock = %d,m = %x, p1 = %x.\n",
                        clock.dot, clock.m, clock.p1);
    } else {

    }
  }
  fp = oaktrail_m_converts[clock.m + -10] << 8;
  dpll = dpll | 268435456U;
  dpll = dpll | 2147483648U;
  if ((int )is_lvds) {
    dpll = dpll | 134217728U;
  } else {
    dpll = dpll | 67108864U;
  }
  if ((int )is_sdvo) {
    sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;
    dpll = dpll | 1073741824U;
    dpll = (u32 )((sdvo_pixel_multiply + -1) << 4) | dpll;
  } else {

  }
  dpll = (u32 )((1 << (clock.p1 + -2)) << 17) | dpll;
  dpll = dpll | 2147483648U;
  mrstPrintPll((char *)"chosen", & clock);
  if ((int )dpll < 0) {
    REGISTER_WRITE(dev, map->fp0, fp);
    REGISTER_WRITE(dev, map->dpll, dpll & 2147483647U);
    REGISTER_READ(dev, map->dpll);
    __const_udelay(644250UL);
  } else {

  }
  REGISTER_WRITE(dev, map->fp0, fp);
  REGISTER_WRITE(dev, map->dpll, dpll);
  REGISTER_READ(dev, map->dpll);
  __const_udelay(644250UL);
  REGISTER_WRITE(dev, map->dpll, dpll);
  REGISTER_READ(dev, map->dpll);
  __const_udelay(644250UL);
  REGISTER_WRITE(dev, map->conf, pipeconf);
  REGISTER_READ(dev, map->conf);
  psb_intel_wait_for_vblank(dev);
  REGISTER_WRITE(dev, map->cntr, dspcntr);
  psb_intel_wait_for_vblank(dev);
  oaktrail_crtc_mode_set_exit: 
  gma_power_end(dev);
  return (0);
}
}
static bool oaktrail_crtc_mode_fixup(struct drm_crtc *crtc , struct drm_display_mode  const  *mode ,
                                     struct drm_display_mode *adjusted_mode ) 
{ 

  {
  return (1);
}
}
static int oaktrail_pipe_set_base(struct drm_crtc *crtc , int x , int y , struct drm_framebuffer *old_fb ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_crtc *psb_intel_crtc ;
  struct drm_crtc  const  *__mptr ;
  struct psb_framebuffer *psbfb ;
  struct drm_framebuffer  const  *__mptr___0 ;
  int pipe ;
  struct psb_offset  const  *map ;
  unsigned long start ;
  unsigned long offset ;
  u32 dspcntr ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_crtc  const  *)crtc;
  psb_intel_crtc = (struct psb_intel_crtc *)__mptr;
  __mptr___0 = (struct drm_framebuffer  const  *)crtc->fb;
  psbfb = (struct psb_framebuffer *)__mptr___0;
  pipe = psb_intel_crtc->pipe;
  map = dev_priv->regmap + (unsigned long )pipe;
  ret = 0;
  if ((unsigned long )crtc->fb == (unsigned long )((struct drm_framebuffer *)0)) {
    descriptor.modname = "gma500_gfx";
    descriptor.function = "oaktrail_pipe_set_base";
    descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_crtc.c.prepared";
    descriptor.format = "No FB bound\n";
    descriptor.lineno = 664U;
    descriptor.flags = 0U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No FB bound\n");
    } else {

    }
    return (0);
  } else {

  }
  tmp___0 = gma_power_begin(dev, 1);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  start = (unsigned long )(psbfb->gtt)->offset;
  offset = (unsigned long )((crtc->fb)->pitches[0] * (unsigned int )y + (unsigned int )(((crtc->fb)->bits_per_pixel / 8) * x));
  REGISTER_WRITE(dev, map->stride, (crtc->fb)->pitches[0]);
  dspcntr = REGISTER_READ(dev, map->cntr);
  dspcntr = dspcntr & 3288334335U;
  switch ((crtc->fb)->bits_per_pixel) {
  case 8: 
  dspcntr = dspcntr | 134217728U;
  goto ldv_38408;
  case 16: ;
  if ((crtc->fb)->depth == 15U) {
    dspcntr = dspcntr | 268435456U;
  } else {
    dspcntr = dspcntr | 335544320U;
  }
  goto ldv_38408;
  case 24: ;
  case 32: 
  dspcntr = dspcntr | 402653184U;
  goto ldv_38408;
  default: 
  dev_err((struct device  const  *)dev->dev, "Unknown color depth\n");
  ret = -22;
  goto pipe_set_base_exit;
  }
  ldv_38408: 
  REGISTER_WRITE(dev, map->cntr, dspcntr);
  REGISTER_WRITE(dev, map->base, (uint32_t )offset);
  REGISTER_READ(dev, map->base);
  REGISTER_WRITE(dev, map->surf, (uint32_t )start);
  REGISTER_READ(dev, map->surf);
  pipe_set_base_exit: 
  gma_power_end(dev);
  return (ret);
}
}
static void oaktrail_crtc_prepare(struct drm_crtc *crtc ) 
{ struct drm_crtc_helper_funcs *crtc_funcs ;

  {
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->dpms))(crtc, 3);
  return;
}
}
static void oaktrail_crtc_commit(struct drm_crtc *crtc ) 
{ struct drm_crtc_helper_funcs *crtc_funcs ;

  {
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->dpms))(crtc, 0);
  return;
}
}
struct drm_crtc_helper_funcs  const  oaktrail_helper_funcs  = 
     {& oaktrail_crtc_dpms, & oaktrail_crtc_prepare, & oaktrail_crtc_commit, & oaktrail_crtc_mode_fixup,
    & oaktrail_crtc_mode_set, & oaktrail_pipe_set_base, 0, 0, 0};
int ldvarg18  ;
int ldvarg20  ;
struct drm_display_mode *oaktrail_helper_funcs_group0  ;
struct drm_crtc *oaktrail_helper_funcs_group2  ;
int ldvarg16  ;
struct drm_framebuffer *oaktrail_helper_funcs_group1  ;
int ldvarg21  ;
struct drm_display_mode *ldvarg17  ;
int ldvarg22  ;
struct drm_display_mode *ldvarg19  ;
void ldv_main_exported_7(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_7 == 1) {
    oaktrail_pipe_set_base(oaktrail_helper_funcs_group2, ldvarg22, ldvarg21, oaktrail_helper_funcs_group1);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_38437;
  case 1: ;
  if (ldv_state_variable_7 == 1) {
    oaktrail_crtc_dpms(oaktrail_helper_funcs_group2, ldvarg20);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_38437;
  case 2: ;
  if (ldv_state_variable_7 == 1) {
    oaktrail_crtc_mode_fixup(oaktrail_helper_funcs_group2, (struct drm_display_mode  const  *)ldvarg19,
                             oaktrail_helper_funcs_group0);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_38437;
  case 3: ;
  if (ldv_state_variable_7 == 1) {
    oaktrail_crtc_commit(oaktrail_helper_funcs_group2);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_38437;
  case 4: ;
  if (ldv_state_variable_7 == 1) {
    oaktrail_crtc_mode_set(oaktrail_helper_funcs_group2, oaktrail_helper_funcs_group0,
                           ldvarg17, ldvarg16, ldvarg18, oaktrail_helper_funcs_group1);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_38437;
  case 5: ;
  if (ldv_state_variable_7 == 1) {
    oaktrail_crtc_prepare(oaktrail_helper_funcs_group2);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_38437;
  default: ;
  goto ldv_38437;
  }
  ldv_38437: ;
  return;
}
}
void ldv_mutex_lock_697(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_698(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_699(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_700(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_701(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_702(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_703(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_704(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_705(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_706(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_707(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_708(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_724(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_722(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_725(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_727(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_729(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_730(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_732(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_721(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_723(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_726(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_728(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_731(struct mutex *ldv_func_arg1 ) ;
extern struct i2c_adapter *i2c_get_adapter(int  ) ;
__inline static int pm_request_idle(struct device *dev ) 
{ int tmp ;

  {
  tmp = __pm_runtime_idle(dev, 1);
  return (tmp);
}
}
static void oaktrail_lvds_set_power(struct drm_device *dev , struct psb_intel_encoder *psb_intel_encoder ,
                                    bool on ) 
{ u32 pp_status ;
  struct drm_psb_private *dev_priv ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  if ((int )on) {
    tmp___1 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___1 | 1U);
    ldv_38225: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((pp_status & 3221225472U) == 1073741824U) {
      goto ldv_38225;
    } else {
      goto ldv_38226;
    }
    ldv_38226: 
    dev_priv->is_lvds_on = 1;
    if ((unsigned long )(dev_priv->ops)->lvds_bl_power != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                 bool  ))0)) {
      (*((dev_priv->ops)->lvds_bl_power))(dev, 1);
    } else {

    }
  } else {
    if ((unsigned long )(dev_priv->ops)->lvds_bl_power != (unsigned long )((void (*/* const  */)(struct drm_device * ,
                                                                                                 bool  ))0)) {
      (*((dev_priv->ops)->lvds_bl_power))(dev, 0);
    } else {

    }
    tmp___2 = REGISTER_READ(dev, 397828U);
    REGISTER_WRITE(dev, 397828U, tmp___2 & 4294967294U);
    ldv_38227: 
    pp_status = REGISTER_READ(dev, 397824U);
    if ((int )pp_status < 0) {
      goto ldv_38227;
    } else {
      goto ldv_38228;
    }
    ldv_38228: 
    dev_priv->is_lvds_on = 0;
    pm_request_idle(& (dev->pdev)->dev);
  }
  gma_power_end(dev);
  return;
}
}
static void oaktrail_lvds_dpms(struct drm_encoder *encoder , int mode ) 
{ struct drm_device *dev ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct drm_encoder  const  *__mptr ;

  {
  dev = encoder->dev;
  __mptr = (struct drm_encoder  const  *)encoder;
  psb_intel_encoder = (struct psb_intel_encoder *)__mptr;
  if (mode == 0) {
    oaktrail_lvds_set_power(dev, psb_intel_encoder, 1);
  } else {
    oaktrail_lvds_set_power(dev, psb_intel_encoder, 0);
  }
  return;
}
}
static void oaktrail_lvds_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_mode_device *mode_dev ;
  struct drm_mode_config *mode_config ;
  struct drm_connector *connector ;
  struct drm_crtc *crtc ;
  u32 lvds_port ;
  uint64_t v ;
  bool tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  mode_dev = & dev_priv->mode_dev;
  mode_config = & dev->mode_config;
  connector = 0;
  crtc = encoder->crtc;
  v = 1ULL;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  tmp___1 = REGISTER_READ(dev, 397696U);
  lvds_port = (tmp___1 & 1073709055U) | 2147516416U;
  if ((int )mode_dev->panel_wants_dither || (unsigned int )*((unsigned char *)dev_priv + 824UL) != 0U) {
    lvds_port = lvds_port | 33554432U;
  } else {

  }
  REGISTER_WRITE(dev, 397696U, lvds_port);
  __mptr = (struct list_head  const  *)mode_config->connector_list.next;
  connector = (struct drm_connector *)__mptr + 0xfffffffffffffb80UL;
  goto ldv_38256;
  ldv_38255: ;
  if ((unsigned long )connector->encoder == (unsigned long )((struct drm_encoder *)0) || (unsigned long )(connector->encoder)->crtc != (unsigned long )crtc) {
    goto ldv_38254;
  } else {

  }
  ldv_38254: 
  __mptr___0 = (struct list_head  const  *)connector->head.next;
  connector = (struct drm_connector *)__mptr___0 + 0xfffffffffffffb80UL;
  ldv_38256: ;
  if ((unsigned long )(& connector->head) != (unsigned long )(& mode_config->connector_list)) {
    goto ldv_38255;
  } else {
    goto ldv_38257;
  }
  ldv_38257: ;
  if ((unsigned long )connector == (unsigned long )((struct drm_connector *)0)) {
    drm_err("oaktrail_lvds_mode_set", "Couldn\'t find connector when setting mode");
    return;
  } else {

  }
  drm_object_property_get_value(& connector->base, dev->mode_config.scaling_mode_property,
                                & v);
  if (v == 2ULL) {
    REGISTER_WRITE(dev, 397872U, 0U);
  } else
  if (v == 3ULL) {
    if (mode->vdisplay != adjusted_mode->crtc_vdisplay || mode->hdisplay != adjusted_mode->crtc_hdisplay) {
      if (adjusted_mode->crtc_hdisplay * mode->vdisplay == mode->hdisplay * adjusted_mode->crtc_vdisplay) {
        REGISTER_WRITE(dev, 397872U, 2147483648U);
      } else
      if (adjusted_mode->crtc_hdisplay * mode->vdisplay > mode->hdisplay * adjusted_mode->crtc_vdisplay) {
        REGISTER_WRITE(dev, 397872U, 2281701376U);
      } else {
        REGISTER_WRITE(dev, 397872U, 2348810240U);
      }
    } else {
      REGISTER_WRITE(dev, 397872U, 2147483648U);
    }
  } else {
    REGISTER_WRITE(dev, 397872U, 2147483648U);
  }
  gma_power_end(dev);
  return;
}
}
static void oaktrail_lvds_prepare(struct drm_encoder *encoder ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct psb_intel_mode_device *mode_dev ;
  bool tmp ;
  int tmp___0 ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_encoder  const  *)encoder;
  psb_intel_encoder = (struct psb_intel_encoder *)__mptr;
  mode_dev = & dev_priv->mode_dev;
  tmp = gma_power_begin(dev, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {

  }
  mode_dev->saveBLC_PWM_CTL = REGISTER_READ(dev, 397908U);
  mode_dev->backlight_duty_cycle = (int )mode_dev->saveBLC_PWM_CTL & 65535;
  oaktrail_lvds_set_power(dev, psb_intel_encoder, 0);
  gma_power_end(dev);
  return;
}
}
static u32 oaktrail_lvds_get_max_backlight(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  u32 ret ;
  uint32_t tmp ;
  bool tmp___0 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp___0 = gma_power_begin(dev, 0);
  if ((int )tmp___0) {
    tmp = REGISTER_READ(dev, 397908U);
    ret = (tmp >> 17) * 2U;
    gma_power_end(dev);
  } else {
    ret = (dev_priv->regs.saveBLC_PWM_CTL >> 17) * 2U;
  }
  return (ret);
}
}
static void oaktrail_lvds_commit(struct drm_encoder *encoder ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct psb_intel_encoder *psb_intel_encoder ;
  struct drm_encoder  const  *__mptr ;
  struct psb_intel_mode_device *mode_dev ;
  u32 tmp ;

  {
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  __mptr = (struct drm_encoder  const  *)encoder;
  psb_intel_encoder = (struct psb_intel_encoder *)__mptr;
  mode_dev = & dev_priv->mode_dev;
  if (mode_dev->backlight_duty_cycle == 0) {
    tmp = oaktrail_lvds_get_max_backlight(dev);
    mode_dev->backlight_duty_cycle = (int )tmp;
  } else {

  }
  oaktrail_lvds_set_power(dev, psb_intel_encoder, 1);
  return;
}
}
static struct drm_encoder_helper_funcs  const  oaktrail_lvds_helper_funcs  = 
     {& oaktrail_lvds_dpms, 0, 0, & psb_intel_lvds_mode_fixup, & oaktrail_lvds_prepare,
    & oaktrail_lvds_commit, & oaktrail_lvds_mode_set, 0, 0, 0};
static struct drm_display_mode lvds_configuration_modes[7U]  = {      {{0, 0}, {0U, 3739147998U, 0}, {'8', '0', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 33264, 800, 836, 846, 1056, 0, 480, 489, 491, 525, 0, 0U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'8', '0', '0', 'x', '4', '8', '0', '\000'}, 0,
      64U, 30994, 800, 801, 802, 1024, 0, 480, 481, 482, 525, 0, 0U, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '6', '0', '0', '\000'},
      0, 64U, 53990, 1024, 1072, 1104, 1184, 0, 600, 603, 604, 608, 0, 0U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '6', '0', '0', '\000'},
      0, 64U, 53990, 1024, 1104, 1136, 1184, 0, 600, 603, 604, 608, 0, 0U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '6', '0', '0', '\000'},
      0, 64U, 48885, 1024, 1124, 1204, 1312, 0, 600, 607, 610, 621, 0, 0U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '0', '2', '4', 'x', '7', '6', '8', '\000'},
      0, 64U, 65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806, 0, 0U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
        {{0, 0}, {0U, 3739147998U, 0}, {'1', '3', '6', '6', 'x', '7', '6', '8', '\000'},
      0, 64U, 77500, 1366, 1430, 1558, 1664, 0, 768, 769, 770, 776, 0, 0U, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
static void oaktrail_lvds_get_configuration_mode(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ struct drm_display_mode *mode ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_timing_info *ti ;
  void *tmp ;

  {
  mode = 0;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  ti = & dev_priv->gct_data.DTD;
  mode_dev->panel_fixed_mode = 0;
  if ((int )dev_priv->has_gct) {
    tmp = kzalloc(216UL, 208U);
    mode = (struct drm_display_mode *)tmp;
    if ((unsigned long )mode == (unsigned long )((struct drm_display_mode *)0)) {
      return;
    } else {

    }
    mode->hdisplay = ((int )ti->hactive_hi << 8) | (int )ti->hactive_lo;
    mode->vdisplay = ((int )ti->vactive_hi << 8) | (int )ti->vactive_lo;
    mode->hsync_start = mode->hdisplay + (((int )ti->hsync_offset_hi << 8) | (int )ti->hsync_offset_lo);
    mode->hsync_end = mode->hsync_start + (((int )ti->hsync_pulse_width_hi << 8) | (int )ti->hsync_pulse_width_lo);
    mode->htotal = mode->hdisplay + (((int )ti->hblank_hi << 8) | (int )ti->hblank_lo);
    mode->vsync_start = mode->vdisplay + (((int )ti->vsync_offset_hi << 4) | (int )ti->vsync_offset_lo);
    mode->vsync_end = mode->vsync_start + (((int )ti->vsync_pulse_width_hi << 4) | (int )ti->vsync_pulse_width_lo);
    mode->vtotal = mode->vdisplay + (((int )ti->vblank_hi << 8) | (int )ti->vblank_lo);
    mode->clock = (int )ti->pixel_clock * 10;
    mode_dev->panel_fixed_mode = mode;
  } else {

  }
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0) && (unsigned long )mode_dev->vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)mode_dev->vbt_mode);
  } else {

  }
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    if ((unsigned long )dev_priv->lfp_lvds_vbt_mode != (unsigned long )((struct drm_display_mode *)0)) {
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)dev_priv->lfp_lvds_vbt_mode);
    } else {

    }
  } else {

  }
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)(& lvds_configuration_modes) + 2U);
  } else {

  }
  drm_mode_set_name(mode_dev->panel_fixed_mode);
  drm_mode_set_crtcinfo(mode_dev->panel_fixed_mode, 0);
  return;
}
}
void oaktrail_lvds_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_connector *psb_intel_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  struct drm_psb_private *dev_priv ;
  struct edid *edid ;
  struct i2c_adapter *i2c_adap ;
  struct drm_display_mode *scan ;
  void *tmp ;
  void *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  tmp = kzalloc(136UL, 208U);
  psb_intel_encoder = (struct psb_intel_encoder *)tmp;
  if ((unsigned long )psb_intel_encoder == (unsigned long )((struct psb_intel_encoder *)0)) {
    return;
  } else {

  }
  tmp___0 = kzalloc(1864UL, 208U);
  psb_intel_connector = (struct psb_intel_connector *)tmp___0;
  if ((unsigned long )psb_intel_connector == (unsigned long )((struct psb_intel_connector *)0)) {
    goto failed_connector;
  } else {

  }
  connector = & psb_intel_connector->base;
  encoder = & psb_intel_encoder->base;
  dev_priv->is_lvds_on = 1;
  drm_connector_init(dev, connector, & psb_intel_lvds_connector_funcs, 7);
  drm_encoder_init(dev, encoder, & psb_intel_lvds_enc_funcs, 3);
  psb_intel_connector_attach_encoder(psb_intel_connector, psb_intel_encoder);
  psb_intel_encoder->type = 4;
  drm_encoder_helper_add(encoder, & oaktrail_lvds_helper_funcs);
  drm_connector_helper_add(connector, & psb_intel_lvds_connector_helper_funcs);
  connector->display_info.subpixel_order = 1;
  connector->interlace_allowed = 0;
  connector->doublescan_allowed = 0;
  drm_object_attach_property(& connector->base, dev->mode_config.scaling_mode_property,
                             1ULL);
  drm_object_attach_property(& connector->base, dev_priv->backlight_property, 100ULL);
  mode_dev->panel_wants_dither = 0;
  if ((int )dev_priv->has_gct) {
    mode_dev->panel_wants_dither = (dev_priv->gct_data.Panel_Port_Control & 33554432U) != 0U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)dev_priv + 824UL) != 0U) {
    mode_dev->panel_wants_dither = 1;
  } else {

  }
  i2c_adap = i2c_get_adapter((dev_priv->ops)->i2c_bus);
  if ((unsigned long )i2c_adap == (unsigned long )((struct i2c_adapter *)0)) {
    dev_err((struct device  const  *)dev->dev, "No ddc adapter available!\n");
  } else {

  }
  if ((unsigned long )i2c_adap != (unsigned long )((struct i2c_adapter *)0)) {
    edid = drm_get_edid(connector, i2c_adap);
    if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
      drm_mode_connector_update_edid_property(connector, edid);
      drm_add_edid_modes(connector, edid);
      kfree((void const   *)edid);
    } else {

    }
    __mptr = (struct list_head  const  *)connector->probed_modes.next;
    scan = (struct drm_display_mode *)__mptr;
    goto ldv_38310;
    ldv_38309: ;
    if ((scan->type & 8U) != 0U) {
      mode_dev->panel_fixed_mode = drm_mode_duplicate(dev, (struct drm_display_mode  const  *)scan);
      goto out;
    } else {

    }
    __mptr___0 = (struct list_head  const  *)scan->head.next;
    scan = (struct drm_display_mode *)__mptr___0;
    ldv_38310: ;
    if ((unsigned long )(& scan->head) != (unsigned long )(& connector->probed_modes)) {
      goto ldv_38309;
    } else {
      goto ldv_38311;
    }
    ldv_38311: ;
  } else {

  }
  oaktrail_lvds_get_configuration_mode(dev, mode_dev);
  if ((unsigned long )mode_dev->panel_fixed_mode != (unsigned long )((struct drm_display_mode *)0)) {
    (mode_dev->panel_fixed_mode)->type = (mode_dev->panel_fixed_mode)->type | 8U;
    goto out;
  } else {

  }
  if ((unsigned long )mode_dev->panel_fixed_mode == (unsigned long )((struct drm_display_mode *)0)) {
    dev_err((struct device  const  *)dev->dev, "Found no modes on the lvds, ignoring the LVDS\n");
    goto failed_find;
  } else {

  }
  out: 
  drm_sysfs_connector_add(connector);
  return;
  failed_find: 
  descriptor.modname = "gma500_gfx";
  descriptor.function = "oaktrail_lvds_init";
  descriptor.filename = "/work/ldvuser/zakharov_benchmarks/bench/cpa/work/current--X--drivers/gpu/drm/gma500/gma500_gfx.ko--X--x1linux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/42/dscv_tempdir/dscv/ri/32_7a/drivers/gpu/drm/gma500/oaktrail_lvds.c.prepared";
  descriptor.format = "No LVDS modes found, disabling.\n";
  descriptor.lineno = 580U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev->dev, "No LVDS modes found, disabling.\n");
  } else {

  }
  if ((unsigned long )psb_intel_encoder->ddc_bus != (unsigned long )((struct psb_intel_i2c_chan *)0)) {
    psb_intel_i2c_destroy(psb_intel_encoder->ddc_bus);
  } else {

  }
  drm_encoder_cleanup(encoder);
  drm_connector_cleanup(connector);
  kfree((void const   *)psb_intel_connector);
  failed_connector: 
  kfree((void const   *)psb_intel_encoder);
  return;
}
}
struct drm_display_mode *ldvarg127  ;
struct drm_encoder *oaktrail_lvds_helper_funcs_group1  ;
int ldvarg129  ;
struct drm_display_mode *oaktrail_lvds_helper_funcs_group0  ;
struct drm_display_mode *ldvarg128  ;
void ldv_main_exported_6(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_6 == 1) {
    oaktrail_lvds_dpms(oaktrail_lvds_helper_funcs_group1, ldvarg129);
    ldv_state_variable_6 = 1;
  } else {

  }
  goto ldv_38324;
  case 1: ;
  if (ldv_state_variable_6 == 1) {
    psb_intel_lvds_mode_fixup(oaktrail_lvds_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg128,
                              oaktrail_lvds_helper_funcs_group0);
    ldv_state_variable_6 = 1;
  } else {

  }
  goto ldv_38324;
  case 2: ;
  if (ldv_state_variable_6 == 1) {
    oaktrail_lvds_commit(oaktrail_lvds_helper_funcs_group1);
    ldv_state_variable_6 = 1;
  } else {

  }
  goto ldv_38324;
  case 3: ;
  if (ldv_state_variable_6 == 1) {
    oaktrail_lvds_mode_set(oaktrail_lvds_helper_funcs_group1, oaktrail_lvds_helper_funcs_group0,
                           ldvarg127);
    ldv_state_variable_6 = 1;
  } else {

  }
  goto ldv_38324;
  case 4: ;
  if (ldv_state_variable_6 == 1) {
    oaktrail_lvds_prepare(oaktrail_lvds_helper_funcs_group1);
    ldv_state_variable_6 = 1;
  } else {

  }
  goto ldv_38324;
  default: ;
  goto ldv_38324;
  }
  ldv_38324: ;
  return;
}
}
void ldv_mutex_lock_721(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_722(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_723(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_724(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_725(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_726(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_727(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_728(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_729(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_730(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_731(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_732(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_748(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_746(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_749(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_751(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_753(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_754(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_756(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_745(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_747(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_750(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_752(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_755(struct mutex *ldv_func_arg1 ) ;
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
  return;
}
}
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 

  {
  dev_set_drvdata(& pdev->dev, data);
  return;
}
}
int oaktrail_hdmi_i2c_init(struct pci_dev *dev ) ;
void oaktrail_hdmi_i2c_exit(struct pci_dev *dev ) ;
static struct oaktrail_hdmi_limit  const  oaktrail_hdmi_limit  =    {{320000, 1650000}, {1, 15}, {1, 64}, {2, 4095}};
static void oaktrail_hdmi_audio_enable(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  hdmi_dev = dev_priv->hdmi_priv;
  writel(103U, (void volatile   *)hdmi_dev->regs + 4096U);
  readl((void const volatile   *)hdmi_dev->regs + 4096U);
  writel(16U, (void volatile   *)hdmi_dev->regs + 20904U);
  readl((void const volatile   *)hdmi_dev->regs + 20904U);
  writel(1U, (void volatile   *)hdmi_dev->regs + 16384U);
  readl((void const volatile   *)hdmi_dev->regs + 16384U);
  return;
}
}
static void oaktrail_hdmi_audio_disable(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  hdmi_dev = dev_priv->hdmi_priv;
  writel(0U, (void volatile   *)hdmi_dev->regs + 20904U);
  readl((void const volatile   *)hdmi_dev->regs + 20904U);
  writel(0U, (void volatile   *)hdmi_dev->regs + 16384U);
  readl((void const volatile   *)hdmi_dev->regs + 16384U);
  writel(71U, (void volatile   *)hdmi_dev->regs + 4096U);
  readl((void const volatile   *)hdmi_dev->regs + 4096U);
  return;
}
}
static void wait_for_vblank(struct drm_device *dev ) 
{ unsigned long __ms ;
  unsigned long tmp ;

  {
  __ms = 20UL;
  goto ldv_38021;
  ldv_38020: 
  __const_udelay(4295000UL);
  ldv_38021: 
  tmp = __ms;
  __ms = __ms - 1UL;
  if (tmp != 0UL) {
    goto ldv_38020;
  } else {
    goto ldv_38022;
  }
  ldv_38022: ;
  return;
}
}
static unsigned int htotal_calculate(struct drm_display_mode *mode ) 
{ u32 htotal ;
  u32 new_crtc_htotal ;

  {
  htotal = (u32 )((mode->crtc_hdisplay + -1) | ((mode->crtc_htotal + -1) << 16));
  new_crtc_htotal = (u32 )(((mode->crtc_htotal + -1) * 200000) / mode->clock);
  drm_ut_debug_printk(4U, "drm", "htotal_calculate", "new crtc htotal 0x%4x\n", new_crtc_htotal);
  return ((u32 )(mode->crtc_hdisplay + -1) | (new_crtc_htotal << 16));
}
}
static void oaktrail_hdmi_find_dpll(struct drm_crtc *crtc , int target , int refclk ,
                                    struct oaktrail_hdmi_clock *best_clock ) 
{ int np_min ;
  int np_max ;
  int nr_min ;
  int nr_max ;
  int np ;
  int nr ;
  int nf ;
  int __x ;
  int __d ;
  int tmp ;

  {
  np_min = (((int )oaktrail_hdmi_limit.vco.min + target * 10) + -1) / (target * 10);
  np_max = (int )oaktrail_hdmi_limit.vco.max / (target * 10);
  if ((int )oaktrail_hdmi_limit.np.min > np_min) {
    np_min = oaktrail_hdmi_limit.np.min;
  } else {

  }
  if ((int )oaktrail_hdmi_limit.np.max < np_max) {
    np_max = oaktrail_hdmi_limit.np.max;
  } else {

  }
  nr_min = ((refclk * 1000 + (target * 10) * np_max) + -1) / ((target * 10) * np_max);
  nr_max = ((refclk * 1000 + (target * 10) * np_min) + -1) / ((target * 10) * np_min);
  if ((int )oaktrail_hdmi_limit.nr.min > nr_min) {
    nr_min = oaktrail_hdmi_limit.nr.min;
  } else {

  }
  if ((int )oaktrail_hdmi_limit.nr.max < nr_max) {
    nr_max = oaktrail_hdmi_limit.nr.max;
  } else {

  }
  np = ((refclk * 1000 + (target * 10) * nr_max) + -1) / ((target * 10) * nr_max);
  nr = ((refclk * 1000 + (target * 10) * np) + -1) / ((target * 10) * np);
  __x = ((target * 10) * np) * nr;
  __d = refclk;
  if (__x > 0) {
    tmp = (__d / 2 + __x) / __d;
  } else {
    tmp = (__x - __d / 2) / __d;
  }
  nf = tmp;
  drm_ut_debug_printk(4U, "drm", "oaktrail_hdmi_find_dpll", "np, nr, nf %d %d %d\n",
                      np, nr, nf);
  best_clock->np = np;
  best_clock->nr = nr + -1;
  best_clock->nf = nf << 14;
  return;
}
}
static void scu_busy_loop(void *scu_base ) 
{ u32 status ;
  u32 loop_count ;

  {
  status = 0U;
  loop_count = 0U;
  status = readl((void const volatile   *)scu_base + 4U);
  goto ldv_38053;
  ldv_38052: 
  __const_udelay(4295UL);
  status = readl((void const volatile   *)scu_base + 4U);
  loop_count = loop_count + 1U;
  if (loop_count > 1000U) {
    drm_ut_debug_printk(4U, "drm", "scu_busy_loop", "SCU IPC timed out");
    return;
  } else {

  }
  ldv_38053: ;
  if ((int )status & 1) {
    goto ldv_38052;
  } else {
    goto ldv_38054;
  }
  ldv_38054: ;
  return;
}
}
static void oaktrail_hdmi_reset(struct drm_device *dev ) 
{ void *base ;
  unsigned long scu_ipc_mmio ;
  int scu_len ;

  {
  scu_ipc_mmio = 4279353344UL;
  scu_len = 1024;
  base = ioremap((unsigned long long )scu_ipc_mmio, (unsigned long )scu_len);
  if ((unsigned long )base == (unsigned long )((void *)0)) {
    drm_err("oaktrail_hdmi_reset", "failed to map scu mmio\n");
    return;
  } else {

  }
  writel(4279357720U, (void volatile   *)base + 12U);
  writel(2147483615U, (void volatile   *)base + 128U);
  writel(270341U, (void volatile   *)base);
  scu_busy_loop(base);
  writel(4279357720U, (void volatile   *)base + 12U);
  writel(2147483647U, (void volatile   *)base + 128U);
  writel(270341U, (void volatile   *)base);
  scu_busy_loop(base);
  iounmap((void volatile   *)base);
  return;
}
}
int oaktrail_crtc_hdmi_mode_set(struct drm_crtc *crtc , struct drm_display_mode *mode ,
                                struct drm_display_mode *adjusted_mode , int x , int y ,
                                struct drm_framebuffer *old_fb ) 
{ struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  int pipe ;
  int htot_reg ;
  int tmp ;
  int hblank_reg ;
  int tmp___0 ;
  int hsync_reg ;
  int tmp___1 ;
  int vtot_reg ;
  int tmp___2 ;
  int vblank_reg ;
  int tmp___3 ;
  int vsync_reg ;
  int tmp___4 ;
  int dspsize_reg ;
  int tmp___5 ;
  int dsppos_reg ;
  int tmp___6 ;
  int pipesrc_reg ;
  int tmp___7 ;
  int pipeconf_reg ;
  int tmp___8 ;
  int refclk ;
  struct oaktrail_hdmi_clock clock ;
  u32 dspcntr ;
  u32 pipeconf ;
  u32 dpll ;
  u32 temp ;
  int dspcntr_reg ;
  bool tmp___9 ;
  int tmp___10 ;
  struct drm_crtc_helper_funcs *crtc_funcs ;

  {
  dev = crtc->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  hdmi_dev = dev_priv->hdmi_priv;
  pipe = 1;
  if (pipe == 0) {
    tmp = 393216;
  } else {
    tmp = 397312;
  }
  htot_reg = tmp;
  if (pipe == 0) {
    tmp___0 = 393220;
  } else {
    tmp___0 = 397316;
  }
  hblank_reg = tmp___0;
  if (pipe == 0) {
    tmp___1 = 393224;
  } else {
    tmp___1 = 397320;
  }
  hsync_reg = tmp___1;
  if (pipe == 0) {
    tmp___2 = 393228;
  } else {
    tmp___2 = 397324;
  }
  vtot_reg = tmp___2;
  if (pipe == 0) {
    tmp___3 = 393232;
  } else {
    tmp___3 = 397328;
  }
  vblank_reg = tmp___3;
  if (pipe == 0) {
    tmp___4 = 393236;
  } else {
    tmp___4 = 397332;
  }
  vsync_reg = tmp___4;
  if (pipe == 0) {
    tmp___5 = 459152;
  } else {
    tmp___5 = 463248;
  }
  dspsize_reg = tmp___5;
  if (pipe == 0) {
    tmp___6 = 459148;
  } else {
    tmp___6 = 463244;
  }
  dsppos_reg = tmp___6;
  if (pipe == 0) {
    tmp___7 = 393244;
  } else {
    tmp___7 = 397340;
  }
  pipesrc_reg = tmp___7;
  if (pipe == 0) {
    tmp___8 = 458760;
  } else {
    tmp___8 = 462856;
  }
  pipeconf_reg = tmp___8;
  dspcntr_reg = 463232;
  tmp___9 = gma_power_begin(dev, 1);
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10) {
    return (0);
  } else {

  }
  REGISTER_WRITE(dev, 463872U, 2147483648U);
  dpll = REGISTER_READ(dev, 24576U);
  if ((dpll & 16U) == 0U) {
    REGISTER_WRITE(dev, 24576U, dpll | 24U);
    REGISTER_WRITE(dev, 24580U, 0U);
    REGISTER_WRITE(dev, 24592U, 1U);
  } else {

  }
  __const_udelay(644250UL);
  oaktrail_hdmi_reset(dev);
  refclk = 25000;
  oaktrail_hdmi_find_dpll(crtc, adjusted_mode->clock, refclk, & clock);
  dpll = REGISTER_READ(dev, 24576U);
  dpll = dpll & 4293984255U;
  dpll = dpll & 4294967271U;
  REGISTER_WRITE(dev, 24576U, 8U);
  REGISTER_WRITE(dev, 24580U, (uint32_t )((clock.nf << 6) | clock.nr));
  REGISTER_WRITE(dev, 24588U, (uint32_t )((clock.nf >> 14) + -1));
  REGISTER_WRITE(dev, 24576U, ((u32 )(clock.np << 16) | dpll) | 3U);
  REGISTER_WRITE(dev, 24596U, 2147483648U);
  REGISTER_WRITE(dev, 24584U, 2147811586U);
  __const_udelay(644250UL);
  writel(509U, (void volatile   *)hdmi_dev->regs + 4100U);
  writel(1U, (void volatile   *)hdmi_dev->regs + 8192U);
  writel(0U, (void volatile   *)hdmi_dev->regs + 8200U);
  writel(8U, (void volatile   *)hdmi_dev->regs + 12592U);
  writel(25167888U, (void volatile   *)hdmi_dev->regs + 4124U);
  temp = htotal_calculate(adjusted_mode);
  REGISTER_WRITE(dev, (uint32_t )htot_reg, temp);
  REGISTER_WRITE(dev, (uint32_t )hblank_reg, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
  REGISTER_WRITE(dev, (uint32_t )hsync_reg, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
  REGISTER_WRITE(dev, (uint32_t )vtot_reg, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
  REGISTER_WRITE(dev, (uint32_t )vblank_reg, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
  REGISTER_WRITE(dev, (uint32_t )vsync_reg, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
  REGISTER_WRITE(dev, (uint32_t )pipesrc_reg, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)));
  REGISTER_WRITE(dev, 12544U, (uint32_t )((adjusted_mode->crtc_hdisplay + -1) | ((adjusted_mode->crtc_htotal + -1) << 16)));
  REGISTER_WRITE(dev, 12548U, (uint32_t )((adjusted_mode->crtc_hblank_start + -1) | ((adjusted_mode->crtc_hblank_end + -1) << 16)));
  REGISTER_WRITE(dev, 12552U, (uint32_t )((adjusted_mode->crtc_hsync_start + -1) | ((adjusted_mode->crtc_hsync_end + -1) << 16)));
  REGISTER_WRITE(dev, 12556U, (uint32_t )((adjusted_mode->crtc_vdisplay + -1) | ((adjusted_mode->crtc_vtotal + -1) << 16)));
  REGISTER_WRITE(dev, 12560U, (uint32_t )((adjusted_mode->crtc_vblank_start + -1) | ((adjusted_mode->crtc_vblank_end + -1) << 16)));
  REGISTER_WRITE(dev, 12564U, (uint32_t )((adjusted_mode->crtc_vsync_start + -1) | ((adjusted_mode->crtc_vsync_end + -1) << 16)));
  REGISTER_WRITE(dev, 12572U, (uint32_t )(((mode->crtc_hdisplay + -1) << 16) | (mode->crtc_vdisplay + -1)));
  temp = (u32 )(adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start);
  writel((u32 )((adjusted_mode->crtc_hdisplay + -1) << 16) | temp, (void volatile   *)hdmi_dev->regs + 12544U);
  REGISTER_WRITE(dev, (uint32_t )dspsize_reg, (uint32_t )(((mode->vdisplay + -1) << 16) | (mode->hdisplay + -1)));
  REGISTER_WRITE(dev, (uint32_t )dsppos_reg, 0U);
  crtc_funcs = (struct drm_crtc_helper_funcs *)crtc->helper_private;
  (*(crtc_funcs->mode_set_base))(crtc, x, y, old_fb);
  dspcntr = REGISTER_READ(dev, (uint32_t )dspcntr_reg);
  dspcntr = dspcntr | 1073741824U;
  dspcntr = dspcntr | 16777216U;
  dspcntr = dspcntr | 2147483648U;
  pipeconf = REGISTER_READ(dev, (uint32_t )pipeconf_reg);
  pipeconf = pipeconf | 2147483648U;
  REGISTER_WRITE(dev, (uint32_t )pipeconf_reg, pipeconf);
  REGISTER_READ(dev, (uint32_t )pipeconf_reg);
  REGISTER_WRITE(dev, 14344U, pipeconf);
  REGISTER_READ(dev, 14344U);
  wait_for_vblank(dev);
  REGISTER_WRITE(dev, (uint32_t )dspcntr_reg, dspcntr);
  wait_for_vblank(dev);
  gma_power_end(dev);
  return (0);
}
}
void oaktrail_crtc_hdmi_dpms(struct drm_crtc *crtc , int mode ) 
{ struct drm_device *dev ;
  u32 temp ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  dev = crtc->dev;
  drm_ut_debug_printk(4U, "drm", "oaktrail_crtc_hdmi_dpms", "%s %d\n", "oaktrail_crtc_hdmi_dpms",
                      mode);
  switch (mode) {
  case 3: 
  REGISTER_WRITE(dev, 463872U, 2147483648U);
  temp = REGISTER_READ(dev, 463232U);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, 463232U, temp & 2147483647U);
    REGISTER_READ(dev, 463232U);
    tmp = REGISTER_READ(dev, 463260U);
    REGISTER_WRITE(dev, 463260U, tmp);
    REGISTER_READ(dev, 463260U);
  } else {

  }
  temp = REGISTER_READ(dev, 462856U);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, 462856U, temp & 2147483647U);
    REGISTER_READ(dev, 462856U);
  } else {

  }
  temp = REGISTER_READ(dev, 14344U);
  if ((int )temp < 0) {
    REGISTER_WRITE(dev, 14344U, temp & 2147483647U);
    REGISTER_READ(dev, 14344U);
  } else {

  }
  __const_udelay(644250UL);
  temp = REGISTER_READ(dev, 24576U);
  if ((temp & 16U) == 0U) {
    REGISTER_WRITE(dev, 24576U, temp | 24U);
    REGISTER_WRITE(dev, 24592U, 1U);
  } else {

  }
  __const_udelay(644250UL);
  goto ldv_38100;
  case 0: ;
  case 1: ;
  case 2: 
  temp = REGISTER_READ(dev, 24576U);
  if ((temp & 16U) != 0U) {
    REGISTER_WRITE(dev, 24576U, temp & 4294967271U);
    temp = REGISTER_READ(dev, 24584U);
    REGISTER_WRITE(dev, 24584U, temp | 2147483906U);
    REGISTER_READ(dev, 24584U);
  } else {

  }
  __const_udelay(644250UL);
  temp = REGISTER_READ(dev, 462856U);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, 462856U, temp | 2147483648U);
    REGISTER_READ(dev, 462856U);
  } else {

  }
  temp = REGISTER_READ(dev, 14344U);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, 14344U, temp | 2147483648U);
    REGISTER_READ(dev, 14344U);
  } else {

  }
  wait_for_vblank(dev);
  temp = REGISTER_READ(dev, 463232U);
  if ((int )temp >= 0) {
    REGISTER_WRITE(dev, 463232U, temp | 2147483648U);
    tmp___0 = REGISTER_READ(dev, 463260U);
    REGISTER_WRITE(dev, 463260U, tmp___0);
    REGISTER_READ(dev, 463260U);
  } else {

  }
  psb_intel_crtc_load_lut(crtc);
  }
  ldv_38100: 
  REGISTER_WRITE(dev, 458800U, 16319U);
  REGISTER_WRITE(dev, 458804U, 1065880074U);
  REGISTER_WRITE(dev, 458808U, 184944648U);
  REGISTER_WRITE(dev, 458832U, 134415364U);
  REGISTER_WRITE(dev, 458836U, 67372036U);
  REGISTER_WRITE(dev, 459776U, 16384U);
  return;
}
}
static void oaktrail_hdmi_dpms(struct drm_encoder *encoder , int mode ) 
{ int dpms_mode ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  u32 temp ;

  {
  dpms_mode = -1;
  dev = encoder->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  hdmi_dev = dev_priv->hdmi_priv;
  if (dpms_mode == mode) {
    return;
  } else {

  }
  if (mode != 0) {
    temp = 0U;
  } else {
    temp = 153U;
  }
  dpms_mode = mode;
  writel(temp, (void volatile   *)hdmi_dev->regs + 12288U);
  return;
}
}
static int oaktrail_hdmi_mode_valid(struct drm_connector *connector , struct drm_display_mode *mode ) 
{ 

  {
  if (mode->clock > 165000) {
    return (15);
  } else {

  }
  if (mode->clock <= 19999) {
    return (16);
  } else {

  }
  if ((mode->flags & 32U) != 0U) {
    return (8);
  } else {

  }
  return (0);
}
}
static bool oaktrail_hdmi_mode_fixup(struct drm_encoder *encoder , struct drm_display_mode  const  *mode ,
                                     struct drm_display_mode *adjusted_mode ) 
{ 

  {
  return (1);
}
}
static enum drm_connector_status oaktrail_hdmi_detect(struct drm_connector *connector ,
                                                      bool force ) 
{ enum drm_connector_status status ;
  struct drm_device *dev ;
  struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  u32 temp ;

  {
  dev = connector->dev;
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  hdmi_dev = dev_priv->hdmi_priv;
  temp = readl((void const volatile   *)hdmi_dev->regs + 4104U);
  drm_ut_debug_printk(4U, "drm", "oaktrail_hdmi_detect", "HDMI_HSR %x\n", temp);
  if ((int )temp & 1) {
    status = 1;
  } else {
    status = 2;
  }
  return (status);
}
}
static unsigned char const   raw_edid[128U]  = 
  {      0U,      255U,      255U,      255U, 
        255U,      255U,      255U,      0U, 
        16U,      172U,      47U,      160U, 
        83U,      85U,      51U,      48U, 
        22U,      19U,      1U,      3U, 
        14U,      58U,      36U,      120U, 
        234U,      233U,      245U,      172U, 
        81U,      48U,      180U,      37U, 
        17U,      80U,      84U,      165U, 
        75U,      0U,      129U,      128U, 
        169U,      64U,      113U,      79U, 
        179U,      0U,      1U,      1U, 
        1U,      1U,      1U,      1U, 
        1U,      1U,      40U,      60U, 
        128U,      160U,      112U,      176U, 
        35U,      64U,      48U,      32U, 
        54U,      0U,      70U,      108U, 
        33U,      0U,      0U,      26U, 
        0U,      0U,      0U,      255U, 
        0U,      71U,      78U,      55U, 
        50U,      49U,      57U,      53U, 
        82U,      48U,      51U,      85U, 
        83U,      10U,      0U,      0U, 
        0U,      252U,      0U,      68U, 
        69U,      76U,      76U,      32U, 
        50U,      55U,      48U,      57U, 
        87U,      10U,      32U,      32U, 
        0U,      0U,      0U,      253U, 
        0U,      56U,      76U,      30U, 
        83U,      17U,      0U,      10U, 
        32U,      32U,      32U,      32U, 
        32U,      32U,      0U,      141U};
static int oaktrail_hdmi_get_modes(struct drm_connector *connector ) 
{ struct i2c_adapter *i2c_adap ;
  struct edid *edid ;
  int ret ;

  {
  ret = 0;
  i2c_adap = i2c_get_adapter(3);
  if ((unsigned long )i2c_adap == (unsigned long )((struct i2c_adapter *)0)) {
    drm_err("oaktrail_hdmi_get_modes", "No ddc adapter available!\n");
    edid = (struct edid *)(& raw_edid);
  } else {
    edid = (struct edid *)(& raw_edid);
  }
  if ((unsigned long )edid != (unsigned long )((struct edid *)0)) {
    drm_mode_connector_update_edid_property(connector, edid);
    ret = drm_add_edid_modes(connector, edid);
  } else {

  }
  return (ret);
}
}
static void oaktrail_hdmi_mode_set(struct drm_encoder *encoder , struct drm_display_mode *mode ,
                                   struct drm_display_mode *adjusted_mode ) 
{ struct drm_device *dev ;

  {
  dev = encoder->dev;
  oaktrail_hdmi_audio_enable(dev);
  return;
}
}
static void oaktrail_hdmi_destroy(struct drm_connector *connector ) 
{ 

  {
  return;
}
}
static struct drm_encoder_helper_funcs  const  oaktrail_hdmi_helper_funcs  = 
     {& oaktrail_hdmi_dpms, 0, 0, & oaktrail_hdmi_mode_fixup, & psb_intel_encoder_prepare,
    & psb_intel_encoder_commit, & oaktrail_hdmi_mode_set, 0, 0, 0};
static struct drm_connector_helper_funcs  const  oaktrail_hdmi_connector_helper_funcs  =    {& oaktrail_hdmi_get_modes,
    & oaktrail_hdmi_mode_valid, & psb_intel_best_encoder};
static struct drm_connector_funcs  const  oaktrail_hdmi_connector_funcs  = 
     {& drm_helper_connector_dpms, 0, 0, 0, & oaktrail_hdmi_detect, & drm_helper_probe_single_connector_modes,
    0, & oaktrail_hdmi_destroy, 0};
static void oaktrail_hdmi_enc_destroy(struct drm_encoder *encoder ) 
{ 

  {
  drm_encoder_cleanup(encoder);
  return;
}
}
static struct drm_encoder_funcs  const  oaktrail_hdmi_enc_funcs  =    {0, & oaktrail_hdmi_enc_destroy};
void oaktrail_hdmi_init(struct drm_device *dev , struct psb_intel_mode_device *mode_dev ) 
{ struct psb_intel_encoder *psb_intel_encoder ;
  struct psb_intel_connector *psb_intel_connector ;
  struct drm_connector *connector ;
  struct drm_encoder *encoder ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = kzalloc(136UL, 208U);
  psb_intel_encoder = (struct psb_intel_encoder *)tmp;
  if ((unsigned long )psb_intel_encoder == (unsigned long )((struct psb_intel_encoder *)0)) {
    return;
  } else {

  }
  tmp___0 = kzalloc(1864UL, 208U);
  psb_intel_connector = (struct psb_intel_connector *)tmp___0;
  if ((unsigned long )psb_intel_connector == (unsigned long )((struct psb_intel_connector *)0)) {
    goto failed_connector;
  } else {

  }
  connector = & psb_intel_connector->base;
  encoder = & psb_intel_encoder->base;
  drm_connector_init(dev, connector, & oaktrail_hdmi_connector_funcs, 3);
  drm_encoder_init(dev, encoder, & oaktrail_hdmi_enc_funcs, 2);
  psb_intel_connector_attach_encoder(psb_intel_connector, psb_intel_encoder);
  psb_intel_encoder->type = 6;
  drm_encoder_helper_add(encoder, & oaktrail_hdmi_helper_funcs);
  drm_connector_helper_add(connector, & oaktrail_hdmi_connector_helper_funcs);
  connector->display_info.subpixel_order = 1;
  connector->interlace_allowed = 0;
  connector->doublescan_allowed = 0;
  drm_sysfs_connector_add(connector);
  _dev_info((struct device  const  *)dev->dev, "HDMI initialised.\n");
  return;
  failed_connector: 
  kfree((void const   *)psb_intel_encoder);
  return;
}
}
void oaktrail_hdmi_setup(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct pci_dev *pdev ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  int ret ;
  void *tmp ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  pdev = pci_get_device(32902U, 2061U, 0);
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
    return;
  } else {

  }
  tmp = kzalloc(96UL, 208U);
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
  if ((unsigned long )hdmi_dev == (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
    dev_err((struct device  const  *)dev->dev, "failed to allocate memory\n");
    goto out;
  } else {

  }
  ret = pci_enable_device(pdev);
  if (ret != 0) {
    dev_err((struct device  const  *)dev->dev, "failed to enable hdmi controller\n");
    goto free;
  } else {

  }
  hdmi_dev->mmio = (unsigned int )pdev->resource[0].start;
  if (pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start) {
    hdmi_dev->mmio_len = ((unsigned int )pdev->resource[0].end - (unsigned int )pdev->resource[0].start) + 1U;
  } else {
    hdmi_dev->mmio_len = 0U;
  }
  hdmi_dev->regs = ioremap((resource_size_t )hdmi_dev->mmio, (unsigned long )hdmi_dev->mmio_len);
  if ((unsigned long )hdmi_dev->regs == (unsigned long )((void *)0)) {
    dev_err((struct device  const  *)dev->dev, "failed to map hdmi mmio\n");
    goto free;
  } else {

  }
  hdmi_dev->dev = pdev;
  pci_set_drvdata(pdev, (void *)hdmi_dev);
  ret = oaktrail_hdmi_i2c_init(hdmi_dev->dev);
  if (ret != 0) {
    dev_err((struct device  const  *)dev->dev, "HDMI I2C initialization failed\n");
  } else {

  }
  dev_priv->hdmi_priv = hdmi_dev;
  oaktrail_hdmi_audio_disable(dev);
  _dev_info((struct device  const  *)dev->dev, "HDMI hardware present.\n");
  return;
  free: 
  kfree((void const   *)hdmi_dev);
  out: ;
  return;
}
}
void oaktrail_hdmi_teardown(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct pci_dev *pdev ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  hdmi_dev = dev_priv->hdmi_priv;
  if ((unsigned long )hdmi_dev != (unsigned long )((struct oaktrail_hdmi_dev *)0)) {
    pdev = hdmi_dev->dev;
    pci_set_drvdata(pdev, 0);
    oaktrail_hdmi_i2c_exit(pdev);
    iounmap((void volatile   *)hdmi_dev->regs);
    kfree((void const   *)hdmi_dev);
    pci_dev_put(pdev);
  } else {

  }
  return;
}
}
void oaktrail_hdmi_save(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct psb_state *regs ;
  struct psb_pipe *pipeb ;
  int i ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  hdmi_dev = dev_priv->hdmi_priv;
  regs = & dev_priv->regs.ldv_38617.psb;
  pipeb = (struct psb_pipe *)(& dev_priv->regs.pipe) + 1UL;
  hdmi_dev->saveDPLL_CTRL = ioread32((void *)dev_priv->vdc_reg + 24576U);
  hdmi_dev->saveDPLL_DIV_CTRL = ioread32((void *)dev_priv->vdc_reg + 24580U);
  hdmi_dev->saveDPLL_ADJUST = ioread32((void *)dev_priv->vdc_reg + 24588U);
  hdmi_dev->saveDPLL_UPDATE = ioread32((void *)dev_priv->vdc_reg + 24596U);
  hdmi_dev->saveDPLL_CLK_ENABLE = ioread32((void *)dev_priv->vdc_reg + 24584U);
  pipeb->conf = ioread32((void *)dev_priv->vdc_reg + 462856U);
  pipeb->src = ioread32((void *)dev_priv->vdc_reg + 397340U);
  pipeb->htotal = ioread32((void *)dev_priv->vdc_reg + 397312U);
  pipeb->hblank = ioread32((void *)dev_priv->vdc_reg + 397316U);
  pipeb->hsync = ioread32((void *)dev_priv->vdc_reg + 397320U);
  pipeb->vtotal = ioread32((void *)dev_priv->vdc_reg + 397324U);
  pipeb->vblank = ioread32((void *)dev_priv->vdc_reg + 397328U);
  pipeb->vsync = ioread32((void *)dev_priv->vdc_reg + 397332U);
  hdmi_dev->savePCH_PIPEBCONF = ioread32((void *)dev_priv->vdc_reg + 14344U);
  hdmi_dev->savePCH_PIPEBSRC = ioread32((void *)dev_priv->vdc_reg + 12572U);
  hdmi_dev->savePCH_HTOTAL_B = ioread32((void *)dev_priv->vdc_reg + 12544U);
  hdmi_dev->savePCH_HBLANK_B = ioread32((void *)dev_priv->vdc_reg + 12548U);
  hdmi_dev->savePCH_HSYNC_B = ioread32((void *)dev_priv->vdc_reg + 12552U);
  hdmi_dev->savePCH_VTOTAL_B = ioread32((void *)dev_priv->vdc_reg + 12556U);
  hdmi_dev->savePCH_VBLANK_B = ioread32((void *)dev_priv->vdc_reg + 12560U);
  hdmi_dev->savePCH_VSYNC_B = ioread32((void *)dev_priv->vdc_reg + 12564U);
  pipeb->cntr = ioread32((void *)dev_priv->vdc_reg + 463232U);
  pipeb->stride = ioread32((void *)dev_priv->vdc_reg + 463240U);
  pipeb->addr = ioread32((void *)dev_priv->vdc_reg + 463236U);
  pipeb->surf = ioread32((void *)dev_priv->vdc_reg + 463260U);
  pipeb->linoff = ioread32((void *)dev_priv->vdc_reg + 463236U);
  pipeb->tileoff = ioread32((void *)dev_priv->vdc_reg + 463268U);
  regs->saveDSPBCURSOR_CTRL = ioread32((void *)dev_priv->vdc_reg + 458944U);
  regs->saveDSPBCURSOR_BASE = ioread32((void *)dev_priv->vdc_reg + 458948U);
  regs->saveDSPBCURSOR_POS = ioread32((void *)dev_priv->vdc_reg + 458952U);
  i = 0;
  goto ldv_38190;
  ldv_38189: 
  pipeb->palette[i] = ioread32((void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 43008));
  i = i + 1;
  ldv_38190: ;
  if (i <= 255) {
    goto ldv_38189;
  } else {
    goto ldv_38191;
  }
  ldv_38191: ;
  return;
}
}
void oaktrail_hdmi_restore(struct drm_device *dev ) 
{ struct drm_psb_private *dev_priv ;
  struct oaktrail_hdmi_dev *hdmi_dev ;
  struct psb_state *regs ;
  struct psb_pipe *pipeb ;
  int i ;

  {
  dev_priv = (struct drm_psb_private *)dev->dev_private;
  hdmi_dev = dev_priv->hdmi_priv;
  regs = & dev_priv->regs.ldv_38617.psb;
  pipeb = (struct psb_pipe *)(& dev_priv->regs.pipe) + 1UL;
  iowrite32(hdmi_dev->saveDPLL_CTRL, (void *)dev_priv->vdc_reg + 24576U);
  iowrite32(hdmi_dev->saveDPLL_DIV_CTRL, (void *)dev_priv->vdc_reg + 24580U);
  iowrite32(hdmi_dev->saveDPLL_ADJUST, (void *)dev_priv->vdc_reg + 24588U);
  iowrite32(hdmi_dev->saveDPLL_UPDATE, (void *)dev_priv->vdc_reg + 24596U);
  iowrite32(hdmi_dev->saveDPLL_CLK_ENABLE, (void *)dev_priv->vdc_reg + 24584U);
  __const_udelay(644250UL);
  iowrite32(pipeb->src, (void *)dev_priv->vdc_reg + 397340U);
  iowrite32(pipeb->htotal, (void *)dev_priv->vdc_reg + 397312U);
  iowrite32(pipeb->hblank, (void *)dev_priv->vdc_reg + 397316U);
  iowrite32(pipeb->hsync, (void *)dev_priv->vdc_reg + 397320U);
  iowrite32(pipeb->vtotal, (void *)dev_priv->vdc_reg + 397324U);
  iowrite32(pipeb->vblank, (void *)dev_priv->vdc_reg + 397328U);
  iowrite32(pipeb->vsync, (void *)dev_priv->vdc_reg + 397332U);
  iowrite32(hdmi_dev->savePCH_PIPEBSRC, (void *)dev_priv->vdc_reg + 12572U);
  iowrite32(hdmi_dev->savePCH_HTOTAL_B, (void *)dev_priv->vdc_reg + 12544U);
  iowrite32(hdmi_dev->savePCH_HBLANK_B, (void *)dev_priv->vdc_reg + 12548U);
  iowrite32(hdmi_dev->savePCH_HSYNC_B, (void *)dev_priv->vdc_reg + 12552U);
  iowrite32(hdmi_dev->savePCH_VTOTAL_B, (void *)dev_priv->vdc_reg + 12556U);
  iowrite32(hdmi_dev->savePCH_VBLANK_B, (void *)dev_priv->vdc_reg + 12560U);
  iowrite32(hdmi_dev->savePCH_VSYNC_B, (void *)dev_priv->vdc_reg + 12564U);
  iowrite32(pipeb->conf, (void *)dev_priv->vdc_reg + 462856U);
  iowrite32(hdmi_dev->savePCH_PIPEBCONF, (void *)dev_priv->vdc_reg + 14344U);
  iowrite32(pipeb->linoff, (void *)dev_priv->vdc_reg + 463236U);
  iowrite32(pipeb->stride, (void *)dev_priv->vdc_reg + 463240U);
  iowrite32(pipeb->tileoff, (void *)dev_priv->vdc_reg + 463268U);
  iowrite32(pipeb->cntr, (void *)dev_priv->vdc_reg + 463232U);
  iowrite32(pipeb->surf, (void *)dev_priv->vdc_reg + 463260U);
  iowrite32(regs->saveDSPBCURSOR_CTRL, (void *)dev_priv->vdc_reg + 458944U);
  iowrite32(regs->saveDSPBCURSOR_POS, (void *)dev_priv->vdc_reg + 458952U);
  iowrite32(regs->saveDSPBCURSOR_BASE, (void *)dev_priv->vdc_reg + 458948U);
  i = 0;
  goto ldv_38201;
  ldv_38200: 
  iowrite32(pipeb->palette[i], (void *)dev_priv->vdc_reg + (unsigned long )((i << 2) + 43008));
  i = i + 1;
  ldv_38201: ;
  if (i <= 255) {
    goto ldv_38200;
  } else {
    goto ldv_38202;
  }
  ldv_38202: ;
  return;
}
}
int ldvarg208  ;
struct drm_display_mode *ldvarg207  ;
struct drm_display_mode *ldvarg195  ;
struct drm_connector *oaktrail_hdmi_connector_helper_funcs_group0  ;
int ldvarg154  ;
uint32_t ldvarg151  ;
extern int ldv_oaktrail_hdmi_connector_funcs_probe_3(void) ;
uint32_t ldvarg152  ;
struct drm_connector *oaktrail_hdmi_connector_funcs_group0  ;
struct drm_encoder *ldvarg30  ;
extern int ldv_oaktrail_hdmi_enc_funcs_probe_2(void) ;
struct drm_display_mode *oaktrail_hdmi_helper_funcs_group0  ;
bool ldvarg153  ;
struct drm_display_mode *ldvarg206  ;
struct drm_encoder *oaktrail_hdmi_helper_funcs_group1  ;
void ldv_main_exported_4(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_4 == 1) {
    oaktrail_hdmi_get_modes(oaktrail_hdmi_connector_helper_funcs_group0);
    ldv_state_variable_4 = 1;
  } else {

  }
  goto ldv_38224;
  case 1: ;
  if (ldv_state_variable_4 == 1) {
    oaktrail_hdmi_mode_valid(oaktrail_hdmi_connector_helper_funcs_group0, ldvarg195);
    ldv_state_variable_4 = 1;
  } else {

  }
  goto ldv_38224;
  case 2: ;
  if (ldv_state_variable_4 == 1) {
    psb_intel_best_encoder(oaktrail_hdmi_connector_helper_funcs_group0);
    ldv_state_variable_4 = 1;
  } else {

  }
  goto ldv_38224;
  default: ;
  goto ldv_38224;
  }
  ldv_38224: ;
  return;
}
}
void ldv_main_exported_3(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_3 == 2) {
    drm_helper_connector_dpms(oaktrail_hdmi_connector_funcs_group0, ldvarg154);
    ldv_state_variable_3 = 2;
  } else {

  }
  if (ldv_state_variable_3 == 1) {
    drm_helper_connector_dpms(oaktrail_hdmi_connector_funcs_group0, ldvarg154);
    ldv_state_variable_3 = 1;
  } else {

  }
  goto ldv_38232;
  case 1: ;
  if (ldv_state_variable_3 == 2) {
    oaktrail_hdmi_detect(oaktrail_hdmi_connector_funcs_group0, (int )ldvarg153);
    ldv_state_variable_3 = 2;
  } else {

  }
  if (ldv_state_variable_3 == 1) {
    oaktrail_hdmi_detect(oaktrail_hdmi_connector_funcs_group0, (int )ldvarg153);
    ldv_state_variable_3 = 1;
  } else {

  }
  goto ldv_38232;
  case 2: ;
  if (ldv_state_variable_3 == 2) {
    oaktrail_hdmi_destroy(oaktrail_hdmi_connector_funcs_group0);
    ldv_state_variable_3 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38232;
  case 3: ;
  if (ldv_state_variable_3 == 2) {
    drm_helper_probe_single_connector_modes(oaktrail_hdmi_connector_funcs_group0,
                                            ldvarg152, ldvarg151);
    ldv_state_variable_3 = 2;
  } else {

  }
  if (ldv_state_variable_3 == 1) {
    drm_helper_probe_single_connector_modes(oaktrail_hdmi_connector_funcs_group0,
                                            ldvarg152, ldvarg151);
    ldv_state_variable_3 = 1;
  } else {

  }
  goto ldv_38232;
  case 4: ;
  if (ldv_state_variable_3 == 1) {
    ldv_oaktrail_hdmi_connector_funcs_probe_3();
    ldv_state_variable_3 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38232;
  default: ;
  goto ldv_38232;
  }
  ldv_38232: ;
  return;
}
}
void ldv_main_exported_2(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_2 == 2) {
    oaktrail_hdmi_enc_destroy(ldvarg30);
    ldv_state_variable_2 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_38242;
  case 1: ;
  if (ldv_state_variable_2 == 1) {
    ldv_oaktrail_hdmi_enc_funcs_probe_2();
    ldv_state_variable_2 = 2;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  goto ldv_38242;
  default: ;
  goto ldv_38242;
  }
  ldv_38242: ;
  return;
}
}
void ldv_main_exported_5(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_5 == 1) {
    oaktrail_hdmi_dpms(oaktrail_hdmi_helper_funcs_group1, ldvarg208);
    ldv_state_variable_5 = 1;
  } else {

  }
  goto ldv_38249;
  case 1: ;
  if (ldv_state_variable_5 == 1) {
    oaktrail_hdmi_mode_fixup(oaktrail_hdmi_helper_funcs_group1, (struct drm_display_mode  const  *)ldvarg207,
                             oaktrail_hdmi_helper_funcs_group0);
    ldv_state_variable_5 = 1;
  } else {

  }
  goto ldv_38249;
  case 2: ;
  if (ldv_state_variable_5 == 1) {
    psb_intel_encoder_commit(oaktrail_hdmi_helper_funcs_group1);
    ldv_state_variable_5 = 1;
  } else {

  }
  goto ldv_38249;
  case 3: ;
  if (ldv_state_variable_5 == 1) {
    oaktrail_hdmi_mode_set(oaktrail_hdmi_helper_funcs_group1, oaktrail_hdmi_helper_funcs_group0,
                           ldvarg206);
    ldv_state_variable_5 = 1;
  } else {

  }
  goto ldv_38249;
  case 4: ;
  if (ldv_state_variable_5 == 1) {
    psb_intel_encoder_prepare(oaktrail_hdmi_helper_funcs_group1);
    ldv_state_variable_5 = 1;
  } else {

  }
  goto ldv_38249;
  default: ;
  goto ldv_38249;
  }
  ldv_38249: ;
  return;
}
}
void ldv_mutex_lock_745(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_746(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_747(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_748(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_749(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_750(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_751(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_752(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_753(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_754(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_755(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_756(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_772(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_770(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_773(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_775(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_777(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_778(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_780(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_782(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_769(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_771(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_774(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_776(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_779(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_781(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) ;
void ldv_mutex_unlock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) ;
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
__inline static void init_completion(struct completion *x ) 
{ struct lock_class_key __key ;

  {
  x->done = 0U;
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
  return;
}
}
extern long wait_for_completion_interruptible_timeout(struct completion * , unsigned long  ) ;
extern void complete(struct completion * ) ;
__inline static void *i2c_get_adapdata(struct i2c_adapter  const  *dev ) 
{ void *tmp ;

  {
  tmp = dev_get_drvdata(& dev->dev);
  return (tmp);
}
}
extern int i2c_add_numbered_adapter(struct i2c_adapter * ) ;
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ int tmp ;

  {
  tmp = request_threaded_irq(irq, handler, 0, flags, name, dev);
  return (tmp);
}
}
extern void free_irq(unsigned int  , void * ) ;
static void hdmi_i2c_irq_enable(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ u32 temp ;

  {
  temp = readl((void const volatile   *)hdmi_dev->regs + 4100U);
  temp = temp | 28U;
  writel(temp, (void volatile   *)hdmi_dev->regs + 4100U);
  readl((void const volatile   *)hdmi_dev->regs + 4100U);
  return;
}
}
static void hdmi_i2c_irq_disable(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ 

  {
  writel(0U, (void volatile   *)hdmi_dev->regs + 4100U);
  readl((void const volatile   *)hdmi_dev->regs + 4100U);
  return;
}
}
static int xfer_read(struct i2c_adapter *adap , struct i2c_msg *pmsg ) 
{ struct oaktrail_hdmi_dev *hdmi_dev ;
  void *tmp ;
  struct hdmi_i2c_dev *i2c_dev ;
  u32 temp ;

  {
  tmp = i2c_get_adapdata((struct i2c_adapter  const  *)adap);
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
  i2c_dev = hdmi_dev->i2c_dev;
  i2c_dev->status = 0;
  i2c_dev->msg = pmsg;
  i2c_dev->buf_offset = 0;
  i2c_dev->complete.done = 0U;
  temp = (u32 )(((int )pmsg->len << 20) | 13);
  writel(temp, (void volatile   *)hdmi_dev->regs + 4672U);
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
  goto ldv_37993;
  ldv_37992: 
  wait_for_completion_interruptible_timeout(& i2c_dev->complete, 2500UL);
  ldv_37993: ;
  if (i2c_dev->status != 2) {
    goto ldv_37992;
  } else {
    goto ldv_37994;
  }
  ldv_37994: ;
  return (0);
}
}
static int xfer_write(struct i2c_adapter *adap , struct i2c_msg *pmsg ) 
{ 

  {
  return (0);
}
}
static int oaktrail_hdmi_i2c_access(struct i2c_adapter *adap , struct i2c_msg *pmsg ,
                                    int num ) 
{ struct oaktrail_hdmi_dev *hdmi_dev ;
  void *tmp ;
  struct hdmi_i2c_dev *i2c_dev ;
  int i ;

  {
  tmp = i2c_get_adapdata((struct i2c_adapter  const  *)adap);
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
  i2c_dev = hdmi_dev->i2c_dev;
  ldv_mutex_lock_781(& i2c_dev->i2c_lock);
  writel(34656U, (void volatile   *)hdmi_dev->regs + 4352U);
  hdmi_i2c_irq_enable(hdmi_dev);
  i = 0;
  goto ldv_38008;
  ldv_38007: ;
  if ((unsigned int )pmsg->len != 0U && (unsigned long )pmsg->buf != (unsigned long )((__u8 *)0)) {
    if ((int )pmsg->flags & 1) {
      xfer_read(adap, pmsg);
    } else {
      xfer_write(adap, pmsg);
    }
  } else {

  }
  pmsg = pmsg + 1;
  i = i + 1;
  ldv_38008: ;
  if (i < num) {
    goto ldv_38007;
  } else {
    goto ldv_38009;
  }
  ldv_38009: 
  hdmi_i2c_irq_disable(hdmi_dev);
  ldv_mutex_unlock_782(& i2c_dev->i2c_lock);
  return (i);
}
}
static u32 oaktrail_hdmi_i2c_func(struct i2c_adapter *adapter ) 
{ 

  {
  return (3U);
}
}
static struct i2c_algorithm  const  oaktrail_hdmi_i2c_algorithm  =    {& oaktrail_hdmi_i2c_access, 0, & oaktrail_hdmi_i2c_func};
static struct i2c_adapter oaktrail_hdmi_i2c_adapter  = 
     {& __this_module, 8U, & oaktrail_hdmi_i2c_algorithm, 0, {{{{0U}}, 0U, 0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                            {{0, 0}}, 0, 0, 0, 0,
                                                            0, 0}, 0, 0, {0, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 {{0}},
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0},
                                                                          0, 0, {{0},
                                                                                 {{{{{0U}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0,
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                                          0, 0, 0,
                                                                          {{0}, (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (_Bool)0,
                                                                           (_Bool)0,
                                                                           (_Bool)0,
                                                                           (_Bool)0,
                                                                           {{{{{0U}},
                                                                              0U,
                                                                              0U,
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                           {0, 0},
                                                                           {0U, {{{{{{0U}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0}}},
                                                                           0, (_Bool)0,
                                                                           (_Bool)0,
                                                                           {{0, 0},
                                                                            0UL, 0,
                                                                            0, 0UL,
                                                                            0, 0,
                                                                            0, {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0},
                                                                            {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}},
                                                                           0UL, {{0L},
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                                           {{{{{{0U}},
                                                                               0U,
                                                                               0U,
                                                                               0,
                                                                               {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                            {0, 0}},
                                                                           {0}, {0},
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           (unsigned char)0,
                                                                           0, 0, 0,
                                                                           0, 0UL,
                                                                           0UL, 0UL,
                                                                           0UL, 0,
                                                                           0}, 0,
                                                                          0, 0, 0ULL,
                                                                          0, {0, 0},
                                                                          0, {0, 0},
                                                                          0, {0},
                                                                          0U, 0U,
                                                                          {{{{{0U}},
                                                                             0U, 0U,
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                          {0, 0},
                                                                          {0, {0,
                                                                               0},
                                                                           {{0}}},
                                                                          0, 0, 0,
                                                                          0}, 3, {'o',
                                                                                  'a',
                                                                                  'k',
                                                                                  't',
                                                                                  'r',
                                                                                  'a',
                                                                                  'i',
                                                                                  'l',
                                                                                  '_',
                                                                                  'h',
                                                                                  'd',
                                                                                  'm',
                                                                                  'i',
                                                                                  '_',
                                                                                  'i',
                                                                                  '2',
                                                                                  'c',
                                                                                  '\000'},
    {0U, {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}}, {{0}, {{{{{0U}},
                                                                              0U,
                                                                              0U,
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                                      {0, 0}, 0, 0,
                                                                      0, {0, {0, 0},
                                                                          0, 0, 0UL}},
    {0, 0}};
static void hdmi_i2c_read(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ struct hdmi_i2c_dev *i2c_dev ;
  struct i2c_msg *msg ;
  u8 *buf ;
  u32 temp ;
  int i ;
  int offset ;
  size_t __len ;
  void *__ret ;

  {
  i2c_dev = hdmi_dev->i2c_dev;
  msg = i2c_dev->msg;
  buf = msg->buf;
  offset = i2c_dev->buf_offset;
  i = 0;
  goto ldv_38028;
  ldv_38027: 
  temp = readl((void const volatile   *)hdmi_dev->regs + (unsigned long )((i + 1152) * 4));
  __len = 4UL;
  if (__len > 63UL) {
    __ret = __memcpy((void *)buf + (unsigned long )(i * 4 + offset), (void const   *)(& temp),
                     __len);
  } else {
    __ret = __builtin_memcpy((void *)buf + (unsigned long )(i * 4 + offset), (void const   *)(& temp),
                             __len);
  }
  i = i + 1;
  ldv_38028: ;
  if (i <= 15) {
    goto ldv_38027;
  } else {
    goto ldv_38029;
  }
  ldv_38029: 
  i2c_dev->buf_offset = i2c_dev->buf_offset + 64;
  temp = readl((void const volatile   *)hdmi_dev->regs + 4108U);
  writel(temp | 8U, (void volatile   *)hdmi_dev->regs + 4108U);
  readl((void const volatile   *)hdmi_dev->regs + 4108U);
  temp = readl((void const volatile   *)hdmi_dev->regs + 4672U);
  writel(temp | 2U, (void volatile   *)hdmi_dev->regs + 4672U);
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
  i2c_dev->status = 1;
  return;
}
}
static void hdmi_i2c_transaction_done(struct oaktrail_hdmi_dev *hdmi_dev ) 
{ struct hdmi_i2c_dev *i2c_dev ;
  u32 temp ;

  {
  i2c_dev = hdmi_dev->i2c_dev;
  temp = readl((void const volatile   *)hdmi_dev->regs + 4108U);
  writel(temp | 4U, (void volatile   *)hdmi_dev->regs + 4108U);
  readl((void const volatile   *)hdmi_dev->regs + 4108U);
  temp = readl((void const volatile   *)hdmi_dev->regs + 4672U);
  writel(temp & 4294967294U, (void volatile   *)hdmi_dev->regs + 4672U);
  readl((void const volatile   *)hdmi_dev->regs + 4672U);
  i2c_dev->status = 2;
  return;
}
}
static irqreturn_t oaktrail_hdmi_i2c_handler(int this_irq , void *dev ) 
{ struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  u32 stat ;

  {
  hdmi_dev = (struct oaktrail_hdmi_dev *)dev;
  i2c_dev = hdmi_dev->i2c_dev;
  stat = readl((void const volatile   *)hdmi_dev->regs + 4108U);
  if ((int )stat & 1) {
    writel(stat | 1U, (void volatile   *)hdmi_dev->regs + 4108U);
    readl((void const volatile   *)hdmi_dev->regs + 4108U);
  } else {

  }
  if ((stat & 8U) != 0U) {
    hdmi_i2c_read(hdmi_dev);
  } else {

  }
  if ((stat & 4U) != 0U) {
    hdmi_i2c_transaction_done(hdmi_dev);
  } else {

  }
  complete(& i2c_dev->complete);
  return (1);
}
}
static void oaktrail_hdmi_i2c_gpio_fix(void) 
{ void *base ;
  unsigned int gpio_base ;
  int gpio_len ;
  u32 temp ;

  {
  gpio_base = 4279418880U;
  gpio_len = 4096;
  base = ioremap((unsigned long long )gpio_base, (unsigned long )gpio_len);
  if ((unsigned long )base == (unsigned long )((void *)0)) {
    drm_err("oaktrail_hdmi_i2c_gpio_fix", "gpio ioremap fail\n");
    return;
  } else {

  }
  temp = readl((void const volatile   *)base + 68U);
  drm_ut_debug_printk(2U, "drm", "oaktrail_hdmi_i2c_gpio_fix", "old gpio val %x\n",
                      temp);
  writel(temp | 2560U, (void volatile   *)base + 68U);
  temp = readl((void const volatile   *)base + 68U);
  drm_ut_debug_printk(2U, "drm", "oaktrail_hdmi_i2c_gpio_fix", "new gpio val %x\n",
                      temp);
  iounmap((void volatile   *)base);
  return;
}
}
int oaktrail_hdmi_i2c_init(struct pci_dev *dev ) 
{ struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;

  {
  tmp = pci_get_drvdata(dev);
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
  tmp___0 = kzalloc(296UL, 208U);
  i2c_dev = (struct hdmi_i2c_dev *)tmp___0;
  if ((unsigned long )i2c_dev == (unsigned long )((struct hdmi_i2c_dev *)0)) {
    drm_err("oaktrail_hdmi_i2c_init", "Can\'t allocate interface\n");
    ret = -12;
    goto exit;
  } else {

  }
  i2c_dev->adap = & oaktrail_hdmi_i2c_adapter;
  i2c_dev->status = 0;
  init_completion(& i2c_dev->complete);
  __mutex_init(& i2c_dev->i2c_lock, "&i2c_dev->i2c_lock", & __key);
  i2c_set_adapdata(& oaktrail_hdmi_i2c_adapter, (void *)hdmi_dev);
  hdmi_dev->i2c_dev = i2c_dev;
  oaktrail_hdmi_i2c_gpio_fix();
  ret = request_irq(dev->irq, & oaktrail_hdmi_i2c_handler, 128UL, (char const   *)(& oaktrail_hdmi_i2c_adapter.name),
                    (void *)hdmi_dev);
  if (ret != 0) {
    drm_err("oaktrail_hdmi_i2c_init", "Failed to request IRQ for I2C controller\n");
    goto err;
  } else {

  }
  ret = i2c_add_numbered_adapter(& oaktrail_hdmi_i2c_adapter);
  return (ret);
  err: 
  kfree((void const   *)i2c_dev);
  exit: ;
  return (ret);
}
}
void oaktrail_hdmi_i2c_exit(struct pci_dev *dev ) 
{ struct oaktrail_hdmi_dev *hdmi_dev ;
  struct hdmi_i2c_dev *i2c_dev ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = pci_get_drvdata(dev);
  hdmi_dev = (struct oaktrail_hdmi_dev *)tmp;
  tmp___0 = i2c_del_adapter(& oaktrail_hdmi_i2c_adapter);
  if (tmp___0 != 0) {
    drm_ut_debug_printk(2U, "drm", "oaktrail_hdmi_i2c_exit", "Failed to delete hdmi-i2c adapter\n");
  } else {

  }
  i2c_dev = hdmi_dev->i2c_dev;
  kfree((void const   *)i2c_dev);
  free_irq(dev->irq, (void *)hdmi_dev);
  return;
}
}
struct i2c_adapter *oaktrail_hdmi_i2c_algorithm_group0  ;
struct i2c_msg *ldvarg32  ;
int ldvarg31  ;
void ldv_main_exported_1(void) 
{ int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_1 == 1) {
    oaktrail_hdmi_i2c_access(oaktrail_hdmi_i2c_algorithm_group0, ldvarg32, ldvarg31);
    ldv_state_variable_1 = 1;
  } else {

  }
  goto ldv_38073;
  case 1: ;
  if (ldv_state_variable_1 == 1) {
    oaktrail_hdmi_i2c_func(oaktrail_hdmi_i2c_algorithm_group0);
    ldv_state_variable_1 = 1;
  } else {

  }
  goto ldv_38073;
  default: ;
  goto ldv_38073;
  }
  ldv_38073: ;
  return;
}
}
void ldv_mutex_lock_769(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_770(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_771(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_772(struct mutex *ldv_func_arg1 ) 
{ ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_773(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_774(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_775(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_776(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_777(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_update_lock_of_backlight_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_778(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_lock_of_fb_info(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_779(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_780(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_struct_mutex_of_drm_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_781(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_lock_i2c_lock_of_hdmi_i2c_dev(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_782(struct mutex *ldv_func_arg1 ) 
{ 

  {
  ldv_mutex_unlock_i2c_lock_of_hdmi_i2c_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
__inline static void ldv_error(void) 
{ 

  {
  ERROR: __VERIFIER_error();
}
}
extern int __VERIFIER_nondet_int(void) ;
long ldv__builtin_expect(long exp , long c ) 
{ 

  {
  return (exp);
}
}
void ldv__builtin_trap(void) 
{ 

  {
  ldv_error();
  return;
}
}
static int ldv_mutex_cred_guard_mutex_of_signal_struct  ;
int ldv_mutex_lock_interruptible_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
  return;
}
}
int ldv_mutex_trylock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_cred_guard_mutex_of_signal_struct(atomic_t *cnt ,
                                                                    struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_cred_guard_mutex_of_signal_struct = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_cred_guard_mutex_of_signal_struct(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_cred_guard_mutex_of_signal_struct = 1;
  return;
}
}
static int ldv_mutex_gtt_mutex_of_drm_psb_private  ;
int ldv_mutex_lock_interruptible_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
  return;
}
}
int ldv_mutex_trylock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_gtt_mutex_of_drm_psb_private(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_gtt_mutex_of_drm_psb_private = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_gtt_mutex_of_drm_psb_private(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_gtt_mutex_of_drm_psb_private = 1;
  return;
}
}
static int ldv_mutex_i2c_lock_of_hdmi_i2c_dev  ;
int ldv_mutex_lock_interruptible_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
  return;
}
}
int ldv_mutex_trylock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_i2c_lock_of_hdmi_i2c_dev(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_i2c_lock_of_hdmi_i2c_dev(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 1;
  return;
}
}
static int ldv_mutex_lock  ;
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_lock == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_lock = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_lock == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_lock = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_lock == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_lock = 2;
  return;
}
}
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_lock == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_lock = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_lock == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_lock = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_lock == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_lock == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_lock = 1;
  return;
}
}
static int ldv_mutex_lock_of_fb_info  ;
int ldv_mutex_lock_interruptible_lock_of_fb_info(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_lock_of_fb_info = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_lock_of_fb_info(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_lock_of_fb_info = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_lock_of_fb_info(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_lock_of_fb_info = 2;
  return;
}
}
int ldv_mutex_trylock_lock_of_fb_info(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_lock_of_fb_info = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_lock_of_fb_info(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_lock_of_fb_info = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_lock_of_fb_info(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_lock_of_fb_info == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_lock_of_fb_info(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_lock_of_fb_info == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_lock_of_fb_info = 1;
  return;
}
}
static int ldv_mutex_mutex_of_device  ;
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_mutex_of_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_mutex_of_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_mutex_of_device = 2;
  return;
}
}
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_mutex_of_device = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_mutex_of_device = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_mutex_of_device == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_mutex_of_device = 1;
  return;
}
}
static int ldv_mutex_mutex_of_drm_mode_config  ;
int ldv_mutex_lock_interruptible_mutex_of_drm_mode_config(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_mutex_of_drm_mode_config = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_mutex_of_drm_mode_config(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_mutex_of_drm_mode_config = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_mutex_of_drm_mode_config = 2;
  return;
}
}
int ldv_mutex_trylock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_mutex_of_drm_mode_config = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_mutex_of_drm_mode_config(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_mutex_of_drm_mode_config = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_mutex_of_drm_mode_config(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_mutex_of_drm_mode_config(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_mutex_of_drm_mode_config == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_mutex_of_drm_mode_config = 1;
  return;
}
}
static int ldv_mutex_power_mutex  ;
int ldv_mutex_lock_interruptible_power_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_power_mutex == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_power_mutex = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_power_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_power_mutex == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_power_mutex = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_power_mutex(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_power_mutex == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_power_mutex = 2;
  return;
}
}
int ldv_mutex_trylock_power_mutex(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_power_mutex == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_power_mutex = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_power_mutex(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_power_mutex == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_power_mutex = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_power_mutex(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_power_mutex == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_power_mutex(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_power_mutex == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_power_mutex = 1;
  return;
}
}
static int ldv_mutex_struct_mutex_of_drm_device  ;
int ldv_mutex_lock_interruptible_struct_mutex_of_drm_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_struct_mutex_of_drm_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_struct_mutex_of_drm_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_struct_mutex_of_drm_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_struct_mutex_of_drm_device = 2;
  return;
}
}
int ldv_mutex_trylock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_struct_mutex_of_drm_device = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_struct_mutex_of_drm_device(atomic_t *cnt , struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_struct_mutex_of_drm_device = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_struct_mutex_of_drm_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_struct_mutex_of_drm_device(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_struct_mutex_of_drm_device == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_struct_mutex_of_drm_device = 1;
  return;
}
}
static int ldv_mutex_update_lock_of_backlight_device  ;
int ldv_mutex_lock_interruptible_update_lock_of_backlight_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_update_lock_of_backlight_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_update_lock_of_backlight_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
    ldv_error();
  }
  nondetermined = __VERIFIER_nondet_int();
  if (nondetermined) {
    ldv_mutex_update_lock_of_backlight_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_update_lock_of_backlight_device(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
    ldv_error();
  }
  ldv_mutex_update_lock_of_backlight_device = 2;
  return;
}
}
int ldv_mutex_trylock_update_lock_of_backlight_device(struct mutex *lock ) 
{ int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
    ldv_error();
  }
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
  if (is_mutex_held_by_another_thread) {
    return (0);
  } else {
    ldv_mutex_update_lock_of_backlight_device = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_update_lock_of_backlight_device(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ int atomic_value_after_dec ;

  {
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
    ldv_error();
  }
  atomic_value_after_dec = __VERIFIER_nondet_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_update_lock_of_backlight_device = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_update_lock_of_backlight_device(struct mutex *lock ) 
{ int nondetermined ;

  {
  if (ldv_mutex_update_lock_of_backlight_device == 1) {
    nondetermined = __VERIFIER_nondet_int();
    if (nondetermined) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_update_lock_of_backlight_device(struct mutex *lock ) 
{ 

  {
  if (ldv_mutex_update_lock_of_backlight_device == 2) {

  } else {
    ldv_error();
  }
  ldv_mutex_update_lock_of_backlight_device = 1;
  return;
}
}
void ldv_initialize(void) 
{ 

  {
  ldv_mutex_cred_guard_mutex_of_signal_struct = 1;
  ldv_mutex_gtt_mutex_of_drm_psb_private = 1;
  ldv_mutex_i2c_lock_of_hdmi_i2c_dev = 1;
  ldv_mutex_lock = 1;
  ldv_mutex_lock_of_fb_info = 1;
  ldv_mutex_mutex_of_device = 1;
  ldv_mutex_mutex_of_drm_mode_config = 1;
  ldv_mutex_power_mutex = 1;
  ldv_mutex_struct_mutex_of_drm_device = 1;
  ldv_mutex_update_lock_of_backlight_device = 1;
  return;
}
}
void ldv_check_final_state(void) 
{ 

  {
  if (ldv_mutex_cred_guard_mutex_of_signal_struct == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_gtt_mutex_of_drm_psb_private == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_i2c_lock_of_hdmi_i2c_dev == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_lock == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_lock_of_fb_info == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_mutex_of_device == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_mutex_of_drm_mode_config == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_power_mutex == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_struct_mutex_of_drm_device == 1) {

  } else {
    ldv_error();
  }
  if (ldv_mutex_update_lock_of_backlight_device == 1) {

  } else {
    ldv_error();
  }
  return;
}
}
