extern void __VERIFIER_error() __attribute__ ((__noreturn__));

/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 24 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/sysinfo.h"
struct pt_regs;
#line 14 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2024_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2024_8 ldv_2024 ;
};
#line 27 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
struct task_struct;
#line 35
struct lockdep_map;
#line 58 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2096_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2111_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2112_11 {
   struct __anonstruct_ldv_2096_12 ldv_2096 ;
   struct __anonstruct_ldv_2111_13 ldv_2111 ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2112_11 ldv_2112 ;
};
#line 43 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned char ist : 3 ;
   unsigned char zero0 : 5 ;
   unsigned char type : 5 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
};
#line 81 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/desc_defs.h"
typedef struct gate_struct64 gate_desc;
#line 84 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
};
#line 355 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct thread_struct;
#line 356
struct tss_struct;
#line 101 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
struct pv_cpu_ops {
   unsigned long (*get_debugreg)(int  ) ;
   void (*set_debugreg)(int  , unsigned long  ) ;
   void (*clts)(void) ;
   unsigned long (*read_cr0)(void) ;
   void (*write_cr0)(unsigned long  ) ;
   unsigned long (*read_cr4_safe)(void) ;
   unsigned long (*read_cr4)(void) ;
   void (*write_cr4)(unsigned long  ) ;
   unsigned long (*read_cr8)(void) ;
   void (*write_cr8)(unsigned long  ) ;
   void (*load_tr_desc)(void) ;
   void (*load_gdt)(struct desc_ptr  const  * ) ;
   void (*load_idt)(struct desc_ptr  const  * ) ;
   void (*store_gdt)(struct desc_ptr * ) ;
   void (*store_idt)(struct desc_ptr * ) ;
   void (*set_ldt)(void const   * , unsigned int  ) ;
   unsigned long (*store_tr)(void) ;
   void (*load_tls)(struct thread_struct * , unsigned int  ) ;
   void (*load_gs_index)(unsigned int  ) ;
   void (*write_ldt_entry)(struct desc_struct * , int  , void const   * ) ;
   void (*write_gdt_entry)(struct desc_struct * , int  , void const   * , int  ) ;
   void (*write_idt_entry)(gate_desc * , int  , gate_desc const   * ) ;
   void (*alloc_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*free_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*load_sp0)(struct tss_struct * , struct thread_struct * ) ;
   void (*set_iopl_mask)(unsigned int  ) ;
   void (*wbinvd)(void) ;
   void (*io_delay)(void) ;
   void (*cpuid)(unsigned int * , unsigned int * , unsigned int * , unsigned int * ) ;
   u64 (*read_msr)(unsigned int  , int * ) ;
   int (*write_msr)(unsigned int  , unsigned int  , unsigned int  ) ;
   u64 (*read_tsc)(void) ;
   u64 (*read_pmc)(int  ) ;
   unsigned long long (*read_tscp)(unsigned int * ) ;
   void (*irq_enable_sysexit)(void) ;
   void (*usergs_sysret64)(void) ;
   void (*usergs_sysret32)(void) ;
   void (*iret)(void) ;
   void (*swapgs)(void) ;
   void (*start_context_switch)(struct task_struct * ) ;
   void (*end_context_switch)(struct task_struct * ) ;
};
#line 127 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2767_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2767_18 ldv_2767 ;
};
#line 210 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   u32 reserved1 ;
   u64 sp0 ;
   u64 sp1 ;
   u64 sp2 ;
   u64 reserved2 ;
   u64 ist[7U] ;
   u32 reserved3 ;
   u32 reserved4 ;
   u16 reserved5 ;
   u16 io_bitmap_base ;
};
#line 257 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[1025U] ;
   unsigned long stack[64U] ;
};
#line 298 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5125_23 {
   u64 rip ;
   u64 rdp ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5131_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5132_22 {
   struct __anonstruct_ldv_5125_23 ldv_5125 ;
   struct __anonstruct_ldv_5131_24 ldv_5131 ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5141_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5132_22 ldv_5132 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5141_25 ldv_5141 ;
};
#line 350 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 371 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 376 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 382 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 388 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 396 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 444
struct perf_event;
#line 445 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 574 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_5960_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_5961_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5960_29 ldv_5960 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_5961_28 ldv_5961 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 15 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 398 "include/linux/gfp.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 648 "include/linux/module.h"
struct rb_augment_callbacks {
   void (*propagate)(struct rb_node * , struct rb_node * ) ;
   void (*copy)(struct rb_node * , struct rb_node * ) ;
   void (*rotate)(struct rb_node * , struct rb_node * ) ;
};
#line 42 "include/uapi/linux/random.h"
struct rnd_state {
   __u32 s1 ;
   __u32 s2 ;
   __u32 s3 ;
};
#line 74 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/archrandom.h"
struct test_node {
   struct rb_node rb ;
   u32 key ;
   u32 val ;
   u32 augmented ;
};
#line 1 "<compiler builtins>"
long ldv__builtin_expect(long exp , long c ) ;
#line 119 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 354 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
extern struct pv_cpu_ops pv_cpu_ops ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 177 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
__inline static u64 paravirt_read_tsc(void) 
{ 
  u64 __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 179
  __edi = __edi;
#line 179
  __esi = __esi;
#line 179
  __edx = __edx;
#line 179
  __ecx = __ecx;
#line 179
  __eax = __eax;
#line 179
  tmp = ldv__builtin_expect((unsigned long )pv_cpu_ops.read_tsc == (unsigned long )((u64 (*)(void))0),
                         0L);
#line 179
  if (tmp != 0L) {
#line 179
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (179), "i" (12UL));
    ldv_3911: ;
#line 179
    goto ldv_3911;
  } else {

  }
#line 179
  __asm__  volatile   ("771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n": "=D" (__edi),
                       "=S" (__esi), "=d" (__edx), "=c" (__ecx), "=a" (__eax): [paravirt_typenum] "i" (35UL),
                       [paravirt_opptr] "i" (& pv_cpu_ops.read_tsc), [paravirt_clobber] "i" (511): "memory",
                       "cc", "r8", "r9", "r10", "r11");
#line 179
  __ret = (unsigned long long )__eax;
#line 179
  return (__ret);
}
}
#line 17 "include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ 


  {
#line 19
  *remainder = (u32 )(dividend % (u64 )divisor);
#line 20
  return (dividend / (u64 )divisor);
}
}
#line 82 "include/linux/math64.h"
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ 
  u32 remainder ;
  u64 tmp ;

  {
#line 85
  tmp = div_u64_rem(dividend, divisor, & remainder);
#line 85
  return (tmp);
}
}
#line 169 "include/linux/mutex.h"
extern void mutex_unlock(struct mutex * ) ;
#line 172
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 7 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 10
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 15
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 19
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 22 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/tsc.h"
__inline static cycles_t get_cycles(void) 
{ 
  unsigned long long ret ;

  {
#line 24
  ret = 0ULL;
#line 30
  ret = paravirt_read_tsc();
#line 32
  return (ret);
}
}
#line 61 "include/linux/rbtree.h"
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
#line 62
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
#line 66
extern struct rb_node *rb_next(struct rb_node  const  * ) ;
#line 68
extern struct rb_node *rb_first(struct rb_root  const  * ) ;
#line 75 "include/linux/rbtree.h"
__inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
                                  struct rb_node **rb_link ) 
{ 
  struct rb_node *tmp ;

  {
#line 78
  node->__rb_parent_color = (unsigned long )parent;
#line 79
  tmp = 0;
#line 79
  node->rb_right = tmp;
#line 79
  node->rb_left = tmp;
#line 81
  *rb_link = node;
#line 82
  return;
}
}
#line 44 "include/linux/rbtree_augmented.h"
extern void __rb_insert_augmented(struct rb_node * , struct rb_root * , void (*)(struct rb_node * ,
                                                                                 struct rb_node * ) ) ;
#line 47 "include/linux/rbtree_augmented.h"
__inline static void rb_insert_augmented(struct rb_node *node , struct rb_root *root___0 ,
                                         struct rb_augment_callbacks  const  *augment ) 
{ 


  {
#line 50
  __rb_insert_augmented(node, root___0, augment->rotate);
#line 51
  return;
}
}
#line 99 "include/linux/rbtree_augmented.h"
__inline static void rb_set_parent(struct rb_node *rb , struct rb_node *p ) 
{ 


  {
#line 101
  rb->__rb_parent_color = (rb->__rb_parent_color & 1UL) | (unsigned long )p;
#line 102
  return;
}
}
#line 104 "include/linux/rbtree_augmented.h"
__inline static void rb_set_parent_color(struct rb_node *rb , struct rb_node *p ,
                                         int color ) 
{ 


  {
#line 107
  rb->__rb_parent_color = (unsigned long )color | (unsigned long )p;
#line 108
  return;
}
}
#line 111 "include/linux/rbtree_augmented.h"
__inline static void __rb_change_child(struct rb_node *old , struct rb_node *new ,
                                       struct rb_node *parent , struct rb_root *root___0 ) 
{ 


  {
#line 114
  if ((unsigned long )parent != (unsigned long )((struct rb_node *)0)) {
#line 115
    if ((unsigned long )parent->rb_left == (unsigned long )old) {
#line 116
      parent->rb_left = new;
    } else {
#line 118
      parent->rb_right = new;
    }
  } else {
#line 120
    root___0->rb_node = new;
  }
#line 121
  return;
}
}
#line 123
extern void __rb_erase_color(struct rb_node * , struct rb_root * , void (*)(struct rb_node * ,
                                                                            struct rb_node * ) ) ;
#line 127 "include/linux/rbtree_augmented.h"
__inline static void rb_erase_augmented(struct rb_node *node , struct rb_root *root___0 ,
                                        struct rb_augment_callbacks  const  *augment ) 
{ 
  struct rb_node *child ;
  struct rb_node *tmp ;
  struct rb_node *parent ;
  struct rb_node *rebalance ;
  unsigned long pc ;
  struct rb_node *successor ;
  struct rb_node *child2 ;
  unsigned long pc2 ;

  {
#line 130
  child = node->rb_right;
#line 130
  tmp = node->rb_left;
#line 134
  if ((unsigned long )tmp == (unsigned long )((struct rb_node *)0)) {
#line 142
    pc = node->__rb_parent_color;
#line 143
    parent = (struct rb_node *)(pc & 0xfffffffffffffffcUL);
#line 144
    __rb_change_child(node, child, parent, root___0);
#line 145
    if ((unsigned long )child != (unsigned long )((struct rb_node *)0)) {
#line 146
      child->__rb_parent_color = pc;
#line 147
      rebalance = 0;
    } else {
#line 149
      rebalance = (int )pc & 1 ? parent : 0;
    }
#line 150
    tmp = parent;
  } else
#line 151
  if ((unsigned long )child == (unsigned long )((struct rb_node *)0)) {
#line 153
    pc = node->__rb_parent_color;
#line 153
    tmp->__rb_parent_color = pc;
#line 154
    parent = (struct rb_node *)(pc & 0xfffffffffffffffcUL);
#line 155
    __rb_change_child(node, tmp, parent, root___0);
#line 156
    rebalance = 0;
#line 157
    tmp = parent;
  } else {
#line 159
    successor = child;
#line 160
    tmp = child->rb_left;
#line 161
    if ((unsigned long )tmp == (unsigned long )((struct rb_node *)0)) {
#line 171
      parent = successor;
#line 172
      child2 = successor->rb_right;
#line 173
      (*(augment->copy))(node, successor);
    } else {
      ldv_14297: 
#line 190
      parent = successor;
#line 191
      successor = tmp;
#line 192
      tmp = tmp->rb_left;
#line 193
      if ((unsigned long )tmp != (unsigned long )((struct rb_node *)0)) {
#line 194
        goto ldv_14297;
      } else {

      }
#line 194
      child2 = successor->rb_right;
#line 194
      parent->rb_left = child2;
#line 195
      successor->rb_right = child;
#line 196
      rb_set_parent(child, successor);
#line 197
      (*(augment->copy))(node, successor);
#line 198
      (*(augment->propagate))(parent, successor);
    }
#line 201
    tmp = node->rb_left;
#line 201
    successor->rb_left = tmp;
#line 202
    rb_set_parent(tmp, successor);
#line 204
    pc = node->__rb_parent_color;
#line 205
    tmp = (struct rb_node *)(pc & 0xfffffffffffffffcUL);
#line 206
    __rb_change_child(node, successor, tmp, root___0);
#line 207
    if ((unsigned long )child2 != (unsigned long )((struct rb_node *)0)) {
#line 208
      successor->__rb_parent_color = pc;
#line 209
      rb_set_parent_color(child2, parent, 1);
#line 210
      rebalance = 0;
    } else {
#line 212
      pc2 = successor->__rb_parent_color;
#line 213
      successor->__rb_parent_color = pc;
#line 214
      rebalance = (int )pc2 & 1 ? parent : 0;
    }
#line 216
    tmp = successor;
  }
#line 219
  (*(augment->propagate))(tmp, 0);
#line 220
  if ((unsigned long )rebalance != (unsigned long )((struct rb_node *)0)) {
#line 221
    __rb_erase_color(rebalance, root___0, augment->rotate);
  } else {

  }
#line 222
  return;
}
}
#line 39 "include/linux/random.h"
extern u32 prandom_u32_state(struct rnd_state * ) ;
#line 45 "include/linux/random.h"
__inline static u32 __seed(u32 x , u32 m ) 
{ 


  {
#line 47
  return (x < m ? x + m : x);
}
}
#line 55 "include/linux/random.h"
__inline static void prandom_seed_state(struct rnd_state *state , u64 seed ) 
{ 
  u32 i ;

  {
#line 57
  i = ((u32 )(seed >> 32) ^ ((u32 )seed << 10U)) ^ (u32 )seed;
#line 59
  state->s1 = __seed(i, 1U);
#line 60
  state->s2 = __seed(i, 7U);
#line 61
  state->s3 = __seed(i, 15U);
#line 62
  return;
}
}
#line 35 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static struct rb_root root  =    {0};
#line 36 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static struct test_node nodes[100U]  ;
#line 38 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static struct rnd_state rnd  ;
#line 40 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static void insert(struct test_node *node , struct rb_root *root___0 ) 
{ 
  struct rb_node **new ;
  struct rb_node *parent ;
  u32 key ;
  struct rb_node  const  *__mptr ;

  {
#line 42
  new = & root___0->rb_node;
#line 42
  parent = 0;
#line 43
  key = node->key;
#line 45
  goto ldv_14389;
  ldv_14388: 
#line 46
  parent = *new;
#line 47
  __mptr = (struct rb_node  const  *)parent;
#line 47
  if (((struct test_node *)__mptr)->key > key) {
#line 48
    new = & parent->rb_left;
  } else {
#line 50
    new = & parent->rb_right;
  }
  ldv_14389: ;
#line 45
  if ((unsigned long )*new != (unsigned long )((struct rb_node *)0)) {
#line 46
    goto ldv_14388;
  } else {

  }
#line 53
  rb_link_node(& node->rb, parent, new);
#line 54
  rb_insert_color(& node->rb, root___0);
#line 55
  return;
}
}
#line 57 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
__inline static void erase(struct test_node *node , struct rb_root *root___0 ) 
{ 


  {
#line 59
  rb_erase(& node->rb, root___0);
#line 60
  return;
}
}
#line 62 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
__inline static u32 augment_recompute(struct test_node *node ) 
{ 
  u32 max ;
  u32 child_augmented ;
  struct rb_node  const  *__mptr ;
  struct rb_node  const  *__mptr___0 ;

  {
#line 64
  max = node->val;
#line 65
  if ((unsigned long )node->rb.rb_left != (unsigned long )((struct rb_node *)0)) {
#line 66
    __mptr = (struct rb_node  const  *)node->rb.rb_left;
#line 66
    child_augmented = ((struct test_node *)__mptr)->augmented;
#line 68
    if (max < child_augmented) {
#line 69
      max = child_augmented;
    } else {

    }
  } else {

  }
#line 71
  if ((unsigned long )node->rb.rb_right != (unsigned long )((struct rb_node *)0)) {
#line 72
    __mptr___0 = (struct rb_node  const  *)node->rb.rb_right;
#line 72
    child_augmented = ((struct test_node *)__mptr___0)->augmented;
#line 74
    if (max < child_augmented) {
#line 75
      max = child_augmented;
    } else {

    }
  } else {

  }
#line 77
  return (max);
}
}
#line 81 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
__inline static void augment_callbacks_propagate(struct rb_node *rb , struct rb_node *stop ) 
{ 
  struct test_node *node ;
  struct rb_node  const  *__mptr ;
  u32 augmented ;
  u32 tmp ;

  {
#line 80
  goto ldv_14414;
  ldv_14413: 
#line 80
  __mptr = (struct rb_node  const  *)rb;
#line 80
  node = (struct test_node *)__mptr;
#line 80
  tmp = augment_recompute(node);
#line 80
  augmented = tmp;
#line 80
  if (node->augmented == augmented) {
#line 80
    goto ldv_14412;
  } else {

  }
#line 80
  node->augmented = augmented;
#line 80
  rb = (struct rb_node *)(node->rb.__rb_parent_color & 0xfffffffffffffffcUL);
  ldv_14414: ;
#line 80
  if ((unsigned long )rb != (unsigned long )stop) {
#line 81
    goto ldv_14413;
  } else {

  }
  ldv_14412: ;
#line 85
  return;
}
}
#line 81 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
__inline static void augment_callbacks_copy(struct rb_node *rb_old , struct rb_node *rb_new ) 
{ 
  struct test_node *old ;
  struct rb_node  const  *__mptr ;
  struct test_node *new ;
  struct rb_node  const  *__mptr___0 ;

  {
#line 80
  __mptr = (struct rb_node  const  *)rb_old;
#line 80
  old = (struct test_node *)__mptr;
#line 80
  __mptr___0 = (struct rb_node  const  *)rb_new;
#line 80
  new = (struct test_node *)__mptr___0;
#line 80
  new->augmented = old->augmented;
#line 81
  return;
}
}
#line 81 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static void augment_callbacks_rotate(struct rb_node *rb_old , struct rb_node *rb_new ) 
{ 
  struct test_node *old ;
  struct rb_node  const  *__mptr ;
  struct test_node *new ;
  struct rb_node  const  *__mptr___0 ;

  {
#line 80
  __mptr = (struct rb_node  const  *)rb_old;
#line 80
  old = (struct test_node *)__mptr;
#line 80
  __mptr___0 = (struct rb_node  const  *)rb_new;
#line 80
  new = (struct test_node *)__mptr___0;
#line 80
  new->augmented = old->augmented;
#line 80
  old->augmented = augment_recompute(old);
#line 81
  return;
}
}
#line 80 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static struct rb_augment_callbacks  const  augment_callbacks  =    {& augment_callbacks_propagate, & augment_callbacks_copy, & augment_callbacks_rotate};
#line 83 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static void insert_augmented(struct test_node *node , struct rb_root *root___0 ) 
{ 
  struct rb_node **new ;
  struct rb_node *rb_parent ;
  u32 key ;
  u32 val ;
  struct test_node *parent ;
  struct rb_node  const  *__mptr ;

  {
#line 85
  new = & root___0->rb_node;
#line 85
  rb_parent = 0;
#line 86
  key = node->key;
#line 87
  val = node->val;
#line 90
  goto ldv_14448;
  ldv_14447: 
#line 91
  rb_parent = *new;
#line 92
  __mptr = (struct rb_node  const  *)rb_parent;
#line 92
  parent = (struct test_node *)__mptr;
#line 93
  if (parent->augmented < val) {
#line 94
    parent->augmented = val;
  } else {

  }
#line 95
  if (parent->key > key) {
#line 96
    new = & parent->rb.rb_left;
  } else {
#line 98
    new = & parent->rb.rb_right;
  }
  ldv_14448: ;
#line 90
  if ((unsigned long )*new != (unsigned long )((struct rb_node *)0)) {
#line 91
    goto ldv_14447;
  } else {

  }
#line 101
  node->augmented = val;
#line 102
  rb_link_node(& node->rb, rb_parent, new);
#line 103
  rb_insert_augmented(& node->rb, root___0, & augment_callbacks);
#line 104
  return;
}
}
#line 106 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static void erase_augmented(struct test_node *node , struct rb_root *root___0 ) 
{ 


  {
#line 108
  rb_erase_augmented(& node->rb, root___0, & augment_callbacks);
#line 109
  return;
}
}
#line 111 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static void init(void) 
{ 
  int i ;

  {
#line 114
  i = 0;
#line 114
  goto ldv_14459;
  ldv_14458: 
#line 115
  nodes[i].key = prandom_u32_state(& rnd);
#line 116
  nodes[i].val = prandom_u32_state(& rnd);
#line 114
  i = i + 1;
  ldv_14459: ;
#line 114
  if (i <= 99) {
#line 115
    goto ldv_14458;
  } else {

  }

#line 119
  return;
}
}
#line 120 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static bool is_red(struct rb_node *rb ) 
{ 


  {
#line 122
  return ((rb->__rb_parent_color & 1UL) == 0UL);
}
}
#line 125 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static int black_path_count(struct rb_node *rb ) 
{ 
  int count ;
  bool tmp ;
  int tmp___0 ;

  {
#line 128
  count = 0;
#line 128
  goto ldv_14469;
  ldv_14468: 
#line 129
  tmp = is_red(rb);
#line 129
  if (tmp) {
#line 129
    tmp___0 = 0;
  } else {
#line 129
    tmp___0 = 1;
  }
#line 129
  count = tmp___0 + count;
#line 128
  rb = (struct rb_node *)(rb->__rb_parent_color & 0xfffffffffffffffcUL);
  ldv_14469: ;
#line 128
  if ((unsigned long )rb != (unsigned long )((struct rb_node *)0)) {
#line 129
    goto ldv_14468;
  } else {

  }

#line 130
  return (count);
}
}
#line 133 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static void check(int nr_nodes ) 
{ 
  struct rb_node *rb ;
  int count ;
  int blacks ;
  u32 prev_key ;
  struct test_node *node ;
  struct rb_node  const  *__mptr ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool __warned___0 ;
  int __ret_warn_once___0 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int __ret_warn_on___0 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  bool __warned___1 ;
  int __ret_warn_once___1 ;
  int tmp___8 ;
  int tmp___9 ;
  int __ret_warn_on___1 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  bool __warned___2 ;
  int __ret_warn_once___2 ;
  int __ret_warn_on___2 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;

  {
#line 136
  count = 0;
#line 137
  blacks = 0;
#line 138
  prev_key = 0U;
#line 140
  rb = rb_first((struct rb_root  const  *)(& root));
#line 140
  goto ldv_14497;
  ldv_14496: 
#line 141
  __mptr = (struct rb_node  const  *)rb;
#line 141
  node = (struct test_node *)__mptr;
#line 142
  __ret_warn_once = node->key < prev_key;
#line 142
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 142
  if (tmp___1 != 0L) {
#line 142
    __ret_warn_on = ! __warned;
#line 142
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 142
    if (tmp != 0L) {
#line 142
      warn_slowpath_null("/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared",
                         142);
    } else {

    }
#line 142
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 142
    if (tmp___0 != 0L) {
#line 142
      __warned = 1;
    } else {

    }
  } else {

  }
#line 142
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 143
  tmp___2 = is_red(rb);
#line 143
  if ((int )tmp___2) {
#line 143
    if ((rb->__rb_parent_color & 0xfffffffffffffffcUL) == 0UL) {
#line 143
      tmp___4 = 1;
    } else {
#line 143
      tmp___3 = is_red((struct rb_node *)(rb->__rb_parent_color & 0xfffffffffffffffcUL));
#line 143
      if ((int )tmp___3) {
#line 143
        tmp___4 = 1;
      } else {
#line 143
        tmp___4 = 0;
      }
    }
  } else {
#line 143
    tmp___4 = 0;
  }
#line 143
  __ret_warn_once___0 = tmp___4;
#line 143
  tmp___7 = ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
#line 143
  if (tmp___7 != 0L) {
#line 143
    __ret_warn_on___0 = ! __warned___0;
#line 143
    tmp___5 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 143
    if (tmp___5 != 0L) {
#line 143
      warn_slowpath_null("/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared",
                         144);
    } else {

    }
#line 143
    tmp___6 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 143
    if (tmp___6 != 0L) {
#line 143
      __warned___0 = 1;
    } else {

    }
  } else {

  }
#line 143
  ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
#line 145
  if (count == 0) {
#line 146
    blacks = black_path_count(rb);
  } else {
#line 148
    if ((unsigned long )rb->rb_left == (unsigned long )((struct rb_node *)0) || (unsigned long )rb->rb_right == (unsigned long )((struct rb_node *)0)) {
#line 148
      tmp___8 = black_path_count(rb);
#line 148
      if (tmp___8 != blacks) {
#line 148
        tmp___9 = 1;
      } else {
#line 148
        tmp___9 = 0;
      }
    } else {
#line 148
      tmp___9 = 0;
    }
#line 148
    __ret_warn_once___1 = tmp___9;
#line 148
    tmp___12 = ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
#line 148
    if (tmp___12 != 0L) {
#line 148
      __ret_warn_on___1 = ! __warned___1;
#line 148
      tmp___10 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 148
      if (tmp___10 != 0L) {
#line 148
        warn_slowpath_null("/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared",
                           149);
      } else {

      }
#line 148
      tmp___11 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 148
      if (tmp___11 != 0L) {
#line 148
        __warned___1 = 1;
      } else {

      }
    } else {

    }
#line 148
    ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
  }
#line 150
  prev_key = node->key;
#line 151
  count = count + 1;
#line 140
  rb = rb_next((struct rb_node  const  *)rb);
  ldv_14497: ;
#line 140
  if ((unsigned long )rb != (unsigned long )((struct rb_node *)0)) {
#line 141
    goto ldv_14496;
  } else {

  }
#line 153
  __ret_warn_once___2 = count != nr_nodes;
#line 153
  tmp___15 = ldv__builtin_expect(__ret_warn_once___2 != 0, 0L);
#line 153
  if (tmp___15 != 0L) {
#line 153
    __ret_warn_on___2 = ! __warned___2;
#line 153
    tmp___13 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
#line 153
    if (tmp___13 != 0L) {
#line 153
      warn_slowpath_null("/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared",
                         153);
    } else {

    }
#line 153
    tmp___14 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
#line 153
    if (tmp___14 != 0L) {
#line 153
      __warned___2 = 1;
    } else {

    }
  } else {

  }
#line 153
  ldv__builtin_expect(__ret_warn_once___2 != 0, 0L);
#line 155
  return;
}
}
#line 156 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static void check_augmented(int nr_nodes ) 
{ 
  struct rb_node *rb ;
  struct test_node *node ;
  struct rb_node  const  *__mptr ;
  bool __warned ;
  int __ret_warn_once ;
  u32 tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 160
  check(nr_nodes);
#line 161
  rb = rb_first((struct rb_root  const  *)(& root));
#line 161
  goto ldv_14517;
  ldv_14516: 
#line 162
  __mptr = (struct rb_node  const  *)rb;
#line 162
  node = (struct test_node *)__mptr;
#line 163
  tmp = augment_recompute(node);
#line 163
  __ret_warn_once = node->augmented != tmp;
#line 163
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 163
  if (tmp___2 != 0L) {
#line 163
    __ret_warn_on = ! __warned;
#line 163
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 163
    if (tmp___0 != 0L) {
#line 163
      warn_slowpath_null("/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared",
                         163);
    } else {

    }
#line 163
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 163
    if (tmp___1 != 0L) {
#line 163
      __warned = 1;
    } else {

    }
  } else {

  }
#line 163
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 161
  rb = rb_next((struct rb_node  const  *)rb);
  ldv_14517: ;
#line 161
  if ((unsigned long )rb != (unsigned long )((struct rb_node *)0)) {
#line 162
    goto ldv_14516;
  } else {

  }

#line 166
  return;
}
}
#line 167 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static int rbtree_test_init(void) 
{ 
  int i ;
  int j ;
  cycles_t time1 ;
  cycles_t time2 ;
  cycles_t time ;

  {
#line 172
  printk("\trbtree testing");
#line 174
  prandom_seed_state(& rnd, 3141592653589793238ULL);
#line 175
  init();
#line 177
  time1 = get_cycles();
#line 179
  i = 0;
#line 179
  goto ldv_14534;
  ldv_14533: 
#line 180
  j = 0;
#line 180
  goto ldv_14528;
  ldv_14527: 
#line 181
  insert((struct test_node *)(& nodes) + (unsigned long )j, & root);
#line 180
  j = j + 1;
  ldv_14528: ;
#line 180
  if (j <= 99) {
#line 181
    goto ldv_14527;
  } else {

  }
#line 182
  j = 0;
#line 182
  goto ldv_14531;
  ldv_14530: 
#line 183
  erase((struct test_node *)(& nodes) + (unsigned long )j, & root);
#line 182
  j = j + 1;
  ldv_14531: ;
#line 182
  if (j <= 99) {
#line 183
    goto ldv_14530;
  } else {

  }
#line 179
  i = i + 1;
  ldv_14534: ;
#line 179
  if (i <= 99999) {
#line 180
    goto ldv_14533;
  } else {

  }
#line 186
  time2 = get_cycles();
#line 187
  time = time2 - time1;
#line 189
  time = div_u64(time, 100000U);
#line 190
  printk(" -> %llu cycles\n", time);
#line 192
  i = 0;
#line 192
  goto ldv_14543;
  ldv_14542: 
#line 193
  init();
#line 194
  j = 0;
#line 194
  goto ldv_14537;
  ldv_14536: 
#line 195
  check(j);
#line 196
  insert((struct test_node *)(& nodes) + (unsigned long )j, & root);
#line 194
  j = j + 1;
  ldv_14537: ;
#line 194
  if (j <= 99) {
#line 195
    goto ldv_14536;
  } else {

  }
#line 198
  j = 0;
#line 198
  goto ldv_14540;
  ldv_14539: 
#line 199
  check(100 - j);
#line 200
  erase((struct test_node *)(& nodes) + (unsigned long )j, & root);
#line 198
  j = j + 1;
  ldv_14540: ;
#line 198
  if (j <= 99) {
#line 199
    goto ldv_14539;
  } else {

  }
#line 202
  check(0);
#line 192
  i = i + 1;
  ldv_14543: ;
#line 192
  if (i <= 99) {
#line 193
    goto ldv_14542;
  } else {

  }
#line 205
  printk("\taugmented rbtree testing");
#line 207
  init();
#line 209
  time1 = get_cycles();
#line 211
  i = 0;
#line 211
  goto ldv_14552;
  ldv_14551: 
#line 212
  j = 0;
#line 212
  goto ldv_14546;
  ldv_14545: 
#line 213
  insert_augmented((struct test_node *)(& nodes) + (unsigned long )j, & root);
#line 212
  j = j + 1;
  ldv_14546: ;
#line 212
  if (j <= 99) {
#line 213
    goto ldv_14545;
  } else {

  }
#line 214
  j = 0;
#line 214
  goto ldv_14549;
  ldv_14548: 
#line 215
  erase_augmented((struct test_node *)(& nodes) + (unsigned long )j, & root);
#line 214
  j = j + 1;
  ldv_14549: ;
#line 214
  if (j <= 99) {
#line 215
    goto ldv_14548;
  } else {

  }
#line 211
  i = i + 1;
  ldv_14552: ;
#line 211
  if (i <= 99999) {
#line 212
    goto ldv_14551;
  } else {

  }
#line 218
  time2 = get_cycles();
#line 219
  time = time2 - time1;
#line 221
  time = div_u64(time, 100000U);
#line 222
  printk(" -> %llu cycles\n", time);
#line 224
  i = 0;
#line 224
  goto ldv_14561;
  ldv_14560: 
#line 225
  init();
#line 226
  j = 0;
#line 226
  goto ldv_14555;
  ldv_14554: 
#line 227
  check_augmented(j);
#line 228
  insert_augmented((struct test_node *)(& nodes) + (unsigned long )j, & root);
#line 226
  j = j + 1;
  ldv_14555: ;
#line 226
  if (j <= 99) {
#line 227
    goto ldv_14554;
  } else {

  }
#line 230
  j = 0;
#line 230
  goto ldv_14558;
  ldv_14557: 
#line 231
  check_augmented(100 - j);
#line 232
  erase_augmented((struct test_node *)(& nodes) + (unsigned long )j, & root);
#line 230
  j = j + 1;
  ldv_14558: ;
#line 230
  if (j <= 99) {
#line 231
    goto ldv_14557;
  } else {

  }
#line 234
  check_augmented(0);
#line 224
  i = i + 1;
  ldv_14561: ;
#line 224
  if (i <= 99) {
#line 225
    goto ldv_14560;
  } else {

  }

#line 237
  return (-11);
}
}
#line 240 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
static void rbtree_test_exit(void) 
{ 


  {
#line 242
  printk("\ttest exit\n");
#line 243
  return;
}
}
#line 268
void ldv_check_final_state(void) ;
#line 277
void ldv_initialize(void) ;
#line 280
extern void ldv_handler_precall(void) ;
#line 283
extern int __VERIFIER_nondet_int(void) ;
#line 286 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
int LDV_IN_INTERRUPT  ;
#line 289 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
int main(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 301
  LDV_IN_INTERRUPT = 1;
#line 310
  ldv_initialize();
#line 320
  ldv_handler_precall();
#line 321
  tmp = rbtree_test_init();
#line 321
  if (tmp != 0) {
#line 322
    goto ldv_final;
  } else {

  }
#line 324
  goto ldv_14599;
  ldv_14598: 
#line 327
  tmp___0 = __VERIFIER_nondet_int();
#line 327
  switch (tmp___0) {
  default: ;
#line 329
  goto ldv_14597;
  }
  ldv_14597: ;
  ldv_14599: 
#line 324
  tmp___1 = __VERIFIER_nondet_int();
#line 324
  if (tmp___1 != 0) {
#line 325
    goto ldv_14598;
  } else {

  }

#line 345
  ldv_handler_precall();
#line 346
  rbtree_test_exit();
  ldv_final: 
#line 349
  ldv_check_final_state();
#line 352
  return 0;
}
}
#line 356 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 361
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 363
  mutex_lock(ldv_func_arg1);
#line 364
  return;
}
}
#line 366 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/lib/rbtree_test.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 371
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 373
  mutex_unlock(ldv_func_arg1);
#line 374
  return;
}
}
#line 10 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: __VERIFIER_error();
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 51
  return (exp);
}
}
#line 8 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 11 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_lock == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_lock = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_lock == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_lock = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_lock == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_lock = 2;
#line 69
  return;
}
}
#line 72 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_lock == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_lock = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_lock == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_lock = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_lock == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_lock == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_lock = 1;
#line 158
  return;
}
}
#line 162 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 


  {
#line 165
  ldv_mutex_lock = 1;
#line 166
  return;
}
}
#line 169 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--lib/rbtree_test.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 172
  if (ldv_mutex_lock == 1) {

  } else {
#line 172
    ldv_error();
  }
#line 173
  return;
}
}
